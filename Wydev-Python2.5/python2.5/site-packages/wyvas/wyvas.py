# -*- coding: utf-8 -*- 
#
# Description:
#
# Wyvas Widgets & Decorators Class Definitons
#
#
#
# Changes:
#
# 2012-01-02
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

from __future__ import with_statement

from _wyvas import WyvasObject, lock, unlock
from os import path, unlink
import urllib
import logging

log = logging.getLogger('wyvas')



class InternalUrl(object):

	def __init__(self, uri):
		self._uri = uri
		self._must_delete = 0
		self._file = ''
		return None

	def __del__(self):
		self.cleanup()
		return None

	def cleanup(self):
		if self._must_delete:
			self._must_delete = 0
			log.debug('Removing file %s' % self._file)
			try:
				unlink(self._file)
			except Exception, e:
				log.debug('Error removing file: %s' % str(e))
		return None

	def get_uri(self):
		return self._uri

	def get_file(self):
		return self._file

	def get_file_path(self):
		if self._uri.find('file://') == 0:
			fn = urllib.unquote(self._uri).replace('file://', '')
			log.debug('Fetching [%s] -> [%s] : Ok' % (self._uri, fn))
			return fn
		try:
			from wytransport import wtpython as wt
			wytransport_version = 2
		except ImportError:
			from wytransport import pywytransport as wt
			wytransport_version = 1
		if wytransport_version == 1:
			job = wt.wt_create_job(self._uri, None)
			wt.wt_set_transfer_mode(job, wt.WT_DLNA_INTERACTIVE)
			wt.wt_set_friendly_name(job, 'wyvas_image')
			res = wt.wt_start_job(job)
			self._file = wt.wt_get_filename(job)
			wt.wt_destroy_job(job)
			if res != wt.WT_COMPLETED:
				self._file = None
		else:
			self._file = wt.wt_do_download(self._uri, '/wymedia/tmp/tmpdest_XXXXXX')
		if self._file is None:
			log.debug('Fetching [%s] -> [%s] : Error' % (self._uri, self._file))
		else:
			log.debug('Fetching [%s] -> [%s] : Ok' % (self._uri, self._file))
			self._must_delete = 1
		return self._file



# Root class for all Wyvas objects.
#
# This class defines the default methods that may or should be
# overriden by other more specialized Wyvas objects such as
# L{Container}, L{Image}...
class Object(object):

	_end_callback = None
	animator_dict = dict(move=(1, 'move'), size=(2, 'resize'), scale=(2, 'resize'), color=(3, 'set_color'), opacity=(3, 'set_color'))
	step_type_dict = dict(linear=0, log=1, exp=2, samples=3, easeinout=3, easein=4, easeout=5, bounce=6)
	loop_type_dict = dict(none=0, redo=1, boom=2)
	percentage_arg_tuple = ('top', 'bottom', 'right', 'left', 'hcenter', 'vcenter', 'width', 'height')

	# This method must be overriden.
	def update(self, *args, **kw):
		print 'UPDATE ON OBJECT NOT IMPLEMENTING IT:',
		print self,
		print args,
		print kw
		return None

	# This method must be overriden.
	def initialize(self, *args, **kw):
		print 'INITIALIZE ON OBJECT NOT IMPLEMENTING IT:',
		print self,
		print args,
		print kw
		return None

	def __init__(self):
		self.obj = WyvasObject(0)
		self.parent = None
		self.name = 'obj'
		return None

	def _print_attributes(self):
		print '--------------------------'
		print 'OBJ CANVAS :',
		print self
		print 'parent     :',
		print self.parent
		print '------properties----------'
		print 'visibled   :',
		print self.get_visible()
		print 'pos        :',
		print self.get_pos()
		print 'size       :',
		print self.get_size()
		print 'layer      :',
		print self.get_layer()
		print 'color      :',
		print self.get_color()
		print '------internal------------'
		self.obj.debug()
		print '--------------------------'
		return None

	@staticmethod
	def _arg_str_per(val):
		if isinstance(val, str):
			if val.replace('-', '').isdigit():
				return (int(val), 0)
			else:
				if '%' in val:
					return (int(val.replace('%', '')), 1)
				else:
					raise ValueError, "Invalid relative value '%s'" % val
		return (int(val), 0)

	@staticmethod
	def _arg_color(r=None, g=None, b=None, a=None):
		return (((int(r), 1) if r is not None else (255, 0)),
						((int(g), 1) if g is not None else (255, 0)),
						((int(b), 1) if b is not None else (255, 0)),
						((int(a), 1) if a is not None else (255, 0)))

	# This method moves an object using the I{movement description} given by I{kw}.
	# 
	# A X{movement description} is a list of values (see below) that
	# can be either an integer or a string with percent (eg: "50%").
	# 
	# If the value is an integer, the value is the number of pixels
	# that the object should be moved (absolute move).
	# 
	# If the value is a string, the value is calulated by using the
	# parent object's size (relative move).
	# 
	# @param top: Distance between the top edge of the object and
	#     the top of the container.
	# @param bottom: Distance between the top edge of the object
	#     and the top of the container.
	# @param right: distance between the top edge of the object and
	#     the top of the container.
	# @param left: distance between the top edge of the object and
	#     the top of the container.
	# @param vcenter: distance between the center of the object and
	#     the upper left corner of the container, positive is rightward.
	# @param hcenter: Distance between the center of the object and
	#     the upper left corner of the container, positive is downward.
	def move(self, **kw):
		arg_str_per = Object._arg_str_per
		for k, v in kw.iteritems():
			kw[k] = arg_str_per(v)
		self.obj.move(**kw)
		return None

	# Redefine the color of the Object.
	# 
	# @param r: red canal [0..255]
	# @param b: blue canal [0..255]
	# @param g: green canal [0..255]
	# @param a: alpha canal [0..255]
	# @param color: tuple of everything -> (r,g,b,a)
	def set_color(self, r=None, g=None, b=None, a=None, color=None):
		if color is not None:
			r, g, b, a = color
		self.obj.set_color(color=Object._arg_color(r, g, b, a))
		return None

	# Return the parent object.
	def get_parent(self):
		return self.parent

	# This method detach the current object from its parent.
	# 
	# All underlying structures are freed by this method. So it must
	# be called when you're sure that you don't own object reference anymore.
	def unparent(self):
		if self.parent is not None:
			self.parent.remove_child(self)
			self.parent = None
		return None

	# This method attach the current object to X{parent}
	# 
	# It does the same thing as L{add_child} except it doesn't
	# accept position parameters.
	# 
	# @param parent: the object to attach to.
	def adopted(self, parent):
		self.parent = parent
		self.parent._children.append(self)
		self.obj.adopted(parent.obj)
		return None

	# This method detach the current object from its parent.
	# 
	# Unlike L{unparent} method, nothing is freed so you can still
	# use an orphaned object.
	def orphaned(self):
		if self.parent is not None:
			self.parent._children.remove(self)
			self.parent = None
			self.obj.orphaned()
		return None

	# Change the size of the object.
	# 
	# Value can be an absolute integer or a percentage (of the container size).
	# 
	# @param width: integer or percent string (eg: "40%")
	# @param height: integer or percent string
	# 
	# FIXME: args is used in pygui, looks like it's a dirty way to make things
	def resize(self, *args, **kw):
		arg_str_per = Object._arg_str_per
		for k, v in kw.iteritems():
			kw[k] = self._arg_str_per(v)
		self.obj.resize(*[arg_str_per(a) for a in args], **kw)
		return None

	# Returns the position of the upper left corner of the object.
	#
	# @return: a tuple (X position, Y position)
	def get_pos(self):
		return self.obj.get_pos()

	# Return the current size of the object.
	#
	# @return: integer tuple (Width, Height)
	def get_size(self):
		return self.obj.get_size()

	# Returns the color tuple of the object.
	#
	# @return: 4-integers tuple (r,g,b,a)
	def get_color(self):
		return self.obj.get_color()

	# Set the value of the alpha channel.
	#
	# Equivalent to set_color(a=<int>)
	#
	# @type opacity: integer
	# @param opacity: Opacity value.
	def set_opacity(self, opacity):
		self.set_color(a=opacity)
		return None

	# Returns the value of the alpha channel.
	#
	# @rtype: integer
	def get_opacity(self):
		return self.get_color()[3]

	# Set the name of the Object.
	#
	# @type name: string
	# @param name: The name.
	def set_name(self, name):
		self.name = name
		return None

	# Returns the name of the object.
	#
	# @rtype: string
	def get_name(self):
		return self.name

	# Sets the layer on which the Object has to be displayed.
	# 
	# The higher is the higher on the stack
	# 
	# @type layer: integer
	# @type absolute: boolean, default is 0
	def set_layer(self, layer, absolute=0):
		if absolute:
			self.obj.set_layer(abs_layer=layer)
		else:
			self.obj.set_layer(layer=layer)
		return None

	# Returns the layer where the object is displayed.
	# 
	# @type absolute: boolean, default is 0
	# @rtype: integer
	def get_layer(self, absolute=0):
		return self.obj.get_layer(absolute)

	# Makes the object visible.
	#
	# Equivalent to set_visible(1).
	def show(self):
		self.obj.show()
		return None

	# Makes the object invisible.
	#
	# Equivalent to set_visible(0).
	def hide(self):
		self.obj.hide()
		return None

	# Set if the object has to be visible or not.
	#
	# @param visible: 1 means make it visible, 0 means hide.
	def set_visible(self, visible):
		self.obj.set_visible(visible)
		return None

	# Get if the Object is visible.
	#
	# @return: 1 if if the object is visible, else 0.
	def get_visible(self):
		return self.obj.get_visible()

	# Sets if the aspect has to be preserved or not.
	#
	# @type preserve_aspect: integer
	def set_aspect(self, preserve_aspect=0):
		self.obj.set_aspect_preserve(preserve_aspect)
		return None

	def _invoke_end_callback(self):
		ec = self._end_callback
		if ec is not None:
			self._end_callback = None
			ec()
		return None

	# Stop the specified animation.
	# 
	# Currently the behaviour is different if L{type} parameter is
	# specified or not.
	# 
	# If L{type} specifies a type of animation then this specific
	# animation will be stop and the animated property will go to
	# its final state. The callback, if it was set during the call
	# to L{animate} method, will be called.
	# 
	# If L{type} is not passed then all animations will be stopped
	# but all animated states won't go to their final
	# states. Moreover the callback won't be called.
	# 
	# Before this method is returning, the global callback is
	# reset. This means that if an animation is processed and has an
	# associated callback, this callback won't be called if another
	# animation on an other property is stopped.
	# 
	# @type type: string
	# @param type: animated property to stop. Possible values are:
	#     - None (to stop all the animations)
	#     - move
	#     - size
	#     - scale
	#     - color
	#     - opacity
	#     - all
	def animate_stop(self, type=None):
		if type is None:
			type = 4
		else:
			type = self.animator_dict[type][0]
		self.obj.animate_stop(type)
		self._end_callback = None
		return None

	# Start an animation on an object property.
	# 
	# Different properties can be animated but this method can
	# animate only one property during a single call.
	# 
	# The properties are: the position, the size, the color...
	# 
	# You can also define the type of the animation by using the
	# L{step_type} parameter.
	# 
	# @type param: string
	# @param method: This describes the property to animate. The
	# possible values are:
	#     - move
	#     - size
	#     - scale
	#     - color
	#     - opacity
	# 
	# @type step_type: string
	# @param step_type: Possible values are: linear, log or exp
	# @type loop_type: string
	# @param loop_type: Possible values are: none, redo or boom
	# 
	# @type height: integer or percent string
	# @param height: If the object size is animated, this is the
	# final height the object will get.
	# @type width: integer or percent string
	# @param width: If the object size is animated, this is the
	# final width the object will get.
	# 
	# @type left: integer or percent string
	# 
	# @param left: Used if the object position is animated.
	# @type right: integer or percent string
	# @param right: Used if the object position is animated.
	# @type top: integer or percent string
	# @param top: Used if the object position is animated.
	# @type bottom: integer or percent string
	# @param bottom: Used if the object position is animated.
	# @type hcenter: integer or percent string
	# @param hcenter: Used if the object position is animated.
	# @type vcentert: integer or percent string
	# @param vcenter: Used if the object position is animated.
	# 
	# @type  r: integer
	# @param r: Used if the object color is animated.
	# @type  g: integer
	# @param g: Used if the object color is animated.
	# @type  b: integer
	# @param b: Used if the object color is animated.
	# @type  a: integer
	# @param a: Used if the object color is animated.
	# @type color: tuple
	# @param color: Used if the object color is animated.
	# 
	# @param duration: can be 0
	def animate(self, method, **kwargs):
		arg = {}
		kwargs_get = kwargs.get
		duration = kwargs_get('duration', 1) * 1000
		arg['duration'] = int(duration)
		arg['animator'], animator_call = self.animator_dict[method]
		arg['step_type'] = Object.step_type_dict[kwargs_get('step_type', 'linear')]
		arg['loop_type'] = Object.loop_type_dict[kwargs_get('loop_type', 'none')]
		arg_str_per = Object._arg_str_per
		for argname in Object.percentage_arg_tuple:
			val = kwargs_get(argname)
			if val is not None:
				arg[argname] = arg_str_per(val)
		color = kwargs_get('color')
		if color is not None:
			arg['color'] = Object._arg_color(*color)
		else:
			r = kwargs_get('r')
			g = kwargs_get('g')
			b = kwargs_get('b')
			a = kwargs_get('a')
			if a is None:
				a = kwargs_get('opacity')
			arg['color'] = Object._arg_color(r, g, b, a)
		if self._end_callback is not None:
			log.debug('WYVAS WARNING, end_callback overridden !! (%s)' % self._end_callback)
		self._end_callback = kwargs_get('end_callback')
		if duration != 0:
			if self._end_callback is not None:
				arg['end_callback'] = self._invoke_end_callback
			self.obj.animate(**arg)
		else:
			getattr(self.obj, animator_call)(**arg)
			self._invoke_end_callback()
		return None

	# Change the ratio of the object.
	# 
	# @type ratio: integer
	# @param ratio:
	#     - 1 = 4/3
	#     - 0 = 16/9
	def set_aspect_ratio(self, ratio=0):
		self.obj.set_aspect_ratio(ratio)
		return None

	# If keep_real_size is 1, the object will be drawn with its real size
	# Any changes from resize won't be forgotten though
	# 
	# @type keep_real_size: integer
	# @param keep_real_size: 0 or 1
	def set_keep_real_size(self, keep_real_size=0):
		self.obj.set_keep_real_size(keep_real_size)
		return None




# This class handles image object.
# 
# It's generic enough to display a lot of types of image such as:
# jpeg, png, giff...
# 
# It's based on imlib2 library.
class Image(Object):

	# @type  image_or_file: string
	# @param image_or_file: path to the sprite file
	# @type  repository: string
	# @param repository: path to the image repository directory
	# @type  size: tuple (integer, integer)
	# @type  url: string
	# @param url: url of the file, override image_or_file
	def __init__(self, image_or_file=None, repository=None, size=None, url=None):
		self.name = 'obj'
		self._repository = repository
		self._file = None
		self._url = None
		self._angle = 0
		if url is not None and isinstance(url, basestring):
			self._url = InternalUrl(url)
			image_or_file = self._url.get_file_path()
		arg = {}
		if isinstance(image_or_file, basestring) or image_or_file is None:
			if image_or_file is not None:
				self._file = image_or_file
				try:
					arg['filename'] = self._find_file(image_or_file)
				except NameError, e:
					log.debug(str(e))
					self._file = None
			self.obj = WyvasObject(1, **arg)
		else:
			if isinstance(image_or_file, buffer):
				data = image_or_file
				self.obj = WyvasObject(1, **arg)
				self.obj.set_data(data, size, False)
			else:
				raise TypeError('Images can be build from a string or a buffer only !!')
		self.parent = None
		return None

	def update(self, signal, sender, value, action=None, callback=None):
		if isinstance(value, basestring) and value[0] != '/' and '://' in value:
			self.load(url=value, callback=callback)
		else:
			self.load(value, callback=callback)
		return None

	initialize = update

	def set_border(self, left, right, top, bottom):
		self.obj.set_border(left, right, top, bottom)
		return None

	# Load an image from a file or url.
	# 
	# An empty string for file destroy the image; it's not considered as an error.
	# 
	# @type file: string, default is None
	# @type  url: string, default is None
	# @param url: override the file argument if not None.
	# terminated. It takes a boolean argument indicating if an error happened (True <==> error).
	def load(self, file=None, url=None, callback=None):
		if self._url is not None:
			self._url.cleanup()
			self._url = None
		if url is not None and isinstance(url, basestring):
			self._url = InternalUrl(url)
			file = self._url.get_file_path()
		if file != self._file:
			if file is None:
				self._file = ''
			else:
				try:
					self._file = self._find_file(file)
				except NameError:
					log.info("Can't find '%s' !", file)
					self._file = ''
		elif self._angle == 0:
			return None
		self._angle = 0
		self.obj.load(self._file, callback)
		return None

	# Rotates the image (clockwise), angle unit is PI/2
	# 
	# Negative values for angle are also accepted.
	# (-1 = 90 degrees counterclockwise)
	# 
	# NOTE: works by modifying the image data B{in place}.
	# 
	# @type  angle: integer
	# @param angle: the number of represent a number of PI/2 to
	# rotate the image.
	#     - 1 =  90 degrees
	#     - 2 = 180 degrees
	#     - 3 = 270 degrees.
	def rotate(self, angle=1):
		angle %= 4
		if angle:
			self.obj.rotate(angle)
			self._angle += angle
			self._angle %= 4
		return None

	def _find_file(self, filename):
		if path.exists(filename):
			return filename
		elif self._repository:
			fullpath = path.join(self._repository, filename)
			if path.exists(fullpath):
				return fullpath
		raise NameError('Unable to find file %s!' % filename)

	# Set a directory where we will search for the images.
	# 
	# The path will be prepended to the filename you are searching.
	# 
	# @type repository: string
	# @param repository: a directory path
	def set_repository(self, repository=None):
		self._repository = repository
		if self._file:
			self.load(self._file)
		return None

	def get_repository(self):
		return self._repository

	repository = property(get_repository, set_repository)




# A class to create text.
# 
# It's based on Evas Text object.
class Text(Object):

	# @type  text: string
	# @param text: text we want to see
	# @type  font: string
	# @param font: name of the font
	# @type  size: integer
	# @param size: size of the font
	# @type  color: tuple (int, int, int, int)
	# @param color: sets the r,g,b,a color through set_color(color=color)
	def __init__(self, text='', font='Vera', size=20, color=None):
		self.name = 'obj'
		arg = {}
		if text is not None:
			arg['text'] = text
		if font is not None:
			arg['font'] = font
		if size is not None:
			arg['font_size'] = size
		self.obj = WyvasObject(2, **arg)
		self.parent = None
		if color is not None:
			self.set_color(color=color)
		return None

	# Change the text value, equivalent to L{set_text}.
	def update(self, signal, sender, value, action=None):
		self.set_text(value)
		return None

	initialize = update

	# Change the font of the text.
	# 
	# @type font: string
	# @type size: integer
	def set_font(self, font=None, size=None):
		arg = {}
		if font is not None:
			arg['font'] = font
		if size is not None:
			arg['font_size'] = size
		self.obj.set_font(**arg)
		return None

	# Change the text.
	#
	# The color is a shortcut for set_color(color = color)
	def set_text(self, text, color=None):
		self.obj.set_text(text)
		if color is not None:
			self.set_color(*color)
		return None




# A class to create text block object.
# 
# It's based on Evas Text Block object.
class TextBlock(Text):

	def __init__(self, text='', font='Vera', size=20, color=None, replace_and_sign=True):
		self.name = 'obj'
		arg = {}
		if text is not None:
			if replace_and_sign:
				arg['text'] = text.replace('&', '&amp;')
			else:
				arg['text'] = text
		if font is not None:
			arg['font'] = font
		if size is not None:
			arg['font_size'] = size
		arg['textblock'] = 1
		self.obj = WyvasObject(7, **arg)
		self.parent = None
		return None

	def get_text_geometry(self):
		return self.obj.get_text_geometry()



# A class used to manage others Wyvas objects.
# 
# All objects attached to the container are subject to modification
# is the container itself is moved for example.
class Container(Object):

	def __init__(self):
		self.name = 'obj'
		self._children = []
		self.obj = WyvasObject(3)
		self.parent = None
		return None

	def _print_attributes(self):
		print '--------------------------'
		print '-------CONTAINER----------'
		print '--------------------------'
		print 'OBJ CANVAS :',
		print self
		print 'parent     :',
		print self.parent
		print '------properties----------'
		print 'visible    :',
		print self.get_visible()
		print 'pos        :',
		print self.get_pos()
		print 'size       :',
		print self.get_size()
		print 'layer      :',
		print self.get_layer()
		print 'color      :',
		print self.get_color()
		print '------internal------------'
		self.obj.debug()
		print '--------------------------'
		print '--------------------------'
		print '--------CHILD-------------'
		print '--------------------------'
		for child in self._children:
			child._print_attributes()
		print '--------------------------'
		print '-------END CONTAINER------'
		print '--------------------------'
		return None

	# Add an object into this container.
	# 
	# @type child: Object
	# @param child: The object to add
	# 
	# @param width: width size of the object
	# @param height: height size of the object
	# 
	# @param left: left position of the object
	# @param right: right position of the object
	# @param top: top position of the object
	# @param bottom: bottom position of the object
	# @param vcenter: vcenter position of the object
	# @param hcenter: hcenter position of the object
	# 
	# @param color: color tuple of the object (r,g,b,a)
	def add_child(self, child, **kwargs):
		if child in self._children:
			return None
		self._children.append(child)
		child.parent = self
		arg_str_per = Object._arg_str_per
		kwargs_get = kwargs.get
		for attr in Object.percentage_arg_tuple:
			val = kwargs_get(attr)
			if val is not None:
				kwargs[attr] = arg_str_per(val)
		color = kwargs_get('color')
		if color is not None:
			kwargs['color'] = Object._arg_color(*color)
		aspect = kwargs_get('aspect')
		if aspect is not None:
			kwargs['aspect'] = int(aspect == 'preserve')
		name = kwargs_get('name')
		if name is not None:
			child.name = name
		self.obj.add_child(child.obj, **kwargs)
		return child

	# Remove child object from the children list.
	# 
	# @raise ValueError: the child is not found
	def remove_child(self, child):
		if child not in self._children:
			raise ValueError, 'Child not found'
		self.obj.remove_child(child.obj)
		self._children.remove(child)
		child.parent = None
		return None

	# Clean the container from all its children.
	#
	# All the children are freed, therefore you should not keep any references of them.
	def wipe(self):
		self.obj.wipe()
		self._children = []
		return None

	# Return the first child with a matching name.
	# 
	# This check the containers recursively so the child may be a
	# grand-child
	# 
	# @type name: string
	# @param name: the name of the child to retrieve.
	# 
	# @return: None if no child matches
	def get_obj_by_name(self, name):
		for child in self._children:
			if child.get_name() == name:
				return child
			if isinstance(child, Container):
				result = child.get_obj_by_name(name)
				if result is not None:
					return result
		return None

	# Return a list off all children whose names match the parameter.
	# 
	# Equivalent to L{get_obj_by_name} but returns the list of B{all}
	# the matching children
	# 
	# @type name: string
	# @param name: the name of the children to retrieve
	# 
	# @return: if name is None, returns []
	def get_list_obj_by_name(self, name):
		result = []
		for child in self._children:
			if child and child.get_name() == name:
				result.append(child)
			elif isinstance(child, Container):
				result.extend(child.get_list_obj_by_name(name))
		return result

	def set_size(self, width=None, height=None):
		size = (width, height)
		if self.parent is not None:
			self.obj.resize_size(size)
		else:
			self.resize(size)
		return None



# A class which represents the screen.
# 
# You should create one instance of this object.
class Canvas(Container):

	# @type  size: tuple (width, height)
	# @param size: size of the canvas
	# @param type: ?
	# @param event: if 1 this canvas will generate events handled by a callback registered by L{register_event}
	# @param font_path: path to the fonts directory
	# @param fb_dev: The associated frame buffer
	# @param queue_size: number of events that the canvas will be able to remember.
	# @param key_repeat: ?
	# @param fps: refresh rate of the canvas
	def __init__(self, size, type=1, event=0, font_path='/usr/share/fonts', fb_dev=0, queue_size=5, key_repeat=2, fps=60):
		self.name = 'obj'
		self._children = []
		self.obj = WyvasObject(5, size=size, type=type, font_path=font_path, fb_dev=fb_dev, fps=fps)
		self._current_resolution = (size, type)
		self.parent = None
		self._callback = None
		self._event_compat = 0
		if event == 1:
			self._init_event(self._event_callback, queue_size, key_repeat)
		return None

	# Changes the resolution of the canvas.
	# 
	# @type size: tuple (width, height)
	# @type interlaced: integer, 1 or 0
	# @type frequency: integer
	def set_resolution(self, size, interlaced=0, frequency=60):
		self.obj.set_resolution(size=size, interlaced=interlaced, frequency=frequency)
		self._current_resolution = (size, interlaced)
		return None

	# Returns the canvas resolution.
	#
	# @return: tuple ((width, height), interlaced, fps)
	def get_resolution(self):
		return self._current_resolution

	def _init_event(self, callback, queue_size, key_repeat):
		arg = {}
		arg['callback'] = callback
		arg['queue_size'] = queue_size
		arg['key_repeat'] = key_repeat
		self.obj.init_event(**arg)
		return None

	def _event_callback(self, key, press, time):
		if self._callback != None:
			press = bool(press)
			if self._event_compat == 1:
				self._callback(key, press)
			else:
				self._callback(key, press, time)
		return None

	def register_event(self, callback):
		self._callback = callback
		return None

	def register_event_keyboard(self, callback):
		print 'UNSUPPORTED NOW'
		return None

	def register_event_remote(self, callback):
		print 'UNSUPPORTED NOW'
		print '->activate fallback'
		self._event_compat = 1
		self._callback = callback
		return None



class LCD(Container):

	def __init__(self, size=(160, 128), font_path='/usr/share/fonts', fb_dev=1, use_framebuffer=True):
		self.name = 'obj'
		self._children = []
		if use_framebuffer == True:
			self.obj = WyvasObject(5, size=size, type=0, font_path=font_path, fb_dev=fb_dev)
		else:
			self.obj = WyvasObject(5, size=size, type=1, font_path=font_path, fb_dev=fb_dev)
		self.parent = None
		return None




# A class to create rectangle object.
# 
# It's based Evas Rectangle Object.
class Rectangle(Object):

	def __init__(self, size=None, color=None):
		self.name = 'obj'
		arg = {}
		if size is not None:
			arg['width'] = (size[0], 0)
			arg['height'] = (size[1], 0)
		if color is not None:
			arg['color'] = Object._arg_color(*color)
		self.obj = WyvasObject(6, **arg)
		self.parent = None
		return None



# This class as L{Image} display image.
# 
# But unlike L{Image}, it's faster to display jpeg image because it
# uses the libjpeg in that case. Otherwise it uses the same method
# as L{Image}.
# 
# It can also load all type of image asynchronously.
class Viewer(Image):

	# @param image_or_file: path to the sprite file
	# @type image_or_file: string
	# @param repository: path to the image repository directory
	# @type repository: string
	# @type output_size: tuple (integer, integer) ?
	# @type use_hardware: integer: ?
	# @type url: string
	# @param url: url of the file, override image_or_file
	def __init__(self, image_or_file=None, repository=None, output_size=(1280, 720), use_hardware=0, url=None):
		self.name = 'obj'
		self.parent = None
		self._repository = repository
		self._file = None
		self._url = None
		self._angle = 0
		if url is not None and isinstance(url, basestring):
			self._url = InternalUrl(url)
			image_or_file = self._url.get_file_path()
		arg = {}
		if isinstance(image_or_file, basestring) or image_or_file is None:
			if image_or_file is not None:
				self._file = image_or_file
				arg['filename'] = self._find_file(image_or_file)
			arg['output_size'] = output_size
			arg['use_hardware'] = use_hardware
			self.obj = WyvasObject(8, **arg)
		else:
			raise TypeError('Images can be build from a string only !!')
		return None

	def set_output_size(self, output_size=(1280, 720)):
		self.obj.set_output_size(output_size)
		return None



class Wydget(Image):

	def __init__(self, wydget_name=None, size=(1280, 720)):
		self.name = 'obj'
		self.parent = None
		self.obj = WyvasObject(9, wydget_name=wydget_name, size=size)
		return None

	def send_data(self, motif, *data):
		self.obj.send_data(motif, *data)
		return None

	def update(self, signal, sender, value, action=None):
		print 'Not Yet implemented'
		return None



class Animage(Wydget):

	def __init__(self, size=None):
		if size is None:
			raise ValueError('Browser accept only valid url !')
		self.name = 'obj'
		self.parent = None
		self.obj = WyvasObject(9, wydget_name='animage', size=size)
		return None

	def update(self, signal, sender, value, action=None):
		sleep = value['sleep']
		filename = value['filename']
		self.send_data('si', filename, sleep)
		return None



class Browser(Wydget):

	def __init__(self, size=(1280, 720)):
		self.name = 'obj'
		self.parent = None
		self.obj = WyvasObject(9, wydget_name='pleyo', size=size)
		return None

	def update(self, signal, sender, value, action=None):
		if isinstance(value, basestring) and '://' in value:
			self.send_data('s', value)
		else:
			raise TypeError('Browser accept only valid url !')
		return None



class Webcam(Wydget):

	def __init__(self, size=(0, 0)):
		self.name = 'obj'
		self.parent = None
		self.obj = WyvasObject(9, wydget_name='webcam', size=size)
		return None



class _WyvasLock(object):

	__slots__ = []

	def __enter__(self):
		lock()
		return None

	def __exit__(self, type, value, tb):
		unlock()
		return None



render_lock = _WyvasLock()
