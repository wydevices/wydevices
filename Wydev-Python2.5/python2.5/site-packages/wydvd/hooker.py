# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definition
#
#
#
# Changes:
#
# 2012-03-23
# Initial Commit
#
#
# Copyright 2010-2014, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

__doc__ = 'Proxy objects for any library, that allow you to add hooks before or after\nmethods on a specific object.\n\n'
__version__ = '$Revision$'
__author__ = 'Martin Blais <blais@furius.ca>'

import types
from pprint import pformat

__all__ = ['HookProxy']



class ProxyMethodWrapper():
	
	# Wrapper object for a method to be called.
	def __init__(self, obj, func, name):
		self.obj, self.func, self.name = obj, func, name
		return None

	def __call__(self, *args, **kwds):
		return self.obj._method_call(self.name, self.func, *args, **kwds)



	# Proxy object that delegates methods and attributes that don't start with _.
	# You can derive from this and add appropriate hooks where needed.
	# Override _pre/_post to do something before/afer all method calls.
	# Override _pre_<name>/_post_<name> to hook before/after a specific call.
class HookProxy(object):

	def __init__(self, objname, obj):
		self._objname, self._obj = objname, obj
		return None

	# Return a proxy wrapper object if this is a method call.
	def __getattribute__(self, name):
		if name.startswith('_'):
			return object.__getattribute__(self, name)
		else:
			att = getattr(self._obj, name)
			if type(att) is types.MethodType:
				return ProxyMethodWrapper(self, att, name)
			else:
				return att

	# Delegate [] syntax.
	def __setitem__(self, key, value):
		name = '__setitem__'
		att = getattr(self._obj, name)
		pmeth = ProxyMethodWrapper(self, att, name)
		pmeth(key, value)
		return None

	# Returns a printable version of the call.
	# This can be used for tracing.
	def _call_str(self, name, *args, **kwds):
		pargs = [pformat(x) for x in args]
		for k, v in kwds.iteritems():
			pargs.append('%s=%s' % (k, pformat(v))
		return '%s.%s(%s)' % (self._objname, name, ', '.join(pargs))

	# This method gets called before a method is called.
	def _method_call(self, name, func, *args, **kwds):
		try:
			prefunc = getattr(self, '_pre')
		except AttributeError:
			pass
		else:
			prefunc(name, *args, **kwds)
		try:
			prefunc = getattr(self, '_pre_%s' % name)
		except AttributeError:
			pass
		else:
			prefunc(name, *args, **kwds)
		rval = func(*args, **kwds)
		try:
			postfunc = getattr(self, '_post_%s' % name)
		except AttributeError:
			pass
		else:
			postfunc(rval)
		try:
			postfunc = getattr(self, '_post')
		except AttributeError:
			pass
		else:
			kwds['rval_intercepted' = rval
			postfunc(name, *args, **kwds)
		return rval



def test():
	import sys
	class Foo():
		def foo(self, bli):
			print '       (running foo -> %s)' % bli
			return 42



	class To():
		def hello(self, bibi):
			print 'Hello BOB'



	class BabblingFoo(HookProxy):
		
		# Proxy for Foo.
		def _pre(self, name, *args, **kwds):
			print >> sys.stderr, 'LOG :: %s' % self._call_str(name, *args, **kwds)

		def _post(self, name, *args, **kwds):
			print 'after all'

		def _pre_foo(self, *args, **kwds):
			print 'before foo...'

		def _post_foo(self, *args, **kwds):
			print 'after foo...'



	class EtTo(HookProxy):
		
		# Proxy for To
		def _pre(self, name, *args, **kwds):
			print >> sys.stderr, 'LOG :: %s' % self._call_str(name, *args, **kwds)



	f = BabblingFoo('f', Foo())
	t = EtTo('t', To())
	print 'rval = %s' % f.foo(17)
	t.hello(345)
	try:
		f.nonexisting()
		raise RuntimeError
	except AttributeError:
		pass

if __name__ == '__main__':
	test()
