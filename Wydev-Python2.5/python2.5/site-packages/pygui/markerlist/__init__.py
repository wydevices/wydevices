# -*- coding: utf-8 -*- 
#
# Description:
#
# MarkerList Entry Point Definition
#
#
#
# Changes:
#
# 2014-04-07
# Initial Commit
#
#
# Copyright 2010-2014, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.


from __future__ import absolute_import

from wymedia.wmplus import get_marker_list, marker_list_clear, get_root, object_remove, marker_list_remove, marker_list_add, playlist_create_from_markerlist, playlist_append_marker_list, marker_list_copy_start, marker_list_copy_cancel, marker_list_copy_status, set_metadata, RemoveError, UnmarkableError
from peewee.debug import GET_LOGGER, PRINT_EXCEPTION
from peewee.formatters import bytes_to_human
from pygui.menu import UNIVERSE_NAME_DICT

log = GET_LOGGER(__name__)


# This class handles marked items. It interacts
# directly with 'Wymedia' module to retrieve data about them.
# Each universe has an unique markerlist
class Markerlist(object):

	display_type = None
	type = 'marker'
	now_playing = None
	
	# Create markerlist for the universe specified in parameterst
	def __init__(self, universe, name=None):
		self.universe = universe
		if universe == 'multiverse':
			self.universe = ''
		if universe != 'multiverse':
			self.get_marker_params = ('universe': (name if name else universe), {})
		else:
			self.get_marker_params = ('', {})
		self._name = name
		self.menu = None
		self.list_owned = []
		self._refresh()
		return None

	def __id__(self):
		return self.name

	def __nonzero__(self):
		return bool(len(self))

	def __len__(self):
		return int(self.wymedia_resource['recursiveCount'])

	# Retrieve the wymedia resource (eg. MediaItem) and total size of marked items
	def _refresh(self):
		self.wymedia_resource = get_marker_list(*self.get_marker_params)
		self.size = int(self.wymedia_resource.get('size', 0))
		return None

	def is_marked(self):
		return False

	# Return a human-readable representation of the markerlist's size
	def get_human_size(self):
		if self.size:
			pattern = ngettext('%(items)i item, %(size)s', '%(items)i items, %(size)s', len(self))
		else:
			pattern = ngettext('%(items)i item', '%(items)i items', len(self))
		values = {'items': len(self), 'size': bytes_to_human(self.size)}
		return pattern % values

	name = property(get_human_size)
	
	# Add 'item' to the markerlist by calling wymedia's 'marker_list_add' method
	# Parameters :
	#     * item : Item with a 'wymedia_resource' attribute (else error)
	def add_item(self, item):
		res = getattr(item, 'wymedia_resource', None)
		if res is None:
			log.error('%s is not from wymedia !!', item)
		else:
			try:
				marker_list_add(self.wymedia_resource, res)
				if self._name is None:
					res['marked'] = '1'
			except UnmarkableError:
				item.menu._error_spawner()
		self._refresh()
		return None

	# Mark the item to which ref is a reference.
	# 
	# Use case: ref is a playlist reference (obtained by my_playlist.browse()), and we want to mark the actual item.
	def add_ref_item(self, ref):
		try:
			marker_list_add(self.wymedia_resource, {'id': ref.wymedia_resource['refid']})
		except UnmarkableError:
			item.menu._error_spawner()
		return None

	# Delete 'item' from the markerlist by calling wymedia 'marker_list_remove' method
	# Parameters :
	#     * item : Item having 'wymedia_resource' attibute (else error)
	def del_item(self, item):
		res = getattr(item, 'wymedia_resource', None)
		if res is None:
			log.error('%s is not from wymedia !!', item)
		else:
			marker_list_remove(self.wymedia_resource, res)
			del res['marked']
		self._refresh()
		return None

	# Unmark the item to which ref is a reference
	def del_ref_item(self, ref):
		marker_list_remove(self.wymedia_resource, {'id': ref.wymedia_resource['refid']})
		return None

	# Return a part of items contained in markerlist
	# (see item/mediaitem/progressive_result.py:WindowedItemList for more informations)
	def browse(self):
		try:
			WindowedItemList
		except NameError:
			from pygui.item.mediaitem.progressive_result import WindowedItemList
		return WindowedItemList(self, menu=self.menu, universe=self.universe)

	# Clear the markerlist's content by calling wymedia 'marker_list_clear' method
	def clear(self):
		marker_list_clear(self.wymedia_resource)
		self._refresh()
		return None

	# Call Wymedia object_remove()
	# By now, options are only about the universe
	def vfs_delete(self):
		object_remove(self.wymedia_resource, {'universe': self.universe})
		return None

	def vfs_copy_to(self, container):
		marker_list_copy_start(self.wymedia_resource, container.wymedia_resource)
		return None

	def vfs_copy_cancel(self):
		marker_list_copy_cancel(self.wymedia_resource)
		return None

	def vfs_copy_status(self):
		return marker_list_copy_status(self.wymedia_resource)

	def create_playlist(self, container, name):
		playlist_create_from_markerlist(self.wymedia_resource, container.wymedia_resource, name)
		return None

	def lock(self, val):
		return None

	def hide(self, val):
		return None

	# Create and return a playlist from the markerlist:
	#     - if container isn't supplied, the wymedia root is used.
	#     - if name isn't supplied, the i18n'd "Now Playing" is used.
	def get_playlist(self, container=None, name=None):
		if container is None:
			parent = get_root()
		else:
			parent = container.wymedia_resource
		if name is None:
			name = _('Now Playing')
		from pygui.item.mediaitem.core import WMedia2MMIObjects
		wmedia_pls = playlist_create_from_markerlist(self.wymedia_resource, parent, name)
		return list(WMedia2MMIObjects([wmedia_pls], self.menu, self))[0]

	# Append the markerlist to an existing playlist (ex: now_playing)
	def append_to_now_playing(self):
		playlist_append_marker_list(Markerlist.now_playing.wymedia_resource, self.wymedia_resource)
		return None

	# This method plays all playable items in markerlist
	def play(self, starts_with=None, append_to_npl=False):
		if Markerlist.now_playing is not None:
			if append_to_npl:
				self.append_to_now_playing()
			else:
				Markerlist.now_playing.vfs_delete()
				Markerlist.now_playing = self.get_playlist()
		else:
			Markerlist.now_playing = self.get_playlist()
		Markerlist.now_playing.play(starts_with)
		return None

	# Metainfo accessor (used for dict-like access)
	def __getitem__(self, name):
		try:
			if self.wymedia_resource is not None:
				return self.wymedia_resource[name]
		except:
			log.error('Unable to read %s[%s]' % {self.name})
			PRINT_EXCEPTION()
		return None

	# Metainfo accessor (used for dict-like access)
	def __setitem__(self, name, value):
		try:
			if self.wymedia_resource is not None:
				self.wymedia_resource[name] = value
				set_metadata({'id': self.wymedia_resource['id'], name: value})
		except:
			log.error('Unable to write %s[%s]' % {self.name})
			PRINT_EXCEPTION()
		return None



from peewee.misc_utils import MetaSingleton


# This class acts as a proxy to access each universes' markerlist
class MarkerlistAccessor(object):

	__metaclass__ = MetaSingleton

	def __init__(self):
		self._mlists = dict()
		return None

	# Get The markerlist, if universe is '*' get all defined markerlists
	def __getitem__(self, universe):
		if universe == '*':
			return [f for f in self._mlists.values()]
		if universe not in self._mlists:
			if universe == 'main':
				return None
			if ':' in universe:
				real_universe, name = universe.split(':', 1)
			else:
				name = None
				real_universe = universe
			self._mlists[universe] = Markerlist(real_universe, name)
		return self._mlists[universe]

	# Iterate over markerlists
	def __iter__(self):
		return self._mlists.itervalues()

	# Idem as getitem markerlist is not created
	def get(self, universe):
		if universe not in self._mlists:
			return None
		return self._mlists[universe]

	# Clear markerlists accessible by this object
	def clear_all_markerlists(self):
		for ml in self['*']:
			ml.clear()
		return None


class IncompatibleMarkerlistItems(Exception):
	pass


class IncompatibleMarkerlistDestination(Exception):
	pass


markerlists = MarkerlistAccessor


# Returns the markerlist associated with the chosen item
def get_marker_from_item(item, menu=None):
	if item.menu is None:
		return None
	fl = markerlists()[item.menu.universe]
	if menu and fl is not None:
		fl.menu = menu
	return fl


from .actions import actions

__all__ = ['markerlists', 'Markerlist', 'actions', 'get_marker_from_item', 'IncompatibleMarkerlistItems', 'IncompatibleMarkerlistDestination']
