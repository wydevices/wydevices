# -*- coding: utf-8 -*- 
#
# Description:
#
# TV Items Class Definitions
#
#
#
# Changes:
#
# 2011-10-02
# Initial Commit
#
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.


from __future__ import absolute_import

from peewee.debug import GET_LOGGER
from peewee.misc_utils import MetaSingleton
from pygui.config import user_config, plugins
from pygui.facilities.codemapping import country_dict
from pygui.facilities.l10n import UnicodeDict
from pygui.item.containers import GenericContainer
from pygui.item.mediaitem.core import MediaItem, DirItem, RootItem, HiddenRoot, TV_FAVORITES_FOLDER, get_mmi_object, WMedia2MMIObjects
from pygui.item.mediaitem.progressive_result import WindowedItemList
from pygui.shared import pygui_globs
from wymedia.wmplus import get_root, browse_ng, container_search

if 'tv' in plugins:
	from wyrecord import WyRecord
	from wyrecord.recording import RECORDING_STATUS_UNKNOWN, RECORDING_STATUS_SCHEDULED, RECORDING_STATUS_RUNNING
	RECS_TO_DISPLAY = frozenset([RECORDING_STATUS_SCHEDULED, RECORDING_STATUS_RUNNING])

log = GET_LOGGER(__name__)



# Generic TV channel item.
class ChannelItem(MediaItem):

	player = None

	watch = (lambda self, observer : None)
	unwatch = (lambda self, observer : None)

	def __init__(self, wymedia_resource, type_='channel', **kw):
		service_id = int(wymedia_resource.get('serviceId', 0))
		live = WyRecord().live_manager._GetLiveFromServiceID(service_id)
		if live and live.isRecording():
			type_ += '_recording'
		MediaItem.__init__(self, wymedia_resource, type_=type_, **kw)
		if ChannelItem.player is None:
			try:
				from pygui.menu.players import TVPlayer
				from pygui.menu.players.core import wyplayer_instance
				ChannelItem.player = TVPlayer(player=wyplayer_instance(), type='tvplayer')
			except Exception, e:
				log.error('Unable to spawn TV player: %s', str(e))
		return None

	def _get_dt(self):
		return self.wymedia_resource['logical_channel_number']

	def _set_dt(self, dt):
		return None

	# Switch the TV player to this channel, and set the current
	# favorite while we're at it.
	def execute(self):
		self.player.play(item=self, favorite=self.parent)
		return None

	# scrape_database(start_time, end_time, limit) -> [wymedia resources]
  # 
	# Attempt to find EPG data in the Wymedia database for the
	# channel, between start_time and end_time.
  # 
	# At most limit results are returned.
  # 
	# Note that this method only returns wymedia resources (i.e. dicts),
	# not ProgramItems, and doesn't do any kind of filtering and/or
	# padding.
  # 
	# You are probably looking for L{browse} instead.
	def scrape_database(self, start_time, end_time, limit):
		options = {'universe': 'tv', 'serviceId': self.wymedia_resource['serviceId'], 'scheduledStartTime': str(int(start_time)), 'scheduledEndTime': str(int(end_time))}
		ret = browse_ng(get_root('epg'), 0, limit, ['+scheduledStartTime'], options)
		if not ret:
			return []
		return ret

	# Return at most limit (default: 10) EPGs for the channel between
	# start_time and end_time.
  # 
	# If not specified, start_time defaults to 0 and end_time to sys.maxint.
  # 
	# If pad=True, dummy program items are added so that the first
	# program starts at least at start_time, and the last program
	# ends at least at end_time.
  # 
	# If focus is specified (as a timestamp), it represents the user's center
	# of attention. In case there are more than limit programs between
	# start_time and end_time, browse() will try to ensure the programs
	# near focus aren't cut off and replaced by padding (implementation:
	# we request up to 50 EPGs, and return the limit first EPGs if
	# focus is before the average of start_time and end time, or the limit
	# last programs otherwise).
  # 
	# The language in which EPGs are requested follows
	# L{scrape_database}'s policy: OSD, then country, then anything.
	def browse(self, start_time=0, end_time=2147483640, limit=10, pad=False, focus=0, preview=False):
		raw_resources = self.scrape_database(start_time, end_time, 50 if focus else limit)
		if focus < (start_time + end_time) / 2:
			resources = raw_resources[:limit]
		else:
			resources = raw_resources[-limit:]
		if pad:
			my_id = self['id']
			if resources:
				min_time = int(resources[0]['scheduledStartTime'])
				max_time = int(resources[-1]['scheduledEndTime'])
				if start_time < min_time:
					new_prog = {'id': '%s%i' % (my_id, start_time), 'class': 'object.item.epgItem.dummy', 'title': _('EPG not available'), 'description': _('EPG not available'), 'language': 'unknown', 'scheduledStartTime': '%i' % start_time, 'scheduledEndTime': '%i' % min_time, 'rating': '0'}
					resources.insert(0, new_prog)
				if max_time < end_time:
					new_prog = {'id': '%s%i' % (my_id, max_time), 'class': 'object.item.epgItem.dummy', 'title': _('EPG not available'), 'description': _('EPG not available'), 'language': 'unknown', 'scheduledStartTime': '%i' % max_time, 'scheduledEndTime': '%i' % end_time, 'rating': '0'}
					resources.append(new_prog)
			else:
				new_prog = {'id': '%s%i' % (my_id, start_time), 'class': 'object.item.epgItem.dummy', 'title': _('EPG not available'), 'description': _('EPG not available'), 'language': 'unknown', 'scheduledStartTime': '%i' % start_time, 'scheduledEndTime': '%i' % end_time, 'rating': '0'}
				resources.append(new_prog)
		return list(WMedia2MMIObjects(resources, self.menu, self))



# Capture service (AUX, line in, etc.).
class CaptureChannelItem(ChannelItem):

	def __init__(self, wymedia_resource, type_='capture_channel', **kw):
		ChannelItem.__init__(self, wymedia_resource, type_, **kw)
		return None

	# Capture services never have EPGs
	def scrape_database(self, start_time, end_time, limit):
		return []



# EPG information for a single program.
class ProgramItem(MediaItem):

	EXTRA_INFO_FIELDS = [('videoFormat_16_9', _('16:9')), ('videoFormatHD', _('High definition')), ('nrAudioChannels', _('Multiple audio tracks')), ('nrSubtitleTracks', _('Subtitles')), ('subtitleHardOfHearing', _('Subtitles for hearing impaired')), ('audioHardOfHearing', _('Audio for hearing impaired')), ('audioVisuallyImpaired', _('Audio for visually impaired')), ('freeCaMode', _('Scrambled'))]
	_CONTENT_DESC_MAPPING = UnicodeDict({0: 'Undefined content', 16: 'Movie/Drama', 17: 'Detective/Thriller', 18: 'Adventure/Western/War', 19: 'Science fiction/Fantasy/Horror', 20: 'Comedy', 21: 'Soap/Melodrama/Folkloric', 22: 'Romance', 23: 'Serious/Classical/Religious/Historical movie/drama', 24: 'Adult movie/drama', 31: 'User defined', 32: 'News/Current affairs', 33: 'News/Weather report', 34: 'News magazine', 35: 'Documentary', 36: 'Discussion/Interview/Debate', 47: 'User defined', 48: 'Show/Game show', 49: 'Game show/Quiz/Contest', 50: 'Variety show', 51: 'Talk show', 63: 'User defined', 64: 'Sports', 65: 'Special Events (Olympic games, World cup...)', 66: 'Sports magazine', 67: 'Football/Soccer', 68: 'Tennis/Squash', 69: 'Team sports (other than football)', 70: 'Athletics', 71: 'Motor sports', 72: 'Water sports', 73: 'Winter sports', 74: 'Equestrian sports', 75: 'Martial arts', 79: 'User defined', 80: "Children's/Youth program", 81: "Pre-school children's program", 82: 'Entertainment program (6 to 14 years old)', 83: 'Entertainment program (10 to 16 years old)', 84: 'Informational/Educational/School program', 85: 'Cartoon/Puppet show', 95: 'User defined', 96: 'Music/Ballet/Dance', 97: 'Rock/Pop', 98: 'Serious/Classical music', 99: 'Folk/Traditional music', 100: 'Jazz', 101: 'Musical/Opera', 102: 'Ballet', 111: 'User defined', 112: 'Arts/Culture (other than music)', 113: 'Performing arts', 114: 'Fine arts', 115: 'Religion', 116: 'Popular culture/Traditional arts', 117: 'Literature', 118: 'Film/Cinema', 119: 'Experimental film/video', 120: 'Broadcasting/Press', 121: 'New media', 122: 'Arts/Culture magazine', 123: 'Fashion', 127: 'User defined', 128: 'Social/political issues/Economics', 129: 'Magazine/Report/Documentary', 130: 'Economics/Social advisory', 131: 'Remarkable people', 143: 'User defined', 144: 'Education/Science/Factual topic', 145: 'Nature/Animals/Environment', 146: 'Technology/Natural sciences', 147: 'Medicine/Physiology/Psychology', 148: 'Foreign countries/Expeditions', 149: 'Social/Spiritual sciences', 150: 'Further education', 151: 'Languages', 159: 'User defined', 160: 'Leisure hobby', 161: 'Tourism/Travel', 162: 'Handicraft', 163: 'Motoring', 164: 'Fitness and health', 165: 'Cooking', 166: 'Advertisement/Shopping', 167: 'Gardening', 175: 'User defined'})
	_SPECIAL_ATTRIBUTES_MAPPING = UnicodeDict({176: 'Original language', 177: 'Black and white', 178: 'Unpublished', 179: 'Live broadcast', 191: 'User defined', 255: 'User defined'})

	def __init__(self, wymedia_resource, type_='epg', **kw):
		self.id = wymedia_resource['id']
		if self.recording_status in RECS_TO_DISPLAY:
			type_ += '_recording'
		MediaItem.__init__(self, wymedia_resource, type_=type_, **kw)
		self.start_time = int(wymedia_resource['scheduledStartTime'])
		self.end_time = int(wymedia_resource['scheduledEndTime'])
		(self.duration, wymedia_resource['duration']) = (self.end_time - self.start_time, self.end_time - self.start_time)
		self.description = wymedia_resource.get('longDescription', '')
		self.short_description = wymedia_resource.get('description', '')
		desc_code = int(wymedia_resource.get('contentDesc', 0))
		self.content_type = self._CONTENT_DESC_MAPPING.get(desc_code, 'Undefined content')
		try:
			rating = int(wymedia_resource['maturityRating'])
		except KeyError:
			rating = int(wymedia_resource.get('rating', 0))
		if rating < 10:
			maturity_rating = 0
		elif rating == 10:
			maturity_rating = 10
		elif 10 < rating <= 12:
			maturity_rating = 12
		elif 12 < rating <= 16:
			maturity_rating = 16
		else:
			maturity_rating = 18
		self.wymedia_resource['maturityRating'] = maturity_rating
		return None

	def watch(self, observer):
		return None

	def unwatch(self, observer):
		return None

	# If this program has been scheduled for recording via the EPG
	# grid, recording_id holds the scheduled recording's Wyrecord ID.
	# Otherwise, it's 0 (well, wyrecord.recording.RECORDING_ID_NULL).
	@property
	def recording_id(self):
		return WyRecord().scheduler.GetRecordingIdFromProgramId(self.id)
	
	# If this program has been scheduled for recording via the EPG
	# grid, recording_status holds the scheduled recording's status
	# (one of the wyrecord.recording.RECORDING_STATUS_* constants).
	@property
	def recording_status(self):
		rec_id = self.recording_id
		if rec_id:
			return WyRecord().scheduler.GetRecording(rec_id).status
		return RECORDING_STATUS_UNKNOWN

	# Executing a ProgramItem will play the channel it's from
	# in the TV player. Better than raising an AttributeError, now,
	# don't you think?
	def execute(self):
		self.parent.execute()
		return None


# All Channels list. It's basically a read-only playlist with a minimal interface.
class AllChannelsList(DirItem):

	def __init__(self, wymedia_resource, menu):
		DirItem.__init__(self, wymedia_resource, type_='all_channels_list', menu=menu, parent=TVRootItem())
		return None

	# Given a service ID, return the corresponding ChannelItem
	def get_channel_from_service_id(self, service_id):
		res = container_search(self.wymedia_resource, 'serviceId', str(service_id))
		if not res:
			raise KeyError('AllChannelsList.get_channel_from_service_id: no such service ID', service_id)
		if len(res) > 1:
			log.warn('Wymedia knows more than 1 channel with that service ID.')
		return get_mmi_object(res[0], self.menu, self)

	@property
	def name(self):
		return _('Full Channel List')

	def browse(self, include_aux=True, preview=False):
		if include_aux:
			filter = None
		else:
			filter = {'class': 'object.item.videoItem.videoBroadcast'}
		return WindowedItemList(self, menu=self.menu, universe=self.universe, sort_order=['logical_channel_number'], filter=filter)



# The root container for TV recordings.
class RecordingsRootItem(DirItem):

	def __init__(self, menu):
		DirItem.__init__(self, get_root('recordings'), menu=menu, type_='video_dir')
		return None

	# We're faking the universe for this class because it can be called
	# from the TV universe too, and recordings belong to the video universe.
  # 
	# Yes, it's a hack.
	universe = property((lambda : 'video'))



class TVRootItem(MediaItem, GenericContainer):

	__metaclass__ = MetaSingleton

	def __init__(self, menu=None):
		RootItem()
		MediaItem.__init__(self, _('TV Universe'), type_='tv_root', menu=menu)
		return None

	# The source argument can be one of:
	# - "acl" (default): Return the all channels list.
	# - "favorites": Return all the favorites lists.
  # 
	# TODO: Maybe it's be a good idea to do away with "acl" and return
	# the ACL as the first (last?) favorite (since we have get_acl() anyway).
	def browse(self, source='acl', menu=None, preview=False):
		dispatch = {'acl': self.browse_acl, 'favorites': self.browse_favorites, 'recordings': self.browse_recordings}
		return dispatch[source](menu if menu else self.menu)

	# This class is a singleton, so it technically has no menu.
	# show_menu therefore just goes back one menu (for all the hand-related stuff).
	def show_menu(self):
		pygui_globs['menustack'].back_one_menu()
		return None

	# Return the all channels list.
	def get_acl(self, menu=None):
		res = get_root('channel')
		res['title'] = u'all_channels_list'
		return AllChannelsList(res, menu if menu else self.menu)

	# Return the all channels list.
	def browse_acl(self, menu=None):
		return [self.get_acl(menu)]

	# Return the TV favorites.
	def get_favorites_root(self, menu=None):
		return HiddenRoot().get_child(TV_FAVORITES_FOLDER, menu)

	# Return the TV favorites.
	def browse_favorites(self, menu=None):
		return self.get_favorites_root(menu).browse()

	def get_recordings(self, menu=None):
		return RecordingsRootItem(menu if menu else self.menu)

	def browse_recordings(self, menu=None):
		return self.get_recordings(menu).browse()
