# -*- coding: utf-8 -*- 
#
# Description:
#
# Dilbert MediaItems Class Definition
#
#
#
# Changes:
#
# 2014-04-03
# Initial Commit
#
#
# Copyright 2010-2014, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.


from __future__ import absolute_import
from item.containers import GenericContainer
from item.mediaitem.core import ImageItem, AudioItem, VideoItem
import urllib
from peewee.cache_utils import cache_result
from peewee.misc_utils import MetaSingleton
from peewee.debug import GET_LOGGER

log = GET_LOGGER(__name__)


class DilbertYearFolder(GenericContainer):

	def __init__(self, year, type_='dir', **kw):
		GenericContainer.__init__(self, str(year), type_=type_, **kw)
		self.year = year
		return None

	def browse(self, preview=False):
		img_list = [ImageItem('%02d/%d' % {m, d}, uri='http://people.csail.mit.edu/adonovan/dilbert/dilbert-%02d-%02d-%d.gif' % {m, d, self.year}) for m in xrange(1, 13) for d in xrange(1, 30)]
		for i in img_list:
			i.parent = self
			i.menu = self.menu
		return img_list



class DilbertFolder(GenericContainer):

	def __init__(self):
		GenericContainer.__init__(self, 'Dilbert comics', type_='dir')
		return None

	@cache_result(600)
	def browse(self, preview=False):
		fd_list = [DilbertYearFolder(y) for y in xrange(1997, 2014)]
		for i in fd_list:
			i.parent = self
			i.menu = self.menu
		return fd_list


class MLCFolder(GenericContainer):

	__metaclass__ = MetaSingleton
	max_idx = 290
	base_uri = 'http://monsieur-le-chien.fr/'
	uri = base_uri + 'index.php?planche='

	def __init__(self, **kw):
		GenericContainer.__init__(self, 'Monsieur le chien', type_='dir', **kw)
		return None

	def _num2jpg(self, num):
		real_uri = self.uri + str(num)
		web = urllib.urlopen(real_uri)
		data = web.read()
		try:
			idx = data.index('i/planches/')
		except ValueError:
			print 'No data'
		return self.base_uri + data[idx:].split('"', 1)[0]

	@cache_result(600)
	def browse(self, preview=False):
		return [ImageItem('MLC n %d' % i, parent=self, menu=self.menu, uri=(lambda self, i: self._num2jpg(i))) for i in xrange(290, 1, -1)]


# XKCD Images informations fetcher
# works by downloading pages and parsing data
class XkcdImg(ImageItem):

	base_site = 'http://%sxkcd.com/'

	# "base" define the Image wanted for this object, can be:
	# None   (default) for random
	# ''     for Latest
	# <int>  for the corresponding episode
	def __init__(self, base=None, **kw):
		if base is None:
			base = 'comic/random'
			prefix = 'dynamic.'
			name = 'Random Episode'
			self._number = None
		else:
			if isinstance(base, int):
				base = str(base)
				self._number = base
			else:
				self._number = None
			prefix = ''
			if base:
				name = 'Episode %s' % base
			else:
				name = 'Latest'
		uri = self.base_site % prefix + base
		if uri[-1] != '/':
			uri += '/'
		self.uri = uri
		self._pic_uri = None
		ImageItem.__init__(self, name, uri=self.get_uri, thumbnail=self.get_uri, **kw)
		return None

	def __repr__(self):
		return '<%s %s>' % (self.name, self.__class__.__name__)

	# Get the corresponding website data
	def _get_data(self):
		site = urllib.urlopen(self.uri)
		return site.read()

	# Try to find an uri next prefix
	# "prefix"
	#     "Magic" pattern that should be at the left of the uri
	# "lookup_size"
	#     Size of the superstring used for lookup
	def _find_prefixed_uri(self, prefix, lookup_size=500):
		data = self._get_data()
		idx = data.index(prefix) + len(prefix)
		substring = data[idx:idx + lookup_size]
		return substring[substring.index('http'):substring.index('</')]

	# Get the effective number of this comic
	def get_number(self):
		if self._number is None:
			full_uri = self._find_prefixed_uri('Permanent link to this comic: ')
			for subpart in reversed(full_uri.split('/')):
				if subpart.isdigit():
					self._number = int(subpart)
					break
		return self._number

	# Return picture's uri as a string
	# "force refresh"
	#     Force redownloading the page (force a full reload)
	#     Generally, result in uri change since last time in random mode
	def get_uri(self, force_refresh=False):
		if self._pic_uri is None or force_refresh:
			self._pic_uri = self._find_prefixed_uri('Image URL (for hotlinking/embedding):')
		return self._pic_uri


# Class showing XkcdImg use
class XkcdFolder(GenericContainer):

	__metaclass__ = MetaSingleton
	_Max = None

	def __init__(self, **kw):
		GenericContainer.__init__(self, name='XKCD webcomic', type_='dir', **kw)
		if XkcdFolder._Max is None:
			latest = XkcdImg('')
			XkcdFolder._Max = latest.get_number()
		return None

	# Return a list of all pictures from XKCD
	# The first element is a magic Random picture
	@cache_result(600)
	def browse(self, preview=False):
		ret = [XkcdImg()]
		ret.extend((XkcdImg(n, parent=self, menu=self.menu) for n in xrange(self._Max, 0, -1))
		return ret


import re
import urllib2

cook_opener = urllib2.build_opener(urllib2.HTTPCookieProcessor())

def get_site(opts=''):
	return cook_opener.open('http://youporn.com/' + opts).read()

class YoupornVideo(VideoItem):

	flv_re = re.compile('"([^"]+?\\.flv)"')

	def __init__(self, video_id, thumb, title, **kw):
		self.vid_id = video_id
		self.thumb = thumb
		self._uri = None
		VideoItem.__init__(self, title, uri=self.get_uri, thumbnail=thumb, **kw)
		return None

	def get_uri(self):
		if self._uri is None:
			site = get_site('watch/' + self.vid_id)
			self._uri = self.flv_re.findall(site)[0]
		return self._uri

	def get_thumbnail(self):
		return self.thumb



class YoupornFolder(GenericContainer):

	def __init__(self, page=1, **kw):
		self._re = re.compile('<a href="/watch/(\\d+)"\\s+class="thumblink"><img id="thumb\\d+" src="([^"]+)".*?class="thumb"\\s*[/<>a\\s]+<p\\s+class="title">[^>]+>(.*?)</a>')
		self.page = str(page)
		GenericContainer.__init__(self, name='YouPorn', type_='dir', **kw)
		return None

	@cache_result(600)
	def browse(self, preview=False):
		return list((YoupornVideo(parent=self, menu=self.menu, a) for a in self._re.findall(get_site('?user_choice=Enter&page=%s' % self.page))))


import xml.etree.ElementTree as ET

class ShoutCastRadio(AudioItem):

	def __init__(self, **kw):
		AudioItem.__init__(self, kw['name'], uri='http://www.shoutcast.com/sbin/tunein-station.pls?id=%s' % kw['id'])
		return None


class ShoutCastGenreFolder(GenericContainer):

	def __init__(self, **kw):
		self.genre = kw.pop('name')
		GenericContainer.__init__(self, name=self.genre, type_='dir', **kw)
		return None

	@cache_result(600)
	def browse(self, preview=False):
		ret = []
		data = urllib.urlopen('http://www.shoutcast.com/sbin/newxml.phtml?genre=%s' % self.genre).read()
		try:
			shoutcast = ET.fromstring(data)
		except:
			log.debug(data)
		for stat in shoutcast.findall('station'):
			ret.append(ShoutCastRadio(**stat.attrib))
		return ret


class ShoutCastFolder(GenericContainer):

	def __init__(self, **kw):
		GenericContainer.__init__(self, name='Shoutcast', type_='dir', **kw)
		return None

	@cache_result(600)
	def browse(self, preview=False):
		ret = []
		data = urllib.urlopen('http://www.shoutcast.com/sbin/newxml.phtml').read()
		try:
			tree = ET.fromstring(data)
		except:
			log.debug(data)
		for clas in tree.findall('genre'):
			ret.append(ShoutCastGenreFolder(**clas.attrib))
		return ret
