# -*- coding: utf-8 -*- 
#
# Description:
#
# Media Items Core Class Definitions
#
#
#
# Changes:
#
# 2011-10-02
# Initial Commit
#
# 2012-04-16
# Add TV Replay item to video universe (Only M6 french TV for now)
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.


from __future__ import absolute_import

__all__ = ['MediaItem', 'AudioItem', 'ImageItem', 'VideoItem', 'DVDItem', 'IsoDVDItem', 'DirItem', 'ChannelItem', 'ProgramItem', 'TVRootItem', 'Playlist', 'WMedia2MMIObjects']

from peewee.debug import GET_LOGGER, PRINT_EXCEPTION
from peewee.misc_utils import MetaSingleton
from peewee.notifier import Task
from pygui.config import plugins, user_config
from pygui.item.containers import GenericContainer
from pygui.item.core import Item
from pygui.shared import pygui_globs
from wymedia.wmplus import get_root, browse_ng, container_search, get_child_count, get_object, get_subtitles, create_container, object_remove, playlist_create, playlist_append_child, get_metadata, set_metadata, playlist_append_marker_list, playlist_append_container, playlist_clear, register_update_callback, unregister_update_callback, FreeSpaceCriticalError


log = GET_LOGGER(__name__)
UNICODE_METADATA_FIELDS = frozenset(['title', 'description', 'author'])
TV_FAVORITES_FOLDER = 'TV Favorites'

#	This is the base item for every media, could be considered virtual
#	All of those items are build from wymedia
class MediaItem(Item):
	
	npl_dict = dict()
	media_update_fields = ()

	def __init__(self, wymedia_resource=None, type_=None, menu=None, display_type=None, parent=None, **meta_infos):
		valid_wymedia_obj = False
		self._observers = set()
		self._metadata_handle = None
		if wymedia_resource is None:
			wymedia_resource = 'Unnamed'
		if isinstance(wymedia_resource, basestring):
			name = wymedia_resource
		else:
			if 'i18n' in wymedia_resource:
				name = _(wymedia_resource['title'])
			elif wymedia_resource['title']:
				name = wymedia_resource['title'].decode('utf-8', 'ignore')
			else:
				name = _('Untitled')
			valid_wymedia_obj = True
		Item.__init__(self, name=name, type_=type_, menu=menu, display_type=display_type, parent=parent)
		if valid_wymedia_obj:
			self.wymedia_resource = wymedia_resource
			self.infos = None
		else:
			self.wymedia_resource = None
			self.infos = dict(uri='unknown://void', duration=0)
			if meta_infos:
				self.infos.update(meta_infos)
		self._update_received_task = Task(self._update_received)
		self._async_media_update_task = Task(self._async_media_update)
		self._async_media_update_task.delay = 0
		self._async_media_update_task._considered_idle = True
		self.async_media_update = self._async_media_update_task.start
		return None

	def __repr__(self):
		if self.wymedia_resource:
			return '<%s::%s(%s):%s>' % (self.__class__.__name__, self.type, repr(self.name), self.wymedia_resource.get('id', 'unknown'))
		else:
			return Item.__repr__(self)

	def _get_parent(self):
		if not self._parent:
			if self.wymedia_resource and self['parentid']:
				if int(self['parentid']) == 0:
					self._parent = RootItem()
				else:
					wm_parent = get_object(self['parentid'], ('uri', 'class', 'title'))
					self._parent = get_mmi_object(wm_parent, self.menu, None)
		return self._parent

	def _set_parent(self, item):
		self._parent = item
		return None

	parent = property(_get_parent, _set_parent)
	del _get_parent
	del _set_parent

	@property
	def wpl_options(self):
		return {}

	def is_marked(self):
		try:
			return bool(self.wymedia_resource.get('marked'))
		except AttributeError:
			return False

	def vfs_set_metas(self, _unref_link=False, **kw):
		log.debug('Setting %s to %s', kw, self)
		if self.wymedia_resource:
			if _unref_link:
				self.wymedia_resource.update(kw)
				kw['id'] = self.wymedia_resource['refid']
				try:
					set_metadata(kw)
				except:
					log.debug('set_metadata %s on %s failed!', kw, self)
			else:
				for key, value in kw.iteritems():
					try:
						self[key] = value
					except:
						log.debug('setting %s[%s]=%s Failed', self, key, value)
						PRINT_EXCEPTION()

			log.debug('RES: %s', self.wymedia_resource)
		return None

	def vfs_rename(self, new_name):
		self['title'] = new_name.encode('utf-8')
		self.name = new_name
		return None

	# Call Wymedia object_remove()
	def vfs_delete(self):
		object_remove(self.wymedia_resource, {'universe': self.universe})
		return None

	def handle_update(self, *args):
		self._update_received_task.args = args
		self._update_received_task.start(0, consider_idle=True)
		return None

	def watch(self, observer):
		log.info('%s by %s', self, observer)
		if self.wymedia_resource is not None:
			self._observers.add(observer)
			self.async_media_update()
		return None

	def unwatch(self, observer=None):
		log.info('%s by %s', self, observer)
		if self.wymedia_resource is not None:
			if observer is None:
				self._observers = set()
			else:
				self._observers.discard(observer)
			if not self._observers:
				log.info('unregister %s', self)
				unregister_update_callback(self.wymedia_resource)
		return None

	watched = property((lambda self: bool(self._observers)))
	
	#	Asynchronous call to update wymedia_resource
	def _async_media_update(self):
		if self.wymedia_resource is not None and not self._metadata_handle:
			log.info(self)
			register_update_callback(self.wymedia_resource, self.handle_update)
			get_metadata(self.wymedia_resource)
			self._metadata_handle = True
		return None

	#	Asynchronous update Callback from wymedia
	def _update_received(self, infos, kind):
		log.info(self)
		log.debug('%s infos=%s', self, infos)
		try:
			if 'title' in infos:
				if 'i18n' in infos:
					self.name = _(infos['title'])
				else:
					self.name = infos['title'].decode('utf-8')
			self.wymedia_resource.update(infos)
			for observer in list(self._observers):
				observer(self)
		except:
			PRINT_EXCEPTION()
		return None

	#	Synchronous call to update wymedia_resource
	def media_update(self, *names):
		if self.wymedia_resource is not None:
			wm_resource = None
			wanted_attr = None
			if names:
				wanted_attr = names
			elif self.media_update_fields:
				wanted_attr = self.media_update_fields
			if wanted_attr:
				log.debug('%s %s', self, wanted_attr)
				wm_resource = get_object(self['id'], wanted_attr)
				if wm_resource:
					if 'title' in wm_resource:
						if 'i18n' in wm_resource:
							self.name = _(wm_resource['title'])
						else:
							self.name = wm_resource['title'].decode('utf-8')
					index = self.wymedia_resource.get('index', None)
					if index is not None:
						wm_resource['index'] = index
					self.wymedia_resource.update(wm_resource)
		return None

	#	Metainfo accessor (used for dict-like access)
	def __getitem__(self, name):
		try:
			if self.wymedia_resource is not None:
				if name == 'subtitles':
					return list(WMedia2MMIObjects(get_subtitles(self.wymedia_resource), self.menu, self))
				elif name == 'thumbnail':
					tn = self.wymedia_resource.get('preview')
					if tn is None:
						if hasattr(self.menu, '_thumbnail_updated'):
							self.watch(self.menu._thumbnail_updated)
						else:
							self.async_media_update()
					return tn
				data = self.wymedia_resource[name]
				if name in UNICODE_METADATA_FIELDS:
					return data.decode('utf-8')
				else:
					return data
			else:
				res = self.infos.get(name)
				if callable(res):
					(res, self.infos[name]) = (res(), res())
				return res
		except Exception:
			log.debug('No such key: %s[%s]', self, name)
		return None

	#	Metainfo accessor (used for dict-like access)
	def __setitem__(self, name, value):
		if self.wymedia_resource is not None:
			if name not in ('subtitles', 'thumbnail', 'preview'):
				self.wymedia_resource[name] = value
				log.debug('wymedia.set_metadata(id: %s  %s: %s)', self.wymedia_resource['id'], name, value)
				try:
					set_metadata({'id': self.wymedia_resource['id'], name: value})
				except:
					log.debug('set_metadata in __setitem__ failed!')
		else:
			self.infos[name] = value
		return None

	def execute(self, *args, **kw):
		try:
			self.player.play(self, *args, **kw)
		except Exception, e:
			PRINT_EXCEPTION(e)
		return None

	def __hash__(self):
		if self.wymedia_resource is None:
			return hash(self.name + self.type + self['uri'])
		return hash(self.wymedia_resource['id'])

	def __eq__(self, other):
		if hasattr(other, 'wymedia_resource'):
			if self.wymedia_resource is None or other.wymedia_resource is None:
				return (self.name + self.type == other.name + other.type)
			return (self.wymedia_resource['id'] == other.wymedia_resource['id'])
		if isinstance(other, dict) and 'id' in other:
			return (self.wymedia_resource['id'] == other['id'])
		return None

	def __ne__(self, other):
		return not (self == other)

	def __cmp__(self, other):
		if isinstance(other, MediaItem):
			if self.wymedia_resource is None or other.wymedia_resource is None:
				return cmp(self.name + self.type, other.name + other.type)
			return cmp(self.wymedia_resource['id'], other.wymedia_resource['id'])
		elif isinstance(other, dict) and 'id' in other:
			return cmp(self.wymedia_resource['id'], other['id'])
		else:
			return cmp(type(self), type(other))
		return None

	def _npl_decision(self, *args, **kw):
		if 'playone' in plugins:
			return self.player.play(self, **kw)
		ms = pygui_globs['menustack']
		ms.back_to_menu(self.menu)
		player = ms.get_player()
		if self.universe == 'multiverse':
			try:
				self.player.play(self, **kw)
			except AttributeError:
				pass
			except:
				PRINT_EXCEPTION()
			return None
		name = self.universe + ':npl'
		if name not in MediaItem.npl_dict:
			wmedia_pls = playlist_create(get_root(), name)
			MediaItem.npl_dict[name] = get_mmi_object(wmedia_pls, self.menu, None)
		pl = MediaItem.npl_dict[name]
		if isinstance(self, GenericContainer):
			item_to_add = self
			item_to_start = None
		else:
			item_to_add = self.parent
			item_to_start = self
		log.debug('NPL: pl=%s to_add=%s to_start=%s', pl, item_to_add, item_to_start)
		if player is None:
			log.debug('NPL: no running player')
			pl.vfs_clear()
			pl.menu = self.menu
			pl.vfs_add_item(item_to_add)
			pl.play(item_to_start, **kw)
		else:
			log.debug('NPL: player found ask for add/replace')

			def _replace():
				pl.vfs_clear()
				pl.vfs_add_item(item_to_add)
				pl.play(item_to_start, **kw)
				return None

			def _add():
				if isinstance(self, GenericContainer):
					player.get_item_list('main_list').extend(self.browse())
				else:
					player.get_item_list('main_list').append(self)
				player.song_changed()
				if player.random_mode:
					player.random_mode = False
					player.go_random()
				return None

			if self.universe == 'audio':
				from pygui.window import ConfirmWindow, Button
				cw = ConfirmWindow(_('Add to now playing or play this item ?'), buttons=[Button(_('Add'), True), Button(_('Replace'), False)])
				cw.buttons[0].connect(_add)
				cw.buttons[1].connect(_replace)
				cw.show()
			else:
				_replace()
		return None



# Item representing directory
class DirItem(MediaItem, GenericContainer):

	def __init__(self, wymedia_resource, type_='dir', **kw):
		MediaItem.__init__(self, wymedia_resource, type_=type_, **kw)
		return None

	# Create a subfolder.
	def vfs_mkdir(self, name):
		create_container(self.wymedia_resource, name)
		return None

	# Browse the DirItem.
	# 	- menu: the menu to which the returned items belong (default: self.menu)
	# 	- universe: the universe to browse -- only items belonging to that universe
	# 		will be returned. (default: self.universe)
	# 	- sort_order: a tuple that specifies the various criteria according to which
	# 		to sort the results. e.g. ("+name",) will sort the items by increasing
	# 		alphabetical order (likewise, ("-name",) will sort them by decreasing
	# 		alphabetical order). Defaults to increasing alphabetical order, with the
	# 		containers (e.g. sub-folders) first.
	def browse(self, sort_order=None, preview=False):
		return WindowedItemList(self, menu=self.menu, universe=self.universe, sort_order=sort_order)

	def execute(self):
		self._npl_decision()
		return None

	def get_free_child_name(self, prefix):
		if prefix not in self:
			return prefix
		prefix += '-'
		for n in xrange(1, 1000):
			real_prefix = prefix + str(n)
			if real_prefix not in self:
				return real_prefix
		log.warn('Unable to find a unique name')
		return None

	def get_child(self, name, menu=None):
		result_set = container_search(self.wymedia_resource, 'title', name)
		if result_set:
			if len(result_set) > 1:
				log.warn("Query for '%s' returned more than 1 child.", name)
			return get_mmi_object(result_set[0], menu if menu else self.menu, self)
		else:
			raise KeyError("No such child: '%s'" % name)
		return None

	def get_child_count(self):
		try:
			return get_child_count(self.wymedia_resource, dict(universe=self.universe))
		except:
			log.warn('%s does not support get_child_count()', self)
		return None

	# dict-like interface to "in" -- we're searching by name.
	# Usage:
	# >>> if "Slayer - Raining Blood" in music_dir:
	# >>>     print "Thrash metal detected"
	def __contains__(self, name):
		return bool(container_search(self.wymedia_resource, 'title', name))



#Playlist object, launch an editor on browse() (see browse_action)
class Playlist(DirItem):

	def __init__(self, wymedia_resource, type_='playlist', **kw):
		MediaItem.__init__(self, wymedia_resource, type_=type_, **kw)
		return None

	def play(self, starts_with=None, **kw):
		log.debug('%s.play(starts_with=%s)', self, starts_with)
		items = self.browse()
		if starts_with is None:
			for it in items:
				if hasattr(it, 'player'):
					it.player.play(it, playlist=items, **kw)
					break
			else:
				log.info('Nothing to play here')
		else:
			starts_with.player.play(starts_with, playlist=items, **kw)
		return None

	def execute(self):
		from pygui.markerlist import Markerlist
		if self == Markerlist.now_playing:
			log.debug("Can't play Now Playing List !")
			return None
		DirItem.execute(self)
		return None

	# edit the playlist on browse
	def browse_action(self):
		from pygui.markerlist import Markerlist
		if self == Markerlist.now_playing:
			log.error("Can't edit Now Playing List!")
			return None
		if self['mimeType'] == 'audio/mpegurl':
			log.error("Can't edit M3U playlist!")
			return None
		if self['backend'] == 'upnp':
			log.error("Can't edit remote playlist!")
			return None
		from pygui.menu.menu import PlaylistEditor
		PlaylistEditor(playlist=self, universe=self.menu.universe).show(hide_previous_menu=False)
		return None

	# my_playlist.add_item(item): Append item to the playlist
	def vfs_add_item(self, item):
		if isinstance(item, DirItem):
			from pygui.config import admin_age
			browse_options = dict(universe=self.universe)
			if user_config['security']['parental_control']:
				if not user_config['security']['parent_mode']:
					if not user_config['security']['maturity_rating']:
						maturity_rating = 19
					else:
						maturity_rating = user_config['security']['maturity_rating']
				else:
					if not user_config['security']['show_hidden']:
						maturity_rating = 19
					else:
						maturity_rating = admin_age
				browse_options['maturity_rating'] = str(maturity_rating)
			return playlist_append_container(self.wymedia_resource, item.wymedia_resource, wymedia_sorting, browse_options)
		elif isinstance(item, Item):
			return playlist_append_child(self.wymedia_resource, item.wymedia_resource)
		elif not isinstance(item, dict):
			return playlist_append_marker_list(self.wymedia_resource, item.wymedia_resource)
		else:
			return playlist_append_child(self.wymedia_resource, item)
		return None

	def vfs_clear(self):
		playlist_clear(self.wymedia_resource)
		return None

	# my_playlist.vfs_del_item(item): Remove item from the playlist
	def vfs_del_item(self, item):
		if isinstance(item, Item):
			item = item.wymedia_resource
		children = container_search(self.wymedia_resource, 'refid', item['id'])
		if not children:
			raise ValueError('Playlist.vfs_del_item(x): x not in playlist')
		object_remove(children[0], {'universe': self.universe})
		return None



# The root item, mother of every item
class RootItem(MediaItem, GenericContainer):
	__metaclass__ = MetaSingleton

	parent = property((lambda self: None), (lambda self, val: None))

	def __init__(self):
		from wymedia.wmplus import init
		log.debug('Root::init')
		try:
			init()
		except FreeSpaceCriticalError:
			log.debug('No space left on device')
		log.debug('Root::get')
		egg = get_root()
		self._sort = ['family'] + list(wymedia_sorting)
		MediaItem.__init__(self, egg, type_='root')
		pygui_globs['db_root'] = self
		return None

	def browse(self, universe='main', menu=None, preview=False):
		if universe == 'multiverse':
			options = dict()
		else:
			options = dict(universe=universe)
		log.debug('browsing root...')
		ret = browse_ng(self.wymedia_resource, 0, 100, self._sort, options)
		log.debug('converting result...')
		wm_obj = list(WMedia2MMIObjects(ret, menu, self))
		if 'sysfuck' in plugins:
			wm_obj = list(reversed(wm_obj))
		if 'audio' in universe:
			wm_obj.append(ShoutCastFolder(parent=self, menu=self.menu))
		if 'video' in universe:
			wm_obj.append(YouTubeContainer(parent=self, menu=self.menu))
			wm_obj.append(DailyMotionContainer(parent=self, menu=self.menu))
			wm_obj.append(TVReplayContainer(parent=self, menu=self.menu))
			wm_obj.append(LiveStreamingContainer(parent=self, menu=self.menu))
#			if not user_config['security']['parental_control'] or user_config['security']['parent_mode']:
#				wm_obj.append(YoupornContainer(parent=self, menu=self.menu))
			wm_obj.append(PicasaContainer(parent=self, menu=self.menu))
			wm_obj.append(DVDItem('USB-DVD', parent=self, menu=self.menu))
		return wm_obj

	def show_menu(self):
		pygui_globs['menustack'].back_one_menu()
		return None



# The root of all hidden items.
# 
# The HiddenRoot is a VFS structure for things that are saved in the
# wymedia database but have no physical existence on the hard drive.
# 
# The HiddenRoot is guaranteed to contain the following subcontainers:
# - TV Favorites
class HiddenRoot(DirItem):
	__metaclass__ = MetaSingleton

	parent = None

	def __init__(self):
		DirItem.__init__(self, get_root('hidden'), type_='hidden_root')
		for folder in (TV_FAVORITES_FOLDER,):
			if folder not in self:
				log.info('%s not in HiddenRoot. Creating it.', folder)
				self.vfs_mkdir(folder)
		return None

	def browse(self, universe=None, menu=None, sort_order=None, preview=False):
		return WindowedItemList(self, menu, universe, sort_order=sort_order)



wymedia_sorting = ('container', 'title')



# return MMI object for the specified Wymedia object
def get_mmi_object(wm_obj, menu, parent):
#	print 'get_mmi_object'
#	print 'wm_obj: ', wm_obj
	display_prefix = menu.type + '_'
	if display_prefix.startswith('marker'):
		display_prefix = display_prefix[6:]
	wm_class = wm_obj['class']
	while True:
		klass = wmedia_types.get(wm_class)
		if klass is not None:
			break
		try:
			(wm_class, stripped) = wm_class.rsplit('.', 1)
		except ValueError:
			raise TypeError('Unknown object type: %s' % wm_obj['class'])
	ni = klass(wm_obj)
	ni.menu = menu
	ni.parent = parent
	ni.display_type = display_prefix + ni.type
#	print 'ni: ', ni
	return ni


# yield MMI objects mapped on wymedia objects found in <iterable>
def WMedia2MMIObjects(iterable, menu, parent):
	for i in iterable:
		try:
			yield get_mmi_object(i, menu, parent)
		except TypeError:
			pass



from pygui.item.mediaitem.misc import SubtitleItem
from pygui.item.mediaitem.progressive_result import WindowedItemList

if 'tv' in plugins:
	from pygui.item.mediaitem.tv import ChannelItem, CaptureChannelItem, ProgramItem, TVRootItem, AllChannelsList
else:
	def ChannelItem():
		return None

	def CaptureChannelItem():
		return None

	def ProgramItem():
		return None

	def TVRootItem():
		return None

	def AllChannelsList():
		return None

from pygui.item.mediaitem.audiovideo import AudioItem, DVDItem, ImageItem, IsoDVDItem, VideoItem, TVRecordItem, UpnpDirItem, UsbDirItem, RtmpStreamingItem
from pygui.item.mediaitem.dailymotion import DailyMotionContainer
from pygui.item.mediaitem.youtube import YouTubeContainer
#from pygui.item.mediaitem.youporn import YoupornContainer
from pygui.item.mediaitem.tvreplay import TVReplayContainer
from pygui.item.mediaitem.streaming import LiveStreamingContainer
from pygui.item.mediaitem.picasa import PicasaContainer
from pygui.item.mediaitem.shoutcast import ShoutCastFolder
from pygui.item.mediaitem.net import NetDirItem, NetFeedItem, NetItem

wmedia_types = {'object.container': DirItem,
								'object.container.netDir': NetDirItem,
								'object.container.netFeed': NetFeedItem,
								'object.container.playlistContainer': Playlist,
								'object.container.storageSystem': DirItem,
								'object.container.storageSystem.upnpStorage': UpnpDirItem,
								'object.container.storageVolume': UsbDirItem,
								'object.item': MediaItem,
								'object.item.audioItem': AudioItem,
								'object.item.epgItem': ProgramItem,
								'object.item.epgItem.dummy': ProgramItem,
								'object.item.imageItem': ImageItem,
								'object.item.netItem': NetItem,
								'object.item.netItem.audio': AudioItem,
								'object.item.netItem.video': VideoItem,
								'object.item.netItem.image': ImageItem,
								'object.item.videoItem': VideoItem,
								'object.item.videoItem.dvd': DVDItem,
								'object.item.videoItem.isoDvd': IsoDVDItem,
								'object.item.videoItem.isoDvd': IsoDVDItem,
								'object.item.videoItem.rtmpItem': RtmpStreamingItem,
								'object.item.videoItem.tvRecord': TVRecordItem,
								'object.item.videoItem.videoBroadcast': ChannelItem,
								'object.item.videoItem.videoBroadcast.videoCapture': CaptureChannelItem,
								'object.item.textItem.subtitle': SubtitleItem}
