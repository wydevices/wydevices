# -*- coding: utf-8 -*- 
#
# Description:
#
# Windowed Items List Class Definitions
#
#
#
# Changes:
#
# 2011-10-02
# Initial Commit
#
# 2011-12-13
# Modify fill_cache from 11 to 40 at WindowedItemList.__init__
# This solved a TV list problem. (11th channel appear under the 1th in list)
#
# Copyright 2010-2014, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.


from __future__ import absolute_import

__all__ = ['WindowedItemList']

from weakref import ref
from peewee.ranges import Range
from peewee.debug import GET_LOGGER, PRINT_EXCEPTION
from peewee.messages import send as louie_send
from pygui.item.mediaitem.core import WMedia2MMIObjects, wymedia_sorting, Playlist
from pygui.config import admin_age
from wymedia import browse_ng_new
from wymedia.wmplus import container_search, get_browse_position, playlist_swap_children

import functools

log = GET_LOGGER(__name__)



# Windowed item list.
# 
# This list is a view over a bigger, usually database-backed list, that we'd like
# to avoid being entirely loaded in memory at once (see the documentation for
# __init__ for details on how this is done).
# 
# The WindowedItemList maintains an internal cache of usually 2*WindowedItemList.delta
# items around the last accessed item (refreshed whenever an item outside the cache
# is accessed).
# 
# /!\\ **WARNING** /!\\ While WindowedItemList implements __getitem__ in a list-like
# fashion, its behavior differs from that of list when the argument to __getitem__
# is a slice:
# - If the slice's start or stop is None (e.g. [foo:], [:foo] or [:]), the
# beginning and end *of the cache* (*not* of the WIL) are used instead. To
# retrieve the entire actual contents of the WIL (although this isn't
# recommended, for obvious reasons), use my_wil[0:len(my_wil)].
# 
# /!\\ **WARNING TOO** /!\\ Iterating over a WIL actually only iterates over its cache.
# If you want to iterate over the whole list, you'll have to use the good old C-ism:
# for i in xrange(len(wil)):
# # do stuff with wil[i]
class WindowedItemList(object):

	__slots__ = ['_si', '_range', '_cached', 'menu', '_browse_options', '_browse_fn', '_sort', '_length', '_owners', '_pattern', 'end_reached']
	delta = 20

	# Generate a windowed result from an item
	# The "cache filling" will look like:
	# 	browse_fn(source_item, offset, nb_results, sorting_list, options)
	# options is a dict holding universe and the filtering data given in filter (if any)
	# SPECIAL CASE:
	# 	An browse_fn can raise a BrowseError
	# 	(and handled)
	def __init__(self, source_item, menu=None, universe=None, browse_fn=None, sort_order=None, pattern=None, filter=None):
		self._length = 0
		self._si = source_item
		if not menu:
			self.menu = source_item.menu
		else:
			self.menu = menu
		if not universe:
			universe = self.menu.universe
		if not sort_order:
			self._sort = wymedia_sorting
		else:
			self._sort = sort_order
		self._pattern = pattern
		self.end_reached = False
		if browse_fn is not None:
			if pattern is not None:
				self._browse_fn = functools.partial(browse_fn, pattern)
			else:
				self._browse_fn = functools.partial(browse_fn, source_item)
		else:
			self._browse_fn = functools.partial(browse_ng_new, source_item.wymedia_resource)
		if universe == 'multiverse':
			self._browse_options = {}
		else:
			self._browse_options = dict(universe=universe)
		if not filter:
			self._browse_options.update({})
		else:
			self._browse_options.update(filter)
		self._update_browse_options()
		self._range = Range(0, 0)
		self._cached = []
		self._owners = set()
		self._fill_cache(Range(0, 40))
		return None

	def _owner_removed(self, who):
		self._owners.remove(who)
		return None

	def add_owner(self, who):
		ow = self._owners
		ow.add(ref(who, self._owner_removed))
		for item in self._cached:
			item.list_owned = [elt().list_name for elt in self._owners]
		return None

	def __iter__(self):
		return iter(self._cached)

	def __repr__(self):
		if self._si is not None:
			name = self._si
		else:
			name = self._pattern
		return '<WIL(%s)%s of len %d> %s' % (name, self._range, len(self), self._cached)

	def remove_list(self, list_name):
		for it in self._cached:
			try:
				it.list_owned.remove(list_name)
			except ValueError:
				pass
		return None

	def index(self, elt):
		if isinstance(self._si, Playlist) and self._si.wymedia_resource['id'] != elt.wymedia_resource['parentid']:
			try:
				idx = int(container_search(self._si.wymedia_resource, 'refid', elt.wymedia_resource.get('refid', elt.wymedia_resource['id']))[0]['rank'])
				return int(idx)
			except IndexError:
				log.error('container_search(%s, "refid", %s) ->  []', self._si.wymedia_resource, elt.wymedia_resource.get('refid', elt.wymedia_resource['id']))
				wmedia_elt = elt.wymedia_resource
				PRINT_EXCEPTION()
		else:
			wmedia_elt = elt.wymedia_resource
		try:
			return self._cached.index(wmedia_elt) + self._range.start
		except (ValueError, IndexError):
			try:
				idx = int(wmedia_elt['index'])
				self[idx]
			except KeyError:
				log.debug('No index attribute. Fetching it from the DB.')
				return get_browse_position(wmedia_elt, self._sort, self._browse_options)
			except Exception, e:
				PRINT_EXCEPTION(e)
			return self._cached.index(wmedia_elt) + self._range.start
		return None

	def __len__(self):
		if hasattr(self._si, 'wymedia_resource'):
			cc = self._si.wymedia_resource.get('childCount')
			if cc is not None:
				return int(cc)
		return self._length

	# Update browse options according to parent/children mode configuration
	def _update_browse_options(self):
		if 'maturity_rating' in self._browse_options:
			del self._browse_options['maturity_rating']
		from pygui.config import user_config
		if user_config['security']['parental_control']:
			if not user_config['security']['parent_mode']:
				if user_config['security']['maturity_rating']:
					maturity_rating = user_config['security']['maturity_rating']
				else:
					maturity_rating = 19
				self._browse_options['maturity_rating'] = str(maturity_rating)
			else:
				if user_config['security']['show_hidden']:
					maturity_rating = admin_age
				else:
					maturity_rating = 19
				self._browse_options['maturity_rating'] = str(maturity_rating)
		return None

	# Fill the cache with the given window start & widow_size
	def _fill_cache(self, fill_range=None):
		try:
			delta_range = fill_range - self._range
		except:
			delta_range = None
		if fill_range is None:
			fill_range = self._range
		self._update_browse_options()
		signal = None
		log.debug('MR: %s DR: %s FR: %s', self._range, delta_range, fill_range)
		log.debug('requesting %d items starting at %d', len(fill_range), fill_range.start)
		if delta_range and delta_range < fill_range:
			windowed_childrens = self._browse_fn(delta_range.start, len(delta_range), self._sort, self._browse_options)
			if len(windowed_childrens) < len(delta_range):
				self.end_reached = True
			if delta_range.start == self._range.stop:
				items = list(WMedia2MMIObjects(windowed_childrens, self.menu, self._si))
				del self._cached[:fill_range.start - self._range.start]
				self._cached.extend(items)
				signal = 'scroll_down'
			elif delta_range.stop == self._range.start:
				items = list(WMedia2MMIObjects(windowed_childrens, self.menu, self._si))
				signal = 'scroll_up'
				my_len = len(self)
				if fill_range.stop < my_len or (fill_range.start < my_len and fill_range.stop >= my_len):
					del self._cached[fill_range.stop - self._range.start:]
					self._cached[0:0] = items
				else:
					del self._cached[fill_range.stop:]
					self._cached[0:0] = items
		else:
			windowed_childrens = self._browse_fn(fill_range.start, len(fill_range), self._sort, self._browse_options)
			if len(windowed_childrens) < len(fill_range):
				self.end_reached = True
			items = list(WMedia2MMIObjects(windowed_childrens, self.menu, self._si))
			self._cached[:] = items
			signal = 'everything'
		for it in self._cached:
			it.list_owned = [elt().list_name for elt in self._owners]
		self._range = fill_range
		if self._length in fill_range:
			self._length = self._range.start + len(self._cached)
		else:
			self._length = max(self._length, self._range.start + len(self._cached))
		louie_send(signal, sender=self.menu.universe, items=items)
		return None

	# Called on second browse (when first returns nothing)
	# in order to know if media for others universes are available.
	# Browse is done without 'universe' key in _browse_options
	def _second_browse(self):
		_d = self._browse_options.pop('universe', None)
		ret = (self._browse_fn(0, 1, self._sort, self._browse_options) == [])
		if _d is not None:
			self._browse_options.update(dict(universe=_d))
		return ret

	empty = property(_second_browse)
	del _second_browse

	# /!\ Careful /!\ __getitem__ with slice arguments doesn't behave exactly
	# like list.__getitem__.
	# See the main WindowedItemList documentation for details.
	def __getitem__(self, item):
		log.debug('WIL%s getitem(%s)', self._range, item)
		if isinstance(item, slice):
			if item.step:
				(start, stop, step) = item.indices(len(self))
				if item.start is None:
					start = max(start, self._range.start)
				if item.stop is None:
					stop = min(stop, self._range.stop)
				return [self[i] for i in xrange(start, stop, step)]
			req_range = Range(max(0, (self._range.start if item.start is None else item.start)), (min(len(self)+1, item.stop) if item.stop else len(self)))
			if req_range.start > req_range.stop:
				req_range.stop = req_range.start + 10
			if req_range in self._range:
				log.debug('cache HIT (%d cached)', len(self._cached))
				return self._cached[req_range.get_slice(offset=self._range.start)]
			else:
				log.debug('cache MISS (little sunshine)')
				self._fill_cache(req_range.get_range(grow=self.delta))
				return self[item]
		else:
			log.debug('WIL single integer')
			if item >= self._range.stop - 1 or item <= self._range.start:
				if not(item == 0 == self._range.start):
					self._fill_cache(Range(max(0, item - self.delta), item + self.delta))
			return self._cached[item - self._range.start]
		return None

	# Swap two elements given their position
	# WARNING: assume it's a playlist
	def swap(self, i1, i2):
		ret = playlist_swap_children(self[i1].wymedia_resource, self[i2].wymedia_resource)
		offset = self._range.start
		t = self._cached
		ri1 = i1 - offset
		ri2 = i2 - offset
		(t[ri1], t[ri2]) = (t[ri2], t[ri1])
		return ret

	# Append an item to the list
	# WARNING: assume it's a playlist
	def append(self, item):
		if self._si is not None:
			ret = self._si.vfs_add_item(item)
			self._fill_cache()
			return ret
		return False

	# Extend the list with another list
	# WARNING: assume it's a playlist
	def extend(self, other_list):
		if self._si is not None and isinstance(other_list, WindowedItemList):
			ret = self._si.vfs_add_item(other_list._si)
			self._fill_cache()
			return ret
		return False
