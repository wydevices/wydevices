# -*- coding: utf-8 -*- 
#
# Description:
#
# Items Containers Class Definiton
#
#
#
# Changes:
#
# 2011-10-02
# Initial Commit
#
# 2011-10-05
# Add Cyclic Behavior to ItemGrid
#
# 2012-04-22
# Modify menus behavior to center view on first checked item
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.


from __future__ import absolute_import

__all__ = ['ItemList', 'ItemListItem', 'GenericContainer']

from peewee.debug import GET_LOGGER
from peewee.messages import send as louie_send
from pygui.item.core import ActionItem, Item
from weakref import ref


log = GET_LOGGER(__name__)



class _MList(list):

	__slots__ = ['_owners']

	def __init__(self, *args):
		list.__init__(self, *args)
		self._owners = []
		return None

	def append(self, it):
		ow = self._owners
		it.list_owned = [elt().list_name for elt in ow]
		list.append(self, it)
		return None

	def insert(self, pos, it):
		ow = self._owners
		it.list_owned = [elt().list_name for elt in ow]
		list.insert(self, pos, it)
		return None

	def remove_list(self, list_name):
		for item in self:
			try:
				item.list_owned.remove(list_name)
			except ValueError:
				pass	
		return None

	def _owner_removed(self, who):
		self._owners.remove(who)
		return None

	def add_owner(self, who):
		self._owners.append(ref(who, self._owner_removed))
		for item in self:
			item.list_owned.append(who.list_name)
		return None



# A list of Items (in menu context)
class ItemList(object):

	_edited = False

	def __init__(self, menu, _list, list_name, selected_pos=0):
		for it in _list:
			it.menu = menu
		self.list_name = list_name
		self.menu = menu
		self.cyclic = False
		self.set_items(_list)
		self.selected_pos = -1
		if selected_pos >= 0 and selected_pos < len(self._data):
			self.selected_pos = selected_pos
		self._ItemList__sel_observers = set()
		return None

	def _get_selected(self):
		if 0 <= self.selected_pos < len(self._data):
			return self._data[self.selected_pos]
		return None

	def _set_selected(self, it):
		return None

	selected = property(_get_selected, _set_selected)
	del _get_selected
	del _set_selected

	def __repr__(self):
		return ('<ItemList pointing %s @%d :: %s>' % (self.selected, self.selected_pos, self._data))

	# Use to remove its list_name to items in _data (not possible in weakref callback)
	def __del__(self):
		try:
			self._data.remove_list(self.list_name)
		except AttributeError:
			pass
		return None

	# Remove handler for selection changes
	def del_sel_observer(self, who):
		self._ItemList__sel_observers.remove(who)
		return None

	# Add handler for selection changes
	# handler is called with 2 params: this list and the old selection
	def add_sel_observer(self, who):
		if who not in self._ItemList__sel_observers:
			self._ItemList__sel_observers.add(who)
		return None

	def __iter__(self):
		return (iter(self._data))

	def __contains__(self, item):
		return (item in self._data)

	def __len__(self):
		return (len(self._data))

	def __getitem__(self, idx):
		return (self._data[idx])

	def __setitem__(self, k, value):
		if isinstance(k, slice):
			for it in value:
				it.list_owned = [elt().list_name for elt in self._data._owners]
			self._data[k] = value
			for owner in self._data._owners:
				owner = owner()
				louie_send(owner.list_name, sender=owner.menu, action='reset', value=owner)
		else:
			self._data[k] = value
			value.menu = self.menu
			value.list_owned = [elt().list_name for elt in self._data._owners]
			for owner in self._data._owners:
				owner = owner()
				louie_send(owner.list_name, sender=owner.menu, action='reset', value=owner, position=k)
		return None

	def __delitem__(self, i):
		if isinstance(self._data, (list, tuple)):
			del self._data[i]
		else:
			self._data._fill_cache()
		if len(self._data):
			if i == self.selected_pos:
				try:
					sel = self._data[self.selected_pos]
				except IndexError:
					self.selected_pos = len(self._data) - 1
			elif i < self.selected_pos:
				self.selected_pos -= 1
			for owner in self._data._owners:
				owner = owner()
				if owner != self and i < owner.selected_pos:
					owner.selected_pos -= 1
		else:
			self.selected_pos = -1
		for owner in self._data._owners:
			owner = owner()
			louie_send(owner.list_name, sender=owner.menu, action='remove', value=owner, position=i)
		return None

	def is_empty(self):
		if isinstance(self._data, list):
			return (self._data == [])
		else:
			return self._data.empty

	def index(self, value):
		return self._data.index(value)

	def insert(self, i, item):
		item.menu = self.menu
		if i > 0:
			index = i
		else:
			index = max(0, len(self._data) + i)
		if index > len(self._data):
			index = len(self._data)
		if index < self.selected_pos:
			self.selected_pos += 1
		self._data.insert(i, item)
		for owner in self._data._owners:
			owner = owner()
			louie_send(owner.list_name, sender=owner.menu, action='add', value=owner, position=index)
		return None

	def append(self, x):
		x.menu = self.menu
		if not x.display_type:
			x.display_type = self.menu.type + '_' + x.type
		position = len(self._data)
		self._data.append(x)
		for owner in self._data._owners:
			owner = owner()
			louie_send(owner.list_name, sender=owner.menu, action='add', value=owner, position=position)
		return None

	def extend(self, other_list):
		menu = self.menu
		position = len(self._data)
		self._data.extend(other_list)
		display_prefix = menu.type + '_'
		for i, x in enumerate(other_list):
			x.menu = menu
			if not x.display_type:
				x.display_type = display_prefix + x.type
			for owner in self._data._owners:
				owner = owner()
				louie_send(owner.list_name, sender=owner.menu, action='add', value=owner, position=position + i)
		return None

	def remove(self, x):
		index = self._data.index(x)
		del self[index]
		return None

	def pop(self, i=-1):
		if i < 0:
			index = len(self._data) + i
		else:
			index = i
		elt = self._data.pop(i)
		for owner in self._data._owners:
			owner = owner()
			louie_send(owner.list_name, sender=owner.menu, action='remove', value=owner, position=index)
		return elt

	# Signal whenever the selection is on a list boundary or not i
	def advertise(self):
		if self.selected_pos == 0:
			for owner in self._data._owners:
				owner = owner()
				louie_send('%s_top_limit' % owner.list_name, owner.menu)
			if len(self) == 1:
				for owner in self._data._owners:
					owner = owner()
					louie_send('%s_bottom_limit' % owner.list_name, owner.menu)
		elif self.selected_pos == (len(self) - 1):
			for owner in self._data._owners:
				owner = owner()
				louie_send('%s_bottom_limit' % owner.list_name, owner.menu)
			if not len(self):
				for owner in self._data._owners:
					owner = owner()
					louie_send('%s_top_limit' % owner.list_name, owner.menu)
		else:
			for owner in self._data._owners:
				owner = owner()
				louie_send('%s_no_limit' % owner.list_name, owner.menu)
		return None

	def get_edit(self):
		return self._edited

	def set_edit(self, val):
		if val != self._edited:
			louie_send(self.list_name, sender=self.menu, action='edit', value=self, edit_mode=val)
			self._edited = val
		elif val and val == self._edited:
				louie_send('edit_list_not_editable', sender=self.menu)
		return None

	# Toggle edit mode
	edited = property(get_edit, set_edit)
	del get_edit
	del set_edit

	def reset_view(self):
		louie_send(self.list_name, sender=self.menu, action='reset', value=self)
		return None

	# Change the selected item
	# if in edit mode, move this item instead of selecting the next one
	def select(self, item=None, force_pos=False):
		if item is None:
			self.selected_pos = -1
			louie_send(self.list_name, sender=self.menu, action='reset', value=self)
			return None
		if self._edited:
			pos1 = self.selected_pos
			try:
				pos2 = pos1 + item
			except TypeError:
				log.error('%s.select(%s, %s)', self.list_name, item, force_pos)
				return False
			if pos1 > pos2:
				(max_pos, min_pos) = (pos1, pos2)
			else:
				(max_pos, min_pos) = (pos2, pos1)
			try:
				self._data[max_pos]
			except IndexError:
				return False
			if 0 > min_pos:
				return False
			self.selected_pos += item
			if isinstance(self._data, list):
				(self._data[pos2], self._data[pos1]) = (self._data[pos1], self._data[pos2])
			else:
				self._data.swap(pos1, pos2)
			for owner in self._data._owners:
				owner = owner()
				if owner != self:
					offset = 0
					if pos1 == owner.selected_pos:
						offset = pos2 - pos1
					elif pos1 < owner.selected_pos <= pos2:
						offset = -1
					elif pos2 <= owner.selected_pos < pos1:
						offset = 1
					if offset:
						owner.selected_pos += offset
				louie_send(owner.list_name, sender=owner.menu, action='swap', value=owner, i1=pos1, i2=pos2)
			return True
		index = 0
		if isinstance(item, Item):
			index = self._data.index(item)
		elif isinstance(item, int):
			if force_pos is True or self.selected is None:
				index = item
			else:
				index = self.selected_pos + item
		if 0 <= index:
			if self.selected_pos == index:
				return False
			try:
				index = self._ItemList__find_next_selectable(index)
			except (ValueError, IndexError):
				if self.cyclic:
					index = 0
				else:
					return False
			self.selected_pos = index
			old_sel = self.selected
			for observer in self._ItemList__sel_observers:
				observer(self, old_sel)
			louie_send(self.list_name, sender=self.menu, action='update', value=self, position=self.selected_pos)
			self.advertise()
			return True
		elif index == -1 and self.cyclic:
			old_sel = self.selected
			self.selected_pos = len(self) - 1
			for observer in self._ItemList__sel_observers:
				observer(self, old_sel)
			louie_send(self.list_name, sender=self.menu, action='update', value=self, position=self.selected_pos)
			self.advertise()
			return True
		return False

	def set_items(self, items, selected=-1, cyclic=False):
		menu = self.menu
		if isinstance(items, (tuple, list)):
			self.cyclic = cyclic
			self._data = _MList(items)
			self._data.add_owner(self)
			display_prefix = menu.type + '_'
			if display_prefix.startswith('marker'):
				display_prefix = display_prefix[6:]
			for it in items:
				it.menu = menu
				if not it.display_type:
					it.display_type = display_prefix + it.type
		elif isinstance(items, ItemList):
			self._data = items._data
			self._data.add_owner(self)
		else:
			self._data = items
			self._data.add_owner(self)
			self.cyclic = False
		if isinstance(selected, Item):
			selected = items.index(selected)
		if 0 <= selected < len(self._data):
			self.selected_pos = selected
		elif selected >= len(self._data) > 0:
			try:
				self._data[selected]
				self.selected_pos = selected
			except IndexError, e:
				log.error('Unable to reload cache %s[%s]: %s', self._data, selected, e)
				self.selected_pos = len(self._data) - 1
		else:
			try:
				for it in self._data:
					if it.display_type == 'checked':
						self.selected_pos = self._data.index(it)
						break
				else:
					self.selected_pos = 0
			except:
				self.selected_pos = 0
		louie_send(self.list_name, sender=menu, action='reset', value=self)
		self.advertise()
		return None

	def _ItemList__find_next_selectable(self, wanted):
		start_idx = 0
		if isinstance(wanted, int):
			start_idx = wanted
		else:
			start_idx = self._data.index(wanted)
		if self.selected_pos > start_idx:
			idxs_to_scan = range(start_idx, max(-1, start_idx - 19), -1)
		else:
			idxs_to_scan = range(start_idx, start_idx + 20)
		self._data[start_idx:start_idx + 10]
		for idx in idxs_to_scan:
			item = self._data[idx]
			if not hasattr(item, 'sensitive') or item.sensitive:
				return idx
		raise ValueError('find_next_selectable(%s) on "%s" returned nothing !!' % (wanted, self.list_name))



# ItemList subclass with a 2-dimensional twist.
# 
# Used to model containers that will be visualized as a grid,
# and thus require vertical and horizontal selection mechanisms.
# 
# The underlying structure is the same as that of an
# ItemList, laid out as follows:
# 
# Horizontal selection
# <---------->
# [0, 1, 2, 3,  ^
#  4, 5, 6, 7,  | Vertical selection
#  8, 9]        v
# 
# (example for a row_length of 4)
# 
# TODO Add some sort of wrap-around behavior in select_*.
# TODO self.__len__() don't return the good number at first browse ???
class ItemGrid(ItemList):
	
	# Create an ItemGrid. See L{ItemList.__init__} for the basic info.
	# @param row_length: The number of items making a single row of the grid.
	def __init__(self, menu, _list, list_name, row_length, selected_pos=0):
		ItemList.__init__(self, menu, _list, list_name, selected_pos)
		self.row_length = row_length
		return None

	# Select the [value]th next row, while keeping the same column selected, if possible.
	# If force_pos is True, select the [value]th row.
	def select_vertical(self, value, force_pos=False):
		if self.selected_pos == -1:
			raise ValueError('An item needs to be selected before you change the selected row.')
		if force_pos:
			new_pos = value * self.row_length + self.selected_column
		else:
			new_pos = value * self.row_length + self.selected_pos
		# Handle cyclic behavior
		# table_size = Size of table where thumb are placed
		# Exemple:
		# 0, 1, 2, 3, 4
		# 5, 6
		# Will give 10 place in this table
		if (self.__len__() % self.row_length) != 0:
			table_size = (((self.__len__() // self.row_length) + 1) * self.row_length)
		else:
			table_size = self.__len__()
		# Down cyclic behavior
		if new_pos >= self.__len__():
			new_pos -= table_size
		# Up cyclic behavior
		if new_pos < 0:
			new_pos += table_size
			if new_pos >= self.__len__():
				new_pos = self.__len__() - 1
		return self.select(new_pos, True)

	# Select the [value]th next column, while keeping the same row selected, if possible.
	# If force_pos is True, select the [value]th column.
	def select_horizontal(self, value, force_pos=False):
		if self.selected_pos == -1:
			raise ValueError('An item needs to be selected before you change the selected column.')
		if force_pos:
			new_pos = self.row_length * self.selected_row + value
		else:
			new_pos = self.selected_pos + value
		# Handle cyclic behavior
		if new_pos >= self.__len__():
			new_pos -= self.__len__()
		if new_pos < 0:
			new_pos += self.__len__()
		return self.select(new_pos, True)

	# The currently-selected row
	def _get_selected_row(self):
		if self.selected_pos == -1:
			return -1
		return self.selected_pos // self.row_length
	
	selected_row = property(_get_selected_row)
	del _get_selected_row
	
	# The currently-selected column
	def _get_selected_column(self):
		if self.selected_pos == -1:
			return -1
		return self.selected_pos - self.selected_row * self.row_length

	selected_column = property(_get_selected_column)
	del _get_selected_column

	def __repr__(self):
		return '<ItemGrid pointing %s @(row:%i, col:%i) :: %s>' % (self.selected, self.selected_row, self.selected_column, self._data)



class ItemListItem(ItemList, Item):

	def __init__(self, name, type_='item_list', menu=None, _list=[], list_name='main_list', selected_pos=0):
		Item.__init__(self, name, type_)
		ItemList.__init__(self, menu, _list, list_name, selected_pos)
		return None

	def is_marked(self):
		return False

	def __eq__(self, other):
		try:
			return self.name == other.name
		except Exception:
			return False

	def __cmp__(self, other):
		try:
			return cmp(self.name, other.name)
		except Exception:
			return -1



# Interface for containers
class GenericContainer(Item):

	def browse(self, preview=False):
		raise NotImplementedError('browse() method not implemented on %s' % self.__class__.__name__)

	def _get_playable_iterator(self):
		from pygui.item.mediaitem import MediaItem
		return (not isinstance(it, GenericContainer) and isinstance(it, MediaItem) for it in self.browse())



# Base class to handle multi choices options (aka checkbox).
# Your class must have a self.actions_dict describing the available actions.
# Your class can have a self.radio boolean attribute to allow only one
# checkbox to be checked.
# Example self.actions_dict()
# self.actions_dict = {
# 'opt1':{'handler':self.check_opt, 'caption': _('Opt1'), 'checked': True, 'args':('opt1'), 'kwargs':{}, 'pos': 1},
# 'opt2':{'handler':self.check_opt, 'caption': _('Opt2'), 'checked': False, 'args':('opt2'), 'kwargs':{}, 'pos': 2}
# }
# A list of ActionItem will be built on .browse()
class ActionContainer(GenericContainer):

	# Update the checked attribute of an action
	def _update_checked(self, key):
		if hasattr(self, 'radio') and self.radio:
			if not self.actions_dict[key]['checked']:
				self.actions_dict[key]['checked'] = True
			for k in self.actions_dict:
				if k != key:
					self.actions_dict[k]['checked'] = False
		else:
			self.actions_dict[key]['checked'] = not self.actions_dict[key]['checked']
		return None

	# Sort the options of self.actions_dict using the ['pos'] key
	def _ksort(self, d):
		def sort_action(a, b):
			if 'pos' in self.actions_dict[a] and 'pos' in self.actions_dict[b]:
				if self.actions_dict[a]['pos'] > self.actions_dict[b]['pos']:
					return 1
			return -1

		keys = d.keys()
		keys.sort(sort_action)
		return keys

	# Return an ActionItem list built using self.actions_dict
	def browse(self, preview=False):
		item_list = []
		for act in self._ksort(self.actions_dict):
			infos = self.actions_dict[act]
			if infos['checked']:
				display_type = 'checked'
			elif infos['checked'] == None:
				display_type = ''
			else:
				display_type = 'not_checked'
			if 'caption' in infos:
				caption = infos['caption']
			else:
				caption = act
			item_list.append(ActionItem(caption, type_='action', menu=self.menu, display_type=display_type, action=infos['handler'], args=infos['args'], kwargs=infos['kwargs']))
		return item_list
