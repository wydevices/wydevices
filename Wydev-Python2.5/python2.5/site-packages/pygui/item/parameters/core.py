# -*- coding: utf-8 -*- 
#
# Description:
#
# Parameter Items Core Definitions
#
#
#
# Changes:
#
# 2011-10-08
# Initial Commit
#
#
# Copyright 2010-2014, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.


from __future__ import absolute_import

import itertools
import pygui.config as config

from peewee.debug import PRINT_EXCEPTION
from peewee.messages import send as louie_send
from pygui.facilities.l10n import UnicodeDict
from pygui.item.containers import GenericContainer
from pygui.item.core import ActionItem, Item



class ParametersSetupItem(Item):

	# name: name is the untranslated base name.
	# name_args: parameters for the name string (%s etc...)
	def __init__(self, name, type_='setupitem', menu=None, display_type=None, related_item=None, name_args=None):
		if name_args is None:
			displayed_name = _(name)
		else:
			displayed_name = _(name) % name_args
		Item.__init__(self, displayed_name, type_, menu=menu, display_type=display_type)
		self.related_item = related_item
		self.preview_list = []
		self.base_name = name
		self.name_args = name_args
		return None

	def browse(self, preview=False):
		return self.preview_list

	# Send louie signal and eventually rebuild the options_list after a change
	def reload_options_list(self, rebuild=False):
		menu = self.menu
		browse_method = {'center_list': menu._browse_center, 'main_list': menu._browse_main}
		if rebuild:
			if menu['center_list']:
				list = 'center_list'
			else:
				list = 'main_list'
			options_selected = menu.selected_options
			browse_method[list]()
			menu.selected_options = options_selected
		louie_send('options_list', sender=menu, action='reset', value=menu['options_list'])
		return None

	# Send louie signal and eventually rebuild the center_list after a change
	def reload_center_list(self, rebuild=False):
		menu = self.menu
		if rebuild:
			center_selected = menu.selected_center
			menu._browse_main()
			menu.selected_center = center_selected
		louie_send('center_list', sender=menu, action='reset', value=menu['center_list'])
		return None

	def update_name(self):
		if self.name_args is None:
			self._name = _(self.base_name)
		else:
			self._name = _(self.base_name) % self.name_args
		return None



# Before calling this mother class constructor, be sure that yous inherited class
# has a translation_dict setted.
class UserConfigSetupItem(ParametersSetupItem):

	# Before calling this mother class constructor, be sure that yous inherited class
	# has a translation_dict setted.
	def __init__(self, domain, key, choices_list, *args, **kw):
		ParametersSetupItem.__init__(self, *args, **kw)
		self.domain = domain
		self.key = key
		self.choices_list = choices_list
		try:
			value = config.user_config[domain][key]
			self.preview_list = [ActionItem(name=self.translation_dict.get(val, str(val)), display_type=('checked' if val == value else 'not_checked'), type_='setupitem', action=self._select_option, args=[val]) for val in choices_list]
		except AttributeError, e:
			PRINT_EXCEPTION(e)
		return None

	def _select_option(self, val):
		config.user_config[self.domain][self.key] = val
		config.user_config.save()
		if hasattr(self, 'execute_action'):
			self.execute_action(val)
		if self.menu['options_list']:
			to_reload = self.menu['options_list']
		elif self.menu['options0_list']:
			to_reload = self.menu['options0_list']
		elif self.menu['aspect_ratio_list']:
			to_reload = self.menu['aspect_ratio_list']
		else:
			to_reload = self.menu['aspect_ratio_options_list']
		if to_reload and len(to_reload) > 0:
			self.menu._set_options_list(self, keep_selection=True)
		return None

	def browse(self, preview=False):
		val = config.user_config[self.domain][self.key]
		for it, choice in itertools.izip(self.preview_list, self.choices_list):
			it.name = self.translation_dict.get(choice)
			if val == it.args[0]:
				it.display_type = 'checked'
			else:
				it.display_type = 'not_checked'
		return self.preview_list



class BooleanUserConfigSetupItem(UserConfigSetupItem):

	translation_dict = UnicodeDict({True: 'ON', False: 'OFF'})



# Acts like UserConfigSetupItem but not construct ActionItem
# preview_list must be filled with a browseable item
class UserConfigSetupMultipleItem(ParametersSetupItem):

	def __init__(self, domain, key, *args, **kw):
		ParametersSetupItem.__init__(self, *args, **kw)
		self.domain = domain
		self.key = key
		return None

	# items selected MUST have a 'chosen_value' attribute
	def _select_option(self, *args, **kw):
		get_it = self.menu.get_item_list
		result = [str(get_it(choices).selected.kwargs.get('chosen_value', None)) for choices in self.menu.available_choices if hasattr(get_it(choices).selected, 'kwargs') and get_it(choices).selected is not None]
		try:
			config.user_config[self.domain][self.key] = ''.join(result)
			config.user_config.save()
		except:
			pass
		if hasattr(self, 'execute_action'):
			try:
				self.execute_action(result)
			except:
				PRINT_EXCEPTION()
		self.menu._set_options_list(self, keep_selection=True)
		return None



# Item that handle a Container Item (as UserConfigSetupMultipleItem) but no writes
# in config the entered value. It can check if entered value is the same as config's one
class UserConfigSetupCheckMultipleItem(ParametersSetupItem):

	def __init__(self, domain, key, *args, **kw):
		ParametersSetupItem.__init__(self, *args, **kw)
		self.domain = domain
		self.key = key
		self.entered_value = None
		return None

	def check_entered_value(self):
		return config.user_config[self.domain][self.key] == self.entered_value

	def _select_option(self, *args, **kw):
		get_it = self.menu.get_item_list
		self.entered_value = ''.join([str(get_it(choices).selected.kwargs.get('chosen_value', None)) for choices in self.menu.available_choices if hasattr(get_it(choices).selected, 'kwargs') and get_it(choices).selected is not None])
		self.menu._set_options_list(self, keep_selection=True)
		return None



# Class that handle a container of ActionItems which values
# are in a iterable.
# If iterable is not a dict (e.g. list, tuple, xrange, ...), it is
# transformed in a dict which items are (elt, str(elt))
class IterItemContainer(GenericContainer):

	def __init__(self, name, iter_, **kw):
		if not isinstance(iter_, dict):
			self.iter_ = dict([(val,str(val)) for val in iter_])
		else:
			self.iter_ = iter_
		GenericContainer.__init__(self, name, type_='parameter', **kw)
		return None

	def browse(self, preview=False):
		return [ActionItem(name=self.iter_.get(i, str(i)), type_='unknown', menu=self.menu, action=self.parent._select_option, kwargs=dict(chosen_value=i)) for i in sorted(self.iter_)]
