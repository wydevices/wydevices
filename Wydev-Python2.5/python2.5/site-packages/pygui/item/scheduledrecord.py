# -*- coding: utf-8 -*- 
#
# Description:
#
# Scheduled Records Item Class Definiton
#
#
#
# Changes:
#
# 2011-10-02
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.


from __future__ import absolute_import

from peewee.debug import PRINT_EXCEPTION, DEBUG
from pygui.facilities.l10n import UnicodeDict
from pygui.item.containers import GenericContainer
from pygui.item.core import Item
from time import time
from wyrecord import WyRecord
from wyrecord.recordscheduler import RECORDING_FLAG_SCHEDULED, RECORDING_FLAG_CANCELED, RECORDING_FLAG_COMPLETED, RECORDING_FLAG_ALL


_wyrec = WyRecord()
PERIODICITY = UnicodeDict({'daily': 'Every day', 'weekly': 'Every week'})



class ScheduledRecordRootItem(GenericContainer):

	def __init__(self, menu=None, display_type=None, parent=None):
		Item.__init__(self, _('My scheduled recordings'), 'schedule_dir', menu, display_type, parent)
		return None

	# Return all the scheduled records.
	#
	# If scheduled_only is True (default), only the scheduled records
	# are returned. Otherwise, completed, canceled and other bogus
	# records are included in the result set.
	def browse(self, scheduled_only=True, preview=False):
		_list = []
		if scheduled_only:
			flags = RECORDING_FLAG_SCHEDULED
		else:
			flags = RECORDING_FLAG_ALL
		for record in _wyrec.scheduler.GetRecordingList(nFlags=flags, ignore_periodic=True):
			_list.append(ScheduledRecordItem(record))
		for periodic_rule in _wyrec.scheduler.GetPeriodicRecordingList(active=True, unactive=True):
			_list.append(PeriodicScheduledRecordItem(periodic_rule))
		_list.sort(key=(lambda item: item.record.start_time))
		return _list



class ScheduledRecordItem(Item):
	def __init__(self, record, type_='schedule', menu=None, display_type=None):
		Item.__init__(self, record.name.decode('utf-8', 'ignore'), type_, menu, display_type)
		self.record = record
		return None

	def __eq__(self, other):
		if isinstance(other, ScheduledRecordItem):
			return (self.record == other.record)
		return False



class PeriodicScheduledRecordItem(ScheduledRecordItem):

	def __init__(self, periodic_rule, type_='periodic_schedule', menu=None, display_type=None):
		self.periodic_rule = periodic_rule
		self.period = PERIODICITY[periodic_rule.extern_rule_name]
		all_records = _wyrec.scheduler.recording_list.GetPeriodicRecordingListByRule(periodic_rule.id)
		now = time()
		self.remaining_records = [i for i in all_records if i.start_time >= now]
		try:
			ScheduledRecordItem.__init__(self, self.remaining_records[0], type_, menu, display_type) 
		except:
			PRINT_EXCEPTION()
		return None

	def _get_remaining_count(self):
		return len(self.remaining_records)

	# The remaining number of repeats for this record
	remaining_count = property(_get_remaining_count)
	del _get_remaining_count

	def _get_active(self):
		return self.periodic_rule.is_active

	def _set_active(self, active):
		if self.active:
			_wyrec.scheduler.DeactivatePeriodicityRule(self.periodic_rule.id)
		else:
			_wyrec.scheduler.ActivatePeriodicityRule(self.periodic_rule.id)
		return None

	# The record's activity status.
	active = property(_get_active, _set_active)
	del _get_active
	del _set_active


