# -*- coding: utf-8 -*- 
#
# Description:
#
# Player Action Items Definitons
#
#
#
# Changes:
#
# 2012-04-11
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

from __future__ import absolute_import

from pygui.config import HMI_PHOTO, user_config
from pygui.facilities.codemapping import country_dict, audio_codec_substitution_dict
from pygui.item.containers import ActionContainer



def go_aspect(context, display, aspect_corrected_mode):
	if 'selected' in context and context['selected']:
		context['selected'].show_menu()
	return None

def get_travelling(context):
	return []

def set_travelling(key, value):
	return None

def get_audio_substreams(context):
	player = context['menu']
	return player.get_audio_substreams()

def set_audio_substream(key, value, aid, player):
	player.set_audio_substream(aid)
	return None

def set_repeat_mode(player, mode):
	player.repeat_mode = (False if mode == 'off' else mode)
	return None

def set_random_mode(player, mode):
	player.go_random()
	return None

def set_play_mode(player, mode):
	player.playmode = mode
	return None

def play_embedded_audio(context):
	context['selected'].play_embedded_audio()
	return None

def play_embedded_video(context):
	context['selected'].play_embedded_video()
	return None

def play_embedded_image(context):
	context['selected'].play_embedded_image()
	return None



class TransitionsActionItem(ActionContainer):

	def __init__(self, item, menu, name, **kw):
		self.item = item
		self.actions_dict = dict()
		ActionContainer.__init__(self, name=name, type_='action', menu=menu, **kw)
		self.radio = True
		from pygui.facilities.codemapping import transition_dict
		for trans in HMI_PHOTO['transitions']:
			caption = '%s' % transition_dict.get(trans, trans)
			self.actions_dict[trans] = dict(handler=self.transitions, caption=caption, checked=user_config['photo']['transition'] == trans, args=(trans,), kwargs=dict())
		return None

	def transitions(self, trans):
		self._update_checked(trans)
		user_config['photo']['transition'] = trans
		user_config.save()
		self.menu._set_options_list(keep_selection=True)
		return None



# Used to set the user's TV's aspect ratio (is it 4:3 or 16:9?).
#
# Note that this is a player setting, not a per-item one.
class AspectRatioActionItem(ActionContainer):

	def __init__(self, menu, name, **kw):
		self.player = menu
		current_ratio = menu.aspect_ratio
		self.actions_dict = {'4_3': {'handler': self.set_aspect_ratio, 'caption': _('4:3'), 'checked': current_ratio == '4_3', 'args': ('4_3',), 'kwargs': {}}, '16_9': {'handler': self.set_aspect_ratio, 'caption': _('16:9'), 'checked': current_ratio == '16_9', 'args': ('16_9',), 'kwargs': {}}}
		self.radio = True
		ActionContainer.__init__(self, name=name, type_='action', menu=menu, **kw)
		return None

	# Set the player's aspect ratio. aspect_ratio must be one of:
	#  - "4_3": if the display has a 4:3 aspect ratio (e.g. oldschool TV)
	#  - "16_9": if the display has a 16:9 aspect ratio (e.g. HDTV)
	def set_aspect_ratio(self, aspect_ratio):
		self._update_checked(aspect_ratio)
		self.player.aspect_ratio = aspect_ratio
		self.menu._set_options_list(keep_selection=True)
		return None



# Used to set the display format when the TV's aspect ratio does not
# match that of the video stream (e.g. 16:9 video on a 4:3 display).
# See http://wiki.wyplay.int/doku.php/wybox:soft:multimedia:output_control
# for a definition of what each setting does depending on the currently-selected aspect ratio.
class DisplayFormatActionItem(ActionContainer):

	def __init__(self, menu, name, **kw):
		self.player = menu
		current_format = menu.display_format
		values = [('letter_box', _('Original')), ('pan_scan', _('Full screen')), ('fullscreen', _('Cinema'))]
		actions_dict = {}
		for key, caption in values:
			action = {'handler': self.set_display_format, 'caption': caption, 'checked': current_format == key, 'args': (key,), 'kwargs': {}}
			actions_dict[key] = action
		self.actions_dict = actions_dict
		self.radio = True
		ActionContainer.__init__(self, name=name, type_='action', menu=menu, **kw)
		return None

	# Set the player's display format. display_format must be one of:
	#  - "letter_box"
	#  - "pan_scan"
	#  - "center_cut_out"
	#  - "fullscreen"
	def set_display_format(self, display_format):
		self._update_checked(display_format)
		self.player.display_format, user_config['video']['display_format'] = display_format, display_format
		user_config.save()
		self.menu._set_options_list(keep_selection=True)
		return None



class SubtitlesActionItem(ActionContainer):

	def __init__(self, item, menu, name, **kw):
		self.item = item
		self.actions_dict = dict()
		ActionContainer.__init__(self, name=name, type_='action', menu=menu, **kw)
		self.radio = True
		lang_dict = {}
		for sub in self.menu.get_subtitles():
			try:
				caption = _(country_dict[sub[0][:2]]['language'])
			except KeyError:
				caption = _(sub[0])
			try:
				nb = lang_dict[caption]
				lang_dict[caption] = nb + 1
				caption = '%s-%.2d' % (caption, nb)
			except KeyError:
				lang_dict[caption] = 2
			sid = sub[2]
			self.actions_dict[sid] = dict(handler=self.subtitles, caption=caption, checked=sub[1], args=(self.menu, sid), kwargs=dict(), pos=sid + 1)
		return None

	def subtitles(self, player, sid):
		self._update_checked(sid)
		player.set_subtitle(sid)
		self.menu._set_options_list(keep_selection=True)
		return None



# Used to set the sibtitles textbock size of video player
# Allowed value is in range of 1 to 100
# Original size are:
#  - Wyplayer  : 40
#  - Zoltar    : 28
#  - Mediatitan: 28
#  - Mediatec  : 26
class SubtitlesSizeActionItem(ActionContainer):

	def __init__(self, item, player, name, **kw):
		self.item = item
		self.actions_dict = dict()
		ActionContainer.__init__(self, name=name, type_='action', menu=player, **kw)
		_size = player.get_subs_size()
		self.radio = True
		for size in xrange(5, 100, 5):
			caption = _('%d') % size
			self.actions_dict[size] = dict(handler=self._set_subs_size, caption=caption, checked=(size == _size), args=(size, player), kwargs=dict(), pos=size)
		return None

	def _set_subs_size(self, size, player):
		self._update_checked(size)
		player.set_subs_size(size)
		self.menu._set_options_list(keep_selection=True)
		return None



class AudioSubstreamsActionItem(ActionContainer):

	def __init__(self, item, menu, name, **kw):
		self.item = item
		self.actions_dict = dict()
		ActionContainer.__init__(self, name=name, type_='action', menu=menu, **kw)
		self.radio = True
		lang_dict = {}
		for i, sub in enumerate(self.menu.get_audio_substreams()):
			lang = sub[0]
			try:
				caption = _(country_dict[lang[:2]]['language'])
			except KeyError:
				caption = lang
			if len(sub) > 3 and sub[3] not in ('mp2',):
				caption += '-' + audio_codec_substitution_dict.get(sub[3], sub[3])
			num = lang_dict.get(caption, 0)
			lang_dict[caption] = num + 1
			if num:
				caption += '-%d' % num
			sid = sub[2]
			self.actions_dict[sid] = dict(handler=self.substreams, caption=caption, checked=sub[1], pos=i, args=(self.menu, sid), kwargs=dict())
		return None

	def substreams(self, player, sid):
		self._update_checked(sid)
		player.set_audio_substream(sid)
		self.menu._set_options_list(keep_selection=True)
		return None



class RepeatAudioActionItem(ActionContainer):

	def __init__(self, player, *args, **kw):
		ActionContainer.__init__(self, *args, **kw)
		self.player = player
		self.radio = True
		if not self.player.repeat_mode:
			sel = (True, False, False)
		elif self.player.repeat_mode == 'track':
			sel = (False, True, False)
		elif self.player.repeat_mode == 'all':
			sel = (False, False, True)
		self.actions_dict = {'off': {'handler': self.set_repeat, 'caption': _('OFF'), 'checked': sel[0], 'args': ('off',), 'kwargs': {}, 'pos': 1}, 'track': {'handler': self.set_repeat, 'caption': _('Track'), 'checked': sel[1], 'args': ('track',), 'kwargs': {}, 'pos': 2}, 'all': {'handler': self.set_repeat, 'caption': _('All'), 'checked': sel[2], 'args': ('all',), 'kwargs': {}, 'pos': 3}}
		return None

	def set_repeat(self, mode):
		set_repeat_mode(self.player, mode)
		self._update_checked(mode)
		self.menu._set_options_list(keep_selection=True)
		return None



class RandomModeActionItem(ActionContainer):

	def __init__(self, player, *args, **kw):
		ActionContainer.__init__(self, *args, **kw)
		self.radio = True
		self.player = player
		sel = ((False, True) if self.player.random_mode else (True, False))
		self.actions_dict = {'off': {'handler': self.set_random, 'caption': _('OFF'), 'checked': sel[0], 'args': ('off',), 'kwargs': {}, 'pos': 1}, 'on': {'handler': self.set_random, 'caption': _('ON'), 'checked': sel[1], 'args': ('on',), 'kwargs': {}, 'pos': 2}}
		return None

	def set_random(self, mode):
		set_random_mode(self.player, mode)
		self._update_checked(mode)
		self.menu._set_options_list(keep_selection=True)
		return None



class RepeatVideoActionItem(RepeatAudioActionItem):

	def __init__(self, player, *args, **kw):
		RepeatAudioActionItem.__init__(self, player, *args, **kw)
		self.actions_dict.pop('track')
		self.actions_dict.pop('all')
		_is_not_repeat = self.actions_dict['off']['checked']
		self.actions_dict['on'] = {'handler': self.set_repeat, 'caption': _('ON'), 'checked': not _is_not_repeat, 'args': ('dummy',), 'kwargs': {}, 'pos': 2}
		return None

	def set_repeat(self, mode):
		_mode = (self.player.playmode if mode != 'off' else mode)
		set_repeat_mode(self.player, _mode)
		key = ('on' if mode == 'dummy' else mode)
		self._update_checked(key)
		self.menu._set_options_list(keep_selection=True)
		return None



class PlayModeVideoActionItem(ActionContainer):

	def __init__(self, player, *args, **kw):
		ActionContainer.__init__(self, *args, **kw)
		self.player = player
		self.radio = True
		sel = ((True, False) if self.player.playmode == 'track' else (False, True))
		self.actions_dict = {'track': {'handler': self.set_play_mode, 'caption': _('One'), 'checked': sel[0], 'args': ('track',), 'kwargs': {}, 'pos': 1}, 'all': {'handler': self.set_play_mode, 'caption': _('List'), 'checked': sel[1], 'args': ('all',), 'kwargs': {}, 'pos': 2}}
		return None

	def set_play_mode(self, mode):
		if self.player.repeat_mode:
			self.player.repeat_mode = mode
		set_play_mode(self.player, mode)
		self._update_checked(mode)
		self.menu._set_options_list(keep_selection=True)
		return None
