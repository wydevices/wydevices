# -*- coding: utf-8 -*- 
#
# Description:
#
# Actions Jobs FileSystem Class Definition
#
#
#
# Changes:
#
# 2014-04-07
# Initial Commit
#
#
# Copyright 2010-2014, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.


from __future__ import absolute_import

import time
from peewee.formatters import bytes_to_human
from peewee.notifier import Task, ThreadedTask, HookThread
from peewee.debug import PRINT_EXCEPTION, GET_LOGGER
from pygui.shared import pygui_globs
from pygui.menu.menu import FavoriteEditor, PlaylistEditor
from pygui.window import MessageWindow, BigMessageWindow, KeyboardWindow, ProgressWindow, ConfirmWindow
from pygui.markerlist import get_marker_from_item
from wymedia.wmplus import CopyError, RemoveError, SetMetadataError, CreateContainerError, NotPermittedError, FilenameExistsError, DiskFullError

log = GET_LOGGER(__name__)


def execute_eject():
	bus = pygui_globs['wydbus']
	try:
		name = 'com.wyplay.wydetect'
		path = '/com/wyplay/wydetect_status'
		burn_clt = bus.reference(name, path)
		burn_clt_eject = burn_clt.method('toggle_tray', 's', '')
		burn_clt_eject('/dev/cdrom')
	except Exception, e:
		print 'Cannot load wydetect',
		print str(e)
	except:
		print 'Cannot load wydetect.'
	return None


def execute_delete(context, marker):
	def __do_delete(context, marker_list):
		try:
			context['selected'].vfs_delete()
		except RemoveError:
			PRINT_EXCEPTION()
			MessageWindow(text=_('Error removing %s') % context['selected'].name, title=_('Error')).show(timeout=5)
		except NotPermittedError, e:
			PRINT_EXCEPTION()
			if e.message == 'NOT_SUPPORTED_BY_FS':
				BigMessageWindow(text=_('The way this disk was formatted does not allow this operation'), title=_('Error')).show(timeout=5)
			else:
				MessageWindow(text=_('Operation not permitted'), title=_('Error')).show(timeout=5)
		marker_list._refresh()
		context['selected'].show_menu()
		return None
	win = ConfirmWindow(_('Are you sure ?'), confirm_action=__do_delete, confirm_args=(context, marker))
	win.show()
	if context['menu'] and hasattr(context['menu'], 'contextual_windows'):
		context['menu'].contextual_windows.append(win)
	return None


def execute_rename(context):
	text = None
	def __do_rename(kbd):
		new_name = kbd._text
		if new_name:
			try:
				context['selected'].vfs_rename(new_name.strip())
			except SetMetadataError:
				PRINT_EXCEPTION()
				MessageWindow(text=_('Error renaming %s') % context['selected'].name, title=_('Error')).show(timeout=5)
			except FilenameExistsError:
				PRINT_EXCEPTION()
				MessageWindow(text=_('Filename %s already exists') % new_name.strip(), title=_('Error')).show(timeout=5)
			except NotPermittedError, e:
				PRINT_EXCEPTION()
				if e.message == 'NOT_SUPPORTED_BY_FS':
					BigMessageWindow(text=_('The way this disk was formatted does not allow this operation'), title=_('Error')).show(timeout=5)
				else:
					MessageWindow(text=_('Operation not permitted'), title=_('Error')).show(timeout=5)
			finally:
				kbd.hide()
	text = context['selected'].name
	kbd = KeyboardWindow(_('Rename'), text=text, confirm_action=__do_rename)
	context['selected'].show_menu()
	kbd.show()
	if context['menu'] and hasattr(context['menu'], 'contextual_windows'):
		context['menu'].contextual_windows.append(kbd)
	return None


# Reorder a playlist (spawn a playlist editor).
# If the playlist is a TV favorite, a favorite editor is used instead.
def execute_reorder(context):
	selected = context['selected']
	pygui_globs['menustack'].back_to_menu(selected.menu)
	if context['menu'].universe == 'tv':
		editor = FavoriteEditor(playlist=selected)
	else:
		editor = PlaylistEditor(playlist=selected)
	editor.show(hide_previous_menu=False)
	return None


# Create a new folder.
def execute_mkdir(context):
	def __do_mkdir(kbd):
		name = kbd._text
		if name:
			try:
				context['parent'].vfs_mkdir(name.strip())
			except CreateContainerError:
				PRINT_EXCEPTION()
				MessageWindow(text=_('Error creating %s') % name.strip(), title=_('Error')).show(timeout=5)
			except FilenameExistsError:
				PRINT_EXCEPTION()
				MessageWindow(text=_('Filename %s already exists') % name.strip(), title=_('Error')).show(timeout=5)
			except NotPermittedError, e:
				PRINT_EXCEPTION()
				if e.message == 'NOT_SUPPORTED_BY_FS':
					BigMessageWindow(text=_('The way this disk was formatted does not allow this operation'), title=_('Error')).show(timeout=5)
				else:
					MessageWindow(text=_('Operation not permitted'), title=_('Error')).show(timeout=5)
			finally:
				kbd.hide()
	name = context['parent'].get_free_child_name(_('New folder'))
	kbd = KeyboardWindow(_('Folder name'), text=name, confirm_action=__do_mkdir)
	context['parent'].show_menu()
	kbd.show()
	if context['menu'] and hasattr(context['menu'], 'contextual_windows'):
		context['menu'].contextual_windows.append(kbd)
	return None


# Launch a thread job and report its state on a ProgressWindow
class GraphicalProgress(ThreadedTask):

	def __init__(self, job, context, title=None, win=None, *args, **kw):
		if title is None:
			title = _('Please wait...')
		ThreadedTask.__init__(self, job)
		self._title = title
		self._context = context
		self._context.show_menu()
		self._context.menu.hold = True
		if win:
			self._win = win
			self._win.title = self._title
		else:
			self._win = ProgressWindow(self._title)
		self._win.set_cancel(self.cancel)
		self._win.show()
		return None

	def report_job_progress(self, infos_dict):
		try:
			pw = self._win
			percent = 0.0
			if infos_dict is not None:
				if isinstance(infos_dict, basestring):
					BigMessageWindow(text=infos_dict, title=_('Error')).show(timeout=5)
				else:
					percent = infos_dict.pop('percent', 100.0)
					for k, v in infos_dict.items():
						setattr(pw, k, v)
			pw.progress = percent
		except:
			PRINT_EXCEPTION()
		return None

	def on_terminate(self):
		context = self._context
		context.menu.reload_func()
		if context.menu.selected == None:
			context.menu.select(0)
		log.debug('context.menu.hold=%s', context.menu.hold)
		try:
			from pygui.facilities.power import PowerManager
			power_mgr = PowerManager()
			if context.menu.hold and power_mgr.pm.apm_state > 0:
				log.debug('hack for standby: go home')
				Task((lambda : pygui_globs['menustack'].back_to_home())).start(1)
		except:
			PRINT_EXCEPTION()
		context.menu.hold = False
		self._win.hide()
		return None



# Process the copy of items via wymedia calls
class CopyThread(HookThread):

	def __init__(self, marker, context):
		HookThread.__init__(self)
		self._marker = marker
		self._context = context
		return None

	def func_process(self):
		marker = self._marker
		marker.vfs_copy_to(self._context)
		self.started.set()
		return None

	def get_infos(self):
		self.started.wait()
		try:
			status = self._marker.vfs_copy_status()
			log.debug('status: %s', status)
		except (CopyError, IOError):
			return _('Error while copying files')
		except DiskFullError:
			return _('Error while copying files: disk full')
		except NotPermittedError, e:
			if e.message == 'NOT_SUPPORTED_BY_FS':
				return _('The way this disk was formatted does not allow this operation')
			else:
				return _('Operation not permitted')
		if status is None:
			self.completed.set()
			return None
		tot_nb, tot_size, copied_nb, copied_size, current = status
		rem = tot_size - copied_size
		return dict(percent=copied_size * 100.0 / (tot_size if tot_size else 1), description=current, total=bytes_to_human(tot_size), elapsed=bytes_to_human(copied_size), remaining=(bytes_to_human(rem) if rem >= 0 else 'N/A'))

	def on_cancel(self):
		self._marker.vfs_copy_cancel()
		HookThread.on_cancel(self)
		return None
