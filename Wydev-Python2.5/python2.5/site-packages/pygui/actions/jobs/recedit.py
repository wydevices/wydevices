# -*- coding: utf-8 -*- 
#
# Description:
#
# Hand ActionItem to launch Records Editor Player
#
#
#
# Changes:
#
# 2012-04-29
# Initial Commit
#
#
# Copyright 2010-2014, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

import os
import re
import glob
import shutil
import unicodedata 

from time import sleep

from peewee.formatters import ellipsize
from peewee.notifier import Task, HookThread
from wyrecord.chunkinfo import ChunkInfo, UriChunkToPath

from pygui.shared import pygui_globs
from pygui.item.core import ActionItem
from pygui.item.containers import ActionContainer
from pygui.item.mediaitem.audiovideo import TVRecordItem
from pygui.menu.players.recedit_player import RecEditPlayer
from pygui.actions.jobs.fs import execute_delete, GraphicalProgress
from pygui.window import BigMessageWindow, KeyboardWindow, NoHomeProgressWindow


def clean_text(text): 
	text = unicodedata.normalize('NFKD', text).encode('ascii', 'ignore') 
	text = unicode(re.sub('[^\w\s-]', '', text).strip()) 
	return re.sub('[-\s]+', '_', text) 


class RecEditLaunchItem(ActionItem):
	def __init__(self, name, type_, *args, **kw):
		ActionItem.__init__(self, name, type_, action=self.execute_action, *args, **kw)

	def execute_action(self, context):
		try:
			old_player = context['selected'].player
			context['selected'].player = RecEditPlayer()
			context['selected'].execute()
			context['selected'].player = old_player
		except:
			print 'Enable to launch recedit'


class Rec2VidThread(HookThread):
	def __init__(self, context):
		HookThread.__init__(self)
		self.context = context
		self.new_name = self.context['menu'].video_name
		self.buf_size = self.context['menu'].copy_buf_size * 1024 * 1024
		self.record_path = '/wymedia/timeshift/records/%s' % self.context['selected'].wymedia_resource['oid']
		self.chunk_list = glob.glob(os.path.join(self.record_path, '*.ts'))
		self.actual_chunk_name = ''
		self.total_copied_bytes = 0
		self.total_bytes_to_copy = self._get_total_bytes_to_copy()
		self.canceled = False

	def _get_record_total_bytes(self):
		chunk_size = 0
		for chunk_file in self.chunk_list:
			chunk_size += os.path.getsize(chunk_file)
		return chunk_size

	def _get_total_bytes_to_copy(self):
		bytes_to_copy = 0
		for mark in self.context['menu'].mark_list:
			if mark['end']['byte'] == -1.0:
				mark['end']['byte'] = self._get_record_total_bytes()
			bytes_to_copy += int(mark['end']['byte']) - int(mark['start']['byte'])
		return bytes_to_copy

	def _copy_record_bytes(self, dest_file, record_offset, copy_length):
		chunk_num = 0
		copied_bytes = 0
		bytes_to_read = 0
		bytes_to_copy = copy_length
		record_offset_before = 0
		record_offset_current = record_offset
		record_offset_after = 0
		for chunk_file in self.chunk_list:
			chunk_num += 1
			record_offset_before = record_offset_after
			chunk_size = os.path.getsize(chunk_file)
			record_offset_after += chunk_size
			if record_offset_before <= record_offset_current and record_offset_current < record_offset_after:
				self.actual_chunk_name = os.path.basename(chunk_file)
				source_file = open(chunk_file, 'rb')
				seek_offset = record_offset_current - record_offset_before
				source_file.seek(seek_offset)
				if bytes_to_copy >= chunk_size - seek_offset:
					bytes_to_read = chunk_size - seek_offset
				else:
					bytes_to_read = bytes_to_copy
				data_buf = source_file.read(bytes_to_read)
				dest_file.write(data_buf)
				copied_bytes += len(data_buf)
				record_offset_current += copied_bytes
				bytes_to_copy -= copied_bytes
				source_file.close()
				if bytes_to_copy == 0:
					break
		self.total_copied_bytes += copied_bytes
		return copied_bytes

	def _copy_record_part(self, dest_file, mark_start_offset, mark_end_offset):
		copied_bytes = 0
		bytes_to_copy = 0
		mark_size = mark_end_offset - mark_start_offset
		while copied_bytes < mark_size:
			if self.buf_size >= mark_size - copied_bytes:
				bytes_to_copy = mark_size - copied_bytes
			else:
				bytes_to_copy = self.buf_size
			copied_bytes += self._copy_record_bytes(dest_file, mark_start_offset + copied_bytes, bytes_to_copy)

	def _async_func_process(self):
		if not os.path.exists('/wymedia/My Videos/RECS'):
			os.mkdir('/wymedia/My Videos/RECS')
		print ('opening file %s' % ('/wymedia/My Videos/RECS/%s.ts' % self.new_name))
		dest_file = open(('/wymedia/My Videos/RECS/%s.ts' % self.new_name), 'wb') 
		for mark in self.context['menu'].mark_list:
			if self.canceled == True:
				break
			if mark['end']['byte'] == -1.0:
				mark['end']['byte'] = self._get_record_total_bytes()
			self._copy_record_part(dest_file, int(mark['start']['byte']), int(mark['end']['byte']))
		print ('closing file %s' % ('/wymedia/My Videos/RECS/%s.ts' % self.new_name))
		dest_file.close()
		if self.canceled == True:
			os.remove(('/wymedia/My Videos/RECS/%s.ts' % self.new_name))
		else:
			if 'yes' in self.context['menu'].delete_record:
				self.context['selected'].vfs_delete()
			os.system('/wymedia/usr/bin/sqlite3 /etc/params/wymedia/.wyplay_db.-1.db \"UPDATE object SET state=\'tocheck\' WHERE (class=\'object.container\' OR	class=\'object.container.storageSystem\') AND state=\'ok\'\"')
		pygui_globs['menustack'].close_player()
		self.completed.set()

	def func_process(self):
#		print 'func_process'
		self.started.set()
		self._async_func_process()

	def get_infos(self):
#		print 'get_infos'
		self.started.wait()
		if self.total_copied_bytes == self.total_bytes_to_copy:
			self.completed.set()
			return None
#		print 'get_infos done'
		progress = self.total_copied_bytes * 100.0 / self.total_bytes_to_copy
		return dict(percent=progress, description=_('Copying %s') % self.actual_chunk_name, total='%d%%' % int(progress), elapsed='', remaining='')

	def on_cancel(self):
		self.canceled = True
		HookThread.on_cancel()


class RecEditDeleteMarkItem(ActionItem):
	def __init__(self, name, type_, *args, **kw):
		ActionItem.__init__(self, name, type_, action=self.execute_action, *args, **kw)

	def execute_action(self, context):
		try:
			if 'start' in context['menu'].current_mark:
				context['menu'].current_mark.clear()
				list_len = len(context['menu'].mark_list)
				context['menu'].last_mark_time = context['menu'].mark_list[list_len - 1]['end']['time']
			else:
				if len(context['menu'].mark_list) != 0:
					player_obj	= pygui_globs['display'].get_obj_by_name('recedit_player')
					mark_list_obj = player_obj.get_obj_by_name('mark_list')
					for bar in mark_list_obj.get_list_obj_by_name('mark_bar'):
						last_bar = bar
					mark_list_obj.remove_child(last_bar)
					context['menu'].current_mark = context['menu'].mark_list.pop()
					context['menu'].current_mark.pop('end')
					context['menu'].last_mark_time = context['menu'].current_mark['start']['time']
			sleep(1)
		except:
			print 'Enable to remove last mark'


class RecEditVideoNameItem(ActionItem):
	def __init__(self, name, type_, *args, **kw):
		ActionItem.__init__(self, name, type_, action=self.execute_action, *args, **kw)

	def execute_action(self, context):
		def _do_edit_name(kbd):
			new_name = kbd._text
			if new_name:
				if os.path.exists(('/wymedia/My Videos/RECS/%s.ts' % new_name)):
					BigMessageWindow(text=(_('File %s already exist.') % new_name), title=_('Error')).show(timeout=3)
				else:
					context['menu'].video_name = new_name
			kbd.hide()

		kbd = KeyboardWindow(_('Enter the new video name'), text=clean_text(context['selected'].name), confirm_action=_do_edit_name)
		kbd.show()

class RecEditBufferSizeItem(ActionContainer):
	def __init__(self, name, menu, **kw):
		pos = 0
		self.player = menu
		self.actions_dict = dict()
		for buf_size in range(2, 64, 2):
			self.actions_dict[str(buf_size)] = dict(handler=self.set_buf_size, caption='%dMB'%buf_size, checked=(self.player.copy_buf_size == buf_size), pos=pos, args=(buf_size), kwargs=dict())
			pos += 1
		self.radio = True
		ActionContainer.__init__(self, name=name, type_='action', menu=menu, **kw)

	def set_buf_size(self, buf_size):
		self._update_checked(buf_size)
		self.player.copy_buf_size = buf_size
		self.menu._set_options_list(keep_selection=True)


class RecEditDeleteRecordItem(ActionContainer):
	def __init__(self, name, menu, **kw):
		self.player = menu
		self.actions_dict = {'yes': {'handler': self.set_delete_record, 'caption': _('Yes'), 'checked': (self.player.delete_record == 'yes'), 'pos': 0, 'args': ('yes',), 'kwargs': {}},
						 'no': {'handler': self.set_delete_record, 'caption': _('No'), 'checked': (self.player.delete_record == 'no'), 'pos': 1, 'args': ('no',), 'kwargs': {}}}
		self.radio = True
		ActionContainer.__init__(self, name=name, type_='action', menu=menu, **kw)

	def set_delete_record(self, delete_record):
		self._update_checked(delete_record)
		self.player.delete_record = delete_record
		self.menu._set_options_list(keep_selection=True)


class RecEditStartProcessItem(ActionItem):
	def __init__(self, name, type_, *args, **kw):
		ActionItem.__init__(self, name, type_, action=self.execute_action, *args, **kw)

	def execute_action(self, context):
		if '' in context['menu'].video_name:
			context['menu'].video_name = clean_text(context['selected'].name)
		if 'start' in context['menu'].current_mark:
			context['menu'].current_mark.setdefault('end', dict(byte=-1.0, time=context['menu'].total_time))
			tmp_mark = copy_obj(context['menu'].current_mark)
			context['menu'].mark_list.append(tmp_mark)
		if 'no' in context['menu'].delete_record:
			win_title = _('Processing copy operation')
		else:
			win_title = _('Processing move operation')
#		try:
		GraphicalProgress(job=Rec2VidThread(context), title=win_title , context=context['parent'], win=NoHomeProgressWindow()).start(delay=1)
#		except:
#			BigMessageWindow(text=_('Error while copying files'), title=_('Error')).show(timeout=5)
