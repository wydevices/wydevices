#################################################################
################## WYMODCP PLUGIN INTERFACE #####################
##################  Copyright 2010 Polo35   #####################
#################################################################


import platform, socket, time, os
from threading import Thread

if platform.machine() == 'sh4':
	from peewee.notifier import Task
	from pygui.config import user_config
	from wyrecord import error, WyRecord


#################################################################
# WymodCP plugin interface
# Handle commands send to Unix socket '/wymedia/tmp/wymodcp_socket'
#################################################################
class PluginInterface(Thread):
	__module__ = __name__
	__doc__ = 'WyModCP control plugin.'

	# WymodCP plugin thread Init
	def __init__(self, post_key):
		Thread.__init__(self)
		self.post_key = post_key
		self.running = False
		self.setDaemon(True)
		self.setName('WyModCP Plugin')
		if platform.machine() == 'sh4':
			Task(self.start).start(0.10000000000000001)
		else:
			self.start()


	# WymodCP plugin thread Run
	def run(self):
		self.running = True
		# Delete last socket
		try:
				os.remove("/wymedia/tmp/wymodcp_socket")
		except OSError:
				pass
		# Create the socket
		try:
			self.wymodcp_sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
			self.wymodcp_sock.bind('/wymedia/tmp/wymodcp_socket')
			self.wymodcp_sock.listen(1)
			self.wymodcp_sock.settimeout(None)
		except:
			print 'WyModCP Plugin Socket Creation Error'
			return 0
		# Main thread loop
		while self.running:
			# Wait a connection to the socket
			(self.wymodcp_conn, self.wymodcp_addr) = self.wymodcp_sock.accept()
			self.wymodcp_conn.settimeout(None)
			print 'WyModCP Plugin connection accepted'
			# Main socket loop
			while True:
				command = {}
				# Try to receive data
				try:
					cmd_line = self.wymodcp_conn.recv(1024).replace('\n', '')

				except socket.error, e:
					print 'WyModCP Plugin error ', e
					break
				# Try to handle command
				try:
					# Parse command
					cmd_members = cmd_line.split(' ')
					for members in cmd_members:
						(member_name, member_value) = members.split(':')
						command.setdefault(member_name, member_value)
				except:
					print 'WyModCP Plugin error parsing command'
					try:
						self.wymodcp_conn.send('ERROR DATA')
					except:
						break
					continue
				# Switch command universe
				if 'RECORD' in command['universe']:
					self.record_universe(command)
				elif 'REMOTE' in command['universe']:
					try:
						print 'WyModCP Plugin Remote command: ',
						print command['command']
						self.post_key(command['command'])
						self.wymodcp_conn.send('OK')
					except:
						print 'UNKNOW REMOTE COMMAND !!!'
						self.wymodcp_conn.send('ERROR COMMAND')
				elif 'PARAMETERS' in command['universe']:
					self.parameters_universe(command)
				else :
					print 'UNKNOW COMMAND UNIVERSE !!!'
					self.wymodcp_conn.send('ERROR UNIVERSE')
			# Close the socket connection
			self.wymodcp_conn.close()
			print 'WyModCP plugin disconnected'
		# Close the socket
		self.wymodcp_sock.close()
		print 'WyModCP plugin Terminated'


	def str2bool(self, v):
		return v.lower() in ["yes", "true", "t", "1"]


	def record_universe(self, command):
		# Initiate WyRecord scheduler
		try:
			Scheduler = WyRecord().scheduler
		except:
			self.wymodcp_conn.send('ERROR SCHEDULER')
			return 0

		# GETLIST Command -> 'universe:RECORD command:GETLIST arg1:nFlags arg2:ignore_periodic'
		# - arg1 (flag) can be RECORDING_FLAG_RUNNING = 1, RECORDING_FLAG_COMPLETED = 2, RECORDING_FLAG_INCONFLICT = 4,
		# RECORDING_FLAG_SCHEDULED = 8, RECORDING_FLAG_CANCELED = 16, RECORDING_FLAG_MISSED = 16, RECORDING_FLAG_ALL = 255
		# - arg2 (ignore_periodic) can be True or False
		# Return value: Recording list or 'ERROR'
		if 'GETLIST' in command['command']:
			try:
				result = []
				rec_list = Scheduler.GetRecordingList(nFlags=int(command['arg1']), ignore_periodic=self.str2bool(command['arg2']))
				for e in rec_list:
					result.append(str(e))
			except:
				result = 'ERROR'

		# GETPERIODICLIST Command -> 'universe:RECORD command:GETPERIODICLIST arg1:active arg2:unactive'
		# - arg1 (active) can be True or False
		# - arg1 (unactive) can be True or False
		# Return value: Periodic recording list or 'ERROR'
		elif 'GETPERIODICLIST' in command['command']:
			try:
				result = []
				rec_list = Scheduler.GetPeriodicRecordingList(active=self.str2bool(command['arg1']), unactive=self.str2bool(command['arg2']))
				for e in rec_list:
					result.append(str(e))
			except:
				result = 'ERROR'

		# SAVELIST Command -> 'universe:RECORD command:SAVELIST'
		# Return value: OK or 'ERROR'
		elif 'SAVELIST' in command['command']:
			try:
				print "Saving Recording List"
				Scheduler.SaveRecordingList()
				result = 'OK'
			except:
				result = 'ERROR'

		# RENAME Command -> 'universe:RECORD command:RENAME arg1:nRecordingID arg2:new_name'
		# - arg1 (nRecordingID) must be a valid record id taken from records list
		# - arg2 (new_name) must be the new name of the record
		# Return value: OK or 'ERROR'
		elif 'RENAME' in command['command']:
			try:
				print 'Renaming record id %d to %s'%(command['arg1'], command['arg2'])
				res = Scheduler.UpdateRecordingName(nRecordingID=int(command['arg1']), new_name=command['arg2'])
				if res is None:
					result = 'OK'
				else:
					result = 'ERROR'
			except:
				result = 'ERROR'

		# STOP Command -> 'universe:RECORD command:STOP arg1:nRecordingID arg2:stop_at_player_pos'
		# - arg1 (nRecordingID) must be a valid record id taken from records list
		# - arg2 (stop_at_player_pos) can be True or False (always False it seems ???)
		# Return value: OK or 'ERROR'
		elif 'STOP' in command['command']:
			try:
				print "Stopping all running records"
				res = Scheduler.StopRecording(nRecordingID=int(command['arg1']), stop_at_player_pos=self.str2bool(command['arg2']))
				if res == True:
					result = 'OK'
				else:
					result = 'ERROR'
			except:
				result = 'ERROR'
		

		# STOPALL Command -> 'universe:RECORD command:STOPALL'
		# Return value: OK or 'ERROR'
		elif 'STOPALL' in command['command']:
			try:
				print "Stopping all running records"
				Scheduler.StopAllRunningRecord()
				result = 'OK'
			except:
				result = 'ERROR'

		# CHECKSCHEDULE Command -> 'universe:RECORD command:CHECKSCHEDULE arg1:save_list'
		# - arg1 (save_list) can be True or False
		# Return value: OK or 'ERROR'
		elif 'CHECKSCHEDULE' in command['command']:
			try:
				print 'Checking scheduled records'
				res = Scheduler.CheckSchedule(save_list=self.str2bool(command['arg1']))
				if res is None:
					result = 'OK'
				else:
					result = 'ERROR'
			except:
				result = 'ERROR'

		# STARTLIVE Command -> 'universe:RECORD command:STARTLIVE arg1:nServiceID arg2:nForcedDeviceID arg3:duration arg4:name'
		# - arg1 (nServiceID)
		# - arg2 (nForcedDeviceID)
		# - arg3 (duration)
		# - arg4 (name)
		# Return value: OK or 'ERROR'
		elif 'STARTLIVE' in command['command']:
			try:
				print 'Starting live record'
				res = Scheduler.StartLiveRecording(nServiceID=int(command['arg1']), nForcedDeviceID=self.str2bool(command['arg2']), duration=int(command['arg3']), name=command['arg4'])
				if res['status'] != error.WYRECORD_SUCCESS:
					result = 'OK'
				else:
					result = 'ERROR'
			except:
				result = 'ERROR'

		# UNKNOW RECORD COMMAND
		else:
			print 'UNKNOW RECORD COMMAND !!!'
			result = 'ERROR COMMAND'

		# Send result through socket
		self.wymodcp_conn.send(str(result))


# User Config Parameters
# 'universe:PARAMETERS command:SET arg1:sound arg2:volume arg3:3'
# 'universe:PARAMETERS command:SET arg1:sound arg2:mute arg3:0'

# 'universe:PARAMETERS command:SET arg1:config_version arg2:18'

# 'universe:PARAMETERS command:SET arg1:network arg2:iface arg3:eth0'
# 'universe:PARAMETERS command:SET arg1:network arg2:wifi_security arg3:None'
# 'universe:PARAMETERS command:SET arg1:network arg2:wifi_key arg3:None'
# 'universe:PARAMETERS command:SET arg1:network arg2:type arg3:wired'
# 'universe:PARAMETERS command:SET arg1:network arg2:upnp arg3:True'
# 'universe:PARAMETERS command:SET arg1:network arg2:wifi_name arg3:None'

# 'universe:PARAMETERS command:SET arg1:power arg2:screensaver_threshold arg3:300'
# 'universe:PARAMETERS command:SET arg1:power arg2:screensaver_type arg3:image'

# 'universe:PARAMETERS command:SET arg1:tv arg2:last_channel_index arg3:4'
# 'universe:PARAMETERS command:SET arg1:tv arg2:lnb_high_voltage arg3:False'
# 'universe:PARAMETERS command:SET arg1:tv arg2:record_duration arg3:180'
# 'universe:PARAMETERS command:SET arg1:tv arg2:epg_margin arg3:10'
# 'universe:PARAMETERS command:SET arg1:tv arg2:max_record_duration arg3:360'
# 'universe:PARAMETERS command:SET arg1:tv arg2:scan_with_scrambled arg3:True'
# 'universe:PARAMETERS command:SET arg1:tv arg2:timeshift_length arg3:180'
# 'universe:PARAMETERS command:SET arg1:tv arg2:last_scan_time arg3:0'
# 'universe:PARAMETERS command:SET arg1:tv arg2:last_favorite_name arg3:MAISON'

# 'universe:PARAMETERS command:SET arg1:photo arg2:filename arg3:True'
# 'universe:PARAMETERS command:SET arg1:photo arg2:transition arg3:no_transition'
# 'universe:PARAMETERS command:SET arg1:photo arg2:period arg3:15.0'
# 'universe:PARAMETERS command:SET arg1:photo arg2:zoom arg3:False'

# 'universe:PARAMETERS command:SET arg1:connections arg2:scart2_io_mode arg3:in'
# 'universe:PARAMETERS command:SET arg1:connections arg2:scart2_out_mode arg3:s-video'
# 'universe:PARAMETERS command:SET arg1:connections arg2:scart1_io_mode arg3:out'
# 'universe:PARAMETERS command:SET arg1:connections arg2:hdmi_sound arg3:False'
# 'universe:PARAMETERS command:SET arg1:connections arg2:spdif_surround arg3:False'
# 'universe:PARAMETERS command:SET arg1:connections arg2:active_device arg3:hdmi'
# 'universe:PARAMETERS command:SET arg1:connections arg2:scart1_in_mode arg3:composite'
# 'universe:PARAMETERS command:SET arg1:connections arg2:composite_output arg3:pal'
# 'universe:PARAMETERS command:SET arg1:connections arg2:scart2_in_mode arg3:rgb'
# 'universe:PARAMETERS command:SET arg1:connections arg2:scart1_out_mode arg3:rgb'
# 'universe:PARAMETERS command:SET arg1:connections arg2:auto_frame_rate arg3:False'
# 'universe:PARAMETERS command:SET arg1:connections arg2:resolution arg3:1920,1080,1,50'
# 'universe:PARAMETERS command:SET arg1:connections arg2:component_output arg3:rgb'

# 'universe:PARAMETERS command:SET arg1:base arg2:help_banner arg3:1'
# 'universe:PARAMETERS command:SET arg1:base arg2:language arg3:fr'
# 'universe:PARAMETERS command:SET arg1:base arg2:dateformat arg3:1'
# 'universe:PARAMETERS command:SET arg1:base arg2:country arg3:fr'
# 'universe:PARAMETERS command:SET arg1:base arg2:timeupdatemode arg3:3'
# 'universe:PARAMETERS command:SET arg1:base arg2:firstboot arg3:False'
# 'universe:PARAMETERS command:SET arg1:base arg2:timeformat arg3:1'
# 'universe:PARAMETERS command:SET arg1:base arg2:timezone arg3:Europe/Paris'

# 'universe:PARAMETERS command:SET arg1:video arg2:dvdmenulanguage arg3:fr'
# 'universe:PARAMETERS command:SET arg1:video arg2:language arg3:fr'
# 'universe:PARAMETERS command:SET arg1:video arg2:channel arg3:1'
# 'universe:PARAMETERS command:SET arg1:video arg2:dvdchannel arg3:1'
# 'universe:PARAMETERS command:SET arg1:video arg2:dvdautolaunch arg3:False'
# 'universe:PARAMETERS command:SET arg1:video arg2:dvdmovielanguage arg3:fr'
# 'universe:PARAMETERS command:SET arg1:video arg2:dvdbrowse arg3:False'
# 'universe:PARAMETERS command:SET arg1:video arg2:aspect_ratio arg3:0'
# 'universe:PARAMETERS command:SET arg1:video arg2:display_format arg3:letter_box'
# 'universe:PARAMETERS command:SET arg1:video arg2:dvdsubtitlelanguage arg3:fr'
# 'universe:PARAMETERS command:SET arg1:video arg2:subtitlesfiles arg3:False'
# 'universe:PARAMETERS command:SET arg1:video arg2:dvdprotectionlevel arg3:0'

# 'universe:PARAMETERS command:SET arg1:music arg2:riprate arg3:192'
# 'universe:PARAMETERS command:SET arg1:music arg2:ripcodec arg3:wav'
# 'universe:PARAMETERS command:SET arg1:music arg2:autorip arg3:False'

# 'universe:PARAMETERS command:SET arg1:security arg2:maturity_rating arg3:0'
# 'universe:PARAMETERS command:SET arg1:security arg2:parent_mode arg3:True'
# 'universe:PARAMETERS command:SET arg1:security arg2:secretcode arg3:None'
# 'universe:PARAMETERS command:SET arg1:security arg2:answer arg3:None'
# 'universe:PARAMETERS command:SET arg1:security arg2:parental_control arg3:False'
# 'universe:PARAMETERS command:SET arg1:security arg2:question arg3:None'
# 'universe:PARAMETERS command:SET arg1:security arg2:show_hidden arg3:True'

# 'universe:PARAMETERS command:SET arg1:net arg2:login arg3:None'
# 'universe:PARAMETERS command:SET arg1:net arg2:password arg3:None'

# 'universe:PARAMETERS command:SET arg1:advanced arg2:demo_mode arg3:False'
# 'universe:PARAMETERS command:SET arg1:advanced arg2:start_on_demo_mode arg3:False'
# 'universe:PARAMETERS command:SET arg1:advanced arg2:last_universe arg3:tv'

	def parameters_universe(self, command):
		# GET Command -> 'universe=PARAMETERS command=GET arg1: arg2:'
		if 'GET' in command['command']:
			try:
				if 'config_version' in command['arg1']:
					print 'Getting parameter %s'%(command['arg1'])
					result = user_config[command['arg1']]
				else:
					print 'Getting parameter %s.%s'%(command['arg1'], command['arg2'])
					result = user_config[command['arg1']][command['arg2']]
			except:
				result = 'ERROR'

		# SET Command -> 'universe=PARAMETERS command=SET arg1: arg2: arg3:'
		elif 'SET' in command['command']:
			try:
				if 'config_version' in command['arg1']:
					print 'Setting parameter %s is not safe'%(command['arg1'])
					result = 'ERROR'
				else:
					print 'Setting parameter %s.%s to %s'%(command['arg1'], command['arg2'], command['arg3'])
# I didn't activated write because i think there will be some interger/string/boolean conflict
# Maybe use a table (dict) to know the value type of each args and convert them with int()/str()/self.str2bool()
#					user_config[command['arg1']][command['arg2']] = command['arg3']
#					user_config.save()
					result = 'OK'
			except:
				result = 'ERROR'
		else :
			print 'UNKNOW PARAMETERS COMMAND !!!'
			result = 'ERROR COMMAND'

		# Send result through socket
		self.wymodcp_conn.send(str(result))


if (__name__ == '__main__'):
	def post_key(key, timeout = None):
		print key

	PluginInterface(post_key)

	while 1:
		time.sleep(1)

