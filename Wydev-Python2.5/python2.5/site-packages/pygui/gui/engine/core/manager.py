# -*- coding: utf-8 -*- 
#
# Description:
#
# GUI Engine ViewManager Class Definition
#
#
#
# Changes:
#
# 2011-10-21
# Initial Commit
#
#
#
# Copyright 2010-2014, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.


from __future__ import absolute_import

import os
import weakref
import pygui.config as config
from functools import partial
from itertools import chain
from peewee.debug import GET_LOGGER, PRINT_EXCEPTION
from peewee.messages import connect as louie_connect, send as louie_send
from pygui.gui.engine.core.widget import MenuWidget
from pygui.gui.widget.core.widgetfactory import WidgetLibrary

log = GET_LOGGER(__name__)



# This class manages ONE view. (associated with one theme handler, associated with a display)
# You must add some ViewManager to the engines of MenuManager. (menu/menu/stack.py)
class ViewManager(object):

	def __init__(self, display, theme):
		self._visible = False
		self._content = None
		self.wl = WidgetLibrary()
		self.theme = theme
		self.display = display
		self.menu_stack = list()
		self.window_dict = dict()
		self.menu_cache = weakref.WeakValueDictionary()
		self.on_idle = False
		self.up_window_layer = partial(self.update_window_layer, up_layer=True)
		self.down_window_layer = partial(self.update_window_layer, up_layer=False)
		return None

	def __getattr__(self, attr):
		return getattr(self._content, attr)

	def __repr__(self):
		return '<gui.Application @%s, %s skin>' % (self.display, self.theme)

	def __getitem__(self, name):
		if name.startswith('menu'):
			return MenuWidget(name, self.display, self.wl)
		elif name.startswith('window'):
			from pygui.gui.engine.core.window import __engine__
			return __engine__[name](name, self.display, self.wl)
		return None

	def loader_iterator(self):
		if config.user_config['base']['use_serialized_theme']:
			for step in xrange(1, 4):
				datapack = os.path.join(config.themes_dir, self.theme, 'xml', 'data.pk%d' % step)
				if os.path.exists(datapack):
					self.wl.load_pickle(datapack)
					yield None
				else:
					raise StopIteration
		else:
			self.wl.load_xml(os.path.join(config.themes_dir, self.theme, 'xml'))
			yield None

	def add_window(self, win):
		window_content = self['window_%s' % win.type]
		if window_content:
			window_content.display = self.display
			self.window_dict[win] = window_content
			window_content.show(win)
			louie_send(signal='on_create', sender=win)
		return None

	def remove_window(self, win):
		louie_send(signal='on_remove', sender=win)
		self.window_dict[win].hide()
		del self.window_dict[win]
		return None

	def update_window(self, win):
		wid = self.window_dict.get(win)
		if wid is not None:
			wid.update()
		else:
			log.warn('%s is not on screen anymore...', win)
		return None

	# Update windows' layer to keep them on top on menus.
	# !! When up_layer is True (ie on push_menu), call the method AFTER appending menu in menu_stack.
	# Has an effect only when not in idle (eg. no screensaver)
	def update_window_layer(self, menu_layer, up_layer=True):
		if not self.on_idle:
			for win in self.window_dict.values():
				if up_layer:
					win._layer = max((m._layer for m in self.menu_stack)) + menu_layer
				else:
					win._layer -= menu_layer
				win.set_layer(win._layer)
		return None

	def create_content(self, menu, showing=None, layer=None):
		if not showing:
			showing = 'menu_%s' % menu.type
		try:
			menu_content = self[showing]
			menu_content.create(menu, self.wl.get_container(showing, menu=menu))
			if layer is not None:
				menu_content.set_layer(layer)
			return menu_content
		except KeyError, e:
			PRINT_EXCEPTION(e)
			raise NameError('no special menu engine for %s' % showing)
		return None

	def push_menu(self, menu, hide_previous_menu=True):
		if config.navigator_cache and menu.type in ('audio', 'video', 'image', 'video_image'):
			if menu.type in self.menu_cache:
				menu_content = self.menu_cache[menu.type]
				menu_content.menu = menu
				menu_content.sync_model_view()
				for animation in menu_content._animations:
					louie_connect(receiver=animation.play, signal=animation.event, sender=menu)
			else:
				menu_content = self.create_content(menu)
				menu_content.cached = True
				self.menu_cache[menu.type] = menu_content
		else:
			menu_content = self.create_content(menu)
		if menu_content:
			if len(self.menu_stack) > 0:
				prev_menu = self.menu_stack[-1]
				if hide_previous_menu:
					prev_menu.pause_perpetual_anim()
					prev_menu._is_hidden = True
					louie_send(signal='on_hide', sender=prev_menu.menu)
				else:
					prev_menu._is_hidden = False
					louie_send(signal='on_background', sender=prev_menu.menu)
			self.menu_stack.append(menu_content)
			self.up_window_layer(menu_content._layer_depth)
			louie_send(signal='on_create', sender=menu)
		else:
			log.warning('Unable to create a widget for this menu')
		return None

	def back_one_menu(self):
		if len(self.menu_stack) <= 1:
			return None
		removed_menu = self.menu_stack.pop()
		removed_menu.remove()
		last_menu = self.menu_stack[-1]
		self.down_window_layer(removed_menu._layer_depth)
		if last_menu._is_hidden:
			last_menu.unpause_perpetual_anim()
			louie_send(signal='on_show', sender=last_menu.menu)
		else:
			louie_send(signal='on_foreground', sender=last_menu.menu)
		return None

	def back_to_menu(self, menu):
		while len(self.menu_stack) > 1 and self.menu_stack[-1].menu != menu:
			removed_menu = self.menu_stack.pop()
			removed_menu.remove()
			self.down_window_layer(removed_menu._layer_depth)
		last_menu = self.menu_stack[-1]
		if last_menu._is_hidden:
			last_menu.unpause_perpetual_anim()
			louie_send(signal='on_show', sender=last_menu.menu)
		else:
			louie_send(signal='on_foreground', sender=last_menu.menu)
		return None

	def pop_group(self, rank, _range):
		group_on_top = _range + rank == len(self.menu_stack) - 1
		for i in xrange(_range + 1):
			removed = self.menu_stack.pop(rank)
			removed.remove()
			self.down_window_layer(removed._layer_depth)
			louie_send(signal='on_remove', sender=removed.menu)
		layer = self.menu_stack[-1]
		if group_on_top:
			top_menu = self.menu_stack[-1]
			louie_send(signal='on_show', sender=top_menu.menu)
			top_menu.unpause_perpetual_anim()
		return None

	def swap(self, i1, i2, len_group_first=0, len_group_last=0):
		ms = self.menu_stack
		if i1 > i2:
			i2, i1 = i1, i2
		first = ms[i1]
		last = ms[i2]
		base_layer = first._layer
		groups_menu_first, groups_menu_last = list(), list()
		for indice in xrange(len_group_first):
			groups_menu_first.append(ms[i1 + indice + 1])
		for indice in xrange(len_group_last):
			groups_menu_last.append(ms[i2 + indice + 1])
		ms.insert(i1, ms.pop(i2))
		for indice in xrange(len_group_last):
			ms.insert(i1 + 1 + indice, ms.pop(i2 + 1 + indice))
		for m in ms[i1:]:
			m.set_layer(base_layer, 1)
			m._layer = base_layer
			base_layer += m._layer_depth
		for elt in chain((first,), groups_menu_first):
			elt._is_hidden = False
			louie_send(signal='on_show', sender=elt.menu)
		for elt in chain((last,), groups_menu_last):
			elt._is_hidden = True
			louie_send(signal='on_hide', sender=elt.menu)
			elt.pause_perpetual_anim()
		ms[-1].unpause_perpetual_anim()
		return None

	# Replace the current page (sub menu) with new one.
	# Actualize view stuff, and louie calls.
	def switch_sub_menu(self, menu, pos):
		log.debug('ms=%s menu=%s pos=%s', self.menu_stack, menu, pos)
		ms = self.menu_stack
		base_layer = ms[pos]._layer
		menu_content = self.create_content(menu, layer=base_layer)
		ms[pos].remove()
		louie_send(signal='on_remove', sender=ms[pos].menu)
		ms[pos] = menu_content
		for m in ms[pos:]:
			m.set_layer(base_layer, 1)
			m._layer = base_layer
			base_layer += m._layer_depth
		louie_send(signal='on_create', sender=menu)
		return None
