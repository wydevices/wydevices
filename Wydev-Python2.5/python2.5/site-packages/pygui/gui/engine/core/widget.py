# -*- coding: utf-8 -*- 
#
# Description:
#
# GUI Engine Widgets Class Definitions
#
#
#
# Changes:
#
# 2011-10-21
# Initial Commit
#
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.


from __future__ import absolute_import

import pygui.config as config
from peewee.debug import GET_LOGGER
from peewee.gettime import time
from peewee.messages import connect as louie_connect, disconnect as louie_disconnect, send as louie_send
from peewee.notifier import Task
from pygui.gui.widget import Container

log = GET_LOGGER(__name__)
_SYNC_CHUNK_DELAY = 0.29999999999999999
_SYNC_MAX_TIME_PER_CHUNK = 0.29999999999999999



def _get_max_visible_layer(display):
	max_layer = 0
	wid_list = [display]
	for wid in wid_list:
		try:
			wid_list.extend(wid._children)
		except Exception, e:
			max_layer = max(max_layer, wid.get_layer(1))
	return max_layer

try:
	from wyvas import get_max_visible_layer
	log.debug('get_max_visible_layer from wyvas')
except ImportError:
	get_max_visible_layer = _get_max_visible_layer
	log.debug('get_max_visible_layer from pygui')



# Base class for every menu view element
class MenuWidget(Container):

	specific_name_list = []
	cached = False

	def __init__(self, type, display, wl):
		Container.__init__(self)
		self.type = type
		self.menu = None
		self._is_hidden = True
		display.add_child(self)
		self.display = display
		return None

	def create(self, menu, container):
		self.menu = menu
		self.specific_name_list = menu._getitems_keywords.keys()
		self._layer = get_max_visible_layer(self.display)
		self.add_child(container)
		self.set_layer(self._layer, 1)
		self._animations = container._animations
		del container._animations
		self.sync_model_view()
		self._layer_depth = get_max_visible_layer(container) - self._layer + 1
		return None

	def unparent(self):
		menu = self.menu
		for name in self.specific_name_list:
			for view_element in self.get_list_obj_by_name(name):
				if hasattr(view_element, 'clear'):
					try:
						view_element.clear()
					except Exception, e:
						log.debug('Clear failed: %s.' % str(e))
		Container.unparent(self)
		menu.clear()
		del self.menu
		return None

	def remove(self):
		if config.fast_pushmenu:
			self._push_task.stop()
		menu = self.menu
		for name in self.specific_name_list:
			try:
				for view_element in self.get_list_obj_by_name(name):
					_sender = getattr(view_element, 'shared_name', None)
					louie_disconnect(receiver=view_element.update, signal=name, sender=menu)
					if _sender is not None:
						louie_disconnect(receiver=view_element.update, signal=name, sender=_sender)
			except Exception, e:
				log.debug(str(e))
		louie_send(signal='on_remove', sender=menu)
		try:
			for animation in self._animations:
				animation.stop()
				louie_disconnect(receiver=animation.play, signal=animation.event, sender=menu)
		except Exception, e:
			log.debug(str(e))
		if not self.cached:
			Task(self.unparent).start(5)
		return None

	def pause_perpetual_anim(self):
		for anim in self._animations:
			anim.pause()
		return None

	def unpause_perpetual_anim(self):
		for anim in self._animations:
			anim.unpause()
		return None

	def update_i18n(self):
		def go(obj):
			for child in obj._children:
				try:
					child.refresh_text()
				except AttributeError:
					try:
						go(child)
					except:
						pass
			return None

		go(self)
		return None

	# Connect each view element that has a special name to the appropriate handlers in the menu.
	# 
	# This method returns an iterator which connects as much names as it can within _SYNC_MAX_TIME_PER_CHUNK seconds of CPU time per iteration.
	# To complete the synchronization, exhaust it.
	# 
	# You're probably looking for L{sync_model_view}, though.
	def _sync_by_chunks(self):
		menu = self.menu
		last_yield = time()
		for name in self.specific_name_list:
			for view_element in self.get_list_obj_by_name(name):
				try:
					_sender = getattr(view_element, 'shared_name', None)
					view_element.initialize(signal=None, sender=None, value=menu[name])
					louie_connect(receiver=view_element.update, signal=name, sender=menu)
					if _sender is not None:
						louie_connect(receiver=view_element.update, signal=name, sender=_sender)
				except Exception, e:
					log.error("Can't sync %s in menu %s due to %r", name, menu, e)
			if time() - last_yield > _SYNC_MAX_TIME_PER_CHUNK:
				yield None
				last_yield = time()

	# Connect each view element that has a special name to the appropriate handlers in the menu.
	# 
	# If config.fast_pushmenu is True, the synching is done by chunks in a looping Task (which should make the app more responsive).
	# Otherwise, it's done in one go.
	def sync_model_view(self):
		if config.fast_pushmenu:
			self._push_task = Task(self._sync_by_chunks().next)
			self._push_task.start(_SYNC_CHUNK_DELAY, loop=True, consider_idle=True)
		else:
			list(self._sync_by_chunks())
		return None

	def __repr__(self):
		return '<gui.MenuWidget %s>' % self.type



# Base class for every window view element
class Window(object):

	def __init__(self, type, display, wl):
		self.type = type
		self.display = display
		self._visible = False
		self._window = None
		self._widget_library = wl
		return None

	def create_content(self, win):
		self.win = win
		return self._widget_library.get_container(self.type, menu=win)

	def show(self, win):
		if self._visible:
			return None
		self._visible = True
		self._layer = get_max_visible_layer(self.display)
		self._window = self.create_content(win)
		self.display.add_child(self._window, layer=self._layer - 1)
		return None

	def _Window__destroy(self):
		w = self._window
		if w:
			self._window = None
			w.hide()
			w.unparent()
		return None

	# Removes a window from screen.
	def hide(self):
		if not self._visible:
			return None
		self._visible = False
		for anim in self._window._animations:
			anim.stop()
			louie_disconnect(receiver=anim.play, signal=anim.event, sender=self.win)
		Task(self._Window__destroy).start(2)
		return None

	def __getattr__(self, attr):
		return getattr(self._window, attr)

	def __repr__(self):
		return '<gui.Window %s>' % self.type
