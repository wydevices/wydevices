# -*- coding: utf-8 -*- 
#
# Description:
#
# GUI Engine Windows Class Definitions
#
#
#
# Changes:
#
# 2011-10-21
# Initial Commit
#
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.


from __future__ import absolute_import, with_statement

import math
import pygui.gui.widget as widget
from copy import copy
from peewee.notifier import Task
from pygui.config import HMI_BASE
from pygui.gui.engine.core.widget import Window
from wyvas import render_lock



class UIButton(object):

	def __init__(self, contained=None, selected=False, caption=''):
		self._UIButton__ui_real_object = contained
		self._is_selected = selected
		self._caption = caption
		return None

	def __getattr__(self, attr):
		return getattr(self._UIButton__ui_real_object, attr)

	def __setattr__(self, attr, value):
		if attr != 'parent':
			object.__setattr__(self, attr, value)
		else:
			setattr(self._UIButton__ui_real_object, attr, value)
		return None

	def __cmp__(self, o):
		return cmp(self._UIButton__ui_real_object, o)

	def __eq__(self, o):
		return self._UIButton__ui_real_object == o

	def __hash__(self, o):
		return hash(self._UIButton__ui_real_object)

	def _set_caption(self, caption):
		self._caption = caption
		self.get_obj_by_name('text').set_text(caption)
		return None

	def unparent(self, *args, **kw):
		wid = self._UIButton__ui_real_object
		if wid is None:
			return None
		else:
			return wid.unparent(*args, **kw)
		return None



class LoadingWindow(Window):

	def update(self, *args, **kw):
		try:
			self._window.get_obj_by_name('text').set_text(self.win.text)
		except AttributeError:
			pass
		return None



class KeystrokeWindow(Window):

	def update(self, *args, **kw):
		self._window.get_obj_by_name('text').set_text(self.win.text)
		return None



class TextWindow(Window):

	def update(self, *args, **kw):
		self._window.get_obj_by_name('text').set_text(self.win.text)
		self._window.get_obj_by_name('title').set_text(self.win.title)
		return None



class MessageWindow(TextWindow):

	def __init__(self, *args, **kw):
		TextWindow.__init__(self, *args, **kw)
		return None

	def button2widget(self, button):
		if button.selected:
			state = 'selected'
		else:
			state = 'not_selected'
		prefix = 'button_'
		if button.type:
			prefix = '%s_%s' % (button.type, prefix)
		but = UIButton(self._widget_library.get_container(self.type, prefix + state), selected=button.selected, caption=button.name)
		but.get_obj_by_name('text').set_text(button.name)
		return but

	def create_content(self, win):
		wid = TextWindow.create_content(self, win)
		if win.button is not None:
			but = self.button2widget(win.button)
			wid.add_child(but, hcenter='50%', top='80%')
		return wid



class ProgressWindow(Window):

	def create_content(self, win):
		wid = Window.create_content(self, win)
		self._wid_title = wid.get_obj_by_name('title')
		self._wid_description = wid.get_obj_by_name('description')
		self._wid_progress = wid.get_obj_by_name('progressbar')
		self._wid_total = wid.get_obj_by_name('total')
		self._wid_elapsed = wid.get_obj_by_name('elapsed')
		self._wid_remaining = wid.get_obj_by_name('remaining')
		return wid

	def update(self, *args, **kw):
		win = self.win
		self._wid_progress.set(pos=win.progress)
		self._wid_title.set_text(win.title)
		self._wid_description.set_text(win.description)
		self._wid_total.set_text(win.total)
		self._wid_elapsed.set_text(win.elapsed)
		self._wid_remaining.set_text(win.remaining)
		return None



class SoundLevelWindow(Window):

	def create_content(self, win):
		wid = Window.create_content(self, win)
		self._wid_progress = wid.get_obj_by_name('progressbar')
		self._wid_icon = wid.get_obj_by_name('volume_icon')
		return wid

	def update(self, *args, **kw):
		win = self.win
		self._wid_progress.set(pos=win.progress)
		self._wid_icon.load(win.icon)
		return None



class MuteWindow(Window):

	def create_content(self, win):
		wid = Window.create_content(self, win)
		self._wid_icon = wid.get_obj_by_name('volume_icon')
		return wid

	def update(self, *args, **kw):
		win = self.win
		self._wid_icon.load(win.icon)
		return None



class ConfirmWindow(MessageWindow):

	def create_content(self, win, sync_ui=True):
		wid = TextWindow.create_content(self, win)
		self.buttons = []
		for button in win.buttons:
			but = self.button2widget(button)
			self.buttons.append(but)
		if sync_ui:
			self._sync_ui(wid)
		return wid

	def _draw_buttons(self, new_buttons, wid=None):
		my_buts = self.buttons
		if not wid:
			wid = self._window
		but_space = (100 / len(my_buts))
		width = '%d%%' % but_space
		for but in new_buttons:
			but_idx = my_buts.index(but)
			wid.add_child(but, width=width, left='%d%%' % (but_idx * but_space), top='90%')
		return None

	def _sync_ui(self, wid=None):
		new_buttons = []
		my_buts = self.buttons
		if wid:
			new_buttons = my_buts
		else:
			win_buts = self.win.buttons
			but_idx = 0
			nb_items = len(self.win.buttons)
			if len(my_buts) < nb_items:
				for n in range(nb_items - len(my_buts)):
					my_buts.append(UIButton())
			elif len(my_buts) > nb_items:
				for n in range(len(my_buts) - nb_items):
					my_buts.pop()
			for but_idx in range(nb_items):
				model_but = win_buts[but_idx]
				view_but = my_buts[but_idx]
				if model_but.selected != view_but._is_selected:
					view_but.unparent()
					but = self.button2widget(model_but)
					my_buts[but_idx] = but
					new_buttons.append(but)
				elif model_but.name != view_but._caption:
					view_but._set_caption(model_but.name)
		self._draw_buttons(new_buttons, wid)
		if not wid:
			wid = self._window
		text = self.win.text
		if hasattr(self.win, '_text_cursor_pos'):
			WIDTH = 25
			lt = len(text)
			cursor_pos = self.win._text_cursor_pos
			start = max(0, cursor_pos - WIDTH)
			if lt > WIDTH:
				end = min(lt, start + WIDTH)
			else:
				end = lt
			text = text[start:cursor_pos] + '//CURSOR//' + text[cursor_pos:end]
			if start != 0:
				text = HMI_BASE['keyboard_truncate_prefix'] + text
		wid.get_obj_by_name('text').set_text(text)
		return None

	def update(self, wid=None):
		with render_lock:
			self._sync_ui(wid)
		return None

	def hide(self):
		try:
			self._window.get_obj_by_name('text').set_text(self.win.text)
		except:
			pass
		return MessageWindow.hide(self)



class KeyboardWindow(ConfirmWindow):

	def create_content(self, win):
		wid = ConfirmWindow.create_content(self, win, sync_ui=False)
		wid.get_obj_by_name('title').set_text(win.title)
		self._key_container = wid.get_obj_by_name('standard_keys')
		self._but_container = wid.get_obj_by_name('action_keys')
		self._max_displayed_keys = win.get_max_keys_number()
		Task(self._sync_ui, wid).start(0.10000000000000001)
		return wid

	def _draw_buttons(self, new_buttons, wid=None):
		my_buts = self.buttons
		if not wid:
			wid = self._window
		lines = math.ceil(float(self._max_displayed_keys) / self.win.columns)
		char_space = (100 / self.win.columns)
		char_width = '%d%%' % char_space
		height = (100 / lines)
		alphabet_len = (len(self.win.alphabet) + len(self.win.special_chars))
		buttons_len = (len(self.win.buttons) - alphabet_len)
		but_width = '%d%%' % (100 / buttons_len)
		for but in new_buttons:
			layer = but.get_layer()
			but_idx = my_buts.index(but)
			row, col = divmod(but_idx, self.win.columns)
			if but_idx < alphabet_len:
				self._key_container.add_child(but, width=char_width, left='%d%%' % (col * char_space), height='%d%%' % height, top='%d%%' % (row * height), layer=layer)
			else:
				self._but_container.add_child(but, width=but_width, left='%d%%' % ((but_idx - alphabet_len) * (100 / buttons_len)), top='0%', height='100%', layer=layer)
		return None



# IP address editor.
class IpWindow(ConfirmWindow):

	def create_content(self, win):
		wid = ConfirmWindow.create_content(self, win, sync_ui=False)
		wid.get_obj_by_name('title').set_text(win.title)
		self._key_container = wid.get_obj_by_name('standard_keys')
		self._but_container = wid.get_obj_by_name('action_keys')
		self._sync_ui(wid)
		return wid

	def _draw_buttons(self, new_buttons, wid=None):
		my_buts = self.buttons
		if not wid:
			wid = self._window
		alphabet_len = len(self.win.modifiable_buttons)
		char_space = (100 / alphabet_len)
		char_width = '%d%%' % char_space
		buttons_len = (len(self.win.buttons) - alphabet_len)
		but_width = '%d%%' % (100 / buttons_len)
		for but in new_buttons:
			layer = but.get_layer()
			but_idx = my_buts.index(but)
			if but_idx < alphabet_len:
				self._key_container.add_child(but, width=char_width, left='%d%%' % ((but_idx + 1) * char_space), height='100%', top='100%', layer=layer)
			else:
				self._but_container.add_child(but, width=but_width, left='%d%%' % ((but_idx - alphabet_len + 1) * (100 / buttons_len)), top='0%', height='100%', layer=layer)
		return None



__engine__ = {'window_default': Window, 'window_text': TextWindow, 'window_keystroke': KeystrokeWindow, 'window_loading': LoadingWindow, 'window_message': MessageWindow, 'window_bigmessage': MessageWindow, 'window_confirm': ConfirmWindow, 'window_bigconfirm': ConfirmWindow, 'window_keyboard': KeyboardWindow, 'window_numeric_keyboard': KeyboardWindow, 'window_hexa_keyboard': KeyboardWindow, 'window_bigtitle_keyboard': KeyboardWindow, 'window_progress': ProgressWindow, 'window_progress_update': ProgressWindow, 'window_soundlevel': SoundLevelWindow, 'window_mute': MuteWindow, 'window_ip': IpWindow, 'window_silent_keyboard': KeyboardWindow}
