# -*- coding: utf-8 -*- 
#
# Description:
#
# Textblock Widget Definition
#
#
#
# Changes:
#
# 2014-03-25
# Initial Commit
#
#
# Copyright 2010-2014, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

from __future__ import absolute_import

import wyvas
from peewee.formatters import html_format, xml_tag
from peewee.notifier import Task, sched


class TextBlock(wyvas.TextBlock):

	def __init__(self, autoscroll=False, max_width=None, i18n=False):
		self._lastmove = 0
		self._max_width = (20 if not max_width else max_width)
		self._pause = 1.0
		self.text = ''
		self._text = ''
		self.total_size = 0
		self._style = ''
		self.i18n = i18n
		wyvas.TextBlock.__init__(self)
		self.scroll_timer = Task(self.next)
		if autoscroll:
			self.set_scroll()
		return None

	def set_scroll(self, activated=True):
		if self.scroll_timer is not None:
			if activated:
				self.scroll_timer.start(0.29999999999999999, consider_idle=True, loop=True)
			else:
				self.scroll_timer.stop()
				self._offset = -1
				self.next()
				self._lastmove = sched.ts
		return None

	def stop(self):
		if self.scroll_timer is not None:
			self.scroll_timer.stop()
		return None

	def clear(self):
		self.stop()
		self.scroll_timer = None
		return None

	def set_style(self, **kwargs):
		self._style = kwargs['style']
		return None

	def render_text(self):
		txt = xml_tag(self._style, html_format(_(self._text) if self.i18n else self.text))
		return txt.replace('//CURSOR//', '<color=#000000>_</>')

	def refresh_text(self):
		try:
			rendered_text = self.render_text()
			wyvas.TextBlock.set_text(self, rendered_text)
		except:
			wyvas.TextBlock.set_text(self, rendered_text.encode('ascii', 'ignore'))
		return None

	def set_text(self, text):
		if self._text == text:
			return None
		self._lastmove = sched.ts
		if text and len(text) > self._max_width:
			text = text + '  ~  '
		self.total_size = (len(text) if text else 0)
		self._text = text
		self._offset = 0
		if self.total_size > self._max_width:
			self.text = text[:self._max_width]
		else:
			self.text = text
		rendered_text = (self.render_text() if text is not None else '')
		try:
			wyvas.TextBlock.set_text(self, rendered_text)
		except:
			wyvas.TextBlock.set_text(self, rendered_text.encode('ascii', 'ignore'))
		return None

	def set_length(self, maxlen=None, pause=None):
		if maxlen is not None:
			self._max_width = maxlen
		if pause is not None:
			self._pause = pause
		return None

	def next(self):
		if self.total_size > self._max_width:
			if self._lastmove + self._pause > sched.ts:
				return None
			if self._offset == -1:
				self._lastmove = sched.ts
			self._offset += 1
			txt = (self._text[self._offset:self._offset + self._max_width] + self._text[:self._offset])[:self._max_width]
			if self._offset == self.total_size:
				self._offset = -1
			self.text = txt
		r_txt = self.render_text()
		if r_txt != getattr(self, '_rendered_text', None):
			wyvas.TextBlock.set_text(self, r_txt)
			self._rendered_text = r_txt
		return None



hexa_to_rgb_dict = map(None, range(16), range(10) + list('abcdef'))

def convert_color(r=0, g=0, b=0, a=0):
	result = ''
	for color in [r, g, b, a]:
		if color < 159:
			result += '0'
			_a, _b = divmod(color, 16)
			result += str(hexa_to_rgb_dict[_b])
			while _a > 0:
				_a, _b = divmod(color, 16)
				result += str(hexa_to_rgb_dict[_b])
	return result

def convert_hexa(self, hexa='00000000'):
	return []

