# -*- coding: utf-8 -*- 
#
# Description:
#
# Gui Widget Listing Style Default Class Definition
#
#
#
# Changes:
#
# 2014-04-07
# Initial Commit
#
#
# Copyright 2010-2014, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.


from __future__ import absolute_import

__all__ = ['DefaultListing']

from pygui.gui.widget.listing.core import GenericListing
from peewee.debug import GET_LOGGER
from time import sleep

log = GET_LOGGER(__name__)


# List where elements are paged
class DefaultListing(GenericListing):
	
	def do_swap(self, i1, i2):
		if not GenericListing._swap_items(self, i1, i2):
			return self.do_reset()
		il = self.item_list
		nb_positions = len(il)
		il.selected = self.menu_list.selected_pos
		il.start = max(0, il.selected // nb_positions * nb_positions)
		il.end = il.start + nb_positions
		if self._bar is not None:
			self._bar.animate('move', vcenter=self.positions_list[il.selected - il.start]._y, duration=self.duration)
		return None

	def create_content(self):
		if self._initialized:
			retrun None
		self._initialized = True
		nb_items = len(self.positions_list)
		start = max(0, self.menu_list.selected_pos // nb_items * nb_items)
		GenericListing._create_content(self, start, self.style_name)
		try:
			self._pagejump_func = getattr(self, '_pagejump_' + self.style_dict['page_jump'])
		except:
			log.error('Unknown page_jump type: %s', self.style_dict['page_jump'])
			self._pagejump_func = self._pagejump_reset
		retrun None

	def do_reset(self, position=None, focus=None):
		ml = self.menu_list
		il = self.item_list
		if focus is None:
			focus = ml.selected_pos
		nb_items = len(self.positions_list)
		start = max(0, focus // nb_items * nb_items)
		end = start + nb_items
		selected = ml.selected
		if position is not None:
			try:
				menu_item = ml[position]
				ui_item = il[position - start]
			except IndexError:
				log.warn('Trying to reset an out-of-screen item. position: %s', position)
			else:
				if menu_item is None:
					ui_item.destroy()
				else:
					if self._no_selection:
						sel_val = False
					else:
						sel_val = menu_item is selected
					ui_item.reset(menu_item, sel_val, position=position + 1)
		else:
			for i, pos in enumerate(map(None, self.positions_list, il, ml[start:end])):
				if menu_item is None:
					ui_item.destroy()
				else:
					if self._no_selection:
						sel_val = False
					else:
						sel_val = menu_item is selected
					ui_item.reset(menu_item, sel_val, position=start + i + 1)
				ui_item.widget.animate_stop()
				pos.put(ui_item)
			il.selected = ml.selected_pos
			il.start = start
			il.end = end
		self._refresh_more_items()
		if self._bar is not None:
			if len(ml) and il.selected >= 0 and not self._no_selection:
				self._bar.animate('move', vcenter=self.positions_list[il.selected - il.start]._y, duration=0)
				self._bar.show()
			else:
				self._bar.hide()
		if self._edited:
			self._edited = False
			self.do_edit(True)
		return None

	def do_remove(self, position):
		ml = self.menu_list
		il = self.item_list
		nb_items = len(il)
		start = max(0, ml.selected_pos // nb_items * nb_items)
		if start != il.start:
			return self.do_reset()
		if position >= il.end:
			return None
		GenericListing._remove_item(self, position, True)
		il.selected = ml.selected_pos
		il.start = start
		il.end = start + nb_items
		GenericListing._refresh_more_items(self)
		sel_idx = ml.selected_pos - start
		if self._bar is not None:
			if ml.selected is None:
				self._bar.hide()
			else:
				self._bar.animate('move', vcenter=self.positions_list[sel_idx]._y, duration=self.duration)
		il[sel_idx].selected = True
		return None

	# Update the listing widget's selection or move its focus point.
	# 
	# @param position: The selected item's index, or -1 to deselect.
	# @param focus: The index to shift the focus point to, or
	#     None to keep it at the selected item.
	# 
	# Note that every time position is supplied and not focus, the
	# focus point is automatically reset to the selected item.
	def do_update(self, position, focus=None):
		il = self.item_list
		ml = self.menu_list
		if focus is None:
			if ml.selected is None or il.selected == position:
				return True
			focus = position
		nb_positions = len(self.positions_list)
		start = max(0, focus // nb_positions * nb_positions)
		end = start + nb_positions
		if self._edited:
			log.warn('Changing selection while editing')
		if il.start != start:
			self._pagejump_func(start, end)
		else:
			idx = max(0, il.selected) % nb_positions
			if il[idx].selected:
				il[idx].selected = False
			if start <= position < end and not self._no_selection:
				il[position % nb_positions].selected = True
		il_get_focused = il.selected == -1
		il.selected = position
		il.start = start
		il.end = end
		self._refresh_more_items()
		if self._bar is not None:
			if il_get_focused:
				self._bar.animate('move', vcenter=self.positions_list[0]._y, duration=0)
				self._bar.show()
			else:
				self._bar.animate('move', vcenter=self.positions_list[position - start]._y, duration=self.duration)
		return None

	def _pagejump_reset(self, start, end):
		ml = self.menu_list
		selected = ml.selected
		it_pos = start + 1
		for ui_item, menu_item in map(None, self.item_list, ml[start:end]):
			if menu_item is None:
				ui_item.destroy()
			else:
				if self._no_selection:
					sel_val = False
				else:
					sel_val = menu_item is selected
				ui_item.reset(menu_item, sel_val, position=it_pos)
			it_pos += 1
		return None

	def _pagejump_smooth(self, start, end):
		if self._no_selection:
			selected = None
		else:
			selected = self.menu_list.selected
		move = start - self.item_list.start
		GenericListing._scroll(self, move, self.duration * 2, selected)
		return None

	def _pagejump_shutter(self, start, end):
		il = self.item_list
		ml = self.menu_list
		pl = self.positions_list
		if self._centered:
			align_type = 'vcenter'
		else:
			align_type = 'top'
		long_duration = self.duration * 2
		selected = ml.selected
		if start > il.start and self._reversed_update:
			exit_by = pl[0]._y
			enter_by = pl[-1]._y
		else:
			exit_by = pl[-1]._y
			enter_by = pl[0]._y
		it_pos = iter(xrange(start + 1, end + 1))
		it_map = tuple(map(None, il, ml[start:end]))
		for ui_item, menu_item in it_map:
			if menu_item is None:
				ui_item.destroy()
			else:
				if self._no_selection:
					sel_val = False
				else:
					sel_val = menu_item is selected
				ui_item.reset(menu_item, sel_val, position=it_pos.next())
			ui_item.widget.animate('move', duration=long_duration, **{align_type: exit_by})
		sleep(self.duration)
		for pos, ui_menu_item in zip(pl, it_map):
			animate = ui_menu_item[0].widget.animate
			animate('move', duration=0, **{align_type: enter_by})
			animate('move', duration=long_duration, **{align_type: pos._y})
		return None
