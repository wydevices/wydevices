# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definition of Hybrid Style Items
#
#
#
# Changes:
#
# 2014-03-24
# Initial Commit
#
#
# Copyright 2010-2014, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

from __future__ import absolute_import, with_statement

__all__ = ['HybridListing']

from .core import GenericListing
from peewee.debug import GET_LOGGER
from peewee.notifier import sched
from wyvas import render_lock

log = GET_LOGGER(__name__)


# List where selected item is kept is the middle
# of the list as far as it's possible.
class HybridListing(GenericListing):

	def create_content(self):
		if self._initialized:
			return None
		self._initialized = True
		self._last_timestamp = 0
		ml = self.menu_list
		nb_positions = len(self.positions_list)
		midpos = nb_positions >> 1
		if ml.selected_pos <= midpos:
			start = 0
		elif ml.selected_pos < len(ml) - midpos:
			start = ml.selected_pos - midpos
		else:
			start = max(0, len(ml) - nb_positions)
		GenericListing._create_content(self, start, self.style_name[:-7])
		return None

	def do_reset(self, position=None, focus=None):
		ml = self.menu_list
		il = self.item_list
		nb_positions = len(self.positions_list)
		midpos = nb_positions >> 1
		ml[ml.selected_pos:ml.selected_pos + nb_positions]
		if ml.selected_pos <= midpos:
			start = 0
		elif ml.selected_pos < len(ml) - midpos:
			start = ml.selected_pos - midpos
		else:
			start = max(0, len(ml) - nb_positions)
		end = start + nb_positions
		selected = ml.selected
		if position is not None:
			menu_item = ml[position]
			ui_item = il[position - start]
			if menu_item is None:
				ui_item.destroy()
			else:
				ui_item.reset(menu_item, menu_item is selected, position=position - start + 1)
		else:
			for i, pos in enumerate(map(None, self.positions_list, il, ml[start:end])):
				if menu_item is None:
					ui_item.destroy()
				else:
					ui_item.reset(menu_item, menu_item is selected, position=start + i + 1)
				ui_item.widget.animate_stop()
				pos.put(ui_item)
			il.selected = ml.selected_pos
			il.start = start
			il.end = end
		self._refresh_more_items()
		if self._bar is not None:
			if len(ml) and il.selected >= 0:
				self._bar.animate('move', vcenter=self.positions_list[il.selected - start]._y, duration=0)
				self._bar.show()
			else:
				self._bar.hide()
		if self._edited:
			self._edited = False
			self.do_edit(True)
		return None

	def do_remove(self, position):
		ml = self.menu_list
		il = self.item_list
		try:
			ml[il.end - 2]
		except IndexError:
			pass
		il_selected = il.selected
		old_sel_idx = il_selected - il.start
		ml_sel_pos = ml.selected_pos
		nb_positions = len(il)
		midpos = nb_positions >> 1
		if ml_sel_pos <= midpos:
			start = 0
			scroll_up = True
		elif ml_sel_pos < len(ml) - midpos:
			start = ml_sel_pos - midpos
			scroll_up = True if il_selected < position else ml_sel_pos == il_selected
		else:
			start = max(0, len(ml) - nb_positions)
			scroll_up = il.start == 0
		GenericListing._remove_item(self, position, scroll_up)
		il.start = start
		il.end = start + nb_positions
		il.selected = ml_sel_pos
		GenericListing._refresh_more_items(self)
		sel_item_idx = ml_sel_pos - start
		if position == il_selected:
			il[sel_item_idx].selected = True
		if sel_item_idx != old_sel_idx and self._bar is not None:
			self._bar.animate('move', vcenter=self.positions_list[sel_item_idx]._y, duration=self.duration)
		return None

	def do_update(self, position):
		il = self.item_list
		ml = self.menu_list
		if ml.selected is None or il.selected == position:
			return True
		nb_positions = len(self.positions_list)
		midpos = nb_positions >> 1
		ml[position:position + midpos]
		if position <= midpos:
			start = 0
		elif position < len(ml) - midpos:
			start = position - midpos
		else:
			start = max(0, len(ml) - nb_positions)
		end = start + nb_positions
		if self._edited:
			log.error('Changing selection while editing')
		ts = sched.ts
		duration = max(0.001, min(self.duration, ts - self._last_timestamp - 0.12))
		self._last_timestamp = ts
		il[il.selected - il.start].selected = False
		GenericListing._scroll(self, start - il.start, duration, None)
		il[position - start].selected = True
		il_get_focused = il.selected == -1
		il.selected = position
		il.start = start
		il.end = end
		self._refresh_more_items()
		if self._bar is not None:
			if il_get_focused:
				self._bar.animate('move', vcenter=self.positions_list[position - start]._y, duration=0)
				self._bar.show()
			else:
				self._bar.animate('move', vcenter=self.positions_list[position - start]._y, duration=self.duration)
		return None

	def do_add(self, position):
		il = self.item_list
		ml = self.menu_list
		midpos = len(il) >> 1
		if il.selected >= len(ml) - 1 - midpos and len(il) < len(ml):
			GenericListing._scroll(self, 1, self.duration, None)
			il.start += 1
			il.end += 1
			GenericListing._refresh_more_items(self)
			if self._bar is not None:
				self._bar.animate('move', vcenter=self.positions_list[il.selected - il.start]._y, duration=0)
		else:
			GenericListing.do_add(self, position)
		return None

	def do_swap(self, i1, i2):
		ml = self.menu_list
		il = self.item_list
		nb_positions = len(il)
		sel_index = ml.selected_pos
		ml[sel_index:sel_index + nb_positions]
		midpos = nb_positions >> 1
		if sel_index < midpos:
			start = 0
		elif sel_index < len(ml) - midpos:
			start = sel_index - midpos
		else:
			start = max(0, len(ml) - nb_positions)
		if not GenericListing._swap_items(self, i1, i2):
			return self.do_reset()
		GenericListing._scroll(self, start - il.start, self.duration, ml.selected)
		il.selected = sel_index
		il.start = start
		il.end = start + nb_positions
		if self._bar is not None:
			self._bar.animate('move', vcenter=self.positions_list[sel_index - start]._y, duration=0)
		return None
