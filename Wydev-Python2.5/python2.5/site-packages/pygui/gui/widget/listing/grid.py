# -*- coding: utf-8 -*- 
#
# Description:
#
# Gui Widget Listing Grid Class Definition
#
#
#
# Changes:
#
# 2014-04-07
# Initial Commit
#
#
# Copyright 2010-2014, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.


from __future__ import absolute_import, with_statement

from math import ceil
from wyvas import render_lock
from pygui.gui.widget.listing.items import ItemList
from pygui.gui.widget.listing.style_default import DefaultListing
from pygui.gui.widget.listing.style_fixed import FixedListing

# View over a part of an pygui.item.containers.ItemList.
# 
# Used to fool Listing widgets into believing an ItemList is
# actually a slice of another, beginning at [offset]
# with a step of [step].
# 
# So an _ILView over [1, 2, 3, 4, 5, 6] with an offset of 1
# and a step of 2 will give [2, 4, 6].
# 
# Other than that, it mimics most of a read-only,
# inert ItemList's behavior.
# 
# XXX Maybe this should be moved to pygui.item.containers?
class _ILView(object):

	def __init__(self, item_list, offset=0, step=1):
		self._item_list = item_list
		self.offset = offset
		self.step = step
		self.cyclic = False

	@property
	def menu(self):
		return self._item_list.menu

	@property
	def selected_pos(self):
		actual_sp = self._item_list.selected_pos
		if (actual_sp - self.offset) % self.step == 0:
			return (actual_sp - self.offset) / self.step
		return -1

	@property
	def selected(self):
		selected_pos = self.selected_pos
		if selected_pos != -1:
			return self[selected_pos]
		return None

	def __getitem__(self, k):
		if isinstance(k, slice):
			if k.start is None:
				start = self.offset
			else:
				start = k.start * self.step + self.offset
			if k.stop is None:
				stop = None
			else:
				stop = start + (k.stop - (k.start if k.start else 0)) * self.step
			if k.step is None:
				step = self.step
			else:
				step = k.step * self.step
			return self._item_list[start:stop:step]
		elif isinstance(k, int):
			return self._item_list[k * self.step + self.offset]
		else:
			raise TypeError('_ILView object only supports indexing with ints or slices.')
		return None

	def __setitem__(self, k, value):
		raise TypeError('_ILView object does not support item assignment.')

	def __delitem__(self, k):
		raise TypeError('_ILView object does not support item deletion.')

	def __iter__(self):
		return iter(self._item_list[self.offset::self.step])

	def __len__(self):
		source_len = len(self._item_list)
		return int(ceil((source_len - self.offset) / float(self.step)))



# Grid widget.
# 
# Implemented as a DefaultListing containing [user-set style] listings.
# Each column is made to scroll by the Grid when necessary.
# 
# Requires a L{pygui.item.containers.ItemGrid} as its underlying model.
class Grid(DefaultListing):

	pre_positions = None
	post_positions = None

	# Overridden because DefaultListing must only see the positions
	# of the sub-lists, not those of the items.
	# 
	# (self.positions_list is assigned in create_content)
	def set_positions(self, positions):
		self._all_positions = positions
		return None

	# Overridden because we use params with a plural name, which
	# are expected to be sequences of tuples, unlike the single
	# tuples use dby regular listings.
	def set_extra_positions(self, pre_positions=None, post_positions=None):
		if pre_positions:
			self.pre_positions = pre_positions
		if post_positions:
			self.post_positions = post_positions
		return None

	# This one bypasses GenericListing._create_content completely
	def create_content(self):
		if self._initialized:
			return None
		self._initialized = True
		pl = self._all_positions
		row_length, self.row_length = self.menu_list.row_length, self.menu_list.row_length
		col_length = len(pl) / row_length
		items = []
		positions = []
		with render_lock:
			for i in xrange(row_length):
				start = row_length * i
				end = start + col_length
				if self.style_name.endswith('_fixed'):
					item = FixedListing()
				else:
					item = DefaultListing()
				item.name = '%s_column%i' % (self.name, i)
				item.style_name = self.style_name
				item.style_dict = self.style_dict
				item.set_positions(pl[i::row_length])
				if self.pre_positions:
					item.set_extra_positions(pre_position=self.pre_positions[i])
				if self.post_positions:
					item.set_extra_positions(post_position=self.post_positions[i])
				item.initialize(None, None, _ILView(self.menu_list, i, row_length))
				items.append(item)
				self.add_child(item, left='0%', top='0%', height='100%', width='100%')
				positions.append(('0%', '0%'))
		self.item_list = ItemList(items, 0, col_length, 0)
		self.positions_list = positions
		return None

	def do_update(self, position):
		current_column = self.item_list.selected
		current_row = self.item_list[current_column].item_list.selected
		updated_row = position // self.row_length
		updated_column = position - updated_row * self.row_length
		col_length = len(self.positions_list)
		with render_lock:
			for column, item in enumerate(self.item_list):
				if column == updated_column:
					item.do_update(updated_row)
				else:
					item.do_update(-1, updated_row)
		self.item_list.selected = updated_column
		return None

	def do_remove(self, position):
		row = position // self.row_length
		column = position - row * self.row_length
		selected_row = self.menu_list.selected_row
		with render_lock:
			for index, item in enumerate(self.item_list):
				if index == column:
					item.do_remove(row)
				else:
					item.do_reset()
					item.do_update(-1, selected_row)
		return None

	def do_reset(self, position=None):
		if position is None:
			with render_lock:
				selected_row = self.menu_list.selected_row
				selected_column = self.menu_list.selected_column
				for column, item in enumerate(self.item_list):
					item.do_reset()
					if column != selected_column:
						item.do_update(-1, selected_row)
		else:
			row = position // self.row_length
			column = position - row * self.row_length
			if column == self.menu_list.selected_column:
				self.item_list[column].do_reset(row)
			else:
				self.item_list[column].do_reset(row, focus=row)
		return None

	# x, y: integers in [0 .. 100], representing picked position.
	# return: index (in the model) of the picked element.
	def pick(self, x, y):
		col_index = DefaultListing.pick(self, x)
		row_index = self.item_list[col_index].pick(y)
		return row_index * self.row_length + col_index

	# forward: if True, forward jump (else backward jump of course).
	# return: new pos if a page jump happened (so it doesn't jump !).
	def page_jump(self, forward):
		il = self.item_list
		ml = self.menu_list
		pl = self._all_positions
		row_length = self.row_length
		col_length = len(pl) / row_length
		pos = ml.selected_pos
		if forward:
			ml = self.menu_list
			new_pos = pos + row_length * col_length
			ml[pos:new_pos]
			return min(new_pos, len(ml) - 1)
		else:
			new_pos = pos - row_length * col_length
			return max(0, new_pos)

	def do_enable_selection(self, select):
		if self._no_selection != select:
			return None
		self._no_selection = not select
		if not select:
			for sublist in self.item_list:
				sublist.do_enable_selection(False)
		else:
			sublists = self.item_list
			sublists[sublists.selected].do_enable_selection(True)
			for sublist in self.item_list:
				sublist._no_selection = False
		return None
