# -*- coding: utf-8 -*- 
#
# Description:
#
# Gui Widget Listing Core Class Definition
#
#
#
# Changes:
#
# 2014-04-07
# Initial Commit
#
#
# Copyright 2010-2014, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.


from __future__ import absolute_import, with_statement

__all__ = ['GenericListing']

from peewee.debug import GET_LOGGER, PRINT_EXCEPTION
from peewee.messages import send
from pygui.widget.listing.items import class_item_name_dict, ItemList
from wyvas import Container, render_lock

log = GET_LOGGER(__name__)


# Listing widget.
class GenericListing(Container):

	_initialized = False
	_bar = None
	item_list = None
	positions_list = [('20%', '20%'), ('50%', '50%'), ('80%', '80%')]
	pre_position = None
	post_position = None
	_centered = False
	_selected = 0
	duration = 0.0
	_edited = False
	_more_items_before = None
	_more_items_after = None
	_no_selection = False
	_reversed_update = False
	_anim_type = 'linear'
	_activate_fade = True
	_cyclic = True
	update_handlers = dict(update='do_update', reset='do_reset', add='do_add', mark='do_mark', remove='do_remove', edit='do_edit', swap='do_swap', enable_selection='do_enable_selection')

	# Init the listing widget. Additional args are defined by the different
	# _init functions for the specific style (text or image).
	def __init__(self):
		Container.__init__(self)
		self.style_dict = dict(font_style='font=Vera font_size=18', text_color=(255, 255, 255, 255), text_size=('100%', '100%'), selected_font_style='font=Vera font_size=20', selected_text_color=(255, 255, 255, 255), selected_text_size=('100%', '100%'), unsensitive_font_style='font=Vera font_size=18', unsensitive_text_color=(255, 255, 255, 255), unsensitive_text_size=('100%', '100%'), repository='', icon_size=('100%', '100%'), selected_icon_size=('100%', '100%'), unsensitive_icon_size=('100%', '100%'), item_size=('100%', '100%'), selected_item_size=('100%', '100%'), progress_bar_background='', progress_bar_foreground='', progress_bar_offset=('0%', '0%'), progress_bar_size=('5%', '100%'), rec_icon='', rec_icon_offset=('75%', '0%'), time_offset=('5%', '0%'), time_font_style='font=Gill font_size=20 align=left', time_color=(128, 0, 64, 255), title_font_style='font=Gill font_size=20 align=left wrap=char', title_color=(128, 128, 128, 255), selected_time_font_style='font=Gill font_size=24 align=left', selected_time_color=(255, 0, 128, 255), selected_title_font_style='font=Gill font_size=24 align=left wrap=char', selected_title_color=(255, 255, 255, 255), selected_blurb_time_font_style='font=Gill font_size=24 align=left', selected_blurb_time_color=(255, 0, 128, 255), selected_blurb_title_font_style='font=Gill font_size=24 align=left wrap=char', selected_blurb_title_color=(255, 255, 255, 255), selected_blurb_text_offset=('0%', '14%'), selected_blurb_offset=('-2%', '1%'), selected_blurb_zoom='110%', selection_cursor_image='', preserve_icon_aspect=0, preserve_icon_size=0, marker_image=None, selected_marker_image=None, marker_offset=('0%', '0%'), marker_size=('100%', '10%'), centered=False, text_offset=('0%', '4%'), selected_text_offset=('0%', '14%'), enumerated=False, edit_offset=20, duration=1, opacity=255, maxlen=20, extension=('png',), autoscroll=True, page_jump='reset', pos_policy='position', fade_pre_post=True)
		return None

	# Update the style dict, this dict is shared between list elements and the list itself
	def update_style(self, **kwargs):
		self.style_dict.update(kwargs)
		return None

	# Add reference positions for the items. Each value of positions must be a tuple
	# of integer, such as (x,y) with x and y value of top left corner or center (depend configuration)
	# The Number of defined positions determine the number of items displayed
	def set_positions(self, positions=None):
		self.positions_list = positions
		return None

	# Set the position of the selected item
	def set_selected_item(self, selected_item=0):
		self._selected = selected_item
		return None

	# Set if we must center objects or not
	def set_centered(self, centered=False):
		self._centered = centered
		self.style_dict['centered'] = centered
		return None

	# Set the base duration for animations
	def set_duration(self, duration=0.0):
		self.duration = duration
		self.style_dict['duration'] = duration
		return None

	# Fix the bar (highlight) name
	def set_bar(self, bar):
		self._bar = self.get_obj_by_name(bar)
		return None

	# "repository" is a directory where application will found icons and images relatives to displayed items
	def set_repository(self, repository=None):
		self.repository = repository
		self.style_dict['repository'] = repository
		return None

	# Set the "before first" and "after last" virtual positions
	def set_extra_positions(self, pre_position=None, post_position=None):
		if pre_position is not None:
			self.pre_position = pre_position
		if post_position is not None:
			self.post_position = post_position
		return None

	def set_reversed_update(self, reversed_update=True):
		self._reversed_update = reversed_update
		return None

	def set_anim_type(self, anim_type='linear'):
		if anim_type in ('linear', 'log', 'exp', 'samples', 'easein', 'easeout', 'easeinout', 'bounce'):
			self._anim_type = anim_type
		else:
			log.error('Invalid anim_type (linear, log, exp, samples, easein, easeout, easeinout, bounce): %s', anim_type)
		return None

	def set_cyclic(self, cyclic=False):
		self._cyclic = cyclic
		return None

	# Interface to signals, dispatch the signal according to "action"
	def update(self, signal, sender, value, action=None, **kw):
		self.menu_list = value
		if action is not None:
			try:
				getattr(self, GenericListing.update_handlers[action])(**kw)
			except Exception, e:
				PRINT_EXCEPTION(e, True)
		return None

	# Create the list for the first time
	def initialize(self, signal, sender, value, **kw):
		self.menu_list = value
		self.create_content()
		self.do_reset()
		if not self._initialized:
			_op = self.style_dict['opacity']
			self.set_color(a=_op)
			self._initialized = True
		return None

	def unparent(self):
		self.menu_list = None
		Container.unparent(self)
		return None

	# Clear everything
	def clear(self):
		self.menu_list = None
		for it in self.item_list:
			it.destroy()
		try:
			self._hidden_item.destroy()
		except:
			pass
		return None

	# Mark the selected item
	def do_mark(self, position=None):
		ml = self.menu_list
		if not ml or position < 0:
			return None
		il = self.item_list
		if il.start <= position < il.end:
			il[position - il.start].marked = ml[position].is_marked()
		return None

	# update the list to reflect a selection change
	def do_update(self, position):
		log.error('do update NOT IMPLEMENTED')
		return None

	# Visually inserts the element at specified position
	def do_add(self, position):
		il = self.item_list
		if il.start <= position < il.end:
			return self._refresh_more_items()
		new_item = self.menu_list[position]
		new_index = position - il.start
		new_comer = il[new_index]
		new_pos = self.positions_list[new_index]
		new_comer.widget.animate_stop()
		new_comer.reset(new_item, False, position=position + 1)
		self.post_position.put(new_comer)
		new_comer.fade_in()
		new_pos.move(new_comer, self.duration)
		return None

	# Redraw the element at specified position (if unspecified, redraw everything)
	def do_reset(self, position=None, focus=None):
		log.error('do reset NOT IMPLEMENTED')
		return None

	# Remove the element at specified position
	def do_remove(self, position):
		log.error('do remove NOT IMPLEMENTED')
		return None

	# Create the list content, called by initialize
	def create_content(self):
		log.error('create_content NOT IMPLEMENTED')
		return None

	# Switch list to edit_mode or not
	def do_edit(self, edit_mode):
		il = self.item_list
		if self._edited != edit_mode:
			self._edited = edit_mode
			il[il.selected - il.start].edited = edit_mode
		return None

	# Swap two elements of the list
	def do_swap(self, i1, i2):
		log.error('do swap NOT IMPLEMENTED')
		return None

	def _create_content(self, start, style_name):
		pos_klass = position_klasses[self.style_dict['pos_policy']]
		pl = [pos_klass(self, pos) for pos in self.positions_list]
		self.positions_list = pl
		self._activate_fade = self.style_dict['fade_pre_post']
		if self.pre_position is None:
			self.pre_position = pl[0]
		else:
			self.pre_position = pos_klass(self, self.pre_position)
		if self.post_position is None:
			self.post_position = pl[-1]
		else:
			self.post_position = pos_klass(self, self.post_position)
		item_creator = class_item_name_dict[style_name]
		self.item_list = ItemList([item_creator(self.style_dict) for i in pl], start, start+len(pl), self.menu_list.selected_pos)
		for pos, ui_item in zip(pl, self.item_list):
			self.add_child(ui_item.widget, pos.get_kwargs())
		self._hidden_item = item_creator(self.style_dict)
		self.add_child(self._hidden_item.widget)
		if self._cyclic:
			self._cyclic = self.menu_list.cyclic
		if self._bar is not None:
			self._bar.hide()
			self._bar.move(vcenter=pl[self._selected]._y)
		return None

	# Scroll self.item_list items.
	# move: count of items that will appear (and disappear). A positive
	#       move indicates a scrolling up, a negative one a scrolling down.
	# duration: duration of each basic move.
	# selected: item of the menu_list which is selected, in order to select
	#           the corresponding Item ; None is no Item has to be
	#           selected (used by FixedListing).
	def _scroll(self, move, duration, selected):
		if move == 0:
			return None
		il = self.item_list
		ml = self.menu_list
		pl = self.positions_list
		old_start = il.start
		old_end = il.end
		index_offset = 1
		cyclic = self._cyclic
		if abs(move) > len(il):
			new_start = old_start + move
			new_end = old_end + move
			if move > 0:
				ml = [None] * old_end + ml[new_start:new_end]
				hole_size = new_start - old_end
				move -= hole_size
				index_offset += hole_size
			else:
				ml = ml[max(0, new_start):new_end] + [None] * abs(new_start)
				hole_size = old_start - new_end
				move += hole_size
				old_start -= hole_size
				old_end -= hole_size
			cyclic = False
		if move > 0:
			outsider_pos = self.pre_position
			new_comer_pos = self.post_position
			outsider_idx = 0
			new_comers_indices = (old_end + i for i in (xrange(move))
			new_comer_idx = len(il)
			try:
				ml[old_end + move]
			except IndexError:
				pass
		else:
			outsider_pos = self.post_position
			new_comer_pos = self.pre_position
			outsider_idx = -1
			new_comers_indices = (old_start - i for i in (xrange(1, -move + 1))
			new_comer_idx = 0
		render_lock.__enter__()
		try:
			len_ml = len(ml)
			if cyclic:
				cyclic = len_ml > 2
			for new_item_idx in new_comers_indices:
			outsider = il.pop(outsider_idx)
			outsider.widget.animate_stop()
			outsider_pos.move(outsider, duration)
			if not self._activate_fade:
				outsider.active_widget.hide()
				outsider.widget.get_obj_by_name('marker').hide()
			else:
				outsider.fade_out()
			new_comer = self._hidden_item
			self._hidden_item = outsider
			new_comer.widget.animate_stop()
			il.insert(new_comer_idx, new_comer)
			if 0 <= new_item_idx < len_lm:
				new_item = ml[new_item_idx]
				new_comer.reset(new_item, new_item is selected, position=new_item_idx + index_offset)
			else:
				if cyclic is True:
					new_item = ml[new_item_idx % len_ml]
					new_comer.reset(new_item, new_item is selected, position=new_item_idx + index_offset)
				else:
					new_comer.destroy()
			if not self._activate_fade:
				new_comer.active_widget.show()
				if new_comer._marked:
					new_comer.widget.get_obj_by_name('marker').show()
			else:
				new_comer.fade_in()
			new_comer_pos.put(new_comer)
			for ui_item, pos in zip(il, pl):
				ui_item.widget.animate_stop()
				pos.move(ui_item, duration)
		finally:
			render_lock.__exit__()
		return None

	# Swap 2 items of self.item_list.
	# i1, i2: indices of the 2 corresponding menu items in self.menu_list.
	# return: a boolean value indicates if swapping has been done ;
	#         if not, a do_reset() should be done.
	def _swap_items(self, i1, i2):
		il = self.item_list
		ml = self.menu_list
		pl = self.positions_list
		nb_positions = len(pl)
		start = il.start
		item_index1 = i1 - start
		item_index2 = i2 - start
		if 0 <= item_index1 < nb_positions:
		in_page1 = (0 <= item_index1 < nb_positions)
		in_page2 = (0 <= item_index2 < nb_positions)
		if in_page1 ^ in_page2:
			return False
		if not(in_page1 and in_page2):
			return True
		render_lock.__enter__()
		try:
			selected = ml.selected
			for ui_item, pos, menu_item_idx in ((il[item_index1], pl[item_index2], i2), (il[item_index2], pl[item_index1], i1)):
				ui_item.widget.animate_stop()
				pos.move(ui_item, self.duration)
				ui_item.set_position(menu_item_idx + 1)
		finally:
			render_lock.__exit__()
		il[item_index2], il[item_index1] = il[item_index1], il[item_index2]
		return True

	# Remove one items in self.item_list.
	# Beware: it uses self.item_list.start/end as the old values (before
	#         removing item), so modify these values AFTER calling this method.
	# position: index (in self.menu_list) of the removed item.
	# scroll_up: boolean indicating if hole must be filled by scrolling up
	#           items (ie: if False, we scroll down items).
	def _remove_item(self, position, scroll_up):
		il = self.item_list
		ml = self.menu_list
		selected = ml.selected
		start = il.start
		end = il.end
		if start <= position < end:
			outsider = il.pop(position - start)
			outsider.selected = False
		else:
			if scroll_up:
				if position >= end:
					return None
				outsider = il.pop(0)
				outsider_position = self.pre_position
			else:
				if position < start:
					for i, ui_item in enumerate(il):
						ui_item.set_position(start + i)
					return None
				outsider = il.pop()
				outsider_position = self.post_position
			outsider_position.move(ui_item, self.duration)
		outsider.fade_out()
		newcomer = self._hidden_item
		self._hidden_item = outsider
		newcomer.widget.animate_stop()
		if scroll_up:
			il.append(newcomer)
			if len(ml) >= end:
				new_item = ml[end - 1]
			else:
				new_item = None
			newcomer_position = self.post_position
		else:
			il.insert(0, newcomer)
			if start > 0:
				new_item = ml[start - 1]
			else:
				new_item = None
			newcomer_position = self.pre_position
		newcomer_position.put(newcomer)
		if new_item is not None:
			newcomer.reset(new_item, new_item is selected)
		else:
			newcomer.destroy()
		newcomer.fade_in()
		if scroll_up:
			idx_offset = 1
		else:
			idx_offset = 0
		duration = self.duration
		for i, ui_item in enumerate(zip(il, self.positions_list)):
			pos.move(ui_item, duration)
			ui_item.set_position(start + i + idx_offset)
		return None

	# Refresh the upper/lower "more items" sigils
	# (ellipses, arrows, whatever, pick your poison).
	def _refresh_more_items(self):
		il = self.item_list
		ml = self.menu_list
		menu = ml.menu
		mib = il.start > 0
		if mib:
			if self._more_items_before is not True:
				send('%s_more_items_before' % self.name, menu)
		else:
			if self._more_items_before is not False:
				send('%s_no_more_items_before' % self.name, menu)
		self._more_items_before = mib
		mia = len(ml) > il.end
		if mia:
			if self._more_items_after is not True:
				send('%s_more_items_after' % self.name, menu)
		else:
			if self._more_items_after is not False:
				send('%s_no_more_items_after' % self.name, menu)
		self._more_items_after = mia
		return None

	# ratio: integer in [0 .. 100], representing picked position.
	# return: index (in the model) of the picked element.
	def pick(self, ratio):
		nb_positions = len(self.positions_list)
		pos = ratio // 100 // nb_positions
		if pos >= nb_positions:
			pos = nb_positions - 1
		return min(pos + self.item_list.start, len(self.menu_list) - 1)

	# forward: if True, forward jump (else backward jump of course).
	# return: new pos if a page jump happened (so it doesn't jump !).
	def page_jump(self, forward):
		il = self.item_list
		if forward:
			ml = self.menu_list
			pos = il.selected
			new_pos = pos + len(il)
			ml[pos:new_pos]
			return min(new_pos, len(ml) - 1)
		else:
			return max(0, il.selected - len(il))
		return None

	def do_enable_selection(self, select):
		il = self.item_list
		il[max(0, il.selected - il.start)].selected = select
		self._no_selection = not select
		if self._bar is not None:
			if select and len(self.menu_list):
				self._bar.show()
			else:
				self._bar.hide()
		return None



class Position(object):

	__slots__ = ('_x', '_y', '_move_dic', '_anim_type')

	def __init__(self, listing, x, y):
		self._x = x
		self._y = y
		if listing._centered:
			xkey, ykey = ('hcenter', 'vcenter')
		else:
			xkey, ykey = ('left', 'top')
		self._move_dic = {xkey: x, ykey: y}
		self._anim_type = listing._anim_type
		return None

	def get_kwargs(self):
		return self._move_dic

	def put(self, ui_item):
		ui_item.widget.move(**self._move_dic)
		return None

	def move(self, ui_item, duration):
		ui_item.widget.animate('move', duration=duration, step_type=self._anim_type, **self._move_dic)
		return None



class LayerPosition(Position):

	__slots__ = ('_x', '_y', '_move_dic', '_anim_type', '_layer')

	def __init__(self, listing, x, y, layer):
		Position.__init__(self, listing, x, y)
		if not isinstance(layer, int):
			print 'Invalid position (x, y, layer):',
			print x,
			print y,
			print layer
			layer = 0
		self._layer = layer
		return None

	def get_kwargs(self):
		kwargs = dict(self._move_dic)
		kwargs['layer'] = self._layer
		return kwargs

	def put(self, ui_item):
		Position.put(self, ui_item)
		ui_item.widget.set_layer(self._layer)
		return None

	def move(self, ui_item, duration):
		Position.move(self, ui_item, duration)
		ui_item.widget.set_layer(self._layer)
		return None



class SizePosition(Position):

	__slots__ = ('_x', '_y', '_move_dic', '_anim_type', '_width', '_height')

	def __init__(self, listing, x, y, width, height):
		Position.__init__(self, listing, x, y)
		self._width = width
		self._height = height
		return None

	def put(self, ui_item):
		Position.put(self, ui_item)
		ui_item.active_widget.resize(width=self._width, height=self._height)
		return None

	def move(self, ui_item, duration):
		Position.move(self, ui_item, duration)
		ui_item.active_widget.animate('size', width=self._width, height=self._height, step_type=self._anim_type, duration=duration)
		return None



class PerspectivePosition(Position):

	__slots__ = ('_x', '_y', '_move_dic', '_anim_type', '_layer', '_width', '_height')

	def __init__(self, listing, x, y, width, height, layer):
		Position.__init__(self, listing, x, y)
		if not isinstance(layer, int):
			print 'Invalid position: (x, y, width, height, layer)',
			print x,
			print y,
			print width,
			print height,
			print layer
			layer = 0
		self._layer = layer
		self._width = width
		self._height = height
		return None

	def get_kwargs(self):
		kwargs = dict(self._move_dic)
		kwargs['layer'] = self._layer
		return kwargs

	def put(self, ui_item):
		Position.put(self, ui_item)
		ui_item.active_widget.resize(width=self._width, height=self._height)
		ui_item.widget.set_layer(self._layer)
		return None

	def move(self, ui_item, duration):
		Position.move(self, ui_item, duration)
		ui_item.active_widget.animate('size', width=self._width, height=self._height, step_type=self._anim_type, duration=duration)
		ui_item.widget.set_layer(self._layer)
		return None



position_klasses = {'position': Position, 'layer': LayerPosition, 'size': SizePosition, 'perspective': PerspectivePosition}
