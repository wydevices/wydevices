# -*- coding: utf-8 -*- 
#
# Description:
#
# Gui Widget Listing Epg Item Class Definition
#
#
#
# Changes:
#
# 2014-04-07
# Initial Commit
#
#
# Copyright 2010-2014, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.


from __future__ import absolute_import, with_statement

from itertools import izip
from time import time
import peewee.messages as louie
from wyrecord.recording import RECORDING_STATUS_SCHEDULED, RECORDING_STATUS_RUNNING
from wyvas import Container, Image, render_lock
from peewee.formatters import seconds_to_hhmm
from pygui.facilities import timeslices as ts
from pygui.item.mediaitem.tv import RECS_TO_DISPLAY
from pygui.gui.widget.textblock import TextBlock
from pygui.gui.widget.listing.ui_items import UIItem


# Return (start_time, end_time) tuples based on
# those in programs, except that the following constraints are
# applied:
# 
# 1. No program may have an apparent duration of less than min_duration seconds
# 2. The sum of durations should be close to the sum of the original
# programs' duration (we try to shave extra seconds added because of 1.
# off larger programs).
# 
# Note that 2. is *not* guaranteed, and that seconds are shaved off previous
# programs if the larger programs are in the first half of the list, or off
# the following programs otherwise.
# 
# In addition, if the global_start_time and/or global_end_time arguments are
# supplied, adjust_durations will substitute any starting times earlier
# than global_start_time with global_start_time, and any ending times later
# than global_end_time with global_end time, *before* running its calculations.
def adjust_durations(programs, min_duration=700, global_start_time=None, global_end_time=None):
	out = []
	missing_seconds = 0
	if not programs:
		return out
	if not global_start_time:
		global_start_time = programs[0].start_time
	if not global_end_time:
		global_end_time = programs[-1].end_time
	midpoint = max(programs[len(programs) / 2].start_time, global_start_time)
	use_reverse = midpoint > (global_start_time + global_end_time) / 2
	if use_reverse:
		programs = reversed(programs)
	for prog in programs:
		prog_start_time = max(prog.start_time, global_start_time)
		prog_end_time = min(prog.end_time, global_end_time)
		prog_duration = prog_end_time - prog_start_time
		if use_reverse:
			end_time = prog_end_time - missing_seconds
		else:
			start_time = prog_start_time + missing_seconds
		if prog_duration < min_duration:
			duration = min_duration
			missing_seconds += min_duration - prog_duration
		else:
			duration = max(prog_duration - missing_seconds, min_duration)
			missing_seconds -= prog_duration - duration
		if use_reverse:
			start_time = end_time - duration
		else:
			end_time = start_time + duration
		out.append((start_time, end_time))
	if use_reverse:
		out.reverse()
	return out



# A widget that displays information about a single TV program:
#     - start time
#     - title
class ProgramBlurb(Container):

	# Create a ProgramBlurb.
	# The style dict must have all the keys specified in set_style.
	# It may also have the following keys:
	#     - maxlen: maximum text length for the title text block.
	#     - progress_bar_foreground: progress bar picture.
	#     - progress_bar_background: progress bar background picture.
	#     - progress_bar_offset: offset for the progress bar in (left, top)
	#       format (0%, 0% is the ProgramBlurb's top left corner).
	#     - progress_bar_size: progress bar's size.
	#     - rec_icon: "scheduled for recording" picture.
	def __init__(self, style, **kwargs):
		Container.__init__(self, **kwargs)
		self.start_time_display = TextBlock()
		self.title_display = TextBlock(max_width=style.get('maxlen', None))
		self.rec_icon = Image(repository=style['repository'], image_or_file=style['rec_icon'])
		self.rec_icon.set_keep_real_size(False)
		self.rec_status = False
		self.progress_bar = Container()
		self.progress_bar_fg = Image(repository=style['repository'], image_or_file=style['progress_bar_foreground'])
		self.progress_bar_fg.set_keep_real_size(False)
		self.progress_bar_bg = Image(repository=style['repository'], image_or_file=style['progress_bar_background'])
		self.progress_bar_bg.set_keep_real_size(False)
		self.progress_bar.add_child(self.progress_bar_bg, top='0%', left='0%', height='100%', width='100%', aspect=False)
		self.progress_bar.add_child(self.progress_bar_fg, top='0%', left='0%', height='100%', width='100%', aspect=False)
		bar_left, bar_top = style['progress_bar_offset']
		bar_width, bar_height = style['progress_bar_size']
		self.add_child(self.progress_bar, top=bar_top, left=bar_left, height=bar_height, width=bar_width, layer=-1)
		self.add_child(self.rec_icon, height='0%', width='0%')
		self.add_child(self.start_time_display)
		self.add_child(self.title_display)
		self.set_style(style)
		return None

	# Change the ProgramBlurb's style.
	# The style dict must have the following keys:
	#     - time_font_style
	#     - time_color
	#     - time_offset
	#     - title_font_style
	#     - title_color
	#     - text_offset
	#     - rec_icon_offset
	# Their names are, I believe, self-explanatory.
	def set_style(self, style):
		self.start_time_display.set_style(style=style['time_font_style'])
		self.start_time_display.set_color(color=style['time_color'])
		time_left, time_top = style['time_offset']
		self.start_time_display.move(top=time_top, left=time_left)
		self.title_display.set_style(style=style['title_font_style'])
		self.title_display.set_color(color=style['title_color'])
		title_left, title_top = style['text_offset']
		title_width = '%i%%' % (100 - int(title_left.rstrip('%')))
		self.title_display.move(top=title_top, left=title_left)
		self.title_display.resize(width=title_width)
		rec_icon_left, rec_icon_top = style['rec_icon_offset']
		self.rec_icon.move(top=rec_icon_top, left=rec_icon_left)
		return None

	# Set the program's progress to n percent
	def set_progress(self, n):
		self.progress_bar_fg.resize(height='%i%%' % n)
		return None

	# Set the "scheduled for recording" property of this blurb.
	# If True, a specific pictogram will be displayed next to the program's name.
	def set_record(self, record):
		if record and not self.rec_status:
			self.rec_icon.set_keep_real_size(True)
			self.rec_icon.resize(width='100%')
		elif self.rec_status and not record:
			self.rec_icon.set_keep_real_size(False)
			self.rec_icon.resize(width='0%')
		self.rec_status = record
		return None

	# Reset(timestamp, string): Reset the ProgramBlurb to display the requested info.
	# 
	# The record argument is a shortcut for the set_record method.
	def reset(self, start_time, name, record=False):
		self.start_time_display.set_text(seconds_to_hhmm(start_time))
		self.title_display.set_text(name)
		self.set_record(record)
		return None



# A list item that displays an electronic program guide for one channel.
class EPGItem(UIItem):

	__slots__ = ['_selected', '_marked', '_position', '_edited', 'widget', 'style', 'channel', 'start_ts', 'end_ts', 'displayed_programs', 'adjusted_durations', 'selected_program', '_not_selected_widget', '_selected_widget', 'selection_cursor', 'blurbs', 'spare_selected_blurbs', 'spare_not_selected_blurbs', '__weakref__']

	not_selected_style = property((lambda self: {'repository': self.style['repository'], 'progress_bar_offset': self.style['progress_bar_offset'], 'progress_bar_size': self.style['progress_bar_size'], 'progress_bar_background': self.style['progress_bar_background'], 'progress_bar_foreground': self.style['progress_bar_foreground'], 'time_offset': self.style['time_offset'], 'time_font_style': self.style['time_font_style'], 'time_color': self.style['time_color'], 'title_font_style': self.style['title_font_style'], 'title_color': self.style['title_color'], 'text_offset': self.style['text_offset'], 'rec_icon': self.style['rec_icon'], 'rec_icon_offset': self.style['rec_icon_offset'], 'maxlen': self.style['maxlen']}))
	selected_style = property((lambda self: {'repository': self.style['repository'], 'progress_bar_offset': self.style['progress_bar_offset'], 'progress_bar_size': self.style['progress_bar_size'], 'progress_bar_background': self.style['progress_bar_background'], 'progress_bar_foreground': self.style['progress_bar_foreground'], 'time_offset': self.style['time_offset'], 'time_font_style': self.style['selected_time_font_style'], 'time_color': self.style['selected_time_color'], 'title_font_style': self.style['selected_title_font_style'], 'title_color': self.style['selected_title_color'], 'text_offset': self.style['selected_text_offset'], 'rec_icon': self.style['rec_icon'], 'rec_icon_offset': self.style['rec_icon_offset'], 'maxlen': self.style['maxlen']}))
	selected_program_style = property((lambda self: {'repository': self.style['repository'], 'time_offset': self.style['time_offset'], 'time_font_style': self.style['selected_time_font_style'], 'time_color': self.style['selected_blurb_time_color'], 'title_font_style': self.style['selected_title_font_style'], 'title_color': self.style['selected_blurb_title_color'], 'text_offset': self.style['selected_blurb_text_offset'], 'rec_icon': self.style['rec_icon'], 'rec_icon_offset': self.style['rec_icon_offset'], 'maxlen': self.style['maxlen']}))

	# Set_boundaries(datetime, datetime)
	# 
	# Set the boundaries of the EPGItem. It will display any
	# programs from self.channel that start before end_ts
	# and end after start_ts.
	def set_boundaries(self, start_ts, end_ts):
		self.start_ts = start_ts
		self.end_ts = end_ts
		if self.channel:
			progs = self.channel.browse(start_ts, end_ts, limit=10, pad=True, focus=time())
		else:
			progs = []
		with render_lock:
			self.set_programs(progs)
			self.set_selected_program(-1)
		return None

	def set_programs(self, progs):
		ns_visible = self._not_selected_widget.get_visible()
		s_visible = self._selected_widget.get_visible()
		total_duration = self.end_ts - self.start_ts
		if 0 <= self.selected_program <= len(self.displayed_programs):
			selected_program_item = self.displayed_programs[self.selected_program]
		else:
			selected_program_item = None
		old_programs = set(self.displayed_programs)
		self.displayed_programs[:] = progs
		for program in old_programs.difference(progs):
			selected_blurb, not_selected_blurb = self.blurbs.pop(program.id)
			if program is selected_program_item:
				selected_blurb.set_style(self.selected_style)
			selected_blurb.hide()
			selected_blurb.orphaned()
			self.spare_selected_blurbs.add(selected_blurb)
			not_selected_blurb.hide()
			not_selected_blurb.orphaned()
			self.spare_not_selected_blurbs.add(not_selected_blurb)
		self.adjusted_durations = adjust_durations(progs, global_start_time=self.start_ts, global_end_time=self.end_ts)
		for program, start_time in izip(progs, self.adjusted_durations):
			if program.start_time < self.start_ts:
				displayed_start_time, start_time = self.start_ts, self.start_ts
				name = u'\u2026\n%s' % program.name
			else:
				displayed_start_time = program.start_time
				name = program.name
			end_time = min(end_time, self.end_ts)
			top = (start_time - self.start_ts) / total_duration * 100
			height = (end_time - start_time) / total_duration * 100
			rec = program.recording_status in RECS_TO_DISPLAY
			if program in old_programs:
				selected_blurb, not_selected_blurb = self.blurbs[program.id]
				selected_blurb.reset(displayed_start_time, name, rec)
				selected_blurb.move(duration=0, top='%i%%' % top)
				selected_blurb.resize(duration=0, height='%i%%' % height)
				not_selected_blurb.reset(displayed_start_time, name, rec)
				not_selected_blurb.move(duration=0, top='%i%%' % top)
				not_selected_blurb.resize(duration=0, height='%i%%' % height)
			elif self.spare_selected_blurbs and self.spare_not_selected_blurbs:
				selected_blurb = self.spare_selected_blurbs.pop()
				not_selected_blurb = self.spare_not_selected_blurbs.pop()
				selected_blurb.reset(displayed_start_time, name, rec)
				not_selected_blurb.reset(displayed_start_time, name, rec)
				selected_blurb.adopted(self._selected_widget)
				selected_blurb.move(top='%i%%' % top, left='0%')
				selected_blurb.resize(height='%i%%' % height, width='100%')
				selected_blurb.set_visible(s_visible)
				not_selected_blurb.adopted(self._not_selected_widget)
				not_selected_blurb.move(top='%i%%' % top, left='0%')
				not_selected_blurb.resize(height='%i%%' % height, width='100%')
				not_selected_blurb.set_visible(ns_visible)
				self.blurbs[program.id] = (selected_blurb, not_selected_blurb)
			else:
				selected_blurb = ProgramBlurb(self.selected_style)
				selected_blurb.reset(displayed_start_time, name, rec)
				not_selected_blurb = ProgramBlurb(self.not_selected_style)
				not_selected_blurb.reset(displayed_start_time, name, rec)
				self._not_selected_widget.add_child(not_selected_blurb, name=program.id, top='%i%%' % top, left='0%', height='%i%%' % height, width='100%')
				self._selected_widget.add_child(selected_blurb, name=program.id, top='%i%%' % top, left='0%', height='%i%%' % height, width='100%')
				self.blurbs[program.id] = (selected_blurb, not_selected_blurb)
		self._selected_widget.set_visible(s_visible)
		self._not_selected_widget.set_visible(ns_visible)
		self.update_progress(time())
		return None

	# Marks the [value]th program as selected
	def set_selected_program(self, value):
		if not self.displayed_programs:
			return None
		total_duration = self.end_ts - self.start_ts
		animation_duration = self.style['duration']
		if 0 <= self.selected_program < len(self.displayed_programs):
			current_program = self.displayed_programs[self.selected_program]
			current_widget, _ = self.blurbs[current_program.id]
			start_time, end_time = self.adjusted_durations[self.selected_program]
			start_time = max(self.start_ts, start_time)
			end_time = min(end_time, self.end_ts)
			top = (start_time - self.start_ts) / total_duration * 100
			left = 0
			current_widget.set_style(self.selected_style)
			current_widget.move(duration=animation_duration, top='%i%%' % top, left='%i%%' % left)
			current_widget.resize(duration=animation_duration, width='100%')
		if 0 <= value < len(self.displayed_programs):
			new_program = self.displayed_programs[value]
			new_widget, _ = self.blurbs[new_program.id]
			start_time, end_time = self.adjusted_durations[value]
			start_time = max(self.start_ts, start_time)
			end_time = min(end_time, self.end_ts)
			left_offset, top_offset = (int(x.rstrip('%')) for x in (self.style['selected_blurb_offset']))
			top = (start_time - self.start_ts) / total_duration * 100 + top_offset
			left = left_offset
			new_widget.set_style(self.selected_program_style)
			new_widget.move(duration=animation_duration, top='%i%%' % top, left='%i%%' % left)
			new_widget.resize(duration=animation_duration, width=self.style['selected_blurb_zoom'])
			width, height = new_widget.get_size()
			self.selection_cursor.move(duration=animation_duration, top='%i%%' % top, left='%i%%' % left)
			self.selection_cursor.resize(duration=animation_duration, width=width, height=height)
			self.selection_cursor.set_visible(True)
		else:
			self.selection_cursor.set_visible(False)
		self.selected_program = value
		return None

	# Update the program blurbs' progress bars to match the timestamp given in value.
	def update_progress(self, value):
		for prog in self.displayed_programs:
			selected_blurb, not_selected_blurb = self.blurbs[prog.id]
			start_ts, end_ts = max(prog.start_time, self.start_ts), min(prog.end_time, self.end_ts)
			if value < start_ts:
				progress = 0
			elif value > end_ts:
				progress = 100
			else:
				duration = end_ts - start_ts
				elapsed = value - start_ts
				progress = float(elapsed) / duration * 100
			selected_blurb.set_progress(progress)
			not_selected_blurb.set_progress(progress)
		return None

	# Refresh the "scheduled for recording" status of the selected program blurb
	def update_record(self):
		prog = self.displayed_programs[self.selected_program]
		scheduled = bool(prog.recording_id)
		selected_blurb, not_selected_blurb = self.blurbs[prog.id]
		selected_blurb.set_record(scheduled)
		not_selected_blurb.set_record(scheduled)
		return None

	# It's expected that item is a ChannelItem or an object that behaves as such.
	def reset(self, item, selected, position=None):
		if item is not None:
			self.channel = item
			if self.start_ts and self.end_ts:
				self.set_boundaries(self.start_ts, self.end_ts)
			else:
				start_ts, end_ts = map(ts.datetime_to_timestamp, ts.current_timeslice())
				self.set_boundaries(start_ts, end_ts)
				now = time()
				for i, prog in enumerate(self.displayed_programs):
					if prog.start_time <= now and prog.end_time >= now:
						self.set_selected_program(i)
						break
				else:
					self.set_selected_program(-1)
		else:
			self.widget.set_color(a=0)
		UIItem.reset(self, item, selected)
		return None

	# Return a 2-tuple of the form:
	# (not_selected_widget, selected_widget).
	# 
	# The problem here is that we can't create much of it beforehand,
	# what with the program number and durations being unknowns and all.
	def _create(self):
		not_sel_widget = Container()
		sel_widget = Container()
		self.channel = None
		self.displayed_programs = []
		self.selected_program = 0
		self.start_ts = 0
		self.end_ts = 0
		self.blurbs = {}
		self.spare_selected_blurbs = set()
		self.spare_not_selected_blurbs = set()
		selection_cursor = Image(image_or_file=self.style['selection_cursor_image'], repository=self.style['repository'])
		selection_cursor.set_keep_real_size(False)
		selection_cursor.set_color(a=0)
		sel_widget.add_child(selection_cursor, aspect=False)
		self.selection_cursor = selection_cursor
		item_width, item_height = self.style['item_size']
		self._not_selected_kwargs.update({'width': item_width, 'height': item_height})
		selected_item_width, selected_item_height = self.style['selected_item_size']
		self._selected_kwargs.update({'width': selected_item_width, 'height': selected_item_height})
		for signal in self._UPDATE_DISPATCH:
			louie.connect(self.update, signal)
		return (not_sel_widget, sel_widget)

	_UPDATE_DISPATCH = {'set_boundaries': set_boundaries, 'clock': update_progress}

	# Louie signal handler -- always active
	def update(self, signal, sender=None, *args, **kw):
		self._UPDATE_DISPATCH[signal](self, *args, **kw)
		return None

	_SELECTED_UPDATE_DISPATCH = {'set_selected_program': set_selected_program, 'update_record': update_record}

	# Louie signal handler, active only when the item is selected
	def _selected_update(self, signal, sender=None, *args, **kw):
		self._SELECTED_UPDATE_DISPATCH[signal](self, *args, **kw)
		return None

	def _set_selected(self, selected, *args, **kw):
		if selected:
			for signal in self._SELECTED_UPDATE_DISPATCH:
				louie.connect(self._selected_update, signal)
		elif self.selected:
			for signal in self._SELECTED_UPDATE_DISPATCH:
				louie.disconnect(self._selected_update, signal, wipe=False)
			self.set_selected_program(-1)
		self.selection_cursor.set_color(a=(255 if selected else 0))
		UIItem._set_selected(self, selected, *args, **kw)
		return None

	def destroy(self):
		if self.selected:
			self.selection_cursor.set_visible(False)
			for signal in self._SELECTED_UPDATE_DISPATCH:
				louie.disconnect(self._selected_update, signal, wipe=False)
		return UIItem.destroy(self)
