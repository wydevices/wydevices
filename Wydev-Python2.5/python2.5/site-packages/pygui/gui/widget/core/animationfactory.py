# -*- coding: utf-8 -*- 
#
# Description:
#
# GUI Widget Core Animation Factory Definiton
#
#
#
# Changes:
#
# 2012-05-02
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

from __future__ import absolute_import

from pygui.config import plugins
from pygui.gui.widget.core.macros import MACRO_GLOBS
from peewee.debug import GET_LOGGER
from peewee.formatters import string_or_float

log = GET_LOGGER(__name__)



def in_set(*args):
	values_set = set(args)
	def _aux(value):
		if value in values_set:
			return value
		log.error('Invalid value %s : not in %s', value, args)
		return args[0]
	return _aux



_step_type_cast = in_set('linear',
												 'log',
												 'exp',
												 'samples',
												 'easein',
												 'easeout',
												 'easeinout',
												 'bounce')

_animation_list = ['size',
									 'opacity',
									 'move',
									 'color']

_att_cast_list = {'name': None,
									'opacity': float,
									'opacity_min': float,
									'opacity_max': float,
									'width': string_or_float,
									'height': string_or_float,
									'left': string_or_float,
									'right': string_or_float,
									'top': string_or_float,
									'bottom': string_or_float,
									'hcenter': string_or_float,
									'vcenter': string_or_float,
									'a': int,
									'r': int,
									'g': int,
									'b': int,
									'starting_offset': float,
									'duration': float,
									'step_type': _step_type_cast}



# Evaluate and return a lambda function which execute the XML macro and
# cast the result with appropriated cast function
# !!! Not secure !!!
def _py_macro_call(m, cast):
	return (lambda : cast(eval('%s' % m[3:], MACRO_GLOBS)))



# Class used to stock informations about a certain animation.
class Anim(object):

	def _cast_att(self, dict):
		for key, val in dict.iteritems():
			castor = _att_cast_list.get(key, None)
			if castor is not None:
				dict[key] = castor(val)
		return dict

	def __init__(self, node):
		self.object = None
		kwargs = node.attrib
		self.type = node.tag
		self._callbacks = []
		self._stopped = False
		self._kwargs = self._cast_att(kwargs)
		for subnode in node:
			self._callbacks.append(Anim(subnode))
		return None

	def __repr__(self):
		return '<%s:%s::%s(%s)>' % (self.__class__.__name__, self.object, self.type, self._kwargs)

	def play(self, object=None):
		self._stopped = False
		self.object = object
		if self._callbacks:
			self._kwargs['end_callback'] = self.end_callback
		log.debug('ANIM %s %d : %s --> %s', object.name, id(object), self.type, self._kwargs)
		getattr(object, 'animate')(self.type, **self._kwargs)
		return None

	def end_callback(self):
		log.info('running end callback (should be thread-safe, I hope :P)')
		if not self._stopped:
			for anim in self._callbacks:
				anim.play(self.object)
		return None

	def stop(self):
		self._stopped = True
		return None



class PerpetualAnim(Anim):

	def __init__(self, node):
		self.type = node.tag
		self.object = None
		self._task = None
		self._in_pause = False
		maximums = dict()
		minimums = dict()
		duration = 1
		value = 'opacity'
		step_type = 'linear'
		for k, v in node.attrib.iteritems():
			if k.endswith('_min'):
				name = k[:-4]
				if str(v).startswith('py:'):
					minimums[name] = _py_macro_call(v, _att_cast_list.get(name))
				else:
					minimums[name] = _att_cast_list.get(name)(v)
			elif k.endswith('_max'):
				name = k[:-4]
				if str(v).startswith('py:'):
					maximums[name] = _py_macro_call(v, _att_cast_list.get(name))
				else:
					maximums[name] = _att_cast_list.get(name)(v)
			elif k == 'duration':
				if str(v).startswith('py:'):
					duration = _py_macro_call(v, _att_cast_list.get(k))
				else:
					duration = float(v)
			elif k == 'type':
				value = v
			elif k == 'step_type':
				step_type = _step_type_cast(v)
		self._properties = dict(maxi=maximums, mini=minimums, duration=duration, value=value, step_type=step_type)
		return None

	def __repr__(self):
		return '<%s:%s::%s(%s)>' % (self.__class__.__name__, self.object, self.type, self._properties)

	def play(self, object=None):
		self.object = object
		p = self._properties
		d = p['duration']
		duration = (d() if callable(d) else float(d))
		log.debug('PERPETANIM %s %d : %s --> mini:%s value:%s duration:0', object.name, id(object), self.type, p['mini'], p['value'])
		object.animate(p['value'], duration=0, **p['mini'])
		if 'noglow' in plugins:
			return None
		log.debug('PERPETANIM %s %d : %s --> maxi:%s value:%s duration:%s step_type:%s', object.name, id(object), self.type, p['maxi'], p['value'], duration, p['step_type'])
		object.animate(p['value'], duration=duration, loop_type='boom', end_callback=self.set_min, step_type=p['step_type'], **p['maxi'])
		return None

	def set_min(self):
		self.object.animate(p['value'], duration=0, **self._properties['mini'])
		return None

	def stop(self):
		self.object.animate_stop(self._properties['value'])
		return None

	def pause(self):
		self.object.animate_stop(self._properties['value'])
		return None

	def unpause(self):
		p = self._properties
		self.object.animate(p['value'], duration=p['duration'], loop_type='boom', step_type=p['step_type'], end_callback=self.set_min, **p['maxi'])
		return None



# This class is a sort of contanier for multiple animations.
# It's used when more than one animation are being played
# on the same object at the same time (event).
class Animation(object):

	def __init__(self, node, obj=None):
		self._animations = []
		self.event = node.get('event')
		self.name = node.get('id')
		self.add_animations(node)
		self.obj = obj
		return None

	def __repr__(self):
		return '%s({"event": %s, "name": %s}, %s)' % (self.__class__.__name__, self.event, self.name, self._animations)

	def add_animations(self, node):
		for anim_node in node:
			if anim_node.tag in _animation_list:
				self._animations.append(Anim(anim_node))
			elif anim_node.tag == 'glow':
				self._animations.append(PerpetualAnim(anim_node))
		return None

	def play(self, *args, **kargs):
		log.info('play %s %s', args, kargs)
		for anim in self._animations:
			anim.play(self.obj)
		return None

	def stop(self):
		for anim in self._animations:
			anim.stop()
		return None

	def pause(self):
		for anim in self._animations:
			anim._in_pause = True
			try:
				anim.pause()
			except AttributeError:
				pass
		return None

	def unpause(self):
		for anim in self._animations:
			anim._in_pause = False
			try:
				anim.unpause()
			except AttributeError:
				pass
		return None


class AnimationCreator(object):

	def __getitem__(self, att):
		if att == 'list':
			return _animation_list
		return None

	def create(self, node, obj):
		return Animation(node, obj)



