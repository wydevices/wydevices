# -*- coding: utf-8 -*- 
#
# Description:
#
# Windows EventManager Class Definition
#
#
#
# Changes:
#
# 2014-03-25
# Initial Commit
#
#
# Copyright 2010-2014, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

from __future__ import absolute_import

from pygui.eventmanager import EventDispatcher
from pygui.shared import pygui_globs
from peewee.debug import GET_LOGGER

log = GET_LOGGER(__name__)


class WindowEventHandler(EventDispatcher):
	
	def event_home(self, event):
		from pygui.menu.menu.firstboot import FirstBootMenu
		for menu in reversed(pygui_globs['menustack'].menus_stack):
			if isinstance(menu, FirstBootMenu):
				return True
		return EventDispatcher.event_home(self, event)


class MessageEventHandler(WindowEventHandler):
	
	def catch_event(self, event):
		return True

	event_left, event_right, event_up, event_down, event_wheel_rwd, event_wheel_fwd = catch_event, catch_event, catch_event, catch_event, catch_event, catch_event
	
	def event_select(self, event):
		play = self.player
		if play._timeout_timer:
			play._timeout_timer.stop()
		play.hide()
		if play.button:
			play.button.emit()
		return True

	def event_stop(self, event):
		play = self.player
		if not play.timeout_callback:
			return False
		if play._timeout_timer:
			play._timeout_timer.stop()
		play.hide()
		play.timeout_callback()
		return True


class CancelOnlyEventHandler(WindowEventHandler):
	
	def event_stop(self, event):
		play = self.player
		if play._cancel_fn:
			try:
				play._cancel_fn()
			except Exception, e:
				log.error('Cancel action failed: %s', str(e))
		return True


class NoHomeEventHandler(CancelOnlyEventHandler):
	
	def event_home(self, event):
		return True


class ButtonListEventHandler(WindowEventHandler):
	
	def event_left(self, event):
		play = self.player
		sel_idx = play.buttons.index(play.selected)
		if sel_idx > 0:
			play.selected = play.buttons[sel_idx - 1]
		pygui_globs['menustack'].update_window(play)
		return True

	def event_right(self, event):
		play = self.player
		sel_idx = play.buttons.index(play.selected)
		max_idx = len(play.buttons) - 1
		if sel_idx < max_idx:
			play.selected = play.buttons[sel_idx + 1]
		pygui_globs['menustack'].update_window(play)
		return True

	def event_select(self, event):
		self.player.hide()
		self.player.selected.emit()
		return True

	def event_stop(self, event):
		return True


class DismissableButtonListEventHandler(ButtonListEventHandler):
	
	def event_stop(self, event):
		self.player.hide()
		return True


class KeyboardEventHandler(WindowEventHandler):
	
	def __call__(self, event):
		EventDispatcher.__call__(self, event)
		pygui_globs['menustack'].update_window(self.player)
		return True

	def event_left(self, event):
		sel_idx = self.player.buttons.index(self.player.selected)
		self.player.selected = self.player.buttons[sel_idx - 1]
		return True

	def event_right(self, event):
		sel_idx = self.player.buttons.index(self.player.selected)
		nb_elts = len(self.player.buttons)
		new_idx = (sel_idx + 1) % nb_elts
		self.player.selected = self.player.buttons[new_idx]
		return True

	def event_up(self, event):
		sel_idx = self.player.buttons.index(self.player.selected)
		new_sel = sel_idx - self.player.columns
		if self.player.buttons[sel_idx] in self.player.action_buttons and self.player.buttons[new_sel] not in self.player.action_buttons:
			self.player.selected = self.player.buttons[-len(self.player.action_buttons) - 1]
		else:
			self.player.selected = self.player.buttons[new_sel]
		return True

	def event_down(self, event):
		sel_idx = self.player.buttons.index(self.player.selected)
		nb_elts = len(self.player.buttons)
		new_sel = (sel_idx + self.player.columns) % nb_elts
		if self.player.buttons[sel_idx] not in self.player.action_buttons and (new_sel < sel_idx or self.player.buttons[new_sel] in self.player.action_buttons):
			self.player.selected = self.player.action_buttons[0]
		else:
			self.player.selected = self.player.buttons[new_sel]
		return True

	def event_select(self, event):
		self.player.selected.emit()
		return True

	def event_wheel_rwd(self, event):
		self.player._text_cursor_pos = max(self.player._text_cursor_pos - 1, 0)
		return True

	def event_wheel_fwd(self, event):
		self.player._text_cursor_pos = min(self.player._text_cursor_pos + 1, len(self.player.text))
		return True

	# Change case.
	def event_marker(self, event):
		idx = self.player.buttons.index(self.player.selected)
		self.player.selected = None
		self.player.change_special_char(-1)
		self.player.selected = self.player.buttons[idx]
		return True

	# Switch to symbols.
	def event_action_menu(self, event):
		idx = self.player.buttons.index(self.player.selected)
		self.player.selected = None
		self.player.change_special_char()
		self.player.selected = self.player.buttons[idx]
		return True

	# Backspace.
	def event_stop(self, event):
		self.player.delete_char()
		return True


class SilentKeyboardEventHandler(KeyboardEventHandler):
	
	def event_toggle_menu(self, event):
		self.player.hide()
		return True


class SearchKeyboardEventHandler(KeyboardEventHandler):
	
	# Close search menu
	def event_action_menu(self, event):
		self.player.hide(hide_search_menu=True)
		return True


class MultiIntegerButtonsEventHandler(KeyboardEventHandler):
	
	def __init__(self, num_buttons, player):
		KeyboardEventHandler.__init__(self, player)
		self.num_buttons = num_buttons
		return None

	def event_up(self, event):
		sel_idx = self.player.buttons.index(self.player.selected)
		if 0 <= sel_idx < self.num_buttons:
			self.player.selected.upper()
			self.player.update()
		return True

	def event_down(self, event):
		sel_idx = self.player.buttons.index(self.player.selected)
		if 0 <= sel_idx < self.num_buttons:
			self.player.selected.lower()
			self.player.update()
		return True
