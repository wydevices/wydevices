# -*- coding: utf-8 -*- 
#
# Description:
#
# ZonesEventHandlers Class Definitons
#
#
#
# Changes:
#
# 2012-11-12
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

from __future__ import absolute_import

__all__ = ['UPSLIDER_ZONE', 'RIGHTSLIDER_ZONE', 'DOWNSLIDER_ZONE', 'ZonesMapEventHandler', 'SliderEventHandler', 'GridEventHandler', 'ButtonEventHandler', 'GestureEventHandler', 'TrickmodeSliderEventHandler', 'MultiZoneEventHandler', 'split_zone']

from peewee.debug import GET_LOGGER, PRINT_EXCEPTION
from peewee.notifier import Task
from pygui.config import HMI_BASE



log = GET_LOGGER(__name__)
UPSLIDER_ZONE = (0, 100, 0, 20)
RIGHTSLIDER_ZONE = (80, 100, 0, 100)
DOWNSLIDER_ZONE = (0, 100, 80, 100)
LEFTSLIDER_ZONE = (0, 20, 0, 100)
GRID_ZONE = (20, 80, 20, 80)
KBDGRID_ZONE = (20, 80, 20, 100)
UPLEFT_ZONE = (0, 20, 0, 20)
COMPLETE_ZONE = (0, 100, 0, 100)
THUMBNAIL_ZONE = (0, 100, 0, 80)
EPSILON = HMI_BASE['rcu_move_threshold']
GESTURE_THRESHOLD = HMI_BASE.get('rcu_gesture_threshold', 15.0)
LONGCLIC_THRESHOLD = HMI_BASE['rcu_longclic_threshold']
BUTTONS_REPEAT_TIMEOUT = HMI_BASE['rcu_buttons_repeat_timeout']
BUTTONS_REPEAT_DELAY = HMI_BASE['rcu_buttons_repeat_delay']
DEFAULT_MARGIN = HMI_BASE.get('rcu_default_margin', 10)
BUTTONS_CLICK_TIMEOUT = BUTTONS_REPEAT_DELAY + BUTTONS_REPEAT_DELAY / 10



class ZoneHandler(object):

	__slots__ = ('_handler', '_zone')

	# @arg handler: function which takes a zone (see ZonesMapEventHandler) argument.
	# @arg zone: zone argument gived to handler when it is called.
	def __init__(self, handler, zone):
		self._handler = handler
		self._zone = zone
		return None

	def __call__(self):
		self._handler(self._zone)
		return None



# Manage a set of handlers of zones.
# A zone is a tuple (xmin , xmax, ymin, ymax), ie an axis-aligned bounding box (AABB).
# Coordinates are between 0 and 100.
class ZonesMapEventHandler(object):

	#@arg xseps: zone separations for x axis
	# @arg yseps: zone separations for y axis
	# 
	# eg: ZonesMapEventHandler((20, 80), (20, 80)) will give a 'zones' attribute:
	# [[(0,   20, 0, 20), (0,   20, 20, 80), (0,   20, 80, 100)],
	# [(20,  80, 0, 20), (20,  80, 20, 80), (20,  80, 80, 100)],
	# [(80, 100, 0, 20), (80, 100, 20, 80), (80, 100, 80, 100)]]
	def __init__(self, xseps=(20, 80), yseps=(20, 80)):
		seps = [0] + list(xseps) + [100]
		xzones = tuple(((seps[i], seps[i+1]) for i in (xrange(len(seps) - 1))))
		self._xzones = xzones
		seps = [0] + list(yseps) + [100]
		yzones = tuple(((seps[i], seps[i+1]) for i in (xrange(len(seps) - 1))))
		self._yzones = yzones
		self._handlers = [[None]*len(zzones) for e in xzones]
		self.zones = [[(xmin, xmax, ymin, ymax) for line, ymin, ymax in yzones] for column, xmin, xmax in xzones]
		return None

	def set_handler(self, column, line, handlers, zone=None):
		if zone is None:
			zone = self.zones[column][line]
		self._handlers[column][line] = [ZoneHandler(handler, zone) for handler in handlers]
		return None

	def _manage_event(self, event):
		arg = event.arg
		x = arg['x']
		y = arg['y']
		yzones = self._yzones
		for column, xmin, xmax in self._xzones:
			if x < xmax:
				for line, ymin, ymax in yzones:
					if y < ymax:
						if event.name == 'MOUSE':
							handler = self._handlers[column][line][0]
						else:
							if event.name == 'BUTTON0':
								handler = self._handlers[column][line][1]
						if handler is not None:
							handler()
						return True
		return False

	def event_button1(self, event):
		if not hasattr(self, 'handle_button1'):
			return False
		self.handle_button1()
		return True

	event_mouse = _manage_event

	event_button0 = _manage_event



# Compute for linear equation with points (x0, 0) & (x1, 100)
def compute_linear_coordinate(x, x0, x1):
	return 100 * (x - x0) / (x1 - x0)



def do_nothing(*args):
	return None



class ZoneEventHandler(object):

	# @arg zone: tuple (xmin , xmax, ymin, ymax) (see compute_zones()).
	# @arg margin: integer representing margin out the zone.
	# 	If the zone is active, it catch mouse event in the
	# 	zone plus the external margin.
	# @arg pick_on_click: boolean: do a pick (select) while handling button0
	def __init__(self, player, zone, margin=DEFAULT_MARGIN, pick_on_click=False):
		self.player = player
		if zone is not None:
			self._zone = zone
		else:
			self._zone = (0, 0, 0, 0)
		self._margin = margin
		self._pick_on_click = pick_on_click
		self._button0_task = Task((lambda : None))
		self._button1_task = Task((lambda : None))
		self._button2_task = Task((lambda : None))
		self._button3_task = Task((lambda : None))
		self._button4_task = Task((lambda : None))
		self.handle_click = do_nothing
		self.handle_pressed = do_nothing
		self.handle_long_click = do_nothing
		return None

	def _check_zone(self, event, handler, xkey, ykey, remap_coord):
		arg = event.arg
		x = arg[xkey]
		y = arg[ykey]
		ret = self._in_zone(x, y)
		if ret:
			if remap_coord:
				zone = self._zone
				arg[xkey] = min(zone[1], max(zone[0], x))
				arg[ykey] = min(zone[3], max(zone[2], y))
			handler(arg)
		return ret

	def _in_zone(self, x, y):
		zone = self._zone
		margin = self._margin
		if zone[0] - margin <= x <= zone[1] - margin and zone[2] - margin <= y <= zone[3] - margin:
			return True
		return False

	def event_mouse(self, event):
		if not self._button0_task.running:
			return self._check_zone(event, self._manage_mouse, 'x', 'y', True)
		else:
			log.warn('%s Dropped because button0 task is running', event)
			return True

	def event_button0(self, event):
		return self._check_zone(event, self._manage_button0, 'start_x', 'start_y', False)

	def event_button1(self, event):
		if not hasattr(self, 'handle_button1'):
			return False
		self._manage_button1(event.arg)
		return True

	def event_button2(self, event):
		if not hasattr(self, 'handle_button2'):
			return False
		self._manage_button2(event.arg)
		return True

	def event_button3(self, event):
		if not hasattr(self, 'handle_button3'):
			return False
		self._manage_button3(event.arg)
		return True

	def event_button4(self, event):
		if not hasattr(self, 'handle_button4'):
			return False
		self._manage_button4(event.arg)
		return True

	def _manage_button0(self, event_arg):
		count = event_arg['count']
		if self.player._autohide_timeout:
			self.player._autohide_timeout.start()
		if self._pick_on_click:
			self._pick(event_arg)
		task = self._button0_task
		move_detected = self._check_button_move(event_arg)
		self.handle_pressed()
		if count < LONGCLIC_THRESHOLD and not move_detected:
			task.fn = self.handle_click
			task.args = ()
			task.start(BUTTONS_CLICK_TIMEOUT)
		else:
			task.fn = self._manage_long_click
			task.args = (event_arg,)
			task.start(BUTTONS_CLICK_TIMEOUT)
		return None

	def _manage_mouse(self, event_arg):
		if self.player._autohide_timeout:
			self.player._autohide_timeout.start()
		self._pick(event_arg)
		return None

	def _manage_button1(self, event_arg):
		self._button1_task.fn = self.handle_button1
		self._button1_task.start(BUTTONS_REPEAT_TIMEOUT)
		return None

	def _manage_button2(self, event_arg):
		self._button2_task.fn = self.handle_button2
		self._button2_task.start(BUTTONS_REPEAT_TIMEOUT)
		return None

	def _manage_button3(self, event_arg):
		self._button3_task.fn = self.handle_button3
		self._button3_task.start(BUTTONS_REPEAT_TIMEOUT)
		return None

	def _manage_button4(self, event_arg):
		self._button4_task.fn = self.handle_button4
		self._button4_task.start(BUTTONS_REPEAT_TIMEOUT)
		return None

	def _manage_long_click(self, event_arg):
		return None

	def _pick(self, event_arg):
		print 'ERROR: _pick() NOT IMPLEMENTED'
		return None

	# Just check if we move enougth to launch a 'move_click'
	def _check_button_move(self, event_arg):
		if abs(event_arg['x'] - event_arg['start_x']) > EPSILON:
			return True
		return abs(event_arg['y'] - event_arg['start_y']) > EPSILON



def null_pick_coord(coord):
	return None



class SliderEventHandler(ZoneEventHandler):

	def __init__(self, player, zone, vertical=True, margin=DEFAULT_MARGIN, pick_on_click=False):
		ZoneEventHandler.__init__(self, player, zone, margin, pick_on_click)
		self._vertical = vertical
		self.handle_forward_click = do_nothing
		self.handle_backward_click = do_nothing
		self.handle_transversal_click = do_nothing
		self.handle_pick_coord = null_pick_coord
		return None

	def _pick(self, event_arg):
		zone = self._zone
		if self._vertical:
			coord = compute_linear_coordinate(event_arg['y'], zone[2], zone[3])
		else:
			coord = compute_linear_coordinate(event_arg['x'], zone[0], zone[1])
		self.handle_pick_coord(coord)
		return None

	def _manage_long_click(self, event_arg):
		majordiff = event_arg['x'] - event_arg['start_x']
		minordiff = event_arg['y'] - event_arg['start_y']
		if self._vertical:
			majordiff, minordiff = minordiff, majordiff
		abs_majordiff = abs(majordiff)
		abs_minordiff = abs(minordiff)
		log.debug('LONGCLIC: event_arg: %s abs_major=%s abs_minor=%s', event_arg, abs_majordiff, abs_minordiff)
		if abs_majordiff >= abs_minordiff:
			if abs_majordiff < EPSILON:
				self.handle_long_click()
			else:
				if majordiff > 0:
					self.handle_forward_click()
				else:
					self.handle_backward_click()
		else:
			if abs_minordiff < EPSILON:
				self.handle_long_click()
			else:
				self.handle_transversal_click()
		return None



def null_pick_x_y(x, y):
	return None



class GridEventHandler(ZoneEventHandler):
	
	def __init__(self, player, zone, vertical=True, margin=DEFAULT_MARGIN, pick_on_click=False):
		ZoneEventHandler.__init__(self, player, zone, margin, pick_on_click)
		self.handle_pick_x_y = null_pick_x_y
		return None

	def _pick(self, event_arg):
		zone = self._zone
		x = compute_linear_coordinate(event_arg['x'], zone[0], zone[1])
		y = compute_linear_coordinate(event_arg['y'], zone[2], zone[3])
		self.handle_pick_x_y(x, y)
		return None



class ButtonEventHandler(ZoneEventHandler):

	def __init__(self, player, zone, margin=DEFAULT_MARGIN, pick_on_click=False):
		ZoneEventHandler.__init__(self, player, zone, margin, pick_on_click)
		self.handle_hover = do_nothing
		return None

	def _manage_mouse(self, event_arg):
		if self.player._autohide_timeout:
			self.player._autohide_timeout.start()
		self.handle_hover()
		return None

	def _manage_long_click(self, event_arg):
		self.handle_click()
		return None



class GestureEventHandler(ZoneEventHandler):

	def __init__(self, player, zone, margin=DEFAULT_MARGIN, pick_on_click=True):
		ZoneEventHandler.__init__(self, player, zone, margin, pick_on_click)
		self.start_pos = []
		self.start_count = 0
		self.move_repeat_delay = HMI_BASE['rcu_move_repeat_delay']
		self.handle_x_gesture = do_nothing
		self.handle_y_gesture = do_nothing
		return None

	def _manage_mouse(self, event_arg):
		if event_arg['count'] == 1:
			self.start_pos = [event_arg['x'], event_arg['y']]
			self.start_count = 1
		else:
			if self.start_pos:
				x_diff = event_arg['x'] - self.start_pos[0]
				y_diff = event_arg['y'] - self.start_pos[1]
				count = event_arg['count'] - self.start_count
				abs_x_diff = abs(x_diff)
				abs_y_diff = abs(y_diff)
				callback = do_nothing
				if abs_x_diff >= abs_y_diff:
					majordiff = x_diff
					abs_majordiff = abs_x_diff
					callback = self.handle_x_gesture
				else:
					majordiff = y_diff
					abs_majordiff = abs_y_diff
					callback = self.handle_y_gesture
				if abs_majordiff > GESTURE_THRESHOLD:
					move = int(round(abs_majordiff / GESTURE_THRESHOLD))
					speed = abs_majordiff / count * self.move_repeat_delay
					if move >= 1:
						if majordiff > 0:
							move = move
						else:
							move = -move
						callback(move, speed)
						self.start_pos = [event_arg['x'], event_arg['y']]
						self.start_count = event_arg['count']
		return None

	_manage_button0 = _manage_mouse



class TrickmodeSliderEventHandler(SliderEventHandler):

	def __init__(self, player, zone, vertical=True, margin=DEFAULT_MARGIN, pick_on_click=False):
		SliderEventHandler.__init__(self, player, zone, vertical, margin, pick_on_click)
		self.handle_released = do_nothing
		self.handle_pressed = do_nothing
		return None

	def _manage_button0(self, event_arg):
		count = event_arg['count']
		if self.player._autohide_timeout:
			self.player._autohide_timeout.start()
		self._pick(event_arg)
		self.handle_pressed()
		task = self._button0_task
		if count < LONGCLIC_THRESHOLD:
			task.fn = self.handle_click
		else:
			task.fn = self.handle_released
		task.args = ()
		task.start(BUTTONS_REPEAT_TIMEOUT * 3)
		return None



class SubZoneHandler(object):

	__slots__ = ('handler', 'active')

	def __init__(self, handler, active=True):
		self.handler = handler
		self.active = active
		return None



# A ZoneEventHandler that manages several inner zones aligned horizontally or vertically.
#
# Each zone has its own zone_event_handler (with event_mouse() and event_button0()) and can be active or inactive.
# An inactive zone forwards all events which are for it to the nearest active zone.
# So there can be several active zones and several inactive zones.
class MultiZoneEventHandler(ZoneEventHandler):

	def __init__(self, player, zone, vertical=True, margin=DEFAULT_MARGIN, pick_on_click=False):
		ZoneEventHandler.__init__(self, player, zone, margin, pick_on_click)
		self._subzone_handlers = []
		self._vertical = vertical
		return None

	def add_subzone_handler(self, zone_event_handler, active=True):
		zone_event_handler._margin = 0
		self._subzone_handlers.append(SubZoneHandler(zone_event_handler, active))
		return None

	# Activate/deactivate a zone.
	#
	# @param zone_id: first zone appent has id 0, second id 1 etc...
	# @param active: boolean value.
	def set_subzone_active(self, zone_id, active):
		self._subzone_handlers[zone_id].active = active
		return None

	def _manage_event_aux(self, xkey, ykey, event, method_name, xkey2remap=None, ykey2remap=None):
		event_arg = event.arg
		x = event_arg[xkey]
		y = event_arg[ykey]
		if not self._in_zone(x, y):
			return False
		for zeh in self._subzone_handlers:
			if zeh.active:
				break
		else:
			return True
		zone = self.zone
		event_arg[xkey] = min(zone[1], max(zone[0], x))
		event_arg[ykey] = min(zone[3], max(zone[2], y))
		for i, zeh in enumerate(self._subzone_handlers):
			if zeh.active:
				if getattr(zeh.handler, method_name)(event):
					return True
			else:
				if zeh.handler._in_zone(x, y):
					zone, new_x, new_y = self._search_active_zone(i, x, y)
					event_arg[xkey] = new_x
					event_arg[ykey] = new_y
					if xkey2remap is not None:
						event_arg[xkey2remap] = event_arg[xkey2remap] + new_x - x
						event_arg[ykey2remap] = event_arg[ykey2remap] + new_y - y
					getattr(zone.handler, method_name)(event)
					return True
		return None

	def event_mouse(self, event):
		return self._manage_event_aux('x', 'y', event, 'event_mouse')

	def event_button0(self, event):
		return self._manage_event_aux('start_x', 'start_y', event, 'event_button0', 'x', 'y')

	# Search the nearest active zone.
	# @param i: index of the current zone (zone which contains (x, y) point)
	# @param x: x of the mouse event
	# @param y: y of the mouse event
	def _search_active_zone(self, i, x, y):
		subzones = self._subzone_handlers
		inf = i - 1
		while inf >= 0:
			if subzones[inf].active:
				break
			inf -= 1
		else:
			inf = None
		sup = i + 1
		while sup < len(subzones):
			if subzones[sup].active:
				break
			sup += 1
		else:
			sup = None
		if inf is None:
			return self._remap_by_sup(x, y, subzones[sup])
		elif sup is None:
			return self._remap_by_inf(x, y, subzones[inf])
		if i - inf < sup - i:
			return self._remap_by_inf(x, y, subzones[inf])
		else:
			return self._remap_by_sup(x, y, subzones[sup])
		return None

	def _remap_by_sup(self, x, y, newzone):
		if self._vertical:
			return (newzone, x, newzone.handler._zone[2])
		else:
			return (newzone, newzone.handler._zone[0], y)

	def _remap_by_inf(self, x, y, newzone):
		if self._vertical:
			return (newzone, x, newzone.handler._zone[3])
		else:
			return (newzone, newzone.handler._zone[1], y)



# Utils function that splits a zone a in 'parts' equal subzone, vertically or horizontally.
# e.g: split_zone((10, 70, 15, 35), 3, False) gives: [(10, 30, 15, 35), (30, 50, 15, 35), (50, 70, 15, 35)]
def split_zone(zone, parts, vertical):
	xmin, xmax, ymin, ymax = zone
	if vertical:
		def build_subzone(ymin, ymax):
			return (xmin, xmax, ymin, ymax)
		coordmin = ymin
		coordmax = ymax
	else:
		def build_subzone(xmin, xmax):
			return (xmin, xmax, ymin, ymax)
		coordmin = xmin
		coordmax = xmax
	lenght = (coordmax - coordmin) // parts
	coordmax = coordmin + lenght
	res = []
	for i in xrange(parts):
		res.append(build_subzone(coordmin, coordmax))
		coordmin = coordmax
		coordmax += lenght
	return res
