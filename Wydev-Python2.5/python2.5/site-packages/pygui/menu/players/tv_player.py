# -*- coding: utf-8 -*- 
#
# Description:
#
# TV Player Class Definiton
#
#
#
# Changes:
#
# 2012-04-01
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

from __future__ import absolute_import

from pygui.config import HMI_TV, add_tv_info_banner_idle_events, user_config, plugins
if 'tv' not in plugins:
	raise ImportError('TV is disabled')
from time import localtime, strftime, time
from wymedia.wmplus import BrowseError
from wyrecord import WyRecord
from wyrecord import RECORDING_EVENT_RECORD_STARTED, RECORDING_EVENT_RECORD_STOPPED, RECORDING_EVENT_RECORD_START_ERROR, RECORDING_EVENT_RECORD_GOING_TO_START, RECORDING_TYPE_NOT_SCHEDULED, RECORDING_EVENT_RECORD_DISK_SPACE_START_ERROR, RECORDING_EVENT_RECORD_MACROVISION_START_ERROR, RECORDING_EVENT_RECORD_MACROVISION_STOP_ERROR
from wyrecord.callbacks import UPDATE_SERVICE_ADDED, UPDATE_SERVICE_UPDATED, UPDATE_SERVICE_REMOVED
from wyrecord.exceptions import LiveIsRecordingErrors, LiveInConflictError, DefaultLiveControllerError, NoLiveAvailableError, StartingLiveErrors, StartLivePlayingErrors, NoDeviceForServiceErrors, SchedulingFailedOnConflictErrors, SchedulingDoneWithConflictErrors, SchedulingFailedOnDiskSpaceErrors
from peewee.debug import GET_LOGGER, PRINT_EXCEPTION
from peewee.cache_utils import cache_result
from peewee.formatters import ellipsize, seconds_to_hhmm, seconds_to_hhmm_utc
from peewee.messages import send as louie_send
from peewee.notifier import Task, tasked
from peewee.ranges import f_list
from pygui.eventmanager.players import TVEventHandler
from pygui.facilities.codemapping import country_dict, player_aspect_ratio_dict
from pygui.facilities.l10n import get_date_format
from pygui.facilities.mixer import Mix
from pygui.item.core import Item
from pygui.item.mediaitem.tv import TVRootItem, ProgramItem
from pygui.shared import pygui_globs
from pygui.menu import gui_updater, selective_gui_updater
from pygui.menu.menu.security import SecretCodeCheckMenu
from pygui.menu.menu.tv.navigator import TvNavigatorMenu
from pygui.menu.players.core import Player, TimerActivator
from pygui.window import ConfirmWindow, LoadingWindow, MessageWindow
from pygui.menu.players import forward_tricks_icons, backward_tricks_icons

log = GET_LOGGER(__name__)
info_banner_activator = TimerActivator(signals=('on_user_event', 'on_user_idle'), delay=HMI_TV.get('banner_period', 2), _check=(not add_tv_info_banner_idle_events))
record_banner_activator = TimerActivator(signals=('on_show_record', 'on_hide_record'), delay=HMI_TV.get('record_banner_period', 5))
INSTANT_RECORD_NAME_PATTERN = _('%(date)s %(channel)s %(start_time)s - %(end_time)s')
_EMPTY_RECORD_TIMESHIFT_PROGRAM_BAR = dict(live=0, direct=0, program_begin=0, program_end=100, timeshift_begin=0, timeshift_end=0, record_begin=None, record_end=None)



class TVPlayer(Player):

	# The info banner can be removed when the player is playing at x1 speed
	# and the TV stream is not scrambled.
	def could_remove_banner(self):
		return ((not self.live_controller.scrambled) if 0 < abs(self._speed) <= 1 else 0 < abs(self._speed) <= 1)

	def __init__(self, player=None, type='tvplayer'):
		Player.__init__(self, type, universe='tv')
		self.eventhandler = TVEventHandler(self)
		self._getitems_keywords.update(dict(clock=(lambda : None),
																				channel_name=(lambda : self.player_info['channel_name']),
																				channel_type=(lambda : self.player_info['channel_type']),
																				program_name=(lambda : self.player_info['program_name']),
																				program_content=(lambda : self.player_info['program_content']),
																				program_start_time=(lambda : self.player_info['program_start_time']),
																				program_stop_time=(lambda : self.player_info['program_stop_time']),
																				program_duration=(lambda : self.player_info['program_duration']),
																				program_remaining_time=(lambda : self.player_info['program_remaining_time']),
																				program_elapsed_time=(lambda : self.player_info['program_elapsed_time']),
																				live_time=(lambda : seconds_to_hhmm(self.real_utc_time)),
																				rec_duration=(lambda : self.player_info['rec_duration']),
																				rec_elapsed_time=(lambda : self.player_info['rec_elapsed_time']),
																				rec_remaining_time=(lambda : self.player_info['rec_remaining_time']),
																				rec_status=(lambda : self.player_info['rec_status']),
																				foreign_rec_status=(lambda : self.player_info['foreign_rec_status']),
																				foreign_rec_channel_name=(lambda : self.player_info['foreign_rec_channel_name']),
																				record_timeshift_programbar=self.get_record_timeshift_programbar,
																				speed=(lambda : (('%-.1fx' % self._speed) if self._speed not in f_list([0, 1]) else '')),
																				videoformat_16_9_icon=(lambda : self.player_info['program_videoFormat_16_9']),
																				videoformathd_icon=(lambda : self.player_info['program_videoFormatHD']),
																				nraudiochannels_icon=(lambda : self.player_info['program_nrAudioChannels']),
																				nrsubtitletracks_icon=(lambda : self.player_info['program_nrSubtitleTracks']),
																				subtitlehardofhearing_icon=(lambda : self.player_info['program_subtitleHardOfHearing']),
																				audiohardofhearing_icon=(lambda : self.player_info['program_audioHardOfHearing']),
																				audiovisuallyimpaired_icon=(lambda : self.player_info['program_audioVisuallyImpaired']),
																				freecamode_icon=(lambda : self.player_info['program_freeCaMode']),
																				maturity_rating_icon=(lambda : self.player_info['program_maturity_rating'])))
		_wyrec = WyRecord()
		self.live_controller = _wyrec.getLiveController(player)
		self.record_scheduler = _wyrec.scheduler
		callbacks = _wyrec.callbacks
		callbacks.new_present_epg.register(self.new_present_epg_handler)
		callbacks.disk_space_alert.register(self.disk_space_alert_handler)
		callbacks.start_playing.register(self.start_playing_event_handler)
		self._new_present_epg_task = Task(self._new_present_epg_handler)
		self._speed_change_task = Task(self._speed_change_event_handler)
		self._scrambled_change_task = Task(self._scrambled_change_event_handler)
		self._record = None
		self._conflicting_rec = None
		self._foreign_rec = None
		def _build_navigator():
			self._navigator = TvNavigatorMenu(_('EPG Navigator Menu'), player=self, fill_root=False, type='tv_navigator')
			return None
		Task(_build_navigator).start(0.01)
		self._last_scrambled_status = None
		self.code_check = None
		self.shielded = False
		self.previously_muted = False
		self._favorite_list = TVRootItem().get_acl(self)
		self._TVPlayer__zap_timer = Task(self.zap)
		self._tick_can_refresh = False
		self._speed = 1
		self.program = None
		self.player_info = {}
		self._initialize_program_info()
		self._initialize_record_info()
		return None
	
	# Cache for Wyrecord's getTimeInfo
	@cache_result(validity=1)
	def _get_time_info(self):
		return self.live_controller.default_renderer.getTimeInfo()
		
	def _get_playmode(self):
		return 'none'

	def tick_callback(self):
		if self._tick_can_refresh:
			program, time_info = self.program, self._get_time_info()
			utc_time = time_info.current_time
			if program:
				self.player_info['program_remaining_time'] = seconds_to_hhmm_utc(max(0, program['scheduledEndTime'] - utc_time))
				self.player_info['program_elapsed_time'] = seconds_to_hhmm_utc(utc_time - program['scheduledStartTime'])
			else:
				elapsed = utc_time - time_info.min_available_time
				timeshift_duration = user_config['tv']['timeshift_length'] * 60
				self.player_info['program_remaining_time'] = seconds_to_hhmm_utc(timeshift_duration - elapsed)
				self.player_info['program_elapsed_time'] = seconds_to_hhmm_utc(elapsed)
			if self._record:
				real_utc_time = self.real_utc_time
				self.player_info['rec_elapsed_time'] = seconds_to_hhmm_utc(real_utc_time - self._record.start_time)
				self.player_info['rec_remaining_time'] = seconds_to_hhmm_utc(max(0, self._record.stop_time + self._record.stop_padding - real_utc_time))
			else:
				self.player_info['rec_elapsed_time'], self.player_info['rec_remaining_time'] = '--:--', '--:--'
			for key in ('program_duration', 'program_elapsed_time', 'program_remaining_time', 'record_timeshift_programbar', 'rec_duration', 'rec_elapsed_time', 'rec_remaining_time', 'status_icon'):
				louie_send(key, sender=self, value=self[key])
		return None

	#	When the TV player is put to the foreground:
	#  - Refresh the current favorite.
	def on_foreground(self):
		Player.on_foreground(self)
		chan = self.selected
		try:
			items = self._favorite_list.browse()
			if not items:
				raise ValueError('Current favorite is empty')
		except (BrowseError, ValueError), e:
			PRINT_EXCEPTION(e)
			log.info('Unable to browse current favorite -- falling back to ACL.')
			self._favorite_list = TVRootItem().get_acl(self)
			items = self._favorite_list.browse()
		try:
			self.set_items(items, 'main_list', chan)
		except ValueError, e:
			PRINT_EXCEPTION(e)
			self.set_items(items, 'main_list')
		return None

	def get_subtitles(self):
		subtitles_list = [{'lang': _('OFF'), 'id': -1}] + self.live_controller.slist()
		sid = self.live_controller.sid
		return [[s['lang'], s['id'] == sid, s['id']] for s in subtitles_list]

	def set_subtitle(self, sid):
		self.live_controller.wyplayer.sid = sid
		return None

	def get_audio_substreams(self):
		audiostreams_list = self.live_controller.alist()
		aid = self.live_controller.wyplayer.aid
		return [[a['lang'], a['id'] == aid, a['id'], a['codec']] for a in audiostreams_list]

	def set_audio_substream(self, aid):
		self.live_controller.wyplayer.aid = aid
		return None

	def _get_aspect_ratio(self):
		return self.live_controller.wyplayer.aspect_ratio

	def _set_aspect_ratio(self, aspect_ratio):
		log.info('Setting aspect ratio to %s', aspect_ratio)
		self.live_controller.wyplayer.aspect_ratio = aspect_ratio
		return None

	# The player's aspect ratio (4_3 or 16_9)
	aspect_ratio = property(_get_aspect_ratio, _set_aspect_ratio)
	del _get_aspect_ratio
	del _set_aspect_ratio

	def _get_display_format(self):
		return self.live_controller.wyplayer.display_format

	def _set_display_format(self, display_format):
		log.info('Setting display format to %s', display_format)
		self.live_controller.wyplayer.display_format = display_format
		return None

	# The player's display format (for use when the stream's aspect ratio differs from that of the display)
	display_format = property(_get_display_format, _set_display_format)
	del _get_display_format
	del _set_display_format

	# Blackout the screen and mute the sound.
	def _shield(self):
		louie_send('hide_screen', sender=self)
		mix = Mix()
		self.previously_muted = mix.get_mute()
		mix.set_mute(True)
		self.shielded = True
		return None

	# Un-blackout the screen, restore the sound.
	def _unshield(self):
		louie_send('show_screen', sender=self)
		Mix().set_mute(self.previously_muted)
		if self.code_check in pygui_globs['menustack'].menus_stack:
			self.code_check.hide()
		self.code_check = None
		self.shielded = False
		return None

	# Prompt the user for the parental control's PIN code.
	def prompt_for_pin(self):
		self.code_check = SecretCodeCheckMenu(name=_('Check PIN Code'), action=self._pin_ok, cancel_action=self._pin_nok)
		self.code_check.show()
		return None

	# Called when the user enters a correct PIN code on the code_check dialog.
	# Enjoy your adult entertainment.
	def _pin_ok(self):
		user_config['security']['parent_mode'] = True
		user_config.save()
		self._unshield()
		return None

	# Called when the user enters an incorrect PIN code on the code_check dialog.
	# Back to the blackout screen.
	def _pin_nok(self):
		self.code_check.hide()
		return None

	# Update the audio tracks/subtitles/HD pictograms based on the player's data.
	def _update_tracks_info(self):
		self.player_info['program_nrAudioChannels'] = ('tvplayer_nraudiochannels.png' if len(self.live_controller.alist()) > 1 else None)
		self.player_info['program_nrSubtitleTracks'] = ('tvplayer_nrsubtitletracks.png' if len(self.live_controller.slist()) > 0 else None)
		if len(self.live_controller.vlist()) > 0:
			stream_info = self.live_controller.vlist()[0]
			self.player_info['program_videoFormatHD'] = ('tvplayer_videoformathd.png' if len(stream_info) > 0 and stream_info['height'] >= 720 else None)
		else:
			self.player_info['program_videoFormatHD'] = None
		for key in ('nrSubtitleTracks', 'nrAudioChannels', 'videoFormatHD'):
			louie_send('%s_icon' % key.lower(), sender=self, value=self.player_info['program_' + key])
		return None

	# Called when new EPG data is available.
	@selective_gui_updater('program_name', 'program_start_time', 'program_stop_time', 'program_duration', 'program_content', 'maturity_rating_icon')
	def _new_present_epg_handler(self, program_data, dbus_player_path):
		log.debug('EPG received: %s', program_data)
		if program_data.get('channelID', -1) != int(self.selected['serviceId']):
			return None
		self.program = ProgramItem(program_data)
		self.player_info['program_name'] = ellipsize(self.program.name, 30)
		self.player_info['program_content'] = self.program.content_type
		self.player_info['program_start_time'] = seconds_to_hhmm(self.program['scheduledStartTime'])
		self.player_info['program_stop_time'] = seconds_to_hhmm(self.program['scheduledEndTime'])
		self.player_info['program_duration'] = seconds_to_hhmm(self.program['duration'])
		self._update_tracks_info()
		maturity_rating = int(self.program['maturityRating'])
		self.player_info['program_maturity_rating'] = 'tvplayer_maturityrating_%i.png' % maturity_rating
		if user_config['security']['parental_control'] and not user_config['security']['parent_mode']:
			if maturity_rating and maturity_rating >= user_config['security']['maturity_rating']:
				if not self.shielded:
					self._shield()
			elif self.shielded:
				self._unshield()
		for key, title in self.program.EXTRA_INFO_FIELDS:
			if key in ('nrAudioChannels', 'nrSubtitleTracks'):
				self.player_info['program_' + key] = ('tvplayer_%s.png' % key.lower() if int(self.program[key]) > 0 else None)
				louie_send('%s_icon' % key.lower(), sender=self, value=self.player_info['program_' + key])
		return None

	def new_present_epg_handler(self, *args, **kw):
		self._new_present_epg_task.args = args
		self._new_present_epg_task.kw = kw
		self._new_present_epg_task.start(-0.10000000000000001)
		return None

	# Called when disk space is running low.
	def _disk_space_alert_handler(self, needed_space, available_space, timeshift_ratio):
		log.warn('DISK SPACE ALERT: %s %s', needed_space, available_space)
		message = _('Disk space is running low.')
		title = _('Disk space warning')
		if available_space <= 0:
			message = _('Disk space has run out. Timeshift and recordings have been disabled.')
		else:
			message_pattern = _('Maximum timeshift duration has been reduced to %(duration)s.')
			message = message_pattern % {'duration': '%i%%' % timeshift_ratio}
		MessageWindow(message, title, button=None).show(timeout=5)
		return None

	def disk_space_alert_handler(self, *args, **kw):
		return Task(self._disk_space_alert_handler, *args, **kw).start(0.10000000000000001)

	# Called on recording events.
	@selective_gui_updater('record_timeshift_programbar')
	def _recording_event_handler(self, nEventType, oRecording, in_conflict_recordings, live_to_stop_list):
		if nEventType == RECORDING_EVENT_RECORD_STARTED:
			real_utc_time = self.real_utc_time
			log.info("Recording %s STARTED on channel '%s'", oRecording.id, oRecording.service_name)
			if oRecording.service_id == int(self.selected['serviceId']):
				self._record = oRecording
				if self._conflicting_rec:
					self.live_controller.setDuration(self._conflicting_rec.start_time - self._record.start_time)
					values = {'channel':self._record.service_name, 'date':strftime(get_date_format(), localtime(self._record.start_time)), 'start_time':seconds_to_hhmm(self._record.start_time), 'end_time':seconds_to_hhmm(self._record.stop_time)}
					self._record.name = INSTANT_RECORD_NAME_PATTERN % values
			else:
				self._foreign_rec = oRecording
		elif nEventType == RECORDING_EVENT_RECORD_STOPPED:
			log.info("Recording %s STOPPED on channel '%s'", oRecording.id, oRecording.service_name)
			if oRecording.service_id == int(self.selected['serviceId']):
				self._record = None
			else:
				self._foreign_rec = None
		elif nEventType == RECORDING_EVENT_RECORD_START_ERROR:
			log.info("Recording %s CAN NOT START on channel '%s'", oRecording.id, oRecording.service_name)
			title = _('Recording scheduler')
			message_pattern =_('The recording "%(recording_name)s" failed to start on %(channel_name)s.')
			message = message_pattern % {'recording_name': oRecording.name, 'channel_name': oRecording.service_name}
			MessageWindow(message, title, button=None).show(timeout=5)
		elif nEventType == RECORDING_EVENT_RECORD_DISK_SPACE_START_ERROR:
			title = _('Recording scheduler')
			message_pattern =_('Not enough space left : The recording "%(recording_name)s" failed to start on %(channel_name)s.')
			message = message_pattern % {'recording_name': oRecording.name, 'channel_name': oRecording.service_name}
			MessageWindow(message, title, button=None).show(timeout=5)
		elif nEventType == RECORDING_EVENT_RECORD_GOING_TO_START:
			log.info('GOING TO START EVENT _ rec id = %s', oRecording.id)
			if in_conflict_recordings:
				log.debug('GOING TO START EVENT following will be stopped', in_conflict_recordings.getRecToModify())
			if oRecording.service_id != int(self.selected['serviceId']):
				title = _('Recording scheduler')
				message = _('A recording is about to start on %s.') % oRecording.service_name
				if live_to_stop_list:
					message += _('\nThe channel will change when recording starts.')
				MessageWindow(message, title, button=None).show(timeout=5)
		elif nEventType == RECORDING_EVENT_RECORD_MACROVISION_START_ERROR:
			log.info('Macrovision prevented %s from starting', oRecording)
			title = _('Copy protection')
			message = _('You are trying to record from a content-protected source.\nThis is forbidden.\nCannot start recording on %s.') % oRecording.service_name
			MessageWindow(message, title, button=None).show(timeout=5)
		elif nEventType == RECORDING_EVENT_RECORD_MACROVISION_STOP_ERROR:
			log.info('Macrovision stopped %s', oRecording)
			title = _('Copy protection')
			message = _('You are trying to record from a content-protected source.\nThis is forbidden.\nRecording stopped on %s.') % oRecording.service_name
			MessageWindow(message, title, button=None).show(timeout=5)
		else:
			log.warn('Received unknown recording event (%s)', nEventType)
			self._conflicting_rec = None
			self.update_record_info()
		return None

	recording_event_handler = lambda self, *args, **kw : Task(self._recording_event_handler, *args, **kw).start(0.20000000000000001)

	# Called when a new live starts playing.
	#
	# Update the program information and display the info banner
	# (in case the event is not a cause of a direct zap, e.g. when a record starts).
	# recording is True if a zap is due to a recording start.
	@info_banner_activator
	@selective_gui_updater('channel_name', 'channel_type', 'speed', 'status')
	def _start_playing_event_handler(self, renderer, live, recording=False):
		log.info('Zap notification: %s', live.serviceid)
		louie_send('start_playing', sender=self)
		service_id = live.serviceid
		if recording and str(service_id) != self.selected['serviceId']:
			acl = TVRootItem().get_acl(self)
			chan_in_acl = acl.get_channel_from_service_id(live.serviceid)
			try:
				favorite_name = live.current_rec.favorite
				favorite = TVRootItem().get_favorites_root(self).get_child(favorite_name, self)
				chan = favorite.get_child(chan_in_acl.name, self)
			except (AttributeError, KeyError), e:
				PRINT_EXCEPTION(e)
				favorite = acl
				chan = chan_in_acl
			self._favorite_list = favorite
			Player.play(self, chan, favorite.browse(), False)
			self.player_info['channel_name'] = self.get_channel_name()
			self.player_info['channel_type'] = self.get_channel_type()
			self._get_record()
		return None

	start_playing_event_handler = lambda self, *args, **kw : Task(self._start_playing_event_handler, *args, **kw).start(0.050000000000000003)

	# Fired when a signal change event is received (usually means the antenna cable was plugged in or out).
	def _device_signal_event_handler(self, device_id, signal_status):
		if device_id != self.live_controller.getCurrentlive().deviceid:
			log.info('Signal changed on other device -- ignoring...')
		if signal_status:
			log.info('Acquired signal on device %s', device_id)
			louie_send('signal_acquired', sender=self)
		else:
			log.info('Lost signal on device %s', device_id)
			louie_send('signal_lost', sender=self)
		return None

	device_signal_event_handler = lambda self, *args, **kw : Task(self._device_signal_event_handler, *args, **kw).start(0.10000000000000001)

	def _service_added(self, service_info):
		log.info('Added service %s', service_info)
		title = _('New service detected')
		text = _('%(channel_name)s added on channel #%(channel_number)i.') % service_info
		MessageWindow(text, title, button=None).show(timeout=5)
		return None

	def _service_updated(self, service_info):
		log.info('Updated service %s', service_info)
		return None

	def _service_removed(self, service_info):
		log.info('Removed service %s', service_info)
		if int(self.selected['serviceId']) == service_info['service_id']:
			self.select(1)
		title = _('Service removed')
		text = _('%(channel_name)s is not available anymore.') % service_info
		MessageWindow(text, title, button=None).show(timeout=5)
		return None

	# Fired when a service update event is received.
	# Defer to the appropriate sub-handler.
	def _service_update_event_handler(self, device, service_info_list, tp_info):
		dispatch = {UPDATE_SERVICE_ADDED: self._service_added, UPDATE_SERVICE_UPDATED: self._service_updated, UPDATE_SERVICE_REMOVED: self._service_removed}
		for service in service_info_list:
			service_info = dict(zip(('service_id', 'channel_name', 'channel_number', 'channel_type'), service[0:3]))
			dispatch[service[4]](service_info)
		return None

	service_update_event_handler = lambda self, *args, **kw : Task(self._service_update_event_handler, *args, **kw).start(0.10000000000000001)

	# Called when wyplayer changes its speed.
	@selective_gui_updater('status_icon', 'speed')
	def _speed_change_event_handler(self, speed):
		self._speed = speed
		return None

	def speed_change_event_handler(self, *args, **kw):
		self._speed_change_task.args = args
		self._speed_change_task.kw = kw
		self._speed_change_task.start(0.10000000000000001)
		return None

	# Called when wyplayer detects it's started (or stopped) playing a scrambled program.
	@info_banner_activator
	def _scrambled_change_event_handler(self, scrambled):
		log.info('Player scrambled change: %s', scrambled)
		if scrambled == self._last_scrambled_status:
			return None
		if scrambled:
			self.player_info['program_freeCaMode'] = 'tvplayer_freecamode.png'
			if self._last_scrambled_status is not None:
				title = _('Scrambled program')
				text = _('This program is scrambled.')
				MessageWindow(text, title, button=None).show(timeout=5)
		elif self.live_controller.status != 'playing':
			return None
		else:
			self.player_info['program_freeCaMode'] = None
		self._last_scrambled_status = scrambled
		louie_send('freecamode_icon', sender=self, value=self.player_info['program_freeCaMode'])
		return None

	def scrambled_change_event_handler(self, *args, **kw):
		self._scrambled_change_task.args = args
		self._scrambled_change_task.kw = kw
		self._scrambled_change_task.start(0.10000000000000001)
		return None

	@tasked(0.5)
	def _set_livecontroller_speed(self, val):
		self.live_controller.speed = val
		return None

	@selective_gui_updater('speed', 'status_icon')
	@info_banner_activator
	def _set_speed(self, val):
		self._speed = val
		self._set_livecontroller_speed(val)
		return None

	def _get_speed(self):
		return self._speed

	speed = property(_get_speed, _set_speed)
	del _get_speed
	del _set_speed

	# Return the currently-selected channel's name, formatted with
	# leading logical channel number. If greater than 20 chars, truncate
	# and add an ellipsis.
	def get_channel_name(self):
		channel = self.selected
		if channel is None:
			return u''
		title = u'%02i %s' % (int(channel['logical_channel_number']), channel.name)
		return ellipsize(title, 20)

	# Return the currently-selected channel's type, as an icon name.
	def get_channel_type(self):
		channel = self.selected
		if channel is None:
			return None
		return '%s.png' % channel.display_type

	# Return the amount of time to seek by when pressing left/right.
	def get_seek_step(self):
		time_info = self._get_time_info()
		amount = (time_info.max_available_time - time_info.min_available_time) / 10.0
		return (amount if amount else 600)

	def get_record_timeshift_programbar(self, record=None):
		_lc = self.live_controller
		time_info = self._get_time_info()
		direct = time_info.max_available_time
		if self.program:
			begin = self.program['scheduledStartTime']
			end = self.program['scheduledEndTime']
		else:
			begin = time_info.min_available_time
			end = begin + user_config['tv']['timeshift_length'] * 60
		return dict(live=time_info.current_time, direct=direct, timeshift_begin=time_info.min_available_time, timeshift_end=direct, program_begin=begin, program_end=end, record_begin=(self._record.start_time if self._record else None), record_end=(self._record.stop_time if self._record else None))

	def _get_status(self):
		if self.live_controller.status in ('loading', 'idle'):
			return 'loading'
		speed = self._speed
		if speed == 1:
			try:
				return ('live' if self.live_controller.default_renderer.isPlayingOnlive() else 'timeshift')
			except Exception, e:
				PRINT_EXCEPTION(e)
				return 'unknown'
		elif speed == 0:
			return 'pause'
		elif -1 <= speed < 0:
			return 'slow_motion_rewind'
		elif 0 < speed < 1:
			return 'slow_motion_forward'
		elif speed > 1:
			return forward_tricks_icons[self.eventhandler.forward_steps.index(speed)]
		elif speed < -1:
			return backward_tricks_icons[self.eventhandler.backward_steps.index(speed)]
		return None

	# Identify and return a (channel, favorite, playlist) combination suitable for playback.
	# 
	# Used to solve problems such as "I deleted the favorite I was watching",
	# or "I deleted the channel I was watching from the current favorite",
	# when coming back to the TV universe after a trip in the home menu.
	# 
	# Note that on "unknown channel" fallbacks, _request_channel will try to
	# avoid yielding analog capture channels (unless it has no other choice).
	def _request_channel(self, req_channel=None, req_favorite=None):
		if req_favorite:
			favorite = req_favorite
		elif self._favorite_list:
			favorite = self._favorite_list
		else:
			favorite = TVRootItem().get_acl(self)
		try:
			playlist = favorite.browse()
		except BrowseError, e:
			PRINT_EXCEPTION(e)
			log.info('Cannot browse requested favorite -- falling back to the ACL')
			favorite = TVRootItem().get_acl(self)
			playlist = favorite.browse()
		if not req_channel or req_channel.name not in favorite:
			lzs = self._last_zap_service
			if lzs is not None and lzs.parent == favorite and lzs.name in favorite:
				channel = lzs
				log.info('Falling back to previous service: %s', channel)
			else:
				channel = playlist[0]
				if channel['class'].endswith('videoCapture') and len(playlist) > 1:
					channel = playlist[1]
				log.info('Falling back to first service in playlist %s: %s', playlist, channel)
		else:
			channel = req_channel
		return (channel, favorite, playlist)

	# Return whether it is possible to zap (that is, if there is at least
	# one tuner that's not recording something).
	def can_zap(self):
		return self.live_controller.canZap()

	@info_banner_activator
	@selective_gui_updater('channel_name', 'channel_type')
	def play(self, item=None, favorite=None):
		if self not in pygui_globs['menustack']:
			callbacks = WyRecord().callbacks
			callbacks.device_signal.register(self.device_signal_event_handler)
			callbacks.service_update.register(self.service_update_event_handler)
			callbacks.recording_event.register(self.recording_event_handler)
			self.live_controller.watch_property('speed', self.speed_change_event_handler)
			self.live_controller.watch_property('scrambled', self.scrambled_change_event_handler)
			self.status = 'playing'
			last_favorite_name = user_config['tv']['last_favorite_name']
			if last_favorite_name != u'all_channels_list':
				try:
					self._favorite_list = TVRootItem().get_favorites_root(self).get_child(last_favorite_name)
				except KeyError, e:
					PRINT_EXCEPTION(e)
			last_channel_index = user_config['tv']['last_channel_index']
			if last_channel_index is None:
				self._last_zap_service = None
			else:
				try:
					playlist = self._favorite_list.browse()
					self._last_zap_service = playlist[last_channel_index]
				except IndexError, e:
					PRINT_EXCEPTION(e)
					self._last_zap_service = None
		item, self._favorite_list, playlist = self._request_channel(item, favorite)
		self._initialize_record_info()
		self.clear_info_banner()
		Player.play(self, item, playlist)
		self.zap(self.selected)
		self['main_list'].cyclic = True
		from pygui.menu.players import _on_record_event
		_on_record_event()
		self.player_info['channel_name'] = self.get_channel_name()
		self.player_info['channel_type'] = self.get_channel_type()
		return None

	# Called when quitting the TV universe
	def stop(self):
		self._TVPlayer__zap_timer.stop()
		info_banner_activator.force_ending()
		record_banner_activator.force_ending()
		self._initialize_record_info()
		self._initialize_program_info()
		callbacks = WyRecord().callbacks
		callbacks.device_signal.unregister(self.device_signal_event_handler)
		callbacks.service_update.unregister(self.service_update_event_handler)
		callbacks.recording_event.unregister(self.recording_event_handler)
		self.live_controller.watch_property('speed', None)
		self.live_controller.watch_property('scrambled', None)
		Player.stop(self)
		try:
			self.live_controller.close()
		except LiveIsRecordingErrors, e:
			PRINT_EXCEPTION(e)
#			pass
		if self.shielded:
			self._unshield()
		return None

	# Fill the record info with blank/dummy values.
	def _initialize_record_info(self):
		player_info = self.player_info
		player_info['rec_status'] = None
		player_info['rec_duration'] = '--:--'
		player_info['rec_remaining_time'] = '--:--'
		player_info['rec_elapsed_time'] = '--:--'
		player_info['foreign_rec_status'] = None
		player_info['foreign_rec_channel_name'] = ''
		return None

	# Fill the player info with blank/dummy values.
	def _initialize_program_info(self):
		timeshift_duration = user_config['tv']['timeshift_length'] * 60
		utc_time = time()
		player_info = self.player_info
		player_info['program_name'] = ''
		player_info['program_content'] = ''
		player_info['program_start_time'] = seconds_to_hhmm(utc_time)
		player_info['program_stop_time'] = seconds_to_hhmm(utc_time + timeshift_duration)
		player_info['program_duration'] = seconds_to_hhmm_utc(timeshift_duration)
		player_info['program_remaining_time'] = seconds_to_hhmm_utc(timeshift_duration)
		player_info['program_elapsed_time'] = '00:00'
		player_info['program_videoFormat_16_9'] = None
		player_info['program_videoFormatHD'] = None
		player_info['program_nrAudioChannels'] = None
		player_info['program_nrSubtitleTracks'] = None
		player_info['program_subtitleHardOfHearing'] = None
		player_info['program_audioHardOfHearing'] = None
		player_info['program_audioVisuallyImpaired'] = None
		player_info['program_freeCaMode'] = None
		player_info['program_maturity_rating'] = None
		return None

	# Clear the info banner (usually called when selecting a new channel).
	@selective_gui_updater('program_name', 'program_start_time', 'program_stop_time', 'maturity_rating_icon', 'program_content', 'program_duration', 'program_elapsed_time', 'program_remaining_time', 'rec_status')
	def clear_info_banner(self):
		player_info = self.player_info
		for key, title in ProgramItem.EXTRA_INFO_FIELDS:
			if player_info['program_' + key]:
				louie_send('%s_icon' % key.lower(), sender=self, value=None)
		self._initialize_program_info()
		self._initialize_record_info()
		louie_send('record_timeshift_programbar', sender=self, value=_EMPTY_RECORD_TIMESHIFT_PROGRAM_BAR)
		return None

	@selective_gui_updater('channel_name', 'channel_type')
	@info_banner_activator
	def select(self, item):
		self._tick_can_refresh = False
		if Player.select(self, item):
			self.player_info['channel_name'] = self.get_channel_name()
			self.player_info['channel_type'] = self.get_channel_type()
			if self._TVPlayer__zap_timer.running:
				self._TVPlayer__zap_timer.stop()
			else:
				self.clear_info_banner()
			self._TVPlayer__zap_timer.start(HMI_TV['zap_time'])
		else:
			self.select(self.choices[(len(self.choices) - 1 if item < 0 else 0)])
		return True

	def toggle_menu(self):
		self._navigator.select_program(self._favorite_list, self.selected)
		ms = pygui_globs['menustack']
		if self._navigator not in ms.menus_stack:
			self._navigator.show()
			louie_send('show_program_info', sender=self._navigator)
			louie_send('empty_preview', sender=self._navigator)
			louie_send('hide_preview_program_bar', sender=self._navigator)
			louie_send('show_program_bar', sender=self._navigator)
		else:
			ms.toggle()
			self._navigator.show_help()
		record_banner_activator.force_ending()
		info_banner_activator.force_ending()
		return None

	# Return the real time.
	@property
	def real_utc_time(self):
		return time()

	# Return the timeshift's local time (which is equal
	# to the real time if no timeshift is underway).
	@property
	def timeshift_utc_time(self):
		return self._get_time_info().current_time

	# Zap to item.
	def zap(self, item=None):
		if not item:
			item = self.selected
		service_id = int(item['serviceId'])
		current_live = self.live_controller.getCurrentlive(True)
		if current_live and current_live.serviceid == service_id and self.program:
			self.new_present_epg_handler(self.program.wymedia_resource, None)
		else:
			self.program = None
		try:
			options = dict(lang=country_dict[user_config['video']['language']]['iso-639-2'], aspect_ratio=player_aspect_ratio_dict[user_config['video']['aspect_ratio']], display_format=user_config['video']['display_format'], spdif_surround=user_config['connections']['spdif_surround'])
			self.live_controller.zap(service_id, **options)
			self._get_record()
		except NoLiveAvailableError, e:
			PRINT_EXCEPTION(e)
			log.warn('too many live running %s', str(e))
			try:
				live_list = self.live_controller.getRunningLiveList()
				old_index = live_list.index(self.live_controller.getCurrentlive())
				next_live = live_list[(old_index + 1) % len(live_list)]
				service_list = Player.get_item_list(self, 'main_list')
				service_id = next_live.serviceid
				for i in xrange(len(service_list)):
					service = service_list[i]
					if int(service['serviceId']) == service_id:
						break
				acl = TVRootItem().get_acl(self)
				self._favorite_list = TVRootItem().get_acl(self)
				service = acl.get_channel_from_service_id(service_id)
				self.set_items(acl.browse(), 'main_list')
				Player.select(self, service)
				self._last_zap_service = self.selected
				self.live_controller.zap(next_live.serviceid)
				self._get_record()
			except Exception, e:
				PRINT_EXCEPTION(e)
				self._record = None
		except (StartingLiveErrors, StartLivePlayingErrors, NoDeviceForServiceErrors), e:
			PRINT_EXCEPTION(e)
			log.error('unable to start live for service %s', item.name)
			self._record = None
			return None
		except Exception, e:
			PRINT_EXCEPTION(e)
			self._record = None
			return None
		self._last_zap_service = self.selected
		user_config['tv']['last_favorite_name'] = self._favorite_list['title']
		user_config['tv']['last_channel_index'] = int(self.selected['index'])
		Task(user_config.save).start(1)
		self._last_scrambled_status = None
		if self.shielded:
			self._unshield()
		louie_send('signal_acquired', sender=self)
		# variable tick_can_refreshed is delayed to avoid to overload the player with this call
		# while it begins to read the new service.
		def turn_on_tick_delayed():
			self._tick_can_refresh = True
			return None
		Task(turn_on_tick_delayed).start(1)
		return None

	# Launch an instant recording on the current channel with the default
	# IR duration specified in hmi.xml.
	@selective_gui_updater('record_timeshift_programbar')
	def start_recording(self):
		service_name = self.selected.name
		duration = user_config['tv']['record_duration'] * 60
		start_time = self.timeshift_utc_time
		end_time = start_time + duration
		values = {'channel':service_name, 'date':strftime(get_date_format(), localtime(start_time)), 'start_time':seconds_to_hhmm(start_time), 'end_time':seconds_to_hhmm(end_time)}
		record_name = INSTANT_RECORD_NAME_PATTERN % values
		try:
			self.live_controller.startRecord(duration, record_name)
		except SchedulingDoneWithConflictErrors, e:
			conflicting_rec = e.conflict.getAllRecInConflict()[0]
			title = _('Instant recording conflict')
			message_pattern = _('This instant recording will stop when the scheduled recording "%(name)s" starts at %(start_time)s on %(channel)s.')
			message = message_pattern % {'name': ellipsize(conflicting_rec.name, 40), 'start_time': seconds_to_hhmm(conflicting_rec.start_time), 'channel': conflicting_rec.service_name}
			MessageWindow(message, title, button=None).show(timeout=5)
			self._conflicting_rec = conflicting_rec
		except SchedulingFailedOnConflictErrors, e:
			conflicting_rec = e.conflict.getAllRecInConflict()[0]
			title = _('Instant recording conflict')
			message_pattern = _('A recording is already in progress on %s.')
			message = message_pattern % conflicting_rec.service_name
			MessageWindow(message, title, button=None).show(timeout=5)
			return None
		info_banner_activator((lambda self: None))(self)
		record_banner_activator((lambda self: None))(self)
		return None

	# Stop a recording in progress, adjusting its name to reflect its new (and final) parameters.
	#
	# @param rec: The recording to stop
	# @param stop_at_player_pos: If True and the player is currently timeshifting,
	# stop the recording at the current timeshift time.
	@selective_gui_updater('rec_duration', 'rec_status', 'rec_remaining_time', 'record_timeshift_programbar')
	def stop_recording(self, rec, stop_at_player_pos=False):
		if rec.type == RECORDING_TYPE_NOT_SCHEDULED:
			start_time = rec.start_time
			end_time = (self.timeshift_utc_time if stop_at_player_pos else self.real_utc_time)
			values = {'channel': rec.service_name, 'date': strftime(get_date_format(), localtime(start_time)), 'start_time': seconds_to_hhmm(start_time), 'end_time': seconds_to_hhmm(end_time)}
			rec.name = INSTANT_RECORD_NAME_PATTERN % values
		self.live_controller.scheduler.StopRecording(rec.id, stop_at_player_pos)
		return None

	# Display the record banner and prompt the user to stop the
	# recording on the current channel. Triggered when the user presses stop and
	# a record is in progress.
	@record_banner_activator
	@selective_gui_updater('rec_duration', 'rec_remaining_time')
	def _prompt_stop_record(self):
		message = _('A recording is in progress. %s remaining. Stop it ?') % self.player_info['rec_remaining_time']
		messbox = ConfirmWindow(text=message, confirm_action=self.stop_recording, confirm_args=[self._record, True])
		messbox.show()
		return None

	# Prompt the user to stop the recording on a channel they aren't watching.
	# Triggered when the user presses stop and a record is in progress on
	# another channel than the one they're watching.
	def _prompt_stop_foreign_rec(self):
		record = self._foreign_rec
		message_pattern = _('A recording is in progress on channel %(channel)s. %(remaining_time)s remaining. Stop it?')
		data = {'channel': record.service_name, 'remaining_time': seconds_to_hhmm_utc(max(0, record.stop_time + record.stop_padding - self.real_utc_time))}
		messbox = ConfirmWindow(text=message_pattern % data, confirm_action=self.stop_recording, confirm_args=[record])
		messbox.show()
		return None

	@record_banner_activator
	@info_banner_activator
	@selective_gui_updater('rec_duration', 'rec_remaining_time', 'record_timeshift_programbar')
	def set_record_duration(self, offset):
		if self._record is not None:
			try:
				duration = self._record.stop_time - self._record.start_time + offset
				if 1800 <= duration <= user_config['tv']['max_record_duration'] * 60:
					rec = self._record
					start_time = rec.start_time
					end_time = start_time + duration
					values = {'channel': rec.service_name, 'date': strftime(get_date_format(), localtime(start_time)), 'start_time': seconds_to_hhmm(start_time), 'end_time': seconds_to_hhmm(end_time)}
					rec.name = INSTANT_RECORD_NAME_PATTERN % values
					real_utc_time = self.real_utc_time
					self.live_controller.setDuration(duration)
					self.update_record_info()
			except SchedulingFailedOnDiskSpaceErrors, e:
				log.error('Record duration not changed because of insufficient disk space (%s remaining, we need %s)', e.space_needed, e.space_available)
				title = _('Not enough disk space')
				message = _("This recording duration was not changed because there isn't enough disk space to store it.")
				MessageWindow(message, title, button=None).show(timeout=5)
			except SchedulingFailedOnConflictErrors, e:
				log.error('Record duration not changed because of an overlap with another scheduled record')
				conflicting_rec = e.conflict.getAllRecInConflict()[0]
				title = _('Conflict with another scheduled recording')
				message_pattern = _('This record\'s duration was not changed because it would conflict with "%(name)s", starting at %(start_time)s on %(channel)s.')
				message = message_pattern % {'name': ellipsize(conflicting_rec.name, 40), 'start_time': seconds_to_hhmm(conflicting_rec.start_time), 'channel': conflicting_rec.start_time}
				MessageWindow(message, title, button=None).show(timeout=5)
			except SchedulingDoneWithConflictErrors, e:
				log.error('Record duration changed, but there are conflicts')
				conflicting_rec = e.conflict.getAllRecInConflict()[0]
				title = _('Conflict with a scheduled recording')
				message_pattern = _('This instant recording will stop when the scheduled recording "%(name)s" starts at %(start_time)s on %(channel)s.')
				message = message_pattern % {'name': ellipsize(conflicting_rec.name, 40), 'start_time': seconds_to_hhmm(conflicting_rec.start_time), 'channel': conflicting_rec.start_time}
				MessageWindow(message, title, button=None).show(timeout=5)
			except DefaultLiveControllerError, e:
				log.error('Unable to change recording duration: %s', e)
		return None

	# Retrieve information about currently-running recordings.
	def _get_record(self):
		current_live = self.live_controller.current_live
		if current_live:
			self._record = current_live.current_rec
		for live in self.live_controller.getRunningLiveList():
			rec = live.current_rec
			if rec and live != current_live:
				self._foreign_rec = rec
				break
		else:
			self._foreign_rec = None
		self.update_record_info()
		return None

	# Update the recording info text fields and pictograms.
	@selective_gui_updater('rec_status', 'foreign_rec_status', 'foreign_rec_channel_name', 'rec_duration', 'rec_remaining_time', 'rec_elapsed_time')
	def update_record_info(self):
		player_info = self.player_info
		record = self._record
		if record:
			real_utc_time = self.real_utc_time
			player_info['rec_status'] = 'tvplayer_recording.png'
			player_info['rec_duration'] = seconds_to_hhmm_utc(record.stop_time - record.start_time)
			player_info['rec_elapsed_time'] = seconds_to_hhmm_utc(real_utc_time - record.start_time)
			player_info['rec_remaining_time'] = seconds_to_hhmm_utc(max(0, record.stop_time + record.stop_padding - real_utc_time))
		else:
			self._initialize_record_info()
		if self._foreign_rec:
			player_info['foreign_rec_status'] = 'tvplayer_foreign_recording.png'
			player_info['foreign_rec_channel_name'] = self._foreign_rec.service_name
		else:
			player_info['foreign_rec_status'] = None
			player_info['foreign_rec_channel_name'] = ''
		return None

	def resume(self):
		self.live_controller.resume()
		self._speed = 1
		return None

	def pause(self):
		self.live_controller.pause()
		self._speed = 0
		return None

	@info_banner_activator
	@selective_gui_updater('status_icon')
	def action_seek(self, offset):
		self.live_controller.seek(offset)
		return None

	@selective_gui_updater('rec_duration', 'rec_remaining_time')
	def action_rec(self):
		if self.live_controller.current_live.IsRecording:
			info_banner_activator((lambda self: None))(self)
			record_banner_activator((lambda self: None))(self)
		self.start_recording()
		return None

	@info_banner_activator
	@selective_gui_updater('speed', 'status_icon')
	def action_play_pause(self):
		sp = self._speed
		if abs(sp) <= 1 and sp != 0:
			self.pause()
		else:
			self.resume()
		return None

	def action_info(self, refresh=False):
		if info_banner_activator._timer and info_banner_activator._timer.running and not refresh:
			info_banner_activator.force_ending()
		else:
			info_banner_activator((lambda self: None))(self)
		return None

	# If a recording is in progress (anywhere), prompt the user to stop it.
	def action_stop(self):
		self.update_record_info()
		if self._record:
			self._prompt_stop_record()
		elif self._foreign_rec:
			self._prompt_stop_foreign_rec()
		return None

	def action_vertical(self, offset):
		inverted = HMI_TV['invert_y_axis']
		if record_banner_activator._timer.running:
			if self._record is not None:
				self.set_record_duration(offset * HMI_TV['record_duration_step'])
				self.player_info['rec_duration'] = self._record
		elif self.can_zap():
			self.select((not offset if inverted else offset))
		else:
			title = _('A recording is in progress.')
			message = _('Stop the recording before changing channels.')
			MessageWindow(message, title, button=None).show(timeout=5)
		return None

	def schedule_record(self):
		from pygui.menu.menu.tv.scheduled_record import ScheduledRecordMenu
		_loading = LoadingWindow()
		_loading.show()
		menu = ScheduledRecordMenu()
		menu.select_channel(self.selected, self._favorite_list)
		date = self.real_utc_time
		menu.select_date(date, date + 3600)
		menu.show()
		_loading.hide()
		return None

	def display_epg(self):
		from pygui.menu.menu.tv.epg_grid import EpgGridMenu
		menu = EpgGridMenu(player=self, channel_list=self._favorite_list, selected_chan=self.selected)
		menu.show()
		return None

	@gui_updater
	def zapping_rollback(self):
		Player.select(self, self._last_zap_service)
		return None

	# Clear the last zap service and favorite list --
	# if called when the player is stopped, restarting it
	# will make it zap on the ACL's first item instead of
	# the last played service.
	# 
	# Used mostly to ensure the player plays the first channel in
	# the ACL right after a scan (bugtraq: 2029).
	def clear_last_zap(self):
		self._last_zap_service, self._favorite_list = None, None
		user_config['tv']['last_favorite_name'] = u'all_channels_list'
		user_config['tv']['last_channel_index'] = None
		Task(user_config.save).start(1)
		return None

	def goto_schedule_record(self):
		ms = pygui_globs['menustack']
		if self._navigator not in ms.menus_stack:
			self._navigator.show(hide_previous_menu=False)
			self._navigator.select_schedule_recordings()
		else:
			ms.toggle()
			self._navigator.select_schedule_recordings()
		return None
