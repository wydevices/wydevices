# -*- coding: utf-8 -*- 
#
# Description:
#
# Channel Scanner Player Class Definition
#
#
#
# Changes:
#
# 2014-04-07
# Initial Commit
#
#
# Copyright 2010-2014, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.


from __future__ import absolute_import

from time import time
from peewee.debug import PRINT_EXCEPTION, GET_LOGGER
from peewee.messages import send as louie_send
from peewee.notifier import Task, tasked
from wyrecord.callbacks import UPDATE_SERVICE_ADDED, UPDATE_SERVICE_UPDATED, UPDATE_SERVICE_REMOVED
from pygui.config import user_config
from pygui.eventmanager.menus import ChannelScannerEventHandler
from pygui.shared import pygui_globs
from pygui.window import TextWindow, ConfirmWindow, Button, LoadingWindow, MessageWindow
from pygui.menu import selective_gui_updater, UNIVERSE_NAME_DICT
from pygui.item.core import Item
from pygui.item.mediaitem import ChannelItem
from pygui.menu.players.core import Player

log = GET_LOGGER(__name__)


# ChannelScanner interface.
# Used for DVB-S and DVB-T scan.
class ChannelScanner(Player):

	wyscanserver = None
	_back_main_menu = False
	_waiting_for_commit = False

	def __init__(self, type='channelscanner'):
		Player.__init__(self, 'channelscanner')
		self.scan_status = [0, 0, 0, 0]
		self.eventhandler = ChannelScannerEventHandler(self)
		self.set_items([], list_name='video_services')
		self.set_items([], list_name='radio_services')
		self._new_services = False
		self.video_services = []
		self.radio_services = []
		self._running = False
		self._message_window = LoadingWindow()
		self._getitems_keywords.update(dict(signal_strength_progress_bar=(lambda : dict(pos=self.scan_status[2], max=100)), signal_strength=(lambda : '%d%%' % self.scan_status[2]), signal_noise_ratio_progress_bar=(lambda : dict(pos=self.scan_status[3], max=100)), signal_noise_ratio=(lambda : '%d%%' % self.scan_status[3]), scan_progressbar=(lambda : dict(pos=self.scan_status[0], max=self.scan_status[1])), scan_progress=(lambda : '%d%%' % (100 * float(self.self.scan_status[0]) / self.self.scan_status[1] if self.self.scan_status[0] > 0 else 0)), video_services_list=(lambda : self.get_item_list('video_services')), radio_services_list=(lambda : self.get_item_list('radio_services')), nb_video_services=(lambda : '%d' % len(self.video_services)), nb_radio_services=(lambda : '%d' % len(self.radio_services)), scan_name=(lambda : UNIVERSE_NAME_DICT[self.type])))
		return None

	# Start the scan.
	def play(self, item, playlist=None, hide_previous_menu=True):
		Player.play(self, item, playlist, hide_previous_menu=hide_previous_menu)
		ChannelScanner._back_main_menu = False
		if self.wyscanserver is not self.selected.wyscanserver:
			self.wyscanserver = self.selected.wyscanserver
			self.wyscanserver.errorCallback.register(self.dbus_error_callback)
			self.wyscanserver.eventCallback.register(self.dbus_event_callback)
			self.wyscanserver.scanEventCallback.register(self.dbus_scan_callback)
			self.wyscanserver.serviceUpdateCallback.register(self.dbus_scan_service_found_callback)
			self.wyscanserver.scanProgression.register(self.dbus_scan_progression)
		self.wyscanserver.ConfigurePermanentScan(item.include_scrambled, False)
		ret_scan = self.wyscanserver.StartScan(item.antenna[7], item.antenna[6], item.transponder[0], item.scan_network, item.include_scrambled)
		if ret_scan:
			self._stop()
			MessageWindow(title=_('Error'), text=_('Scan impossible')).show()
		else:
			self.wyscanserver.RemoveAllServices()
		self._running = False
		self._waiting_for_commit = False
		return None

	def dbus_error_callback(self, *args, **kw):
		log.warning('ERROR %s %s', args, kw)
		self._stop()
		return None

	def dbus_event_callback(self, *args, **kw):
		log.debug('EVENT %s %s', args, kw)
		return None

	def dbus_scan_callback(self, *args, **kw):
		def _callback(self, *args, **kw):
			nDeviceID, nEventID = args
			if nDeviceID != self.selected.antenna[7]:
				return None
			if nEventID == 1:
				self._running = True
			elif nEventID == 2:
				self._running = False
				self.prompt_for_commit()
			elif nEventID == 3:
				self._message_window.hide()
				self._stop()
			return None
		log.debug('SCAN EVENT CALLBACK %s %s', args, kw)
		Task(_callback, self, *args, **kw).start(0.10000000000000001)
		return None

	@tasked(0.10000000000000001)
	def dbus_scan_progression(self, TP_index, TP_list_size, signal_strength, signal_noise_ratio):
		self.scan_status = [TP_index, TP_list_size, signal_strength, signal_noise_ratio]
		louie_send('scan_progress', sender=self, value=self['scan_progress'])
		louie_send('scan_progressbar', sender=self, value=self['scan_progressbar'])
		log.debug(self.scan_status)
		return None

	@tasked(0.10000000000000001)
	def dbus_scan_service_found_callback(self, device, service_info_list, tp_info):
		log.debug('Services found: %s', service_info_list)
		for service_info in service_info_list:
			log.info('Service: %s -- channel_id: %s -- channel_name:%s', service_info[0], service_info, service_info[1])
			if service_info[0] == UPDATE_SERVICE_ADDED:
				self.video_services.insert(0, Item(service_info[1], 'channel'))
		else:
			log.info('NO service found')
		self._update_services()
		return None

	# Sync the display with the actual services list.
	# 
	# This is done here and not in the dbus callbacks because the dbus
	# callback is called in a separate thread.
	# This method, however, is tasked.
	@selective_gui_updater('nb_video_services', 'nb_radio_services')
	def _update_services(self):
		self.set_items(self.video_services, 'video_services_list')
		return None

	def tick_callback(self):
		return None

	def unregister_wyscan_callbacks(self):
		self.wyscanserver.errorCallback.unregister(self.dbus_error_callback)
		self.wyscanserver.eventCallback.unregister(self.dbus_event_callback)
		self.wyscanserver.scanEventCallback.unregister(self.dbus_scan_callback)
		self.wyscanserver.serviceUpdateCallback.unregister(self.dbus_scan_service_found_callback)
		self.wyscanserver.scanProgression.unregister(self.dbus_scan_progression)
		self.wyscanserver = None
		return None

	def _stop(self):
		self.scan_status = [0, 0, 0, 0]
		louie_send('scan_progress', sender=self, value=self['scan_progress'])
		louie_send('scan_progressbar', sender=self, value=self['scan_progressbar'])
		ms = pygui_globs['menustack']
		try:
			self.unregister_wyscan_callbacks()
			if ChannelScanner._back_main_menu:
				ms.back_to_home()
			elif not ms.is_on_firstboot() and len(self.video_services) > 0:
				ms.back_to_home(safe=False)
				ms.get_root().launch_tv()
			elif len(pygui_globs['menustack'].menus_stack) <= 2:
				ms.back_to_home()
			else:
				ms.back_one_menu()
				louie_send('tv_scan_finished', sender='tv')
		except:
			PRINT_EXCEPTION()
		return None

	# Ask Wyscan to stop scanning (will trigger callbacks)
	def process_stop(self):
		self.wyscanserver.StopScan(self.selected.antenna[7])
		return None

	def stop(self):
		Player.stop(self)
		if self._running:
			ChannelScanner._back_main_menu = True
			self.wyscanserver.StopScan(self.selected.antenna[7])
		elif self._waiting_for_commit:
			self.wyscanserver.RollbackScan(self.selected.antenna[7])
			self.unregister_wyscan_callbacks()
		return None

	# If any channels were found during the scan, prompt the user to save them.
	# 
	# Afterwards, return to the previous menu.
	def prompt_for_commit(self):
		device_id = self.selected.antenna[7]
		self.scan_status[0] = self.scan_status[1]
		louie_send('scan_progress', sender=self, value=self['scan_progress'])
		louie_send('scan_progressbar', sender=self, value=self['scan_progressbar'])
		num_services = len(self.radio_services) + len(self.video_services)
		if num_services == 0 or ChannelScanner._back_main_menu:
			self.wyscanserver.RollbackScan(self.selected.antenna[7])
			self._stop()
			return None
		self._waiting_for_commit = True
		def _rollback():
			self.wyscanserver.RollbackScan(self.selected.antenna[7])
			ChannelScanner._back_main_menu = True
			self._stop()
			return None
		def _commit():
			if ChannelItem.player is not None:
				ChannelItem.player.clear_last_zap()
			self.wyscanserver.CommitScan(self.selected.antenna[7])
			user_config['tv']['last_scan_time'] = time()
			user_config.save()
			self._message_window.show()
			return None
		message = _('%(num_services)i channels found. Do you want to save them ?')
		values = {'num_services': num_services}
		button = Button(_('OK'), True)
		button.connect(_commit)
		cancel_button = Button(_('No'), False)
		cancel_button.connect(_rollback)
		w = ConfirmWindow(text=message % values, buttons=[button, cancel_button])
		Task(w.show).start(0.5)
		return None
