# -*- coding: utf-8 -*- 
#
# Description:
#
# Audio Player Class Definition
#
#
#
# Changes:
#
# 2011-11-12
# Initial Commit
#
#
#
# Copyright 2010-2014, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.


from __future__ import absolute_import

__all__ = ['AudioPlayer']

import pygui.config as config
from peewee.debug import GET_LOGGER, PRINT_EXCEPTION
from peewee.messages import send as louie_send
from peewee.messages import connect as louie_connect
from peewee.messages import disconnect as louie_disconnect
from peewee.notifier import tasked
from peewee.notifier import Task
from pygui.eventmanager.players import AudioEventHandler
from pygui.menu.players.core import user_action, Player, WPlayer
from pygui.menu import selective_gui_updater
from pygui.shared import pygui_globs
from random import choice

log = GET_LOGGER(__name__)



class AudioPlayer(Player, WPlayer):

	media = 'audio'
	_audio_stream = True
	_video_stream = False
	_sub_stream = False
	caching_sig = ('scroll_up', 'scroll_down', 'everything')

	def __init__(self):
		Player.__init__(self, 'audioplayer')
		WPlayer.__init__(self)
		self._getitems_keywords['edit_list'] = self._get_edit_list
		self._getitems_keywords['title'] = self._get_title
		self._getitems_keywords['artist'] = self._get_artist
		self._getitems_keywords['album'] = self._get_album
		self._getitems_keywords['track'] = self._get_track
		self.tasks.update({'show_help_playlist': Task(self._show_help_playlist), 'hide_help_playlist': Task(self._hide_help_playlist)})
		self.set_items([], 'edit_list')
		self.eventhandler = AudioEventHandler(self)
		self.available_choices.append('edit_list')
		self._old_played_dt = None
		self._old_played = None
		self._current_played = None
		for sig in AudioPlayer.caching_sig:
			louie_connect(receiver=self._callback_fill_list, sender='audio', signal=sig)
		self._status_change_callback.task._considered_idle = True
		self._start_playing.task._considered_idle = True
		self.update_media_info.task._considered_idle = True
		return None

	def _get_edit_list(self):
		return self.get_item_list('edit_list')

	def _get_title(self):
		if self.selected['metadata_title']:
			return self.selected['metadata_title']
		else:
			return self.selected['name']

	def _get_artist(self):
		return self.selected['author']

	def _get_album(self):
		return self.selected['album']

	def _get_track(self):
		if self.selected['track']:
			return self.selected['track']
		else:
			return u''

	def _start_timers(self):
		self.tasks['tick'].start(self._timers_interval, loop=True, consider_idle=True)
		self.tasks['screensaver_block'].start(delay=config.user_config['power']['screensaver_threshold'] - 1, loop=True, consider_idle=True)
		return None

	# The info banner (status icon) is always active in the audio player.
	def could_remove_banner(self):
		return False

	@tasked(0.10000000000000001)
	def _status_change_callback(self, status):
		log.info('status changed: %s', status)
		WPlayer._status_change_callback(self, status)
		if not self._start_playing.task.running and self.old_status == 'playing' and self.stopped:
			if self.repeat_mode == 'track':
				try:
					WPlayer.play(self, self.get_item_list('main_list').selected)
				except OverflowError:
					PRINT_EXCEPTION(stop=True)
			else:
				if self._check_exception():
					self.stack.close_player()
				if not self.random_mode:
					if not self.select(1):
						if self.repeat_mode == 'all':
							old_pos = self.selected_pos
							self.select(0, force_pos=True)
							if self.selected_pos == old_pos:
								self._start_playing()
						else:
							self.stack.close_player()
				else:
					self.select_random()
		log.debug('end status changed')
		return None

	# do a select with a random pos from unplayed_positions.
	def select_random(self):
		if not self._unplayed_positions:
			if self.repeat_mode == 'all':
				self.random_mode = False
				self.go_random()
			else:
				self.stack.close_player()
		pos = choice(self._unplayed_positions)
		ret = self.select(pos, force_pos=True)
		if not ret:
			log.error('unable to select track %s', pos)
			self.stack.close_player()
		else:
			try:
				idx = self._unplayed_positions.index(pos)
				del self._unplayed_positions[idx]
			except:
				log.warn('error removing current position from unplayed_positions: %s', self.selected_pos)
		return ret

	# go in random mode and build unplayed_positions
	def go_random(self):
		if self.random_mode:
			self.random_mode = False
			self._unplayed_positions = []
		else:
			if self.selected:
				npl = None
				if self.universe + ':npl' in self.selected.npl_dict:
					npl = self.selected.npl_dict[self.universe + ':npl']
				else:
					from pygui.markerlist import markerlists
					fl = markerlists().get(self.universe)
					if fl is not None:
						npl = fl.now_playing
				if npl:
					npl.wymedia_resource['childCount'] = str(npl.get_child_count())
					self._unplayed_positions = range(0, int(npl.wymedia_resource['childCount']))
					try:
						idx = self._unplayed_positions.index(self.selected_pos)
						del self._unplayed_positions[idx]
					except:
						log.warn('error removing current position from unplayed_positions: %s', self.selected_pos)
					self.random_mode = True
		return None

	@selective_gui_updater('progressbar', 'time_remaining', 'time_elapsed', 'time_total', 'status_icon', 'playmode_icon')
	def tick_callback(self):
		log.debug('Tick!')
		if not self._start_playing.task.running and self.status == 'playing':
			WPlayer.tick_callback(self)
		return None

	@tasked(0.40000000000000002)
	@selective_gui_updater('progressbar', 'time_remaining', 'time_elapsed', 'time_total')
	def update_media_info(self):
		WPlayer.update_media_info(self)
		return None

	# refresh edit_list and display_type when song changes
	def song_changed(self):
		main_list = self.get_item_list('main_list')
		edit_list = self.get_item_list('edit_list')
		if self._old_played:
			if not self._old_played_dt:
				self._old_played.display_type = 'audio_audio'
			else:
				self._old_played.display_type = self._old_played_dt
		self._old_played_dt = main_list.selected.display_type
		main_list.selected.display_type = 'audioplayer_audio_playing'
		log.debug('loudspeaker icon %s -> %s', self._old_played, main_list.selected)
		louie_send('edit_list', sender=self, action='reset', value=edit_list)
		self._selection_changed(None)
		try:
			sel = main_list.selected
			sel.watch(self._selection_changed)
			sel.async_media_update()
		except AttributeError:
			log.warn('%s.watch failed !', sel)
		return None

	def _selection_changed(self, item):
		try:
			louie_send('title', sender=self, value=self['title'])
			louie_send('artist', sender=self, value=self['artist'])
			louie_send('album', sender=self, value=self['album'])
			louie_send('track', sender=self, value=self['track'])
		except:
			log.error('Tags error')
		# TODO: screensaver
		screensaver = pygui_globs['screensaver']
		if screensaver is not None:
			screensaver.refresh_metadata(self['title'], self['artist'], self['album'])
		return None

	def select(self, val, list_name='main_list', force_pos=False):
		if not self.get_item_list('main_list').selected:
			self._old_played = None
		else:
			self._old_played = self.get_item_list('main_list').selected
		if self._old_played is not None:
			try:
				self._old_played.unwatch(self._selection_changed)
			except AttributeError:
				log.info('Item %s is not unwatchable', self._old_played)
		sel_ret = Player.select(self, val, list_name=list_name, force_pos=force_pos)
		if list_name != 'main_list':
			return sel_ret
		if sel_ret is True:
			if val > 0:
				louie_send('event_up', self)
			else:
				louie_send('event_down', self)
			self.song_changed()
			self._start_playing()
		return sel_ret

	def play(self, item=None, playlist=None):
		self.time_elapsed = 0.0
		self.random_mode = False
		self._unplayed_positions = []
		try:
			log.debug('PLAY(%s)', item)
			Player.play(self, item, playlist)
		except:
			PRINT_EXCEPTION()
			if self._check_exception(_("Can't find media")):
				pygui_globs['menustack'].close_player()
				return None
		self.song_changed()
		self._start_playing()
		return None

	@user_action
	def action_play(self):
		if self.stopped:
			self.play(self.get_item_list('main_list').selected)
		else:
			if self.speed == 1:
				self.speed = 0
			else:
				self.speed = 1
		return None

	@tasked(config.HMI_MUSIC['lazy_selection'])
	def _start_playing(self):
		log.debug('start playing...')
		try:
			sel = self.get_item_list('main_list').selected
			log.info('Start playing %s', sel)
			WPlayer.play(self, sel, show_loading=True)
		except Exception, e:
			PRINT_EXCEPTION(e)
			log.debug('Player unable to load/read selected item')
			if not self.select(1):
				pygui_globs['menustack'].close_player()
		return None

	def stop(self):
		log.debug('stop() on MMI PLAYER')
		if self.active_list == 'edit_list':
			self.get_item_list('edit_list').edited = False
			self.focus_previous()
		try:
			self.get_item_list('main_list').selected.unwatch(self._selection_changed)
		except AttributeError:
			log.info('Item %s is not unwatchable', self.get_item_list('main_list').selected)
		self._start_playing.task.stop()
		WPlayer.stop(self)
		Player.stop(self)
		for sig in AudioPlayer.caching_sig:
			louie_disconnect(receiver=self._callback_fill_list, signal=sig, sender='audio')
		return None

	def refresh_edit_list(self, edit_list):
		edit_list.set_items(self.get_item_list('main_list'))
		edit_list.select(self.selected)
		self.focus_next()
		return None

	def _show_help_playlist(self):
		if config.user_config['base']['help_banner']:
			louie_send('show_help_playlist', sender=self)
			self.hide_help_playlist()
		return None

	def show_help_playlist(self):
		if self.show_help_banner:
			self.tasks['show_help_playlist'].start(0.5)
		return None

	def _hide_help_playlist(self):
		if config.user_config['base']['help_banner'] != 1:
			louie_send('hide_help_playlist', self)
		return None

	def hide_help_playlist(self):
		if self.show_help_banner:
			self.tasks['hide_help_playlist'].start(config.HMI_BASE['helpbanner_duration'])
		return None

	# Method called when data cache has changed in edit_list to set good display_type to currently played item (communication by signals)
	def _callback_fill_list(self, signal, sender, items):
		if self.active_list == 'edit_list':
			on_air_item = self._current_played
			for it in items:
				if it == on_air_item:
					it.display_type = 'audioplayer_audio_playing'
		return None
