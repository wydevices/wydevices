# -*- coding: utf-8 -*- 
#
# Description:
#
# Core Player Class Definition
#
#
#
# Changes:
#
# 2011-10-19
# Initial Commit
#
#
#
# Copyright 2010-2014, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.


from __future__ import absolute_import

__all__ = ['Player', 'WPlayer', 'wyplayer_instance']

from threading import Event
from time import gmtime, sleep, time
from peewee.debug import GET_LOGGER, PRINT_EXCEPTION
from peewee.messages import send as louie_send
from peewee.notifier import Task, sched, tasked
from pygui.facilities.codemapping import player_aspect_ratio_dict
from pygui.shared import pygui_globs
from pygui.menu import selective_gui_updater
from pygui.menu.menu import Menu
from pygui.window import BigMessageWindow, LoadingWindow
from peewee.misc_utils import MetaSingleton
import pygui.config as config

log = GET_LOGGER(__name__)



class _WyPlayerWrap(object):

	__metaclass__ = MetaSingleton

	def __init__(self):
		if not config.no_PLAYERS:
			from wyplayer import WyPlayer
			self.player = WyPlayer(arch=config.architecture)
		else:
			self.player = config.no_PLAYERS



def wyplayer_instance():
	return _WyPlayerWrap().player

def _seconds_to_hhmmss(time_val):
	return '%d:%02d:%02d' % tuple(gmtime(time_val)[3:6])

def _seconds_to_hhmm(time_val):
	return '%d:%02d' % tuple(gmtime(time_val)[3:5])

def _guarded_seconds_to_hhmmss(time_val):
	if time_val <= 0:
		return '--:--:--'
	return '%d:%02d:%02d' % tuple(gmtime(time_val)[3:6])



# OO and slightly more flexible replacement for user_action and friends.
# Doesn't replace them all yet, but soon will. Trust me.
#
# XXX user_action = TimerActivator(signals=('on_user_event', 'on_user_idle'), _check=True)
class TimerActivator(object):

	def __init__(self, signals=('on_start', 'on_stop'), delay=2, _check=False):
		self.signals = signals
		self._timer = Task(self.handler)
		self._delay = delay
		self._sender = None
		self._check = _check
		return None

	def handler(self):
		if self._check and not self._sender.could_remove_banner():
			return None
		self._timer.stop()
		louie_send(self.signals[1], sender=self._sender)
		self._sender.tasks['tick'].stop()
		return None

	def __call__(self, func):
		def _exec(menu, *args, **kw):
			ret = None
			try:
				ret = func(menu, *args, **kw)
			except Exception, e:
				log.debug('%s', e)
			self._sender = menu
			if self._timer.running:
				self._timer.start(loop=True, consider_idle=True)
			else:
				self._timer.start(self._delay, loop=True, consider_idle=True)
				self._sender._start_timers()
				louie_send(self.signals[0], sender=self._sender)
			return ret

		return _exec

	def force_ending(self, mute=False):
		if self._timer.running:
			self._timer.stop()
			if not mute:
				louie_send(self.signals[1], sender=self._sender)
				self._sender.tasks['tick'].stop()
		return None



user_action = TimerActivator(signals=('on_user_event', 'on_user_idle'), delay=config.HMI_VIDEO['idle_threshold'], _check=True)



# Class base for Player application
#
# A Player is a specialized Menu which can (dis)play media such as Audio, Video or Image,...
# When we want to play something, a playlist may be passed. So the Player will
# sequentially play all media present in the playlist.
class Player(Menu):

	toggleable = True
	_timers_interval = 1
	_idle_timer = None

	def __init__(self, type_, universe=None):
		self.stack = pygui_globs['menustack']
		self.total_time = 0.0
		self.time_elapsed = 0.0
		Menu.__init__(self, [], type=type_, universe=universe)
		self._getitems_keywords.update(dict(time_elapsed=(lambda : _seconds_to_hhmmss(round(self.time_elapsed))), time_remaining=(lambda : _guarded_seconds_to_hhmmss(round(self.total_time) - round(self.time_elapsed))), time_total=(lambda : _guarded_seconds_to_hhmmss(round(self.total_time))), progressbar=self._get_progressbar, status_icon=self._get_status_icon, playmode_icon=self._get_playmode_icon, subtitles=(lambda : '')))
		self.tasks['tick'] = Task(self.tick_callback)
		self.tasks['screensaver_block'] = Task((lambda : None))
		return None

	# Return whether the info banner can be removed.
	# Default behavior is to leave the info banner on as long as
	# the player is neither in pause, nor playing at x1 speed.
	def could_remove_banner(self):
		return self.speed in (0, 1)

	def _get_progressbar(self):
		if self.total_time - self.time_elapsed >= 1.0:
			return dict(pos=round(self.time_elapsed), max=round(self.total_time))
		else:
			return dict(pos=round(self.total_time), max=round(self.total_time))

	def tick_callback(self):
		return None

	def _start_timers(self):
		self.tasks['tick'].start(self._timers_interval, loop=True, init_delay=0)
		self.tasks['screensaver_block'].start(delay=config.user_config['power']['screensaver_threshold'] - 1, loop=True)
		return None

	def _get_status_icon(self):
		try:
			status = self._get_status()
		except AttributeError:
			status = None
		if status:
			return status + '.png'
		return None

	def _get_playmode_icon(self):
		status = self._get_playmode()
		if status:
			return status + '.png'
		return None

	# Try to return the playlist attached to 'item' in a generic way
	# If no playlist is attached, return item itself (eg. the playlist is only composed by item)
	def _playlist_from_item(self, item):
		try:
			new_playlist = item.get_playlist()
			if not isinstance(new_playlist, (list, tuple)):
				new_playlist = new_playlist.playlist
		except Exception, e:
			log.warn(' **Warning** Cannot get playlist: %s', e)
			new_playlist = [item]
		return new_playlist

	def select(self, item_or_pos, list_name='main_list', force_pos=False):
		if self.get_item_list(list_name).selected == item_or_pos:
			return False
		ret = Menu.select(self, item_or_pos, list_name=list_name, force_pos=force_pos)
		if list_name != 'main_list':
			return None
		if ret:
			self.time_elapsed = 0.0
			self.total_time = 0.0
		if self.stack.is_on_top(self):
			self.stack.back_to_menu(self)
		louie_send('main_list', sender=self, action='reset', value=self['main_list'], position=self['main_list'].selected_pos)
		return ret

	def clear(self):
		if self.status is None:
			log.debug('Clearing player...')
			for k in self.item_lists_dict:
				self.item_lists_dict[k].set_items([])
		return None

	# Play media
	# Parameters :
	#  * item (optional)     : Item instance to be played
	#  * playlist (optional) : list of Item to be played
	# !!! item AND playlist can't be both None
	def play(self, item=None, playlist=None, hide_previous_menu=True):
		self.status = True
		stack = self.stack
		if not playlist:
			playlist = [item]
		if not item:
			item = playlist[0]
		self.universe = item.menu.universe
		if playlist != self.choices:
			self.set_items(playlist, 'main_list', item)
		if self not in stack:
			stack.close_player()
			self.show(hide_previous_menu=hide_previous_menu)
			self._start_timers()
		elif hide_previous_menu:
			stack.bubble_raise(self)
		return None

	def stop(self):
		self.status = None
		self.total_time = 0.0
		self.time_elapsed = 0.0
		if self._idle_timer is not None:
			self._idle_timer.stop()
		try:
			nav = self.stack.get_navigator()
			if nav:
				nav.force_preview = True
		except:
			PRINT_EXCEPTION()
		Menu.stop(self)
		return None

	# launch InfoMenu for selected Item
	def action_info(self):
		if self.selected:
			from pygui.menu.menu.info import item_info_menu_dict
			try:
				info_menu = item_info_menu_dict[self.selected.type](self.selected)
			except KeyError:
				log.warn('No InfoMenu defined for type %s', self.selected.type)
			else:
				info_menu.show()
		return None

	@tasked(1)
	def _play_next(self):
		if not self.select(1):
			self.stack.close_player()
		return None



class WPlayer(object):

	_signals = dict(closed=Event(), idle=Event(), loading=Event(), playing=Event(), info=Event())
	_audio_stream = False
	_video_stream = False

	def __init__(self):
		self.time_elapsed = 0.0
		self._getitems_keywords.update(dict(video_substream_list=(lambda : self.wpl.vlist()), audio_substream_list=(lambda : self.wpl.alist()), subtitle_substream_list=(lambda : self.wpl.slist()), speed=self._formatted_speed, duration=(lambda : self.wpl.duration)))
		self.wpl = wyplayer_instance()
		self._old_status, self.status = self.wpl.status, self.wpl.status
		self._speed = 1
		self.repeat_mode = False
		self.random_mode = False
		if self._video_stream:
			self.last_video_resolution = config.user_config['connections']['resolution']
		return None

	@property
	def stopped(self):
		return self.status in ('idle', 'closed')

	def _get_speed(self):
		return self._speed

	@tasked(0.5)
	def _set_wpl_speed(self, val):
		self.wpl.speed = val
		return None

	@selective_gui_updater('speed')
	@user_action
	def _set_speed(self, val):
		log.info('User defined speed: %s', val)
		self._speed = val
		self._set_wpl_speed(val)
		return None

	speed = property(_get_speed, _set_speed)
	del _get_speed
	del _set_speed

	def _wait_for_status(self, *sig_list, **kw):
		log.debug('Waiting for status %r', sig_list)
		timeout = float(kw.get('timeout', 120))
		for sig in sig_list:
			sig_handler = WPlayer._signals[sig]
			t = time()
			sig_handler.wait(timeout)
			if timeout and time() - t > timeout:
				log.debug("Expected signal '%s' never caught, raise Overflow exception!", sig)
				raise OverflowError
			log.debug("Got expected signal '%s' !", sig)
		return None

	# update media meta data when this function is called
	def update_media_info(self):
		duration = self.wpl.duration / 1000.0
		self.time_elapsed = 0.0
		self.total_time = duration
		if self.repeat_mode == 'track':
			self.repeat_mode = False
		return None

	@selective_gui_updater('speed')
	def speed_change_callback(self, speed):
		log.info('SPEED CHANGE from player: %s', speed)
		self._speed = speed
		return None

	def status_change_callback(self, status):
		log.debug('Status change: %s', status)
		for e_name, e_sig in self._signals.iteritems():
			if e_name == status:
				e_sig.set()
			else:
				e_sig.clear()
		self.old_status = self.status
		self.status = status
		self._status_change_callback(status)
		return None

	# Called when wyplayer's status changes
	def _status_change_callback(self, status):
		if status == 'playing':
			self.update_media_info()
		return None

	def _get_status(self):
		speed = self.speed
		if self.status == 'playing':
			if speed == 0:
				return 'pause'
			elif speed == 1:
				return 'play'
			elif -1 <= speed < 0:
				return 'slow_motion_rewind'
			elif 0 < speed < 1:
				return 'slow_motion_forward'
			elif speed > 1:
				return 'fast_forward'
			elif speed < -1:
				return 'fast_rewind'
		return 'stop'

	def _get_playmode(self):
		if self.repeat_mode:
			if self.random_mode:
				if self.repeat_mode == 'all':
					return 'loop_random'
				else:
					return 'loop_track_random'
			else:
				if self.repeat_mode == 'all':
					return 'loop'
				else:
					return 'loop_track'
		elif self.random_mode:
			return 'random'
		else:
			return 'none'

	# Return the player's speed, formatted in a human-readable fashion, for display on the OSD.
	# If the speed is 0 or 1 (i.e. stopped, paused or playing at normal speed), return an empty string.
	def _formatted_speed(self):
		s = self.speed
		if 0 < s < 1:
			return '%.1fx' % s
		elif s in (0, 1):
			return ''
		else:
			return '%dx' % s

	def play(self, item, show_loading=False, offset=0, default_audio=None, default_video=None, default_sub=None):
		if show_loading:
			win = LoadingWindow()
			win.show()
		self.wpl.watch_property('status', self.status_change_callback)
		self.wpl.watch_property('speed', self.speed_change_callback)
		try:
			item.media_update()
		except AttributeError:
			log.warning('item %s is not updatable', item)
		options = dict()
		uri_options = dict()
		for k, v in item.wpl_options.iteritems():
			if k in ('data', 'osd', 'outwin', 'adrv', 'vdrv'):
				options[k] = v
			else:
				uri_options[k] = v
		self.old_status, self.status = self.wpl.status, self.wpl.status
		log.info('STATUS: %s', self.status)
		if self.status == 'closed':
			log.debug('STATUS IS CLOSED, opening...')
			options['audio'] = self._audio_stream
			options['video'] = self._video_stream
			self.wpl.open(**options)
			self.aspect_ratio = player_aspect_ratio_dict[config.user_config['video']['aspect_ratio']]
			self.display_format = config.user_config['video']['display_format']
		elif self.status != 'idle':
			log.debug('STATUS IS NOT IDLE , stopping...')
			self._signals['playing'].clear()
			self.wpl.stop()
		if self._sub_stream:
			subs = item['subtitles']
			if subs:
				sub_path = subs[0]['uri'].split('//', 1)[1]
				uri_options['subfile'] = sub_path
				uri_options['sublang'] = (default_sub if default_sub else 'eng')
		dlna = item['dlnaProfile']
		if dlna:
			uri_options['dlna_profile'] = dlna
			uri_options['mime_type'] = item['mimeType']
		self.wpl.spdif_surround = config.user_config['connections']['spdif_surround']
		log.debug('LOAD URI: %s (%s)', item['uri'], uri_options)
		self.wpl.load_uri(item['uri'], uri_options)
		self._wait_for_status('loading', timeout=3)
		self._wait_for_status('idle', timeout=120)
		preferred_language = config.user_config['video']['language']
		preferred_len = len(preferred_language)
		log.info('preferred: %s', preferred_language)
		for a_track in self.wpl.alist():
			if a_track['lang'][:preferred_len].lower() == preferred_language:
				self.wpl.aid = a_track['id']
				log.info('audio: %s', a_track)
				break
		if item.wymedia_resource:
			use_bytes = item['class'].endswith('tvRecord')
		else:
			use_bytes = False
		if self._video_stream:
			self._set_framerate()
		log.debug('PLAY LOADED!')
		self.wpl.play_loaded(start_pos=offset, bytes=use_bytes)
		error = False
		for n in xrange(100):
			log.warning("It's the player countdown ! %d...", n)
			try:
				self._wait_for_status('playing', timeout=1)
			except OverflowError:
				if self._check_exception():
					error = True
					break
			else:
				break
		if show_loading:
			win.hide()
		if error or self._check_exception():
			self._play_next()
		return None

	# close and re-open wpl to avoid some resolution bugs
	def _clear_wpl(self):
		log.debug('calling wpl.close() / wpl.open() ...')
		options = dict()
		options['audio'] = self._audio_stream
		options['video'] = self._video_stream
		options['subtitles'] = self._sub_stream
		self.wpl.close()
		self.wpl.open(**options)
		return None

	# Set the appropriate framerate for the video.
	# Must be called before 'playing' !!
	def _set_framerate(self):
		new_mode = None
		if config.user_config['connections']['auto_frame_rate']:
			if self.wpl.is_cinema():
				new_mode = (1920, 1080, 0, 24)
				log.debug('wpl.is_cinema() returned True: new_mode = (1920, 1080, 0, 24)')
			else:
				log.debug('wpl.is_cinema() returned False')
				try:
					from peewee.ranges import f_list
					fuzzy_list = f_list([25.0], range=2)
					vlist = self.wpl.vlist()
					if vlist:
						framerate = vlist[0]['framerate']
						log.debug('auto_framerate: wpl.framerate: %s', framerate)
						if 10 < framerate < 100:
							if framerate in fuzzy_list:
								framerate = 50
							else:
								framerate = 59
						else:
							raise IndexError
					else:
						framerate = config.user_config['connections']['resolution'][3]
				except IndexError:
					pass
				else:
					new_mode = list(config.user_config['connections']['resolution'])
					new_mode[-1] = framerate
					new_mode = tuple(new_mode)
		if new_mode and self.status != 'playing' and self.last_video_resolution != new_mode:
			try:
				log.debug('auto_framerate: change mode %s  ->  %s', self.last_video_resolution, new_mode)
				vm = pygui_globs['videomodes']
				if vm.hdmi_sink:
					self._clear_wpl()
					if vm.secure_set_resolution(new_mode):
						self.last_video_resolution = new_mode
					else:
						log.warn('auto_framerate failed. %s not supported', new_mode)
			except:
				PRINT_EXCEPTION()
		return None

	def _check_exception(self, force=False):
		uri = self['main_list'].selected['uri']
		if uri.startswith('http://') or uri.startswith('dlna+http://'):
			ignore = True
		else:
			ignore = False
		message = None
		ex = self.wpl.exception
		if force:
			message = force
		else:
			if ex == "media: couldn't open input file":
				message = _('The content you requested was not found.')
			elif ex == 'media: timeout':
				message = _('The server is not responding. Please try to access the content later.')
			elif ex == 'media: unsupported container':
				message = _('Cannot play this media (bad container).')
			elif ex == 'decode: no recognized stream':
				message = _('Cannot Play this media (no audio codec supported).')
			elif ex:
				message = _('Cannot play this media (bad container).')
			else:
				if not self.wpl.alist():
					if not ignore:
						message = _('Cannot Play this media (no audio codec supported).')
					else:
						message = ''
				elif self._video_stream and not self.wpl.vlist():
					message = _('Cannot Play this media (no video codec supported).')
		if message:
			Task(BigMessageWindow(message).show, timeout=5).start(0.10000000000000001)
			return True
		return False

	@user_action
	def action_seek(self, val):
		self.wpl.seek(val)
		return None

	def stop(self):
		self.repeat_mode = False
		self.random_mode = False
		self.wpl.watch_property('uri', None)
		self.wpl.watch_property('speed', None)
		log.debug('calling stop & close')
		self.wpl.stop()
		self.wpl.close()
		self._wait_for_status('idle', timeout=30)
		if self._video_stream and self.last_video_resolution != config.user_config['connections']['resolution']:
			from itertools import count
			retries = count()
			while self.wpl.status == 'playing' and retries.next() < 100:
				sleep(0.10000000000000001)
			log.debug('auto_framerate: setting back previous mode: %s', config.user_config['connections']['resolution'])
			vm = pygui_globs['videomodes']
			if vm.hdmi_sink:
				vm.secure_set_resolution(config.user_config['connections']['resolution'])
				self.last_video_resolution = config.user_config['connections']['resolution']
		self.wpl.watch_property('status', None)
		return None

	def tick_callback(self):
		try:
			self.time_elapsed = self.wpl.rel_pos[self.media]
			if self.time_elapsed < 0.0:
				self.time_elapsed = 0.0
		except:
			self.time_elapsed = 0
		return None

	def get_subtitles(self):
		subtitles_list = self.wpl.slist()
		sid = self.wpl.sid
		return [[_('OFF'), -1 == sid, -1]] + [[s['lang'], s['id'] == sid, s['id']] for s in subtitles_list]

	def set_subtitle(self, sid):
		self.wpl.sid = sid
		return None

	def get_audio_substreams(self):
		audiostreams_list = self.wpl.alist()
		aid = self.wpl.aid
		return [[s['lang'], s['id'] == aid, s['id'], s['codec']] for s in audiostreams_list]

	def set_audio_substream(self, aid):
		self.wpl.aid = aid
		return None

	def _get_aspect_ratio(self):
		return self.wpl.aspect_ratio

	def _set_aspect_ratio(self, aspect_ratio):
		log.info('Setting aspect ratio to %s', aspect_ratio)
		self.wpl.aspect_ratio = aspect_ratio
		return None

	# The player's aspect ratio (4_3 or 16_9)
	aspect_ratio = property(_get_aspect_ratio, _set_aspect_ratio)

	def _get_display_format(self):
		return self.wpl.display_format

	def _set_display_format(self, display_format):
		log.info('Setting display format to %s', display_format)
		self.wpl.display_format = display_format
		return None

	# The player's display format (for use when the stream's aspect ratio differs from that of the display)
	display_format = property(_get_display_format, _set_display_format)
