# -*- coding: utf-8 -*- 
#
# Description:
#
# Video Player Class Definition
#
#
#
# Changes:
#
# 2011-10-25
# Initial Commit
#
# 2012-04-21
# Add subtitles size modification via hand menu
#
#
# Copyright 2010-2014, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.


from __future__ import absolute_import

__all__ = ['VideoPlayer', 'YoutubePlayer', 'DailyMotionPlayer']

import re
import pygui.config as config
from peewee.debug import GET_LOGGER, PRINT_EXCEPTION
from peewee.messages import send as louie_send
from peewee.notifier import tasked, Task
from peewee.ranges import f_list
from pygui.eventmanager.players import VideoEventHandler
from pygui.eventmanager.players.video_player import YoutubeEventHandler
from pygui.shared import pygui_globs
from pygui.menu import selective_gui_updater
from pygui.menu.players.core import user_action, Player, WPlayer
from pygui.menu.players import forward_tricks_icons, backward_tricks_icons
from pygui.item.mediaitem.tvreplay import M6ReplayItem

log = GET_LOGGER(__name__)



class VideoPlayer(Player, WPlayer):

	media = 'video'
	_audio_stream = True
	_video_stream = True
	_sub_stream = True

	def __init__(self, type_='videoplayer'):
		Player.__init__(self, type_=type_)
		WPlayer.__init__(self)
		self.eventhandler = VideoEventHandler(self)
		self._getitems_keywords['hd_info_icon'] = self._get_hd_info_icon
		self._getitems_keywords['snd_info_icon'] = self._get_snd_info_icon
		self.subserver = pygui_globs['subserver']
		self.subtitles_textblock = None
		self.cur_subs_size = config.user_config['video']['subtitles_size']
		self.playmode = 'all'
		return None

	def _get_hd_info_icon(self):
		sel = self.selected
		ico = None
		if len(self.wpl.vlist()) > 0 and self.wpl.vlist()[0]['height'] >= 720:
			ico = 'tvplayer_videoformathd.png'
		return ico

	def _get_snd_info_icon(self):
		sel = self.selected
		ico = None
		if sel and sel['nrAudioChannels']:
			if int(sel['nrAudioChannels']) > 5:
				ico = 'tvplayer_audio51.png'
		return ico

	@tasked(0.10000000000000001)
	def _status_change_callback(self, status):
		log.info('status changed: %s', status)
		WPlayer._status_change_callback(self, status)
		if not self._start_playing.task.running and self.old_status == 'playing' and self.stopped:
			if self.repeat_mode:
				if self.repeat_mode == 'track':
					try:
						WPlayer.play(self, self.get_item_list('main_list').selected)
					except OverflowError:
						PRINT_EXCEPTION(stop=True)
				else:
					if self._check_exception():
						self.stack.close_player()
					if not self.select(1, end_reached=True):
						if self.repeat_mode == 'all':
							old_pos = self.selected_pos
							self.select(0, force_pos=True, end_reached=True)
							if self.selected_pos == old_pos:
								self._start_playing()
						else:
							self.stack.close_player()
			else:
				if self._check_exception():
					self.stack.close_player()
				elif self.playmode == 'track':
					self.stack.close_player()
				elif self.playmode == 'all':
					if not self.select(1, end_reached=True):
						self.stack.close_player()
			log.debug('end status changed')
		return None

	def _get_status(self):
		ret = WPlayer._get_status(self)
		if ret == 'fast_forward':
			return forward_tricks_icons[self.eventhandler.forward_steps.index(self.speed)]
		elif ret == 'fast_rewind':
			return backward_tricks_icons[self.eventhandler.backward_steps.index(self.speed)]
		elif ret == 'play' and self.playmode == 'all':
			return 'play_list'
		return ret

	def _get_playmode(self):
		if self.repeat_mode == 'track':
			return 'video_loop'
		elif self.repeat_mode == 'all':
			return 'video_loop_list'
		else:
			return 'none'

	@selective_gui_updater('progressbar', 'time_remaining', 'time_elapsed', 'time_total', 'status_icon', 'playmode_icon')
	def tick_callback(self):
		log.debug('tick')
		if not self._start_playing.task.running and self.status == 'playing':
			WPlayer.tick_callback(self)
		log.debug('end tick')
		return None

	@tasked(0.40000000000000002)
	@selective_gui_updater('progressbar', 'time_remaining', 'time_elapsed', 'time_total')
	def update_media_info(self):
		duration = self.wpl.duration / 1000.0
		if duration == 0:
			try:
				duration = float((self.selected['duration'] if not self.selected['recordedDuration'] else self.selected['recordedDuration']))
			except:
				log.error('No duration available for %s -- recordedDuration %s, duration %s', self.selected, self.selected['recordedDuration'], self.selected['duration'])
				duration = 1000
		self.total_time = duration
		if duration > 0:
			self._seek_step = duration * config.HMI_VIDEO['seek_percent']
		else:
			self._seek_step = config.HMI_VIDEO['seek_period']
		return None

	def _render_subtitle(self, subs):
		dasubs = '\n'.join(subs)
		louie_send('subtitles', sender=self, value=dasubs)
		return None

	# Search the "subtitles" textblock widget through all menus recursively
	def search_subtitles_widget(self):
		# Recursive function
		def search_subtitles_in_obj(obj):
			for child in obj._children:
				try:
					if child.name == 'subtitles':
						return child
				except:
					pass
				try:
					ret = search_subtitles_in_obj(child)
					if ret is not None:
						return ret
				except:
					pass
			return None

		subtitles = None
		stack = pygui_globs['menustack']
		for engine in stack.engines:
			for menu_widget in engine.menu_stack:
				subtitles = search_subtitles_in_obj(menu_widget)
				if subtitles is not None:
					break
		return subtitles

	# Return the current subtitles size
	def get_subs_size(self):
		return self.cur_subs_size
	
	# Set the "subtitles" textblock widget size to "size". (Modify font_size property)
	# Originals font_size of each Wybox are:
	#  - Wyplayer  : 40
	#  - Zoltar    : 28
	#  - Mediatitan: 28
	#  - Mediatec  : 26
	def set_subs_size(self, size):
		# Try to find "subtitles" textblock widget if not already done
		if self.subtitles_textblock is None:
			self.subtitles_textblock = self.search_subtitles_widget()
		# "subtitles" textblock widget is located, update it
		if self.subtitles_textblock is not None:
			try:
				def sub_style(attr):
					return attr.group('start') + str(size) + attr.group('end')
				new_style = re.sub(r'(?P<start>.*font_size=)(?P<size>\d+)(?P<end>.*)', sub_style, self.subtitles_textblock._style)
				self.subtitles_textblock._style = new_style
				self.subtitles_textblock.resize(height='%i%%' % (19 + size / 3))
				self.subtitles_textblock.refresh_text()
			except Exception, e:
				PRINT_EXCEPTION(e)
			else:
				config.user_config['video']['subtitles_size'] = self.cur_subs_size
				Task(config.user_config.save).start(1)
		# No way to find "subtitles" textblock widget. :(
		else:
			self.cur_subs_size = config.user_config['video']['subtitles_size']
		return None

	@selective_gui_updater('progressbar', 'time_remaining', 'time_elapsed', 'time_total', 'item_name', 'info_icon')
	def select(self, val, list_name='main_list', end_reached=False, force_pos=False):
		if end_reached:
			unref_link = bool(self.selected['refid'])
			self.selected.vfs_set_metas(_unref_link=unref_link, playbackStatus='')
		sel_ret = Player.select(self, val, list_name=list_name, force_pos=force_pos)
		if sel_ret:
			self._start_playing()
		return sel_ret

	@user_action
	@selective_gui_updater('progressbar', 'time_remaining', 'time_elapsed', 'time_total', 'item_name', 'info_icon', 'snd_info_icon', 'hd_info_icon')
	def play(self, item=None, playlist=None, delay=0):
		try:
			Player.play(self, item, playlist)
		except:
			PRINT_EXCEPTION()
			if self._check_exception(_("Can't find media")):
				pygui_globs['menustack'].close_player()
				return None
		if self.subserver:
			self.subserver.register_txt_render(self._render_subtitle)
			self.set_subs_size(config.user_config['video']['subtitles_size'])
		try:
			WPlayer.play(self, self.selected, show_loading=False, offset=delay)
		except OverflowError:
			log.debug('Player unable to load/read selected item')
			if not self.select(1):
				pygui_globs['menustack'].close_player()
		return None

	@user_action
	def action_play(self):
		if self.stopped:
			self.play(self.selected)
		else:
			if self.speed == 1:
				self.speed = 0
			else:
				self.speed = 1
		return None

	@tasked(config.HMI_VIDEO['lazy_selection'])
	@user_action
	@selective_gui_updater('snd_info_icon', 'hd_info_icon')
	def _start_playing(self):
		log.debug('start playing...')
		sel = self.get_item_list('main_list').selected
		if sel.player != self:
			log.debug('Switching players %s <> %s', sel.player, self)
			self.stop()
			sel.player.play(sel, self.choices)
		else:
			try:
				WPlayer.play(self, sel, show_loading=False)
			except:
				PRINT_EXCEPTION()
				log.debug("Can't play selected, play next...")
				if not self.select(1):
					pygui_globs['menustack'].close_player()
		return None

	def stop(self):
		try:
			if 'transcode' in config.plugins:
				if hasattr(self, 'stop_transcode'):
					self.stop_transcode(0)
					del self.stop_transcode
			if config.resume_video:
				if self.selected['class'].endswith('tvRecord'):
					resume_pos = self.wpl.byte_pos['data']
				else:
					resume_pos = self.time_elapsed
				unref_link = 'refid' in self.selected.wymedia_resource
				self.selected.vfs_set_metas(_unref_link=unref_link, playbackStatus=repr(resume_pos))
				log.debug('%s save resume position at %s', self.selected, resume_pos)
		finally:
			WPlayer.stop(self)
			Player.stop(self)
			self._start_playing.task.stop()
			self.subserver.unregister_txt_render()
			self._render_subtitle(u'')
		return None

	# Nothing needs to happen when Info is pressed, other than the info bar reappearing as a result of user_action.
	def action_info(self):
		if user_action._timer and user_action._timer.running:
			user_action.force_ending()
		else:
			@user_action
			def _do_nothing(self):
				return None
			_do_nothing(self)
		return None



class YoutubePlayer(VideoPlayer):

	def __init__(self):
		VideoPlayer.__init__(self)
		self.eventhandler = YoutubeEventHandler(self)
		return None



class DailyMotionPlayer(VideoPlayer):

	def __init__(self, type_='dailymotionvideoplayer'):
		VideoPlayer.__init__(self, type_=type_)
		self.eventhandler = YoutubeEventHandler(self)
		self._getitems_keywords['rating'] = self._get_rating
		self._getitems_keywords['view_count'] = self._get_view_count
		return None

	def _get_rating(self):
		return self.selected['rating']

	def _get_view_count(self):
		return self.selected['view_count']

	@selective_gui_updater('rating', 'view_count')
	def select(self, val, list_name='main_list', end_reached=False):
		VideoPlayer.select(self, val, list_name, end_reached)
		return None
