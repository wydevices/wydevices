# -*- coding: utf-8 -*- 
#
# Description:
#
# Navigator Menu Class Definition
#
#
#
# Changes:
#
# 2011-11-16
# Initial Commit
#
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.


from __future__ import absolute_import

__all__ = ['MarkerNavigator', 'ThumbnailNavigator', 'Navigator', 'GenericNavigator', 'EmptyItem']

from copy import copy
from time import sleep
from wymedia.wmplus import BrowseError, metadata_collector_clear
from peewee.debug import GET_LOGGER, PRINT_EXCEPTION
from peewee.formatters import seconds_to_hhmmss_utc, seconds_to_mmss_utc, bytes_to_human, ellipsize
from peewee.messages import send as louie_send
from peewee.messages import connect as louie_connect
from peewee.misc_utils import MetaSingleton
from peewee.notifier import Task
from pygui import config
from pygui.window import LoadingWindow
from pygui.eventmanager.menus import MarkerListEventHandler, NavigatorEventHandler, ThumbnailNavigatorEventHandler
from pygui.facilities.l10n import omnicode
from pygui.item.core import Item
from pygui.item.containers import ItemGrid
from pygui.item.mediaitem import RootItem, TVRootItem, DVDItem, IsoDVDItem, VideoItem, ImageItem, AudioItem
from pygui.item.mediaitem import DirItem, Playlist
from pygui.item.mediaitem.net import NetFeedItem
from pygui.item.mediaitem.audiovideo import TVRecordItem
from pygui.item.mediaitem.core import TV_FAVORITES_FOLDER
from pygui.item.mediaitem.net import NetItem
from pygui.markerlist import markerlists
from pygui.menu import UNIVERSE_NAME_DICT
from pygui.menu.menu.core import Menu
from pygui.shared import pygui_globs
from pygui.window import Button, ConfirmWindow
from pygui.window import LoadingWindow

log = GET_LOGGER(__name__)


# Decorate a function that may received a wymedia.wmplus.BrowseError.
# If it happens, catches the exception and calls back_to_root()
def back_root_if_error(fn):
	def wrap(self, *args, **kw):
		ret = None
		try:
			ret = fn(self, *args, **kw)
		except BrowseError:
			print 'back_root_if_error->BrowseError'
			self.back_to_root()
		return ret

	wrap.__name__ = fn.__name__
	return wrap



# A simple item to put in empty places to signal it
class EmptyItem(Item):

	__metaclass__ = MetaSingleton

	def __init__(self):
		Item.__init__(self, _('No content'), type_='empty', display_type='empty')
		return None

	@property
	def name(self):
		return _('No content')



# A simple item to put in empty places to signal it
class NotSoEmptyItem(Item):

	__metaclass__ = MetaSingleton

	def __init__(self):
		Item.__init__(self, _('No content for this universe'), type_='empty', display_type='empty')
		return None

	@property
	def name(self):
		return _('No content for this universe')



# Stack-like class with modification notification handler
class HistoryStack(list):

	def __init__(self, history=None, on_modify=None):
		list.__init__(self)
		if history is not None:
			self[:] = history
			if on_modify:
				on_modify()
		if not on_modify:
			self._modification_handler = (lambda: None)
		else:
			self._modification_handler = on_modify
		return None

	def pop(self, *args, **kw):
		ret = list.pop(self, *args, **kw)
		self._modification_handler()
		return ret

	def append(self, *args, **kw):
		ret = list.append(self, *args, **kw)
		self._modification_handler()
		return ret

	def empty(self):
		self[:] = list()
		return None



# Defines 'browser' menus, to access filesystem contents
class GenericNavigator(Menu):

	toggleable = True

	def __init__(self, name, universe, choices=None, eventhandler=None, **kw):
		self._history = HistoryStack()
		self._actual_preview = None
		self.force_preview = False
		self.contextual_windows = []
		Menu.__init__(self, name, choices, universe=universe, **kw)
		self.tasks.update({'build_preview': Task(self._build_preview), 'hide_preview': Task(self._hide_preview), 'refresh_root': Task(self._refresh_root), 'reload_func': Task(self._reload_func)})
		self._getitems_keywords.update(preview_list=(lambda : self.get_item_list('preview_list')),
																	 markerlist=(lambda : self.get_item_list('markerlist')),
			 														 universe_name=(lambda : UNIVERSE_NAME_DICT[self.type]),
			 														 parent_icon_name=self._get_parent_icon_name,
			 														 parent_item_name=self._get_parent_item_name,
			 														 thumbnail=self._get_thumbnail,
			 														 folder_depth=(lambda : len(self._history)),
			 														 parental_rating=self._get_parental_rating,
			 														 title=self._get_title,
			 														 date=self._get_date,
			 														 artist=self._get_artist, 
																	 album=self._get_album,
																	 track=self._get_track,
																	 duration=self._get_duration,
																	 size=self._get_size,
																	 author=self._get_author,
																	 description=self._get_description,
																	 link=self._get_link,
																	 embedded_media=self._get_embedded_media_icon)
		self.set_items([], list_name='preview_list')
		self.set_items([], list_name='markerlist')
		if eventhandler:
			self.eventhandler = eventhandler
			self.markerlist = None
		else:
			self.eventhandler = NavigatorEventHandler(self)
			self.markerlist = markerlists()[self.universe]
		self._update_marker()
		louie_connect(receiver=self.back_to_root, signal='refresh_root', sender='navigator')
		return None

	def _get_artist(self):
		if self.selected is not None and self.selected.type in ('audio',):
			if hasattr(self.selected, "__getitem__"):
				if self.selected['author']:
					return self.selected['author']
				return u''
		return ''

	def _get_album(self):
		if self.selected is not None and self.selected.type in ('audio',):
			if hasattr(self.selected, "__getitem__"):
				if self.selected['album']:
					return self.selected['album']
				return u''
		return ''

	def _get_track(self):
		if self.selected is not None and self.selected.type in ('audio',):
			if hasattr(self.selected, "__getitem__"):
				if self.selected['track']:
					return self.selected['track']
				return u''
		return ''

	def _get_duration(self):
		if self.selected is not None and self.selected.type in ('audio',):
			return self._get_audio_duration()
		return ''

	def _get_size(self):
		if self.selected is not None and self.selected.type in ('image',):
			if hasattr(self.selected, "__getitem__"):
				if self.selected['size']:
					return bytes_to_human(int(self.selected['size']))
			return u''
		return ''

	def _get_author(self):
		if self.selected is not None:
			if hasattr(self.selected, "__getitem__"):
				if self.selected['author']:
					return self.selected['author']
		return u''

	def _get_description(self):
		if self.selected is not None:
			if hasattr(self.selected, "__getitem__"):
				if self.selected['description']:
					return ellipsize(self.selected['description'], 400)
		return u''

	def _get_link(self):
		if self.selected is not None:
			if hasattr(self.selected, "__getitem__"):
				return self.selected['link']
		return u''

	def _get_embedded_media(self):
		if self.selected is not None:
			if hasattr(self.selected, "__getitem__"):
				if self.selected['backend'] == 'net_services':
					if self.selected['uri'] and self.selected['uri'] != '::online::':
						return 'embedded_media'
		return u''

	def _get_embedded_media_icon(self):
		embedded = self._get_embedded_media()
		if embedded:
			return embedded + '.png'
		return None

	def _get_date(self):
		if self.selected is not None and self.selected.type == 'audio':
			if hasattr(self.selected, "__getitem__"):
				if self.selected['backend'] == 'net_services':
					return self.selected['date']
				return self.selected['exif_date']
		return u''

	def _get_title(self):
		if self.selected is not None and self.selected.type == 'audio':
			if hasattr(self.selected, "__getitem__"):
				if self.selected['backend'] == 'net_services':
					return self.selected['title']
				return self.selected['metadata_title']
		return u''

	def _get_audio_duration(self):
		if hasattr(self.selected, "__getitem__"):
			if self.selected['duration']:
				seconds = int(self.selected['duration'])
				if seconds >= 3600:
					return seconds_to_hhmmss_utc(seconds)
				return seconds_to_mmss_utc(seconds)
		return ''

	def _get_parental_rating(self):
		ico = None
		if config.user_config['security']['parental_control']:
			if not config.user_config['security']['parent_mode']:
				ico = 'maturityrating_%s.png' % config.user_config['security']['maturity_rating']
		return ico

	# Will set the preview type to 'kind' if it's not the actual state
	def _set_preview_type(self, kind):
		if pygui_globs['menustack'].menus_stack[-1] is not self:
			log.debug('%s not on top of stack. avoid sending preview type', self)
			return None
		log.debug('actual_preview:%s  new_preview:%s', self._actual_preview, kind)
		if kind != self._actual_preview or self.force_preview:
			if self._actual_preview is not None:
				log.debug('hide_%s_preview', self._actual_preview)
				louie_send('hide_%s_preview' % self._actual_preview, self)
			if kind is not None:
				log.debug('show_%s_preview', kind)
				louie_send('show_%s_preview' % kind, self)
			self._actual_preview = kind
		self.force_preview = False
		return None

	def _get_parent_item_name(self):
		if len(self._history):
			return self._history[-1]['selected'].name
		elif self.selected:
			parent = self.selected.parent
			if parent not in (RootItem(), TVRootItem(), self.markerlist) and parent.name != TV_FAVORITES_FOLDER:
				return parent.name
		return ''

	def _get_parent_icon_name(self):
		if len(self._history):
			return 'parentfolder-%s.png' % self.type
		elif self.selected:
			parent = self.selected.parent
			if parent not in (RootItem(), TVRootItem(), self.markerlist) and parent.name != TV_FAVORITES_FOLDER:
				return 'parentfolder-%s.png' % self.type
		return 'root-%s.png' % self.type

	def show(self, hide_previous_menu=True):
		Menu.show(self, hide_previous_menu)
		self.get_item_list('main_list').advertise()
		return None

	def reset(self, name, universe, **kw):
		Menu.reset(self, name=name, universe=universe, **kw)
		self._history.empty()
		self.set_items([], list_name='preview_list')
		self.set_items([], list_name='markerlist')
		self.markerlist = markerlists()[self.universe]
		self.set_items(self.root_getter(), list_name='main_list')
		self.build_preview()
		return None

	def stop(self):
		if hasattr(self.selected, 'unwatch'):
			self.selected.unwatch(self._selection_changed)
		Menu.stop(self)
		return None

	def clear(self):
		return None

	def _get_thumbnail(self):
		try:
			if not self.selected['thumbnail']:
				return 'default.png'
			return self.selected['thumbnail']
		except Exception, e:
			pass
		return None

	# Update parent_item data in view (use it after a browse)
	def _path_changed(self):
		louie_send('parent_item_name', sender=self, value=self['parent_item_name'])
		louie_send('parent_icon_name', sender=self, value=self['parent_icon_name'])
		louie_send('folder_depth', sender=self, value=len(self._history))
		return None

	def backup_navigator_history(self, navigator):
		self._history = HistoryStack(history=navigator._history)
		last_context = self._history[-1]
		self.set_items(last_context['items'], 'main_list', last_context['position'])
		self.build_preview()
		return None

	@back_root_if_error
	def execute_selected(self):
		self.stop()
		self.selected.execute()
		return None
		
	# Refresh the content of the main_list by calling browse() on the parent item
	@back_root_if_error
	def _reload_func(self):
		log.debug('reloading %s', self)
		if pygui_globs['menustack'].menus_stack[-1] is not self:
			return None
		louie_send('parental_rating', sender=self, action='reset', value=self['parental_rating'])
		self._update_marker()
		try:
			previous = self._history[-1]['selected']
		except IndexError:
			previous = self.selected.parent
			if previous.parent is None:
				self.refresh_root()
				return None
		old_sel = self.selected_pos
		new_content = previous.browse()
		try:
			new_content[max(old_sel, 0)]
		except IndexError:
			old_sel = len(new_content) - 1
		if ( self.selected is None or old_sel == -1 ) and len(new_content) > 0:
			old_sel = 0
		elif not len(new_content):
			self.selected = None
			self.set_items([], 'preview_list')
		self.set_items(new_content, list_name='main_list', position=old_sel)
		if hasattr(self.selected, 'watch'):
			self.selected.watch(self._selection_changed)
		return None		

	def reload_func(self):
		Menu.reload_func(self)
		self.tasks['reload_func'].start(0.5)
		return None

	def _refresh_root(self):
		old_sel = max(0, self.selected_pos)
		if not self._history:
			log.debug('refreshing items')
			self.set_items(self.root_getter(), list_name='main_list', position=old_sel)
		else:
			log.debug('refreshing history')
			history_dict = self._history[0]
			history_dict['items'] = self.root_getter()
			history_dict['position'] = min(history_dict['position'], len(history_dict['items']) - 1)
		return None

	def refresh_root(self):
		self.tasks['refresh_root'].start(1.0)
		return None

	# Browse the selected item.
	# 
	# If the selected item has a browse_action method, it is called instead
	# of the regular browsing operation. This behavior may be overridden by supplying action_override=True.
	# 
	# If *args and **kw are supplied, they are passed to item.browse.
	# This is useful to pass filtering arguments (e.g. to get the
	# EPGs starting from a specific date in the TV universe).
	@back_root_if_error
	def browse_selected(self, action_override=False, *args, **kw):
		sel = self.selected
		loading = None
		if hasattr(sel, 'watch'):
			self.selected.watch(self._selection_changed)
		try:
			new_history = dict(position=self.choices.selected_pos, selected=sel, items=copy(self.choices))
		except AttributeError:
			new_history = None
		if new_history is not None:
			if hasattr(sel, 'type') and sel.type == 'net_feed':
				loading = LoadingWindow()
				self.contextual_windows.append(loading)
				loading.show()
			if hasattr(sel, 'browse_action') and not action_override:
				sel.browse_action()
			else:
				res = None
				try:
					res = sel.browse(*args, **kw)
				except AttributeError:
					pass
				if res is None:
					louie_send('main_list_not_browse', sender=self)
					if loading:
						loading.hide()
					return False
				else:
					self._history.append(new_history)
					self._path_changed()
					louie_send('event_right', sender=self)
					sleep(config.HMI_BASE['navigator_listing_delay'])
					self.set_items([], 'preview_list')
					self.set_items(res, 'main_list')
					self.tasks['build_preview'].start(config.HMI_BASE['preview_delay'] * 2)
					try:
						self.selected.watch(self._selection_changed)
					except AttributeError:
						pass
			if loading:
				loading.hide()
			return True
		return False
		
	def browse_previous(self):
		try:
			last_context = self._history.pop()
			if hasattr(self.selected, 'unwatch'):
				self.selected.unwatch(self._selection_changed)
		except IndexError:
			if self.selected and self.selected.parent:
				self.go_to_item(self.selected.parent, 'event_left')
				louie_send('on_root', sender=self)
			elif not config.block_navigator:
				pygui_globs['menustack'].back_to_home()
			return None
		if last_context is not None:
			louie_send('event_left', sender=self)
			sleep(config.HMI_BASE['navigator_listing_delay'])
			if self.choices:
				preview_list = self.choices[:10]
			elif self.choices.is_empty():
				preview_list = [EmptyItem()]
			else:
				preview_list = [NotSoEmptyItem()]
			self.set_items(last_context['items'], 'main_list', last_context['position'])
			self.set_items(preview_list, 'preview_list', -1)
			self._set_preview_type('dir')
			self.tasks['reload_func'].start(1)
			self._path_changed()
			return True
		return False

	# Get the parent of <item>, move navigator to it, and select <item> in the main_list
	#  * item: the item to select
	#  * pos: position of <item> inside its parent folder.
	#         <pos> override the position found in <item>.wymedia_resource
	# Note: its an absolute move, _history is empty after that !
	@back_root_if_error
	def go_to_item(self, item=None, event=None, pos=None):
		if item:
			parent = item.parent
		else:
			parent = RootItem()
		if parent:
			if parent is RootItem():
				res = self.root_getter()
			else:
				res = parent.browse()
			if res is not None:
				self._history.empty()
				if event:
					louie_send(event, sender=self)
				sleep(config.HMI_BASE['navigator_listing_delay'])
				self.set_items([], 'preview_list')
				self.set_items(res, 'main_list')
				if pos:
					self.select(pos, force_pos=True)
				elif item:
					self.select(item)
				else:
					self.select(0)
				self._path_changed()
				self._build_preview()
				return True
		return False

	def _selection_changed(self, item):
		log.debug('UPDATE %s', item)
		if self.selected == item:
			log.debug('IS SELECTED')
			louie_send('main_list', sender=self, action='reset', value=self['main_list'], position=self.selected_pos)
			self.build_preview()
		else:
			if self._history and item == self._history[-1]['selected']:
				log.debug('IS PARENT')
				self.reload_func()
		return None

	@back_root_if_error
	def select(self, item, list_name=None, force_pos=False):
		ret = Menu.select(self, item, list_name, force_pos)
		if ret is not False and  (list_name or self.active_list) == 'main_list':
			if self.tasks['hide_preview'].running and self._actual_preview is not None:
				self.hide_preview()
			self.build_preview()
		return ret

	# Jump to upper-most folder (aka "/")
	def back_to_root(self, *args, **kw):
		for win in self.contextual_windows:
			try:
				win.hide()
			except:
				log.debug('Unable to close %s', win)
		self.go_to_item(None, event='event_left')
		return None

	def _update_marker(self):
		markerlist = self.markerlist
		if bool(markerlist):
			markerlist._refresh()
			self.set_items([markerlist], list_name='markerlist')
		else:
			self.set_items([], list_name='markerlist')
		main_list = self.get_item_list('main_list')
		louie_send('main_list', sender=self, action='mark', value=main_list, position=main_list.selected_pos)
		self.build_preview()
		return None

	# Called when Menu goes in foreground (toggle)
	def on_foreground(self):
		Menu.on_foreground(self)
		self.force_preview = True
		self.build_preview()
		return None

	# Called when Menu goes in background (toggle)
	def on_background(self):
		Menu.on_background(self)
		self.stop()
		return None

	def _hide_preview(self):
		if self._actual_preview is not None:
			louie_send('hide_%s_preview' % self._actual_preview, sender=self)
			louie_send('preview_list_no_more_items_before', sender=self)
			louie_send('preview_list_no_more_items_after', sender=self)
			self._actual_preview = None
		return None

	def hide_preview(self):
		self.tasks['hide_preview'].start(config.HMI_BASE['preview_delay'] + 0.10000000000000001)
		return None

	def _build_preview(self):
		hide_preview_task = self.tasks['hide_preview']
		if hide_preview_task.running:
			hide_preview_task.stop()
		sel = self.selected
		try:
			sel.watch(self._selection_changed)
		except AttributeError:
			pass
		try:
			louie_send('title', sender=self, value=self['title'])
			louie_send('artist', sender=self, value=self['artist'])
			louie_send('album', sender=self, value=self['album'])
			louie_send('track', sender=self, value=self['track'])
			louie_send('duration', sender=self, value=self['duration'])
			louie_send('size', sender=self, value=self['size'])
			louie_send('date', sender=self, value=self['date'])
		except:
			PRINT_EXCEPTION()
			log.error('Id3Tags error')
		louie_send('author', sender=self, value=self['author'])
		louie_send('description', sender=self, value=self['description'])
		louie_send('link', sender=self, value=self['link'])
		louie_send('embedded_media', sender=self, value=self['embedded_media'])
		try:
			louie_send('item_name', sender=self, action='update', value=omnicode(self['item_name']))
		except Exception, e:
			log.error('Item Name error: %s', e)
		# Display thumbnail or content preview
		pt = None
		try:
			louie_send('thumbnail', sender=self, value=self['thumbnail'])
			if isinstance(sel, ImageItem):
				pt = 'img'
			elif isinstance(sel, VideoItem):
				pt = 'mov'
			elif isinstance(sel, AudioItem):
				pt = 'snd'
			elif isinstance(sel, NetItem):
				pt = 'net'
			else:
				pt = 'dir'
		except:
			log.error('Thumbnail error!')
		log.debug('%s: preview_type is: %s', self, pt)
		self._set_preview_type(pt)
		# Display preview content if possible and wanted
		if sel and hasattr(sel, 'browse') and config.user_config['advanced']['preview_folder']:
			item_list = []
			try:
				item_list = sel.browse(preview=True)
				if item_list is not None and len(item_list) == 0:
					if isinstance(item_list, list) or item_list.empty:
						item_list = [EmptyItem()]
					else:
						item_list = [NotSoEmptyItem()]
				self.set_items(item_list[:10], list_name='preview_list', position=-1)
			except:
				self.set_items([], list_name='preview_list')
		else:
			self.set_items([], list_name='preview_list')
		return True

	def build_preview(self):
		self.tasks['build_preview'].start(config.HMI_BASE['preview_delay'])
		return None



# Defines 'browser' menus, to access filesystem contents
class Navigator(GenericNavigator):

	name = 'navigator'

	def __init__(self, name, universe, choices=None, eventhandler=None, fill_root=True, **kw):
		GenericNavigator.__init__(self, name, universe, choices, eventhandler, **kw)
		self.tasks['_fill_nav'] = Task(self._fill_nav)
		if fill_root:
			self.tasks['_fill_nav'].start(-1)
		return None

	def _fill_nav(self):
		self.set_items(self.root_getter())
		self.build_preview()
		return None

	def root_getter(self):
		try:
			root_items = list(RootItem().browse(self.type, self))
		except BrowseError:
			root_items = [EmptyItem()]
		return root_items

	def reset(self, *args, **kw):
		GenericNavigator.reset(self, *args, **kw)
		self._update_marker()
		return None

	def clear(self):
		return None

	def select(self, item, list_name=None, force_pos=False):
		old_sel = self.selected
		ret = GenericNavigator.select(self, item, list_name=list_name, force_pos=force_pos)
		if ret and old_sel != self.selected:
			try:
				if old_sel.watched:
					old_sel.unwatch(self._selection_changed)
			except AttributeError:
				pass
		return ret

	@back_root_if_error
	def execute_selected(self):
		item = copy(self.selected)
		self.stop()
		if type(item) in (VideoItem, DVDItem, IsoDVDItem, TVRecordItem) and config.resume_video:
			position = self.selected['playbackStatus']
			if position:
				position = eval(position)
				_buttons = [Button(_('From last position'), True), Button(_('From the beginning'), False)]
				_buttons[0].connect(item.execute, position)
				_buttons[1].connect(item.execute)
				ConfirmWindow(text=_('Resume playback?'), buttons=_buttons).show()
				item = None
		if item is not None:
			from pygui.item.mediaitem.dailymotion import DailyMotionContainer, DailyMotionSubContainer
			from pygui.item.mediaitem.picasa import PicasaContainer, PicasaPublicAreaContainer, PicasaPublicUserContainer, PicasaPrivateAreaContainer, PicasaPrivateUserContainer
			from pygui.item.mediaitem.shoutcast import ShoutCastFolder, ShoutCastTop500Folder, ShoutCastGenreFolder, ShoutCastSubGenreFolder, ShoutCastSearchFolder, ShoutCastSubSearchFolder
			from pygui.item.mediaitem.tvreplay import TVReplayContainer
			from pygui.item.mediaitem.tvreplay import M6ReplayContainer, M6ReplayCategory, M6ReplaySubCategory
			from pygui.item.mediaitem.tvreplay import W9ReplayContainer, W9ReplayCategory, W9ReplaySubCategory 
			from pygui.item.mediaitem.tvreplay import TF1ReplayContainer, TF1ReplayCategory, TF1ReplaySubCategory 
			from pygui.item.mediaitem.tvreplay import RTVEReplayContainer, RTVEReplaySubContainer
			from pygui.item.mediaitem.youtube import YouTubeContainer, YoutubeSearchContainer, YoutubeStandardFeedContainer, YoutubeUsersContainer, YoutubePlaylistContainer, YouTubeSubContainer
			browseable_types = [DirItem, Playlist,
													DailyMotionContainer, DailyMotionSubContainer,
													PicasaContainer, PicasaPublicAreaContainer, PicasaPublicUserContainer, PicasaPrivateAreaContainer, PicasaPrivateUserContainer,
													ShoutCastFolder, ShoutCastTop500Folder, ShoutCastGenreFolder, ShoutCastSubGenreFolder, ShoutCastSearchFolder, ShoutCastSubSearchFolder,
													TVReplayContainer,
													M6ReplayContainer, M6ReplayCategory, M6ReplaySubCategory,
													W9ReplayContainer, W9ReplayCategory, W9ReplaySubCategory,
													TF1ReplayContainer, TF1ReplayCategory, TF1ReplaySubCategory,
													RTVEReplayContainer, RTVEReplaySubContainer,
													YouTubeContainer, YoutubeSearchContainer, YoutubeStandardFeedContainer, YoutubeUsersContainer, YoutubePlaylistContainer, YouTubeSubContainer
													]
			if isinstance(item, tuple(browseable_types)):
				self.browse_selected()
			w = LoadingWindow()
			w.show()
			item.execute()
			w.hide()
		return None

	# Launch InfoMenu for selected Item
	def action_info(self):
		if self.selected:
			from pygui.menu.menu.info import item_info_menu_dict
			try:
				info_menu = item_info_menu_dict[self.selected.type](self.selected)
			except KeyError:
				self._error_spawner()
				log.warn('No InfowWindow defined for type %s', self.selected.type)
			else:
				info_menu.show()
		return None

	def browse_previous(self):
		ret = GenericNavigator.browse_previous(self)
		stack = pygui_globs['menustack']
		if ret is None and stack.get_player() is None:
			if self['main_list'].selected_pos == 0 and 'universe_switcher' not in config.plugins:
				stack.back_to_home()
			else:
				self.select(0, force_pos=True)
				louie_send('main_list', action='update', sender=self, value=self['main_list'], position=0)
		return None



class MarkerNavigator(GenericNavigator):

	name = 'MarkerList'

	def __init__(self, name, universe, choices, origin, marker, **kw):
		GenericNavigator.__init__(self, name, universe, choices, eventhandler=MarkerListEventHandler(self), **kw)
		if origin:
			self.set_items([copy(origin)], list_name='origin_list')
		else:
			self.set_items([], list_name='origin_list')
		self.set_items([marker], list_name='markerlist')
		self.markerlist = marker
		self._getitems_keywords['origin_list'] = self._get_origin_list
		self.selected = None
		self.select(0)
		return None

	def _get_origin_list(self):
		return self.get_item_list('origin_list')
	
	def stop(self):
		try:
			pygui_globs['menustack'].get_navigator().force_preview = True
		except:
			PRINT_EXCEPTION()
		GenericNavigator.stop(self)
		return None

	def unmark_selected(self):
		sel = self.selected
		self.markerlist.del_item(sel)
		self.delete_item(sel)
		self.build_preview()
		return None

	def refresh_root(self):
		return None

	# Launch InfoMenu for marker navigator
	def action_info(self):
		from pygui.menu.menu.info import MarkerListInfoMenu
		info_menu = MarkerListInfoMenu(self.markerlist)
		info_menu.show()
		return None



# Navigator that uses ItemGrids instead of ItemLists.
# 
# Perfect for thumbnails and the like.
# Grids have their row lengths set by the row_length class attribute.
#
# TODO Maybe allow one row length per grid, with a {name: length} dict?
class GridNavigator(GenericNavigator):

	row_length = 5

	# Overridden to use ItemGrids instead of ItemLists
	def add_item_list(self, list_name, items=None):
		if list_name is not None:
			if not items:
				self.item_lists_dict[list_name] = ItemGrid(self, [], list_name, self.row_length)
			else:
				self.item_lists_dict[list_name] = ItemGrid(self, items, list_name, self.row_length)
		return None

	# Select the [item]th next column in an ItemGrid.
	# Note that unlike L{select}, this method requires item to be an int.
	def select_horizontal(self, item, list_name=None, force_pos=False):
		if not list_name:
			return self.get_item_list(self._active_list).select_horizontal(item, force_pos)
		return self.get_item_list(list_name).select_horizontal(item, force_pos)

	# Select the [item]th next row in an ItemGrid.
	# Note that unlike L{select}, this method requires item to be an int.
	def select_vertical(self, item, list_name=None, force_pos=False):
		if not list_name:
			return self.get_item_list(self._active_list).select_vertical(item, force_pos)
		return self.get_item_list(list_name).select_vertical(item, force_pos)



# Thumbnail browser.
class ThumbnailNavigator(GridNavigator):

	toggleable = False
	groupeable = True
	row_length = config.HMI_PHOTO['thumbnail_row_length']

	def __init__(self, name, universe, choices=None, eventhandler=None, folder=None, type=None, **kw):
		GridNavigator.__init__(self, name, universe, choices=choices, eventhandler=ThumbnailNavigatorEventHandler(self), type=type, **kw)
		self.folder = folder
		if not choices and self.folder:
			self.folder.menu = self
			self.set_items(self.folder.browse())
		self._getitems_keywords.pop('preview_list')
		self._getitems_keywords['parent_item_name'] = self._get_parent_item_name
		return None

	def _get_parent_item_name(self):
		if self.folder:
			return self.folder.name
		return u''
	
	def build_preview(self, *args, **kw):
		return None

	def stop(self):
		try:
			pygui_globs['menustack'].get_navigator().force_preview = True
		except:
			PRINT_EXCEPTION()
		GridNavigator.stop(self)
		metadata_collector_clear()
		return None

	@back_root_if_error
	def execute_selected(self):
		item = copy(self.selected)
		self.stop()
		if type(item) in (VideoItem, DVDItem, IsoDVDItem, TVRecordItem) and config.resume_video:
			position = self.selected['playbackStatus']
			if position:
				position = eval(position)
				_buttons = [Button(_('From last position'), True), Button(_('From the beginning'), False)]
				_buttons[0].connect(item.execute, position)
				_buttons[1].connect(item.execute)
				ConfirmWindow(text=_('Resume playback?'), buttons=_buttons).show()
				item = None
		if item is not None:
			w = LoadingWindow()
			w.show()
			item.execute()
			w.hide()
		return None

	# Refresh all thumbnails.
	def _refresh_main(self):
		louie_send('main_list', sender=self, action='reset', value=self['main_list'])
		return None

	# Callback for wymedia update: a new thumbnail is available.
	def _thumbnail_updated(self, item):
		pos = self['main_list'].index(item)
		louie_send('main_list', sender=self, action='reset', value=self['main_list'], position=pos)
		return None
