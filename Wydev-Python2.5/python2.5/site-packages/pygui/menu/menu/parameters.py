# -*- coding: utf-8 -*- 
#
# Description:
#
# Parameters Menus Class Definitions (NoteBook Type)
#
#
#
# Changes:
#
# 2011-10-02
# Initial Commit
#
# 2011-10-04
# Add cyclic behaviour to main parameter menu
# Modify version menu definition to handle center_list
# This is required for new Update parameter item.
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.


from __future__ import absolute_import

from time import time
from peewee.debug import GET_LOGGER, PRINT_EXCEPTION
from peewee.messages import send as louie_send, connect as louie_connect, disconnect as louie_disconnect
from peewee.notifier import Task
from peewee.system import get_free_available_space, get_space
from pygui.config import plugins, user_config
from pygui.eventmanager.menus import HorizontalNotebookMenuEventHandler, ParametersSubMenuEventHandler, SecretCodeMenuEventHandler
from pygui.facilities.codemapping import hdmiresolution_dict
from pygui.facilities.l10n import get_date_format, get_time_format
from pygui.item.core import Item
from pygui.item.parameters.generalsetup.securitysetup import SecretCodeUserConfigSetupItem, SecretCodeCheckConfigSetupItem
from pygui.item.parameters.videophoto.video import AspectRatioParametersSetupItem
from pygui.menu import UNIVERSE_NAME_DICT
from pygui.menu.menu.core import Menu
from pygui.menu.menu.notebook import NotebookMenu, NotebookSubMenu
from pygui.menu.menu.security import SecretCodeCheckMenu, QuestionAnswerCheckLauncher, QuestionAnswerSetupParametersLauncher
from pygui.shared import pygui_globs
from wynetwork.utils import WyNetwork




log = GET_LOGGER(__name__)

# SubMenus Definitions
_submenus_dict = {'generalsetup': (lambda : (GeneralConfigNotebookSubMenuParameters, dict(name=_('General'), type='notebook_setup_general'))), 'videophoto': (lambda : (GeneralNotebookSubMenuParameters, dict(name=_('Video/Photo'), type='notebook_setup_videophoto'))), 'connections': (lambda : (ConnectionsNotebookSubMenuParameters, dict(name=_('Connection'), type='notebook_setup_connections'))), 'network': (lambda : (NetworkNotebookSubMenuParameters, dict(name=_('General'), type='notebook_setup_network'))), 'advanced': (lambda : (AdvancedNotebookSubMenuParameters, dict(name=_('Advanced'), type='notebook_setup_advanced'))), 'version': (lambda : (VersionNotebookSubMenuParameters, dict(name=_('Version'), type='notebook_setup_version')))}

# Add Tv SubMenu Definition (if needed)
if 'tv' in plugins:
	from pygui.item.parameters.tv.tvsetup import TNTScanMenuSetupItem
	def submenus_dict_tv():
		return (TVNotebookSubMenuParameters, dict(name=_('TV'), type='notebook_setup_tv'))
	_submenus_dict['tv'] = submenus_dict_tv
else:
	TNTScanMenuSetupItem = None


class MainSetupParametersNotebookMenu(NotebookMenu):

	universe = 'setup'
	lazy_selection_delay = 1

	def __init__(self, name, **kw):
		self.parameters_items = []
		self.parameters_menus = []
		self.parameters_args = []
		self.type = kw['type']
		self._root_getter()
		self.eventhandler = HorizontalNotebookMenuEventHandler(self)
		NotebookMenu.__init__(self, name=name, choices=self.parameters_items, submenus=self.parameters_menus, subargs=self.parameters_args, subpos=-2, **kw)
		self.set_items(self.parameters_items)
		self.get_item_list('main_list').cyclic = True
		self.refresh_network_task = Task(self._refresh_network)
		self.refresh_network_task.delay = 1
		self.refresh_network = self.refresh_network_task.start
		self.wn = WyNetwork()
		self.wn.wn_dev.attach(self)
		self.wn.wn_gen.attach(self)

		def _network_text():
			status = _('Disconnected')
			try:
				if self.wn.wn_gen.isConnected():
					for dev in self.wn.wn_dev.getDevices():
						dev_infos = self.wn.wn_dev.getDeviceInfos(dev)
						if dev_infos['active'] == 'true':
							if dev_infos['networkType'] == '802.11':
								status = dev_infos['activeNetwork']
							else:
								status = _('Ethernet network')
							break
			except Exception, e:
				log.error('unable to get status from wynetwork')
				PRINT_EXCEPTION(e)
			return status

		def _network_icon():
			if self.wn.wn_gen.isConnected() and self.wn.wn_cfg.getActiveConfigurationInfos()['networkType'] != '802.3':
				return 'network_icon_wireless_selected.png'
			return 'network_icon_wired_selected.png'

		def _connection_text():
			if user_config['connections']['active_device'] == 'hdmi':
				current_connection = hdmiresolution_dict.get(user_config['connections']['resolution'], _('N/A'))
			else:
				current_connection = user_config['connections']['composite_output']
				current_connection = str(current_connection).upper()
			return current_connection

		self._getitems_keywords.update(dict(space_available=(lambda : _('%(size)s available space') % {'size': get_free_available_space('/wymedia')}), space_total=(lambda : _('%(size)s total space') % {'size': get_space('/wymedia')}), network=_network_text, network_icon=_network_icon, connection=_connection_text, universe_name=(lambda : UNIVERSE_NAME_DICT[self.type]), clock=(lambda : None)))
		louie_connect(self.connection_switched, 'connection_switched')
		return None

	# Load the root modules and fill parameters_items with it
	def _root_getter(self):
		if not self.parameters_items:
			glob = globals()
			loc = locals()
			for pname in sorted(plugins.get('parameters')):
				pname = pname.split('.', 1)[1]
				try:
					_mod = __import__('pygui.item.parameters.' + pname, glob, loc, ['items'], level=0)
					item = _mod.getitem(self)
					if item is not None:
						menu, arg = _submenus_dict[pname]()
						menu.related_item = item
						self.parameters_menus.append(menu)
						self.parameters_items.append(item)
						self.parameters_args.append(arg)
						log.debug('pygui.item.parameters.%s loaded' % pname)
				except Exception, e:
					PRINT_EXCEPTION(e)
		return None

	def refresh_connection(self, value):
		louie_send('connection', sender=self, value=value)
		return None

	# Handler called when HDMI/CVBS has been (un)plugged to refresh connection reading area
	def connection_switched(self, signal):
		self.refresh_connection(self['connection'])
		return None

	def _refresh_network(self):
		net_name = self['network']
		net_icon = self['network_icon']
		louie_send('network', sender=self, value=net_name)
		louie_send('network_icon', sender=self, value=net_icon)
		return None

	def on_modify_lang(self):
		stack = pygui_globs['menustack']
		for engine in stack.engines:
			for menu_widget in engine.menu_stack:
				menu = menu_widget.menu
				for item_list in menu.item_lists_dict.itervalues():
					for item in item_list:
						try:
							item.update_name()
						except AttributeError:
							pass
				menu_widget.sync_model_view()
				menu_widget.update_i18n()
		return None

	def stop(self):
		self.wn.wn_gen.detach(self)
		louie_disconnect(self.connection_switched, 'connection_switched')
		NotebookMenu.stop(self)
		return None

	def onConnected(self):
		self.refresh_network()
		return None

	def onDisconnected(self):
		self.refresh_network()
		return None

	def onDeviceConnected(self, device):
		self.refresh_network()
		return None

	def onDeviceDisconnected(self, device):
		self.refresh_network()
		return None


# Menu related to page 'General', 'Photo/Video', 'Connections', 'Version'
class GeneralNotebookSubMenuParameters(NotebookSubMenu):

	universe = 'setup'

	def __init__(self, browse_at_init=True, *args, **kw):
		self.eventhandler = ParametersSubMenuEventHandler(self)
		NotebookSubMenu.__init__(self, *args, **kw)
		self.available_choices = ['main_list', 'center_list', 'options_list']
		self._getitems_keywords.update(dict(center_list=(lambda : self.get_item_list('center_list')), options_list=(lambda : self.get_item_list('options_list'))))
		if browse_at_init:
			self._browse_main()
		self.browse_selected_task = Task(self._browse_selected)
		self.browse_selected_task.delay = 0.5
		self.browse_selected = self.browse_selected_task.start
		return None

	def _set_main(self, value):
		item_list = self.get_item_list('main_list')
		item_list.select(value)
		return None

	def _get_main(self):
		item_list = self.get_item_list('main_list')
		if not item_list.selected:
			ret = self['main_list']
		else:
			ret = item_list.selected
		return ret

	selected_main = property(_get_main, _set_main)
	del _get_main
	del _set_main

	def _set_center(self, value):
		item_list = self.get_item_list('center_list')
		item_list.select(value)
		return None

	def _get_center(self):
		item_list = self.get_item_list('center_list')
		if not item_list.selected:
			ret = self['center_list']
		else:
			ret = item_list.selected
		return ret

	selected_center = property(_get_center, _set_center)
	del _get_center
	del _set_center

	def _set_options(self, value):
		item_list = self.get_item_list('options_list')
		item_list.select(value)
		return None

	def _get_options(self):
		item_list = self.get_item_list('options_list')
		if not item_list.selected:
			ret = self['options_list']
		else:
			ret = item_list.selected
		return ret

	selected_options = property(_get_options, _set_options)
	del _get_options
	del _set_options

	# Browse the selected item on left_list or, if not, the top item
	# Set the result in :                                   
	#  - options_list if item's depth is 2               
	#  - center_list if item's depth is 3, then call _browse_center
	def _browse_main(self):
		if not self.selected_main:
			item_top = self['main_list'][0]
		else:
			item_top = self.selected_main
		if hasattr(item_top, 'depth'):
			if item_top.depth == 2:
				self.set_items([], 'center_list')
				self.set_items(item_top.browse(), 'options_list')
			elif item_top.depth == 3:
				self.set_items(item_top.browse(), 'center_list')
				self._browse_center()
		else:
			self.set_items([], 'center_list')
			self.set_items([], 'options_list')
		return None

	# Browse the selected item on center_list or, if not, the top item
	# Set the result, if capable, on options_list             
	def _browse_center(self):
		try:
			content = self.selected_center.browse()
		except AttributeError:
			log.debug('Center Item is not browseable')
			content = []
		self.set_items(content, 'options_list')
		return None

	def _browse_selected(self):
		switch = {'main_list': self._browse_main, 'center_list': self._browse_center}
		switch.get(self.active_list, (lambda : None))()
		return None

	def focus_next(self):
		if self.browse_selected_task.running:
			self.browse_selected_task.stop()
			self._browse_selected()
		if self.active_list == 'main_list' and not self['center_list']:
			log.debug('NEXT with center hop')
			self.active_list = 'options_list'
		else:
			log.debug('NEXT without center hop')
			Menu.focus_next(self)
		return None

	def focus_previous(self):
		if self.active_list == 'main_list':
			return False
		elif self.active_list == 'options_list' and not self['center_list']:
			log.debug('PREV with center hop')
			self.active_list = 'main_list'
		else:
			Menu.focus_previous(self)
		return None

	def _set_options_list(self, selection, keep_selection=False):
		self.selected.display_type = 'checked'
		self.focus_previous()
		self.browse_selected()
		return None



class GeneralConfigNotebookSubMenuParameters(GeneralNotebookSubMenuParameters):

	def __init__(self, *args, **kw):
		self.first_parental = False
		self._secret_code_launched = False
		GeneralNotebookSubMenuParameters.__init__(self, *args, **kw)
		return None

	def on_first_parental_control(self):
		user_config['security']['parental_control'] = False
		user_config.save()
		SecretCodeSetupParametersMenu(name='', verif_first=False).show()
		self._secret_code_launched = True
		return None

	def reload_func(self):
		if self._secret_code_launched and user_config['security']['secretcode'] is not None:
			self._secret_code_value = user_config['security']['secretcode']
			user_config['security']['secretcode'] = None
			user_config.save()
			def _set_parental_ok():
				user_config['security']['parental_control'] = True
				user_config['security']['secretcode'] = self._secret_code_value
				user_config.save()
				self.end_func()
				self.first_parental = False

			self._secret_code_launched = False
			QuestionAnswerSetupParametersLauncher(check=False, end_action=_set_parental_ok)
		return None



class ConnectionsNotebookSubMenuParameters(GeneralNotebookSubMenuParameters):

	def __init__(self, *args, **kw):
		GeneralNotebookSubMenuParameters.__init__(self, browse_at_init=False, *args, **kw)
		self.available_choices = ['main_list', 'center_list', 'options_list', 'aspect_ratio_options_list']
		self._getitems_keywords.update(dict(aspect_ratio_options_list=(lambda : self.get_item_list('aspect_ratio_options_list'))))
		self._browse_main()
		return None

	def _browse_main(self):
		if isinstance(self.selected_main, AspectRatioParametersSetupItem):
			try:
				content = self.selected_main.browse()
			except AttributeError:
				log.debug('Center Item is not browseable')
				content = []
			self.set_items(content, 'aspect_ratio_options_list')
			self.set_items([], 'options_list')
		else:
			GeneralNotebookSubMenuParameters._browse_main(self)
			self.set_items([], 'aspect_ratio_options_list')
		return None

	def focus_next(self):
		if isinstance(self.selected_main, AspectRatioParametersSetupItem) and self.active_list == 'main_list':
			if self.browse_selected_task.running:
				self.browse_selected_task.stop()
				self._browse_selected()
			self.active_list = 'aspect_ratio_options_list'
		else:
			GeneralNotebookSubMenuParameters.focus_next(self)
		return None

	def focus_previous(self):
		if self.active_list == 'main_list':
			return False
		elif self.active_list in ('options_list', 'aspect_ratio_options_list'):
			self.active_list = 'main_list'
		else:
			GeneralNotebookSubMenuParameters.focus_previous(self)
		return None

	def _set_options_list(self, selection, keep_selection=False):
		self.selected.display_type = 'checked'
		self.focus_previous()
		self.browse_selected()
		return None



class AdvancedNotebookSubMenuParameters(GeneralNotebookSubMenuParameters):

	def focus_next(self):
		from pygui.item.parameters.advanced.advancedsetup import ReInitBoxItem
		if isinstance(self.selected, ReInitBoxItem):
			return False
		else:
			GeneralNotebookSubMenuParameters.focus_next(self)
		return None



class VersionNotebookSubMenuParameters(GeneralNotebookSubMenuParameters):

	def focus_next(self):
		from pygui.item.parameters.advanced.advancedsetup import ReInitBoxItem
		if isinstance(self.selected, ReInitBoxItem):
			return False
		else:
			GeneralNotebookSubMenuParameters.focus_next(self)
		return None



class NetworkNotebookSubMenuParameters(GeneralNotebookSubMenuParameters):

	def _browse_main(self):
		GeneralNotebookSubMenuParameters._browse_main(self)
		from pygui.item.parameters.network.networksetup import StatusNetworkConfSetupItem
		if isinstance(self.selected, StatusNetworkConfSetupItem):
			self['options_list'].selected = None
		return None

	def focus_previous(self):
		return False

	def focus_next(self):
		return False



class TVNotebookSubMenuParameters(GeneralNotebookSubMenuParameters):

	def __init__(self, *args, **kw):
		GeneralNotebookSubMenuParameters.__init__(self, browse_at_init=False, *args, **kw)
		self.available_choices = ['main_list', 'center_list', 'options_list', 'options_auto_list']
		self._getitems_keywords.update(dict(options_auto_list=(lambda : self.get_item_list('options_auto_list'))))
		self._browse_main()
		return None

	def _browse_main(self):
		if isinstance(self.selected_main, TNTScanMenuSetupItem):
			try:
				content = self.selected_main.browse()
				louie_send('show_tv_button', sender=self)
			except AttributeError:
				log.debug('Center Item is not browseable')
				content = []
			self.set_items(content, 'options_auto_list')
			self.set_items([], 'options_list')
		else:
			GeneralNotebookSubMenuParameters._browse_main(self)
			self.set_items([], 'options_auto_list')
			louie_send('remove_tv_button', sender=self)
		return None

	def focus_previous(self):
		if self.active_list == 'main_list':
			return False
		elif self.active_list in ('options_list', 'options_auto_list'):
			if not self['center_list']:
				log.debug('PREV with center hop')
				self.active_list = 'main_list'
			else:
				self.active_list = 'center_list'
		else:
			Menu.focus_previous(self)
		return None

	def focus_next(self):
		if isinstance(self.selected_main, TNTScanMenuSetupItem) and self.active_list == 'main_list':
			if self.browse_selected_task.running:
				self.browse_selected_task.stop()
				self._browse_selected()
			self.active_list = 'options_auto_list'
		else:
			GeneralNotebookSubMenuParameters.focus_next(self)
		return None

	def _set_options_list(self, selection, keep_selection=False):
		self.selected.display_type = 'checked'
		self.focus_previous()
		self.browse_selected()
		return None



# This Menu adds new secret code capture capability to the SecretCodeCheckMenu.
# This appends after checking that user knows the current secret code
class SecretCodeSetupParametersMenu(SecretCodeCheckMenu):

	def __init__(self, name, verif_first=True, eventhandler=None, **kw):
		SecretCodeCheckMenu.__init__(self, name, **kw)
		self.main_items.append(SecretCodeUserConfigSetupItem(name='SecretCode', menu=self, domain='security', key='secretcode'))
		self.prompt_items.append(Item(name=_('Enter your new code'), type_='unknown'))
		self._current_action = self.main_items[0]
		self._display_explain = False
		if not verif_first:
			self._display_explain = True
			self._good_verif()
		return None

	def _good_verif(self):
		self._browse_items(1)
		self._current_action = self.main_items[1]
		self.active_list = 'main_list'
		return None

	def _set_options_list(self, selection, keep_selection=False):
		if isinstance(selection, SecretCodeCheckConfigSetupItem):
			if selection.check_entered_value():
				self._good_verif()
			else:
				try:
					remain = self.countdown.pop()
				except IndexError:
					QuestionAnswerCheckLauncher(self._good_verif)
				else:
					self._browse_items(0)
					self.active_list = 'main_list'
		else:
			if self._display_explain:
				louie_send('secret_code_explain_off', sender=self)
			pygui_globs['menustack'].back_one_menu()
		return None

	def cancel(self):
		if self._current_action is self.main_items[0]:
			SecretCodeCheckMenu.cancel(self)
		return None

	def show(self, hide_previous_menu=False):
		SecretCodeCheckMenu.show(self, hide_previous_menu)
		if self._display_explain:
			louie_send('secret_code_explain_on', sender=self)
		return None
