# -*- coding: utf-8 -*- 
#
# Description:
#
# TV Navigator Menu Definiton
#
#
#
# Changes:
#
# 2012-04-06
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

from __future__ import absolute_import

from time import time, strftime, localtime
from peewee.messages import send as louie_send
from peewee.debug import GET_LOGGER
from peewee.misc_utils import MetaSingleton
from peewee.notifier import Task
from peewee.formatters import ellipsize, seconds_to_hhmm, seconds_to_hhmm_utc
from wyrecord import WyRecord, SchedulerConflictError, SchedulerConflictWithInstantRecordError, SchedulerRecordingRunningError, SchedulerError
import pygui.config as config
from pygui.eventmanager.menus import TvNavigatorEventHandler
from pygui.item.scheduledrecord import ScheduledRecordRootItem, ScheduledRecordItem
from pygui.item.mediaitem.core import TVRootItem, DirItem, ChannelItem, AllChannelsList, Playlist, ProgramItem
from pygui.item.mediaitem.progressive_result import WindowedItemList
from pygui.item.core import Item
from pygui.menu import gui_updater, selective_gui_updater
from pygui.window import MessageWindow
from pygui.menu.menu.core import Menu
from pygui.menu.menu.info import ChannelInfoMenu, TVInfoMenu, ScheduledRecordRootInfoMenu
from pygui.menu.menu.navigators import Navigator, EmptyItem, back_root_if_error
from pygui.menu.menu.tv import ScheduledRecordNavigator
from pygui.menu.menu.tv.epg_grid import EPG_RECORDING_NAME_PATTERN
from pygui.shared import pygui_globs

log = GET_LOGGER(__name__)



#  A simple item to put in empty places to signal it.
class EmptyScheduledItem(Item):

	__metaclass__ = MetaSingleton
	locked = False
	hidden = False

	def __init__(self):
		Item.__init__(self, _('No scheduled recordings'), type_='empty', display_type='empty')
		return None


#  A simple item to put in empty places to signal it.
class EmptyProgramItem(Item):

	__metaclass__ = MetaSingleton
	locked = False
	hidden = False

	def __init__(self):
		Item.__init__(self, _('EPG not available'), type_='empty', display_type='empty')
		return None



# TV Navigator/zaplist.
# Appears when the user toggles away from the TV player.
class TvNavigatorMenu(Navigator):

	player = None
	toggleable = True

	def __init__(self, name=_('Channels List Menu'), services=[], type='tv_navigator', player=None, fill_root=True):
		Navigator.__init__(self, name=name, choices=services, type=type, fill_root=fill_root, universe='tv')
		self.eventhandler = TvNavigatorEventHandler(self)
		self._all_channel_list = None
		self._program = None
		self._player = player
		self._getitems_keywords.update(dict(program_start_time=(lambda : (seconds_to_hhmm(int(self._program.wymedia_resource['scheduledStartTime'])) if self._program and seconds_to_hhmm(int(self._program.wymedia_resource['scheduledStartTime'])) else '')),
																				program_stop_time=(lambda : (seconds_to_hhmm(int(self._program.wymedia_resource['scheduledEndTime'])) if self._program and seconds_to_hhmm(int(self._program.wymedia_resource['scheduledEndTime'])) else '')),
																				program_remaining_time=(lambda : (seconds_to_hhmm_utc(min(int(self._program.wymedia_resource['scheduledEndTime']) - self._player.real_utc_time, self._program['duration'])) if self._program and self._player and seconds_to_hhmm_utc(min(int(self._program.wymedia_resource['scheduledEndTime']) - self._player.real_utc_time, self._program['duration'])) else '')),
																				program_elapsed_time=(lambda : (seconds_to_hhmm_utc(max(self._player.real_utc_time - int(self._program.wymedia_resource['scheduledStartTime']), 0)) if self._program and self._player and seconds_to_hhmm_utc(max(self._player.real_utc_time - int(self._program.wymedia_resource['scheduledStartTime']), 0)) else '')),
																				program_duration=(lambda : (seconds_to_hhmm_utc(self._program['duration']) if self._program and seconds_to_hhmm_utc(self._program['duration']) else '')),
																				program_description=(lambda : (self._program.short_description + '\n' + self._program.description if self._program and self._program.short_description + '\n' + self._program.description else '')),
																				program_content_type=(lambda : (self._program.content_type if self._program and self._program.content_type else '')),
																				live_time=(lambda : (self._player['live_time'] if self._player and self._player['live_time'] else '')),
																				record_timeshift_programbar=self._get_program_bar,
																				recording_info=self._get_recording_info))
		self.tasks.update({'show_help_left': Task(self._show_help, side=-1), 'show_help_right': Task(self._show_help, side=1)})
		return None

	def _show_help(self, side=0):
		if config.user_config['base']['help_banner']:
			if config.user_config['base']['help_banner'] == 1:
				louie_send('hide_help', sender=self)
			if not side:
				louie_send('show_help', sender=self)
			elif side == 1:
				louie_send('show_help_right', sender=self)
			elif side == -1:
				louie_send('show_help_left', sender=self)
			self.hide_help()
		return None

	def show_help_left(self):
		if self.show_help_banner:
			self.tasks['show_help_left'].start(0.5)
		return None

	def show_help_right(self):
		if self.show_help_banner:
			self.tasks['show_help_right'].start(0.5)
		return None

	def _get_program_bar(self):
		sel = self.selected
		program = None
		if isinstance(sel, ChannelItem):
			service = sel
			l = self.get_item_list('preview_list')
			if len(l) > 0 and l[0]:
				program = l[0]
			else:
				program = None
		elif isinstance(sel, ProgramItem):
			service = self._history[-1]['selected']
			program = sel
		elif isinstance(sel, ScheduledRecordRootItem):
			program = None
		res = dict()
		if self._player is None or program in (None, EmptyProgramItem()):
			res['program_begin'] = 0
			res['program_end'] = 100
			res['direct'] = 0
			res['live'] = 0
		else:
			_lc = self._player.live_controller
			res['program_begin'] = int(program['scheduledStartTime'])
			res['program_end'] = int(program['scheduledEndTime'])
			time_info = _lc.default_renderer.getTimeInfo()
			res['direct'] = time_info.max_available_time
			res['live'] = time_info.current_time
			if self._player.selected['serviceId'] == service['serviceId']:
				res['timeshift_begin'] = time_info.min_available_time
				res['timeshift_end'] = res['direct']
				if self._player._record:
					res['record_begin'] = self._player._record.start_time
					res['record_end'] = self._player._record.stop_time
				else:
					res['record_begin'] = None
					res['record_end'] = None
			else:
				res['timeshift_begin'] = None
				res['timeshift_end'] = None
		return res

	# If a recording is underway, return the name of the corresponding channel.
	def _get_recording_info(self):
		for live in WyRecord().live_controller.getRunningLiveList():
			if live.isRecording():
				service_id = live.serviceid
				channel = self._all_channel_list.get_channel_from_service_id(service_id)
				return channel.name
		return u''

	# Generate the root of the TV toggle menu.
	def root_getter(self):
		tv_root = TVRootItem()
		_list = []
		_list.append(ScheduledRecordRootItem(self, parent=tv_root))
		self._all_channel_list = tv_root.get_acl(self)
		_list.append(self._all_channel_list)
		_list.extend(list(tv_root.browse_favorites(self)))
		return _list

	def select(self, item, list_name=None):
		ret = Menu.select(self, item, list_name)
		if ret:
			louie_send('hide_preview', sender=self)
			if isinstance(self.selected, ProgramItem):
				self._program = self.selected
			else:
				self._program = None
			self.build_preview()
		return ret

	# Execute the selected item, overriding the "now playing" stuff done in normal navigators.
	# 
	# There's no sense in doing it for TV channels -- they don't ever finish, so:
	#     - If all tuners are busy running records, display a warning message and don't do anything else
	#         (unless we're trying to zap to the currently-selected channel).
	#     - If the selected item is a channel, zap to it (and its parent favorite list).
	#     - If the selected item is a favorite list or the ACL, zap to the first element in that list.
	# 
	# TODO Maybe it'd be better to move the special-case logic to a
	# theoretical TVFavorite(Playlist) class, but right now there's no
	# sure-fire way to tell a TV favorite from a regular playlist at
	# the Wymedia level. We'll see.
	def execute_selected(self):
		item = self.selected
		player = self._player
		if isinstance(item, Playlist):
			self.browse_selected()
			return None
		if item == player.selected or player.can_zap():
			if isinstance(item, DirItem):
				item.browse()[0].execute()
			else:
				Navigator.execute_selected(self)
		else:
			title = _("Can't change channels")
			message = _('A recording is in progress. Stop it before zapping.')
			MessageWindow(message, title, button=None).show(timeout=5)
		return None

	def _build_preview(self):
		sel = self.selected
		if not self._history:
			self._refresh_root()
		sel = self.selected
		item_list = None
		_refresh_program_bar = False
		if isinstance(sel, ProgramItem):
			louie_send('empty_preview', self)
			selective_gui_updater('program_start_time', 'program_stop_time', 'program_remaining_time', 'program_elapsed_time', 'program_duration', 'program_content_type', 'program_description', 'record_timeshift_programbar')((lambda self: None))(self)
			return True
		elif isinstance(sel, ChannelItem):
			try:
				item_list = sel.browse(self._player.real_utc_time, limit=4)
			except:
				item_list = sel.browse()
			if len(item_list) == 0:
				item_list = [EmptyProgramItem()]
			_refresh_program_bar = True
		else:
			item_list = sel.browse()
			if len(item_list) == 0:
				if isinstance(self.selected, ScheduledRecordRootItem):
					item_list = [EmptyScheduledItem()]
				else:
					item_list = [EmptyItem()]
		self.set_items(item_list[:4], list_name='preview_list', position=-1)
		louie_send('show_preview', self)
		if _refresh_program_bar:
			louie_send('record_timeshift_programbar', sender=self, value=self['record_timeshift_programbar'])
		louie_send('not_empty_preview', self)
		return True

	def browse_selected(self):
		# TOFIX changed is always False. It's maybe an old removed feature.
		changed = False
		args = list()
		kw = dict()
		preview_list = self.get_item_list('preview_list')
		_sel = self.selected
		if isinstance(_sel, ProgramItem):
			louie_send('main_list_not_browse', sender=self)
			return None
		elif len(preview_list) < 2 and preview_list[0] in [EmptyProgramItem(), EmptyItem(), EmptyScheduledItem()]:
			return None
		elif isinstance(_sel, ChannelItem):
			louie_send('show_program_info', sender=self)
			louie_send('show_program_bar', sender=self)
			louie_send('hide_preview_program_bar', sender=self)
			louie_send('show_program_description', sender=self)
			self.show_help_left()
			kw['pad'] = False
			kw['start_time'] = self._player.real_utc_time
			selective_gui_updater('record_timeshift_programbar')((lambda self: None))(self)
		elif isinstance(_sel, (AllChannelsList, Playlist)):
			self._favorites_list = _sel
			louie_send('show_preview_program_bar', sender=self)
			louie_send('hide_program_bar', sender=self)
			self.show_help()
			selective_gui_updater('record_timeshift_programbar')((lambda self: None))(self)
		elif isinstance(_sel, ScheduledRecordRootItem):
			_schedule_menu = ScheduledRecordNavigator(name=_sel.name)
			louie_send('hide_program_bar', sender=self)
			louie_send('hide_preview_program_bar', sender=self)
			_schedule_menu.show()
			return None
		Navigator.browse_selected(self, action_override=True, *args, **kw)
		if isinstance(self.selected, ProgramItem):
			self._program = self.selected
		else:
			self._program = None
		if changed:
			self.universe = 'tv'
		return None

	def browse_previous(self):
		try:
			last_context = self._history.pop()
			if hasattr(self.selected, 'unwatch'):
				self.selected.unwatch(self._selection_changed)
		except IndexError:
			if self.selected and self.selected.parent:
				self.go_to_item(self.selected.parent, 'event_left')
				louie_send('on_root', sender=self)
			return None
		if last_context is not None:
			louie_send('hide_program_bar', sender=self)
			louie_send('event_left', sender=self)
			@selective_gui_updater('parent_item_name', 'parent_icon_name')
			def _set_prev_content(self, preview_list):
				prev_items = last_context['items']
				if isinstance(prev_items, WindowedItemList):
					prev_items.menu = self
					prev_items._fill_cache()
				self.set_items(prev_items, 'main_list', last_context['position'])
				_sel = self.selected
				if isinstance(_sel, ScheduledRecordItem):
					preview_list = _sel.browse()
					louie_send('hide_preview_program_bar', sender=self)
					self.show_help()
				elif isinstance(_sel, (AllChannelsList, Playlist)):
					louie_send('hide_preview_program_bar', sender=self)
					self.show_help_right()
				elif isinstance(_sel, ChannelItem):
					louie_send('show_preview_program_bar', sender=self)
					self.show_help()
					for it in ('program_start_time', 'program_stop_time', 'program_remaining_time', 'program_elapsed_time', 'program_duration', 'program_content_type', 'program_description'):
						louie_send(it, sender=self, value=None)
				elif isinstance(_sel, DirItem) and _sel.wymedia_resource['backend'] == 'wyrecord':
					self.show_help_right()
				self.set_items(preview_list, 'preview_list', -1)
				louie_send('not_empty_preview', self)
				louie_send('hide_program_info', sender=self)
				return None
			self.tasks['set_prev_content'] = Task(_set_prev_content, self, (self.choices[0:10] if self.choices else [EmptyProgramItem()]))
			self.tasks['set_prev_content'].start(config.HMI_BASE['navigator_listing_delay'])
			return True
		return False

	def select_service(self, playlist, service):
		self._history.empty()
		root = self.root_getter()
		position = root.index(playlist)
		playlist = root[position]
		self._history.append(dict(position=position, selected=playlist, items=root))
		_playlist = playlist.browse()
		try:
			ind = _playlist.index(service)
		except ValueError, e:
			ind = 0
		self.set_items(_playlist, position=ind)
		self.build_preview()
		louie_send('hide_program_info', sender=self)
		louie_send('show_preview_program_bar', sender=self)
		louie_send('hide_program_bar', sender=self)
		return None

	@gui_updater
	def select_program(self, playlist, service):
		self._history.empty()
		root = self.root_getter()
		position = root.index(playlist)
		playlist = root[position]
		self._history.append(dict(position=position, selected=playlist, items=root))
		_playlist = playlist.browse()
		self._history.append(dict(position=_playlist.index(service), selected=service, items=_playlist))
		if self._player:
			programs_list = service.browse(start_time=self._player.real_utc_time, pad=False)
		else:
			programs_list = service.browse(pad=False)
		if len(programs_list) < 1:
			programs_list = [EmptyProgramItem()]
			self.set_items(programs_list)
			self._program = None
		else:
			self.set_items(programs_list)
			self._program = self.selected
		self.set_items([], 'preview_list')
		louie_send('show_program_info', sender=self)
		louie_send('empty_preview', sender=self)
		louie_send('hide_preview_program_bar', sender=self)
		louie_send('show_program_bar', sender=self)
		return None

	def select_schedule_recordings(self):
		self._history.empty()
		root = self.root_getter()
		self.set_items(root)
		self._build_preview()
		self.browse_selected()
		return None

	# Refresh the parent item name when toggling in.
	@selective_gui_updater('parent_item_name', 'parent_icon_name', 'recording_info')
	def on_foreground(self):
		Navigator.on_foreground(self)
		return None

	# Display the EPG grid.
	def display_epg(self):
		self._player.display_epg()
		return None

	# Take in count when previous item is MyRecordings, so change self.universe on the fly
	@back_root_if_error
	def _reload_func(self):
		# TODO changed is strange !!!
		changed = False
		try:
			previous = self._history[-1]['selected']
		except IndexError:
			previous = self.selected.parent
		if isinstance(previous, DirItem) and previous.wymedia_resource['backend'] == 'wyrecord':
			# TODO set changed to True and self.universe to 'video'
			changed = True
			self.universe = 'video'
		elif isinstance(self.selected, ProgramItem):
			louie_send('show_program_info', sender=self)
			louie_send('show_program_bar', sender=self)
		if changed:
			# TODO changed is True so self.universe is setted to 'tv' ???
			self.universe = 'tv'
		log.debug('reloading %s', self)
		if pygui_globs['menustack'].menus_stack[-1] is not self:
			return None
		louie_send('parental_rating', sender=self, action='reset', value=self['parental_rating'])
		self._update_marker()
		try:
			previous = self._history[-1]['selected']
		except IndexError:
			previous = self.selected.parent
		if previous.parent is None:
			self.refresh_root()
			return None
		old_sel = self.selected_pos
		if isinstance(previous, ChannelItem):
			new_content = previous.browse(self._player.real_utc_time, pad=False)
		else:
			new_content = previous.browse()
		try:
			new_content[max(old_sel, 0)]
		except IndexError:
			old_sel = len(new_content) - 1
		if (self.selected is None or old_sel == -1) and len(new_content) > 0:
			old_sel = 0
		elif not(len(new_content)):
			self.selected = None
			self.set_items('preview_list')
		self.set_items(new_content, list_name='main_list', position=old_sel)
		if hasattr(self.selected, 'watch'):
			self.selected.watch(self._selection_changed)
		return None

	# Display an information window for the selected item (if possible).
	#
	# There's some isinstance branching in there -- maybe there's a better way to handle this.
	def action_info(self):
		item = self.selected
		if isinstance(item, ChannelItem):
			menu = ChannelInfoMenu(item)
		elif isinstance(item, AllChannelsList):
			menu = TVInfoMenu(item)
		elif isinstance(item, ScheduledRecordRootItem):
			menu = ScheduledRecordRootInfoMenu(item)
		else:
			log.error("Information window for %s (%s) isn't supported", item, type(item))
		menu.show()
		return None

	# If a program is selected, schedule it for recording.
	#
	# TODO Maybe start an instant recording if a channel is selected?
	def action_record(self):
		item = self.selected
		if isinstance(item, ProgramItem):
			if item.recording_id:
				self.cancel_record_selected()
			else:
				self.record_selected()
			self.set_items(item.parent.browse(self._player.real_utc_time), 'main_list', position=self.selected_pos)
		else:
			self._error_spawner()
		return None

	# If a program is selected and scheduled for recording, cancel it.
	#
	# TODO Maybe stop recording if a recording channel is selected?
	def action_stop(self):
		item = self.selected
		if isinstance(item, ProgramItem) and item.recording_id:
			self.cancel_record_selected()
			self.set_items(item.parent.browse(self._player.real_utc_time), 'main_list', position=self.selected_pos)
		else:
			self._error_spawner()
		return None

	# Attempt to record the selected program.
	#
	# TODO Factor this out, it's cut&pasted from epg_grid.py.
	def record_selected(self):
		program = self.selected
		now = int(time())
		if program.end_time > now:
			start_time = max(now, program.start_time)
			end_time = min(program.end_time, start_time + 21600)
			channel = program.parent
			chan_id = int(channel['serviceId'])
			favorite_name = channel.parent.name
			values = {'channel': channel.name, 'title': program.name, 'date': strftime('%Y/%m/%d', localtime(start_time)), 'start_time': seconds_to_hhmm(start_time), 'end_time': seconds_to_hhmm(end_time)}
			record_name = EPG_RECORDING_NAME_PATTERN % values
			try:
				WyRecord().scheduler.ScheduleRecording(chan_id, start_time, end_time, record_name, program_id=program.id, favorite=favorite_name)
				louie_send('update_record')
			except SchedulerConflictWithInstantRecordError, e:
				louie_send('update_record', sender=None)
				conflicting_rec = e.conflict.getAllRecInConflict()[0]
				message_pattern = _('An instant recording on %(channel)s will be stopped when this recording starts.')
				message = message_pattern % {'name': ellipsize(conflicting_rec.name, 40), 'start_time': seconds_to_hhmm(conflicting_rec.start_time), 'channel': conflicting_rec.service_name}
				title = _('Conflict with an instant recording')
				MessageWindow(message, title, button=None).show(timeout=5)
			except SchedulerConflictError, e:
				conflicting_rec = e.conflict.getAllRecInConflict()[0]
				message_pattern = _('The recording you are attempting to schedule conflicts with "%(name)s", starting at %(start_time)s on %(channel)s.')
				message = message_pattern % {'name': ellipsize(conflicting_rec.name, 40), 'start_time': seconds_to_hhmm(conflicting_rec.start_time), 'channel': conflicting_rec.service_name}
				title = _('Recording scheduler error')
				MessageWindow(message, title, button=None).show(timeout=5)
			except SchedulerError, e:
				log.error("Can't start recording due to %s", e)
				title = _('Recording scheduler error')
				message = 'Unable to schedule your recording. Sorry.'
				MessageWindow(message, title, button=None).show(timeout=5)
		else:
			message = _('The program is over. You cannot record it.')
			title = _('Program already over')
			win = MessageWindow(message, title, button=None)
			win.show(timeout=5)
		return None

	# Cancel the scheduled recording of the selected program.
	#
	# TODO Factor this out, it's cut&pasted from epg_grid.py.
	def cancel_record_selected(self):
		program = self.selected
		rec_id = program.recording_id
		if rec_id:
			log.info('Canceling recording for %s', program)
			try:
				WyRecord().scheduler.DeleteRecording(rec_id)
			except SchedulerRecordingRunningError:
				error_title = _('Impossible to cancel recording')
				message = _('This recording has already started. To stop it, close the EPG grid and press Stop.')
				MessageWindow(message, error_title, button=None).show(timeout=5)
		return None
