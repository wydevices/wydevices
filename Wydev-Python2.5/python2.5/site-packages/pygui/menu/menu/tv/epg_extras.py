# -*- coding: utf-8 -*- 
#
# Description:
#
# EPG Extras Menus Definitons
#
#
#
# Changes:
#
# 2012-04-04
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

from __future__ import absolute_import

from datetime import timedelta
from peewee.messages import send as louie_send
from peewee.formatters import seconds_to_hhmm, seconds_to_hhmm_utc
from peewee.notifier import Task
from pygui.config import HMI_TV
from pygui.eventmanager.menus import EpgControlWindowEventHandler, EpgInfoBannerEventHandler
from pygui.facilities.l10n import get_date_format
from pygui.facilities import timeslices as ts
from pygui.item.core import Item
from pygui.item.mediaitem import HiddenRoot, TVRootItem
from pygui.menu import selective_gui_updater
from pygui.menu.menu.core import Menu



# EPG control window.
class EpgControlWindowMenu(Menu):

	fields = ['date', 'time_slice', 'favorite_list']

	def __init__(self, grid):
		Menu.__init__(self, name='EPG Control Window', choices=[], type='epg_control_window', universe='tv')
		self.eventhandler = EpgControlWindowEventHandler(self)
		self._getitems_keywords.update({'date': self.get_date, 'time_slice': self.get_time_slice, 'favorite_list': self.get_favorite_list})
		self.grid = grid
		self.favorites = HiddenRoot().get_child('TV Favorites', self.grid).browse()
		self.acl = TVRootItem().get_acl(self.grid)
		if self.grid.channel_list['index'] is None:
			self.selected_favorite_pos = -1
		else:
			self.selected_favorite_pos = int(self.grid.channel_list['index'])
		self.field_dispatch = [self.select_date, self.select_visible_time_slice, self.select_favorite_list]
		self.selected_field = 0
		self.start_time, self.end_time = grid.start_time, grid.end_time
		self.commit_task = Task(self._commit_changes)
		return None

	# Change fields.
	def select_field(self, value):
		if 0 <= self.selected_field + value <= len(self.fields):
			self.selected_field += value
			field_name = self.fields[self.selected_field]
			louie_send('on_control_select_%s' % field_name, sender=self)
		return None

	# Change the value of the current field.
	def select_value(self, value):
		self.field_dispatch[self.selected_field](value)
		return None

	# Select the [value]th next day, remaining on the same time slice.
	# value may be negative.
	@selective_gui_updater('date')
	def select_date(self, value):
		delta = timedelta(days=value)
		if self.grid.lower_limit <= self.start_time + delta <= self.grid.upper_limit:
			self.start_time += delta
			self.end_time += delta
			self.commit_task.start(delay=HMI_TV['zap_time'])
		return None

	# Select the [value]th next visible time slice. value may be negative.
	# Attempting to switch to the next time slice while the active one is
	# 'night' will select the 'morning' time slice on the next day.
	@selective_gui_updater('time_slice', 'date')
	def select_visible_time_slice(self, value):
		slice_count = ts.distance_to_visible_slice(self.start_time, value)
		target_start, target_end = ts.timeslice_boundaries(self.start_time.slice_count)
		if self.grid.lower_limit <= target_start <= self.grid.upper_limit:
			self.start_time = target_start
			self.end_time = target_end
			self.commit_task.start(delay=HMI_TV['zap_time'])
		return None

	# Return the selected favorite list.
	# (the ACL counts as a favorite list for the intents of this property)
	@property
	def selected_favorite_list(self):
		return (self.acl if self.selected_favorite_pos == -1 else self.favorites[self.selected_favorite_pos])

	# Change the active favorite list.
	@selective_gui_updater('favorite_list')
	def select_favorite_list(self, value):
		num_favorites = len(self.favorites)
		if not num_favorites:
			return None
		if self.selected_favorite_pos == -1:
			self.selected_favorite_pos = (0 if value > 0 else num_favorites - 1)
		elif 0 <= self.selected_favorite_pos + value < num_favorites:
			self.selected_favorite_pos += value
		else:
			self.selected_favorite_pos = -1
		self.commit_task.start(delay=HMI_TV['zap_time'])
		return None

	# Commit pending time slice and channel list selections, if any.
	# Those selections are accumulated:
	#     - in (self.start_time, self.end_time) for the time slice changes,
	#     - in self.selected_favorite_list for the channel list changes,
	# and commited by commit_task after HMI_TV['zap_time'] seconds, in order
	# to achieve a quick zap-like behavior.
	def _commit_changes(self):
		grid = self.grid
		if self.selected_favorite_list != grid.channel_list:
			grid.set_channel_list(self.selected_favorite_list)
		if self.start_time != grid.start_time:
			grid.set_boundaries(self.start_time, self.end_time)
			grid.select_current_program()
		return None

	def display_info_banner(self):
		self.grid.display_info_banner()
		return None

	def show(self):
		return Menu.show(self, False)

	def get_date(self):
		return ts.get_epg_day(self.start_time).strftime(get_date_format())

	def get_time_slice(self):
		slice_id = ts.get_visible_slice_id(self.start_time)
		return ts.NAMES[slice_id]

	def get_favorite_list(self):
		return self.selected_favorite_list.name



# Full information banner for a program.
class EpgInfoBanner(Menu):

	PAGE_SIZE = 900

	def __init__(self, program):
		Menu.__init__(self, name='EPG Info Banner', choices=[], type='epg_info_banner')
		self.eventhandler = EpgInfoBannerEventHandler(self)
		self._getitems_keywords.update({'name': self.get_name, 'start_time': self.get_start_time, 'end_time': self.get_end_time, 'duration': self.get_duration, 'content_type': self.get_content_type, 'description': self.get_description})
		self.program = program
		description = self.program.short_description + '\n' + program.description
		if description:
			self.pages = [description[start:start + self.PAGE_SIZE] for start in  xrange(0, len(description), self.PAGE_SIZE)]	
		else:
			self.pages = []
		self.selected_page = 0
		extra_info = [Item(name=title, type_=key.lower(), menu=self) for key, title in program.EXTRA_INFO_FIELDS if int(program[key])]
		maturity_key = program['maturityRating']
		if maturity_key is not None:
			maturity = 'maturityrating_%i.png' % int(maturity_key)
		else:
			maturity = 'maturityrating_unknown.png'
		extra_info.append(Item(name='maturity', type_=maturity, menu=self))
		self.set_items(extra_info, 'main_list', -1)
		return None

	@selective_gui_updater('description')
	def select_page(self, value):
		if 0 <= self.selected_page + value < len(self.pages):
			self.selected_page += value
		return None

	def show(self):
		return Menu.show(self, False)

	def get_name(self):
		return self.program.name

	def get_start_time(self):
		return seconds_to_hhmm(self.program.start_time)

	def get_end_time(self):
		return seconds_to_hhmm(self.program.end_time)

	def get_duration(self):
		return seconds_to_hhmm_utc(self.program.duration)

	def get_content_type(self):
		return self.program.content_type

	def get_short_description(self):
		return self.program.short_description

	def get_description(self):
		return self.pages[self.selected_page]
