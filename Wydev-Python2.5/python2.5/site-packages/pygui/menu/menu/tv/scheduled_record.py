# -*- coding: utf-8 -*- 
#
# Description:
#
# Scheduled Record Menu Definiton
#
#
#
# Changes:
#
# 2012-04-06
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

from __future__ import absolute_import

from datetime import date, datetime, timedelta
from time import time, mktime, localtime, strftime
from peewee.messages import send as louie_send
from peewee.debug import GET_LOGGER, PRINT_EXCEPTION
from peewee.formatters import seconds_to_hhmm
from wyrecord import WyRecord
from wyrecord.exceptions import SchedulerConflictWithInstantRecordError, SchedulerConflictError, SchedulerError, SchedulerRecordingRunningError
from pygui.menu.menu import Menu
from pygui.eventmanager.menus import ModifyScheduledRecordMenuEventHandler
from pygui.facilities.l10n import get_date_format
from pygui.facilities.timeslices import datetime_to_timestamp
from pygui.item.core import Item, ActionItem
from pygui.item.containers import ItemListItem
from pygui.item.mediaitem.core import TVRootItem
from pygui.shared import pygui_globs
from pygui.item.scheduledrecord import PeriodicScheduledRecordItem, ScheduledRecordItem
from pygui.menu import gui_updater, selective_gui_updater
from pygui.config import user_config
from pygui.window import Button, ConfirmWindow, LoadingWindow, KeyboardWindow, MessageWindow
from pygui.facilities.codemapping import day_dict

log = GET_LOGGER(__name__)



def days_in_month(year, month):
	c = date(year, month, 1)
	d = date(c.year + (1 if c.month == 12 else 0), max(1, (c.month + 1) % 13), 1)
	return (d - c).days



class IntegerItem(Item):

	def __init__(self, val, type_='int', menu=None, display_type=None, parent=None):
		Item.__init__(self, '%.2d' % val, type_, menu=None, display_type=None, parent=None)
		self.val = val
		return None

	def __eq__(self, other):
		if isinstance(other, Item):
			return self.val == other.val
		return False



HOURS = [IntegerItem(i) for i in xrange(24)]
MINUTES = [IntegerItem(i) for i in xrange(60)]
MONTHS = [IntegerItem(i) for i in xrange(1, 13)]
REPEAT_NUMBERS = HOURS + [IntegerItem(24), IntegerItem(25)]
DATE_ORDERS = [[1, 0, 2], [2, 0, 1], [0, 2, 1]]



class ScheduledRecordMenu(Menu):

	def __init__(self, name=_('Scheduled recordings'), type_='scheduled_records'):
		Menu.__init__(self, name, type=type_, universe='tv')
		self.PERIODICITY = {'none': (_('Only this time'), 0), 'daily': (_('Every day'), 1), 'weekly': (_('Every week'), 7)}
		self._favorite_list = [TVRootItem().get_acl(menu=self)]
		self._favorite_list.extend(TVRootItem().browse_favorites(self))
		self._all_channel_list = self._favorite_list[0]
		self.eventhandler = ModifyScheduledRecordMenuEventHandler(self)
		self.channel_list = ItemListItem(_('Channels'), menu=self, _list=self._favorite_list, list_name='channel_name_list')
		self.favorite_list = ItemListItem(_('Favorites'), menu=self, _list=self._all_channel_list.browse(), list_name='favorite_name_list')
		self.service_list = ItemListItem(_('Channel'), menu=self, _list=[self.channel_list, self.favorite_list], list_name='service_list')
		self.item_lists_dict['service_list'] = self.service_list
		_today = date.today()
		date_list = [[_('Month'), MONTHS], [_('Year'), [IntegerItem(i) for i in xrange(_today.year + 10)]], [_('Day'), [IntegerItem(i) for i in xrange(1, days_in_month(_today.year, _today.month) + 1)]]]
		date_order = DATE_ORDERS[user_config['base']['dateformat']]
		self.day_index = date_order.index(2)
		self.month_index = date_order.index(0)
		self.year_index = date_order.index(1)
		self.date_1_list = ItemListItem(date_list[date_order[0]][0], menu=self, _list=date_list[date_order[0]][1], list_name='date_1_list')
		self.date_2_list = ItemListItem(date_list[date_order[1]][0], menu=self, _list=date_list[date_order[1]][1], list_name='date_2_list')
		self.date_3_list = ItemListItem(date_list[date_order[2]][0], menu=self, _list=date_list[date_order[2]][1], list_name='date_3_list')
		self.date_list = ItemListItem(_('Date'), menu=self, _list=[self.date_1_list, self.date_2_list, self.date_3_list], list_name='date_list')
		self.item_lists_dict['date_list'] = self.date_list
		self.start_hour_list = ItemListItem(_('Hour'), menu=self, _list=HOURS, list_name='start_hour_list')
		self.start_minute_list = ItemListItem(_('Minute'), menu=self, _list=MINUTES, list_name='start_minute_list')
		self.start_time_list = ItemListItem(_('Start time'), menu=self, _list=[self.start_hour_list, self.start_minute_list], list_name='start_time_list')
		self.item_lists_dict['start_time_list'] = self.start_time_list
		self.stop_hour_list = ItemListItem(_('Hour'), menu=self, _list=HOURS, list_name='stop_hour_list')
		self.stop_minute_list = ItemListItem(_('Minute'), menu=self, _list=MINUTES, list_name='stop_minute_list')
		self.stop_time_list = ItemListItem(_('End time'), menu=self, _list=[self.stop_hour_list, self.stop_minute_list], list_name='stop_time_list')
		self.item_lists_dict['stop_time_list'] = self.stop_time_list
		self.record_name = ''
		def _fun(key):
			it = Item(self.PERIODICITY[key][0], 'periodic', self)
			it.val = self.PERIODICITY[key]
			it.key = key
			return it
		self.repetition_type_list = ItemListItem(_('Frequency'), menu=self, _list=map(_fun, ['none', 'daily', 'weekly']), list_name='repetition_type_list')
		self.repetition_list = ItemListItem(_('Frequency'), menu=self, _list=[self.repetition_type_list], list_name='repetition_list')
		self.item_lists_dict['repetition_list'] = self.repetition_list
		self.repetition_number_list = ItemListItem(_('Number of recordings'), menu=self, _list=REPEAT_NUMBERS, list_name='repetition_number_list')
		self.repetition_num_list = ItemListItem(_('Number of recordings'), menu=self, _list=[self.repetition_number_list], list_name='repetition_num_list')
		self.item_lists_dict['repetition_num_list'] = self.repetition_num_list
		self.confirm_list = ItemListItem(_('Confirm'), menu=self, list_name='confirmation_option_list', _list=[Item(_('Confirm'), 'choice', menu=self)])
		self.cancel_list = ItemListItem(_('Cancel'), menu=self, list_name='cancellation_option_list', _list=[Item(_('Cancel'), 'choice', menu=self)])
		self.confirm_list.execute = self._confirm
		self.cancel_list.execute = self.cancel
		self.confirmation_list = ItemListItem(_('Actions'), menu=self, list_name='confirmation_list', _list=[self.confirm_list, self.cancel_list])
		self.confirmation_list.select(None, True)
		self.item_lists_dict['confirmation_list'] = self.confirmation_list
		self.set_items([self.service_list, self.date_list, self.start_time_list, self.stop_time_list, self.repetition_list, self.repetition_num_list, self.confirmation_list])
		self._getitems_keywords.update({'channel_name' : (lambda : (self.channel_list.selected.name if self.channel_list.selected and self.channel_list.selected.name else _('Unknown'))),
																		'favorite_name' : (lambda : (self.favorite_list.selected.name if self.favorite_list.selected and self.favorite_list.selected.name else _('Unknown'))),
																		'record_name' : (lambda : self.record_name),
																		'date_1' : (lambda : self.date_1_list.selected.name),
																		'date_2' : (lambda : self.date_2_list.selected.name),
																		'date_3' : (lambda : self.date_3_list.selected.name),
																		'date_weekday' : self._get_weekday_from_date,
																		'start_hour' : (lambda : self.start_hour_list.selected.name),
																		'start_minute' : (lambda : self.start_minute_list.selected.name),
																		'stop_hour' : (lambda : self.stop_hour_list.selected.name),
																		'stop_minute' : (lambda : self.stop_minute_list.selected.name),
																		'repetition_type' : (lambda : self.repetition_type_list.selected.name),
																		'repetition_number' : (lambda : self.repetition_number_list.selected.name),
																		'confirmation_list' : (lambda : self.confirmation_list)})
		self._record_to_remove = None
		self.scheduled_record = None
		return None

	def show(self, *args, **kw):
		Menu.show(self, *args, **kw)
		if self.is_only_this_time():
			louie_send('frequency_only_this_time_on', sender=self)
		else:
			louie_send('frequency_only_this_time_off', sender=self)
		return None

	def is_only_this_time(self):
		return self.get_item_list('repetition_list')[0].selected_pos == 0

	def _get_weekday_from_date(self):
		date_list = self.date_list
		return day_dict[date(int(date_list[self.year_index].selected.name), int(date_list[self.month_index].selected.name), int(date_list[self.day_index].selected.name)).weekday()]

	def update_day_list(self):
		d_list = self.date_list[self.day_index]
		d = days_in_month(self.date_list[self.year_index].selected.val, self.date_list[self.month_index].selected.val)
		if d != len(d_list):
			self.date_list[self.day_index].set_items([IntegerItem(i, menu=self) for i in xrange(1, d + 1)], selected=min(d_list.selected_pos, d - 1))
			louie_send('date_%d' % (self.day_index + 1), sender=self, value=self.date_list[self.day_index].selected.name)
		return None

	def select_date(self, _date, stop=None):
		struct_t = localtime(_date)
		self.date_list[self.year_index].select(IntegerItem(struct_t[0]))
		self.date_list[self.month_index].select(IntegerItem(struct_t[1]))
		self.date_list[self.day_index].select(IntegerItem(struct_t[2]))
		louie_send('date_weekday', sender=self, value=self['date_weekday'])
		self.start_hour_list.select(IntegerItem(struct_t[3]))
		self.start_minute_list.select(IntegerItem(struct_t[4]))
		if stop:
			struct_t = localtime(stop)
			self.stop_hour_list.select(IntegerItem(struct_t[3]))
			self.stop_minute_list.select(IntegerItem(struct_t[4]))
		return None

	def select_channel(self, chan_info, current_favorite=None):
		favorite_list = [TVRootItem().get_acl(menu=self)]
		favorite_list.extend(TVRootItem().browse_favorites(self))
		self.favorite_list.set_items(favorite_list)
		if current_favorite is None:
			self.favorite_list.select(0, force_pos=True)
		else:
			self.favorite_list.select(current_favorite)
		chans = self.favorite_list.selected.browse()
		self.channel_list.set_items(chans)
		self.channel_list.select(chan_info)
		return None

	def _set_record(self, scheduled_record):
		self._record_to_remove = scheduled_record
		_wyrecord = WyRecord()
		self.record_name = scheduled_record.name
		self.select_date(scheduled_record.record.start_time, scheduled_record.record.stop_time)
		target_channel = TVRootItem().get_acl(self).get_channel_from_service_id(str(scheduled_record.record.service_id))
		for i in xrange(len(self.favorite_list)):
			if self.favorite_list[i]['serviceId'] == str(scheduled_record.record.service_id):
				target_channel, target_channel = None, self.favorite_list[i]
				break
		self.select_channel(target_channel)
		if isinstance(scheduled_record, PeriodicScheduledRecordItem):
			_rule = _wyrecord.scheduler.GetPeriodicRuleById(scheduled_record.record.periodicity_rule_id)
			self.repetition_type_list.select(Item(self.PERIODICITY[_rule.extern_rule_name][0], 'periodic', self))
			_num = (mktime(_rule.last_time.timetuple()) - _rule.recording_ref.start_time) / float(self.PERIODICITY[_rule.extern_rule_name][1] * 86400)
			self.repetition_number_list.select(IntegerItem(int(_num)))
		return None

	# Check that the user input is correct.
	# 
	# If a value is incorrect, send Louie signals to highlight the incorrect
	# fields, display a pop-up to inform the user and return False.
	# 
	# Otherwise, clear the input field highlights and return True.
	def _validate(self):
		all_fields = set(['date', 'start_time', 'end_date', 'end_time'])
		invalid_fields = set()
		error_message = None
		now = time()
		start_time, end_time = self.start_time, self.end_time
		if abs(end_time - start_time) > 21600:
			error_message = _('The recording cannot be longer than 6 hours.')
		if end_time < now:
			error_message = _('You are trying to record a program already over.')
			invalid_fields.add('end_time')
			if now - end_time >= 86400:
				invalid_fields.add('date')
		for field in all_fields.difference(invalid_fields):
			louie_send('%s_valid' % field, sender=self)
		if error_message is not None:
			for field in invalid_fields:
				louie_send('%s_invalid' % field, sender=self)
			error_title = _('Invalid data')
			MessageWindow(error_message, error_title, button=None).show(timeout=5)
			return False
		return True

	# Execute the actual recording scheduling.
	def _schedule_record(self, rec_name):
		_wyrecord = WyRecord()
		start_time, stop_time = self.start_time, self.end_time
		if self._record_to_remove:
			log.info('Deleting scheduled recording [%s] for replacement', self._record_to_remove)
			try:
				rule_id = self._record_to_remove.periodic_rule.id
				_wyrecord.scheduler.RemovePeriodicRecording(rule_id, delete_records=False)
			except AttributeError:
				try:
					_wyrecord.scheduler.DeleteRecording(self._record_to_remove.record.id)
				except SchedulerRecordingRunningError:
					error_title = _('Impossible to cancel recording')
					message = _('This recording has already started.')
					MessageWindow(message, error_title, button=None).show(timeout=5)
			self._record_to_remove = None
		try:
			self.scheduled_record = _wyrecord.scheduler.ScheduleRecording(int(self.channel_list.selected['serviceId']), int(start_time), int(stop_time), rec_name, favorite=self['favorite_name'])
			periodicity_type = self.repetition_type_list.selected
			periodicity_number = self.repetition_number_list.selected.val
			rule_id = None
			if periodicity_type.key != 'none' and periodicity_number > 1:
				rule_id = _wyrecord.scheduler.createPeriodicityRule(periodicity_type.key)
				end_date = datetime.fromtimestamp(start_time) + timedelta(days=periodicity_type.val[1] * periodicity_number - 1)
				res = _wyrecord.scheduler.GeneratePeriodicRecording(self.scheduled_record.id, rule_id, end_date)
		except SchedulerConflictWithInstantRecordError, e:
			conflicting_rec = e.conflict.getAllRecInConflict()[0]
			message_pattern = _('An instant recording on %(channel)s will be stopped when this recording starts.')
			message = message_pattern % {'name': conflicting_rec.name, 'start_time': seconds_to_hhmm(conflicting_rec.start_time), 'channel': conflicting_rec.service_name}
			title = _('Conflict with an instant recording')
			MessageWindow(message, title, button=None).show(timeout=5)
			self.scheduled_record = e.conflict.rec
		except SchedulerConflictError, e:
			conflicting_rec = e.conflict.getAllRecInConflict()[0]
			message_pattern = _('The recording you are attempting to schedule conflicts with "%(name)s", starting at %(start_time)s on %(channel)s.')
			message = message_pattern % {'name': conflicting_rec.name, 'start_time': seconds_to_hhmm(conflicting_rec.start_time), 'channel': conflicting_rec.service_name}
			error_title = _('Recording scheduler error')
			MessageWindow(message, error_title, button=None).show(timeout=5)
			return None
		except SchedulerError, e:
			log.error("Can't start recording due to %s", e)
			message = 'Unable to schedule your recording. Sorry.'
			error_title = _('Recording scheduler error')
			MessageWindow(message, error_title, button=None).show(timeout=5)
			return None
		kbd = KeyboardWindow(title=_('Scheduled recording name'), text=rec_name, confirm_action=self._rename_record)
		def kbd_hide():
			kbd.hide()
			if rule_id:
				_wyrecord.scheduler.RemovePeriodicRecording(rule_id, delete_records=False)
			else:
				try:
					_wyrecord.scheduler.DeleteRecording(self.scheduled_record.id)
				except SchedulerRecordingRunningError:
					error_title = _('Impossible to cancel recording')
					message = _('This recording has already started.')
					MessageWindow(message, error_title, button=None).show(timeout=5)
					return None
			self.scheduled_record = None
			return None
		kbd.action_buttons[4].connect(kbd_hide)
		kbd.show()
		return None

	def _rename_record(self, kbd):
		WyRecord().scheduler.UpdateRecordingName(self.scheduled_record.id, kbd.text)
		kbd.hide()
		pygui_globs['menustack'].back_one_menu()
		return None

	# Validate the data, prompt the user for a name and schedule the record.
	def _confirm(self):
		if not self._validate():
			return None
		loader = LoadingWindow()
		loader.show()
		name_pattern = _('%(date)s %(channel)s %(start_time)s - %(end_time)s')
		if self._record_to_remove:
			old_rec = self._record_to_remove.record
			old_values = {'channel': old_rec.service_name, 'date': strftime('%Y/%m/%d', localtime(old_rec.start_time)), 'start_time': seconds_to_hhmm(old_rec.start_time), 'end_time': seconds_to_hhmm(old_rec.stop_time)}
			computed_old_name = name_pattern % old_values
		if self._record_to_remove and computed_old_name != self._record_to_remove.name:
			scheduled_name = self._record_to_remove.name
		else:
			values = {'channel': self.channel_list.selected.name, 'date': strftime('%Y/%m/%d', localtime(self.start_time)), 'start_time': seconds_to_hhmm(self.start_time), 'end_time': seconds_to_hhmm(self.end_time)}
			scheduled_name = name_pattern % values
		self._schedule_record(scheduled_name)
		loader.hide()
		return None

	# Close the window, discarding any and all changes.
	def cancel(self):
		pygui_globs['menustack'].back_one_menu()
		return None

	def update(self, _list):
		up_str = _list.list_name[:-5]
		louie_send(up_str, sender=self, value=self[up_str])
		if _list.list_name in ('date_1_list', 'date_2_list', 'date_3_list'):
			louie_send('date_weekday', sender=self, value=self['date_weekday'])
		if _list.name in [_('Month'), _('Year')]:
			self.update_day_list()
		if _list.name == _('Favorites'):
			items = _list.selected.browse()
			current_channel = self.channel_list.selected
			try:
				self.channel_list.set_items(items, current_channel)
			except ValueError:
				self.channel_list.set_items(items, 0)
				louie_send('channel_name', sender=self, value=self['channel_name'])
		if _list.list_name == 'repetition_type_list':
			if self.is_only_this_time():
				louie_send('frequency_only_this_time_on', sender=self)
			else:
				louie_send('frequency_only_this_time_off', sender=self)
		return None

	# Return the currently selected start time as a timestamp.
	def _get_start_time(self):
		dt = datetime(self.date_list[self.year_index].selected.val, self.date_list[self.month_index].selected.val, self.date_list[self.day_index].selected.val, self.start_hour_list.selected.val, self.start_minute_list.selected.val)
		return datetime_to_timestamp(dt)

	start_time = property(_get_start_time)
	del _get_start_time
	
	# Return the currently-selected end time as a timestamp.
	# 
	# Note that if the selected end time is lower than the selected
	# start time, the end timestamp is on the following day,
	# i.e. selecting 10:00 -> 08:00 will record from 10 AM today to
	# 8 AM tomorrow.
	def _get_end_time(self):
		if self.stop_hour_list.selected.val < self.start_hour_list.selected.val:
			end_time = self.start_time + 3600 * (23 - self.start_hour_list.selected.val + self.stop_hour_list.selected.val) + 60 * (60 - self.start_minute_list.selected.val + self.stop_minute_list.selected.val)
		elif self.stop_hour_list.selected.val == self.start_hour_list.selected.val and self.stop_minute_list.selected.val < self.start_minute_list.selected.val:
			end_time = self.start_time + 86400 - 60 * (self.start_minute_list.selected.val - self.stop_minute_list.selected.val)
		else:
			dt = datetime(self.date_list[self.year_index].selected.val, self.date_list[self.month_index].selected.val, self.date_list[self.day_index].selected.val, self.stop_hour_list.selected.val, self.stop_minute_list.selected.val)
			end_time = datetime_to_timestamp(dt)
		return end_time

	end_time = property(_get_end_time)
	del _get_end_time
