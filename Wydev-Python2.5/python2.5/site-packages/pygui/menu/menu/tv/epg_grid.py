# -*- coding: utf-8 -*- 
#
# Description:
#
# EPG Grid Menu Definition
#
#
#
# Changes:
#
# 2012-04-05
# Initial Commit
#
#
# Copyright 2010-2014, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

from __future__ import absolute_import

import datetime
from peewee.messages import send as louie_send
from time import time, strftime, localtime
from peewee.debug import GET_LOGGER
from peewee.formatters import ellipsize, seconds_to_hhmm, seconds_to_hhmm_utc
from peewee.notifier import Task
from pygui.eventmanager.menus import EpgGridEventHandler
from pygui.facilities import timeslices as ts
from pygui.facilities.codemapping import day_dict, month_dict
from pygui.facilities.l10n import get_date_format
from pygui.item.mediaitem import Playlist
from pygui.menu import selective_gui_updater
from pygui.window import MessageWindow
from wyrecord import WyRecord
from wyrecord.exceptions import SchedulerConflictWithInstantRecordError, SchedulerConflictError, SchedulerError, SchedulerRecordingRunningError
from wyrecord.recording import RECORDING_STATUS_UNKNOWN, RECORDING_STATUS_COMPLETED
from pygui.menu.menu.tv.epg_extras import EpgControlWindowMenu, EpgInfoBanner
from pygui.menu.menu.core import Menu

log = GET_LOGGER(__name__)
AUTO_REFRESH_DELAY = 30
EPG_RECORDING_NAME_PATTERN = _('%(date)s %(channel)s %(title)s')



# Model class for the main EPG grid.
class EpgGridMenu(Menu):

	def __init__(self, player, channel_list, universe='tv', selected_chan=0):
		Menu.__init__(self, name='EPG Grid', choices=[], type='epg_grid', universe=universe)
		self.eventhandler = EpgGridEventHandler(self)
		self.player = player
		self.start_time, self.end_time = ts.current_timeslice()
		self.lower_limit = ts.get_epg_day(self.start_time)
		self.upper_limit = self.start_time + datetime.timedelta(days=7)
		self.displayed_programs = []
		self.selected_program = 0
		self._summarized_info = dict()
		self._getitems_keywords.update({'clock': (lambda : None), 'channel_list': (lambda : self.get_item_list('channel_list')), 'channel_list_name': (lambda : self.channel_list.name), 'info_press': (lambda : self._summarized_info['info_press']), 'info_icon': (lambda : self._summarized_info['info_icon']), 'selected_program_name': (lambda : self._summarized_info['program_name']), 'selected_program_duration': (lambda : self._summarized_info['program_duration']), 'selected_program_date': (lambda : self._summarized_info['program_date']), 'selected_program_start_time': (lambda : self._summarized_info['program_start']), 'selected_program_maturity_rating': (lambda : self._summarized_info['program_maturity_rating']), 'selected_program_duration_caption': (lambda : _('Duration')), 'epg_control_window_caption': (lambda : _('EPG Control Window'))})
		self.update_channels_timer = Task(self.update_channels)
		self.refresh_timer = Task(self.refresh)
		self.set_channel_list(channel_list)
		self.select(selected_chan, 'main_list')
		self.select(selected_chan, 'channel_list')
		self.update_programs()
		now = time()
		for i, prog in enumerate(self.displayed_programs):
			if prog.start_time <= now and prog.end_time >= now:
				self.selected_program = i
				self.select_program(0)
				break
		self.tick_timer = Task(self.tick_callback)
		self.tick_timer.start(5, loop=True)
		self.refresh_timer.start(AUTO_REFRESH_DELAY, loop=True, consider_idle=True)
		return None

	# Display the EPG control window.
	def display_control_window(self):
		EpgControlWindowMenu(self).show()
		return None

	# Display the full program information banner on the currently selected program.
	def display_info_banner(self):
		program = self.displayed_programs[self.selected_program]
		if 'dummy' not in program['class']:
			EpgInfoBanner(program).show()
		return None

	# Zap to the currently selected program if it is being broadcast.
	# Returns True on success.
	def zap_to_selected(self):
		if self.player.can_zap():
			channel = self.get_item_list('main_list').selected
			self.hide()
			channel.execute()
			return True
		else:
			title = _("Can't change channels")
			message = _('A recording is in progress. Stop it before zapping.')
			MessageWindow(message, title, button=None).show(timeout=5)
		return None

	# Schedule the recording of the currently selected program.
	def record_selected(self):
		program = self.displayed_programs[self.selected_program]
		now = int(time())
		if program.end_time > now:
			start_time = max(now, program.start_time)
			end_time = min(program.end_time, start_time + 21600)
			channel = self['channel_list'].selected
			chan_id = int(channel['serviceId'])
			favorite_name = self.channel_list.name
			values = {'channel': self['channel_list'].selected.name, 'title': program.name, 'date': strftime('%Y/%m/%d', localtime(start_time)), 'start_time': seconds_to_hhmm(start_time), 'end_time': seconds_to_hhmm(end_time)}
			record_name = EPG_RECORDING_NAME_PATTERN % values
			try:
				WyRecord().scheduler.ScheduleRecording(chan_id, start_time, end_time, record_name, program_id=program.id, favorite=favorite_name)
				louie_send('update_record')
			except SchedulerConflictWithInstantRecordError, e:
				louie_send('update_record', sender=None)
				conflicting_rec = e.conflict.getAllRecInConflict()[0]
				message_pattern = _('An instant recording on %(channel)s will be stopped when this recording starts.')
				message = message_pattern % {'name': ellipsize(conflicting_rec.name, 40), 'start_time': seconds_to_hhmm(conflicting_rec.start_time), 'channel': conflicting_rec.service_name}
				title = _('Conflict with an instant recording')
				MessageWindow(message, title, button=None).show(timeout=5)
			except SchedulerConflictError, e:
				conflicting_rec = e.conflict.getAllRecInConflict()[0]
				message_pattern = _('The recording you are attempting to schedule conflicts with "%(name)s", starting at %(start_time)s on %(channel)s.')
				message = message_pattern % {'name': ellipsize(conflicting_rec.name, 40), 'start_time': seconds_to_hhmm(conflicting_rec.start_time), 'channel': conflicting_rec.service_name}
				title = _('Recording scheduler error')
				MessageWindow(message, title, button=None).show(timeout=5)
			except SchedulerError, e:
				log.error("Can't start recording due to %s", e)
				title = _('Recording scheduler error')
				message = 'Unable to schedule your recording. Sorry.'
				MessageWindow(message, title, button=None).show(timeout=5)
		else:
			message = _('The program is over. You cannot record it.')
			title = _('Program already over')
			win = MessageWindow(message, title, button=None)
			win.show(timeout=5)
		return None

	# Cancel the scheduled recording of the selected program
	# (if it *is* scheduled for recording at all).
	# 
	# Note that a record that has already started may not be canceled
	# from the EPG grid (only from the player). In this case, a
	# SchedulerRecordingRunningError is catched.
	def cancel_record_selected(self):
		program = self.displayed_programs[self.selected_program]
		rec_id = program.recording_id
		if rec_id:
			log.info('Canceling recording for %s', program)
			try:
				WyRecord().scheduler.DeleteRecording(rec_id)
				louie_send('update_record')
			except SchedulerRecordingRunningError:
				error_title = _('Impossible to cancel recording')
				message = _('This recording has already started. To stop it, close the EPG grid and press Stop.')
				MessageWindow(message, error_title, button=None).show(timeout=5)
		else:
			self._error_spawner()
		return None

	# If the selected program isn't scheduled for recording yet,
	# schedule it for recording. Otherwise, cancel the record.
	# 
	# If the selected program is a dummy ("EPG not available"), this
	# action does nothing.
	def action_record(self):
		program = self.displayed_programs[self.selected_program]
		if 'dummy' not in program['class']:
			if program.recording_status in (RECORDING_STATUS_UNKNOWN, RECORDING_STATUS_COMPLETED):
				self.record_selected()
			else:
				self.cancel_record_selected()
		else:
			self._error_spawner()
		return None

	# Move the selection cursor right by event steps.
	def select_channel(self, event):
		self.select(event, 'main_list')
		self.update_channels_timer.start(1)
		self.refresh_timer.start(AUTO_REFRESH_DELAY, loop=True, consider_idle=True)
		return None

	# Move the selection cursor down by event steps.
	# Trigger a time slice change if needed.
	# 
	# This method will not do anything if a time slice change that goes
	# outside the grid's limits (lower = previous midnight, upper = +7 days)
	# would be triggered.
	@selective_gui_updater('info_press', 'selected_program_name', 'selected_program_maturity_rating', 'selected_program_duration', 'selected_program_date', 'selected_program_start_time')
	def select_program(self, event):
		new_selected = self.selected_program + event
		if new_selected < 0 and self.lower_limit < self.start_time:
			self.select_time_slice(-1)
			new_selected = len(self.displayed_programs) - 1
		elif new_selected >= len(self.displayed_programs) and self.end_time < self.upper_limit:
			self.select_time_slice(0)
			new_selected = 0
		elif 0 <= new_selected < len(self.displayed_programs):
			self.selected_program = new_selected
			louie_send('set_selected_program', value=new_selected)
		prog = self.displayed_programs[self.selected_program]
		maturity_key = prog['maturityRating']
		if maturity_key is not None:
			maturity = 'maturityrating_%i.png' % int(maturity_key)
		else:
			maturity = 'maturityrating_unknown.png'
		self._summarized_info = {'program_name': prog.name, 'program_duration': (seconds_to_hhmm_utc(prog.duration) if 'dummy' not in prog['class'] else ''), 'program_start': seconds_to_hhmm(prog.start_time), 'program_date': self.get_selected_program_date(), 'program_maturity_rating': maturity, 'info_press': (_('info') if 'dummy' not in prog['class'] else ''), 'info_icon': self.get_info_icon()}
		self.refresh_timer.start(AUTO_REFRESH_DELAY, loop=True, consider_idle=True)
		return None

	def get_info_icon(self):
		prog = self.displayed_programs[self.selected_program]
		info_key = prog['class']
		if 'dummy' not in info_key:
			louie_send('info_icon', sender=self, value='info_icon.png')
		else:
			louie_send('info_icon', sender=self, value='none.png')
		return None

	def tick_callback(self):
		louie_send('clock', sender=self)
		louie_send('clock', value=time())
		return None

	# Kill the timer before going back.
	def stop(self):
		self.tick_timer.stop()
		self.refresh_timer.stop()
		Menu.stop(self)
		return None

	def _get_start_ts(self):
		return ts.datetime_to_timestamp(self.start_time)

	def _set_start_ts(self, value):
		self.start_time = datetime.datetime.fromtimestamp(value)
		return None

	start_ts = property(_get_start_ts, _set_start_ts)
	del _get_start_ts
	del _set_start_ts

	def _get_end_ts(self):
		return ts.datetime_to_timestamp(self.end_time)

	def _set_end_ts(self, value):
		self.end_time = datetime.datetime.fromtimestamp(value)
		return None

	end_ts = property(_get_end_ts, _set_end_ts)
	del _get_end_ts
	del _set_end_ts

	# Set the channel list displayed in the grid.
	@selective_gui_updater('channel_list_name')
	def set_channel_list(self, channel_list):
		self.channel_list = channel_list
		selected_channel = self['main_list'].selected
		try:
			items = channel_list.browse(include_aux=False)
		except TypeError:
			items = channel_list.browse()
		if selected_channel is None:
			pos = 0
		elif isinstance(channel_list, Playlist):
			try:
				pos = items.index(selected_channel)
			except ValueError:
				pos = 0
		else:
			pos = int(selected_channel['logical_channel_number']) - 1
		self.set_items(items, 'main_list', pos)
		self.set_items(items, 'channel_list', pos)
		self.select_channel(0)
		return None

	# Set the boundaries of the EPG grid and refresh it.
	def set_boundaries(self, start_time, end_time):
		self.start_time = start_time
		self.end_time = end_time
		louie_send('set_boundaries', start_ts=self.start_ts, end_ts=self.end_ts)
		self.update_programs()
		return None

	# Move to the [value]th next/previous time slice.
	def select_time_slice(self, value):
		start_time, end_time = ts.timeslice_boundaries(self.start_time, value)
		if not(self.lower_limit <= start_time <= self.upper_limit):
			return None
		self.set_boundaries(start_time, end_time)
		if value < 0:
			self.selected_program = len(self.displayed_programs) - 1
		elif value > 0:
			self.selected_program = 0
		self.select_program(0)
		return None

	# Move to the [value]th next/previous visible time slice.
	# A visible time slice is a time slice that has a name of its own
	# when it appears in the control window.
	# 
	# See pygui.facilities.timeslices for more information.
	def select_visible_time_slice(self, value):
		slice_count = ts.distance_to_visible_slice(self.start_time, value)
		self.select_time_slice(slice_count)
		return None

	# Update the channels' contents in the main list.
	def update_channels(self):
		pos = self.get_item_list('main_list').selected_pos
		self.get_item_list('channel_list').select(pos, force_pos=True)
		self.update_programs()
		if self.selected_program < 0:
			self.selected_program = 0
		elif self.selected_program >= len(self.displayed_programs):
			self.selected_program = len(self.displayed_programs) - 1
		self.select_current_program()
		return None

	# Fetch info about the currently selected channel's program.
	def update_programs(self):
		selected_channel = self.get_item_list('channel_list').selected
		self.displayed_programs[:] = selected_channel.browse(self.start_ts, self.end_ts, limit=10, pad=True, focus=time())
		return None

	# Refresh the contents of the grid.
	def refresh(self):
		self.select_time_slice(0)
		return None

	# Select the currently-airing program, if possible.
	# Otherwise, do nothing.
	def select_current_program(self):
		now = time()
		for i, prog in enumerate(self.displayed_programs):
			if prog.start_time <= now < prog.end_time:
				self.selected_program = i
				break
		self.select_program(0)
		return None

	def get_selected_program_date(self):
		if self.displayed_programs:
			time_tuple = localtime(self.displayed_programs[self.selected_program].start_time)
			wday = day_dict[time_tuple[6]]
			month = month_dict[time_tuple[1]]
			day = time_tuple[2]
			return u'%s %s %s' % (wday, day, month)
		return ''
