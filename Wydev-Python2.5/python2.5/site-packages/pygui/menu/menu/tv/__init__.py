# -*- coding: utf-8 -*- 
#
# Description:
#
# TV Menu Entry Point and Scheduled Record Navigator Definitons
#
#
#
# Changes:
#
# 2012-04-04
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

from __future__ import absolute_import

from peewee.debug import GET_LOGGER
from peewee.formatters import seconds_to_hhmm
from pygui.eventmanager.menus import ScheduledRecordMenuEventHandler
from pygui.facilities.timeslices import seconds_to_long_date
from pygui.shared import pygui_globs
from pygui.item.scheduledrecord import ScheduledRecordRootItem, PeriodicScheduledRecordItem
from pygui.menu import gui_updater, UNIVERSE_NAME_DICT
from pygui.menu.menu.core import Menu
from pygui.menu.menu.info import ScheduledRecordInfoMenu
from pygui.window import LoadingWindow

log = GET_LOGGER(__name__)



class ScheduledRecordNavigator(Menu):

	groupeable = True
	toggleable = False

	def __init__(self, name=_('Scheduled recordings'), type='scheduled_navigator'):
		self.eventhandler = ScheduledRecordMenuEventHandler(self)
		Menu.__init__(self, name=name, choices=ScheduledRecordRootItem(self).browse(), type=type)
		self._program = None
		self._getitems_keywords.update(dict(universe_name=(lambda : UNIVERSE_NAME_DICT[self.type]),
																				parent_icon_name=(lambda : 'parentfolder-%s.png' % self.type),
																				parent_item_name=(lambda : self.name),
																				record_description=self.get_record_description,
																				record_date=(lambda : (seconds_to_long_date(self.selected.record.start_time) if self.selected else '')),
																				record_start_time=(lambda : (seconds_to_hhmm(self.selected.record.start_time) if self.selected else '')),
																				record_stop_time=(lambda : (seconds_to_hhmm(self.selected.record.stop_time) if self.selected else '')),
																				channel_name=(lambda : (self.selected.record.service_name if self.selected else '')),
																				repetition_type=(lambda : (_(self.selected.periodic_rule.extern_rule_name.capitalize()) if (isinstance(self.selected, PeriodicScheduledRecordItem) and _(self.selected.periodic_rule.extern_rule_name.capitalize())) else '')),
																				repetition_number=(lambda : (self.selected.periodic_rule.limit if (isinstance(self.selected, PeriodicScheduledRecordItem) and self.selected.periodic_rule.limit) else ''))))
		return None

	@gui_updater
	def reload_func(self):
		items = ScheduledRecordRootItem(self).browse()
		self.set_items(items)
		return None

	def modify_scheduled_record(self):
		loader = LoadingWindow()
		loader.show()
		from pygui.menu.menu.tv.scheduled_record import ScheduledRecordMenu
		menu = ScheduledRecordMenu()
		menu._set_record(self.selected)
		menu.show()
		loader.hide()
		return None

	# Display the information window for the selected record.
	def action_info(self):
		ScheduledRecordInfoMenu(self.selected).show()
		return None

	# Display the action menu.
	# Blatantly stolen from NavigatorEventHandler.
	def display_action_menu(self):
		sel = self.selected
		from pygui.menu.menu import ActionMenu
		parent = None
		if sel is None and self._history:
			parent = self._history[-1]['selected']
		else:
			parent = sel.parent
		context = dict(menu=self, selected=sel, parent=parent)
		s = ActionMenu(context, universe=self.universe)
		s.show()
		return None

	@gui_updater
	def select(self, item, list_name='main_list'):
		Menu.select(self, item, list_name=list_name)
		return None

	# Return the selected record's description.
	def get_record_description(self):
		if self.selected is None:
			return u''
		values = {'date': self['record_date'], 'start_time': self['record_start_time'], 'end_time': self['record_stop_time']}
		try:
			values['name'] = self.selected.period
			values['number'] = self.selected.remaining_count
			message_template = _('The %(date)s\nFrom %(start_time)s\nTo %(end_time)s\nrepeated %(name)s (%(number)s more remaining)')
		except AttributeError:
			message_template = _('The %(date)s\nFrom %(start_time)s\nTo %(end_time)s')
		return message_template % values
