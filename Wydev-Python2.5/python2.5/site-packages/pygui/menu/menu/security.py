# -*- coding: utf-8 -*- 
#
# Description:
#
# Security Menu Class Definition
#
#
#
# Changes:
#
# 2014-04-07
# Initial Commit
#
#
# Copyright 2010-2014, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.


from __future__ import absolute_import

from pygui.menu.menu.core import Menu
from pygui.item.core import Item
from pygui.eventmanager.menus import SecretCodeMenuEventHandler
from pygui.item.parameters.generalsetup.securitysetup import SecretCodeUserConfigSetupItem, SecretCodeCheckConfigSetupItem
from pygui.window import KeyboardWindow
from pygui.config import user_config
from pygui.shared import pygui_globs
from pygui.window import TextWindow
from peewee.notifier import Task


# This Menu permits to check that entered secret code (by user) is the
# same as the config's one.
# The user has 3 tries to enter the good code
class SecretCodeCheckMenu(Menu):

	def __init__(self, name, action=(lambda : None), cancel_action=(lambda : None), eventhandler=None, type='secret_code', **kw):
		Menu.__init__(self, name, choices=[], type=type, universe='parameters', **kw)
		if not eventhandler:
			self.eventhandler = SecretCodeMenuEventHandler(self)
		else:
			self.eventhandler = eventhandler
		self.action = action
		self.cancel_action = cancel_action
		self.available_choices = ['options_list', 'main_list', 'options2_list', 'options3_list', 'options4_list']
		self.main_items = [SecretCodeCheckConfigSetupItem(name='SecretCode', menu=self, domain='security', key='secretcode')]
		self.prompt_items = [Item(name=_('Enter your current code'), type_='unknown')]
		self.message_window = TextWindow(_('Wrong PIN code'))
		for c in self.available_choices:
			self._getitems_keywords[c] = (lambda list_name=c : self.get_item_list(list_name))
		self._browse_items()
		self.countdown = range(1, 3)
		return None

	def _browse_items(self, rank=0):
		items = self.main_items[rank].browse()
		prompt = self.prompt_items[rank]
		self.set_items([prompt], 'options_list')
		for browsed, list_name in zip(items, self.available_choices[1:]):
			self.set_items(browsed.browse(), list_name)
			self.get_item_list(list_name).cyclic = True
		return None

	def focus_previous(self):
		if self.active_list == 'main_list':
			self.hide()
		else:
			Menu.focus_previous(self)
		return None

	def _set_options_list(self, selection, keep_selection=False):
		if selection.check_entered_value():
			self.hide()
			self.action()
		else:
			try:
				remain = self.countdown.pop()
				self.message_window.show()
				Task(self.message_window.hide).start(2)
			except IndexError:
				self.cancel()
			else:
				self._browse_items()
				self.active_list = 'main_list'
		return None

	def cancel(self):
		self.cancel_action()
		self.hide()
		return None


class FullScreenSecretCodeCheckMenu(SecretCodeCheckMenu):

	def __init__(self, name, action=(lambda : None), cancel_action=(lambda : None), eventhandler=None, type='full_screen_secret_code', **kw):
		SecretCodeCheckMenu.__init__(self, name, action, cancel_action, eventhandler, type, **kw)
		return None


class QuestionAnswerCheckLauncher(object):

	def __init__(self, action, *args, **kw):
		self.action = action
		self.args = args
		self.kw = kw
		self.countdown = range(1, 3)
		def check_answer(win):
			response = win.text
			if user_config['security']['answer'] == response:
				self.action(*self.args, **self.kw)
				win.hide()
			else:
				try:
					self.countdown.pop()
					win.text = ''
				except IndexError:
					win.hide()
			return None
		kbd = KeyboardWindow(title=user_config['security']['question'], confirm_action=check_answer)
		kbd.show()
		return None


# This class sets up the algorithm for modify the Q/A in setup :
#     - check the current answer (if 'check' parameters is True)
#     - ask the new question
#     - ask the new answer
#     - then if no cancel, record the new question and the new answer
class QuestionAnswerSetupParametersLauncher(object):

	def __init__(self, check=True, end_action=None, end_action_args=(), end_action_kw={}):
		self.countdown = range(1, 3)
		self._new_question = None
		self._new_response = None
		self.end_action = end_action
		self.end_action_args = end_action_args
		self.end_action_kw = end_action_kw
		def set_new_answer(win):
			self._new_response = win.text
			win.hide()
			self._set_new_values()
			return None
		def set_new_question(win):
			self._new_question = win.text
			win.hide()
			kbd = KeyboardWindow(title=_('Enter your answer'), confirm_action=set_new_answer)
			self._connect_cancel_button(kbd)
			kbd.show()
			return None
		def check_answer(win):
			response = win.text
			if user_config['security']['answer'] == response:
				win.hide()
				kbd = KeyboardWindow(title=_('Enter your question'), confirm_action=set_new_question)
				self._connect_cancel_button(kbd)
				kbd.show()
			else:
				win.text = ''
				try:
					self.countdown.pop()
				except IndexError:
					win.hide()
			return None
		if check:
			kbd = KeyboardWindow(title=user_config['security']['question'], confirm_action=check_answer)
		else:
			kbd = KeyboardWindow(title=_('Enter your question.  \nIt will be asked if you lose your secret code'), confirm_action=set_new_question)
			kbd.type = 'bigtitle_keyboard'
		self._connect_cancel_button(kbd)
		kbd.show()
		return None

	# Set new values in config
	# This is done only when the whole process is achieved (so if user cancels
	# just after entering the new question and has not entered the new answer,
	# nothing is recorded
	def _set_new_values(self):
		_question = self._new_question
		_response = self._new_response
		user_config['security']['question'] = _question
		user_config['security']['answer'] = _response
		user_config.save()
		if self.end_action is not None:
			self.end_action(*self.end_action_args, **self.end_action_kw)
		return None

	@staticmethod
	def _on_cancel_firstboot(self):
		m = pygui_globs['menustack'].is_on_firstboot
		if m:
			m.back_previous()
		return None
	
	@staticmethod
	def _connect_cancel_button(self):
		for but in kbd.action_buttons:
			if but.name == _('Cancel'):
				but.connect(QuestionAnswerSetupParametersLauncher._on_cancel_firstboot)
		return None
