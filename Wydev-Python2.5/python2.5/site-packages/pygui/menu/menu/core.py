# -*- coding: utf-8 -*- 
#
# Description:
#
# Core Menu Class Definition
#
#
#
# Changes:
#
# 2011-11-12
# Initial Commit
#
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.


from __future__ import absolute_import

from peewee.debug import GET_LOGGER, PRINT_EXCEPTION
from peewee.messages import send as louie_send
from peewee.notifier import Task
from pygui.config import user_config, HMI_BASE
from pygui.eventmanager.menus import MenuEventHandler
from pygui.facilities.l10n import omnicode
from pygui.item.containers import ItemList
from pygui.shared import pygui_globs

log = GET_LOGGER(__name__)
logselected = None



class UDPSender(object):

	def __init__(self, host='192.168.1.10', port=2345):
		self.addr = (host, port)
		self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
		return None

	def write(self, msg):
		self.sock.sendto(msg, self.addr)
		return None

	def flush(self):
		return None



# Base class for Menu application.
#
# A Menu is a fullscreen application, managed in a stack of Menus.
# Events are send to the upper menu. The interface is described with an XML file and the controler is simply a class inheriting from Menu.
# This class must have an eventhandler acting on the controler.
# Each menu has at least one list of items ('main', the default), plus an arbitrary number others (item_list)
#  Ex : item_list 'main_list' contains Item1, Item2
#  	    item_list 'preview_list' contains ItemList1
#  	    These items can be acceded via 'get_item_list(list_name)', for all available list_name.
#  	    Only one item_list can be active (e.g. the focus on screen can be set on a single item_list at a time)
#  	    Items can be selected, to call methods on it for ex.
#  	    To change the selected item, you must use 'select(item, item_list)'. It is not allowed to change the selected item or the internal choices directly.
#  	    It is obviously possible to add new Items to the Menu.
#  	    For this, you must use set_items(items, item_list)
class Menu(object):

	_active_list = 'main_list'
	toggleable = False
	groupeable = False
	_grouped_menu = 0
	hold = False
	show_help_banner = True

	def _get_active_list(self):
		return self._active_list

	def _set_active_list(self, val):
		dc = self._active_list
		if dc != val:
			louie_send('on_%s_blur' % dc, self)
			self._active_list = val
			louie_send('on_%s_focus' % val, self)
			self.choices.advertise()
		return None

	active_list = property(_get_active_list, _set_active_list)
	del _get_active_list
	del _set_active_list

	# Set the focus on the next item_list available in available_choices,
	# if this item_list contains some items. Return True in this case
	# Return False if we are already at the end of available_choices,
	# or if no items are in the new item_list
	def focus_next(self):
		dc = self.active_list
		if dc != self.available_choices[-1]:
			idx = self.available_choices.index(dc)
			new_choice = self.available_choices[idx + 1]
			new_item_list = self.get_item_list(new_choice)
			if new_item_list:
				self.active_list = new_choice
				return True
		return False

	# Set the focus on the previous item_list available in available_choices,
	# if this item_list contains some items. Return True in this case
	# Return False if we are already at the begining of available_choices,
	# or if no items are in the new item_list
	def focus_previous(self):
		dc = self.active_list
		if dc != self.available_choices[0]:
			idx = self.available_choices.index(dc)
			new_choice = self.available_choices[idx - 1]
			new_item_list = self.get_item_list(new_choice)
			if new_item_list:
				self.active_list = new_choice
				return True
		return False

	# Set the basic attributes to Menu
	# Parameters :
	#  * name                   : menu name
	#  * choices (optional)     : list of items that will be placed in the main_list
	#  * type (optional)        : menu type (string)
	#  * universe (optional)    : universe where the menu is located (ex: 'tv', 'parameters', ...)
	def __init__(self, name, choices=None, type='undefined', universe=None, timeout=None, parent=None, zone=None):
		self.name = name
		self.type = type
		self.universe = universe
		self.tasks = {'show_help': Task(self._show_help), 'hide_help': Task(self._hide_help), 'error_timeout': Task(self._error_canceler)}
		if not hasattr(self, 'zone'):
			self.zone = zone
		self.item_lists_dict = {}
		if choices is None:
			choices = []
		self.set_items(choices, self.active_list)
		self.available_choices = [self.active_list]
		self.item = None
		self._getitems_keywords = dict(menu_name=(lambda : self.name), item_name=self._get_item_name, main_list=(lambda : self.get_item_list('main_list')), menu_type_name=(lambda : self.type), parent_item_name=self._get_parent_item_name)
		if not hasattr(self, 'eventhandler'):
			self.eventhandler = MenuEventHandler(self)
		self.children = []
		self.parent = parent
		if timeout is not None:
			self._autohide_timeout = Task(self._autohide)
			self._autohide_timeout.delay = timeout
			self._autohide_timeout.ival = timeout
		else:
			self._autohide_timeout = None
		return None

	# Show the "unauthorized operation" pictogram.
	# It will auto-disappear after HMI_BASE["error_signal_delay"] seconds.
	def _error_spawner(self, prefix=None):
		error_timeout = self.tasks['error_timeout']
		if not error_timeout.running:
			txt = 'error_signal'
			if prefix is not None:
				txt = prefix + '_' + txt
			louie_send(txt, sender=self)
		error_timeout.start(HMI_BASE['error_signal_delay'])
		return None

	# Hide the "unauthorized operation" pictogram.
	def _error_canceler(self):
		louie_send('end_error_signal', sender=self)
		return None

	def __repr__(self):
		return '<%s::%s @%x>' % (self.__class__.__name__, self.type, id(self))

	def _get_item_name(self):
		sel = self.selected
		if sel:
			return sel.name
		return ''

	def _get_parent_item_name(self):
		item = self.item
		if item and item.type != 'main':
			return item.name
		return u''

	# Reload the menu. Feel free to provide your own implementation.
	def reload_func(self):
		self.show_help()
		return None

	# Flush the menu (delete all items), then set items contained in choices,
	# and name, type and universe specified
	# Parameters (same as __init__) :
	#  * name (optional)     : new name for the menu
	#  * choices (optional)  : new items for the menu main_list
	#  * type (optional)     : new type for the menu
	#  * universe (optional) : new universe for the menu
	def reset(self, name='', choices=None, type=None, universe=None):
		self.name = name
		self.item = None
		self.universe = universe
		self._active_list = 'main_list'
		if type is not None:
			self.type = type
		self.item_lists_dict = dict()
		if choices:
			self.set_items(choices, self.active_list)
		else:
			self.set_items([], self.active_list)
		return None

	def __getitem__(self, name):
		return self._getitems_keywords.get(name, (lambda : None))()

	def clear(self):
		if self not in pygui_globs['menustack']:
			for k, v in self.item_lists_dict.iteritems():
				self.item_lists_dict[k].set_items([])
				v.selected = False
				v.menu = None
				v._data = None
		return None

	def get_item_list(self, list_name=None):
		if not list_name:
			return self.item_lists_dict[self.active_list]
		return self.item_lists_dict[list_name]

	# Return a list of items related to 'list_name'. If 'list_name' is not registred, it is added
	def get_create_item_list(self, list_name):
		if list_name not in self.item_lists_dict:
			self.add_item_list(list_name)
		return self.get_item_list(list_name)

	# Helper to easily get the active choices
	choices = property(get_item_list)

	# Add an ItemList item_list to the menu and fill it with items
	# Parameters :
	#  * list_name        : name of the ItemList created
	#  * items (optional) : list of Items to fill item_list
	def add_item_list(self, list_name, items=None):
		if list_name is not None:
			if not items:
				self.item_lists_dict[list_name] = ItemList(self, [], list_name)
			else:
				self.item_lists_dict[list_name] = ItemList(self, items, list_name)
		return None

	def del_item_list(self, list_name):
		del self.item_lists_dict[list_name]
		return None

	# Set/replace the items in this menu.
	# If position is -1, no item is selected
	# Parameters :
	#  * items                : list of items that will be placed in ItemList 'list_name'
	#  * list_name (optional) : name of the ItemList where items will be set
	#  * position (optional)  : selected item's index (integer)
	#                           0 -> begining
	#                           -1 -> end
	def set_items(self, items, list_name='main_list', position=-1):
		item_list = self.get_create_item_list(list_name)
		item_list.set_items(items, position)
		if list_name == self._active_list:
			self._logselected()
		return None

	# Return the Item selected in 'active_list'
	def _get_selected(self):
		return self.get_item_list().selected

	# Set the Item refered to value in 'active_list'
	def _set_selected(self, value):
		self.get_item_list().select(value)
		return None

	selected = property(_get_selected, _set_selected)
	del _get_selected
	del _set_selected
	
	# Return the Item selected position in 'active_list'
	def _get_selected_pos(self):
		return self.get_item_list().selected_pos

	selected_pos = property(_get_selected_pos)
	del _get_selected_pos

	def _logselected(self):
		global logselected
		try:
			if logselected is not None:
				logselected.write('%s\n' % self.selected.name)
				logselected.flush()
			else:
				if 'logselected' in plugins:
					logselected = UDPSender()
		except:
			pass
		return None

	# Select item in list_name
	# Parameters :
	#  * item                 : refering to the wanted item
	#                           Can be an Item instance or an integer (1 means the next item in ItemList)
	#  * list_name (optional) : name of the ItemList where item is located.
	#                           If list_name isn't provided, the currently active list is used.
	#  * force_pos (optional) :  select the item at this position (an Item can also be passed, but discouraged)
	#  
	# Careful: the display engine uses Items' wymedia IDs or URIs to recognize which is selected.
	def select(self, item, list_name=None, force_pos=False):
		if self._autohide_timeout:
			log.debug('%s autohide postponed', self)
			self._autohide_timeout.start()
		if not list_name:
			val = self.get_item_list(self._active_list).select(item, force_pos)
		else:
			val = self.get_item_list(list_name).select(item, force_pos)
		if val is not False:
			self._logselected()
		return val

	# Delete item located in list_name
	# Parameters :
	#  * item : Item instance
	#  * list_name (optional) : name of the ItemList where item is located
	def delete_item(self, item, list_name=None):
		if not list_name:
			actual_list = self.get_item_list(self.active_list)
		else:
			actual_list = self.get_item_list(list_name)
		actual_list.remove(item)
		return None

	def toggle_menu(self):
		stack = pygui_globs['menustack']
		from pygui.menu.players.core import Player
		for menu in stack.menus_stack:
			if isinstance(menu, Player):
				menu.toggle_menu()
				break
		return None

	def _show_help(self):
		if user_config['base']['help_banner']:
			if not self.tasks['hide_help'].running:
				louie_send('show_help', self)
				self.hide_help()
		return None

	# Show the help banner. Once shown, it will auto-hide after HMI_BASE['helpbanner_duration'] seconds.
	def show_help(self):
		if self.show_help_banner:
			self.tasks['show_help'].start(0.5)
		return None

	def _hide_help(self):
		if user_config['base']['help_banner'] != 1:
			louie_send('hide_help', self)
		return None

	# Hide the help banner.
	def hide_help(self):
		if self.show_help_banner:
			self.tasks['hide_help'].start(HMI_BASE['helpbanner_duration'])
		return None

	def show(self, hide_previous_menu=True, timeout=None):
		pygui_globs['menustack'].push_menu(self, hide_previous_menu)
		self.show_help()
		if self.parent:
			try:
				self.parent.children.append(self)
			except Exception, e:
				log.error('Cannot append %s to %s.children', self, self.parent)
				PRINT_EXCEPTION(e)
		if timeout is not None:
			if self._autohide_timeout is None:
				self._autohide_timeout = Task(self._autohide)
			self._autohide_timeout.delay = timeout
			self._autohide_timeout.ival = timeout
		if self._autohide_timeout:
			self._autohide_timeout.start()
		return None

	def hide(self):
		if self._autohide_timeout:
			self._autohide_timeout.stop()
		if self.parent:
			try:
				self.parent.children.remove(self)
			except Exception, e:
				log.error('Error while removing %s from %s.children', self, self.parent)
				PRINT_EXCEPTION(e)
		stack = pygui_globs['menustack']
		try:
			stack.close_player(self)
		except ValueError:
			log.error("Can't hide %s !", self)
			PRINT_EXCEPTION()
		finally:
			self.hide_help()
		return None

	def _autohide(self):
		if not self.children:
			log.debug('%s no children: calling hide()', self)
			Task(self._autohide_timeout.stop).start(0)
			self.hide()
		else:
			log.debug('%s has children %s ! avoid autohide', self, self.children)
		return None

	# Called when the Menu is popped from the stack.
	# Among other things, stops all running Tasks within the Menu.
	# TODO Check that all Menu subclasses call this method in their own .stop().
	def stop(self):
		log.debug('%s stopping. Stopping tasks...', self)
		for t in self.tasks.itervalues():
			t.stop()
		return None

	# Called when Menu goes in background (toggle)
	def on_background(self):
		self.hide_help()
		return None

	# Called when Menu goes in foreground (toggle)
	def on_foreground(self):
		self.show_help()
		return None

	# Called when the next menu in the stack is grouped with self
	def _Menu__set_grouped_menu(self, value):
		self._grouped_menu = value
		if value:
			log.debug('Menu grouped with %r', self)
		else:
			log.debug('Menu ungrouped from %r', self)
		return None

	def _Menu__get_grouped_menu(self):
		return self._grouped_menu

	grouped_menu = property(_Menu__get_grouped_menu, _Menu__set_grouped_menu)
	del _Menu__set_grouped_menu
	del _Menu__get_grouped_menu

	def _find_list_view(self):
		al = self._active_list
		model_list = self.get_item_list(al)
		for engine in pygui_globs['menustack'].engines:
			for menu_widget in engine.menu_stack:
				for list_view in menu_widget.get_list_obj_by_name(al):
					if list_view.menu_list is model_list:
						return list_view
		return None



# Menu with a few extra features to handle an options_list
# Automatic update of the options_list:
#  - When browsing the main_list. (if the selected item has a browse() method, it's called to populate it)
#  - On focus changes.
class ContextMenu(Menu):

	groupeable = True

	def __init__(self, name, choices=[], type=None, universe=None, *args, **kw):
		Menu.__init__(self, name, choices, type, universe, *args, **kw)
		self.available_choices.append('options_list')
		self._getitems_keywords.update({'options_list': (lambda : self.get_item_list('options_list'))})
		return None

	# Refresh the options_list. If keep_selection is True, the selected item
	# in the options_list is kept. Otherwise, it's reset to -1.
	def _set_options_list(self, keep_selection=False):
		selection = self.get_item_list('main_list').selected
		try:
			browsed = selection.browse()
		except AttributeError:
			browsed = []
		if keep_selection:
			index = self.get_item_list('options_list').selected_pos
		else:
			index = -1
		self.set_items(browsed, list_name='options_list', position=index)
		if browsed:
			louie_send('not_empty_options', sender=self)
		else:
			louie_send('empty_options', sender=self)
		return None

	def select(self, item, list_name=None, force_pos=False):
		ret = Menu.select(self, item, list_name, force_pos)
		if ret and self.active_list == 'main_list':
			self._set_options_list()
		return ret

	def focus_next(self):
		ret = Menu.focus_next(self)
		if ret:
			if self._active_list == 'main_list':
				self._set_options_list()
			self.select(0)
		return ret

	def focus_previous(self):
		ret = Menu.focus_previous(self)
		if ret:
			self._set_options_list(False)
		return ret

	def show(self, *args, **kw):
		return Menu.show(self, False, *args, **kw)
