# -*- coding: utf-8 -*- 
#
# Description:
#
# NoteBook Menus Class Definitions
#
#
#
# Changes:
#
# 2011-10-06
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.


from __future__ import absolute_import

import itertools
from peewee.debug import PRINT_EXCEPTION
from peewee.notifier import Task
from pygui.menu.menu.core import Menu
from pygui.shared import pygui_globs
from pygui.eventmanager.menus import MenuEventHandler



# A notebook menu is a menu that handle couples of (item, sub menus).
# When a item becomes selected, its associated sub menu is pushed automatically on the stack
# (actually, it is kept under this menu)
# These items are set in the main_list, so to access them, use self['main_list']
class NotebookMenu(Menu):

	groupeable = True
	lazy_selection_delay = None

	def __init__(self, name, choices=None, submenus=None, subargs=None, subpos=None, *args, **kw):
		if choices is not None:
			Menu.__init__(self, name, choices, *args, **kw)
		else:
			Menu.__init__(self, name, [], *args, **kw)
		if submenus is not None:
			self._submenus = submenus
		else:
			self._submenus = []
		if subargs is not None:
			self._subargs = subargs
		else:
			self._subargs = []
		if subpos is not None:
			self._subpos = subpos
		else:
			self._subpos = -2
		self._getitems_keywords.update(dict(submenu_selected=(lambda : self._submenus[self.get_item_list('main_list').selected_pos]), subargs_selected=(lambda : self._subargs[self.get_item_list('main_list').selected_pos])))
		self._last_selected_pos = -1
		if self.lazy_selection_delay is not None:
			self.task_set = Task(self.set_submenu)
			self.task_set.delay = self.lazy_selection_delay
			self.set_selected_submenu = self.task_set.start
		else:
			self.set_selected_submenu = self.set_submenu
		return None

	# Get the submenu to displayed (from its rank or from the selected item in main_list)
	# Create it and put it on stack (see menustack.page_switch())
	def set_submenu(self, num_page=None):
		selected_pos = self.selected_pos
		if selected_pos == self._last_selected_pos:
			return None
		if num_page is None:
			submenu = self['submenu_selected'](**self['subargs_selected'])
		else:
			submenu = self._submenus[num_page](**self._subargs[num_page])
		for subpos, menu in enumerate(pygui_globs['menustack'].menus_stack):
			if menu.type.startswith('notebook'):
				break
		submenu.switch_sub_menu(subpos)
		self.submenu_selected = submenu
		self._last_selected_pos = selected_pos
		return None

	# Append a couple a (item, sub menu) to the notebook structure
	def append_page(self, item, menu, args):
		self['main_list'].append(item)
		self._submenus.append(menu)
		self._subargs.append(args)
		return None

	# Return the couple (item, sub menu) at the specified rank
	def get_page(self, rank):
		return (self['main_list'][rank], self._submenus[rank])

	# Return the couple (item, sub menu) with the specified name is the item's one
	# If this item does not exist, return (None, None)
	def get_page_by_name(self, name):
		for it, menu in itertools.izip(self['main_list'], self._submenus):
			if it.name == name:
				return (it, menu)
		return (None, None)

	# Remove the couple (item, sub menu) at the specified rank
	# If this couple was the selected one, next couple is set
	def remove_page(self, rank):
		old_selected_pos = self['main_list'].selected_pos
		try:
			menu = self._submenus.pop(rank)
			del self['main_list'][rank]
			new_selected_pos = self['main_list'].selected_pos
			if old_selected_pos >= rank:
				self.set_selected_submenu()
		except:
			PRINT_EXCEPTION()
		return None

	# Create and push the associated sub menu of selected item
	# (could be matched to sub_to_show)
	# sub_to_show is the class of the item we want to display
	def show(self, sub_to_show=None):
		if self._submenus != []:
			if sub_to_show is not None:
				for i, it in enumerate(self.get_item_list('main_list')):
					if isinstance(it, sub_to_show):
						self.get_item_list('main_list').selected_pos = i
						break
			self.submenu_selected = self['submenu_selected'](**self['subargs_selected'])
			self.submenu_selected.show()
			Menu.show(self, False)
			self._last_selected_pos = self.selected_pos
		return None

	def stop(self):
		try:
			self.task_set.stop()
		except AttributeError:
			pass
		Menu.stop(self)
		return None

	# Set the focus (eg. eventhandler) on selected sub menu
	# and manage attributes for toggling
	def move_to_page(self):
		try:
			if self.task_set.running:
				self.task_set.stop()
				self.set_submenu()
		except AttributeError:
			pass
		pygui_globs['menustack'].swap_notebook_page()
		self.toggleable = True
		self.submenu_selected.toggleable = False
		self.grouped_menu = True
		self.submenu_selected.toggleable = True
		return None

	def select(self, item, list_name='main_list', instantaneously=False):
		list_name = 'main_list'
		ret = Menu.select(self, item, list_name)
		if ret:
			if instantaneously:
				self.set_submenu()
			else:
				self.set_selected_submenu()
		return None



# This menu is the item-associated menu of the Notebook.
# It is almost a generic menu, excepted the special events management to toggle
# with the Notebook menu
class NotebookSubMenu(Menu):

	toggleable = True

	def __init__(self, related_item=None, *args, **kw):
		if not hasattr(self, 'related_item'):
			self.related_item = related_item
		_rel_it = self.related_item
		if _rel_it is not None:
			self.related_menu = _rel_it.menu
			Menu.__init__(self, choices=_rel_it.browse(), *args, **kw)
		else:
			self.related_menu = None
			Menu.__init__(self, choices=[], *args, **kw)
		return None

	# Handle when it must pass to notebook items
	def select(self, item, list_name=None, force_pos=False):
		ret = Menu.select(self, item, list_name, force_pos)
		if ret is not False:
			self.browse_selected()
		else:
			if self.active_list == 'main_list' and isinstance(item, int) and item < 0:
				self.move_to_page()
		return None

	# Place self in right place in menustack
	# When a submenu is put on screen, it is under the notebook menu (which
	# keep the focus)
	def switch_sub_menu(self, subpos):
		self.grouped_menu = True
		pygui_globs['menustack'].switch_sub_menu(self, subpos)
		self.show_help()
		return None

	# Set the focus (eg. the eventhandler) on notebook menu
	# and manage attributes for toggling
	def move_to_page(self):
		pygui_globs['menustack'].swap_notebook_page()
		self.toggleable = True
		try:
			self.related_menu.toggleable = False
		except AttributeError:
			pass
		self.grouped_menu = True
		try:
			self.related_menu.grouped_menu = False
		except AttributeError:
			pass
		return None
