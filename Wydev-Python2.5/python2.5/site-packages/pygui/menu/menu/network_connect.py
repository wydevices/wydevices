# -*- coding: utf-8 -*- 
#
# Description:
#
# Network Connect Menu Class Definiton
#
#
#
# Changes:
#
# 2012-05-03
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

from __future__ import absolute_import

from peewee.messages import send as louie_send
from peewee.notifier import Task
from peewee.debug import GET_LOGGER, PRINT_EXCEPTION
from wynetwork.utils import WyNetwork, WyNetworkConfig
from pygui.item.core import ActionItem, Item
from pygui.item.parameters.network.networksetup import ConnectionTypeContainer, AutoManConnectionContainer, AuthTypeConnectionContainer, EditNetworkConfSetupItem
from pygui.menu.menu import Menu
from pygui.eventmanager.menus import WifiSelectMenuEventHandler
from pygui.window import KeyboardWindow, BigConfirmWindow, ConfirmWindow, Button, MessageWindow, LoadingWindow
from pygui.config import user_config, plugins

log = GET_LOGGER(__name__)



class CryptoItem(Item):

	def __init__(self, network, *args, **kw):
		Item.__init__(self, *args, **kw)
		self.network = network
		return None

	def __eq__(self, other):
		if isinstance(other, CryptoItem):
			return self.network == other.network
		return False

	def __cmp__(self, other):
		if isinstance(other, CryptoItem):
			return cmp(self.network, other.network)
		else:
			return cmp(type(self), type(other))



# To manage configurations (select, active or delete a config)
class NetworkConnectMenu(Menu):

	def __init__(self, **kw):
		self.on_device_connected_task = Task(self._on_device_connected)
		self.on_device_connection_failed_task = Task(self._on_device_connection_failed)
		self.wn = WyNetwork()
		self.wn.wn_dev.attach(self)
		try:
			self.wn.set_scanning(True)
		except Exception, e:
			PRINT_EXCEPTION(e)
		self._connecting_config = None
		Menu.__init__(self, choices=[], **kw)
		self.wizard_menu = None
		self.connect_win = None
		self.loading_win = None
		self.eventhandler = WifiSelectMenuEventHandler(self)
		self.available_choices = ['options0_list', 'options1_list', 'options2_list', 'options3_list']
		self._getitems_keywords['options0_list'] = (lambda : self.get_item_list('options0_list'))
		self._getitems_keywords['options1_list'] = (lambda : self.get_item_list('options1_list'))
		self._getitems_keywords['options2_list'] = (lambda : self.get_item_list('options2_list'))
		self._getitems_keywords['options3_list'] = (lambda : self.get_item_list('options3_list'))
		self.set_items([], 'options0_list')
		self.set_items([], 'options1_list')
		self.set_items([], 'options2_list')
		self.set_items([], 'options3_list')
		self.active_list = 'options2_list'
		self.list_configs()
		return None

	def execute_selected(self):
		self[self.active_list].selected.execute()
		return None

	def stop(self):
		log.debug('Detach from wynetwork signals and set_scanning(False)')
		try:
			self.wn.set_scanning(False)
		except Exception, e:
			PRINT_EXCEPTION(e)
		self.wn.wn_dev.detach(self)
		Menu.stop(self)
		return None

	def list_configs(self):
		cfg_list = []
		self._connecting_config = None
		for config in self.wn.get_configs():
			log.debug('config %s', config.name)
			cfg_list.append(ActionItem(config.name, type_='setupitem', action=self.select_config, args=[config]))
		cfg_list.append(ActionItem(_('Create a new configuration'), type_='setupitem', display_type='create_new_config', action=self.create_config, args=[]))
		self.set_items([Item(_('Choose your configuration'), type_='setupitem')], 'main_list')
		self.set_items(cfg_list, 'options2_list')
		self.active_list = 'options2_list'
		return None

	def select_config(self, config):
		log.debug(config)
		buttons = []
		if config.is_valid():
			buttons.append(Button(_('Connect'), True))
			buttons[-1].connect(self.active_config, config)
		if config.is_removable():
			buttons.append(Button(_('Edit'), False))
			buttons[-1].connect(self.edit_config, config)
			buttons.append(Button(_('Delete'), False))
			buttons[-1].connect(self.delete_config, config)
		if buttons:
			cw = BigConfirmWindow(config.name, buttons)
			cw.show()
		return None

	def active_config(self, config):
		self.loading_win = LoadingWindow()
		self.loading_win.show()
		log.debug(config)
		self._connecting_config = config
		title = _('Connecting to %(net)s') % dict(net=config.name)
		self.connect_win = MessageWindow(title, button=None)
		self.connect_win.eventhandler.event_stop = (lambda event : None)
		self.connect_win.show(timeout=180)
		try:
			self.wn.active_config(config)
		except Exception, e:
			PRINT_EXCEPTION(e)
		return None

	def edit_config(self, config):
		log.debug(config)
		louie_send('on_%s_blur' % self._active_list, self)
		self.wizard_menu = NetworkWizardMenu(callback=self._wizard_callback, config=config)
		self.wizard_menu.show()
		return None

	def delete_config(self, config):
		log.debug(config)
		def _do_delete():
			try:
				self.wn.delete_config(config)
			except Exception, e:
				PRINT_EXCEPTION(e)
			finally:
				self.list_configs()
			return None
		cw = ConfirmWindow(_('Are you sure ?'), confirm_action=_do_delete)
		cw.show()
		return None

	def create_config(self):
		louie_send('on_%s_blur' % self._active_list, self)
		self.wizard_menu = NetworkWizardMenu(callback=self._wizard_callback, config=None)
		self.wizard_menu.show()
		return None

	def _on_device_connected(self, device):
		if self.loading_win is not None:
			self.loading_win.hide()
		log.debug(self._connecting_config)
		self.connect_win.hide()
		title = _('Connected to %(net)s') % dict(net=self._connecting_config.name)
		self.connect_win = MessageWindow(title, button=None)
		self.connect_win.eventhandler.event_stop = (lambda event : None)
		self.connect_win.show(timeout=3)
		self.hide()
		return None

	def _wizard_callback(self, config):
		log.debug('config = %s', config)
		if config == None:
			MessageWindow(_('Error during configuration'), button=None).show(5)
		self.wizard_menu.hide()
		self.list_configs()
		return None

	def _on_device_connection_failed(self, device):
		log.debug(self._connecting_config)
		self.connect_win.hide()
		title = _('Disconnected from %(net)s') % dict(net=self._connecting_config.name)
		self.connect_win = MessageWindow(title, button=None)
		self.connect_win.eventhandler.event_stop = (lambda event : None)
		self.connect_win.show(timeout=3)
		self.list_configs()
		return None

	def onDeviceConnected(self, device):
		log.debug(device)
		self.on_device_connected_task.args = (device,)
		self.on_device_connected_task.start(1)
		return None

	def onDeviceConnectionFailed(self, device):
		log.debug(device)
		self.on_device_connection_failed_task.args = (device,)
		self.on_device_connection_failed_task.start(1)
		return None

	def onDeviceConnecting(self, device):
		return None

	def onDeviceDisconnected(self, device):
		return None



# Used to fill a new config, or edit an existing one (not yet implemented)
class NetworkWizardMenu(Menu):

	def __init__(self, callback, config=None):
		self.eventhandler = WifiSelectMenuEventHandler(self)
		Menu.__init__(self, name='NetworkWizardMenu', type='network_connect', universe='setup')
		self.wn = WyNetwork()
		self._callback = callback
		self.wifi_menu = None
		self.eventhandler = WifiSelectMenuEventHandler(self)
		self.available_choices = ['options0_list', 'options1_list', 'options2_list', 'options3_list']
		self._getitems_keywords['options0_list'] = (lambda : self.get_item_list('options0_list'))
		self._getitems_keywords['options1_list'] = (lambda : self.get_item_list('options1_list'))
		self._getitems_keywords['options2_list'] = (lambda : self.get_item_list('options2_list'))
		self._getitems_keywords['options3_list'] = (lambda : self.get_item_list('options3_list'))
		self.set_items([], 'options0_list')
		self.set_items([], 'options1_list')
		self.set_items([], 'options2_list')
		self.set_items([], 'options3_list')
		self.active_list = 'options0_list'
		self.config_updaters = {'networkType': self._ask_type, 'ipConfigType': self._ask_mode, 'key': self._ask_key, 'essid': self._ask_essid, 'interface': self._ask_interface, 'authType': self._ask_key_type, 'cipher': self._ask_key_type, 'keyMgmt': self._ask_key_type, 'ipAddress': self._ask_ip_params, 'netmask': self._ask_ip_params, 'gateway': self._ask_ip_params}
		self._previous_config = None
		self._current_config = self.wn.new_config()
		log.debug('create new config')
		if config and isinstance(config, WyNetworkConfig):
			if config.is_valid():
				log.debug('editing %s (not implemented)', config.name)
				self._previous_config = config
			else:
				log.error('previous_config %s is not valid. Cancel configuration', config)
				return None
		if '802.11' not in self.wn.availables_networkType():
			log.debug('no 802.11 devices, set_ethernet()')
			self._current_config.set_ethernet()
			if self._previous_config and self._previous_config['networkType'] == '802.11':
				log.error('Editing 802.11 config but no wireless device found. Cancel configuration')
				return None
		log.debug('current_config %s', self._current_config)
		return None

	def show(self, hide_previous_menu=True):
		Menu.show(self, hide_previous_menu)
		self.start()
		return None

	def start(self):
		self.config_wizard = self.configurator()
		self.config_wizard.next()
		if self._previous_config:
			self.set_type(self._previous_config['networkType'])
		else:
			self.config_wizard.next()
		return None

	def execute_selected(self):
		self[self.active_list].selected.execute()
		return None

	# Set item in main_list and item.browse() in list_name, empty other lists
	def list_options(self, item, browse_list_name='options0_list'):
		self.set_items([item], 'main_list')
		for l in self.available_choices:
			self.set_items([], l)
		self.set_items(item.browse(), browse_list_name)
		self.active_list = browse_list_name
		return None

	def _wifi_callback(self, network):
		log.debug('selected network: %s', network)
		self._current_config.set_network(network)
		log.debug('config: %s', self._current_config)
		self.wifi_menu.hide()
		try:
			self.config_wizard.next()
		except StopIteration:
			log.debug('config_wizard STOP')
		return None

	def configurator(self):
		log.debug('init')
		cur_conf_configurator = self._current_config.configurator()
		cur_conf_configurator.next()
		yield None
		log.debug('start !')
		for invalid in cur_conf_configurator:
			log.debug('Asking %s', invalid)
			try:
				self.config_updaters[invalid]()
				yield None
			except Exception, e:
				log.error('Error while filling %s', invalid)
				PRINT_EXCEPTION(e)
			else:
				log.debug('Got %s', invalid)
		invalids = self._current_config.invalids_keys()
		log.debug('config.configurator STOP: invalids=%s', invalids)
		if not invalids:
			if self._previous_config:
				log.debug('Take name from previous_config')
				self._current_config.name = self._previous_config.name
			else:
				log.debug('Asking for a name')
				self._ask_name()
				yield None
			log.debug('got name %s', self._current_config.name)
			self._save_config()

	def _next_key(self):
		try:
			self.config_wizard.next()
		except StopIteration:
			log.debug('fill_config STOP')
		return None

	def _save_config(self):
		log.debug('Configuration done. saving...')
		try:
			self.wn.save_config(self._current_config)
		except Exception, e:
			PRINT_EXCEPTION(e)
		self._callback(self._current_config)
		return None

	def set_type(self, type):
		self._current_config['networkType'] = type
		if type == '802.3':
			self._current_config.set_ethernet()
			self._next_key()
		elif type == '802.11':
			self.wifi_menu = WifiSelectMenu(callback=self._wifi_callback)
			self.wifi_menu.show()
		return None

	def _ask_name(self):
		def _cancel():
			log.error('User does not provide name. Cancel configuration !')
			self.kbd.hide()
			self.hide()
			return None
		def _set_name(kbd):
			self._current_config.name = str(kbd._text)
			kbd.hide()
			self._next_key()
			return None
		text = (self._current_config.name if self._current_config.name else self._current_config.autoname)
		self.kbd = KeyboardWindow(_('Enter a name for this configuration'), text=text, confirm_action=_set_name)
		self.kbd.action_buttons[4].connect(_cancel)
		self.kbd.show()
		return None

	def _ask_type(self):
		def _set_type(type):
			self.set_items([], 'options0_list')
			self.set_type(type)
			return None
		it = ConnectionTypeContainer(callback=_set_type, name=_('Choose your connection type'), type_='parameters', menu=self)
		self.list_options(it, 'options0_list')
		return None

	def _ask_mode(self):
		def _set_mode(mode):
			self.set_items([], 'options0_list')
			self._current_config['ipConfigType'] = mode
			self._next_key()
			return None
		it = AutoManConnectionContainer(callback=_set_mode, name=_('Choose Automatic or Manual'), type_='parameters', menu=self)
		self.list_options(it, 'options0_list')
		return None

	def _ask_interface(self):
		try:
			self.wn.autofill(self._current_config, 'interface')
		except Exception, e:
			PRINT_EXCEPTION(e)
		Task(self.config_wizard.next).start(0.20000000000000001)
		return None

	def _ask_key(self):
		def _cancel():
			log.error('User does not provide key. Cancel configuration !')
			self.kbd.hide()
			self.hide()
			return None
		def _set_key(kbd):
			self._current_config['key'] = str(kbd._text)
			kbd.hide()
			self._next_key()
			return None
		try:
			title = _('%(authType)s key for %(essid)s') % self._current_config.config
		except Exception, e:
			title = _('key')
			PRINT_EXCEPTION(e)
		if self._previous_config and 'key' in self._previous_config:
			text = self._previous_config['key']
		else:
			text = ''
		self.kbd = KeyboardWindow(title, text=text, confirm_action=_set_key)
		self.kbd.action_buttons[4].connect(_cancel)
		self.kbd.show()
		return None

	def _ask_essid(self):
		def _cancel():
			log.error('User does not provide essid. Cancel configuration !')
			self.kbd.hide()
			self.hide()
			return None
		def _set_essid(kbd):
			self._current_config['essid'] = str(kbd._text)
			kbd.hide()
			self._next_key()
			return None
		self.kbd = KeyboardWindow('Network Name', text='', confirm_action=_set_essid)
		self.kbd.action_buttons[4].connect(_cancel)
		self.kbd.show()
		return None

	def _ask_key_type(self):
		def _set_key_type(infos):
			self.set_items([], 'options3_list')
			self._current_config['authType'] = infos['raw_auth']
			self._current_config['keyMgmt'] = infos['raw_key_mgt']
			self._current_config['cipher'] = infos['raw_cipher']
			self._next_key()
			return None
		it = AuthTypeConnectionContainer(callback=_set_key_type, name=_('Choose key type'), type_='parameters', menu=self)
		self.list_options(it, 'options3_list')
		return None

	def _ask_ip_params(self):
		def _set_ip_params(params):
			self.set_items([], 'options1_list')
			for k, v in params.iteritems():
				self._current_config[k] = v
			self._next_key()
			return None
		keys = ('ipAddress', 'netmask', 'gateway', 'dns1', 'dns2')
		values = ['0.0.0.0'] * 5
		default_values = dict(zip(keys, values))
		if self._previous_config:
			for k in keys:
				if k in self._previous_config:
					default_values[k] = self._previous_config[k]
					continue
		it = EditNetworkConfSetupItem(callback=_set_ip_params, default_values=default_values, name=_('Configure IP parameters'), type_='parameters', menu=self)
		self.list_options(it, 'options1_list')
		return None



# Just list availables wifi network
class WifiSelectMenu(Menu):

	def __init__(self, callback, name='Network Connect menu'):
		self.eventhandler = WifiSelectMenuEventHandler(self)
		Menu.__init__(self, name, type='wifi_select', universe='setup')
		self.available_choices = ['main_list', 'crypto_list']
		self._getitems_keywords['crypto_list'] = (lambda : self.get_item_list('crypto_list'))
		self.set_items([], 'main_list')
		self.set_items([], 'crypto_list')
		self._callback = callback
		self.can_scan = True
		self.on_network_appeared_task = Task(self._on_network_appeared)
		self.on_network_disappeared_task = Task(self._on_network_disappeared)
		self.wn = WyNetwork()
		self.wn.wn_net.attach(self)
		self.list_networks()
		return None

	def select(self, item, list_name=None, force_pos=False):
		ret = Menu.select(self, item, list_name, force_pos)
		if ret is not False and (list_name if list_name else self.active_list) == 'main_list':
			Menu.select(self, item, 'crypto_list', force_pos)
		return None

	def execute_selected(self):
		self.selected.execute()
		return None

	def stop(self):
		self.wn.wn_net.detach(self)
		Menu.stop(self)
		return None

	def _on_network_appeared(self, dev, net):
		self.list_networks()
		return None

	def _on_network_disappeared(self, dev, net):
		self.list_networks()
		return None

	def onNetworkAppeared(self, dev, net):
		self.on_network_appeared_task.args = (dev, net)
		self.on_network_appeared_task.start(1)
		return None

	def onNetworkDisappeared(self, dev, net):
		self.on_network_disappeared_task.args = (dev, net)
		self.on_network_disappeared_task.start(1)
		return None

	# Fill menu with available wifi networks
	def list_networks(self):
		it_list = []
		crypto_list = []
		if self.can_scan:
			for network in self.wn.get_networks():
				crypto = CryptoItem(network['essid'], '', type_='setupitem')
				crypto.display_type = ('wifi_select_setupitem' if network['authType'] else 'not_crypted')
				it = ActionItem(name=network['essid'], display_type=None, type_='setupitem', action=self._callback, args=[network])
				it.display_type = self._get_display_type(network['strength'])
				it_list.append(it)
				crypto_list.append(crypto)
			hidden_crypto = CryptoItem('hidden', '', type_='setupitem')
			hidden_crypto.display_type = 'not_crypted'
			hidden_it = ActionItem(_('Connect to an other network'), display_type=None, type_='setupitem', action=self._callback, args=[None])
			it_list.append(hidden_it)
			crypto_list.append(hidden_crypto)
			self.set_items(it_list, 'main_list')
			self.set_items(crypto_list, 'crypto_list')
		else:
			log.debug('scan blocked by pending configuration process')
		return None

	# Return correct display_type for signal strength
	def _get_display_type(self, strength):
		strength = int(strength)
		if strength > 0 and strength <= 100:
			if strength > 80:
				return 'wifi_signal_1'
			elif strength > 60:
				return 'wifi_signal_2'
			elif strength > 40:
				return 'wifi_signal_3'
			elif strength > 20:
				return 'wifi_signal_4'
		return 'wifi_signal_5'
