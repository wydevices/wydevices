# -*- coding: utf-8 -*- 
#
# Description:
#
# Root & Home Menus Class Definitions
#
#
#
# Changes:
#
# 2011-10-02
# Add "_get_usb_mode" telling if USB is used for MTP or PS3 mode
# Remove WYDEMO and Wyplay Update handling
#
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.


from __future__ import absolute_import

__all__ = ['HomeMenu', 'UniverseSwitcherMenu', 'RootMenu']

from pygui.menu.menu.core import Menu
from peewee.messages import send as louie_send
from peewee.debug import GET_LOGGER, PRINT_EXCEPTION
from peewee.notifier import stop, Task
from pygui.config import plugins, url_list, home_order, user_config
from pygui.eventmanager import EventDispatcher
from pygui.eventmanager.menus import HomeEventHandler
from pygui.facilities.l10n import omnicode
from pygui.facilities.codemapping import control_mode_popup_dict
from pygui.item.core import ActionItem
from pygui.item.mediaitem.core import TVRootItem, ChannelItem
from pygui.shared import pygui_globs
from pygui.window import Button, ConfirmWindow, MessageWindow


log = GET_LOGGER(__name__)


# Traduction Decorator
class TraducedLabel(object):

	def __init__(self, caption):
		self._caption = caption
		return None

	def __str__(self):
		return _(self._caption)



# Universe Label Decorator
class UniverseLabel(object):

	def __init__(self, label, *args):
		self.args = args
		self.label = label
		return None



# Universe Definitions
UNIVERSE_LABELS = {'tv': UniverseLabel(TraducedLabel('TV')), 'audio': UniverseLabel(TraducedLabel('Music'), 'audio'), 'video_image': UniverseLabel(TraducedLabel('Video/Photo'), 'video_image'), 'hdmi_tv_1': UniverseLabel(TraducedLabel('HDMI1')), 'hdmi_tv_2': UniverseLabel(TraducedLabel('HDMI2')), 'image': UniverseLabel(TraducedLabel('Image'), 'image'), 'video': UniverseLabel(TraducedLabel('Video'), 'video'), 'net_services': UniverseLabel(TraducedLabel('Internet Services'), 'net_services'), 'multiverse': UniverseLabel(TraducedLabel('Navigator'), 'multiverse'), 'parameters': UniverseLabel(TraducedLabel('Parameters')), 'test_menu': UniverseLabel(TraducedLabel('Test'))}



# The Root Menu is a menu always present in the stack.
# He is not supposed to have a specific view, nor specific features.
# It's the base menu, used to register all the global callbacks
class RootMenu(Menu):

	def __init__(self):
		self.eventHandler = EventDispatcher(self)
		self._navigator = None
		Menu.__init__(self, 'root', type='root')
		self._getitems_keywords['message'] = (lambda : _('Press Home to switch universe'))
		import wymedia.wmplus as w
		w.register_plug_callback((lambda obj: Task(self.device_plugged, obj, True).start(0)))
		w.register_unplug_callback((lambda obj: Task(self.device_plugged, obj, False).start(0)))
		self._controlmode_popup = None
		usb_mode = self._get_usb_mode()
		if usb_mode == 'MTP':
			from peewee.controlmode import ControlModeManager
			ctrl = ControlModeManager()
			ctrl.register_observer(self.control_changed)
			pygui_globs['controlmodemanager'] = ctrl
		elif usb_mode == 'PS3':
			self.control_changed('mtp_off', True, True)
		self.active_univ = None
		return None

	# USB MTP or PS3 mode
	def _get_usb_mode(self):
		import os
		if not os.path.exists('/wymedia/usr/etc/usbcable.conf'):
			return 'MTP'
		conf_file = os.popen('cat /wymedia/usr/etc/usbcable.conf')
		lines = conf_file.readlines()
		conf_file.close()
		for line in lines:
			line = line.replace('\n', '')
			if line == '':
				continue
			elif 'Mode MTP' in line:
				return 'MTP'
			elif 'Mode PS3' in line:
				return 'PS3'

	# Called when control mode change (mtp)
	def control_changed(self, mode, rcu, standby):
		from peewee.notifier import events_drop
		from pygui.facilities.power import PowerManager
		from pygui.menu.menu.bsod import BSoDMenu
		log.debug('Control changed: mode=%s rcu=%s standby=%s', mode, rcu, standby)
		msg = control_mode_popup_dict[mode]
		if rcu:
			if self._controlmode_popup:
				self._controlmode_popup.hide()
				self._controlmode_popup = None
			events_drop(False)
			plugins.discard('popup_blocker')
			if standby == False:
				stack = pygui_globs['menustack']
				if not stack.is_on_firstboot():
					stack.back_to_home()
				MessageWindow(msg, button=None).show(timeout=3)
		else:
			events_drop(True)
			plugins.add('popup_blocker')
			stack = pygui_globs['menustack']
			if not stack.is_on_firstboot():
				stack.back_to_home()
				BSoDMenu().show()
			self._controlmode_popup = MessageWindow(msg, button=None)
			self._controlmode_popup.show()
		return None

	# Called When A Device Is Plugged
	def device_plugged(self, obj, plugged):
		if not obj.get('title'):
			name = _('Unknown device')
		else:
			name = obj.get('title')
		if plugged:
			msg_template = _('Device "%(name)s" plugged in.')
		else:
			msg_template = _('Device "%(name)s" removed.')
		msg = msg_template % {'name': name}
		log.debug('%s / %s', msg, name)
		stack = pygui_globs['menustack']
#		if plugged:
#			if 'WYDEMO' in obj['title'].upper():
#				from pygui.facilities.demomode import handle_demo
#				handle_demo(obj)
		if 'popup_blocker' in plugins:
			stack.get_player()
		else:
			MessageWindow(msg, button=None).show(timeout=3)
		if 'transcode' in plugins and name.startswith("PSP"):
				pygui_globs['psp_path'] = obj.get(uri)
		nav = self._navigator
		if nav is not None and nav in stack:
			if not plugged:
				concerned = False
				try:
					for h in nav._history:
						if h['selected'] and  obj['id'] == h['selected'].wymedia_resource['id']:
							concerned = True
				except:
					pass
				if concerned:
					stack.close_player()
					stack.back_to_menu(nav)
					nav.back_to_root()
				from pygui.markerlist import markerlists
				for mlist in markerlists():
					mlist._refresh()
				nav._update_marker()
			if nav is stack.get_navigator():
				log.debug('calling _refresh_root()')
				nav._refresh_root()
				if nav._history:
					log.debug('calling build_preview()')
					nav.build_preview()
		return None

	def show(self, hide_previous_menu=True, timeout=None):
		Menu.show(self, hide_previous_menu, timeout)
		if 'restore_last_universe' in plugins and not user_config['advanced']['last_universe']:
			louie_send('show_select_universe', sender=self)
		return None

	def launch_parameters(self):
		def _display_setup():
			from pygui.menu.menu.parameters import MainSetupParametersNotebookMenu
			from pygui.item.parameters.generalsetup import GeneralConfigurationItem
			user_config['security']['parent_mode'] = True
			user_config.save()
			sm = MainSetupParametersNotebookMenu(name=_('Parameters'), type='notebook_setup_parameters', universe='parameters')
			sm.show(sub_to_show=GeneralConfigurationItem)
			return None

		def _display_qa():
			from pygui.menu.menu.security import QuestionAnswerCheckLauncher
			QuestionAnswerCheckLauncher(_display_setup)
			return None

		if user_config['security']['parent_mode'] or not user_config['security']['parental_control']:
			_display_setup()
		else:
			from .parameters import SecretCodeCheckMenu
			sc = SecretCodeCheckMenu(name=_('Check PIN Code'), action=_display_setup, cancel_action=_display_qa)
			pygui_globs['menustack'].push_menu(sc)
		return None

	# Attempt to launch the TV universe, prompting for and launching
	# a scan if required.
	def launch_tv(self):
		def _fullscan():
			from pygui.item.parameters.tv.tvsetup import TNTAutomaticScanItem
			item = TNTAutomaticScanItem(parent=None, name=_('Automatic scan'), type_='setupitem')
			item.menu = self
			item.execute()
			return None

		# Prompt the user to launch a TV scan. If the user answers yes,
    # the TV player is launched after the scan's completion.
		#
    # If play_on_no equals True, attempt to launch the TV player
    # regardless of the user's answer (e.g. if the only channel
    # is the analog capture and the user doesn't want to scan).
		def prompt_tv_scan(play_on_no=False):
			buttons = [Button(_('Yes'), True), Button(_('No'), False)]
			buttons[0].connect(_fullscan)
			if play_on_no:
				buttons[1].connect(ChannelItem.player.play)
			messbox = ConfirmWindow(text=_('Do you want to launch a scan now?'), buttons=buttons)
			messbox.show()
			return None

		try:
			acl = TVRootItem().get_acl(menu=self)
			channels = acl.browse()
			num_channels = len(channels)
		except:
			w = MessageWindow(text=_('Channels are unavailable. Please try again.\nIf the problem persists, launch a scan or reset to factory defaults.'), title=_('TV failure'))
			w.show(timeout=3)
			PRINT_EXCEPTION()
			return None
		user_config['advanced']['last_universe'] = 'tv'
		user_config.save()
		if num_channels == 0:
			_fullscan()
		elif num_channels == 1 and channels[0]['class'].endswith('videoCapture'):
				prompt_tv_scan(play_on_no=True)
		else:
			ChannelItem.player.play()
		return None

	def launch_net_services(self, name):
		from peewee.networkmanager import NetworkManager
		NM = NetworkManager()
		if NM.get_state() == 'disconnected':
			stack.back_to_home()
			MessageWindow(text='Please configure connection', title='Not connected', button=False).show(timeout=5)
		else:
			if name == 'net_services':
				from wymedia.wmplus import set_param
				login, password = user_config['net']['login'], user_config['net']['password']
				if login is not None:
					log.info("'user' param set for net services'")
					set_param('user', login)
				if password is not None:
					log.info("'pass' param set for net services'")
					set_param('pass', password)
				lang = user_config['base']['language']
				log.info("'lang' param set for net services'")
				set_param('lang', lang)
			if self._navigator is None:
				from pygui.menu.menu import Navigator
				self._navigator = Navigator(name, name, [], type=name)
			else:
				self._navigator.reset(name, type=name, universe=name)
			self._navigator.show()
			user_config['advanced']['last_universe'] = name
			user_config.save()
		return None

	def launch_navigator(self, name):
		if self._navigator is None:
			from pygui.menu.menu import Navigator
			self._navigator = Navigator(name, name, [], type=name)
		else:
			self._navigator.reset(name, type=name, universe=name)
		self._navigator.show()
		user_config['advanced']['last_universe'] = name
		user_config.save()
		return None

	launch_multiverse, launch_audio, launch_video, launch_video_image, launch_image = launch_navigator, launch_navigator, launch_navigator, launch_navigator, launch_navigator

	def launch_testmenu(self):
		from pygui.menu.menu.test_menu import GenMenu
		GenMenu().show()
		return None

	def launch_hdmi(self):
		from .bsod import BSoDMenu
		hdmi_menu = BSoDMenu()
		pygui_globs['menustack'].push_menu(hdmi_menu)
		return None

	launch_hdmi_tv_1, launch_hdmi_tv_2, launch_hdmi_tv = launch_hdmi, launch_hdmi, launch_hdmi

	def launch_failsafe(self):
		from pygui.menu.menu import FailsafeMenu
		FailsafeMenu().show()
		return None



# Merge UniverseSwitcher and HomeMenu (in fact, only event_handler and xml should change)
class HomeMenu(Menu):

	def __init__(self, focus=False):
		self._navigator = None
		if 'universe_switcher' in plugins:
			type_ = 'switcher'
		else:
			type_ = 'main'
		self.eventhandler = HomeEventHandler(self)
		Menu.__init__(self, type_, self.get_universes_items(), type=type_)
		self._getitems_keywords['item_name'] = (lambda : self._get_item_name())
		self._getitems_keywords['parental_rating'] = (lambda : self._get_parental_rating())
		self._getitems_keywords['help'] = (lambda : _('Enter Setup universe'))
		self.get_item_list('main_list').cyclic = True
		try:
			if focus:
				self.select(self._HomeMenu__get_named(focus))
			elif home_order:
				for name in home_order:
					if name[0] == '*':
						self.select(self._HomeMenu__get_named(name.lstrip('*')))
						break
		except Exception, e:
			log.error('Select failed: %s' % str(e))
		return None

	def _HomeMenu__get_named(self, name):
		for item in self['main_list']:
			if item.display_type == name:
				return item
		return 0

	def _get_item_name(self):
		if self.selected:
			return omnicode(self.selected.name)
		return self.selected

	def _get_parental_rating(self):
		if user_config['security']['parental_control'] and not user_config['security']['parent_mode']:
			return ('maturityrating_%s.png' % user_config['security']['maturity_rating'])
		return None

	def select(self, item, list_name=None, force_pos=False):
		if isinstance(item, basestring):
			item = self._HomeMenu__get_named(item)
		has_changed = Menu.select(self, item, list_name, force_pos)
		if has_changed is not False:
			louie_send('item_name', sender=self, action='update', value=omnicode(self['item_name']))
		return has_changed

	def show(self, hide_previous_menu=True, timeout=None):
		last_universe = user_config['advanced']['last_universe']
		if last_universe and 'restore_last_universe' in plugins:
			self.select(last_universe)
		Menu.show(self, hide_previous_menu, timeout)
		return None

	def execute_selected(self):
		sel = self.selected
		if sel:
			if self.type == 'switcher':
				ms = pygui_globs['menustack']
				if sel != ms.get_root().active_univ:
					ms.back_to_menu(None)
					ms.get_root().active_univ = sel
					sel.execute()
				else:
					ms.back_one_menu()
			else:
				sel.execute()
		return None

	def byebye(self):
		from pygui.facilities import minimalist_home
		minimalist_home.dump_home()
		stop()
		raise SystemExit('hasta la vista Catalina !')

  # get_universes_items return a list of ActionItems for all universes activable
  # since the local_conf.py file.
  # ActionItem will use RootMenu.launch_* methods to push universes:
  #     - tv   -> launch_tv
  #     - audio -> launch_audio
  #     - video_image -> launch_video_image
  #     - hdmi_tv -> launch_hdmi_tv
  #     - image -> launch_image
  #     - video -> launch_video
  #     - net_services -> launch_net_services
  #     - multiverse -> launch_multiverse
  #     - parameters -> launch_parameters
  #     - test_menu  -> launch_test_menu
	def get_universes_items(self):
		home_plugins = plugins.get('home')
		home_items = []
		root_menu = pygui_globs['menustack'].get_root()
		for universe in home_plugins:
			try:
				univ = UNIVERSE_LABELS[universe]
				home_items.append(ActionItem(univ.label, type_='main', action=getattr(root_menu, ('launch_%s' % universe)), display_type=universe, args=univ.args))
			except KeyError, e:
				log.warning("The universe %s can't be loaded, error message below:\n%s" % (universe, str(e)))
				PRINT_EXCEPTION()
			except AttributeError, e:
				log.warning('%s not implement in%s' % (('launch_%s' % universe), root_menu))
				PRINT_EXCEPTION()
		if home_order:
			ho = []
			for n in home_order:
				ho.append(n.lstrip('*'))
			def _scorify(item):
				try:
					return ho.index(item.display_type)
				except ValueError:
					return 1000
			home_items.sort(key=_scorify)
		return home_items

	def reload_func(self):
		louie_send('item_name', sender=self, action='reset', value=self['item_name'])
		louie_send('main_list', sender=self, action='reset', value=self['main_list'])
		louie_send('parental_rating', sender=self, action='reset', value=self['parental_rating'])
		louie_send('help', sender=self, value=self['help'])
		if not user_config['base']['help_banner']:
			self.hide_help()
		else:
			self.show_help()
		return None
