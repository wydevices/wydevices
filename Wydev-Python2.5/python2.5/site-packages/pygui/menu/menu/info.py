# -*- coding: utf-8 -*- 
#
# Description:
#
# Info Menus Definitons
#
#
#
# Changes:
#
# 2012-04-11
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

from __future__ import absolute_import

from time import localtime, strftime
from peewee.messages import send as louie_send
from pygui.eventmanager.menus import InfoMenuEventHandler, ChannelInfoMenuEventHandler
from pygui.facilities.l10n import get_date_format
from pygui.item.core import ActionItem, Item
from pygui.item.info import InfoItem, RecordActivationItem, ProtectionsActionItem, ParentalRatingActionItem
from pygui.config import user_config
from pygui.menu.menu.core import ContextMenu
from peewee.formatters import seconds_to_hhmm
from peewee.debug import GET_LOGGER

log = GET_LOGGER(__name__)



# Generic information menu.
class InfoMenu(ContextMenu):

	# Create an information menu.
	#  - item: the item about which all of this is about.
	#  - data: various Items to be added to the main_list, that give whatever
	#    information about item you want the user to see. Note that if they
	#    support the browse() operation, its results will be displayed in
	#    the options_list when highlighted.
	def __init__(self, item, data, name='Media information menu', eventhandler=None, type='media_info'):
		self.eventhandler = (InfoMenuEventHandler(self) if not eventhandler else eventhandler)
		ContextMenu.__init__(self, name, type=type)
		self.item = item
		self._getitems_keywords.update({'titles_list': (lambda : self.get_item_list('titles_list'))})
		self.set_items(([] if not data else data), 'main_list')
		self._set_options_list()
		titles = []
		for i in self['main_list']:
			try:
				title_item = Item(name=i.title, type_='info_%s' % i.field)
				titles.append(title_item)
			except AttributeError:
				titles.append(Item(name='', type_=''))
		self.set_items(titles, 'titles_list', 0)
		return None

	# Execute the selected item, if possible.
	def execute_selected(self):
		try:
			self.selected.execute()
		except AttributeError:
			pass
		return None



# Information menu for a ChannelItem.
class ChannelInfoMenu(InfoMenu):

	def __init__(self, item, name='Channel information menu'):
		data = [InfoItem(item, _('Favorites list'), 'favorite_list', False), InfoItem(item, _('Conditonal Access Status'), 'cas', False)]
		InfoMenu.__init__(self, item, data, name, ChannelInfoMenuEventHandler(self), type='tv_info')
		return None



# Information menu for the All Channels List.
class TVInfoMenu(InfoMenu):

	def __init__(self, item, name='Full channels list information menu'):
		info = {'last_scan_date': strftime(get_date_format(), localtime(user_config['tv']['last_scan_time']))}
		data = [InfoItem(item, _('Number of channels'), 'childCount', False), InfoItem(info, _('Latest scan date'), 'last_scan_date', False)]
		if user_config['security']['parental_control'] and user_config['security']['parent_mode']:
			data.extend((ProtectionsActionItem(item, self, _('Hidden')), ParentalRatingActionItem(item, self, _('Rating'))))
		InfoMenu.__init__(self, item, data, name, type='tv_info')
		return None



# Information menu for a ScheduledRecordItem.
class ScheduledRecordInfoMenu(InfoMenu):

	def __init__(self, item, name='Scheduled Record information menu'):
		rec_info = {'start_date': strftime(_('%A %d %B'), localtime(item.record.start_time)), 'start_time': seconds_to_hhmm(item.record.start_time), 'end_time': seconds_to_hhmm(item.record.stop_time)}
		data = [InfoItem(rec_info, _('Date'), 'start_date', False), InfoItem(rec_info, _('Start time'), 'start_time', False), InfoItem(rec_info, _('End time'), 'end_time', False)]
		try:
			repeat_info = {'period': item.period, 'remaining_count': item.remaining_count}
			data.extend([InfoItem(repeat_info, _('Repeat'), 'period', False), InfoItem(repeat_info, _('Remaining recordings'), 'remaining_count', False)])
			if item.remaining_count > 1:
				data.append(RecordActivationItem(item, self, _('Activation')))
		except AttributeError:
			pass
		InfoMenu.__init__(self, item, data, name, type='tv_info')
		return None



# Information menu for the ScheduledRecordRootItem.
class ScheduledRecordRootInfoMenu(InfoMenu):

	def __init__(self, item, name='Scheduled Records Root information menu'):
		all_recs = item.browse()
		info = {'num_records': len(all_recs)}
		data = [InfoItem(info, _('Number of scheduled recordings'), 'num_records', False)]
		if all_recs:
			next_record = all_recs[0].record
			values = {'start_time': strftime('%Y-%m-%d %H:%M', localtime(next_record.start_time))}
			data.append(InfoItem(values, _('Next recording on'), 'start_time', False))
		InfoMenu.__init__(self, item, data, name, type='tv_info')
		return None



# Menu to display available rating choices over InfoMenu.
class RatingInfoMenu(ContextMenu):

	def __init__(self, item, parent_menu, name='Media Rating menu', eventhandler=None, type='rating_info'):
		self.eventhandler = (InfoMenuEventHandler(self) if not eventhandler else eventhandler)
		ContextMenu.__init__(self, name, type=type)
		self.item = item
		self.parent_menu = parent_menu
		self.action_container = ParentalRatingActionItem(item, self, _('Rating'))
		self.set_items(([] if not [self.action_container] else [self.action_container]), 'main_list')
		self._set_options_list()
		self.focus_next()
		return None

	def focus_previous(self):
		return None

	def get_current_rating(self):
		return self.action_container.name

	def execute_selected(self):
		self.selected.execute()
		self.hide()
		self.parent_menu.rating_callback()
		return None

	def clear(self):
		return None



# Defines common methods for accessing wymedia attributes.
class MediaItemInfoMenu(InfoMenu):

	def __init__(self, item, data, name):
		self.rating_launcher = None
		if user_config['security']['parental_control'] and user_config['security']['parent_mode'] and data:
			self.rate_menu = RatingInfoMenu(item, self)
			current_rating = self.rate_menu.get_current_rating()
			rating_launcher = ActionItem(current_rating, type_='info', menu=self, display_type=None, action=self.show_rating, args=(), kwargs={})
			rating_launcher.title = _('Rating')
			rating_launcher.field = 'rating'
			data.append(rating_launcher)
			self.rating_launcher = rating_launcher
		else:
			self.rate_menu = None
		InfoMenu.__init__(self, item, data, name, type='media_info')
		self._getitems_keywords['hd_info_icon'] = (lambda : None)
		self._getitems_keywords['snd_info_icon'] = (lambda : None)
		log.debug('InfoWindow for %s: %s', item, item.wymedia_resource)
		try:
			item.watch(self._selection_changed)
			item.async_media_update()
		except AttributeError:
			log.warn('%s.watch failed !', item)
		return None

	def select(self, item, list_name=None, force_pos=False):
		ret = ContextMenu.select(self, item, list_name, force_pos)
		if ret and self.active_list == 'main_list' and self.rating_launcher == self.selected:
			self.execute_selected()
		return None

	def show_rating(self):
		self.rate_menu.show()
		return None

	# To update the value of current rating choice
	def rating_callback(self):
		self.selected.name = self.rate_menu.get_current_rating()
		louie_send('main_list', sender=self, action='reset', value=self['main_list'], position=self.selected_pos)
		self.rate_menu = RatingInfoMenu(self.item, self)
		return None

	def _selection_changed(self, item):
		log.debug('%s changed, reloading InfoWindow', item)
		for info in self.get_item_list('main_list'):
			if isinstance(info, InfoItem):
				info.reload()
		louie_send('main_list', sender=self, action='reset', value=self['main_list'])
		return None

	def clear(self):
		InfoMenu.clear(self)
		if self.rate_menu:
			ContextMenu.clear(self.rate_menu)
		return None



# Information menu for a AudioItem.
class AudioItemInfoMenu(MediaItemInfoMenu):

	def __init__(self, item, name='AudioItem information menu'):
		data = [InfoItem(item, _('Title'), 'metadata_title', True), InfoItem(item, _('Artist'), 'author', True), InfoItem(item, _('Genre'), 'genre', True), InfoItem(item, _('Album'), 'album', True), InfoItem(item, _('Track'), 'track', True), InfoItem(item, _('Year'), 'year', True), InfoItem(item, _('Format'), 'audio_codec'), InfoItem(item, _('Bitrate'), 'bitrate'), InfoItem(item, _('Duration'), 'duration'), InfoItem(item, _('Size'), 'size'), InfoItem(item, _('Belongs to playlist'), 'playlists'), InfoItem(item, _('Import date'), 'date')]
		MediaItemInfoMenu.__init__(self, item, data, name)
		return None



# Information menu for a VideoItem.
class VideoItemInfoMenu(MediaItemInfoMenu):

	def __init__(self, item, name='VideoItem information menu'):
		data = [InfoItem(item, _('Size'), 'size'), InfoItem(item, _('Codec'), 'video_codec'), InfoItem(item, _('Resolution'), 'resolution'), InfoItem(item, _('Sound track'), 'nrAudioChannels'), InfoItem(item, _('Artist'), 'author')]
		try:
			if item['class'].endswith('tvRecord'):
				data.append(InfoItem(item, _('Record date'), 'recordedStartDateTime'))
			else:
				data.append(InfoItem(item, _('Importation date'), 'date'))
		except:
			data.append(InfoItem(item, _('Importation date'), 'date'))
		data.append(InfoItem(item, _('Cover'), 'cover'))
		MediaItemInfoMenu.__init__(self, item, data, name)
		self._getitems_keywords['hd_info_icon'] = self._get_hd_info_icon
		self._getitems_keywords['snd_info_icon'] = self._get_snd_info_icon
		return None

	def _selection_changed(self, item):
		MediaItemInfoMenu._selection_changed(self, item)
		louie_send('hd_info_icon', sender=self, action='update', value=self._get_hd_info_icon())
		louie_send('snd_info_icon', sender=self, action='update', value=self._get_snd_info_icon())
		return None

	def _get_hd_info_icon(self):
		ico = None
		if self.item['height']:
			if int(self.item['height']) > 700:
				ico = 'tvplayer_videoformathd.png'
		return ico

	def _get_snd_info_icon(self):
		ico = None
		if self.item['nrAudioChannels']:
			if int(self.item['nrAudioChannels']) > 5:
				ico = 'tvplayer_audio51.png'
		return ico



# Information menu for a ImageItem.
class ImageItemInfoMenu(MediaItemInfoMenu):

	def __init__(self, item, name='ImageItem information menu'):
		data = [InfoItem(item, _('Size'), 'size'), InfoItem(item, _('Resolution'), 'resolution'), InfoItem(item, _('Camera Model'), 'exif_model')]
		MediaItemInfoMenu.__init__(self, item, data, name)
		return None



# Information menu for NetFeedItem.
class NetFeedItemInfoMenu(MediaItemInfoMenu):

	def __init__(self, item, name='NetFeedItem information menu'):
		data = [InfoItem(item, _('Link'), 'link'), InfoItem(item, _('URI'), 'uri')]
		MediaItemInfoMenu.__init__(self, item, data, name)
		return None



# Information menu for NetItem.
class NetItemInfoMenu(MediaItemInfoMenu):

	def __init__(self, item, name='NetItem information menu'):
		data = [InfoItem(item, _('Author'), 'author'), InfoItem(item, _('Link'), 'link'), InfoItem(item, _('URI'), 'uri')]
		MediaItemInfoMenu.__init__(self, item, data, name)
		return None



# Information menu for a DirItem.
class DirItemInfoMenu(MediaItemInfoMenu):

	def __init__(self, item, name='DirItem information menu'):
		data = [InfoItem(item, _('Number of files'), 'childs'), InfoItem(item, _('Creation date'), 'date')]
		MediaItemInfoMenu.__init__(self, item, data, name)
		return None



# Information menu for a PlayListItem.
class PlayListItemInfoMenu(MediaItemInfoMenu):

	def __init__(self, item, name='PlayList information menu'):
		data = [InfoItem(item, _('Number of tracks'), 'childs'), InfoItem(item, _('Missing tracks'), 'missing'), InfoItem(item, _('Creation date'), 'date')]
		MediaItemInfoMenu.__init__(self, item, data, name)
		return None



# Information menu for the markerlist.
class MarkerListInfoMenu(MediaItemInfoMenu):

	def __init__(self, item, name='MarkerList information menu'):
		data = []
		MediaItemInfoMenu.__init__(self, item, data, name)
		return None



item_info_menu_dict = {'video': VideoItemInfoMenu, 'iso_dvd': VideoItemInfoMenu, 'audio': AudioItemInfoMenu, 'image': ImageItemInfoMenu, 'net_feed': NetFeedItemInfoMenu, 'net': NetItemInfoMenu, 'dir': DirItemInfoMenu, 'playlist': PlayListItemInfoMenu}
