# -*- coding: utf-8 -*- 
#
# Description:
#
# Menus Views, Controllers & Stack Class Definitions
#
#
#
# Changes:
#
# 2011-10-04
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.


from __future__ import absolute_import

__all__ = ['MenuStack', 'MenuManager']

from itertools import chain
from peewee.debug import GET_LOGGER, PRINT_EXCEPTION
from peewee.misc_utils import MetaSingleton
from peewee.notifier import events_watch
from pygui.shared import pygui_globs

log = GET_LOGGER('stack')



# Main class that manages views and controllers
# 
# self.windows and self.menus_stack are the controllers
# self.engines is a list of views
class MenuManager(object):
	__metaclass__ = MetaSingleton

	def __init__(self, *args, **kw):
		self.menus_stack = MenuStack()
		self.windows = []
		self.engines = []
		self._home_timestamp = None
		self._failsafe_log = []
		events_watch(self.handle)
		self._on_idle = False
		pygui_globs['menustack'] = self
		return None

	def _get_idle_engines(self):
		return self._on_idle

	def _set_idle_engines(self, val):
		self._on_idle = val
		for engine in self.engines:
			engine.on_idle = val
		return None

	on_idle = property(_get_idle_engines, _set_idle_engines)
	del _get_idle_engines
	del _set_idle_engines

	def __repr__(self):
		return 'windows: [%s]\nmenus: [%s]\n' % (', '.join((str(w) for w in self.windows)), ', '.join((str(m) for m in self.menus_stack)))

	def __len__(self):
		return len(self.menus_stack)

	def __contains__(self, m):
		return m in self.menus_stack

	# Event handling function.
	# First send to windows if some exists else send event to menu stack.
	# 
	# Little combo tricks from Wyplay guys:
	# 	1 - Press 10 times 'HOME' button to launch the failsafe menu.
	# 			This menu allow to select video output and resolution.
	# 	2 - Press 10 times 'RECORD', 'HOME', 'RECORD', 'HOME', ...
	# 			to activate the 'logselected' plugin.
	# 			This plugin use a datagram socket to send the name of each selected item to a client
	# 			host=172.16.10.66, port=2345
	def handle(self, event):
		if event.name == 'HOME':
			bl = self._failsafe_log
			bl.append('HOME')
			if not self._home_timestamp:
				self._home_timestamp = event.arg['timeout']
			else:
				if event.arg['timeout'] - self._home_timestamp < 5.0 and len(bl) > 10 and set(bl) == set(['HOME']):
					self._home_timestamp = None
					bl = []
					self.menus_stack[0].launch_failsafe()
		else:
			self._failsafe_log = []
			self._home_timestamp = None
			bl = []
		if bl == ['RECORD', 'HOME', 'RECORD', 'HOME', 'RECORD', 'HOME', 'RECORD', 'HOME', 'RECORD', 'HOME']:
			plugins.add('logselected')
		try:
			for win in reversed(self.windows):
				ret = win.eventhandler(event)
				log.debug('%s -> %s -> %s', event, win, ret)
				if ret is True:
					if ret is None: # TODO: Why ?!?
						log.warn('EventHandlers should not return None, use True instead !!')
					return True
			for m in reversed(self.menus_stack):
				ret = m.eventhandler(event)
				log.debug('%s -> %s -> %s', event, m, ret)
				if ret is True:
					if ret is None: # TODO: Why ?!?
						log.warn('EventHandlers should not return None, use True instead !!')
					return True
		except Exception:
			PRINT_EXCEPTION()
		return None

	# Add window in view data structures
	def add_window(self, window):
		self.windows.append(window)
		for engine in self.engines:
			engine.add_window(window)
		return None

	# Remove window from window list and reset the focus
	def remove_window(self, window):
		try:
			self.windows.remove(window)
		except:
			pass
		for engine in self.engines:
			try:
				engine.remove_window(window)
			except:
				pass
		return None

	def update_window(self, win):
		for engine in self.engines:
			engine.update_window(win)
		return None

	# Add a new Menu in the controler stack and in view lists
	# Handle 'groupeable' Menu (see /menu/menu/core.py)
	def push_menu(self, menu, hide_previous_menu=True):
		try:
			if menu.groupeable:
				self.menus_stack[-1].grouped_menu = True
				menu.toggleable = False
		except AttributeError:
			pass
		self.menus_stack.push_menu(menu)
		for engine in self.engines:
			engine.push_menu(menu, hide_previous_menu)
		return None

	# Go back to the specified menu. All menus on top of it are discarded.
	# If menu is None (default) , go back to the home menu.
	# (@see MenuStack.back_to_menu for more technical details)
	def back_to_menu(self, menu=None, refresh=True):
		if menu is None:
			win_to_remove = []
			for i, w in enumerate(self.windows):
				persistent = getattr(w, 'persistent', False)
				if not persistent:
					win_to_remove.append(i)
			for rank in reversed(win_to_remove):
				win = self.windows.pop(rank)
				for engine in self.engines:
					engine.remove_window(win)
		if self.menus_stack.back_to_menu(menu):
			for engine in self.engines:
				engine.back_to_menu(menu)
		return None

	def back_one_menu(self, refresh=True):
		self.menus_stack.back_one_menu(refresh)
		for engine in self.engines:
			engine.back_one_menu()
		return None

	def is_on_top(self, player):
		try:
			idx = self.menus_stack.index(player)
			return all((m.groupeable for m in self.menus_stack[idx + 1:]))
		except Exception, e:
#			PRINT_EXCEPTION(e)
			return False

	def bubble_raise(self, player):
		for i in self.menus_stack:
			if self.is_on_top(player):
				return True
			self.toggle()
		return False

	# Retrieve in the stack the lengths of the 2 groups of menu
	# the first from the first menu to toggle
	# the second from the last menu to toggle
	# lengths can be 0
	def _get_groups(self, first, last):
		groups = [0, 0]
		ms = self.menus_stack
		ms_len = len(ms)
		while first + groups[0] < last and ms[first + groups[0]].grouped_menu:
			groups[0] += 1
		while last + groups[1] < ms_len and ms[last + groups[1]].grouped_menu:
			groups[1] += 1
		return groups

	# Aka. 'Alt-Tab'
	# Swap the two first toggleable menu (and these that are grouped with them)
	# found in controler stack. Grouped menus are kept well-ordered.
	# Swapping is performed in controler stack and view lists
	def toggle(self):
		ms = self.menus_stack
		toggling_list = []
		for i, m in enumerate(ms):
			if m.toggleable:
				toggling_list.append(i)
		if len(toggling_list) > 1:
			first, last = toggling_list[0], toggling_list[-1]
			group_first, group_last = self._get_groups(first, last)
			ms[first].on_foreground()
			ms[last].on_background()
			for engine in chain((ms,), self.engines):
				engine.swap(first, last, group_first, group_last)
			return True
		return False

	# Swap positions between NotebookMenu and the selected NotebookSubMenu
	def swap_notebook_page(self):
		ms = self.menus_stack
		top_rank = len(ms) - 1
		for engine in chain((ms,), self.engines):
			engine.swap(top_rank - 1, top_rank)
		return None

	# Replace the current sub menu with menu in parameters in the stack and in all engines
	# The insertion is mainly made for Notebook menu. So sub menu is kept just
	# below the notebook
	def switch_sub_menu(self, menu, pos):
		for engine in chain((self.menus_stack,), self.engines):
			engine.switch_sub_menu(menu, pos)
		return None

	# Return the first instance of 'Navigator' found in controler stack (in reverse order),
	# or None if no 'Navigator'
	def get_navigator(self):
		from pygui.menu.menu import Navigator, MarkerNavigator, ThumbnailNavigator
		for probable_nav in reversed(self.menus_stack):
			if isinstance(probable_nav, (Navigator, ThumbnailNavigator)) and not isinstance(probable_nav, MarkerNavigator):
				return probable_nav
		return None

	# Return Home menu if it's just over the RootMenu
	# None is returned if it is in an other position (switcher mode)
	def get_home(self):
		try:
			if self.menus_stack[1].type in ('main', 'switcher'):
				return self.menus_stack[1]
			return None
		except:
			return None
		return None

	# Return Root menu
	def get_root(self):
		return self.menus_stack[0]

	# Return the instance of 'Player' found in controler stack (in reverse order),
	# or None if no 'Player'
	def get_player(self, type=None):
		from pygui.menu.players.core import Player
		for some_menu in self.menus_stack:
			if isinstance(some_menu, Player):
				if type is None:
					return some_menu
				elif 'audio' in type and some_menu.type == 'audioplayer':
					return some_menu
				elif 'video' in type and some_menu.type == 'videoplayer':
					return some_menu
		return None

	# Return to the Home menu or Root menu if there is no Home (switcher mode)
	# if safe == True: push HomeMenu over RootMenu if needed
	def back_to_home(self, safe=True):
		home = self.get_home()
		self.back_to_menu(home)
		self.get_root().active_univ = None
		if safe and not home:
			from pygui.menu.menu import HomeMenu
			HomeMenu().show()
		return None

	# Return to the first navigator in the stack (in reverse order),
	# if available. Otherwise, do nothing.
	def back_to_navigator(self):
		nav = self.get_navigator()
		if nav:
			self.back_to_menu(nav)
		return None

	# Return to the first player in the stack (in reverse order),
	# if available. Otherwise, do nothing.
	def back_to_player(self):
		player = self.get_player()
		if player:
			self.back_to_menu(player)
		return None

	# Pop the player (passed as parameter or auto-detected) in menustack
	# and all grouped menu with it
	# Purge the grouped_menu attribute if necessary
	def close_player(self, player=None, type=None):
		ms = self.menus_stack
		if player is None:
			player = self.get_player(type)
		try:
			rank_min = ms.index(player)
		except:
			rank_min = None
		if player and rank_min is not None:
			ms = self.menus_stack
			if ms[rank_min].grouped_menu:
				ms[rank_min].grouped_menu = False
				i = 1
				while True:
					if not ms[rank_min + i].grouped_menu:
						break
					ms[rank_min + 1].grouped_menu = False
					i += 1
				rank_max = rank_min + i
			else:
				rank_max = rank_min
			for menu in chain((ms,), self.engines):
				menu.pop_group(rank_min, rank_max - rank_min)
		else:
			log.warning('No player (%s) is found.', player)
		return None

	# Return True if a firstboot menu is detected else False
	def is_on_firstboot(self):
		from pygui.menu.menu.firstboot import FirstBootMenu
		for m in self.menus_stack:
			if isinstance(m, FirstBootMenu):
				return m
		return False



# The MenuStack handles a stack of Menus
class MenuStack(list):

	instances_counter = 0

	def __init__(self):
		if MenuStack.instances_counter != 0:
			raise RuntimeError('MenuStack is a singleton !')
		MenuStack.instances_counter += 1
		list.__init__(self)
		return None

	def refresh_top(self):
		self[-1].reload_func()
		return None

	# Move the element at index i2 to index i1, with len_group_last
	# elements after i2 (they are still following i2),
	# shifting the parts of the stack that are between i1 and i2 right.
	# Assumes i2 >= i1; if not, i1 and i2 are inverted.
  # 
	# Examples:
	# [a, b, c, d].swap(0, 2, 0, 0) => [c, a, b, d]
	# [a, b, c, d].swap(0, 2, 0, 1) => [c, d, a, b]
	# [a, b, c, d].swap(0, 1, 0, 2) => [b, c, d, a]
	# """
	def swap(self, i1, i2, len_group_first=0, len_group_last=0):
		if i1 > i2:
			i1, i2 = i2, i1
		list.insert(self, i1, list.pop(self, i2))
		for i in xrange(len_group_last):
			list.insert(self, i1 + 1 + i, list.pop(self, i2 + 1 + i))
		return None

	def pop(self, idx=-1):
		old_menu = list.pop(self, idx)
		if hasattr(old_menu, 'stop'):
			try:
				old_menu.stop()
			except Exception, e:
				log.debug('stop() of %s failed: %s', old_menu, e)
		return old_menu

	# Pop range elements from the rank index in the stack
	# Always remove the element at rank index
	def pop_group(self, rank, range):
		for i in xrange(1 + range):
			self.pop(rank)
		self.refresh_top()
		return None

	# Go back to menu, discarding the menus on top of it from the stack.
	# 
	# This method can't pop the last menu off the stack (IOW, it ensures at
	# least one menu remains in the stack : the RootMenu), and no checks are performed that
	# menu *is* in the stack at all before starting the operation.
	# 
	# Therefore, if the given menu is None,
	# it will return to the bottom-most menu in the stack (home menu)
	def back_to_menu(self, menu):
		changed = False
		while len(self) > 1 and self[-1] != menu:
			self.back_one_menu()
			changed = True
		return changed

	# Go back one menu page
	def back_one_menu(self, refresh=True):
		if len(self) > 1:
			self.pop()
			if refresh:
				self.refresh_top()
			if self[-1].grouped_menu:
				self[-1].grouped_menu = False
		else:
			log.warn('Nothing in menu stack!')
		return None

	# Add a new Menu to the stack and show it
	def push_menu(self, menu):
		self.append(menu)
		return None

	# Replace the current page (sub menu) with new one
	def switch_sub_menu(self, menu, pos):
		self[pos] = menu
		return None

	def eventhandler(self, event):
		return self[-1].eventhandler(event)
