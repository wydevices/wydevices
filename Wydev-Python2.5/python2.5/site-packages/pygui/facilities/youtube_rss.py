# -*- coding: utf-8 -*- 
#
# Description:
#
# Youtube Gdata Class Definiton
#
#
#
# Changes:
#
# 2010-10-10
# Fix Summer 2010 video URL modification.
#
# 2011-09-19
# Fix Summer 2011 video URL modification.
#
# 2011-09-24
# Modify video format choice to match the WyBox codecs restrictions.
# Add default language for search using user_config.
#
# 2011-10-18
# Add video format choice.
# Allow to select format of each video with Hand in Youtube Menu.
#
# 2011-12-13
# Modify the video format choice algorithm.
# See User_config choice.
#
# 2012-01-06
# Add Youtube playlist handling.
# Retrive playlist from a given username
#
# 2012-01-25
# Add playlist thumbnail
#
# 2012-10-04
# Fix September 2012 video URL modification.
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
# Parts taken from 'youtube-dl' : https://github.com/rg3/youtube-dl
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.


__all__ = ['YoutubeData']

import urllib
import urllib2
import httplib
import socket
import re
import os
import string
import datetime

try:
	from urlparse import parse_qs
except ImportError:
	from cgi import parse_qs

from peewee.misc_utils import MetaSingleton
from pygui.config import user_config
from pygui.window import MessageWindow


class YoutubeData(object):

	__module__ = __name__
	__metaclass__ = MetaSingleton


	_standard_feeds = ('top_rated', 'top_favorites', 'most_viewed', 'most_shared', 'most_popular', 'most_recent', 'most_discussed', 'most_responded', 'recently_featured', 'on_the_web')
	_standard_feeds_name = ('Top rated', 'Top favorites', 'Most viewed', 'Most shared', 'Most popular', 'Most recent', 'Most discussed', 'Most responded', 'Recently featured', 'Trending videos')


	def __init__(self):
		import gdata.service
		self.timestamp = datetime.datetime.now()
		self.service = gdata.service.GDataService(server='gdata.youtube.com')
		self.url_open = None
		return None

	def must_be_refresh(self):
		delta = datetime.datetime.now() - self.timestamp
		limit = user_config['video']['youtube_refresh_rate'] * 60
		if delta.seconds > limit:
			return True
		else:
			return False

	def _get_flv_uri(self, player_url, choosen_format):
		_VALID_URL = r'^((?:https?://)?(?:youtu\.be/|(?:\w+\.)?youtube(?:-nocookie)?\.com/)(?!view_play_list|my_playlists|artist|playlist)(?:(?:(?:v|embed|e)/)|(?:(?:watch(?:_popup)?(?:\.php)?)?(?:\?|#!?)(?:.+&)?v=))?)?([0-9A-Za-z_-]+)(?(1).+)?$'

		"""
		|---------------------------------------------------------------------------------------------------------------|
		|                                       Youtube available formats table                                         |
		|---------------------------------------------------------------------------------------------------------------|
		| Format codes              |   5   |  6   | 34|   35  |   18   |   22  |   37  | 38 | 43| 44| 45 |  13  |  17  |
		|---------------------------------------------------------------------------------------------------------------|
		| Container                 |             FLV          |              MP4            |    WebM    |     3GP     |
		|---------------------------------------------------------------------------------------------------------------|
		|       |Encoding           |Sorenson H.263|              MPEG-4 AVC (H.264)         |     VP8    |MPEG-4 Visual|
		|       |-------------------------------------------------------------------------------------------------------|
		|       |Profile            |      –       |    Main   |Baseline|        High        |     –      |      –      |
		|       |-------------------------------------------------------------------------------------------------------|
		| Video |Max width (pixels) |  400  | 448  |640|  854  |   640  | 1280  |  1920 |4096|640|854|1280|     176     |
		|       |-------------------------------------------------------------------------------------------------------|
		|       |Max height (pixels)|  240  | 336  |360|  480  |   360  |  720  |  1080 |3072|360|480| 720|     144     |
		|       |-------------------------------------------------------------------------------------------------------|
		|       |Bitrate (Mbit/s)   | 0.25  | 0.8  |0.5|0.8–1.0|   0.5  |2.0–2.9|3.5–5.0|  – |0.5| 1 |  2 |      –      |
		|-------|-------------------------------------------------------------------------------------------------------|
		|       |Encoding           |  MP3         |                  AAC                    |    Vorbis  |     AAC     |
		|       |-------------------------------------------------------------------------------------------------------|
		|       |Channels           |  1–2         |                          2 (stereo)                         | 1-2  |
		|       |-------------------------------------------------------------------------------------------------------|
		| Audio |Sampling rate (Hz) | 22050 |                                    44100                                  |
		|       |-------------------------------------------------------------------------------------------------------|
		|       |Bitrate (kbit/s)   |  64   |  96  |    128    |   96   |       152          |  128  | 192|      –      |
		|---------------------------------------------------------------------------------------------------------------|
		"""

		# Youtube formats in order of quality and compatible with our WyBox
		youtube_formats = ['38', '37', '22', '18', '13', '17']

		# Remove &feature=youtube_gdata_player from player url
#		if "&feature=youtube_gdata_player" in player_url:
#			player_url = player_url.replace("&feature=youtube_gdata_player", "")

		# Extract video id from URL
		mobj = re.match(_VALID_URL, player_url)
		if mobj is not None:
			video_id = mobj.group(2)
		else:
			MessageWindow(('ERROR: invalid URL: %s' % player_url)).show()
			return ('', 0, [])

		# Get video infos
		for el_type in ['&el=embedded', '&el=detailpage', '&el=vevo', '']:
			video_info_url = ('http://www.youtube.com/get_video_info?&video_id=%s%s&ps=default&eurl=&gl=US&hl=en' % (video_id, el_type))
			request = urllib2.Request(video_info_url)
			try:
				video_info_webpage = urllib2.urlopen(request).read()
				video_info = parse_qs(video_info_webpage)
				if 'token' in video_info:
					break
			except (urllib2.URLError, httplib.HTTPException, socket.error), err:
				MessageWindow(('ERROR: unable to download video info webpage: %s' % str(err))).show()
				return ('', 0, [])

		# Get video token
		if 'token' not in video_info:
			if 'reason' in video_info:
				MessageWindow(('ERROR: YouTube said: %s' % video_info['reason'][0].decode('utf-8'))).show()
			else:
				MessageWindow('ERROR: "token" parameter not in video info for unknown reason').show()
			return ('', 0, [])
		else:
			video_token = urllib.unquote_plus(video_info['token'][0])

		# Get video real url
		if 'url_encoded_fmt_stream_map' in video_info and len(video_info['url_encoded_fmt_stream_map']) >= 1:
			url_data_strs = video_info['url_encoded_fmt_stream_map'][0].split(',')
			url_data = [parse_qs(uds) for uds in url_data_strs]
			url_data = filter(lambda ud: 'itag' in ud and 'url' in ud, url_data)
			url_map = dict((ud['itag'][0], ud['url'][0] + '&signature=' + ud['sig'][0]) for ud in url_data)
			available_formats = [int(x) for x in youtube_formats if x in url_map]
			if len(available_formats) == 0:
				MessageWindow('ERROR: no known formats available for video').show()
				return ('', 0, [])
			if choosen_format == 0: # User_config choice.
				# Little algo to choose the format. xD
				# Try user_config['video']['youtube_formats'], then -1 in youtube_formats, then +1, then -2, then +2, ...
				# Exemple 1:
				# youtube_formats = ['38', '37', '22', '18', '13', '17']
				# user_config['video']['youtube_formats'] = 18
				# check_formats = ['18', '22', '13', '37', '17', '38']
				# Exemple 2:
				# user_config['video']['youtube_formats'] = 22
				# check_formats = ['22', '37', '18', '38', '13', '37']
				index = 0
				count = 1
				even_odd = False
				user_fmt_index = youtube_formats.index(str(user_config['video']['youtube_formats']))
				check_formats = [youtube_formats[user_fmt_index]]
				# Build the check list
				for x in xrange(len(youtube_formats)-1):
					if even_odd == False:
						index = user_fmt_index - count
						if index < 0:
							index = user_fmt_index + count
							count += 1
						even_odd = True
					elif even_odd == True:
						index = user_fmt_index + count
						if index > len(youtube_formats)-1:
							count += 1
							index = user_fmt_index - count
						count += 1
						even_odd = False
					check_formats.append(youtube_formats[index])
				# Choose the appropriated video format
				for check_fmt in check_formats:
					if int(check_fmt) in available_formats:
						choosen_format = int(check_fmt)
						video_real_url = url_map[check_fmt] # User choice format
						break
				else:
					MessageWindow('ERROR: Enable to select video format').show()
					return ('', 0, [])
			else: # Hand menu choice
				video_real_url = url_map[str(choosen_format)]
		elif 'conn' in video_info and video_info['conn'][0].startswith('rtmp'):
			video_real_url = video_info['conn'][0] # Real Time Messaging Protocol
			choosen_format = 0
			available_formats = []
		else:
			MessageWindow('ERROR: no conn or url_encoded_fmt_stream_map information found in video info').show()
			return ('', 0, [])
		return (video_real_url, choosen_format, available_formats)

	def _get_entries(self, path):
		return self.service.Get(('/feeds/api/' + path)).entry

	def _get_dict_from_entry(self, e):
		group_ext = e.FindExtensions(tag='group')[0]
		try:
			view_count = e.FindExtensions(tag='statistics')[0].attributes['viewCount']
		except IndexError:
			view_count = 'NA'
		try:
			rating_ext = e.FindExtensions(tag='rating')[0].attributes['average']
		except IndexError:
			rating_ext = 0
		return dict(title=group_ext.FindChildren(tag='title')[0].text, thumbnail=group_ext.FindChildren(tag='thumbnail')[0].attributes['url'], player_url=group_ext.FindChildren(tag='player')[0].attributes['url'], uri=(lambda uri=group_ext.FindChildren(tag='player')[0].attributes['url']: self._get_flv_uri(uri, 0)), view_count=view_count, rating=rating_ext, description='')

	def simple_search(self, name):
		res_list = []
		try:
			for e in self._get_entries('videos/-/' + urllib.quote_plus(name)):
				res_list.append(self._get_dict_from_entry(e))
		except:
			pass
		return res_list

	def search_playlist(self, username=''):
		res_list = []
		root_uri = 'users/' + username + '/playlists?v=2'
		# Perform search
		try:
			for e in self._get_entries(root_uri):
				try:
					res_list.append(dict(title=e.title.text, id=e.FindExtensions(tag='playlistId')[0].text, thumbnail=e.FindExtensions(tag='group')[0].FindChildren(tag='thumbnail')[0].attributes['url']))
				except:
					pass
		except:
			pass
		return res_list

	def parse_playlist(self, id=''):
		res_list = []
		root_uri = 'playlists/' + id + '?v=2'
		# Perform parsing
		try:
			for e in self._get_entries(root_uri):
				try:
					res_list.append(self._get_dict_from_entry(e))
				except:
					pass
		except:
			pass
		return res_list

	def search_feed(self, feed=0, lang='', orderby='relevance', start_idx=1, max_res=50):
		params = {}
		res_list = []

		# Parse options
		if start_idx <= 0:
			params['start-index'] = 1
		else:
			params['start-index'] = start_idx
		if max_res >= 50:
			params['max-results'] = 50
		elif max_res <= 0:
			params['max-results'] = 1
		else:
			params['max-results'] = max_res
		params['orderby'] = orderby

		root_uri = 'standardfeeds/' + self._standard_feeds[feed]

		# Perform search
		try:
			for e in self._get_entries(  '%s?%s' % ( root_uri, urllib.urlencode(params) )  ):
				try:
					noembed = e.FindExtensions(tag='noembed')[0]
				except IndexError:
					try:
						res_list.append(self._get_dict_from_entry(e))
					except:
						pass
		except:
			pass
		return res_list

	def search_video(self, video='', lang='', orderby='relevance', start_idx=1, max_res=50):
		params = {}
		res_list = []

		# Parse options
		if start_idx <= 0:
			params['start-index'] = 1
		else:
			params['start-index'] = start_idx
		if max_res >= 50:
			params['max-results'] = 50
		elif max_res <= 0:
			params['max-results'] = 1
		else:
			params['max-results'] = max_res
		params['orderby'] = orderby

		root_uri = 'videos'
		params['vq'] = video
		params['lr'] = lang
		if lang == 'en':
			lang = 'gb'
		params['restriction'] = lang.upper()

		# Perform search
		try:
			for e in self._get_entries(  '%s?%s' % ( root_uri, urllib.urlencode(params) )  ):
				try:
					noembed = e.FindExtensions(tag='noembed')[0]
				except IndexError:
					try:
						res_list.append(self._get_dict_from_entry(e))
					except:
						pass
		except:
			pass
		return res_list



if (__name__ == '__main__'):
	import sys
	ytd = YoutubeData()
# Search Playlist
#	for e in ytd.search_playlist(username='polo35580'):
#		print e
#		for e2 in ytd.parse_playlist(id=e.get('id')):
#			print e2
# Search Feed
#	for e in ytd.search_feed(1, lang=user_config['video']['youtube_languages'], max_res=2, orderby='rating'):
#		print 'RESULT:'
#		print ('%(title)s / rated: %(rating)s / viewed: %(view_count)s' % e)
#		print 'DATA:'
#		print e
#		print 'URI:'
#		print e['uri']()
#		print ('#' * 80)
#	Search video
	for e in ytd.search_video('David Guetta', lang=user_config['video']['youtube_languages'], max_res=2, orderby='rating'):
		print 'RESULT:'
		print ('%(title)s / rated: %(rating)s / viewed: %(view_count)s' % e)
		print 'DATA:'
		print e
		print 'URI:'
		print e['uri']()
		print ('#' * 80)
