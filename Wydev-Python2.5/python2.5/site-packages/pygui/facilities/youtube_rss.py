# -*- coding: utf-8 -*- 
#
# Description:
#
# Youtube Gdata Class Definition
#
#
#
# Changes:
#
# 2010-10-10
# Fix Summer 2010 video URL modification.
#
# 2011-09-19
# Fix Summer 2011 video URL modification.
#
# 2011-09-24
# Modify video format choice to match the WyBox codecs restrictions.
# Add default language for search using user_config.
#
# 2011-10-18
# Add video format choice.
# Allow to select format of each video with Hand in Youtube Menu.
#
# 2011-12-13
# Modify the video format choice algorithm.
# See User_config choice.
#
# 2012-01-06
# Add Youtube playlist handling.
# Retrive playlist from a given username
#
# 2012-01-25
# Add playlist thumbnail
#
# 2012-10-04
# Fix September 2012 video URL modification.
#
# 2014-04-15
# Fix video URL modification.
# Add signature decryption algo from youtube-dl
#
#
# Copyright 2010-2014, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
# Parts taken from 'youtube-dl' : https://github.com/rg3/youtube-dl
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

__all__ = ['YoutubeData']

import urllib
import urllib2
import httplib
import socket
import struct
import re
import os
import string
import datetime
import zlib
import codecs

try:
	from urlparse import parse_qs
except ImportError:
	from cgi import parse_qs

import simplejson as json

from peewee.misc_utils import MetaSingleton
from pygui.config import user_config
from pygui.window import MessageWindow


class JSInterpreter(object):

	def __init__(self, code):
		self.code = code
		self._functions = {}

	def interpret_statement(self, stmt, local_vars, allow_recursion=20):
		if allow_recursion < 0:
			raise Exception('Recursion limit reached')

		if stmt.startswith('var '):
			stmt = stmt[len('var '):]
		ass_m = re.match(r'^(?P<out>[a-z]+)(?:\[(?P<index>[^\]]+)\])?' +
						 r'=(?P<expr>.*)$', stmt)
		if ass_m:
			if ass_m.groupdict().get('index'):
				def assign(val):
					lvar = local_vars[ass_m.group('out')]
					idx = self.interpret_expression(
						ass_m.group('index'), local_vars, allow_recursion)
					assert isinstance(idx, int)
					lvar[idx] = val
					return val
				expr = ass_m.group('expr')
			else:
				def assign(val):
					local_vars[ass_m.group('out')] = val
					return val
				expr = ass_m.group('expr')
		elif stmt.startswith('return '):
			assign = lambda v: v
			expr = stmt[len('return '):]
		else:
			raise Exception( 'Cannot determine left side of statement in %r' % stmt)

		v = self.interpret_expression(expr, local_vars, allow_recursion)
		return assign(v)

	def interpret_expression(self, expr, local_vars, allow_recursion):
		if expr.isdigit():
			return int(expr)

		if expr.isalpha():
			return local_vars[expr]

		m = re.match(r'^(?P<in>[a-z]+)\.(?P<member>.*)$', expr)
		if m:
			member = m.group('member')
			val = local_vars[m.group('in')]
			if member == 'split("")':
				return list(val)
			if member == 'join("")':
				return u''.join(val)
			if member == 'length':
				return len(val)
			if member == 'reverse()':
				return val[::-1]
			slice_m = re.match(r'slice\((?P<idx>.*)\)', member)
			if slice_m:
				idx = self.interpret_expression(
					slice_m.group('idx'), local_vars, allow_recursion - 1)
				return val[idx:]

		m = re.match(
			r'^(?P<in>[a-z]+)\[(?P<idx>.+)\]$', expr)
		if m:
			val = local_vars[m.group('in')]
			idx = self.interpret_expression(
				m.group('idx'), local_vars, allow_recursion - 1)
			return val[idx]

		m = re.match(r'^(?P<a>.+?)(?P<op>[%])(?P<b>.+?)$', expr)
		if m:
			a = self.interpret_expression(
				m.group('a'), local_vars, allow_recursion)
			b = self.interpret_expression(
				m.group('b'), local_vars, allow_recursion)
			return a % b

		m = re.match(
			r'^(?P<func>[a-zA-Z$]+)\((?P<args>[a-z0-9,]+)\)$', expr)
		if m:
			fname = m.group('func')
			if fname not in self._functions:
				self._functions[fname] = self.extract_function(fname)
			argvals = [int(v) if v.isdigit() else local_vars[v]
						 for v in m.group('args').split(',')]
			return self._functions[fname](argvals)
		raise Exception('Unsupported JS expression %r' % expr)

	def extract_function(self, funcname):
		func_m = re.search(
			(r'(?:function %s|%s\s*=\s*function)' % (
				re.escape(funcname), re.escape(funcname))) +
			r'\((?P<args>[a-z,]+)\){(?P<code>[^}]+)}',
			self.code)
		if func_m is None:
			raise Exception('Could not find JS function %r' % funcname)
		argnames = func_m.group('args').split(',')

		def resf(args):
			local_vars = dict(zip(argnames, args))
			for stmt in func_m.group('code').split(';'):
				res = self.interpret_statement(stmt, local_vars)
			return res
		return resf



class YoutubeData(object):

	__module__ = __name__
	__metaclass__ = MetaSingleton

	_standard_feeds = ('top_rated', 'top_favorites', 'most_viewed', 'most_shared', 'most_popular', 'most_recent', 'most_discussed', 'most_responded', 'recently_featured', 'on_the_web')
	_standard_feeds_name = ('Top rated', 'Top favorites', 'Most viewed', 'Most shared', 'Most popular', 'Most recent', 'Most discussed', 'Most responded', 'Recently featured', 'Trending videos')
	_std_headers = {'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64; rv:10.0) Gecko/20100101 Firefox/10.0 (Chrome)', 'Accept-Charset': 'ISO-8859-1,utf-8;q=0.7,*;q=0.7', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8', 'Accept-Language': 'en-us,en;q=0.5',}

	def __init__(self):
		import gdata.service
		self.timestamp = datetime.datetime.now()
		self.service = gdata.service.GDataService(server='gdata.youtube.com')
		self.url_open = None
		self._player_cache = {}
		return None

	def must_be_refresh(self):
		delta = datetime.datetime.now() - self.timestamp
		limit = user_config['video']['youtube_refresh_rate'] * 60
		if delta.seconds > limit:
			return True
		else:
			return False

	def _extract_signature_function(self, video_id, player_url, slen):
		id_m = re.match(r'.*-(?P<id>[a-zA-Z0-9_-]+)\.(?P<ext>[a-z]+)$', player_url)
		player_type = id_m.group('ext')
		# Read from filesystem cache
#		func_id = '%s_%s_%d' % (player_type, player_id, slen)
#		assert os.path.basename(func_id) == func_id
#		cache_dir = get_cachedir(self._downloader.params)

#		cache_enabled = cache_dir is not None
#		if cache_enabled:
#			cache_fn = os.path.join(os.path.expanduser(cache_dir),
#									u'youtube-sigfuncs',
#									func_id + '.json')
#			try:
#				with io.open(cache_fn, 'r', encoding='utf-8') as cachef:
#					cache_spec = json.load(cachef)
#				return lambda s: u''.join(s[i] for i in cache_spec)
#			except IOError:
#				pass	# No cache available
		request = urllib2.Request(player_url)
		code = urllib2.urlopen(request).read()
		if player_type == 'js':
			res = self._parse_sig_js(code)
		elif player_type == 'swf':
			res = self._parse_sig_swf(code)
		else:
			res = ''
#		if cache_enabled:
#			try:
#				test_string = u''.join(map(unichr, range(slen)))
#				cache_res = res(test_string)
#				cache_spec = [ord(c) for c in cache_res]
#				try:
#					os.makedirs(os.path.dirname(cache_fn))
#				except OSError as ose:
#					if ose.errno != errno.EEXIST:
#						raise
#				write_json_file(cache_spec, cache_fn)
#			except Exception:
#				tb = traceback.format_exc()
#				self._downloader.report_warning(
#					u'Writing cache to %r failed: %s' % (cache_fn, tb))
		return res

	def _print_sig_code(self, func, slen):
		def gen_sig_code(idxs):
			def _genslice(start, end, step):
				starts = u'' if start == 0 else str(start)
				ends = (u':%d' % (end+step)) if end + step >= 0 else u':'
				steps = u'' if step == 1 else (u':%d' % step)
				return u's[%s%s%s]' % (starts, ends, steps)
			step = None
			start = '(Never used)'	# Quelch pyflakes warnings - start will be
									# set as soon as step is set
			for i, prev in zip(idxs[1:], idxs[:-1]):
				if step is not None:
					if i - prev == step:
						continue
					yield _genslice(start, prev, step)
					step = None
					continue
				if i - prev in [-1, 1]:
					step = i - prev
					start = prev
					continue
				else:
					yield u's[%d]' % prev
			if step is None:
				yield u's[%d]' % i
			else:
				yield _genslice(start, i, step)
		test_string = u''.join(map(unichr, range(slen)))
		cache_res = func(test_string)
		cache_spec = [ord(c) for c in cache_res]
		expr_code = u' + '.join(gen_sig_code(cache_spec))
		code = u'if len(s) == %d:\n	return %s\n' % (slen, expr_code)
		print 'Extracted signature function:\n' + code

	def _parse_sig_js(self, jscode):
		mobj = re.search( r'signature=([a-zA-Z]+)', jscode)
		if mobj:
			funcname = (g for g in mobj.groups() if g is not None).next()
		jsi = JSInterpreter(jscode)
		initial_function = jsi.extract_function(funcname)
		return lambda s: initial_function([s])

	def _parse_sig_swf(self, file_contents):
		if file_contents[1:3] != 'WS':
			raise Exception( u'Not an SWF file; header is %r' % file_contents[:3])
		if file_contents[:1] == 'C':
			content = zlib.decompress(file_contents[8:])
		else:
			raise NotImplementedError(u'Unsupported compression format %r' % file_contents[:1])

		def extract_tags(content):
			pos = 0
			while pos < len(content):
				header16 = struct.unpack('<H', content[pos:pos+2])[0]
				pos += 2
				tag_code = header16 >> 6
				tag_len = header16 & 0x3f
				if tag_len == 0x3f:
					tag_len = struct.unpack('<I', content[pos:pos+4])[0]
					pos += 4
				assert pos+tag_len <= len(content)
				yield (tag_code, content[pos:pos+tag_len])
				pos += tag_len

		code_tag = next(tag
						for tag_code, tag in extract_tags(content)
						if tag_code == 82)
		p = code_tag.index('\0', 4) + 1
		code_reader = io.BytesIO(code_tag[p:])

		# Parse ABC (AVM2 ByteCode)
		def read_int(reader=None):
			if reader is None:
				reader = code_reader
			res = 0
			shift = 0
			for _ in range(5):
				buf = reader.read(1)
				assert len(buf) == 1
				b = struct.unpack('<B', buf)[0]
				res = res | ((b & 0x7f) << shift)
				if b & 0x80 == 0:
					break
				shift += 7
			return res

		def u30(reader=None):
			res = read_int(reader)
			assert res & 0xf0000000 == 0
			return res
		u32 = read_int

		def s32(reader=None):
			v = read_int(reader)
			if v & 0x80000000 != 0:
				v = - ((v ^ 0xffffffff) + 1)
			return v

		def read_string(reader=None):
			if reader is None:
				reader = code_reader
			slen = u30(reader)
			resb = reader.read(slen)
			assert len(resb) == slen
			return resb.decode('utf-8')

		def read_bytes(count, reader=None):
			if reader is None:
				reader = code_reader
			resb = reader.read(count)
			assert len(resb) == count
			return resb

		def read_byte(reader=None):
			resb = read_bytes(1, reader=reader)
			res = struct.unpack('<B', resb)[0]
			return res

		# minor_version + major_version
		read_bytes(2 + 2)

		# Constant pool
		int_count = u30()
		for _c in range(1, int_count):
			s32()
		uint_count = u30()
		for _c in range(1, uint_count):
			u32()
		double_count = u30()
		read_bytes((double_count-1) * 8)
		string_count = u30()
		constant_strings = [u'']
		for _c in range(1, string_count):
			s = read_string()
			constant_strings.append(s)
		namespace_count = u30()
		for _c in range(1, namespace_count):
			read_bytes(1)	# kind
			u30()	# name
		ns_set_count = u30()
		for _c in range(1, ns_set_count):
			count = u30()
			for _c2 in range(count):
				u30()
		multiname_count = u30()
		MULTINAME_SIZES = {
			0x07: 2,	# QName
			0x0d: 2,	# QNameA
			0x0f: 1,	# RTQName
			0x10: 1,	# RTQNameA
			0x11: 0,	# RTQNameL
			0x12: 0,	# RTQNameLA
			0x09: 2,	# Multiname
			0x0e: 2,	# MultinameA
			0x1b: 1,	# MultinameL
			0x1c: 1,	# MultinameLA
		}
		multinames = [u'']
		for _c in range(1, multiname_count):
			kind = u30()
			assert kind in MULTINAME_SIZES, u'Invalid multiname kind %r' % kind
			if kind == 0x07:
				u30()	# namespace_idx
				name_idx = u30()
				multinames.append(constant_strings[name_idx])
			else:
				multinames.append('[MULTINAME kind: %d]' % kind)
				for _c2 in range(MULTINAME_SIZES[kind]):
					u30()

		# Methods
		method_count = u30()
		MethodInfo = collections.namedtuple(
			'MethodInfo',
			['NEED_ARGUMENTS', 'NEED_REST'])
		method_infos = []
		for method_id in range(method_count):
			param_count = u30()
			u30()	# return type
			for _ in range(param_count):
				u30()	# param type
			u30()	# name index (always 0 for youtube)
			flags = read_byte()
			if flags & 0x08 != 0:
				# Options present
				option_count = u30()
				for c in range(option_count):
					u30()	# val
					read_bytes(1)	# kind
			if flags & 0x80 != 0:
				# Param names present
				for _ in range(param_count):
					u30()	# param name
			mi = MethodInfo(flags & 0x01 != 0, flags & 0x04 != 0)
			method_infos.append(mi)

		# Metadata
		metadata_count = u30()
		for _c in range(metadata_count):
			u30()	# name
			item_count = u30()
			for _c2 in range(item_count):
				u30()	# key
				u30()	# value

		def parse_traits_info():
			trait_name_idx = u30()
			kind_full = read_byte()
			kind = kind_full & 0x0f
			attrs = kind_full >> 4
			methods = {}
			if kind in [0x00, 0x06]:	# Slot or Const
				u30()	# Slot id
				u30()	# type_name_idx
				vindex = u30()
				if vindex != 0:
					read_byte()	# vkind
			elif kind in [0x01, 0x02, 0x03]:	# Method / Getter / Setter
				u30()	# disp_id
				method_idx = u30()
				methods[multinames[trait_name_idx]] = method_idx
			elif kind == 0x04:	# Class
				u30()	# slot_id
				u30()	# classi
			elif kind == 0x05:	# Function
				u30()	# slot_id
				function_idx = u30()
				methods[function_idx] = multinames[trait_name_idx]
			else:
				raise Exception(u'Unsupported trait kind %d' % kind)

			if attrs & 0x4 != 0:	# Metadata present
				metadata_count = u30()
				for _c3 in range(metadata_count):
					u30()	# metadata index

			return methods

		# Classes
		TARGET_CLASSNAME = u'SignatureDecipher'
		searched_idx = multinames.index(TARGET_CLASSNAME)
		searched_class_id = None
		class_count = u30()
		for class_id in range(class_count):
			name_idx = u30()
			if name_idx == searched_idx:
				# We found the class we're looking for!
				searched_class_id = class_id
			u30()	# super_name idx
			flags = read_byte()
			if flags & 0x08 != 0:	# Protected namespace is present
				u30()	# protected_ns_idx
			intrf_count = u30()
			for _c2 in range(intrf_count):
				u30()
			u30()	# iinit
			trait_count = u30()
			for _c2 in range(trait_count):
				parse_traits_info()

		if searched_class_id is None:
			raise Exception(u'Target class %r not found' %
								 TARGET_CLASSNAME)

		method_names = {}
		method_idxs = {}
		for class_id in range(class_count):
			u30()	# cinit
			trait_count = u30()
			for _c2 in range(trait_count):
				trait_methods = parse_traits_info()
				if class_id == searched_class_id:
					method_names.update(trait_methods.items())
					method_idxs.update(dict(
						(idx, name)
						for name, idx in trait_methods.items()))

		# Scripts
		script_count = u30()
		for _c in range(script_count):
			u30()	# init
			trait_count = u30()
			for _c2 in range(trait_count):
				parse_traits_info()

		# Method bodies
		method_body_count = u30()
		Method = collections.namedtuple('Method', ['code', 'local_count'])
		methods = {}
		for _c in range(method_body_count):
			method_idx = u30()
			u30()	# max_stack
			local_count = u30()
			u30()	# init_scope_depth
			u30()	# max_scope_depth
			code_length = u30()
			code = read_bytes(code_length)
			if method_idx in method_idxs:
				m = Method(code, local_count)
				methods[method_idxs[method_idx]] = m
			exception_count = u30()
			for _c2 in range(exception_count):
				u30()	# from
				u30()	# to
				u30()	# target
				u30()	# exc_type
				u30()	# var_name
			trait_count = u30()
			for _c2 in range(trait_count):
				parse_traits_info()

		assert p + code_reader.tell() == len(code_tag)
		assert len(methods) == len(method_idxs)

		method_pyfunctions = {}

		def extract_function(func_name):
			if func_name in method_pyfunctions:
				return method_pyfunctions[func_name]
			if func_name not in methods:
				raise Exception(u'Cannot find function %r' % func_name)
			m = methods[func_name]

			def resfunc(args):
				registers = ['(this)'] + list(args) + [None] * m.local_count
				stack = []
				coder = io.BytesIO(m.code)
				while True:
					opcode = struct.unpack('!B', coder.read(1))[0]
					if opcode == 36:	# pushbyte
						v = struct.unpack('!B', coder.read(1))[0]
						stack.append(v)
					elif opcode == 44:	# pushstring
						idx = u30(coder)
						stack.append(constant_strings[idx])
					elif opcode == 48:	# pushscope
						# We don't implement the scope register, so we'll just
						# ignore the popped value
						stack.pop()
					elif opcode == 70:	# callproperty
						index = u30(coder)
						mname = multinames[index]
						arg_count = u30(coder)
						args = list(reversed(
							[stack.pop() for _ in range(arg_count)]))
						obj = stack.pop()
						if mname == u'split':
							assert len(args) == 1
							assert isinstance(args[0], unicode)
							assert isinstance(obj, unicode)
							if args[0] == u'':
								res = list(obj)
							else:
								res = obj.split(args[0])
							stack.append(res)
						elif mname == u'slice':
							assert len(args) == 1
							assert isinstance(args[0], int)
							assert isinstance(obj, list)
							res = obj[args[0]:]
							stack.append(res)
						elif mname == u'join':
							assert len(args) == 1
							assert isinstance(args[0], unicode)
							assert isinstance(obj, list)
							res = args[0].join(obj)
							stack.append(res)
						elif mname in method_pyfunctions:
							stack.append(method_pyfunctions[mname](args))
						else:
							raise NotImplementedError(
								u'Unsupported property %r on %r'
								% (mname, obj))
					elif opcode == 72:	# returnvalue
						res = stack.pop()
						return res
					elif opcode == 79:	# callpropvoid
						index = u30(coder)
						mname = multinames[index]
						arg_count = u30(coder)
						args = list(reversed(
							[stack.pop() for _ in range(arg_count)]))
						obj = stack.pop()
						if mname == u'reverse':
							assert isinstance(obj, list)
							obj.reverse()
						else:
							raise NotImplementedError(
								u'Unsupported (void) property %r on %r'
								% (mname, obj))
					elif opcode == 93:	# findpropstrict
						index = u30(coder)
						mname = multinames[index]
						res = extract_function(mname)
						stack.append(res)
					elif opcode == 97:	# setproperty
						index = u30(coder)
						value = stack.pop()
						idx = stack.pop()
						obj = stack.pop()
						assert isinstance(obj, list)
						assert isinstance(idx, int)
						obj[idx] = value
					elif opcode == 98:	# getlocal
						index = u30(coder)
						stack.append(registers[index])
					elif opcode == 99:	# setlocal
						index = u30(coder)
						value = stack.pop()
						registers[index] = value
					elif opcode == 102:	# getproperty
						index = u30(coder)
						pname = multinames[index]
						if pname == u'length':
							obj = stack.pop()
							assert isinstance(obj, list)
							stack.append(len(obj))
						else:	# Assume attribute access
							idx = stack.pop()
							assert isinstance(idx, int)
							obj = stack.pop()
							assert isinstance(obj, list)
							stack.append(obj[idx])
					elif opcode == 128:	# coerce
						u30(coder)
					elif opcode == 133:	# coerce_s
						assert isinstance(stack[-1], (type(None), unicode))
					elif opcode == 164:	# modulo
						value2 = stack.pop()
						value1 = stack.pop()
						res = value1 % value2
						stack.append(res)
					elif opcode == 208:	# getlocal_0
						stack.append(registers[0])
					elif opcode == 209:	# getlocal_1
						stack.append(registers[1])
					elif opcode == 210:	# getlocal_2
						stack.append(registers[2])
					elif opcode == 211:	# getlocal_3
						stack.append(registers[3])
					elif opcode == 214:	# setlocal_2
						registers[2] = stack.pop()
					elif opcode == 215:	# setlocal_3
						registers[3] = stack.pop()
					else:
						raise NotImplementedError(
							u'Unsupported opcode %d' % opcode)

			method_pyfunctions[func_name] = resfunc
			return resfunc

		initial_function = extract_function(u'decipher')
		return lambda s: initial_function([s])

	def _decrypt_signature(self, s, video_id, player_url, age_gate=False):
		"""Turn the encrypted s field into a working signature"""

		if player_url is not None:
			if player_url.startswith(u'//'):
				player_url = u'https:' + player_url
			try:
				player_id = (player_url, len(s))
				if player_id not in self._player_cache:
					func = self._extract_signature_function(video_id, player_url, len(s))
					self._player_cache[player_id] = func
				func = self._player_cache[player_id]
#				self._print_sig_code(func, len(s))
				return func(s)
			except Exception:
				pass
		return self._static_decrypt_signature(s, video_id, player_url, age_gate)

	def _static_decrypt_signature(self, s, video_id, player_url, age_gate):
		if age_gate:
			# The videos with age protection use another player, so the
			# algorithms can be different.
			if len(s) == 86:
				return s[2:63] + s[82] + s[64:82] + s[63]

		if len(s) == 93:
			return s[86:29:-1] + s[88] + s[28:5:-1]
		elif len(s) == 92:
			return s[25] + s[3:25] + s[0] + s[26:42] + s[79] + s[43:79] + s[91] + s[80:83]
		elif len(s) == 91:
			return s[84:27:-1] + s[86] + s[26:5:-1]
		elif len(s) == 90:
			return s[25] + s[3:25] + s[2] + s[26:40] + s[77] + s[41:77] + s[89] + s[78:81]
		elif len(s) == 89:
			return s[84:78:-1] + s[87] + s[77:60:-1] + s[0] + s[59:3:-1]
		elif len(s) == 88:
			return s[7:28] + s[87] + s[29:45] + s[55] + s[46:55] + s[2] + s[56:87] + s[28]
		elif len(s) == 87:
			return s[6:27] + s[4] + s[28:39] + s[27] + s[40:59] + s[2] + s[60:]
		elif len(s) == 86:
			return s[80:72:-1] + s[16] + s[71:39:-1] + s[72] + s[38:16:-1] + s[82] + s[15::-1]
		elif len(s) == 85:
			return s[3:11] + s[0] + s[12:55] + s[84] + s[56:84]
		elif len(s) == 84:
			return s[78:70:-1] + s[14] + s[69:37:-1] + s[70] + s[36:14:-1] + s[80] + s[:14][::-1]
		elif len(s) == 83:
			return s[80:63:-1] + s[0] + s[62:0:-1] + s[63]
		elif len(s) == 82:
			return s[80:37:-1] + s[7] + s[36:7:-1] + s[0] + s[6:0:-1] + s[37]
		elif len(s) == 81:
			return s[56] + s[79:56:-1] + s[41] + s[55:41:-1] + s[80] + s[40:34:-1] + s[0] + s[33:29:-1] + s[34] + s[28:9:-1] + s[29] + s[8:0:-1] + s[9]
		elif len(s) == 80:
			return s[1:19] + s[0] + s[20:68] + s[19] + s[69:80]
		elif len(s) == 79:
			return s[54] + s[77:54:-1] + s[39] + s[53:39:-1] + s[78] + s[38:34:-1] + s[0] + s[33:29:-1] + s[34] + s[28:9:-1] + s[29] + s[8:0:-1] + s[9]
		else:
			return ''

	def _download_web_page(self, page_url):
		request = urllib2.Request(page_url)
		for h,v in self._std_headers.items():
			if h in request.headers:
				del request.headers[h]
			request.add_header(h, v)
		webpage = urllib2.urlopen(request)
		content = webpage.read()
		webpage.close()
		return content

	def _get_flv_uri(self, player_url, choosen_format):
		_VALID_URL = r"""(?x)^
                     (
                         (?:https?://|//)?                                    # http(s):// or protocol-independent URL (optional)
                         (?:(?:(?:(?:\w+\.)?[yY][oO][uU][tT][uU][bB][eE](?:-nocookie)?\.com/|
                            (?:www\.)?deturl\.com/www\.youtube\.com/|
                            (?:www\.)?pwnyoutube\.com/|
                            (?:www\.)?yourepeat\.com/|
                            tube\.majestyc\.net/|
                            youtube\.googleapis\.com/)                        # the various hostnames, with wildcard subdomains
                         (?:.*?\#/)?                                          # handle anchor (#/) redirect urls
                         (?:                                                  # the various things that can precede the ID:
                             (?:(?:v|embed|e)/)                               # v/ or embed/ or e/
                             |(?:                                             # or the v= param in all its forms
                                 (?:(?:watch|movie)(?:_popup)?(?:\.php)?/?)?  # preceding watch(_popup|.php) or nothing (like /?v=xxxx)
                                 (?:\?|\#!?)                                  # the params delimiter ? or # or #!
                                 (?:.*?&)?                                    # any other preceding param (like /?s=tuff&v=xxxx)
                                 v=
                             )
                         ))
                         |youtu\.be/                                          # just youtu.be/xxxx
                         )
                     )?                                                       # all until now is optional -> you can pass the naked ID
                     ([0-9A-Za-z_-]{11})                                      # here is it! the YouTube video ID
                     (?(1).+)?                                                # if we found the ID, everything can follow
                     $"""
		_NEXT_URL_RE = r'[\?&]next_url=([^&]+)'

		"""
		|---------------------------------------------------------------------------------------------------------------|
		|                                       Youtube available formats table                                         |
		|---------------------------------------------------------------------------------------------------------------|
		| Format codes              |   5   |  6   | 34|   35  |   18   |   22  |   37  | 38 | 43| 44| 45 |  13  |  17  |
		|---------------------------------------------------------------------------------------------------------------|
		| Container                 |             FLV          |              MP4            |    WebM    |     3GP     |
		|---------------------------------------------------------------------------------------------------------------|
		|       |Encoding           |Sorenson H.263|              MPEG-4 AVC (H.264)         |     VP8    |MPEG-4 Visual|
		|       |-------------------------------------------------------------------------------------------------------|
		|       |Profile            |      –       |    Main   |Baseline|        High        |     –      |      –      |
		|       |-------------------------------------------------------------------------------------------------------|
		| Video |Max width (pixels) |  400  | 448  |640|  854  |   640  | 1280  |  1920 |4096|640|854|1280|     176     |
		|       |-------------------------------------------------------------------------------------------------------|
		|       |Max height (pixels)|  240  | 336  |360|  480  |   360  |  720  |  1080 |3072|360|480| 720|     144     |
		|       |-------------------------------------------------------------------------------------------------------|
		|       |Bitrate (Mbit/s)   | 0.25  | 0.8  |0.5|0.8–1.0|   0.5  |2.0–2.9|3.5–5.0|  – |0.5| 1 |  2 |      –      |
		|-------|-------------------------------------------------------------------------------------------------------|
		|       |Encoding           |  MP3         |                  AAC                    |    Vorbis  |     AAC     |
		|       |-------------------------------------------------------------------------------------------------------|
		|       |Channels           |  1–2         |                          2 (stereo)                         | 1-2  |
		|       |-------------------------------------------------------------------------------------------------------|
		| Audio |Sampling rate (Hz) | 22050 |                                    44100                                  |
		|       |-------------------------------------------------------------------------------------------------------|
		|       |Bitrate (kbit/s)   |  64   |  96  |    128    |   96   |       152          |  128  | 192|      –      |
		|---------------------------------------------------------------------------------------------------------------|
		"""

		# Youtube formats in order of quality and compatible with our WyBox
		youtube_formats = ['38', '37', '22', '18', '13', '17']

		# Extract original video URL from URL with redirection, like age verification, using next_url parameter
		mobj = re.search(_NEXT_URL_RE, player_url)
		if mobj:
			player_url = 'https://www.youtube.com/' + urllib.unquote(mobj.group(1)).lstrip('/')

		# Extract video id from URL
		mobj = re.match(_VALID_URL, player_url)
		if mobj:
			video_id = mobj.group(2)
		else:
			MessageWindow(('ERROR: invalid URL: %s' % player_url)).show()
			return ('', 0, [])

		# Get video webpage
		video_url = 'https://www.youtube.com/watch?v=%s&gl=US&hl=en&has_verified=1' % video_id
		video_webpage = self._download_web_page(video_url)
		
		# Attempt to extract SWF player URL
		mobj = re.search(r'swfConfig.*?"(https?:\\/\\/.*?watch.*?-.*?\.swf)"', video_webpage)
		if mobj is not None:
			player_url = re.sub(r'\\(.)', r'\1', mobj.group(1))
		else:
			player_url = None

		# Get video infos
		if re.search(r'player-age-gate-content">', video_webpage) is not None:
			age_gate = True
			# We simulate the access to the video from www.youtube.com/v/{video_id}
			# this can be viewed without login into Youtube
			data = urllib.urlencode({'video_id': video_id,
			                         'el': 'player_embedded',
			                         'gl': 'US',
			                         'hl': 'en',
			                         'eurl': 'https://youtube.googleapis.com/v/' + video_id,
			                         'asv': 3,
			                         'sts':'1588',
			                         })
			video_info_url = 'https://www.youtube.com/get_video_info?' + data
			try:
				video_info_webpage = self._download_web_page(video_info_url)
				video_info = parse_qs(video_info_webpage)
			except (urllib2.URLError, httplib.HTTPException, socket.error), err:
				MessageWindow(('ERROR: unable to download video info webpage: %s' % str(err))).show()
				return ('', 0, [])
		else:
			age_gate = False
			for el_type in ['&el=embedded', '&el=detailpage', '&el=vevo', '']:
				video_info_url = ('https://www.youtube.com/get_video_info?&video_id=%s%s&ps=default&eurl=&gl=US&hl=en' % (video_id, el_type))
				try:
					video_info_webpage = self._download_web_page(video_info_url)
					video_info = parse_qs(video_info_webpage)
					if 'token' in video_info:
						break
				except (urllib2.URLError, httplib.HTTPException, socket.error), err:
					MessageWindow(('ERROR: unable to download video info webpage: %s' % str(err))).show()
					return ('', 0, [])

		# Check video token
		if 'token' not in video_info:
			if 'reason' in video_info:
				MessageWindow(('ERROR: YouTube said: %s' % video_info['reason'][0].decode('utf-8'))).show()
			else:
				MessageWindow('ERROR: "token" parameter not in video info for unknown reason').show()
			return ('', 0, [])
		else:
			video_token = urllib.unquote_plus(video_info['token'][0])

		def uppercase_escape(s):
			unicode_escape = codecs.getdecoder('unicode_escape')
			return re.sub(r'\\U[0-9a-fA-F]{8}', lambda m: unicode_escape(m.group(0))[0], s)

		# Decide which formats to download
		try:
			mobj = re.search(r';ytplayer\.config\s*=\s*({.*?});', video_webpage)
			if mobj:
				json_code = uppercase_escape(mobj.group(1))
				ytplayer_config = json.loads(json_code)
				args = ytplayer_config['args']
				# Easy way to know if the 's' value is in url_encoded_fmt_stream_map
				# this signatures are encrypted
				if 'url_encoded_fmt_stream_map' not in args:
					MessageWindow('ERROR: No stream_map present').show()
					return ('', 0, [])
				re_signature = re.compile(r'[&,]s=')
				m_s = re_signature.search(args['url_encoded_fmt_stream_map'])
				if m_s is not None:
					video_info['url_encoded_fmt_stream_map'] = [args['url_encoded_fmt_stream_map']]
				m_s = re_signature.search(args.get('adaptive_fmts', u''))
				if m_s is not None:
					if 'adaptive_fmts' in video_info:
						video_info['adaptive_fmts'][0] += ',' + args['adaptive_fmts']
					else:
						video_info['adaptive_fmts'] = [args['adaptive_fmts']]
		except ValueError:
			pass

		# Get video real url
		if len(video_info.get('url_encoded_fmt_stream_map', [])) >= 1 or len(video_info.get('adaptive_fmts', [])) >= 1:
			encoded_url_map = video_info.get('url_encoded_fmt_stream_map', [''])[0] + ',' + video_info.get('adaptive_fmts',[''])[0]
			url_map = {}
			for url_data_str in encoded_url_map.split(','):
				url_data = parse_qs(url_data_str)
				if 'itag' in url_data and 'url' in url_data and url_data['itag'][0] in youtube_formats:
					url = url_data['url'][0]
					if 'sig' in url_data:
						url += '&signature=' + url_data['sig'][0]
					elif 's' in url_data:
						encrypted_sig = url_data['s'][0]
						if not age_gate:
							mobj = re.search(r'"assets":.+?"js":\s*("[^"]+")', video_webpage)
							if mobj:
								jsplayer_url_json = (g for g in mobj.groups() if g is not None).next()
							else:
								MessageWindow('ERROR: Unable to retreive the jsplayer url').show()
								return ('', 0, [])
							player_url = json.loads(jsplayer_url_json)
						signature = self._decrypt_signature(encrypted_sig, video_id, player_url, age_gate)
						url += '&signature=' + signature
					if 'ratebypass' not in url:
						url += '&ratebypass=yes'
					url_map[url_data['itag'][0]] = url
			available_formats = [int(x) for x in youtube_formats if x in url_map]
			if len(available_formats) == 0:
				MessageWindow('ERROR: no known formats available for video').show()
				return ('', 0, [])
			if choosen_format == 0: # User_config choice.
				# Little algo to choose the format. xD
				# Try user_config['video']['youtube_formats'], then -1 in youtube_formats, then +1, then -2, then +2, ...
				# Exemple 1:
				# youtube_formats = ['38', '37', '22', '18', '13', '17']
				# user_config['video']['youtube_formats'] = 18
				# check_formats = ['18', '22', '13', '37', '17', '38']
				# Exemple 2:
				# user_config['video']['youtube_formats'] = 22
				# check_formats = ['22', '37', '18', '38', '13', '37']
				index = 0
				count = 1
				even_odd = False
				user_fmt_index = youtube_formats.index(str(user_config['video']['youtube_formats']))
				check_formats = [youtube_formats[user_fmt_index]]
				# Build the check list
				for x in xrange(len(youtube_formats)-1):
					if even_odd == False:
						index = user_fmt_index - count
						if index < 0:
							index = user_fmt_index + count
							count += 1
						even_odd = True
					elif even_odd == True:
						index = user_fmt_index + count
						if index > len(youtube_formats)-1:
							count += 1
							index = user_fmt_index - count
						count += 1
						even_odd = False
					check_formats.append(youtube_formats[index])
				# Choose the appropriated video format
				for check_fmt in check_formats:
					if int(check_fmt) in available_formats:
						choosen_format = int(check_fmt)
						video_real_url = url_map[check_fmt] # User choice format
						break
				else:
					MessageWindow('ERROR: Enable to select video format').show()
					return ('', 0, [])
			else: # Hand menu choice
				video_real_url = url_map[str(choosen_format)]
		elif 'conn' in video_info and video_info['conn'][0].startswith('rtmp'):
			video_real_url = video_info['conn'][0] # Real Time Messaging Protocol
			choosen_format = 0
			available_formats = []
		else:
			MessageWindow('ERROR: no conn or url_encoded_fmt_stream_map information found in video info').show()
			return ('', 0, [])
		return (video_real_url, choosen_format, available_formats)

	def _get_entries(self, path):
		return self.service.Get(('/feeds/api/' + path)).entry

	def _get_dict_from_entry(self, e):
		group_ext = e.FindExtensions(tag='group')[0]
		try:
			view_count = e.FindExtensions(tag='statistics')[0].attributes['viewCount']
		except IndexError:
			view_count = 'NA'
		try:
			rating_ext = e.FindExtensions(tag='rating')[0].attributes['average']
		except IndexError:
			rating_ext = 0
		return dict(title=group_ext.FindChildren(tag='title')[0].text, thumbnail=group_ext.FindChildren(tag='thumbnail')[0].attributes['url'], player_url=group_ext.FindChildren(tag='player')[0].attributes['url'], uri=(lambda uri=group_ext.FindChildren(tag='player')[0].attributes['url']: self._get_flv_uri(uri, 0)), view_count=view_count, rating=rating_ext, description='')

	def simple_search(self, name):
		res_list = []
		try:
			for e in self._get_entries('videos/-/' + urllib.quote_plus(name)):
				res_list.append(self._get_dict_from_entry(e))
		except:
			pass
		return res_list

	def search_playlist(self, username=''):
		res_list = []
		root_uri = 'users/' + username + '/playlists?v=2'
		# Perform search
		try:
			for e in self._get_entries(root_uri):
				try:
					res_list.append(dict(title=e.title.text, id=e.FindExtensions(tag='playlistId')[0].text, thumbnail=e.FindExtensions(tag='group')[0].FindChildren(tag='thumbnail')[0].attributes['url']))
				except:
					pass
		except:
			pass
		return res_list

	def parse_playlist(self, id=''):
		res_list = []
		root_uri = 'playlists/' + id + '?v=2'
		# Perform parsing
		try:
			for e in self._get_entries(root_uri):
				try:
					res_list.append(self._get_dict_from_entry(e))
				except:
					pass
		except:
			pass
		return res_list

	def search_feed(self, feed=0, lang='', orderby='relevance', start_idx=1, max_res=50):
		params = {}
		res_list = []

		# Parse options
		if start_idx <= 0:
			params['start-index'] = 1
		else:
			params['start-index'] = start_idx
		if max_res >= 50:
			params['max-results'] = 50
		elif max_res <= 0:
			params['max-results'] = 1
		else:
			params['max-results'] = max_res
		params['orderby'] = orderby

		root_uri = 'standardfeeds/' + self._standard_feeds[feed]

		# Perform search
		try:
			for e in self._get_entries(  '%s?%s' % ( root_uri, urllib.urlencode(params) )  ):
				try:
					noembed = e.FindExtensions(tag='noembed')[0]
				except IndexError:
					try:
						res_list.append(self._get_dict_from_entry(e))
					except:
						pass
		except:
			pass
		return res_list

	def search_video(self, video='', lang='', orderby='relevance', start_idx=1, max_res=50):
		params = {}
		res_list = []

		# Parse options
		if start_idx <= 0:
			params['start-index'] = 1
		else:
			params['start-index'] = start_idx
		if max_res >= 50:
			params['max-results'] = 50
		elif max_res <= 0:
			params['max-results'] = 1
		else:
			params['max-results'] = max_res
		params['orderby'] = orderby

		root_uri = 'videos'
		params['vq'] = video
		params['lr'] = lang
		if lang == 'en':
			lang = 'gb'
		params['restriction'] = lang.upper()

		# Perform search
		try:
			for e in self._get_entries(  '%s?%s' % ( root_uri, urllib.urlencode(params) )  ):
				try:
					noembed = e.FindExtensions(tag='noembed')[0]
				except IndexError:
					try:
						res_list.append(self._get_dict_from_entry(e))
					except:
						pass
		except:
			pass
		return res_list



if (__name__ == '__main__'):
	import sys
	ytd = YoutubeData()
# Search Playlist
#	for e in ytd.search_playlist(username='polo35580'):
#		print e
#		for e2 in ytd.parse_playlist(id=e.get('id')):
#			print e2
# Search Feed
#	for e in ytd.search_feed(2, lang='fr', max_res=2, orderby='rating'):
#		print 'RESULT:'
#		print ('%(title)s / rated: %(rating)s / viewed: %(view_count)s' % e)
#		print 'DATA:'
#		print e
#		print 'URI:'
#		print e['uri']()
#		print ('#' * 80)
#	Search video
	for e in ytd.search_video('David Guetta', lang='fr', max_res=2, orderby='rating'):
		print 'RESULT:'
		print ('%(title)s / rated: %(rating)s / viewed: %(view_count)s' % e)
		print 'DATA:'
		print e
		print 'URI:'
		print e['uri']()
		print ('#' * 80)
