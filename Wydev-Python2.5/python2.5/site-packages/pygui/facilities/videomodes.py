# -*- coding: utf-8 -*- 
#
# Description:
#
# Video Modes Decorators Class Definitions
#
#
#
# Changes:
#
# 2011-11-02
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.


from __future__ import absolute_import

from wydbus import WyDbus
import pygui.config as config
from pygui.facilities.codemapping import hdmiresolution_dict
from pygui.facilities.power import PowerManager
from pygui.shared import pygui_globs
from peewee.hdmi import HDMISink, VideoMode
from peewee.notifier import Task
from peewee.debug import GET_LOGGER
from peewee.messages import send as louie_send

log = GET_LOGGER(__name__)



class DummyHDMISink(HDMISink):

	def __init__(self, display=0):
		self.display = display
		self.syspath = None
		self.id = 0
		self.modes = self.get_modes()
		return None

	def get_modes(self):
		sys_list = ['S:1280x720p-60', 'S:1280x720p-59', 'S:1280x720p-50', 'S:720x480p-60', 'S:720x480p-59', 'S:720x576p-50']
		modes = [VideoMode(m) for m in sys_list]
		return modes

	def get_hpd(self):
		return True



# Class to handle connected video output
class VideoModes(object):

	def __init__(self):
		self.switch_to_task = Task(self._switch_to)
		self.switch_to_task.delay = 3.0
		self.switch_to = self.switch_to_task.start
		self.close_player_task = Task(self._close_player)
		self.close_player_task.delay = 1.0
		self.close_player = self.close_player_task.start
		self.previous_resolution = None
		self.handle_events = True
		try:
			hdmi_plugged = open('/sys/class/stmcoredisplay/display0/hdmi0.0/hotplug', 'r').read().strip()
		except:
			if config.architecture != 'pc':
				hdmi_plugged = 'n'
			else:
				hdmi_plugged = 'y'
		finally:
			if hdmi_plugged != 'y':
				self.hdmi_sink = None
			else:
				self.hdmi_sink = self._get_hdmi_sink()
		self._initial_switch()
		wdb = pygui_globs['wydbus']
		if wdb:
			self.inst = wdb.instance('/com/wyplay/wycrs/wyhpd')
			self.inst.signal('plug', '', self.plug_hdmi, 0)
			self.inst.signal('unplug', '', self.unplug_hdmi, 0)
		return None

	# Return best supported hd resolution
	def _choose_hd_resolution(self):
		modes = self.hdmi_sink.get_modes()
		modes.sort()
		modes.reverse()
		log.debug('HDMI supported modes: %s', modes)
		current = config.user_config['connections']['resolution']
		if current in modes:
			log.debug('current HD mode (%s) supported by HDMI sink', current)
			return current
		log.debug('%s not supported by HDMI sink, fallback starting...', current)
		fallback = None
		for m in modes:
			mode = m.tuple_repr
			if mode[2] == current[2] and mode[3] == current[3]:
				fallback = mode
				break
		else:
			log.debug('fallback step 1 failed')
			for m in modes:
				mode = m.tuple_repr
				if mode[2] == current[2] and abs(mode[3] - current[3]) <= 1:
					fallback = mode
					break
			else:
				log.debug('fallback step 2 failed')
				for m in modes:
					mode = m.tuple_repr
					if abs(mode[3] - current[3]) <= 1:
						fallback = mode
						break
				else:
					log.debug('fallback step 3 failed')
					for m in modes:
						mode = m.tuple_repr
						if mode in hdmiresolution_dict <= 1:
							fallback = mode
							break
					else:
						log.debug('fallback step 4 failed -> use CVBS resolution (PAL/NTSC)')
						fallback = config.cvbs_resolution[config.user_config['connections']['composite_output']]
		log.debug('best mode supported by HDMI sink: %s', fallback)
		return fallback

	# Check if configuration and plugged devices match
	def _initial_switch(self):
		active_device = config.user_config['connections']['active_device']
		log.debug('initial switch...')
		if active_device == 'hdmi':
			self.previous_resolution = config.user_config['connections']['resolution']
			try:
				w, h, interlaced, freq = self.previous_resolution
				display = pygui_globs['display']
				if display.get_resolution() != ((w, h), interlaced):
					self.previous_resolution = None
			except:
				log.error('get_resolution failed')
		else:
			self.previous_resolution = None
		if self.hdmi_sink is None:
			config.user_config['connections']['active_device'] = 'cvbs'
		else:
			config.user_config['connections']['active_device'] = 'hdmi'
		config.user_config.save()
		self.switch_to()
		return None

	# Wrap go_hdmi and go_cvbs to easily task it
	def _switch_to(self):
		if config.user_config['connections']['active_device'] == 'hdmi':
			self._go_hdmi()
		else:
			self._go_cvbs()
		return None

	def _go_hdmi(self):
		if self.hdmi_sink:
			resolution = self._choose_hd_resolution()
			if self.previous_resolution != resolution:
				w, h, interlaced, freq = resolution
				log.debug('Setting resolution to %s', resolution)
				display = pygui_globs['display']
				display.set_resolution((w, h), interlaced, freq)
				display.set_aspect_ratio(config.user_config['video']['aspect_ratio'])
				config.user_config['connections']['resolution'] = resolution
				if not PowerManager().sleeping:
					config.user_config.save()
				louie_send('connection_switched')
			else:
				log.debug('current_mode = wanted_mode = %s: nothing to do', resolution)
		return None

	def _go_cvbs(self):
		resolution = config.cvbs_resolution[config.user_config['connections']['composite_output']]
		if self.previous_resolution != resolution:
			w, h, interlaced, freq = resolution
			log.debug('Setting resolution to %s', resolution)
			display = pygui_globs['display']
			display.set_resolution((w, h), interlaced, freq)
			louie_send('connection_switched')
		else:
			log.debug('current_mode = wanted_mode = %s: nothing to do', resolution)
		return None

	def _close_player(self):
		log.debug('try to close video player')
		pygui_globs['menustack'].close_player(type='video')
		self.switch_to()
		return None

	def _get_hdmi_sink(self):
		try:
			if config.architecture != 'pc':
				sink = HDMISink()
			else:
				sink = DummyHDMISink()
		except:
			sink = None
		finally:
			return sink

	def get_hdmi_modes(self):
		if self.hdmi_sink:
			modes = self.hdmi_sink.get_modes()
			modes.sort()
			modes.reverse()
			return modes
		return []

	def secure_set_resolution(self, new_mode):
		if self.hdmi_sink is None or new_mode in self.get_hdmi_modes():
			log.debug('SET_RESOLUTION: %s', new_mode)
			w, h, interlaced, freq = new_mode
			display = pygui_globs['display']
			display.set_resolution((w, h), interlaced, freq)
			return True
		return False

	def plug_hdmi(self):
		log.debug('hdmi plugged')
		if self.handle_events:
			self.hdmi_sink = self._get_hdmi_sink()
			self.previous_resolution = config.cvbs_resolution[config.user_config['connections']['composite_output']]
			config.user_config['connections']['active_device'] = 'hdmi'
			if not PowerManager().sleeping:
				config.user_config.save()
			self.close_player()
		return None

	def unplug_hdmi(self):
		log.debug('hdmi unplugged')
		if self.handle_events:
			self.hdmi_sink = None
			self.previous_resolution = config.user_config['connections']['resolution']
			config.user_config['connections']['active_device'] = 'cvbs'
			if not PowerManager().sleeping:
				config.user_config.save()
			self.close_player()
		return None
