# -*- coding: utf-8 -*- 
#
# Description:
#
# sRCU Class Facilitie Definition
#
#
#
# Changes:
#
# 2014-03-25
# Initial Commit
#
#
# Copyright 2010-2014, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

from __future__ import absolute_import

import struct
from time import sleep, time
from peewee.debug import GET_LOGGER, PRINT_EXCEPTION
from peewee.notifier import descriptor_watch

log = GET_LOGGER(__name__)


# A facility module to handle /dev/ir0 (sRCU)
# Warn: It does not use the standard linux input event interface, but it works !
# sRCU has 2 modes, only the first (sensitive) is used for now.
# (The second mode need antenna to detect moves around the sRCU).
# Run this script alone to test sRCU.
class RcuPad():

	format = 'BBBBBBBBBB'
	nb_buttons = 5

	def __init__(self, size=(100, 100), dev='/dev/ir0'):
		log.debug('creating RcuPad !')
		self.f = open(dev)
		self.packetSize = struct.calcsize(self.format)
		log.debug('packetSize = %s', self.packetSize)
		self.mode = 0
		self.left = 0
		self.right = 0
		self.x = size[0]
		self.y = size[1]
		self.dx = self.x / 2
		self.dy = self.y / 2
		self.buttons = [{'press':False, 'start_x':None, 'start_y':None} for i in range(self.nb_buttons)]
		self.lastbutton = 0
		self.lastvector = (0, 0)

	def __str__(self):
		ret = 'x:%d, y:%d b: ' % (self.dx, self.dy)
		for b in self.buttons:
			ret += '%s ' % b['press']
		return ret

	# Cleanup the start_x and start_y fields
	def clean_up(self):
		for but in self.buttons:
			if not but['press']:
				but['start_x'] = None
				but['start_y'] = None
		return None

	# Read the device. Call it with an appropriate frequency
	def get_struct(self):
		buffer = self.f.read(self.packetSize)
		if not buffer:
			return False
		try:
			values = struct.unpack(self.format, buffer)
		except Exception, e:
			log.warn('error while unpacking %s', buffer)
			PRINT_EXCEPTION(e)
			return False
		self.clean_up()
		self.mode = values[0]
		self.left = values[1]
		self.right = values[1]
		self.dx = values[3]
		self.dy = values[4]
		for button, pressed in zip(self.buttons, values[5:]):
			if pressed:
				if not button['press']:
					button['press'] = True
					button['start_x'] = self.dx
					button['start_y'] = self.dy
			elif button['press']:
				button['press'] = False
		return True


if __name__ == '__main__':
	import sys
	m = RcuPad()
	last = time()
	while m.get_struct():
		print m,
		print time() - last
		last = time()
	else:
		sleep(0.02)
