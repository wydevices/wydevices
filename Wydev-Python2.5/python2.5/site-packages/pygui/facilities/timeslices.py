# -*- coding: utf-8 -*- 
#
# Description:
#
# TimeSlice Decorators Definitons
#
#
#
# Changes:
#
# 2012-05-02
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

from __future__ import absolute_import
from datetime import datetime, timedelta
from time import mktime, localtime
from pygui.facilities.codemapping import day_dict, month_dict
from pygui.facilities.l10n import UnicodeDict



SLICES = ['morning',
					'morning2',
					'afternoon',
					'afternoon2',
					'evening',
					'evening2',
					'night']

NAMES = UnicodeDict({'morning': 'Morning',
										 'afternoon': 'Afternoon',
										 	'evening': 'Evening',
										 		'night': 'Night'})

BOUNDARIES = {'morning': (timedelta(hours=6), timedelta(hours=9)),
							'morning2': (timedelta(hours=9), timedelta(hours=12)),
							'afternoon': (timedelta(hours=12), timedelta(hours=15)),
							'afternoon2': (timedelta(hours=15), timedelta(hours=18)),
							'evening': (timedelta(hours=18), timedelta(hours=21)),
							'evening2': (timedelta(hours=21), timedelta(hours=24)),
							'night': (timedelta(hours=24), timedelta(hours=30))}



# get_slice_info(datetime) -> date, slice_id
#
# Return the time slice information for the given datetime.datetime object.
#
# The date returned is the EPG-wise day dt belongs to. In EPGs,
# days run from 6 AM to 6 AM on the following calendar day.
#
# slice_id is one of SLICES.
def get_slice_info(dt):
	day = datetime(dt.year, dt.month, dt.day)
	for slice in SLICES:
		start, end = BOUNDARIES[slice]
		if day + start <= dt < day + end:
			return (day, slice)
	return (day - timedelta(days=1), slice)

# get_epg_day(datetime) -> datetime
#
# Return the EPG-wise day the given datetime.datetime
# object belongs to.
# In EPGs, days run from 6 AM to 6 AM on the following calendar day.
def get_epg_day(dt):
	return get_slice_info(dt)[0]

# get_slice_id(datetime) -> one of SLICES
# Return the time slice identifier for the given
# datetime.datetime object.
def get_slice_id(dt):
	return get_slice_info(dt)[1]

# get_visible_slice_id(datetime) -> one of NAMES.keys()
# Return the visible time slice identifier for the given
# datetime.datetime object.
# 
# "Visible" time slices are time slices that can be seen by
# the user, e.g. in the EPG control window. A visible time
# slice encompasses all the non-visible time slices directly
# after it and before the next visible time slice.
# 
# e.g. given the time slices [v1, i2, i3, v4, i5, i6] where v1
# and v4 are visible, calling get_visible_slice_id on
# a date that's in v4, i5 or i6 will return v4's identifier.
def get_visible_slice_id(dt):
	slice_index = SLICES.index(get_slice_id(dt))
	for slice_id in SLICES[slice_index:None:-1]:
		if slice_id in NAMES:
			return slice_id
	return None

# distance_to_visible_slice(datetime, int) -> int
# Return the number of time slices between the time slice dt belongs to
# and the [value]th next visible time slice.
def distance_to_visible_slice(dt, value):
	slice_id = get_slice_id(dt)
	current_slice_index = SLICES.index(slice_id)
	sign = (1 if value >= 0 else -1)
	slice_count = 0
	if sign == -1:
		visible_slice_id = get_visible_slice_id(dt)
		visible_slice_index = SLICES.index(visible_slice_id)
		slice_count = visible_slice_index - current_slice_index
		current_slice_index = visible_slice_index
	while value:
		slice_count += sign
		current_slice_index = (current_slice_index + sign) % len(SLICES)
		if SLICES[current_slice_index] in NAMES:
			value -= sign
	return slice_count

# timeslice_boundaries(datetime[, int]) -> datetime, datetime
# Return the beginning and end of the [value]th timeslice after dt.
#
# Calling timeslice_boundaries with value=0 (default) will return
# the boundaries of the timeslice dt belongs to.
def timeslice_boundaries(dt, value=0):
	day, slice_id = get_slice_info(dt)
	new_slice_index = SLICES.index(slice_id) + value
	while new_slice_index < 0:
		new_slice_index += len(SLICES)
		day -= timedelta(days=1)
	while new_slice_index >= len(SLICES):
		new_slice_index -= len(SLICES)
		day += timedelta(days=1)
	new_slice_id = SLICES[new_slice_index]
	start_offset, end_offset = BOUNDARIES[new_slice_id]
	return (day + start_offset, day + end_offset)

# current_timeslice() -> (datetime, datetime)
#
# Return the start and end of the timeslice corresponding to
# the system's local time.
def current_timeslice():
	return timeslice_boundaries(datetime.now())

def timedelta_to_seconds(td):
	return td.seconds + td.days * 86400

def datetime_to_timestamp(dt):
	return mktime(dt.timetuple())

# Format a timestamp into a long (textual), i18n'd date.
# 
# Example (using English language):
#     >>> seconds_to_long_date(time.time()) -> u"Tuesday, 19 September 2008"
# 
# Partially stolen from EpgGrid.get_selected_program_date(), which will
# be changed to use it in M5.
# 
# TODO Move this to a more appropriate package in M5.
# pygui.facilities.extra_formatters, maybe?
def seconds_to_long_date(ts):
	time_tuple = localtime(ts)
	year = time_tuple[0]
	month = month_dict[time_tuple[1]]
	day = time_tuple[2]
	wday = day_dict[time_tuple[6]]
	return u'%s, %s %s %s' % (wday, day, month, year)
