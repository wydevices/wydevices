# -*- coding: utf-8 -*- 
#
# Description:
#
# Subtitles Decorators and Class Definitons
#
#
#
# Changes:
#
# 2012-05-02
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

from __future__ import absolute_import
import sgmllib
from time import time
from wydbus import WyDbus
from peewee.notifier import Task
from peewee.debug import GET_LOGGER
from peewee.misc_utils import MetaSingleton
import peewee.notifier as notifier

log = GET_LOGGER(__name__)



# HTML tags stripper
class Stripper(sgmllib.SGMLParser):

	def __init__(self):
		self.data = []
		sgmllib.SGMLParser.__init__(self)
		return None

	def unknown_starttag(self, tag, attrib):
		self.data.append(' ')
		return None

	def unknown_endtag(self, tag):
		self.data.append(' ')
		return None

	def handle_data(self, data):
		self.data.append(data)
		return None

	def gettext(self):
		return ''.join(self.data)



# Special list which call a callback function on append/remove
class SubList(list):

	def __init__(self, callback):
		list.__init__(self)
		self.callback = callback
		return None

	def append(self, data):
		list.append(self, data)
		self.callback(self)
		return None

	def remove(self, data):
		if data in self:
			list.remove(self, data)
		self.callback(self)
		return None



# Special list which remove old task on append/remove
class TaskList(list):

	def _cleanup(self):
		for task in self:
			if not task.running:
				list.remove(self, task)
		return None

	def append(self, data):
		list.append(self, data)
		self._cleanup()
		return None

	def remove(self, data):
		if data in self:
			list.remove(self, data)
		self._cleanup()
		return None



class SubServer(object):

	__metaclass__ = MetaSingleton

	def __init__(self, dbus_path='/com/wyplay/SubServer', txt_render=None):
		self.current_subs = SubList(self.sublist_callback)
		self.txt_render = (self.default_txt_render if not txt_render else txt_render)
		self.freezed = False
		self.task_list = TaskList()
		self.wdb = WyDbus()
		self.inst = self.wdb.instance(dbus_path)
		self.inst.signal('text', 'sti', self.text, 0)
		self.inst.signal('freeze', '', self.freeze, 0)
		self.inst.signal('thaw', '', self.thaw, 0)
		self.st = Stripper()
		return None

	def strip_tag(self, sub):
		self.st.data = []
		self.st.feed(sub)
		self.st.close()
		new = self.st.gettext()
		return new

	# Called for each current_subs change
	def sublist_callback(self, sublist):
		self.txt_render(sublist)
		return None

	def register_txt_render(self, f):
		self.txt_render = f
		return None

	def unregister_txt_render(self):
		self.txt_render = self.default_txt_render
		return None

	def default_txt_render(self, sublist):
		print '\n######## SUB #######'
		for txt in sublist:
			print '-> %s' % txt
		return None

	# Sig handler to add a sub
	def text(self, sub, timestamp, lifetime):
		start_delay = timestamp / 1000000.0
		lifetime = lifetime / 1000.0
		if self.freezed:
			return 0
		full_sub = str(sub)
		full_sub = full_sub.replace('\r\n', '\n').replace('\r', '\n')
		full_sub = self.strip_tag(full_sub)
		self.task_list.append(Task(self.current_subs.append, full_sub).start(start_delay))
		self.task_list.append(Task(self.current_subs.remove, full_sub).start(start_delay + lifetime))
		return None

	# Sig handler to freeze
	def freeze(self):
		self.freezed = True
		for task in self.task_list:
			task.pause()
		return None

	# Sig handler to thaw
	def thaw(self):
		self.freezed = False
		for task in self.task_list:
			task.unpause()
		return None

	def clear(self):
		for task in self.task_list:
			task.stop()
		self.current_subs = SubList(self.sublist_callback)
		self.task_list = TaskList()
		return None



if __name__ == '__main__':
	s = SubServer()
	notifier.loop()
