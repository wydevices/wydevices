# -*- coding: utf-8 -*- 
#
# Description:
#
# WyNetwork Utils Class Definitons
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.



# templates values:
#
# ('val1', 'val2') : mandatory, accepted values in tuple
# (): mandatory, accept all values (must be a string)
# ('val1', 'val2', None): optional, accepted values in tuple
# (None,): optional, accept all values (must be a string)

from copy import copy
from peewee.misc_utils import MetaSingleton
from peewee.debug import GET_LOGGER, PRINT_EXCEPTION
import wynetwork as wn

log = GET_LOGGER(__name__)



tpl_base = {'active': ('false', 'true'),
						'networkType': ('802.3', '802.11'),
						'ipConfigType': ('upnp', 'static'),
						'interface': ()}

tpl_updaters = {'01_networkType_802.11': {'essid': (), 'hidden': ('false', 'true', None), 'authType': ('WEP', 'WPA', 'WPA2', None)},
								'02_hidden_true': {'authType': ('WEP', 'WPA', 'WPA2')},
								'03_authType_WEP': {'cipher': ('WEP40', 'WEP104'), 'key': ()},
								'04_authType_WPA': {'cipher': ('TKIP', 'CCMP'), 'keyMgmt': ('PSK',), 'key': ()},
								'05_authType_WPA2': {'cipher': ('TKIP', 'CCMP'), 'keyMgmt': ('PSK',), 'key': ()},
								'06_ipConfigType_static': {'ipAddress': (), 'netmask': (), 'gateway': (None,), 'dns1': (None,), 'dns2': (None,)}}

invalids_keys_order = ('networkType',
											 'essid',
											 'interface',
											 'authType',
											 'cipher',
											 'keyMgmt',
											 'key',
											 'ipConfigType',
											 'ipAddress',
											 'netmask')

default_config = {'active': 'false'}



# Use it to build a valid Wynetwork configuration.
class WyNetworkConfig(object):

	# Config will be created using ConfigurationInfos dict from wynetwork
	def __init__(self, name=None, ConfigurationInfos=None):
		self.name = name
		self.config = (ConfigurationInfos if ConfigurationInfos and isinstance(ConfigurationInfos, dict) else copy(default_config))
		self.template = None
		return None

	def _get_autoname(self):
		_name = ''
		if self.config.get('networkType', '') == '802.3':
			_name = 'Eth'
		elif self.config.get('networkType', '') == '802.11':
			_name = 'Wifi'
			_name += '-%s' % self.config.get('essid', '')
		if self.config.get('ipConfigType', '') == 'upnp':
			_name += '-auto'
		elif self.config.get('ipConfigType', '') == 'static':
			_name += '-man'
		return _name

	autoname = property(_get_autoname)
	del _get_autoname

	# Remove unknown keys
	def cleanup(self):
		for key in self.config.keys():
			if key not in self.template:
				del self.config[key]
		return None

	# Build the template that match this config.
	# Template is used to check config validity
	def _update_template(self):
		self.template = copy(tpl_base)
		if self.config != None and isinstance(self.config, dict):
			try:
				tu_keys = tpl_updaters.keys()
				tu_keys.sort()
				for tu_key in tu_keys:
					pos, trigger_key, trigger_value = tu_key.split('_')
					if self.config.get(trigger_key, '') == trigger_value:
						tu_value = tpl_updaters[tu_key]
						self.template.update(tu_value)
			except Exception, e:
				log.error('no template match your config')
				PRINT_EXCEPTION(e)
				self.template = None
		else:
			log.error('config must be a dict: %s', self.config)
			self.template = None
		return None

	def __repr__(self):
		return '<%s::%s:%s %s>' % (self.__class__.__name__, repr(self.name), repr(self.autoname), self.config)

	def __setitem__(self, key, value):
		self.config[key] = value
		return None

	def __getitem__(self, key):
		return self.config[key]

	def __contains__(self, key):
		return key in self.config

	# Check if config[key] is valid, according to template[key]
	def _valid_key(self, key):
		t_val = self.template[key]
		if not isinstance(t_val, tuple):
			log.error('template[%s] is not a tuple: %s', key, t_val)
			return False
		can_be_ommitted = None in t_val
		try:
			c_val = self.config[key]
		except KeyError:
			return can_be_ommitted
		if not isinstance(c_val, basestring) or c_val == '':
			return False
		if c_val in t_val:
			return True
		if t_val == ():
			return True
		return False

	def set_ethernet(self):
		self.config['networkType'] = '802.3'
		self._update_template()
		return None

	# Config will be updated with rights values from NetworkInfos dict.
	# If NetworkInfos == None: config[hidden] = 'true'
	def set_network(self, NetworkInfos):
		self.config['networkType'] = '802.11'
		self._update_template()
		if NetworkInfos:
			for net_key, net_value in NetworkInfos.iteritems():
				if net_key in self.template and net_value != '':
					self.config[net_key] = net_value
					self._update_template()
		else:
			self.config['hidden'] = 'true'
			log.debug('set hidden = true')
			self._update_template()
		log.debug('template: %s', self.template)
		return None

	# Yield invalids key.
	# Stop if invalids_keys do not change between 2 iterations
	def configurator(self):
		log.debug('init')
		yield None
		invalids = self.invalids_keys()
		log.debug('start invalids=%s', invalids)
		while invalids:
			yield invalids[0]
			invalids_new = self.invalids_keys()
			log.debug('invalids_new=%s', invalids_new)
			if invalids_new != invalids:
				invalids = invalids_new
			else:
				log.error('invalids dont change: configuration failed')
				raise StopIteration

	def invalids_keys(self):
		self._update_template()
		return [key for key in invalids_keys_order if key in self.template and not self._valid_key(key)]

	def is_valid(self):
		try:
			if not self.invalids_keys() and self.name and len(self.name) > 0:
				return True
			else:
				return False
		except Exception, e:
			PRINT_EXCEPTION(e)
			return False
		return None

	def is_removable(self):
		if self.name and self.name in ('Wireless', 'Ethernet'):
			return False
		return True



class WyNetwork(object):

	__metaclass__ = MetaSingleton

	def __init__(self):
		self.wn_gen = wn.NetGeneral()
		self.wn_dev = wn.NetDevices()
		self.wn_net = wn.NetNetworks()
		self.wn_cfg = wn.NetConfigurations()
		return None

	def attach(self, obs):
		self.wn_gen.attach(obs)
		self.wn_dev.attach(obs)
		self.wn_net.attach(obs)
		return None

	def detach(self, obs):
		self.wn_gen.detach(obs)
		self.wn_dev.detach(obs)
		self.wn_net.detach(obs)
		return None

	def availables_networkType(self):
		try:
			return [self.wn_dev.getDeviceInfos(dev)['networkType'] for dev in self.wn_dev.getDevices()]
		except Exception, e:
			PRINT_EXCEPTION(e)
			return ()
		return None

	def wireless(self):
		return '802.11' in self.availables_networkType()

	def get_configs(self):
		cfgs = []
		net_types = self.availables_networkType()
		try:
			for name in self.wn_cfg.getConfigurations():
				infos = self.wn_cfg.getConfigurationInfos(name)
				if infos['networkType'] in net_types:
					cfgs.append(WyNetworkConfig(name=name, ConfigurationInfos=infos))
		except Exception, e:
			PRINT_EXCEPTION(e)
		return cfgs

	def new_config(self, name=None, ConfigurationInfos=None):
		return WyNetworkConfig(name=name, ConfigurationInfos=ConfigurationInfos)

	def delete_config(self, config):
		log.debug(config)
		if not isinstance(config, WyNetworkConfig):
			raise Exception('config must be a WyNetworkConfig')
		if not self.wn_cfg.deleteConfiguration(config.name):
			raise Exception('deleteConfiguration() failed')
		return None

	def save_config(self, config):
		log.debug(config)
		if not isinstance(config, WyNetworkConfig):
			raise Exception('config must be a WyNetworkConfig')
		if not config.is_valid():
			raise Exception('invalid keys: %s', config.invalids_keys())
		if config.name not in self.wn_cfg.getConfigurations():
			if not self.wn_cfg.addConfiguration(config.name):
				raise Exception('addConfiguration(%s) failed' % config.name)
		if not self.wn_cfg.setConfigurationInfos(config.name, config.config):
			raise Exception('setConfigurationInfos(%s, %s) failed' % (config.name, config.config))
		return None

	def active_config(self, config):
		log.debug(config)
		if not isinstance(config, WyNetworkConfig):
			raise Exception('config must be a WyNetworkConfig')
		if not config.is_valid():
			raise Exception('config is not valid')
		if not self.wn_cfg.setActiveConfiguration(config.name):
			raise Exception('setActiveConfiguration() failed')
		return None

	# Autofill: for now, just add interface if missing
	def autofill(self, config, key):
		invalids = config.invalids_keys()
		if key == 'interface' and key in invalids:
			config['interface'] = self.wn_dev.getDevicesByType(config['networkType'])[0]['interface']
		return None

	def get_networks(self):
		nets = []
		try:
			for dev in self.wn_dev.getDevices():
				dev_infos = self.wn_dev.getDeviceInfos(dev)
				if dev_infos['networkType'] == '802.11':
					for net in self.wn_net.getNetworks(dev):
						net_infos = self.wn_net.getNetworkInfos(dev, net)
						net_infos['interface'] = dev
						nets.append(net_infos)
		except Exception, e:
			PRINT_EXCEPTION(e)
		return nets

	# Control NM scanning (allowed or not)
	def set_scanning(self, enabled):
		for dev_infos in self.wn_dev.getDevicesByType('802.11'):
			if not self.wn_dev.setScanningEnabled(dev_infos['interface'], enabled):
				raise Exception('setScanningEnabled(%s, %s) failed' % (dev_infos['interface'], enabled))
		return None



if __name__ == '__main__':
	net = WyNetwork()
	new_cfg = net.new_config()
	net_list = net.get_networks()
	import pdb
	pdb.set_trace()
