# -*- coding: utf-8 -*- 
#
# Description:
#
# WyRecord Periodic Recording List Class Definition
#
#
#
# Changes:
#
# 2014-03-26
# Initial Commit
#
#
# Copyright 2010-2014, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.


import xml.etree.cElementTree as ET
from periodicscheduling import PeriodicScheduling
from periodicscheduling import GetPeriodicSchedulingInstanceFactory
from logger import log
from peewee.analyse import Chrono


# Keep the list of periodicity rule.
#
# Used to generate a list of start time when scheduling periodic recording
# a rule can be reused for new periodic recording.
class PeriodicRecordingList(object):

	def __init__(self):
		self._periodicRecordings = {}
		return None

	def _computeIdentifier(self):
		rec_id = 1
		if len(self._periodicRecordings) != 0:
			rec_id = 1 + max([recording for recording in self._periodicRecordings])
		return rec_id

	# Add a new rule to the list.
	# Return the id of the new rule
	def AddPeriodicSchedulingRule(self, rule):
		new_rule_id = self._computeIdentifier()
		rule.id = new_rule_id
		self._periodicRecordings[new_rule_id] = rule
		return new_rule_id

	# Generate the list of startime according to rule id
	# from given startTime to given stopTime
	def GetTimeList(self, id, startTime, stopTime, minStartTime=None):
		log.debug('id ' + str(id) + ' startTime ' + str(startTime) + ' stopTime ' + str(stopTime))
		log.debug('self._periodicRecordings ' + str(self._periodicRecordings))
		if id not in self._periodicRecordings:
			return []
		rule = self._periodicRecordings[id]
		time_list = []
		try:
			t_ref = startTime
			if minStartTime:
				t_min = minStartTime
			else:
				t_min = startTime
			while True:
				t_ref = rule.GetNextTime(t_min, t_ref, True)
				t_min = t_ref
				if t_ref > stopTime:
					break
				time_list.append(t_ref)
		except PeriodicSchedulingException:
			pass
		return time_list

	# Load all recordings from an xml node
	def LoadFromXML(self, oXMLNode):
		nodes_rule = oXMLNode.getiterator('rule')
		if not nodes_rule:
			log.warning('wyrecord error: no node rule found')
			return False
		self._periodicRecordings.clear()
		for node_rule in nodes_rule:
			rule = GetPeriodicSchedulingInstanceFactory(node_rule.attrib['type'])
			if rule.LoadFromXML(node_rule):
				rule_id = int(node_rule.attrib['id'])
				rule.id = rule_id
				self._periodicRecordings[rule_id] = rule
		return True

	# Save all recordings into an xml node
	def SaveToXMLNode(self, oXMLNode):
		if oXMLNode == None:
			return False
		for id, rule in self._periodicRecordings.items():
			node_rule = ET.Element('rule')
			node_rule.attrib['id'] = str(id)
			rule.SaveToXMLNode(node_rule)
			oXMLNode.append(node_rule)
		return True

	# Remove a rule from the list.
	def RemoveRule(self, rule_id):
		del self._periodicRecordings[rule_id]
		return None
