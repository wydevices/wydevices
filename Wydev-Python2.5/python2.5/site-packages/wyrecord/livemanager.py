# -*- coding: utf-8 -*- 
#
# Description:
#
# WyRecord Live Manager Class Definition
#
#
#
# Changes:
#
# 2014-03-26
# Initial Commit
#
#
# Copyright 2010-2014, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.


from logger import log
from recording import VirtualRecording
from conflictmanager import ChronologicalElement
from config import *
from exceptions import *
from live import Live
import error
import os
from tools import WyrecordOnShotTimer
from peewee.analyse import Chrono
from globallock import GlobalLock


# Api used to manages live and timeshift.
# Deprecated for many of its method. (see livecontroller)
class LiveManager(object):

	def __init__(self, external_dvb_manager, external_recorder_factory, ext_disk_space):
		try:
			os.makedirs(config.unix_socket_folder_path)
		except:
			pass
		self.external_dvb_manager = external_dvb_manager
		self.last_timeshift_size = config.max_size_for_timeshift
		self.lives = {}
		for i in range(1, config.live_count_max + 1):
			self.lives[i] = Live(i, external_dvb_manager, external_recorder_factory, ext_disk_space)
		return None

	# Get a Live() object from Live Number
	# Result Live() object
	def _GetLiveFromLiveID(self, nLiveID):
		if not self.lives.has_key(nLiveID):
			log.error('Bad Live ID %d !' % nLiveID)
			return None
		return self.lives[nLiveID]

	# Get a Live() object from a service id
	# Result Live() object
	def _GetLiveFromServiceID(self, nServiceID):
		for live in self.lives.itervalues():
			if live.isRunning() and live.serviceid == nServiceID:
				return live
		return None

	# Start a live on the specified LiveNumber
	# Result{} :
	# ['status'] = Status
	# ['live_id'] = Live ID
	def StartLive(self, nServiceID, device_to_use=0):
		live = self._GetLiveFromServiceID(nServiceID)
		if live:
			return {'status': error.WYRECORD_SUCCESS, 'live_id': live.id}
		for live in self.lives.values():
			if not live.isRunning():
				break
		else:
			log.warning('No available live ! => Stop an existing live before !')
			return {'status': error.WYRECORD_LIVE_ALREADY_USED}
		live.prepareRecorder(nServiceID, device_to_use)
		if not live.start(nServiceID, device_to_use):
			return {'status': error.WYRECORD_CAN_NOT_START_LIVE}
		return {'status': error.WYRECORD_SUCCESS, 'live_id': live.id}		

	# Stop a live on the specified LiveID
	# Result{} :
	# ['status'] = Status
	def StopLive(self, nLiveID):
		live = self._GetLiveFromLiveID(nLiveID)
		if live == None:
			log.error('Bad Live ID %d !' % nLiveID)
			return {'status': error.WYRECORD_BAD_LIVE_ID}
		if not live.isRunning():
			log.error('Live ID %d not started !' % nLiveID)
			return {'status': error.WYRECORD_LIVE_NOT_STARTED}
		if live.isRecording():
			return {'status': error.WYRECORD_LIVE_IS_RECORDING}
		if not live.stop():
			return {'status': error.WYRECORD_CAN_NOT_STOP_LIVE}
		return {'status': error.WYRECORD_SUCCESS}

	# Get the list of used list.
	def GetRunningLiveList(self):
		running_live_list = []
		for live in self.lives.itervalues():
			if live.isRunning():
				running_live_list.append(live)
		return running_live_list

	# Get the list of used list.
	def GetRecordingLiveList(self):
		recording_live_list = []
		for live in self.lives.itervalues():
			if live.isRunning() and live.isRecording():
				recording_live_list.append(live)
		return recording_live_list

	@GlobalLock()
	def cbUpdateLiveTime(self, delta):
		for live in self.GetRunningLiveList():
			if live.chunk_info:
				live.chunk_info.refTimeUpdated(delta)
		return None

	# Used to safely update chunk info time
	def AsynchronousUpdateLiveTime(self, delta):
		log.debug('AsynchronousUpdateLiveTime called')
		WyrecordOnShotTimer(self.cbUpdateLiveTime, delta).start(0)
		return None

	# Used to free wyscan uses.
	def StopAllLiveNotRecording(self):
		for live in self.GetRunningLiveList():
			if not live.isRecording():
				live.stop()
		return None

	def GetLivesInConflictWithService(self, service_id, live_to_ignore=None):
		try:
			return [self.GetDeviceForNewService(service_id, live_to_ignore)]
		except LiveInConflictError, e:
			return e.conflict_live_list
		except NoDeviceAvailableForServiceErrors, e:
			return [e]
		return []

	def CompareLive(self, live1, live2):
		p1 = live1.getPriority()
		p2 = live2.getPriority()
		if p1 < p2:
			return -1
		elif p1 > p2:
			return 1
		elif live1.isRecording() and live2.isRecording():
			if live1.recording_task_runner.global_start_time < live2.recording_task_runner.global_start_time:
				return -1
			elif live1.recording_task_runner.global_start_time > live2.recording_task_runner.global_start_time:
				return 1
			else:
				return 0
		return 0

	# Return the device to use for new service if there is no coflict with running live.
	# 
	# It use the conflict manager algorithm.
	# 
	# Raise LiveInConflictError in case of conflict with running live. the exception contains
	# The list of the live that must be stopped .
	# 
	# Raise NoDeviceAvailableForServiceErrors if the service can not be played at all
	@Chrono(['wyrecord'])
	def GetDeviceForNewService(self, service_id, live_to_ignore=None):
		live = self._GetLiveFromServiceID(service_id)
		if live:
			raise LiveInConflictError(service_id, [live])
		invalid_live_list, dummy_rec_list = self._LiveManager__getInvalidLiveListForService(service_id, True, live_to_ignore)
		if invalid_live_list:
			invalid_live_list, dummy_rec_list = self._LiveManager__getInvalidLiveListForService(service_id, False, live_to_ignore)
			raise LiveInConflictError(service_id, invalid_live_list)
		live_list = [rec.live for rec in dummy_rec_list]
		nb_live_to_stop = len(live_list) - config.live_count_max
		if nb_live_to_stop > 0:
			live_list.remove(None)
			live_list.sort(self.CompareLive())
			raise LiveInConflictError(service_id, live_list[-nb_live_to_stop:])
		return rec.deviceid

	def _LiveManager__getInvalidLiveListForService(self, service_id, real=True, live_to_ignore=None):
		devices = [device.id for device in self.external_dvb_manager.GetPlayableServiceDevices(service_id)]
		log.debug('devices id for new service =' + str(devices))
		if len(devices) == 0:
			raise NoDeviceAvailableForServiceErrors(service_id)
		new_rec = VirtualRecording(deviceid=0, possible_deviceids=devices, service_id=service_id, nStartTime=0, nStopTime=0, start_padding=0, stop_padding=0, id=0, live=None)
		dummy_rec_list = []
		if not real:
			dummy_rec_list.append(new_rec)
		for index, live in enumerate(self.lives.itervalues()):
			if live.isRunning() and live != live_to_ignore:
				if real:
					devices_id = [live.deviceid]
				else:
					devices_id = [device.id for device in self.external_dvb_manager.GetPlayableServiceDevices(live.serviceid)]
				rec = VirtualRecording(deviceid=live.deviceid, possible_deviceids=devices_id, service_id=live.service_id, nStartTime=0, nStopTime=0, start_padding=0, stop_padding=0, id=index, live=live)
				dummy_rec_list.append(rec)
		if real:
			dummy_rec_list.append(new_rec)
		chrono = ChronologicalElement(self.external_dvb_manager.AreServicesPlayable(0, 0, dummy_rec_list))
		invalid = chrono.getInvalidRecordingList(None, True)
		invalid_live_list = [rec.live for rec in invalid]
		return [invalid_live_list, dummy_rec_list]
