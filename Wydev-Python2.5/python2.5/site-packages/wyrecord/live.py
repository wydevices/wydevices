# -*- coding: utf-8 -*- 
#
# Description:
#
# WyRecord Live Class Definition
#
#
#
# Changes:
#
# 2014-03-26
# Initial Commit
#
#
# Copyright 2010-2014, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.


LIVE_ID_NULL = 0

import os
import error
from config import *
from logger import log
from chunkinfo import ChunkInfo
from chunkinfo import UriChunkToPath
from peewee.analyse import Chrono
from recordingtaskrunner import RecordingTaskRunner
from externaldvbmanager import WYSCAN_RECORDING_ID_NULL
from callbacks import Callbacks


# Live object is responsible of getting stopping live stream source.
# Live object is responsible of recording the stream (timeshift or record feature)
# 
# Recording needs are abstracted via RecordingTaskRunner object.
#
# Currently, only DVB stream from wyscan is supported
class Live(object):
	
	LIVE_COUNT = 0
	
	def __init__(self, id, external_dvb_manager, external_recorder_factory, ext_disk_space):
		self.id = id
		self.serviceid = 0
		self.deviceid = 0
		self.wyscan_recording_id = WYSCAN_RECORDING_ID_NULL
		self.source_uri = None
		self.dest_uri = None
		self.dest_rec_uri = None
		self.chunk_info = None
		self.has_macrovision = False
		self.recording_task_runner = RecordingTaskRunner(self, ext_disk_space)
		self.external_dvb_manager = external_dvb_manager
		self.external_recorder_factory = external_recorder_factory
		self.external_recorder = None
		self.bytes_per_sec = config.bytes_per_sec
		self.timeshift_folder = os.path.join(config.timeshift_base_folder_path, config.timeshift_live_name + '_' + str(self.id))
		if ext_disk_space:
			ext_disk_space.ReserveSpace(self.timeshift_folder, config.max_size_for_timeshift)
		return None

	# return True if live is in use.
	def isRunning(self):
		return self.wyscan_recording_id != WYSCAN_RECORDING_ID_NULL

	# return True if live is used for records.
	def isRecording(self):
		return self.recording_task_runner.getTaskList() != []

	def prepareRecorder(self, service, device_to_use=0):
		self.resetRecorder()
		self.source_uri, self.dest_uri, self.dest_rec_uri = self._Live__generateSourceAndDestUris(service, device_to_use)
		self.external_recorder = self.external_recorder_factory.getNewExternalRecorder(self.dest_rec_uri)
		return None

	# Zap service.
	#
	# This api allow an optimisation for zapping.
	# It's the same as doing stop followed by start.
	def zap(self, service, device_id, use_post_zap=False):
		return self.start(service, device_id, self.wyscan_recording_id, use_post_zap)

	# For optimization do what is possible after starting playing.
	def postZap(self):
		self.onTimeShiftStart()
		return None

	# Start the live.
	# Get the required stream.
	# Start to record the stream
	def start(self, service, device_to_use=0, service_to_stop=None, use_post_zap=False):
		if not self.external_recorder:
			self.source_uri, self.dest_uri, self.dest_rec_uri = self._Live__generateSourceAndDestUris(service, device_to_use)
			self.dest_uri = None
			self.dest_rec_uri = None
		result = self.external_dvb_manager.startService(service, device_to_use, self.source_uri, service_to_stop)
		if result['status'] != error.WYRECORD_SUCCESS:
			self.resetRecorder()
			self.source_uri = None
			return False
		self.serviceid = service
		self.deviceid = result['deviceid']
		self.wyscan_recording_id = result['wyscan_recording_id']
		if self.external_recorder:
			self.external_recorder.startRec(self.source_uri)
		else:
			log.critical('failed to build a recporder instance')
			return False
		if not use_post_zap:
			self.onTimeShiftStart()
		return True

	# Stop the live.
	def stop(self):
		ret = True
		if self.wyscan_recording_id == WYSCAN_RECORDING_ID_NULL:
			log.error('Trying to stop a live not started')
			return False
		if self.isRecording():
			log.error('Trying to stop a live that is recording')
			return False
		log.debug('self.external_dvb_manager.stopService(self.wyscan_recording_id)')
		try:
			status = self.external_dvb_manager.stopService(self.wyscan_recording_id)
			if status != error.WYRECORD_SUCCESS:
				log.error('StopRecording(%d) FAILED (error %d) !' % (self.internal_recordingid, status))
				ret = False
		except:
			log.critical('failed to stop dvb source')
		self.resetRecorder()
		self.serviceid = 0
		self.deviceid = 0
		self.wyscan_recording_id = WYSCAN_RECORDING_ID_NULL
		self.source_uri = None
		self.dest_uri = None
		self.external_recorder = None
		log.debug('stop live end')
		return ret

	# Lower is higher priority.
	#
	# Used to resolve automaticly conflicts. 
	def getPriority(self):
		if self.recording_task_runner.getTaskList():
			if self.recording_task_runner.containsSchedule():
				return 1
			else:
				return 0
		else:
			return 3

	# Stop the record feature.
	def resetRecorder(self):
		if self.external_recorder:
			self.external_recorder.stopRec()
			self.deleteRecorder(self.external_recorder)
		self.dest_uri = None
		self.dest_rec_uri = None
		self.external_recorder = None
		self.has_macrovision = False
		self.onTimeShiftStop()
		return None

	def getRecorderForPostReset(self):
		ret = self.external_recorder
		self.external_recorder = None
		return ret

	def deleteRecorder(self, recorder):
		self.external_recorder_factory.appendRecorderToDelete(recorder)
		return None

	# Uri generator.
	def _Live__generateSourceAndDestUris(self, service_id, device_id):
		Live.LIVE_COUNT += 1
		extension = '%d_%d_%d' % (device_id, service_id, Live.LIVE_COUNT)
		unix_socket_path = os.path.join(config.unix_socket_folder_path, 'sock_' + extension)
		source_uri = URL_PREFIX_UNIX_SOCKET + unix_socket_path
		timeshift_folder = os.path.join(self.timeshift_folder, 'ts_' + extension)
		timeshift_folder = os.path.join(timeshift_folder, config.timeshift_chunk_file_name_format)
		dest_uri = URL_PREFIX_TIMESHIFT + timeshift_folder
		dest_rec_uri = URL_PREFIX_REC_TIMESHIFT + timeshift_folder
		return [source_uri, dest_uri, dest_rec_uri]

	def saveReadOffset(self, offset):
		if self.chunk_info:
			self.chunk_info.saveReadOffset(offset)
		return None

	def updateTimeshiftSize(self, timeshift_size):
		if not self.external_recorder:
			return False
		recording_size = self.getRecordingSize()
		total_size = timeshift_size + recording_size
		if abs(total_size - self.external_recorder.last_size) > config.size_error_before_allocation:
			log.info('updateTimeshiftSize timeshift_size=' + str(timeshift_size) + ' total=' + str(total_size))
			self.external_recorder.setMaxRecSize(total_size)
			return True
		return False

	# Must be called if timeshift starts.
	# Used to manage chunk info <=> palyer position
	def onTimeShiftStart(self):
		if not self.dest_uri:
			log.critical('no destination uri')
			return False
		if not self.dest_uri.startswith(URL_PREFIX_TIMESHIFT):
			log.critical('WYRECORD ERROR - onTimeShiftStart : no timeshift url ')
			return False
		self.chunk_info = ChunkInfo(UriChunkToPath(self.dest_uri))
		self.chunk_info.synchronyseStartTime(self.external_dvb_manager.GetCurrentUTCTime())
		return True

	# Must be called if timeshift stops.
	# Used to manage chunk info <=> palyer position
	def onTimeShiftStop(self):
		self.chunk_info = None
		return None

	# Return an estimated size for the records.
	def getRecordingSize(self):
		recording_size = 0
		if not self.chunk_info:
			return 0
		bytes_per_sec = self.chunk_info.getBytesPerSec()
		if not bytes_per_sec:
			bytes_per_sec = self.bytes_per_sec
		recording_size = (self.recording_task_runner.global_stop_time - self.recording_task_runner.global_start_time) * bytes_per_sec
		recording_size += 2 * config.size_error_before_allocation
		return recording_size

	def getUsedSpace(self):
		if not self.chunk_info:
			return 0
		return self.chunk_info.getChunkTotalSize()

	def _Live__get_current_rec(self):
		task_list = self.recording_task_runner.getTaskList()
		if task_list:
			return task_list[0]
		return None

	current_rec = property(fget=_Live__get_current_rec)

	def _Live__get_current_recordingid(self):
		task_list = self.recording_task_runner.getTaskList()
		if task_list:
			return task_list[0].id
		return 0

	current_recordingid = property(fget=_Live__get_current_recordingid)

	def IsRecording(self):
		return self.isRecording()

	def IsPlayingOnlive(self):
		return False
