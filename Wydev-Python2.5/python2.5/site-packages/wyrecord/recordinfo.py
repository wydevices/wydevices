# -*- coding: utf-8 -*- 
#
# Description:
#
# WyRecord Record Info Class Definition
#
#
#
# Changes:
#
# 2014-03-26
# Initial Commit
#
#
# Copyright 2010-2014, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.


import xml.etree.cElementTree as ET
import os
from logger import log
from config import *
from wymedia.wmplus import browse_ng, get_root, container_search


class RecordInfo(object):
	
	def __init__(self):
		self.name = ''
		self.parental_rating = 0
		self.service_name = ''
		self.start_time = 0
		self.stop_time = 0
		self.size = 0
		self.url = ''
		self.info_file_path_name = ''
		self.files = {}
		self.files_folder = ''
		return None

	def __str__(self):
		text = 'Record : name = %s, service_name = %s, start_time = %d, stop_time = %d, url = %s, info_file = %s\n' % (self.name, self.service_name, self.start_time, self.stop_time, self.url, self.info_file_path_name)
		for id, file in self.files.items():
			text += 'File %s\n' % file
		return text

	def compute_parental_rating(self):
		self.parental_rating = 0
		try:
			service = container_search(get_root('channel'), 'title', self.service_name)[0]
			options = {'universe': 'tv', 'serviceId': service['serviceId'], 'scheduledStartTime': str(int(self.start_time)), 'scheduledEndTime': str(int(self.stop_time))}
			programs_list = browse_ng(get_root('epg'), 0, -1, ['+scheduledStartTime'], options)
			if not programs_list:
				programs_list = []
			for epg in programs_list:
				maturity_rating = int(epg.get('rating', epg.get('maturityRating', 0)))
				if maturity_rating > self.parental_rating:
					self.parental_rating = maturity_rating
		except:
			pass
		return None

	def IsMultipleFiles(self):
		if self.url != '':
			if self.url.startswith(URL_PREFIX_TIMESHIFT):
				return True
		return False

	def Save(self, url, dvb_service_id):
		self.files = {}
		self.url = ''
		self.info_file_path_name = ''
		if url.startswith(URL_PREFIX_TIMESHIFT):
			file_path_name = os.path.split(url[len(URL_PREFIX_TIMESHIFT):])[0]
			file_name = RECORD_INFO_FILE_NAME_MULTIPLE_FILE_NAME
			path_name = file_path_name
			try:
				_files = os.listdir(path_name)
			except Exception, e:
				return False
			index = 0
			for file in _files:
				log.debug(file)
				index = int(file[len(config.timeshift_chunk_file_base_name):-len(config.timeshift_chunk_file_extention)])
				if index >= 0:
					if self.files.has_key(index):
						log.critical('ERROR: BUG TO FIX : Several record (timeshift) files have same index !!!!')
					self.files[index] = file
				else:
					log.error("Can not extract record (timeshift) file index from '%s'" % file)
			self.size = len(self.files) * config.timeshift_chunk_max_size
		else:
			log.critical("ERROR : BUG TO FIX : BAD URL Prefix for a recording ! : url='%s'" % url)
			return False
		self.url = url
		self.dvb_service_id = dvb_service_id
		self.info_file_path_name = os.path.join(path_name, file_name)
		self.files_folder = os.path.dirname(self.info_file_path_name)
		log.info('files = ' + str(self.files))
		log.info('url = ' + str(self.url))
		log.info('filename = ' + str(self.info_file_path_name))
		self.compute_parental_rating()
		if not self.SaveToFile(self.info_file_path_name):
			log.error("Failed to save Record info file '%s'" % self.info_file_path_name)
			return False
		return True

	def LoadFromFile(self, strFilePathNameName):
		try:
			node_root = ET.parse(strFilePathNameName)
		except:
			log.critical("Can not parse xml file '%s'" % strFilePathNameName)
			return False
		node_root = node_root.find('record')
		if not node_root:
			log.critical('The file ' + str(strFilePathNameName) + ' is not a valid redordinfo')
			return False
		if not self.LoadFromXML(node_root):
			self.info_file_path_name = ''
			return False
		self.info_file_path_name = strFilePathNameName
		self.files_folder = os.path.dirname(self.info_file_path_name)
		return True

	def LoadFromXML(self, oXMLNode):
		self.files = {}
		self.name = ''
		self.parental_rating = 0
		self.service_name = ''
		self.start_time = 0
		self.stop_time = 0
		self.url = ''
		node_information = oXMLNode.find('information')
		if node_information == None:
			log.error("Invalide Record Info file : No 'information' xml node found")
			return False
		node_files = oXMLNode.find('files')
		if node_files == None:
			log.error("Invalide Record Info file : No 'files' xml node found")
			return False
		self.name = node_information.find('name').text
		self.parental_rating = int(node_information.find('parental_rating').text)
		self.service_name = node_information.find('channel').text
		self.dvb_service_id = int(node_information.find('dvb_service_id').text)
		self.start_time = int(node_information.find('start_time').text)
		self.stop_time = int(node_information.find('stop_time').text)
		if node_information.find('size'):
			self.size = int(node_information.find('size').text)
		self.url = node_information.find('url').text
		nodes_file = node_files.getiterator('file')
		for node_file in nodes_file:
			self.files[int(node_file.attrib['index'])] = node_file.attrib['file_path_name']
		return True

	def SaveToFile(self, strFilePathNameName):
		root_node = ET.Element('RecordDescription', version='1.0')
		record_node = ET.Element('record')
		root_node.append(record_node)
		if not self.SaveToXMLNode(record_node):
			log.critical("Failed to save recordinfo '%s'" % strFilePathNameName)
			return False
		tree = ET.ElementTree(root_node)
		tree.write(strFilePathNameName, encoding='utf-8')
		self.info_file_path_name = strFilePathNameName
		os.fsync(os.open(strFilePathNameName, os.O_RDWR))
		return True

	# Return an XML (cElementTree) node representing the current recording
	def SaveToXMLNode(self, oXMLNode):
		if oXMLNode == None:
			return False
		node_information = ET.Element('information')
		oXMLNode.append(node_information)
		node_temp = ET.Element('name')
		node_temp.text = self.name
		node_information.append(node_temp)
		node_temp = ET.Element('parental_rating')
		node_temp.text = str(self.parental_rating)
		node_information.append(node_temp)
		node_temp = ET.Element('channel')
		node_temp.text = self.service_name
		node_information.append(node_temp)
		node_temp = ET.Element('dvb_service_id')
		node_temp.text = str(self.dvb_service_id)
		node_information.append(node_temp)
		node_temp = ET.Element('start_time')
		node_temp.text = str(self.start_time)
		node_information.append(node_temp)
		node_temp = ET.Element('stop_time')
		node_temp.text = str(self.stop_time)
		node_information.append(node_temp)
		node_temp = ET.Element('size')
		node_temp.text = str(self.size)
		node_information.append(node_temp)
		node_temp = ET.Element('url')
		node_temp.text = self.url
		node_information.append(node_temp)
		node_files = ET.Element('files')
		oXMLNode.append(node_files)
		for idx, file in self.files.items():
			node_files.append(ET.Element('file', index=str(idx), file_path_name=os.path.basename(file)))
		return True

	# Check if recordinfo is valid. ie:
	# - if xml file is specified => Check if file is present on disk
	# - For all files, checks if present on disk
	def IsValid(self):
		if self.info_file_path_name != '':
			if not os.path.exists(self.info_file_path_name):
				log.error("RecordInfo: File '%s' does not exist !" % self.info_file_path_name)
				return False
		if self.files_folder != '':
			if not os.path.exists(self.files_folder):
				log.error("RecordInfo: File '%s' does not exist !" % self.files_folder)
				return False
			for id, file in self.files.items():
				if not os.path.exists(os.path.join(self.files_folder, file)):
					log.error("RecordInfo: File '%s' does not exist !" % file)
					return False
		return True

	def Delete(self):
		if os.path.exists(self.info_file_path_name):
			log.info("Delete '%s'" % self.info_file_path_name)
			try:
				os.remove(self.info_file_path_name)
			except:
				pass
		for id, file in self.files.items():
			if os.path.exists(os.path.join(self.files_folder, file)):
				log.info("Delete '%s'" % os.path.join(self.files_folder, file))
				try:
					os.remove(os.path.join(self.files_folder, file))
				except:
					pass
		if self.IsMultipleFiles():
			log.info('%s : Is multiple files !' % self.url)
			log.info("Delete folder '%s'" % self.files_folder)
			if os.path.exists(self.files_folder):
				try:
					os.removedirs(self.files_folder)
				except:
					pass
		return None
