# -*- coding: utf-8 -*- 
#
# Description:
#
# WyRecord External DVB Manager Class Definition
#
#
#
# Changes:
#
# 2014-03-26
# Initial Commit
#
#
# Copyright 2010-2014, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.


from logger import log
import time
import error
from peewee.analyse import Chrono
from peewee.analyse import timestep
from config import URL_PREFIX_UNIX_SOCKET
import WyScan
from WyScan import Service
from WyScan import Device
from threading import Lock

WYSCAN_RECORDING_ID_NULL = 0


class ExternalDVBManagerInterface(object):
	
	def __init__(self, wyscan):
		self.wyscan = wyscan
		return None

	def startService(self, service, device, uri, service_to_stop=WYSCAN_RECORDING_ID_NULL):
		return {'status': error.WYRECORD_UNKNOWN_ERROR}

	def stopService(self, wyscan_recording_id):
		return error.WYRECORD_SUCCESS

	@Chrono(['wyrecord'])
	def GetCurrentUTCTime(self):
		return int(time.time())
	
	@Chrono(['wyrecord'])
	def GetDeviceCurrentUTCTime(self, nDeviceID):
		return int(time.time())

	# Return list of devices that support the given service
  # Result[] : Array of WyScan.Device() objects.
	def GetPlayableServiceDevices(self, nServiceID):
		return []

	# Check if Services can be played at the same time on 2 devices (or same device) (regarding DVB adapters configuration (ie: satellite configuration/etc.).
	# (does not check device availability)
	# Result: True / False
	def AreServicesPlayable(self, nDeviceID1, nServiceID1, nDeviceID2, nServiceID2):
		log.info('call Record_AreServicesCompatible')
		return False

	def EPGFromProgramId(self, program_id):
		ret = None
		return ret

	def startExternEIT(self, path, serviceid):
		return None

	def stopExternEIT(self):
		return None

	def StopDeviceRecordings(self, nDeviceID=0):
		return False

	def GetService(self, nServiceID):
		return None

	def GetServiceByName(self, service_name):
		return None

	# nDeviceID = -1 => All Devices
	# nDeviceType :
	#     => -1 : All Type of Devices
	#     => 1 : DVB-T
	#     => 2 : DVB-S
	#     => 4 : DVB-C
	#     => 8 : ATSC
	#     => 16 : Analog Acquisition (Capture) device
	# Result: Array of Devices
	#    result[i][0] = DeviceID
	#    result[i][1] = Name
	#    result[i][2] = Type (same as nDeviceType)
	#    result[i][3] = Position
	#    result[i][4] = Frontend device name (ex: /dev/dvb/adapter0/frontend0)
	#    result[i][5] = Demux device name
	#    result[i][6] = Primary device ID
	#    result[i][7] = Priority
	def GetDevices(self, nDeviceID=-1, nDeviceType=-1):
		return []



class ExternalDVBManager(ExternalDVBManagerInterface):

	def __init__(self, wyscan):
		self.wyscan = wyscan
		self.lock = Lock()
		return None

	# Ask WYPLAY Record server to start a record
	# It also depends on current configuration (use timeshift / unix socket ? etc.)
	# Result{}:
	# ['status'] = Status
	# ['wyscan_recording_id'] = Recording ID coming from WYPLAY Record Server
	# ['deviceid'] = Device ID on which recording is started
	def startService(self, service, device, uri, service_to_stop=WYSCAN_RECORDING_ID_NULL):
		if not uri.startswith(URL_PREFIX_UNIX_SOCKET):
			return {'status': error.WYRECORD_UNKNOWN_ERROR}
		unix_socket_path = uri[len(URL_PREFIX_UNIX_SOCKET):]
		parameters = "unix_socket_path='%s'" % unix_socket_path
		self.lock.acquire()
		try:
			timestep('dvb_start_service_init')
			if not service_to_stop:
				result = self.wyscan.Record_StartRecordingEx(device, service, 'NormalLive', parameters, 2)
				timestep('wyscan.Record_StartRecordingEx')
			else:
				result = self.wyscan.Record_ZapEx(service_to_stop, device, service, 'NormalLive', parameters, 2)
				timestep('wyscan.Record_ZapEx')
			self.lock.release()
		except BaseException, e:
			self.lock.release()
			log.debug(str(e))
			return {'status': error.WYRECORD_UNKNOWN_ERROR}
		if result[0] != 0:
			log.error("Can not start recording '%s' (Error %d)" % (service, result[0]))
			return {'status': error.WYRECORD_UNKNOWN_ERROR}
		recording_id = result[1]
		device_id = result[2]
		return {'status': error.WYRECORD_SUCCESS, 'wyscan_recording_id': recording_id, 'deviceid': device_id}

	# Ask WYPLAY Record server to stop a record
	# Result: = Status
	def stopService(self, wyscan_recording_id):
		timestep('dvb_stop_service_init')
		self.lock.acquire()
		try:
			result = self.wyscan.Record_StopRecording(wyscan_recording_id)
		except BaseException, e:
			self.lock.release()
			log.debug(str(e))
			return error.WYRECORD_UNKNOWN_ERROR
		self.lock.release()
		timestep('dvb_stop_service_wyscan_time')
		if result != 0:
			log.error('Can not stop recording %d' % wyscan_recording_id)
			return error.WYRECORD_BAD_RECORDING_ID
		return error.WYRECORD_SUCCESS

	@Chrono(['wyrecord'])
	def GetCurrentUTCTime(self):
		return int(time.time())

	@Chrono(['wyrecord'])
	def GetDeviceCurrentUTCTime(self):
		return int(time.time())

	# Return list of devices that support the given service
	# Result[] : Array of WyScan.Device() objects.
	def GetPlayableServiceDevices(self, nServiceID):
		ret = []
		self.lock.acquire()
		try:
			ret = [WyScan.Device(dev) for dev in self.wyscan.GetServiceDevices(nServiceID)]
		except BaseException, e:
			log.debug(str(e))
		self.lock.release()
		return ret

	# Check if Services can be played at the same time on 2 devices (or same device) (regarding DVB adapters configuration (ie: satellite configuration/etc.).
	# (does not check device availability)
	# Result: True / False
	def AreServicesPlayable(self, nDeviceID1, nServiceID1, nDeviceID2, nServiceID2):
		log.info('call Record_AreServicesCompatible')
		self.lock.acquire()
		ret = False
		try:
			if self.wyscan.Record_AreServicesCompatible(nDeviceID1, nServiceID1, nDeviceID2, nServiceID2) == 0:
				ret = True
		except BaseException, e:
			log.debug(str(e))
		self.lock.release()
		return ret

	def EPGFromProgramId(self, program_id):
		self.lock.acquire()
		ret = None
		try:
			ret = self.wyscan.EPGFromProgramId(program_id)
		except BaseException, e:
			log.debug(str(e))
		self.lock.release()
		return ret

	def startExternEIT(self, path, serviceid):
		self.lock.acquire()
		try:
			self.wyscan.startExternEIT(path, serviceid)
		except BaseException, e:
			log.debug(str(e))
		self.lock.release()
		return None

	def stopExternEIT(self):
		self.lock.acquire()
		try:
			self.wyscan.stopExternEIT(0)
		except BaseException, e:
			log.debug(str(e))
		self.lock.release()
		return None

	def StopDeviceRecordings(self, nDeviceID=0):
		self.lock.acquire()
		ret = False
		try:
			if self.wyscan.Record_StopDeviceRecordings(nDeviceID) == 0:
				ret = True
		except BaseException, e:
			log.debug(str(e))
		self.lock.release()
		return ret

	def GetService(self, nServiceID):
		try:
			self.lock.acquire()
			result = self.wyscan.GetService(nServiceID, nFormat=2)
			self.lock.release()
		except BaseException, e:
			log.debug(str(e))
			self.lock.release()
			return None
		if result[0] != 0:
			return None
		if len(result[1]) == 0:
			return None
		return WyScan.Service(result[1][0], 2)

	# Returns list of service ids of the given service name
	# Result : WyScan.Service() object or None
	def GetServiceByName(self, service_name):
		self.lock.acquire()
		try:
			result = self.wyscan.GetServicesByName(service_name)
		except BaseException, e:
			log.debug(str(e))
			self.lock.release()
			return None
		self.lock.release()
		if result[0] != 0:
			return None
		return Service(result[1][0], 0)

	# nDeviceID = -1 => All Devices
	# nDeviceType :
	#     => -1 : All Type of Devices
	#     => 1 : DVB-T
	#     => 2 : DVB-S
	#     => 4 : DVB-C
	#     => 8 : ATSC
	#     => 16 : Analog Acquisition (Capture) device
	# Result: Array of Devices
	#    result[i][0] = DeviceID
	#    result[i][1] = Name
	#    result[i][2] = Type (same as nDeviceType)
	#    result[i][3] = Position
	#    result[i][4] = Frontend device name (ex: /dev/dvb/adapter0/frontend0)
	#    result[i][5] = Demux device name
	#    result[i][6] = Primary device ID
	#    result[i][7] = Priority
	def GetDevices(self, nDeviceID=-1, nDeviceType=-1):
		self.lock.acquire()
		try:
			result = self.wyscan.GetDevices(nDeviceID, nDeviceType)
		except BaseException, e:
			log.debug(str(e))
			self.lock.release()
			return []
		self.lock.release()
		return result
