# -*- coding: utf-8 -*- 
#
# Description:
#
# WyRecord Chunk Info Class Definition
#
#
#
# Changes:
#
# 2014-03-26
# Initial Commit
#
#
# Copyright 2010-2014, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.


import os
import glob
import time
from config import *
from logger import log


def UriChunkToPath(uri):
	return os.path.split(uri[len(URL_PREFIX_TIMESHIFT):])[0]


class ValidityCheck(object):

	def __init__(self):
		return None

	def __call__(self, f):
		def manage_wyrecord_lock(self_chunk_info, *args, **kwds):
			self_chunk_info.checkDataValidity()
			f_result = f(self_chunk_info, *args, **kwds)
			return f_result
		return manage_wyrecord_lock



# Analyse chuncks into a directory.
# Give a chunk file from an offset (global)
# Give a time from an offset
class ChunkInfo(object):

	def __init__(self, timeshift_folder, chunk_file_name_format=config.timeshift_chunk_file_base_name):
		self.timeshift_folder = timeshift_folder
		self.chunk_file_name_format = chunk_file_name_format
		self.first_time = 0
		self.offset_at_first_time = 0
		self._ChunkInfo__validity = 0
		self._ChunkInfo__chunk_file_list = None
		self.offset_to_play = 0
		self._ChunkInfo__deleted_bytes = 0
		self._ChunkInfo__live_offset = 0
		self._ChunkInfo__bytes_per_sec = config.bytes_per_sec
		return None

	def refTimeUpdated(self, delta_t):
		self.first_time -= delta_t
		self._ChunkInfo__validity = 0
		return None

	def saveReadOffset(self, offset):
		self.offset_to_play = offset
		return None

	def checkDataValidity(self):
		current_time = time.time()
		if current_time - self._ChunkInfo__validity > 10 or current_time - self._ChunkInfo__validity > 1 and self._ChunkInfo__validity - self.first_time < 15:
			self._ChunkInfo__computeData(current_time)
		return None

	@ValidityCheck()
	def getReadOffset(self):
		offset = self.offset_to_play
		if not offset:
			offset = self._ChunkInfo__getLiveOffset()
		return offset

	# System time is used now => no synchronisation needed
	def synchronyseStartTime(self, wyrecord_start_time):
		self.offset_at_first_time = 0
		self.first_time = wyrecord_start_time
		return None

	def _ChunkInfo__computeData(self, current_time):
		log.debug('__computeData')
		chunk_file_list = self._getSortedFilelist()
		self._ChunkInfo__chunk_file_list = chunk_file_list
		if not chunk_file_list:
			self._ChunkInfo__deleted_bytes = 0
			self._ChunkInfo__live_offset = 0
			self._ChunkInfo__bytes_per_sec = config.bytes_per_sec
			log.debug('__computeData: NO chunk file')
		else:
			self._ChunkInfo__validity = current_time
			fisrt_chunk_file = os.path.split(chunk_file_list[0])[1]
			index = int(fisrt_chunk_file[len(config.timeshift_chunk_file_base_name):-len(config.timeshift_chunk_file_extention)])
			self._ChunkInfo__deleted_bytes = index * config.timeshift_chunk_max_size
			tmp_offset = self._ChunkInfo__deleted_bytes
			tmp_offset += config.timeshift_chunk_max_size * (len(chunk_file_list) - 1)
			tmp_offset += os.path.getsize(chunk_file_list[-1])
			self._ChunkInfo__live_offset = tmp_offset
			last_file_time = current_time
			first_file_time = self.first_time
			self._ChunkInfo__bytes_per_sec = (self._ChunkInfo__live_offset - self.offset_at_first_time) / (last_file_time - first_file_time)
		return None

	# Get live offset.
	def _ChunkInfo__getLiveOffset(self):
		return self._ChunkInfo__live_offset + (time.time() - self._ChunkInfo__validity) * self._ChunkInfo__bytes_per_sec

	# Key function for chunk info
	@ValidityCheck()
	def getBytesPerSec(self):
		return self._ChunkInfo__bytes_per_sec

	@ValidityCheck()
	def getChunkTotalSize(self):
		return self._ChunkInfo__getLiveOffset() - self._ChunkInfo__deleted_bytes

	# Get time at the beginning of the timeshift buffer.
	def getMinimumTimeshiftTime(self):
		return self.getTimeFromOffset(self._ChunkInfo__deleted_bytes)

	# Get time at the end of the timeshift buffer.
	def getMaximumTimeshiftTime(self):
		return time.time()

	# Guess the time of an offset in bytes.
	@ValidityCheck()
	def getTimeFromOffset(self, offset):
		last_file_time = time.time()
		first_file_time = self.first_time
		max_offset = self._ChunkInfo__getLiveOffset()
		if max_offset > offset:
			log.debug('Offset too high: offset => max is ' + str(max_offset))
			return last_file_time
		try:
			file_time = (offset - self.offset_at_first_time) / self._ChunkInfo__bytes_per_sec + first_file_time
		except:
			return last_file_time
		if not file_time:
			return last_file_time
		return file_time

	# Get the list of chunk file is the right order.
	def _getSortedFilelist(self):
		chunk_file_list = glob.glob(os.path.join(self.timeshift_folder, self.chunk_file_name_format) + '*')
		chunk_file_list.sort()
		return chunk_file_list

	# Retrieve the chunk file from an offset.
	def getChunkFromOffset(self, offset):
		self._ChunkInfo__computeData(time.time())
		tmp_offset = self._ChunkInfo__deleted_bytes
		for f in self._ChunkInfo__chunk_file_list:
			tmp_offset += os.path.getsize(f)
			if tmp_offset >= offset:
				break
		else:
			log.error('no chunk found tmp= ' + str(tmp_offset) + ' offset' + str(offset))
			return ''
		return f
