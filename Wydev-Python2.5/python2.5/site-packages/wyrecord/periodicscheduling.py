# -*- coding: utf-8 -*- 
#
# Description:
#
# WyRecord Periodic Scheduling Class Definition
#
# This module gives a set of class useful to schedule a periodic event
# 
# Usage : call GetNextTime method in order to get next occurence
#     => return an Except
# 
# UseCase sample :
# 
# 1) dayly repeat datetime = t1 => 
#     repetitionRule = DailyRule()
#     repetitionRule.GetNext(t2,t1,True) => return the first datetime after t2 
#     that match t1 reference  and the repetition  rule
# 
# 2) same for weekly => repetitionRule = WeeklyRepetition
#     repetitionRule = WeeklyRule()
# 
# 3) monday to friday
#     repetitionRule = DayListRule(range(5))
#     
# 5) tuesday, saturday, sunday
#     repetitionRule = DayListRule([1,5,6])
#     
# 6) first day of the month
#     repetitionRule = RelativeDayPosInMonthRule(0)
#     
# 7) last day of the month 
#     repetitionRule = RelativeDayPosInMonthRule(-1)
# 
# 7) last saturday of the month
#     repetitionRule = RelativeDayPosInMonthRule(-7)                    => 7 day before the end of the month
#     repetitionRule.child = DayListRule([5], datetime.timedelta(7))    => every saturday during 7 days (means first saturday)
# 
# 8) first saturday of the month
#     repetitionRule = RelativeDayPosInMonthRule(0)                        => first day of the month
#     repetitionRule.child = DayListRule([5], datetime.timedelta(7))       => every saturday during 7 days (means first saturday)
#
# Changes:
#
# 2014-03-26
# Initial Commit
#
#
# Copyright 2010-2014, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.


import datetime
import time
import xml.etree.cElementTree as ET
from recording import Recording
from logger import log


# Main class
# 
# Manage the GetNextTime algorithm
# Manage the generic limit time check
# Manage reccursive child mecanism
# 
# A PeriodicScheduling is used do define a rule of repetition for an event.
# the rule is applied using the only exported interface : GetNextTime
# 
# The optional attribute limit defines the maximum delta time allowed for the rule
# it means that return value of GetNextTime is always less than the "current + self.limit" (where current is a param of GetNextTime) 
class PeriodicScheduling(object):
	
	def __init__(self, limit=None):
		self.id = 0
		self.limit = limit
		self.child = None
		self.extern_rule_name = ''
		self.is_active = False
		self.last_time = None
		self.recording_ref = None
		return None

	def GetExternName(self):
		return self.extern_rule_name

	# Return a time less or equal to minToGo 
	# Params =>
	#     current:  the reference time (time from)
	#     minToGo:  the target time
	# 
	# Must be implemented by derived classes using their own algorithme
	def _NextBeforeOrEqualTarget(self, minToGo, current):
		return None

	# Return a time higher than minToGo 
	# Params =>
	#     current:  the reference time (time from)
	#     minToGo:  the target time
	# 
	# Must be implemented by derived classes using their own algorithme
	def _NextAfterTarget(self, minToGo, current):
		return None

	# Common way of managing the limit time duration
	def _CheckTimeLimitIsOK(self, timeToCheck, timeRef, raiseException=True):
		if self.limit and timeToCheck - timeRef >= self.limit:
			if raiseException:
				raise PeriodicSchedulingException('over limit')
			else:
				return False
		return True

	# Used to get the datetime after (forceTrue if no inclusion) minToGo
	# Current is the current time
	# 
	# MinToGo may be higher or lower than current
	def GetNextTime(self, minToGo, current, forceTrue=False):
		if not self.child:
			ret = self._NextBeforeOrEqualTarget(minToGo, current)
			if ret < minToGo or ret == minToGo and forceTrue:
				ret = self._NextAfterTarget(minToGo, current)
		else:
			ret = self._NextBeforeOrEqualTarget(minToGo, current)
			exception = False
			if self.child:
				try:
					ret = self.child.GetNextTime(minToGo, ret, forceTrue)
				except PeriodicSchedulingException:
					exception = True
			if exception or ret < minToGo or ret == minToGo and forceTrue:
				ret = self._NextAfterTarget(minToGo, current)
				ret = self.child.GetNextTime(minToGo, ret, forceTrue)
		return ret

	# Serialyse itself into oXMLNode
	def SaveToXMLNode(self, oXMLNode):
		if oXMLNode == None:
			return False
		node_ext_name = ET.Element('extern_name')
		node_ext_name.text = self.extern_rule_name
		oXMLNode.append(node_ext_name)
		node_is_active = ET.Element('is_active')
		if self.is_active:
			node_is_active.text = 'true'
		else:
			node_is_active.text = 'false'
		oXMLNode.append(node_is_active)
		if self.last_time:
			node_last_time = ET.Element('last_time')
			DateTimeToXml(node_last_time, self.last_time)
			oXMLNode.append(node_last_time)
		if self.recording_ref:
			node_recording_ref = ET.Element('recording_ref')
			self.recording_ref.SaveToXMLNode(node_recording_ref)
			oXMLNode.append(node_recording_ref)
		if self.limit != None:
			node_limit = ET.Element('limit')
			TimeDeltaToXml(node_limit, self.limit)
			oXMLNode.append(node_limit)
		if self.child != None:
			node_child = ET.Element('child')
			self.child.SaveToXMLNode(node_child)
			oXMLNode.append(node_child)
		return True

	# Fill itself from oXMLNode
	def LoadFromXML(self, oXMLNode):
		if oXMLNode == None:
			return False
		self.extern_rule_name = ''
		node_ext_name = oXMLNode.find('extern_name')
		if node_ext_name != None:
			self.extern_rule_name = node_ext_name.text
		self.is_active = False
		node_is_active = oXMLNode.find('is_active')
		if node_is_active != None:
			if node_is_active.text == 'true':
				self.is_active = True
		self.last_time = None
		node_last_time = oXMLNode.find('last_time')
		if node_last_time:
			self.last_time = GetDateTimeFromXmlNode(node_last_time)
		self.recording_ref = None
		node_recording_ref = oXMLNode.find('recording_ref')
		if node_recording_ref:
			rec = Recording(None, None, None)
			rec.LoadFromXML(node_recording_ref)
			self.recording_ref = rec
		self.limit = None
		node_limit = oXMLNode.find('limit')
		if node_limit != None:
			self.limit = GetTimeDeltaFromXmlNode(node_limit)
		node_child = oXMLNode.find('child')
		if node_child != None:
			rule = GetPeriodicSchedulingInstanceFactory(node_child.attrib['type'])
			rule.LoadFromXML(node_child)
			self.child = rule
		return True


# The rule is a list of datetime.timeldelta
class TimeDeltaListRule(PeriodicScheduling):

	def __init__(self, deltaList=None):
		PeriodicScheduling.__init__(self)
		if deltaList:
			self.deltaList = deltaList
		else:
			self.deltalist = [datetime.timedelta(0)]
		if deltaList:
			deltaList.sort()
		return None

	def _NextBeforeOrEqualTarget(self, minToGo, current):
		ret, last = current + self.deltaList[0], current + self.deltaList[0]
		for i in self.deltaList:
			last = ret
			ret = current + i
			if ret > minToGo:
				break
		return last

	def _NextAfterTarget(self, minToGo, current):
		ret = current + self.deltaList[0]
		for i in self.deltaList:
			ret = current + i
			if ret > minToGo:
				break
		else:
			raise PeriodicSchedulingException('higher failed')
		return ret

	# Return an XML (cElementTree) node representing the current recording
	def SaveToXMLNode(self, oXMLNode):
		if oXMLNode == None:
			return False
		oXMLNode.attrib['type'] = 'time_delta'
		node_time_delta_list = ET.Element('time_delta_list')
		for d in self.deltaList:
			TimeDeltaToXml(node_time_delta_list, d)
		oXMLNode.append(node_time_delta_list)
		PeriodicScheduling.SaveToXMLNode(self, oXMLNode)
		return True

	# Fill Recording() object using oXMLNode (cElementTree) object
	def LoadFromXML(self, oXMLNode):
		if oXMLNode == None:
			return False
		if oXMLNode.attrib['type'] != 'time_delta':
			return False
		PeriodicScheduling.LoadFromXML(self, oXMLNode)
		self.deltaList = []
		node_time_delta_list = oXMLNode.find('time_delta_list')
		if node_time_delta_list != None:
			nodes_d = node_time_delta_list.getiterator('time_delta')
			for node_d in nodes_d:
				self.deltaList.append(GetTimeDeltaFromXmlNode(node_d, False))
		return True


# The rule is a constant period in datetime.timedelta
class ConstantPeriodRule(PeriodicScheduling):

	def __init__(self, period=None, limit=None):
		PeriodicScheduling.__init__(self, limit)
		if period:
			self.period = period
		else:
			self.period = datetime.timedelta(0)
		return None

	def _NextBeforeOrEqualTarget(self, minToGo, current):
		if not self.period:
			raise PeriodicSchedulingException('period null')
		ret, last = current, current
		while ret <= minToGo and self._CheckTimeLimitIsOK(ret, current, False):
			last = ret
			ret += self.period
		return last

	def _NextAfterTarget(self, minToGo, current):
		if not self.period:
			raise PeriodicSchedulingException('period null')
		ret = current
		while ret <= minToGo:
			ret += self.period
		self._CheckTimeLimitIsOK(ret, current)
		return ret

	# Return an XML (cElementTree) node representing the current recording
	def SaveToXMLNode(self, oXMLNode):
		if oXMLNode == None:
			return False
		oXMLNode.attrib['type'] = 'constant_period'
		node_period = ET.Element('period')
		TimeDeltaToXml(node_period, self.period)
		oXMLNode.append(node_period)
		PeriodicScheduling.SaveToXMLNode(self, oXMLNode)
		return True

	# Fill Recording() object using oXMLNode (cElementTree) object
	def LoadFromXML(self, oXMLNode):
		if oXMLNode == None:
			return False
		if oXMLNode.attrib['type'] != 'constant_period':
			return False
		PeriodicScheduling.LoadFromXML(self, oXMLNode)
		self.pos = 0
		node_period = oXMLNode.find('period')
		if node_period != None:
			self.period = GetTimeDeltaFromXmlNode(node_period)
		return True


# The rule is a day offset in month
# 
# 0 means the first day of the month
# -1 means the last day of the month
class RelativeDayPosInMonthRule(PeriodicScheduling):

	def __init__(self, pos=0, limit=None):
		PeriodicScheduling.__init__(self, limit)
		self.pos = pos
		return None

	def _increaseMonth(self, time):
		if time.month == 12:
			return time.replace(year=time.year + 1, month=1)
		else:
			return time.replace(month=time.month + 1)

	def _NextBeforeOrEqualTarget(self, minToGo, current):
		tmp = current.replace(day=1)
		ret, last = tmp + datetime.timedelta(self.pos), tmp + datetime.timedelta(self.pos)
		while ret <= minToGo and self._CheckTimeLimitIsOK(ret, current, False):
			last = ret
			tmp = self._increaseMonth(tmp)
			ret = tmp + datetime.timedelta(self.pos)
		return last

	def _NextAfterTarget(self, minToGo, current):
		tmp = current.replace(day=1)
		ret = tmp + datetime.timedelta(self.pos)
		while ret <= minToGo:
			tmp = self._increaseMonth(tmp)
			ret = tmp + datetime.timedelta(self.pos)
		self._CheckTimeLimitIsOK(ret, current)
		return ret

	# Return an XML (cElementTree) node representing the current recording
	def SaveToXMLNode(self, oXMLNode):
		if oXMLNode == None:
			return False
		oXMLNode.attrib['type'] = 'relative_day_pos_in_month'
		node_pos = ET.Element('pos')
		node_pos.text = str(self.pos)
		oXMLNode.append(node_pos)
		PeriodicScheduling.SaveToXMLNode(self, oXMLNode)
		return True

	# Fill Recording() object using oXMLNode (cElementTree) object
	def LoadFromXML(self, oXMLNode):
		if oXMLNode == None:
			return False
		if oXMLNode.attrib['type'] != 'relative_day_pos_in_month':
			return False
		PeriodicScheduling.LoadFromXML(self, oXMLNode)
		self.pos = 0
		node_pos = oXMLNode.find('pos')
		if node_pos != None:
			self.pos = int(node_pos.text)
		return True


# The rule is a list of days
#
# 0 for monday
# 6 for sunday
class DayListRule(PeriodicScheduling):
	
	def __init__(self, dayList=None, limit=None):
		PeriodicScheduling.__init__(self, limit)
		if dayList:
			self.dayList = dayList
		else:
			self.dayList, dayList = [0], [0]
		return None

	def _findNextDay(self, time, day, acceptFirstDay=False):
		today = time.weekday()
		deltaDay = (day - today) % 7
		if deltaDay == 0:
			if not acceptFirstDay:
				deltaDay = 7
		return time + datetime.timedelta(deltaDay)

	def _NextBeforeOrEqualTarget(self, minToGo, current):
		ret, last = self._findNextDay(current, self.dayList[0], True), self._findNextDay(current, self.dayList[0], True)
		i = 1
		while ret <= minToGo and self._CheckTimeLimitIsOK(ret, current, False):
			last = ret
			ret = self._findNextDay(ret, self.dayList[i % len(self.dayList)])
			i += 1
		return last

	def _NextAfterTarget(self, minToGo, current):
		ret = self._findNextDay(current, self.dayList[0], True)
		i = 1
		while ret <= minToGo:
			ret = self._findNextDay(ret, self.dayList[i % len(self.dayList)])
			i += 1
		self._CheckTimeLimitIsOK(ret, current)
		return ret

	# Return an XML (cElementTree) node representing the current recording
	def SaveToXMLNode(self, oXMLNode):
		if oXMLNode == None:
			return False
		oXMLNode.attrib['type'] = 'day_list'
		node_days = ET.Element('days')
		for day in self.dayList:
			node_day = ET.Element('day')
			node_day.text = str(day)
			node_days.append(node_day)
		oXMLNode.append(node_days)
		PeriodicScheduling.SaveToXMLNode(self, oXMLNode)
		return True

	# Fill Recording() object using oXMLNode (cElementTree) object
	def LoadFromXML(self, oXMLNode):
		if oXMLNode == None:
			return False
		if oXMLNode.attrib['type'] != 'day_list':
			return False
		PeriodicScheduling.LoadFromXML(self, oXMLNode)
		self.dayList = []
		node_days = oXMLNode.find('days')
		if node_days != None:
			nodes_day = node_days.getiterator('day')
			for node_day in nodes_day:
				self.dayList.append(int(node_day.text))
		return True


# Particular case of ConstantPeriodRule
class DailyRule(ConstantPeriodRule):
	
	def __init__(self, oLimit=None):
		ConstantPeriodRule.__init__(self, datetime.timedelta(1), oLimit)
		return None

	# Return an XML (cElementTree) node representing the current recording
	def SaveToXMLNode(self, oXMLNode):
		if oXMLNode == None:
			return False
		PeriodicScheduling.SaveToXMLNode(self, oXMLNode)
		oXMLNode.attrib['type'] = 'daily'
		return True

	# Fill Recording() object using oXMLNode (cElementTree) object
	def LoadFromXML(self, oXMLNode):
		if oXMLNode == None:
			return False
		if oXMLNode.attrib['type'] != 'daily':
			return False
		PeriodicScheduling.LoadFromXML(self, oXMLNode)
		return True



# Particular case of ConstantPeriodRule
class WeeklyRule(ConstantPeriodRule):
	
	def __init__(self, oLimit=None):
		ConstantPeriodRule.__init__(self, datetime.timedelta(7), oLimit)
		return None

	# Return an XML (cElementTree) node representing the current recording
	def SaveToXMLNode(self, oXMLNode):
		if oXMLNode == None:
			return False
		PeriodicScheduling.SaveToXMLNode(self, oXMLNode)
		oXMLNode.attrib['type'] = 'weekly'
		return True

	# Fill Recording() object using oXMLNode (cElementTree) object
	def LoadFromXML(self, oXMLNode):
		if oXMLNode == None:
			return False
		if oXMLNode.attrib['type'] != 'weekly':
			return False
		PeriodicScheduling.LoadFromXML(self, oXMLNode)
		return True


# Exception raised by PeriodicScheduling objects
class PeriodicSchedulingException(Exception):
	
	def __init__(self, value):
		self.value = value
		return None

	def __str__(self):
		return repr(self.value)


# Factory of PeriodicScheduling object.
#
# Return an object in accordance to parameter rule_type.
def GetPeriodicSchedulingInstanceFactory(rule_type):
	if rule_type == 'weekly':
		instance = WeeklyRule()
	elif rule_type == 'daily':
		instance = DailyRule()
	elif rule_type == 'day_list':
		instance = DayListRule()
	elif rule_type == 'relative_day_pos_in_month':
		instance = RelativeDayPosInMonthRule()
	elif rule_type == 'constant_period':
		instance = ConstantPeriodRule()
	elif rule_type == 'time_delta':
		instance = TimeDeltaListRule()
	else:
		instance = None
	return instance


def DateTimeToXml(oXMLNode, oDateTime):
	oXMLNode.append(ET.Element('date_time', year=str(oDateTime.year), month=str(oDateTime.month), day=str(oDateTime.day), hour=str(oDateTime.hour), minute=str(oDateTime.minute), second=str(oDateTime.second)))
	return None


def GetDateTimeFromXmlNode(oXMLNode):
	node_date_time = oXMLNode.find('date_time')
	if node_date_time != None:
		return datetime.datetime(int(node_date_time.attrib['year']), int(node_date_time.attrib['month']), int(node_date_time.attrib['day']), int(node_date_time.attrib['hour']), int(node_date_time.attrib['minute']), int(node_date_time.attrib['second']))
	return None


def TimeDeltaToXml(oXMLNode, oTimeDelta):
	oXMLNode.append(ET.Element('time_delta', days=str(oTimeDelta.days), seconds=str(oTimeDelta.seconds)))
	return None


def GetTimeDeltaFromXmlNode(oXMLNode, look_for_time_delta=True):
	if look_for_time_delta:
		node_time_delta = oXMLNode.find('time_delta')
	else:
		node_time_delta = oXMLNode
	if node_time_delta != None:
		return datetime.timedelta(int(node_time_delta.attrib['days']), int(node_time_delta.attrib['seconds']))
	return None
