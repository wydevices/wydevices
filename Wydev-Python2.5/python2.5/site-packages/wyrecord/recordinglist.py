# -*- coding: utf-8 -*- 
#
# Description:
#
# WyRecord Recording List Class Definition
#
#
#
# Changes:
#
# 2014-03-26
# Initial Commit
#
#
# Copyright 2010-2014, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.


import sys
import error
from exceptions import *
from recording import Recording
import conflictmanager
import xml.etree.cElementTree as ET
from logger import log
from peewee.analyse import Chrono
from recording import RECORDING_STATUS_UNKNOWN
from recording import RECORDING_STATUS_SCHEDULED
from recording import RECORDING_STATUS_RUNNING
from recording import RECORDING_STATUS_IN_CONFLICT
from recording import RECORDING_STATUS_COMPLETED
from recording import RECORDING_STATUS_CANCELED
from recording import RECORDING_STATUS_MISSED
from recording import RECORDING_STATUS_ABORTED
from recording import RECORDING_TYPE_NORMAL
from recording import RECORDING_TYPE_FLASHBACK
from recording import RECORDING_TYPE_NOT_SCHEDULED


# Used to keep the list of recording.
class RecordingList(object):
	
	def __init__(self, recording_builder, oRecordingManager):
		self.recordings = {}
		self.rec_id_from_program_id = {}
		self.recording_launcher = oRecordingManager
		self.recording_builder = recording_builder
		self.chrono = conflictmanager.ChronologicalRecordingList(self.recording_launcher)
		return None

	# Add a recording in the list.
	# Be carreful => does not check for validity or conflict
	def AddRecording(self, oRecording, program_id='', favorite=''):
		if self.recordings.has_key(oRecording.id):
			log.error('Recording ID already used !')
			return False
		rec_id = 1
		if len(self.recordings) != 0:
			rec_id = 1 + max([recording for recording in self.recordings])
		oRecording.id = rec_id
		self.recordings[oRecording.id] = oRecording
		program_id = str(program_id)
		if program_id:
			self.rec_id_from_program_id[program_id] = oRecording.id
			oRecording.program_id = program_id
		oRecording.favorite = favorite
		log.info('Recording added : ' + str(oRecording))
		return True

	# Retrieve a recording from its id.
	def GetRecording(self, nRecordingID):
		if not self.recordings.has_key(nRecordingID):
			log.error('Recording ID is not valid !')
			return None
		return self.recordings[nRecordingID]

	# Get the recording to start.
	def GetFirstRecordingToStart(self):
		if len(self.recordings) == 0:
			return None
		cur_start_time = 0
		cur_recording = None
		for id, recording in self.recordings.items():
			if recording.status != RECORDING_STATUS_SCHEDULED:
				continue
			elif cur_recording == None:
				cur_recording = recording
				cur_start_time = recording.start_time - recording.start_padding
			elif recording.start_time == 0:
				cur_recording = recording
				break
			elif recording.start_time - recording.start_padding < cur_start_time:
				cur_recording = recording
				cur_start_time = recording.start_time - recording.start_padding
		log.info('record to START = ' + str(cur_recording))
		return cur_recording

	# Get the recording to stop.
	def GetFirstRecordingToStop(self):
		if len(self.recordings) == 0:
			return None
		cur_stop_time = 0
		cur_recording = None
		for id, recording in self.recordings.items():
			if recording.status != RECORDING_STATUS_RUNNING:
				continue
			elif recording.stop_time == 0:
				continue
			elif cur_recording == None:
				cur_recording = recording
				cur_stop_time = recording.stop_time + recording.stop_padding
			elif recording.stop_time + recording.stop_padding < cur_stop_time:
				cur_recording = recording
				cur_stop_time = recording.stop_time + recording.stop_padding
		log.info('record to STOP = ' + str(cur_recording))
		return cur_recording

	# Load all recordings from an xml node
	def LoadFromXML(self, oXMLNode):
		nodes_recording = oXMLNode.getiterator('recording')
		self.recordings.clear()
		for node_recording in nodes_recording:
			recording = self.recording_builder.buildNewRecording()
			if recording.LoadFromXML(node_recording):
				self.recordings[recording.id] = recording
				if recording.program_id:
					self.rec_id_from_program_id[recording.program_id] = recording.id
		return True

	# Save all recordings into an xml node
	def SaveToXMLNode(self, oXMLNode):
		if oXMLNode == None:
			return False
		log.debug('number of record in list: ' + str(len(self.recordings)))
		for id, recording in self.recordings.items():
			node_recording = ET.Element('recording')
			recording.SaveToXMLNode(node_recording)
			oXMLNode.append(node_recording)
		return True

	# Return conflict for the given recording.
	def GetConflict(self, oRecording, ignore_not_scheduled=False):
		if ignore_not_scheduled:
			schedule_or_running = filter((lambda rec: rec.type != RECORDING_TYPE_NOT_SCHEDULED if rec.status == RECORDING_STATUS_RUNNING or rec.status == RECORDING_STATUS_SCHEDULED else False), self.recordings.values())
		else:
			schedule_or_running = filter((lambda rec: rec.status == RECORDING_STATUS_SCHEDULED if rec.status == RECORDING_STATUS_RUNNING), self.recordings.values())
		self.chrono.orderRecording(schedule_or_running)
		return self.chrono.getConflict(oRecording)

	# Return the maximum stop time possible for this recording regarding the whole scheduling
	def GetConflictForMaxTime(self, oRecording):
		stop_time_temp = oRecording.stop_time
		oRecording.stop_time = 0
		schedule_or_running = filter((lambda rec: rec.type != RECORDING_TYPE_NOT_SCHEDULED if rec.status == RECORDING_STATUS_RUNNING or rec.status == RECORDING_STATUS_SCHEDULED), self.recordings.values())
		self.chrono.orderRecording(schedule_or_running)
		conflict = self.chrono.getConflict(oRecording)
		oRecording.stop_time = stop_time_temp
		return conflict

	# Used to check if any conflicts before adding a recording.
	def GetConflictForNotScheduledRecording(self, oRecording, include_instant_record=False):
		if include_instant_record:
			schedule_or_running = filter((lambda rec: rec.status == RECORDING_STATUS_RUNNING if rec.status == RECORDING_STATUS_RUNNING), self.recordings.values())
		else:
			schedule_or_running = filter((lambda rec: rec.type != RECORDING_TYPE_NOT_SCHEDULED if rec.status == RECORDING_STATUS_RUNNING or rec.status == RECORDING_STATUS_SCHEDULED), self.recordings.values())
		self.chrono.orderRecording(schedule_or_running)
		self.chrono.insertRecording(oRecording)
		conflict = self.chrono.getConflict(oRecording)
		return conflict

	# Check if all recording are valid (ie: RecordInfo are valid and their subsequent depend files)
	# Result: True/False
	def CleanUp(self):
		log.info('CleanUp RecordingList')
		recording_to_remove = []
		for id, recording in self.recordings.items():
			if not recording.IsValid():
				recording_to_remove.append(recording)
		for recording in recording_to_remove:
			self.recordings.pop(recording.id)
		return True

	# Remove a recording from the list.
	# If bDelete is True, delete the record from file system
	# 
	# Raise SchedulerRecordingRunningError in case of running record
	def RemoveRecording(self, nRecordingID, bDelete=False):
		recording = self.GetRecording(nRecordingID)
		if recording == None:
			log.error('Bad Recording ID %d !' + str(nRecordingID))
			return False
		if RECORDING_STATUS_RUNNING == recording.status:
			raise SchedulerRecordingRunningError()
		if bDelete:
			recording.record_info.Delete()
		if self.rec_id_from_program_id.has_key(recording.program_id):
			self.rec_id_from_program_id.pop(recording.program_id)
		self.recordings.pop(nRecordingID)
		return True

	# Delete a record physically and in the recording list
	# Result: Status (True / False)
	def RemoveRecord(self, oRecordInfo, bDelete=False):
		log.info('DeleteRecord(): %s ' % oRecordInfo)
		for id, recording in self.recordings.items():
			if recording.record_info.info_file_path_name == oRecordInfo.info_file_path_name:
				log.info('RecordInfo found !!!!!')
				return self.RemoveRecording(recording.id, bDelete)
		return True

	# Return a list of recording that match rule_id the recording are in chronological order
	def GetPeriodicRecordingListByRule(self, rule_id=0):
		if rule_id == 0:
			return []
		list = []
		for recording in self.recordings.itervalues():
			if recording.periodicity_rule_id == rule_id:
				list.append(recording)
		list.sort(key=(lambda x: x.start_time))
		return list
