# -*- coding: utf-8 -*- 
#
# Description:
#
# WyRecord Live Controller Class Definition
#
#
#
# Changes:
#
# 2014-03-26
# Initial Commit
#
#
# Copyright 2010-2014, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.


import time
import error
import live
from config import *
from exceptions import *
from peewee.analyse import Chrono
from peewee.analyse import timestep
from logger import log
from asynchronousaction import AsynchronousAction
from asynchronousaction import AsynchronousZap
from callbacks import Callbacks
from globallock import GlobalLock


# Entry point of wyrecord for live, timeshift and instant record feature.
# It wraps wyplayer to avoid client to use wyplayer on live, timeshift and instant record
# each method raise LiveControllerError exception on error (see docstring)
class LiveController(object):
	
	def __init__(self, wyplayer, live_manager, scheduler, renderer_manager):
		self.wyplayer = wyplayer
		self.renderer_manager = renderer_manager
		self.default_renderer = renderer_manager.getDefaultRenderer()
		self.live_manager = live_manager
		self.scheduler = scheduler
		self._LiveController__last_zap_live = None
		Callbacks().pmt_updated.register(self.selfZap)
		Callbacks().pat_updated.register(self.selfZap)
		self.async_zap = AsynchronousZap(self)
		return None

	# Be sure that full wyplayer api is callable from liveController.
	# Automaticly redirect unknown call to wyplayer
	def __getattr__(self, name):
		return getattr(self.wyplayer, name)

	# Get the list of live that are used
	@GlobalLock()
	def getRunningLiveList(self):
		return self.live_manager.GetRunningLiveList()

	@Chrono(['wyrecord'])
	def zap(self, service_id, **kw):
		if config.asynchronous_zap:
			if self.async_zap.isAlive:
				self.async_zap.appendService(service_id)
			else:
				self.async_zap = AsynchronousZap(self)
				self.async_zap.appendService(service_id)
				self.async_zap.start()
		else:
			self.real_zap(service_id, **kw)
		return None

	# Zap on service service_id.
  #
	# If the service is already in the running live list, the associated live is used.
	# If the service is not found in the running live list, a new live is started.
	# 
	# Exceptions are:
	#     NoLiveAvailableError
	#         => service_id
	#     StartingLiveErrors
	#         => service_id
	#     StartLivePlayingErrors
	#         => service_id
	#         => live_id
	#     LiveInConflictError
	#         => service_id
	#         => conflict_live list of the live to stop in order to play the service
	#     NoDeviceForServiceErrors
	#         => service_id
	# 
	# If zap failed you can use getRunningLiveList to find possible choice.
	@GlobalLock()
	def real_zap(self, service_id, **kw):
		timestep('zap_init')
		AsynchronousAction().pause()
		kw['start_extern_eit'] = True
		live_to_stop = None
		current_live = self._LiveController__getCurrentlive(True)
		if current_live and not current_live.isRecording():
			if config.stop_timeshift_on_zap:
				live_to_stop = current_live
			elif self.default_renderer.isPlaying() and not self.default_renderer.on_pause:
				live_to_stop = current_live
		_live = self.live_manager._GetLiveFromServiceID(service_id)
		if _live:
			if _live == current_live:
				if not self.default_renderer.isPlaying():
					self.default_renderer.play(current_live, **kw)
				AsynchronousAction().resume()
				return None
			if live_to_stop:
				self._LiveController__stopLive(False)
			else:
				try:
					self.stopPlaying()
				except:
					pass
			timestep('checkpoint 1')
			if not self.async_zap.isRequiredService(service_id):
				return None
			current_live = _live
			self.default_renderer.play(current_live, **kw)
			self._LiveController__last_zap_live = _live
		else:
			number_of_running_live = len(self.live_manager.GetRunningLiveList())
			max_number = config.live_count_max
			if live_to_stop:
				max_number += 1
			if number_of_running_live >= max_number:
				raise NoLiveAvailableError(service_id)
			if 281410551873536L & service_id != 281410551873536L and config.nb_virtual_tuner == 1:
				device_to_use = 1
			else:
				device_to_use = self.live_manager.GetDeviceForNewService(service_id, live_to_stop)
			timestep('checkpoint 2')
			if not self.async_zap.isRequiredService(service_id):
				return None
			log.debug('device to use: ' + str(device_to_use))
			if live_to_stop and current_live:
				recorder_to_delete = current_live.getRecorderForPostReset()
				current_live.prepareRecorder(service_id, device_to_use)
				if recorder_to_delete:
					recorder_to_delete.stopRec()
				self.default_renderer.stop()
				current_live.deleteRecorder(recorder_to_delete)
				timestep('checkpoint 3')
				if not self.async_zap.isRequiredService(service_id):
					return None
				zap_res = current_live.zap(service_id, device_to_use, True)
				timestep('checkpoint 4')
				if not self.async_zap.isRequiredService(service_id):
					return None
				if zap_res:
					kw['start_extern_eit'] = False
					self.default_renderer.play(current_live, **kw)
					current_live.postZap()
				self._LiveController__last_zap_live = current_live
				AsynchronousAction().resume()
				if not zap_res:
					raise StartingLiveErrors(service_id)
				return None
			else:
				try:
					self.stopPlaying()
				except:
					pass
			start_live_result = self.live_manager.StartLive(service_id, device_to_use)
			status = start_live_result['status']
			if status != error.WYRECORD_SUCCESS:
				if status == error.WYRECORD_LIVE_ALREADY_USED:
					raise NoLiveAvailableError(service_id)
				else:
					raise StartingLiveErrors(service_id)
			live_id = start_live_result['live_id']
			if live_id == 0:
				raise StartingLiveErrors(service_id)
			current_live = self.live_manager._GetLiveFromLiveID(live_id)
			self.default_renderer.play(current_live, **kw)
			self._LiveController__last_zap_live = current_live
			AsynchronousAction().resume()
		return None

	@GlobalLock()
	def canZap(self):
		current_live = self._LiveController__getCurrentlive(True)
		if current_live and current_live.isRecording():
			number_of_running_live = len(self.live_manager.GetRunningLiveList())
			if number_of_running_live >= config.live_count_max:
				return False
		return True

	# Stop all running live that are not recording
	@GlobalLock()
	def stopAllTimeshift(self):
		current_live = self._LiveController__getCurrentlive(True)
		if current_live and not current_live.isRecording():
			self.stopPlaying()
		self.live_manager.StopAllLiveNotRecording()
		return None

	# Stop playing a live.
	# 
	# If play_another_live==True try to play another running live
	# 
	# Return True if another live is playing
	# 
	# Exceptions are:
	#     StopLiveErrors
	#         => live_id
	@GlobalLock()
	def stopLive(self, play_another_live=True):
		return self._LiveController__stopLive(play_another_live)

	# Stop playing a live.
	# 
	# If play_another_live==True try to play another running live
	# 
	# Return True if another live is playing
	# 
	# Exceptions are:
	#     StopLiveErrors
	#         => live_id
	def _LiveController__stopLive(self, play_another_live=True):
		current_live = self._LiveController__getCurrentlive(True)
		if not current_live:
			log.info('ask to stop a live when no live is running')
			return False
		try:
			self.stopPlaying()
		except:
			log.debug('failed to stop playing')
		stop_live_result = self.live_manager.StopLive(current_live.id)
		status = stop_live_result['status']
		if status != error.WYRECORD_SUCCESS and status != error.WYRECORD_LIVE_NOT_STARTED:
			if status == error.WYRECORD_LIVE_IS_RECORDING:
				raise LiveIsRecordingErrors(current_live.id)
			else:
				current_live = None
				raise StopLiveErrors(current_live.id)
		if play_another_live:
			self._LiveController__playAValidLiveIfAny()
		return None

	def _LiveController__playAValidLiveIfAny(self):
		live_list = self.live_manager.GetRunningLiveList()
		if live_list:
			self.zap(live_list[0].serviceid)
			return True
		return False

	# Start recording current live.
	# 
	#         BadServiceIdErrors
	#         NoDeviceForServiceErrors
	#         SchedulingFailedOnConflictErrors => Record not started
	#         SchedulingDoneWithConflictErrors => Record started but with conflict
	def startRecord(self, duration=0, name=''):
		log.debug('liveController.startRecord')
		current_live = self.getCurrentlive()
		if current_live.isRecording():
			raise LiveIsRecordingErrors(current_live.id)
		start_record_result = self.scheduler.StartLiveRecording(current_live.serviceid, current_live.deviceid, duration, name)
		status = start_record_result['status']
		if status != error.WYRECORD_SUCCESS:
			if status == error.WYRECORD_BAD_SERVICE_ID:
				raise BadServiceIdErrors(current_live.id, current_live.serviceid)
			elif status == error.WYRECORD_NO_DEVICE_FOR_SERVICE:
				raise NoDeviceForServiceErrors(current_live.id, current_live.serviceid)
			elif status == error.WYRECORD_SCHEDULE_CONFLICT:
				raise SchedulingFailedOnConflictErrors(current_live.id, current_live.serviceid, start_record_result['conflict'])
			else:
				raise DefaultLiveControllerError(current_live.id, current_live.serviceid)
		if start_record_result['conflict']:
			raise SchedulingDoneWithConflictErrors(current_live.id, current_live.serviceid, start_record_result['conflict'])
		return None

	# Update the duration for the instant record.
	#
	#	Excecptions:
	#		SchedulingFailedOnDiskSpaceErrors => not enough free space on disk
	#		SchedulingFailedOnConflictErrors => new duration not set because of conflict (happen only on scheduled record)
	#		SchedulingDoneWithConflictErrors => new duration set bu causes conflict (happen only on instant record)
	#		DefaultLiveControllerError => anu other errors	
	def setDuration(self, duration):
		current_live = self.getCurrentlive()
		if duration == 0:
			log.error('live controller seDuration with 0')
			return None
		set_duration_result = self.scheduler.SetRecordingDuration(current_live.current_recordingid, duration, False)
		if set_duration_result['status'] == error.WYRECORD_NOT_ENOUGH_DISK_SPACE:
			raise SchedulingFailedOnDiskSpaceErrors(set_duration_result['needed_space'], set_duration_result['available_space'])
		if set_duration_result['status'] != error.WYRECORD_SUCCESS:
			if set_duration_result['status'] == error.WYRECORD_DURATION_TOO_BIG:
				raise SchedulingFailedOnConflictErrors(current_live.id, current_live.serviceid, set_duration_result['conflict'])
			elif set_duration_result['status'] == error.WYRECORD_SCHEDULE_CONFLICT:
				raise SchedulingDoneWithConflictErrors(current_live.id, current_live.serviceid, set_duration_result['conflict'])
			else:
				raise DefaultLiveControllerError(current_live.id, current_live.serviceid)
		return None

	# Stop the current record.
	#
	# If not recording return False
	#
	# Exception :
	#		DefaultLiveControllerError for any errors	
	def stopRecord(self):
		log.debug('liveController.stopRecord')
		current_live = self.getCurrentlive(True)
		if not current_live or not current_live.current_recordingid:
			return False
		ret = self.scheduler.StopRecording(current_live.current_recordingid, True)
		if not ret:
			raise DefaultLiveControllerError(current_live.id, current_live.serviceid)
		return True

	# Jump in the currently playing stream.
	#
	# Perform a jump of offset seconds relative to the current playing
	# position. Offset may be negative for backward jumps.
	# If offset jumps to a position after the end of the playing stream,
	# playback is directly stopped.
	#
	# Note: This has no effect on streaming URIs such as "unix://" or "http://"
	def seek(self, offset):
		self.wyplayer.seek(offset)
		return None

	def pause(self):
		self._LiveController__set_speed(0)
		return None

	def resume(self):
		self._LiveController__set_speed(1)
		return None

	_LiveController__doc_speed = 'floating point number indicating the current playback speed.\n\n           playback state is converted from speed as follows:\n\n            - speed < -1.0: fast backward playback\n            - speed = -1.0: normal speed backward playback\n               - -1.0 < speed < 0.0: slow backward playback\n            - speed = 0.0: pause\n            - 0.0 < speed < 1.0: slow forward playback\n            - speed = 1.0: normal speed forward playback\n            - 1.0 < speed: fast forward playback\n\n           note: in the current wyplayer implementation, backward playback\n           supports only a single speed which is dependent on the specific\n           media stream (depends on spacing between key video frames).\n        '

	# Floating point number indicating the current playback speed.

	# 	Playback state is converted from speed as follows:
	# 	
	# 	 - speed < -1.0: fast backward playback
	# 	 - speed = -1.0: normal speed backward playback
	# 	    - -1.0 < speed < 0.0: slow backward playback
	# 	 - speed = 0.0: pause
	# 	 - 0.0 < speed < 1.0: slow forward playback
	# 	 - speed = 1.0: normal speed forward playback
	# 	 - 1.0 < speed: fast forward playback
	# 	
	# 	Note: In the current wyplayer implementation, backward playback
	# 	supports only a single speed which is dependent on the specific
	# 	media stream (depends on spacing between key video frames).
	def _LiveController__get_speed(self):
		return self.wyplayer.speed

	def _LiveController__set_speed(self, speed):
		self.wyplayer.speed = speed
		if speed == 0:
			self.default_renderer.savePausePosition()
		else:
			self.default_renderer.resetPositionSaving()
		return None

	speed = property(fget=_LiveController__get_speed, fset=_LiveController__set_speed, doc=_LiveController__doc_speed)

	def getEPGFromProgramId(self, program_id):
		current_live = self.getCurrentlive()
		return current_live.external_dvb_manager.EPGFromProgramId(program_id)

	# Retrieve current time of given live (useful to locate properly a Program evolution)
	def getLiveCurrentUTCTime(self):
		current_live = self.getCurrentlive()
		return current_live.external_dvb_manager.GetDeviceCurrentUTCTime(current_live.deviceid)

	# Raise an exception if current live does not exist.
	# Used to get current live.
	@GlobalLock()
	def getCurrentlive(self, no_exception=False):
		return self._LiveController__getCurrentlive(no_exception)

	# Raise an exception if current live does not exist.
	# Used to get current live.
	def _LiveController__getCurrentlive(self, no_exception=False):
		current_live = self.default_renderer.live
		if not current_live:
			live_list = self.live_manager.GetRunningLiveList()
			if live_list:
				if self._LiveController__last_zap_live in live_list:
					current_live = self._LiveController__last_zap_live
				else:
					current_live = live_list[0]
		if no_exception:
			return current_live
		if not current_live:
			raise NoLiveStartedErrors()
		return current_live

	def stopPlaying(self):
		self.default_renderer.stop()
		return None

	@GlobalLock()
	def playCurrentLive(self):
		current_live = self._LiveController__getCurrentlive()
		self.default_renderer.play(current_live)
		return None

	# Used to rezap on current live ...
	@GlobalLock()
	def selfZap(self):
		log.debug('selfZap called')
		current_live = self._LiveController__getCurrentlive(True)
		if current_live:
			service_id = current_live.serviceid
			log.debug('selfZap stop current live')
			self._LiveController__stopLive(False)
			log.debug('zap')
			self.zap(service_id)
		return None

	# Close everything up, e.g. when leaving the TV universe.
	@GlobalLock()
	def close(self, wait_player_closed=True):
		self._LiveController__stopLive(False)
		self.live_manager.external_dvb_manager.stopExternEIT()
		self.default_renderer.close(wait_player_closed)
		return None

	_LiveController__doc_current_live = ' here for backward compatibility\n        '

	# Here for backward compatibility
	def _LiveController__get_current_live(self):
		return self.getCurrentlive(True)

	def _LiveController__set_current_live(self, live):
		return None

	current_live = property(fget=_LiveController__get_current_live, fset=_LiveController__set_current_live, doc=_LiveController__doc_current_live)

	# Return the current playing time.
	def getPlayingTimeshiftTime(self):
		return self.default_renderer.getTimeInfo().current_time

	# Get the minimum available time for timeshift.
	def getMinimumTimeshiftTime(self):
		return self.default_renderer.getTimeInfo().min_available_time

	# Get the maximum available time for timeshift.
	def getMaximumTimeshiftTime(self):
		return self.default_renderer.getTimeInfo().max_available_time
