# -*- coding: utf-8 -*- 
#
# Description:
#
# WyRecord Conflict Manager Class Definition
#
#
#
# Changes:
#
# 2014-03-26
# Initial Commit
#
#
# Copyright 2010-2014, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.


import copy
from config import config
from recording import RECORDING_TYPE_IS_LIVE
from logger import log



# Element used by ChronologicalRecordingList.
#
# A chronological element is defined by:
#  A start time
#  A stop time
#  The list of simultaneous recording during this laps of time
#
# This element is used to store the recordings (self.recording_list) that should be played
# at the same time from self.start to self.stop.
#
# It can compute the list of recording that are in conflict.
class ChronologicalElement(object):

	def __init__(self, are_services_playable, start=-2147483640, stop=0, rec_list=None, next_elem=None, previous_elem=None):
		self.start = start
		self.stop = stop
		self.are_services_playable = are_services_playable
		if not rec_list:
			self.recording_list = []
		else:
			self.recording_list = rec_list
		return None

	# Manage the copy of an elemnt.
	# Useful to split an element.
	def getCopy(self):
		return ChronologicalElement(self.are_services_playable, copy.copy(self.start), copy.copy(self.stop), copy.copy(self.recording_list))

	# Check if the recording in rec_list can play together.
	# "possible_devices" are the list of available devices.
	#
	# Return the list of invalid recordings.
	def getInvalidRecordingList(self, first_rec=None, loop=False):
		invalid_rec_list = []
		found_list = {}
		if first_rec in self.recording_list:
			self.recording_list.remove(first_rec)
			self.recording_list.insert(0, first_rec)
		for recording in self.recording_list:
			log.debug('getInvalidRecordingList recording =' + str(recording.id))
			if recording.deviceid != 0:
				possible_devices = [recording.deviceid]
			else:
				possible_devices = recording.possible_deviceids
			device_found = False
			log.debug('getInvalidRecordingList possible_devices =' + str(possible_devices))
			for device in possible_devices:
				failed_to_found = False
				for (found_recording, found_device) in found_list.items():
					if found_recording.service_id == recording.service_id:
						break
					if not self.are_services_playable(found_device, found_recording.service_id, device, recording.service_id):
						break
				recording.deviceid = device
				found_list[recording] = device
				device_found = True
				if device in found_list.values():
					break
			nb_rec = 0
			for rec in found_list.keys():
				if rec.type != RECORDING_TYPE_IS_LIVE:
					nb_rec += 1
			if not device_found or nb_rec > max_simultaneous_rec:
				invalid_rec_list.append(recording)
				if not loop:
					break
		return invalid_rec_list

	def __str__(self):
		s = ''
		s += '\n start ' + str(self.start)
		s += '\n stop ' + str(self.stop)
		s += '\n list , size = ' + str(len(self.recording_list)) + repr([rec.id for rec in self.recording_list])
		return s



# Used to arrange a recording list in a list of ChronologicalElement.
# A logical structure is used to store recording so that conflict checking and resolving
# are easier. The recordings are stored in a continuous list of chronological element.
#
# The goal is to check simultaneous recording.
#
# Usage:
#  Give the list by constructor
#  Update the list by orderRecording
#  Add recording by insertRecording
#  Get result getConflict
class ChronologicalRecordingList(object):

	def __init__(self, recording_launcher, not_ordered_list=None):
		self.elemList = None
		self.recording_launcher = recording_launcher
		self.orderRecording(not_ordered_list)
		return None

	# Update the element list.
	def orderRecording(self, list_to_order):
		self.elemList = [ChronologicalElement(self.recording_launcher.AreServicesPlayable)]
		if list_to_order:
			for rec in list_to_order:
				self.insertRecording(rec)
		return None

	# Add a new recording.
	def insertRecording(self, rec):
		rec.deviceid = 0
		conflict_list = []
		for current_elem in self.elemList:
			if (current_elem.start < rec.stop_time or rec.stop_time == 0) and (current_elem.stop > rec.start_time or current_elem.stop == 0):
				conflict_list.append(current_elem)
		if conflict_list:
			self._ChronologicalRecordingList__checkBegin(conflict_list[0], rec)
			self._ChronologicalRecordingList__checkEnd(conflict_list[-1], rec)
			self._ChronologicalRecordingList__joinList(conflict_list, rec)
		else:
			log.critical('SHOULD NOT HAPPEN CHECK ALGO')
			self.elemList.recording_list.append(rec)
		return None

	# Get a conflict object according to the current element list.
	def getConflict(self, rec):
		conflict = InConflictRecording(self.elemList, rec)
		if conflict.conflict_list:
			return conflict
		return None

	def __str__(self):
		s = 'THE chronological list'
		for current_elem in self.elemList:
			s += current_elem.__str__()
		return s

	# Split first elem if needed.
	def _ChronologicalRecordingList__checkBegin(self, elem, rec):
		if elem.start > rec.start_time:
			new_elem = ChronologicalElement(self.recording_launcher.AreServicesPlayable, rec.start_time, elem.start, [rec])
			self.elemList.insert(self.elemList.index(elem), new_elem)
		elif elem.start < rec.start_time:
			new_elem = elem.getCopy()
			new_elem.stop = rec.start_time
			elem.start = new_elem.stop
			self.elemList.insert(self.elemList.index(elem), new_elem)
		return None

	# Split last elem if needed.
	def _ChronologicalRecordingList__checkEnd(self, elem, rec):
		if elem.stop == 0 and rec.stop_time == 0:
			return None
		if elem.stop > rec.stop_time or elem.stop == 0:
			new_elem = elem.getCopy()
			new_elem.start = rec.stop_time
			elem.stop = new_elem.start
			self.elemList.insert(self.elemList.index(elem) + 1, new_elem)
		elif elem.stop < rec.stop_time or rec.stop_time == 0:
			new_elem = ChronologicalElement(self.recording_launcher.AreServicesPlayable, elem.stop, rec.stop_time, [rec])
			self.elemList.insert(self.elemList.index(elem) + 1, new_elem)
		return None

	# Fill empty slot.
	def _ChronologicalRecordingList__joinList(self, list, rec):
		previous_elem = None
		for elem in list:
			elem.recording_list.append(rec)
			if previous_elem and previous_elem.stop < elem.start:
				new_elem = ChronologicalElement(self.recording_launcher.AreServicesPlayable, previous_elem.stop, elem.start, [rec])
				self.elemList.insert(self.elemList.index(elem), new_elem)
			previous_elem = elem
		return None



# Object that build the list of recording in conflict.
# Conflict should happen only on new recording that have id = 0
#
# It is used to find the valid time range period for the recording of
# id = rec_id
class InConflictRecording(object):

	def __init__(self, chronological_list, rec):
		self.conflict_list = []
		self.in_conflict_rec = []
		self.valid_start_stop_list = []
		self.rec = rec
		self.recording_list_corrupted = True
		if rec == None:
			log.error('can not work without specifying a recording')
			return None
		self._InConflictRecording__computeConflictList(chronological_list)
		self._InConflictRecording__computeValidStartStopTime()
		return None

	# Build the conflict list from the chronological list.
	def _InConflictRecording__computeConflictList(self, chronological_list):
		self.conflict_list = []
		for current_elem in chronological_list:
			if current_elem.recording_list:
				rec_list = current_elem.getInvalidRecordingList(self.rec, True)
				if rec_list:
					self.conflict_list.append(current_elem)
					self.in_conflict_rec.extend(rec_list)
		return None

	# Build the start stop list of valid time for the recording rec_id.  
	# [(start1, stop1), (start2, stop2) ... (startn, stopn)]
	def _InConflictRecording__computeValidStartStopTime(self):
		if not self.conflict_list:
			return None
		rec_start_time = self.rec.start_time
		for chronological_elem in self.conflict_list:
			if self.rec not in chronological_elem.recording_list:
				log.critical('Wyrecor ERROR: recording list is CORRUPTED')
				return None
			if chronological_elem.start > rec_start_time:
				self.valid_start_stop_list.append((rec_start_time, chronological_elem.start))
			rec_start_time = chronological_elem.stop
		if self.rec.stop_time > chronological_elem.stop:
			self.valid_start_stop_list.append((chronological_elem.stop, self.rec.stop_time))
		self.recording_list_corrupted = False
		return None

	def getAllRecInConflict(self):
		return self.in_conflict_rec

	# Quick check if start time of recording rec_id is OK.
	def isStartTimeValid(self):
		if not self.conflict_list:
			return True
		if not self.rec:
			return False
		if not self.valid_start_stop_list:
			return False
		return self.rec.start_time >= self.valid_start_stop_list[0][0]

	def __str__(self):
		s = '\n'
		s += '\nConflict object description: (for rec= '
		s += repr(self.rec_id)
		s += ')'
		s += '\n    recording_list corrupted:'
		if self.recording_list_corrupted:
			s += 'yes'
		else:
			s += 'no'
		s += '\n    conflict list:'
		for elem in self.conflict_list:
			s += elem.__str__()
		s += '\n    valid time list:'
		s += repr(self.valid_start_stop_list)
		return s
