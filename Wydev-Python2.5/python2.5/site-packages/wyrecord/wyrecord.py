# -*- coding: utf-8 -*- 
#
# Description:
#
# WyRecord Initialization Class Definition
#
# Use to initialize full wyrecord feature
#
#
# Changes:
#
# 2014-03-26
# Initial Commit
#
#
# Copyright 2010-2014, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.


import sys
import error
import WyScan
from recordscheduler import RecordScheduler
from livemanager import LiveManager
from livecontroller import LiveController
from recording import RecordingBuilder
from config import *
from diskspaceuse import DiskSpaceChecker
from externaldvbmanager import ExternalDVBManager
from externaldvbmanager import ExternalDVBManagerInterface
from externalrecorderfactory import ExternalRecorderFactory
from renderermanager import RendererManager
from peewee import timers
from logger import log
from dbusapi import DbusSignaler
from dbusapi import DbusListener
from wydbus import WyDbus
from externalstandby import ExternalStandby
from externaldiskspace import ExternalDiskSpace
from tools import removeFolder
from peewee.misc_utils import MetaSingleton
from callbacks import Callbacks
from asynchronousaction import ActionRemoveFolder
from asynchronousaction import AsynchronousAction
from globallock import wyrecord_global_lock



def wyscanFactoryDefault():
	from ConfigParser import ConfigParser
	import os
	wyscan_conf = ConfigParser()
	wyscan_conf.read(config.wyscan_config_file)
	wyscan_db = wyscan_conf.get('global', 'databasefile')
	log.debug('remove ' + wyscan_conf.get('global', 'databasefile'))
	os.remove(wyscan_db)
	return None

def wyrecordFactoryDefault():
	import os
	log.debug('remove ' + config.recordings_list_file)
	os.remove(config.recordings_list_file)
	return None


# Initialise full wyrecord.
#     
# Instanciate a live manager, a scheduler ...
# Optional api live controller is created only on first getLiveController call.
# 
# Attributes:
#     live_manager
#     scheduler
#     live_controller
#     
# Callbacks:
#     newExternEpgAvailableCallback  that takes two args 
#             => ex 
#                 wyrecord.newExternEpgAvailableCallback.register(self.newExternEpgAvailableHandler)
#                 
#                 def newExternEpgAvailableHandler(self, program_id, dbus_player_path)
#                     print live_controller.getEPGFromProgramId(program_id)
#                     
# 
# Lock:  use this lock to protect from concurency access.
# 
# => lock on zap start : release on zap end
# => lock on record start : release on record start end
# => lock on record stop : release on record stop end
# => lock on disk space manager start : release on disk space manager end
# => many lock in livecontroller
class WyRecord(object):
	
	__metaclass__ = MetaSingleton
	
	def __init__(self, wyplayer=None):
		log.info('WyRecord ..........................')
		AsynchronousAction().pause()
		self.wyrecord_global_lock = wyrecord_global_lock
		self.wyscan = WyScan.WYScanServer(config.wyscan_dbus_bus_name, config.wyscan_dbus_path_name, 'com.wyrecord.recordinglauncher')
		self.wydb = self.wyscan.wdb
		self.ext_standby = ExternalStandby(self.wydb)
		self.ext_disk_space = ExternalDiskSpace(self.wydb, config.disk_device)
		self.dbus_signaler = DbusSignaler(self.wydb)
		self.wyplayer = wyplayer
		if config.dummy_wyscan:
			self.external_dvb_manager = ExternalDVBManagerInterface(self.wyscan)
		else:
			self.external_dvb_manager = ExternalDVBManager(self.wyscan)
		nb_device = len(self.external_dvb_manager.GetDevices(nDeviceType=1))
		self.configureDeviceNumber(nb_device)
		self.callbacks = Callbacks(self.external_dvb_manager.wyscan)
		self.external_recorder_factory = ExternalRecorderFactory(self.wydb)
		self.renderer_manager = RendererManager(self.wyplayer)
		self.live_manager = LiveManager(self.external_dvb_manager, self.external_recorder_factory, self.ext_disk_space)
		self.ext_disk_space.live_manager = self.live_manager
		self.recording_builder = RecordingBuilder(self.live_manager, self.external_dvb_manager, self.renderer_manager)
		self.scheduler = RecordScheduler(self.recording_builder, self.external_dvb_manager, self.dbus_signaler, self.ext_disk_space, self.ext_standby)
		self.live_controller = LiveController(self.wyplayer, self.live_manager, self.scheduler, self.renderer_manager)
		self.newExternEpgAvailableCallback = self.external_dvb_manager.wyscan.newExternEpgAvailableCallback
		self.dbus_listener = DbusListener(self.wydb, self.scheduler, self.ext_standby, self.live_manager, self.wyscan)
		if config.disk_space_manager_active:
			self.disk_space_checker = DiskSpaceChecker(self)
			self.timer_disk_space = timers.ThreadedTimer(self.disk_space_checker.checkDiskUsage)
			self.timer_disk_space.start(config.disk_usage_check_period)
		self.ext_standby.RemoveStandbyModule(config.wystandby_id)
		config.wystandby_id = self.ext_standby.AddStandbyModule(config.wystandby_id)
		self.ext_standby.SetMaxPowerState(config.wystandby_id, APM_STATE_OFF)
		removeFolder(config.timeshift_base_folder_path)
		self.scheduler.AsynchronousCheckSchedule(config.scheduler_start_delay)
		AsynchronousAction().resume()
		AsynchronousAction().start()
		return None

	def __del__(self):
		AsynchronousAction().exit()
		return None

	# Optional api for wyrecord.
	# Gives an higher level api for managing live, timeshift and instant record
	def getLiveController(self, wyplayer=None):
		if wyplayer:
			self.setRenderer(wyplayer)
		return self.live_controller

	# Set the timeshift duration in seconds
	def setMaximumTimeshiftDuration(self, duration):
		config.max_size_for_timeshift = duration * config.bytes_per_sec
		return None

	# Set the record padding duration in seconds.
	def setRecordPadding(self, duration):
		config.record_start_padding = duration
		config.record_stop_padding = duration
		return None

	def setRenderer(self, wyplayer):
		self.wyplayer = wyplayer
		self.external_recorder_factory.wyplayer = wyplayer
		self.renderer_manager.default_renderer.wyplayer = wyplayer
		self.live_controller.wyplayer = wyplayer
		return None

	def configureDeviceNumber(self, nb_device):
		log.info('DVB-T devices number = ' + str(nb_device))
		if config.autoconf_tuner and nb_device > 1:
			config.nb_virtual_tuner = nb_device
			config.live_count_max = nb_device
			config.max_simultaneous_rec = nb_device - 1
		return None
