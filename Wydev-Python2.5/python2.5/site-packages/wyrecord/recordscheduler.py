# -*- coding: utf-8 -*- 
#
# Description:
#
# WyRecord Record Scheduler Class Definition
#
#
#
# Changes:
#
# 2014-03-26
# Initial Commit
#
#
# Copyright 2010-2014, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.


import sys
import error
import WyScan
import datetime
import time
from config import *
from exceptions import *
import xml.etree.cElementTree as ET
from peewee.analyse import Chrono
from callbacks import Callbacks
from recording import Recording
from recordinglist import RecordingList
from periodicrecordinglist import PeriodicRecordingList
from tools import WyrecordOnShotTimer
from conflictresolution import AdjustTimeForRec
from conflictresolution import resolveFromAdjustTimeForRec
from recordinfo import RecordInfo
from peewee import notifier
from logger import log
import os
from peewee.analyse import timestep
from asynchronousaction import ActionSaveRecordingList
from asynchronousaction import AsynchronousAction
from periodicscheduling import WeeklyRule
from periodicscheduling import DailyRule
from periodicscheduling import DayListRule
from periodicscheduling import RelativeDayPosInMonthRule
from periodicscheduling import ConstantPeriodRule
from periodicscheduling import TimeDeltaListRule
from recording import RECORDING_ID_NULL
from recording import PERIODICITY_RULE_ID_NULL
from recording import RECORDING_TYPE_NORMAL
from recording import RECORDING_TYPE_FLASHBACK
from recording import RECORDING_TYPE_NOT_SCHEDULED
from recording import RECORDING_STATUS_UNKNOWN
from recording import RECORDING_STATUS_SCHEDULED
from recording import RECORDING_STATUS_RUNNING
from recording import RECORDING_STATUS_IN_CONFLICT
from recording import RECORDING_STATUS_COMPLETED
from recording import RECORDING_STATUS_CANCELED
from recording import RECORDING_STATUS_MISSED
from recording import RECORDING_STATUS_ABORTED
from recording import RECORDING_STATUS_MACROVISION
from recording import RECORDING_STATUS_DISK_SPACE_ERROR
from recording import RECORDING_STATUS_SYSTEM_FAILURE
from globallock import GlobalLock

RECORDING_FLAG_RUNNING = 1
RECORDING_FLAG_COMPLETED = 2
RECORDING_FLAG_INCONFLICT = 4
RECORDING_FLAG_SCHEDULED = 8
RECORDING_FLAG_CANCELED = 16
RECORDING_FLAG_MISSED = 16
RECORDING_FLAG_ALL = 255
RECORDING_EVENT_RECORD_STARTED = 1
RECORDING_EVENT_RECORD_STOPPED = 2
RECORDING_EVENT_RECORD_START_ERROR = 3
RECORDING_EVENT_RECORD_GOING_TO_START = 4
RECORDING_EVENT_RECORD_DISK_SPACE_START_ERROR = 5
RECORDING_EVENT_RECORD_MACROVISION_START_ERROR = 6
RECORDING_EVENT_RECORD_MACROVISION_STOP_ERROR = 7


def GetRecords(strRecordsFolder=''):
	if strRecordsFolder == '':
		strRecordsFolder = config.records_folder
	if not os.path.exists(strRecordsFolder):
		log.error("Record folder '%s' does not exist !" % strRecordsFolder)
		return {'status': error.WYRECORD_BAD_PATH}
	if not os.path.isdir(strRecordsFolder):
		log.error("Record folder '%s' is not a folder !" % strRecordsFolder)
		return {'status': error.WYRECORD_BAD_PATH}
	files = os.listdir(strRecordsFolder)
	record_infos = []
	for file in files:
		info_file = ''
		file_path_name = os.path.join(strRecordsFolder, file)
		if file.endswith(RECORD_INFO_FILE_NAME_SUFFIX):
			info_file = file_path_name
		elif os.path.isdir(file_path_name):
			info_file = os.path.join(file_path_name, RECORD_INFO_FILE_NAME_MULTIPLE_FILE_NAME)
			if not(os.path.isdir(file_path_name) and os.path.isfile(info_file)):
				info_file = ''
		if info_file != '':
			record_info = RecordInfo()
			if (record_info.LoadFromFile(info_file)):
				if record_info.IsValid():
					record_infos.append(record_info)
	return {'status': error.WYRECORD_SUCCESS, 'record_infos': record_infos}



# Manage the scheduling of records.
# Even for instant record.
#   
# Callbacks().recording_event => (RECORDING_EVENT_RECORD_GOING_TO_START, recording, AdjustTimeForRec_object)
#                                (RECORDING_EVENT_RECORD_START_ERROR, recording, None)
#                                (RECORDING_EVENT_RECORD_DISK_SPACE_START_ERROR, recording, None)
#                                (RECORDING_EVENT_RECORD_STARTED, recording, None)
#                                (RECORDING_EVENT_RECORD_STOPPED, recording, None)
class RecordScheduler(object):

	def __init__(self, recording_builder, recording_launcher, dbus_signaler=None, ext_disk_space=None, ext_standby=None):
		self.ext_disk_space = ext_disk_space
		self.dbus_api = dbus_signaler
		self.ext_standby = ext_standby
		self.ext_standby.scheduler = self
		self.recording_launcher = recording_launcher
		self.recording_builder = recording_builder
		self.last_save_time = 0
		self.server = recording_launcher.wyscan
		self.recording_list = RecordingList(recording_builder, self.recording_launcher)
		self.periodic_recording_list = PeriodicRecordingList()
		self.timer_startrecording = WyrecordOnShotTimer(self.cbtimerStart)
		self.timer_stoprecording = WyrecordOnShotTimer(self.cbtimerStop)
		self.timer_pre_start_alert = WyrecordOnShotTimer(self.cbtimerPreStartAlert)
		self.LoadRecordingList()
		self.CheckRecordingStates()
		self.recording_launcher.StopDeviceRecordings(0)    
		return None

	def GetCurrentUTCTime(self):
		return self.recording_launcher.GetCurrentUTCTime()

	def CheckRecordingStates(self):
		for id, recording in self.recording_list.recordings.items():
			if recording.status == RECORDING_STATUS_RUNNING:
				try:
					log.warning('Recording : ' + str(recording))
					recording.Stop(self.GetCurrentUTCTime(), dbus_api=self.dbus_api)
				except BaseException, e:
					log.critical('EXCEPTION ' + str(e))
					log.critical('excpetion on record stop => record is lost')
		return None

	# Retrieve a list of recording basing on some criteria.
	# nFlags : Combination of the one or more of the following values:
	#      RECORDING_FLAG_RUNNING
	#      RECORDING_FLAG_COMPLETED
	#      RECORDING_FLAG_INCONFLICT
	#      RECORDING_FLAG_SCHEDULED
	#      RECORDING_FLAG_CANCELED
	#      RECORDING_FLAG_ALL
	# nRecordingType : Recording Type
	#      RECORDING_TYPE_NORMAL
	#      RECORDING_TYPE_FLASHBACK (not active yet)
	# Result[]:
	# Array of Recording objects
	def GetRecordingList(self, nFlags=RECORDING_FLAG_ALL, nRecordingType=RECORDING_TYPE_NORMAL, ignore_periodic=False):
		recording_list = []
		for recording in self.recording_list.recordings.values():
			if ignore_periodic:
				if recording.periodicity_rule_id != PERIODICITY_RULE_ID_NULL:
					continue
			if nFlags == RECORDING_FLAG_ALL or (nFlags & RECORDING_FLAG_RUNNING and recording.status == RECORDING_STATUS_RUNNING) or (nFlags & RECORDING_FLAG_INCONFLICT and recording.status == RECORDING_STATUS_IN_CONFLICT) or (nFlags & RECORDING_FLAG_COMPLETED and recording.status == RECORDING_STATUS_COMPLETED) or (nFlags & RECORDING_FLAG_CANCELED and recording.status == RECORDING_STATUS_CANCELED) or (nFlags & RECORDING_FLAG_MISSED and recording.status == RECORDING_STATUS_MISSED) or (nFlags & RECORDING_FLAG_SCHEDULED and recording.status == RECORDING_STATUS_SCHEDULED):
				recording_list.append(recording)
		return recording_list

	# Retrieve an existing Recording object.
	def GetRecording(self, nRecordingID):
		log.info('GetRecording(nRecordingID = %d)' % nRecordingID)
		return self.recording_list.GetRecording(nRecordingID)

	# Load recordings from file
	def LoadRecordingList(self):
		try:
			node_root = ET.parse(config.recordings_list_file)
		except EnvironmentError, e:
			log.info(e)
			log.info('the file will be created automaticly')
			return False
		except Exception, e:
			log.critical("Can not parse xml file '%s'" % config.recordings_list_file)
			log.critical('the file is deleted')
			os.remove(config.recordings_list_file)
			return False
		try:
			node_general = node_root.find('general')
			self.last_save_time = int(node_general.attrib['save_time'])
			node_recordings = node_root.find('recordings')
			ret1 = self.recording_list.LoadFromXML(node_recordings)
			node_periodicity = node_root.find('periodicity')
			ret2 = self.periodic_recording_list.LoadFromXML(node_periodicity)
		except Exception, e:
			self.recording_list = RecordingList(self.recording_builder, self.recording_launcher)
			self.periodic_recording_list = PeriodicRecordingList()
			log.critical("Can not parse xml file '%s'" % config.recordings_list_file)
			log.critical('the file is deleted')
			os.remove(config.recordings_list_file)
			return False
		if ret1:
			return ret2
		return ret1

	def SaveRecordingList(self):
		AsynchronousAction().appendAction(ActionSaveRecordingList(self))
		return None

	def RealSaveRecordingList(self):
		timestep('SaveRecordingList begin')
		self.last_save_time = self.recording_launcher.GetCurrentUTCTime()
		root_node = ET.Element('RecordingList')
		node_general = ET.Element('general', version='1.0', save_time=str(self.last_save_time))
		root_node.append(node_general)
		recordings_node = ET.Element('recordings')
		self.recording_list.SaveToXMLNode(recordings_node)
		root_node.append(recordings_node)
		periodicity_node = ET.Element('periodicity')
		self.periodic_recording_list.SaveToXMLNode(periodicity_node)
		root_node.append(periodicity_node)
		tree = ET.ElementTree(root_node)
		try:
			timestep('init_save_recording_list')
			tree.write(config.recordings_list_file, encoding='utf-8')
			timestep('SAVE RECORDING LIST TIME')
		except Exception, e:
			log.critical('RecordScheduler.SaveRecordingList() : Error : ' + str(e))
			timestep('SaveRecordingList end with exception')
			return False
		finally:
			os.fsync(os.open(config.recordings_list_file, os.O_RDWR))
		timestep('SaveRecordingList end')
		return True

	# Stop scheduler timers.
	# Carrefuly use this method. 
	# Always call CheckSchedule later. 
	def StopAll(self):
		log.info('All timers stopped')
		self.timer_stoprecording.stop()
		self.timer_startrecording.stop()
		self.timer_pre_start_alert.stop()
		return None

	def StopAllRunningRecord(self):
		self.StopAll()
		for rec in self.recording_list.recordings.values():
			if rec.status == RECORDING_STATUS_RUNNING:
				self.StopRecording(rec.id, stop_at_player_pos=False)
				rec.status = RECORDING_STATUS_ABORTED
		self.CheckSchedule()
		return None

	@GlobalLock()
	def cbCheckSchedule(self):
		self.CheckSchedule()
		return None
	
	# - Get current time
	# - Check if there are missing recordings in the list
	# - Update the start_recording and stop_recording timers
	def CheckSchedule(self, save_list=True):
		timestep('CheckSchedule begin')
		self.timer_stoprecording.stop()
		self.timer_startrecording.stop()
		self.timer_pre_start_alert.stop()
		bNeedSave = False
		cur_time = self.GetCurrentUTCTime()
		for id, recording in self.recording_list.recordings.items():
			if recording.status != RECORDING_STATUS_SCHEDULED:
				continue
			elif recording.stop_time != 0 and recording.stop_time < cur_time:
				recording.status = RECORDING_STATUS_MISSED
				bNeedSave = True
			elif recording.start_time != 0 and recording.start_time + recording.max_start_delay < cur_time:
				recording.status = RECORDING_STATUS_MISSED
				bNeedSave = True
		if save_list:
			self.SaveRecordingList()
		rec_to_start = self.recording_list.GetFirstRecordingToStart()
		rec_to_stop = self.recording_list.GetFirstRecordingToStop()
		if rec_to_stop != None:
			stop_timer = self.getStopTimer(rec_to_stop)
			if rec_to_start != None:
				start_timer = self.getStartTimer(rec_to_start)
				if stop_timer <= start_timer:
					self.timer_stoprecording.start(stop_timer)
				else:
					self._RecordScheduler__activeStartTimer(start_timer, rec_to_start.id)
			else:
				self.timer_stoprecording.start(stop_timer)
		elif rec_to_start != None:
			start_timer = self.getStartTimer(rec_to_start)
			self._RecordScheduler__activeStartTimer(start_timer, rec_to_start.id)
		timestep('CheckSchedule end')
		return None

	def _RecordScheduler__activeStartTimer(self, t, id):
		self.timer_startrecording.set_args(id)
		self.timer_startrecording.start(t)
		if t > config.pre_start_alert_delay:
			self.timer_pre_start_alert.set_args(id)
			self.timer_pre_start_alert.start(t - config.pre_start_alert_delay)
		return None

	def getStartTimer(self, oRecording):
		if oRecording == None:
			return None
		start_timer = 0
		self.timer_startrecording.set_args(oRecording.id)
		log.info("Next recording to start : ID = %d, '%s' at '%s' => '%s'!" % (oRecording.id, oRecording.name, self.server.DateTime_UTC2Text(oRecording.start_time), self.server.DateTime_UTC2Text(oRecording.stop_time)))
		cur_time = self.GetCurrentUTCTime()
		log.info('start_padding = %d' % oRecording.start_padding)
		if oRecording.start_time - oRecording.start_padding > cur_time:
			log.info('Start rec id %d in %d seconds' % (oRecording.id, oRecording.start_time - oRecording.start_padding - cur_time))
			start_timer = oRecording.start_time - oRecording.start_padding - cur_time
		else:
			log.info('Start rec id %d now !' % oRecording.id)
		if start_timer < 0:
			start_timer = 0
		return start_timer

	def getStopTimer(self, oRecording):
		if oRecording == None:
			return None
		self.timer_stoprecording.set_args(oRecording.id)
		stop_timer = 0
		log.info("Next recording to stop : ID = %d '%s' at '%s' => '%s'!" % (oRecording.id, oRecording.name, self.server.DateTime_UTC2Text(oRecording.start_time), self.server.DateTime_UTC2Text(oRecording.stop_time)))
		cur_time = self.GetCurrentUTCTime()
		log.info('stop_padding = %d' % oRecording.stop_padding)
		if oRecording.stop_time + oRecording.stop_padding > cur_time:
			log.info('Stop rec id %d in %d seconds' % (oRecording.id, oRecording.stop_time + oRecording.stop_padding - cur_time))
			stop_timer = oRecording.stop_time + oRecording.stop_padding - cur_time
		else:
			log.info('Stop rec id %d now !' % oRecording.id)
		if stop_timer < 0:
			stop_timer = 0
		return stop_timer

	def NotifyRecordingStatusChange(self, nEventType, oRecording, inconflict_recordings, live_to_stop_list=None):
		try:
			Callbacks().recording_event.notify(nEventType, oRecording, inconflict_recordings, live_to_stop_list)
		except BaseException, e:
			log.critical('NotifyRecordingStatusChange FAILED => continue anyway')
			log.critical('EXCEPTION ' + str(e))
		return None

	@GlobalLock()
	def cbtimerPreStartAlert(self, nRecordingID):
		try:
			recording = self.GetRecording(nRecordingID)
			if recording == None:
				log.critical('ERROR : BUG TO FIX => Recording %d not found in Recording List (even scheduled to start now !)' % nRecordingID)
				return None
			rec_to_stop_list_id, live_to_stop = recording.GetRecLiveToStop()
			resolver = None
			if rec_to_stop_list_id:
				rec_to_stop_list = [self.GetRecording(rec_id) for rec_id in rec_to_stop_list_id]
				resolver = AdjustTimeForRec(recording, rec_to_stop_list)
			self.NotifyRecordingStatusChange(RECORDING_EVENT_RECORD_GOING_TO_START, recording, resolver, live_to_stop)
		except BaseException, e:
			log.critical('cbtimerPreStartAlert FAILED => continue anyway')
			log.critical('EXCEPTION ' + str(e))
			recording = self.GetRecording(nRecordingID)
			if recording:
				recording.status = RECORDING_STATUS_SYSTEM_FAILURE
			self.CheckSchedule()
		return None
	
	# 1 - Check if device is available for this service now
	# 2 - If not => Choose an other device. If not possible => send a recording error
	# 3 - Ask the Recording Launcher to start recording
	@Chrono(['wyrecord'])
	@GlobalLock()
	def cbtimerStart(self, nRecordingID):
		try:
			log.info('cbtimerStart(recid = %d)' % nRecordingID)
			recording = self.GetRecording(nRecordingID)
			if recording == None:
				log.critical('ERROR : BUG TO FIX => Recording %d not found in Recording List (even scheduled to start now !)' % nRecordingID)
				return None
			if config.resolve_conflict:
				rec_to_stop_list_id, live_to_stop = recording.GetRecLiveToStop()
				if rec_to_stop_list_id:
					rec_to_stop_list = [self.GetRecording(rec_id) for rec_id in rec_to_stop_list_id]
					resolver = AdjustTimeForRec(recording, rec_to_stop_list)
					resolveFromAdjustTimeForRec(resolver)
					self.CheckSchedule()
					return None
			recording_started = False
			free_space = self.ext_disk_space.getAvailableDiskSpace()
			if free_space >= 0:
				if recording.Start(config.resolve_conflict):
					recording_started = True
				elif recording.status == RECORDING_STATUS_MACROVISION:
					log.error('Can not start recording %d because of MACROVISION' % nRecordingID)
				else:
					recording.status = RECORDING_STATUS_IN_CONFLICT
					log.error('Can not start recording %d (probably because of device already use and service not compatible for this use !)' % nRecordingID)
			else:
				recording.status = RECORDING_STATUS_DISK_SPACE_ERROR
			self.CheckSchedule()
			if not recording_started:
				if recording.status == RECORDING_STATUS_MACROVISION:
					self.NotifyRecordingStatusChange(RECORDING_EVENT_RECORD_MACROVISION_START_ERROR, recording, None)
				elif free_space >= 0:
					self.NotifyRecordingStatusChange(RECORDING_EVENT_RECORD_START_ERROR, recording, None)
				else:
					self.NotifyRecordingStatusChange(RECORDING_EVENT_RECORD_DISK_SPACE_START_ERROR, recording, None)
			else:
				self.ext_standby.SetMaxPowerState(config.wystandby_id, APM_STATE_STANDBY)
				self.NotifyRecordingStatusChange(RECORDING_EVENT_RECORD_STARTED, recording, None)
		except BaseException, e:
			log.critical('cbtimerStart FAILED => continue anyway')
			log.critical('EXCEPTION ' + str(e))
			recording = self.GetRecording(nRecordingID)
			if recording:
				recording.status = RECORDING_STATUS_SYSTEM_FAILURE
			self.CheckSchedule()
		return None
	
	# 1 - Ask the Recording Launcher to stop recording
	@GlobalLock()
	def cbtimerStop(self, nRecordingID):
		try:
			log.info('cbtimerStop(recid = %d)' % nRecordingID)
			self.StopRecording(nRecordingID)
		except BaseException, e:
			log.critical('cbtimerStop FAILED => continue anyway')
			log.critical('EXCEPTION ' + str(e))
			recording = self.GetRecording(nRecordingID)
			if recording:
				recording.status = RECORDING_STATUS_SYSTEM_FAILURE
			self.CheckSchedule()
		return None
	
	# Stop a recording.
	# 
	# Stop_at_player_pos is used for timeshift record.
	# If True the last chunk will be the one the player is reading.
	def StopRecording(self, nRecordingID, stop_at_player_pos=False):
		recording = self.GetRecording(nRecordingID)
		if recording == None:
			log.error('StopRecording: Recording %d not found !' % nRecordingID)
			return False
		cur_time = self.GetCurrentUTCTime()
		bResult = recording.Stop(cur_time, stop_at_player_pos, self.dbus_api)
		self.CheckSchedule()
		if not self.IsSomeRecordingRunning():
			self.ext_standby.SetMaxPowerState(config.wystandby_id, APM_STATE_OFF)
		else:
			log.debug('SetMaxPowerState APM_STATE_OFF not colald because some recordings are running')
		if recording.status == RECORDING_STATUS_MACROVISION:
			self.NotifyRecordingStatusChange(RECORDING_EVENT_RECORD_MACROVISION_STOP_ERROR, recording, None)
		else:
			self.NotifyRecordingStatusChange(RECORDING_EVENT_RECORD_STOPPED, recording, None)
		return bResult

	# Start an instant record.
	def StartLiveRecording(self, nServiceID, nForcedDeviceID=0, duration=0, name=''):
		current_time = self.GetCurrentUTCTime()
		if duration != 0:
			end_time = current_time + duration
		else:
			end_time = 0
		res = self._initialyseNewRec(nServiceID, current_time, end_time, name, nForcedDeviceID)
		if res['status'] != error.WYRECORD_SUCCESS:
			return res
		newrecording = res['new_rec']
		newrecording.start_padding = 0
		newrecording.stop_padding = 0
		conflict = self.recording_list.GetConflictForNotScheduledRecording(newrecording, include_instant_record=True)
		if conflict:
			if not conflict.isStartTimeValid():
				return {'status': error.WYRECORD_SCHEDULE_CONFLICT, 'recording_id': RECORDING_ID_NULL, 'conflict': conflict}
			else:
				if config.auto_adjust_instant_record_stop_time:
					newrecording.stop_time = conflict.valid_start_stop_list[0][1]
		newrecording.MarkAsInstantRecording()
		newrecording.type = RECORDING_TYPE_NOT_SCHEDULED
		if not self.recording_list.AddRecording(newrecording):
			log.error('Can not add recording in list')
			return {'status': error.WYRECORD_UNKNOWN_ERROR, 'recording_id': RECORDING_ID_NULL}
		newrecording.status = RECORDING_STATUS_SCHEDULED
		self.CheckSchedule(False)
		return {'status': error.WYRECORD_SUCCESS, 'recording_id': newrecording.id, 'stop_time': newrecording.stop_time, 'conflict': conflict}

	# Schedule a recording for the given service. The Record Manager will check with existing recordings if any conflict can occur while the recording starts. 
	# It also will predicate the best device to use to record the service.
	# If any conflict occurs, this function returns a Conflict object that describes precisely the conflict and the recordings that are in conflict with the hoped recording.
	# If Start time is 0 => the record will start immediately if no conflict is found.
	# 
	# return:
	#     the scheduled recording_instance
	def ScheduleRecording(self, nServiceID, nStartTime, nStopTime, strRecordingName='', nForcedDeviceID=0, start_padding=-1, stop_padding=-1, check_schedule=True, program_id='', favorite=''):
		if nStartTime >= nStopTime:
			raise SchedulerOtherError()
		res = self._initialyseNewRec(nServiceID, nStartTime, nStopTime, strRecordingName, nForcedDeviceID, start_padding, stop_padding)
		status = res['status']
		if status != error.WYRECORD_SUCCESS:
			if status == error.WYRECORD_BAD_SERVICE_ID:
				raise SchedulerBadServiceIdError(nServiceID)
			elif status == error.WYRECORD_NO_DEVICE_FOR_SERVICE:
				raise SchedulerNoDeviceForServiceError(nServiceID)
			elif status == error.WYRECORD_FORCED_DEVICE_INVALID:
				raise SchedulerForcedDeviceNotValidError(nServiceID, nForcedDeviceID)
			else:
				raise SchedulerOtherError()
		newrecording = res['new_rec']
		conflict = self.recording_list.GetConflictForNotScheduledRecording(newrecording, include_instant_record=True)
		instant_rec_in_conflict = None
		if conflict:
			for rec in conflict.getAllRecInConflict():
				if rec.type != RECORDING_TYPE_NOT_SCHEDULED:
					raise SchedulerConflictError(conflict)
				instant_rec_in_conflict = rec
		if not self.recording_list.AddRecording(newrecording, program_id, favorite):
			raise SchedulerOtherError()
		newrecording.status = RECORDING_STATUS_SCHEDULED
		if instant_rec_in_conflict and config.auto_adjust_instant_record_stop_time:
			instant_rec_in_conflict.stop_time = newrecording.start_time
			log.debug('### new instant record duration is: ' + str(instant_rec_in_conflict.stop_time - instant_rec_in_conflict.start_time))
		if check_schedule:
			self.CheckSchedule()
		if conflict:
			raise SchedulerConflictWithInstantRecordError(conflict)
		return newrecording

	# Schedule a recording for the given service. The Record Manager will check with existing recordings if any conflict can occur while the recording starts. 
	# It also will predicate the best device to use to record the service.
	# If any conflict occurs, this function returns a Conflict object that describes precisely the conflict and the recordings that are in conflict with the hoped recording.
	# If Start time is 0 => the record will start immediately if no conflict is found.
	# Result{}:
	# 	['status'] = Status
	# 	['recording_id'] = Recording ID (if RECORDING_ID_NULL => No recording)
	# 	['conflict_recordings'] = If not None : Array of in conflict recordings
	def _initialyseNewRec(self, nServiceID, nStartTime, nStopTime, strRecordingName='', nForcedDeviceID=0, start_padding=-1, stop_padding=-1):
		nStartTime = int(nStartTime)
		nStopTime = int(nStopTime)
		service = self.recording_launcher.GetService(nServiceID)
		if service == None:
			return {'status': error.WYRECORD_BAD_SERVICE_ID}
		devices = self.recording_launcher.GetPlayableServiceDevices(service.id)
		if len(devices) == 0:
			return {'status': error.WYRECORD_NO_DEVICE_FOR_SERVICE}
		deviceids = [device.id for device in devices]
		if nForcedDeviceID != 0:
			if nForcedDeviceID not in deviceids:
				log.warning('ScheduleRecording : Wanted deviceid %d for recording not possible ath this moment !!' % nForcedDeviceID)
				return {'status': error.WYRECORD_FORCED_DEVICE_INVALID, 'recording_id': RECORDING_ID_NULL}
			deviceids = [nForcedDeviceID]
		log.info('deviceids ' + str(deviceids))
		if start_padding < 0:
			start_padding = config.record_start_padding
		if stop_padding < 0:
			stop_padding = config.record_stop_padding
		if nStartTime == 0:
			nStartTime = self.last_save_time
		newrecording = self.recording_builder.buildNewRecording(strRecordingName, service, deviceids, nStartTime, nStopTime, start_padding, stop_padding, config.max_start_delay)
		return {'status': error.WYRECORD_SUCCESS, 'new_rec': newrecording}

	# Delete a recording physically and in the recording list
	# Stop it if running.
	# Result: Status (True / False)
	# Rise: SchedulerRecordingRunningError (in case of running record)
	def DeleteRecording(self, nRecordingID):
		return self.recording_list.RemoveRecording(nRecordingID, True)

	# Delete a record physically and in the recording list
	# Result: Status (True / False)
	def DeleteRecord(self, oRecordInfo):
		return self.recording_list.RemoveRecord(oRecordInfo, True)

	# return[]:
	# ['status'] : Status
	# ['max_stop_time'] : maximum possible stop time for the given recording ID
	#                     if 0 => Infinite !
	def GetRecordingPossibleMaxStopTime(self, nRecordingID):
		recording = self.GetRecording(nRecordingID)
		if recording == None:
			log.error('Bad Recording ID %d !', nRecordingID)
			return {'status': error.WYRECORD_BAD_RECORDING_ID}
		max_stop_time = 0
		conflict = self.recording_list.GetConflictForMaxTime(recording)
		if conflict:
			if conflict.isStartTimeValid():
				max_stop_time = conflict.valid_start_stop_list[0][1]
			else:
				log.critical('recording list corrupted, Recording ID %d !', nRecordingID)
				return {'status': error.WYRECORD_RECORDING_LIST_CORRUPTED}
		return {'status': error.WYRECORD_SUCCESS, 'max_stop_time': max_stop_time}

	# Used to update recording name.
	def UpdateRecordingName(self, nRecordingID, new_name):
		recording = self.GetRecording(nRecordingID)
		if recording == None:
			log.error('Bad Recording ID %d !', nRecordingID)
			return {'status': error.WYRECORD_BAD_RECORDING_ID}
		recording.name = new_name
		self.SaveRecordingList()
		return None

	# Change the recording duration.
	# if nDuration == 0 : the recording has no more stop time => infinite
	# if nDuration != 0 : Change recording's duration accordingly. 
	#                  If duration have to be shorter:
	#                       if bComputeSuitableDuration == True:
	#                   A new duration is computed
	#               else
	#               Function fails and 'max_duration' is filled with max possible duration
	# return[]:
	# ['status'] : Status
	# ['final_duration'] : final duration.
	# ['max_duration']   : Contains the maximum possible duration
	def SetRecordingDuration(self, nRecordingID, nDuration, bComputeSuitableDuration):
		recording = self.GetRecording(nRecordingID)
		if recording == None:
			log.error('Bad Recording ID %d !', nRecordingID)
			return {'status': error.WYRECORD_BAD_RECORDING_ID}
		if recording.status == RECORDING_STATUS_RUNNING:
			old_stop_time = recording.stop_time
			if nDuration:
				recording.stop_time = recording.start_time + nDuration
			else:
				recording.stop_time = 0
			free_space = self.ext_disk_space.getAvailableDiskSpace()
			recording.stop_time = old_stop_time
			if free_space < 0:
				blind_free_space = self.ext_disk_space.blind_free_space
				if self.ext_disk_space.blind_free_space < 0:
					blind_free_space = 0
				return {'status': error.WYRECORD_NOT_ENOUGH_DISK_SPACE, 'needed_space': blind_free_space - free_space, 'available_space': blind_free_space}
		if recording.type == RECORDING_TYPE_NOT_SCHEDULED:
			if nDuration:
				recording.stop_time = recording.start_time + nDuration
			else:
				recording.stop_time = 0
			conflict = self.recording_list.GetConflict(recording)
			self.CheckSchedule()
			if conflict:
				if config.auto_adjust_instant_record_stop_time:
					recording.stop_time = conflict.valid_start_stop_list[0][1]
				return {'status': error.WYRECORD_SCHEDULE_CONFLICT, 'recording_id': recording.id, 'conflict': conflict}
			else:
				return {'status': error.WYRECORD_SUCCESS, 'final_duration': nDuration, 'max_duration': nDuration}
		nWantedStopTime = 0
		if nDuration != 0:
			start_time = recording.start_time
			if recording.status == RECORDING_STATUS_RUNNING:
				start_time = recording.start_time
			nWantedStopTime = start_time + nDuration
		nMaxStopTime = 0
		conflict = self.recording_list.GetConflictForMaxTime(recording)
		if conflict:
			if conflict.isStartTimeValid():
				nMaxStopTime = conflict.valid_start_stop_list[0][1]
			else:
				log.critical('recording list corrupted, Recording ID %d !', nRecordingID)
				return {'status': error.WYRECORD_RECORDING_LIST_CORRUPTED}
		if nMaxStopTime == 0:
			if nWantedStopTime == 0:
				nStopTime = 0
			else:
				nStopTime = nWantedStopTime
		elif nWantedStopTime == 0:
			nStopTime = nMaxStopTime
		elif nWantedStopTime > nMaxStopTime:
			if bComputeSuitableDuration:
				nStopTime = nMaxStopTime
			else:
				nMaxDuration = nMaxStopTime - recording.start_time
				return {'status': error.WYRECORD_DURATION_TOO_BIG, 'max_duration': nMaxDuration, 'conflict': conflict}
		else:
			nStopTime = nWantedStopTime
		if nStopTime == 0:
			nChosenDuration = 0
			nMaxDuration = 0
		else:
			nChosenDuration = nStopTime - recording.start_time
			nMaxDuration = nMaxStopTime - recording.start_time
		recording.stop_padding = 0
		recording.stop_time = nStopTime
		self.CheckSchedule()
		return {'status': error.WYRECORD_SUCCESS, 'final_duration': nChosenDuration, 'max_duration': nMaxDuration}

	# Create a new periodicity rule.
	# 
	# Return the is of the created rule.
	# 
	# Possible rule:
	# 
	# 'weekly' => no parameters
	# 'daily'  => no parameters
	# 'monday_to_friday'=> no parameters
	# 'day_list' => list of day: 0=monday 6=sunday
	# 'relative_day_pos_in_month'=> index in the month : 0= first day -1= last day
	# 'constant_period'=> datetime.timedelta
	# 'time_delta_list'=> list of datetime.timedelta
	# 
	# Exceptions:
	#     RuleTypeNotFoundError
	def createPeriodicityRule(self, rule_name, *args, **kargs):
		instance = None
		if rule_name == 'weekly':
			instance = WeeklyRule()
		elif rule_name == 'daily':
			instance = DailyRule()
		elif rule_name == 'day_list':
			instance = DayListRule(*args, **kargs)
		elif rule_name == 'monday_to_friday':
			instance = DayListRule(range(5))
		elif rule_name == 'relative_day_pos_in_month':
			instance = RelativeDayPosInMonthRule(*args, **kargs)
		elif rule_name == 'constant_period':
			instance = ConstantPeriodRule(*args, **kargs)
		elif rule_name == 'time_delta_list':
			instance = TimeDeltaListRule(*args, **kargs)
		else:
			raise RuleTypeNotFoundError(rule_name)
		instance.extern_rule_name = rule_name
		return self.periodic_recording_list.AddPeriodicSchedulingRule(instance)

	# Active a periodic recording rule.
	# Generate the recordings according to the rule.
	# 
	# Param new_stop_time enables to update the last time.
	# 
	# Exceptions:
	#       PeriodicRecordingGenerateError
	def ActivatePeriodicityRule(self, rule_id, new_stop_time=None):
		rule = self.GetPeriodicRuleById(rule_id)
		rule.is_active = True
		return self.RefreshPeriodicRule(rule_id, new_stop_time)

	# Unactive a periodicity rule.
	# Used to remove periodic recording without removing the rule. Enable to re-active it later.
	# 
	# Exceptions:
	#       PeriodicRecordingGenerateError
	def DeactivatePeriodicityRule(self, rule_id):
		rule = self.GetPeriodicRuleById(rule_id)
		rule.is_active = False
		self.RefreshPeriodicRule(rule_id)
		return None

	# Exceptions:
	#      PeriodicRecordingGenerateError
	def RefreshPeriodicRule(self, rule_id, stop_time=None, from_time=None):
		result_list = []
		failure_list = []
		to_remove_list = self.recording_list.GetPeriodicRecordingListByRule(rule_id)
		for recording in to_remove_list:
			if recording.status == RECORDING_STATUS_SCHEDULED:
				self.DeleteRecording(recording.id)
		rule = self.GetPeriodicRuleById(rule_id)
		if rule.is_active:
			if not stop_time:
				stop_time = rule.last_time
			else:
				rule.last_time = stop_time
			recording = rule.recording_ref
			if not recording:
				return False
			duration = recording.stop_time - recording.start_time
			datetime_start_time = datetime.datetime.fromtimestamp(recording.start_time)
			if not from_time:
				from_time = datetime.datetime.fromtimestamp(self.GetCurrentUTCTime())
			start_list = self.periodic_recording_list.GetTimeList(rule_id, datetime_start_time, stop_time, from_time)
			start_list = [int(time.mktime(elem.timetuple())) for elem in start_list]
			log.debug(str(start_list))
			first_rec_ok = None
			index = 0
			for next_start_time in start_list:
				next_stop_time = next_start_time + duration
				index += 1
				try:
					rec = self.ScheduleRecording(recording.service_id, next_start_time, next_stop_time, recording.name + '_' + str(index), start_padding=recording.start_padding, stop_padding=recording.stop_padding, check_schedule=False, favorite=recording.favorite)
					result_list.append(rec)
					rec.periodicity_rule_id = rule_id
					if first_rec_ok is None:
						first_rec_ok = rec
						rule.recording_ref.start_time = next_start_time
						rule.recording_ref.stop_time = next_stop_time
				except SchedulerError, e:
					failure_list.append(e, next_start_time, next_stop_time)
			if result_list:
				self.CheckSchedule()
			if failure_list:
				raise PeriodicRecordingGenerateError(result_list, failure_list)
		return result_list

	# Remove all recordings and record from periodicity rule_id
	def RemovePeriodicRecording(self, rule_id, delete_records=False):
		self.DeactivatePeriodicityRule(rule_id)
		if delete_records:
			to_remove_list = self.recording_list.GetPeriodicRecordingListByRule(rule_id)
			for recording in to_remove_list:
				self.DeleteRecording(recording.id)
		self.periodic_recording_list.RemoveRule(rule_id)
		return None

	# Generate from the given record the recording using the periodicity rule rule_id
	# Stop_time is the datetime of the last recording possible
	# 
	# Return:  
	#   list of rec instance
	#   
	# Exceptions:
	#     PeriodicRecordingGenerateError
	def GeneratePeriodicRecording(self, rec_id, rule_id, stop_time):
		recording = self.GetRecording(rec_id)
		rule = self.GetPeriodicRuleById(rule_id)
		if not recording or not rule:
			return False
		recording.periodicity_rule_id = rule_id
		rule.recording_ref = recording
		rule.is_active = True
		rule.last_time = stop_time
		return self.RefreshPeriodicRule(rule_id)

	# Return a periodic rule from a given rule id.
	def GetPeriodicRuleById(self, rule_id):
		return self.periodic_recording_list._periodicRecordings[rule_id]

	# Return a list of PeriodicScheduling object.
	def GetPeriodicRecordingList(self, active=True, unactive=True):
		ret_list = []
		for rule in self.periodic_recording_list._periodicRecordings.itervalues():
			if rule.is_active and active or not rule.is_active and unactive:
				ret_list.append(rule)
		return ret_list

	# Retrieve Record info of a recording
	# ['status'] = Status
	# ['record_info'] = RecordInfo object
	def GetRecordingInfo(self, nRecordingID):
		recording = self.GetRecording(nRecordingID)
		if recording == None:
			log.error('Invalid Recording ID')
			return {'status': error.WYRECORD_BAD_RECORDING_ID}
		record_info = recording.GetRecordInfo()
		if record_info == None:
			log.error("Can not get Recording's record info : Maybe a bad recording's status !")
			return {'status': error.WYRECORD_NO_RECORD_INFO_AVAILABLE}
		return {'status': error.WYRECORD_NO_RECORD_INFO_AVAILABLE, 'record_info': record_info}

	# Scan a folder and build a list of RecordInfo objects of records contained in it.
	# (not recursive)
	# if strRecordsFolder == "" => Default record folder is used
	# ['status'] = status
	# ['record_infos'] = Array of RecordInfo objects
	def GetRecords(self, strRecordsFolder=''):
		GetRecords(strRecordsFolder)
		return None

	# Used to safely check schedule
	def AsynchronousCheckSchedule(self, delay=0):
		log.debug('AsynchronousCheckSchedule called')
		WyrecordOnShotTimer(self.cbCheckSchedule).start(delay)
		return None

	def GetFirstRecordingToStart(self):
		return self.recording_list.GetFirstRecordingToStart()

	def IsSomeRecordingRunning(self):
		return len(self.GetRecordingList(RECORDING_FLAG_RUNNING)) > 0

	# Return the recording_id of the schedule recording associated to program_id.
	# Return RECORDING_ID_NULL the program_id is not known.
	def GetRecordingIdFromProgramId(self, program_id):
		if self.recording_list.rec_id_from_program_id.has_key(program_id):
			return self.recording_list.rec_id_from_program_id[program_id]
		return RECORDING_ID_NULL
