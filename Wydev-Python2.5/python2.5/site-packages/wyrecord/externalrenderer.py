# -*- coding: utf-8 -*- 
#
# Description:
#
# WyRecord External Renderer Class Definition
#
#
#
# Changes:
#
# 2014-03-26
# Initial Commit
#
#
# Copyright 2010-2014, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

from logger import log
from config import *
from peewee.analyse import Chrono
from peewee.analyse import timestep
from threading import Event
from callbacks import Callbacks
from time import time
import os


class RendererTimeInfo():
	
	def __init__(self):
		self.min_available_time = 0
		self.max_available_time = 0
		self.current_time = 0
		return None


class ExternalRenderer(object):
	
	wyplayer_signals = dict(closed=Event(), idle=Event(), playing=Event(), loading=Event())

	def wait_for_status(self, signals, timeout=4, callback=(lambda *args, **kw: None), *args, **kw):
		log.info('player status : %s waiting for %s' % (self.wyplayer.status, signals))
		limit = time() + timeout
		for sig in signals:
			self.wyplayer_signals[sig].wait(timeout)
			if limit < time():
				log.error('Player did not change his status, may be because of signal lost')
			else:
				try:
					callback(*args, **kw)
				except:
					continue
		return None

	def __init__(self, wyplayer):
		self.wyplayer = wyplayer
		self.live = None
		self.on_pause = False
		self._first_pass = True
		self._ExternalRenderer__renderer_time_info = RendererTimeInfo()
		self.action = None
		return None

	def status_change_callback(self, status):
		log.info('New player status : %s' % status)
		for e_name, e_sig in self.wyplayer_signals.iteritems():
			if e_name == status:
				e_sig.set()
			else:
				e_sig.clear()
		if status == 'playing':
			self._select_lang()
			Callbacks().start_playing.notify(self, self.live, recording=self.play_options.get('recording', False))
		if status == 'loading' and self.action == 'play':
			return None
		return None

	def play(self, live, **kw):
		self.action = 'play'
		self.live = live
		recorder = live.external_recorder
		self.play_options = kw
		if not self.wyplayer:
			return None
		if self._first_pass and self.wyplayer.status != 'closed':
			self.wyplayer.close()
			try:
				self.wait_for_status(['closed'], timeout=1)
			except OverflowError:
				log.info('Player reinitialized : status %s , TV should work again' % self.wyplayer.status)
		if not recorder:
			log.error('trying to play a live that have not external recorder')
			self.wyplayer.load_uri(live.source_uri, properties={'wyts': '1', 'probe': '0', 'norm_speed': '1', 'live': '1', 'service': str(live.serviceid & 65535)})
			self.play_loaded()
		else:
			if self.wyplayer.status == 'closed':
				self.wyplayer.watch_property('status', self.status_change_callback)
				self.wyplayer.open()
				def load_options():
					for opt in ['aspect_ratio', 'spdif_surround', 'display_format']:
						val = kw.get(opt, None)
						if val:
							setattr(self.wyplayer, opt, val)
					return None
				self.wait_for_status(['idle'], callback=load_options)
			to_play = os.path.basename(recorder.dbuspath)
			dvb_service_id = live.serviceid & 65535
			service_option = 'service=' + str(dvb_service_id)
			log.debug('call play_rec on ' + to_play + ' opts = ' + service_option)
			timestep('renderer_play_init')
			opts = ('wyts=1', 'probe=0', 'norm_speed=1', 'live=1', service_option)
			self.wyplayer.load(to_play, scheme='rec', properties=opts)
			self.play_loaded()
		self._first_pass = False
		return None

	def _select_lang(self):
		lang = self.play_options.get('lang')
		if lang:
			for asub in self.wyplayer.alist():
				if asub['lang'] == lang:
					self.wyplayer.aid = asub['id']
					break
		return None

	def play_loaded(self):
		self.action = None
		recorder = self.live.external_recorder
		if not self.wyplayer:
			return None
		if not recorder:
			self.wyplayer.play_loaded()
		else:
			pos = 0.0
			if self.live.chunk_info:
				pos = self.live.chunk_info.getReadOffset()
			self.wyplayer.play_loaded(start_pos=float(pos), bytes=True)
			self.live.saveReadOffset(0)
			timestep('wyplayer: play')
			if self.play_options.get('start_extern_eit', False):
				self.live.external_dvb_manager.startExternEIT(config.wyplayer_extern_eit_path, self.live.wyscan_recording_id)
				timestep('renderer_play_extern_eit_time')
		timestep('callback_time')
		return None

	def stop(self):
		self.action = None
		self.live = None
		timestep('renderer_stop_init')
		if self.wyplayer and self.wyplayer.status not in ('idle', 'closed'):
			self.wyplayer.stop()
			timestep('wyplayer: stop')
		return None

	# Close the player. Used before a universe change.
	def close(self, wait_player_closed=True):
		if self.wyplayer and self.wyplayer.status != 'closed':
			timestep('wyplayer: close')
			self.wyplayer.close()
			if wait_player_closed:
				self.wait_for_status(['closed'])
			self.wyplayer.watch_property('status', None)
		return None

	def isPlaying(self):
		log.debug('external renderer called: isPlaying')
		return self.wyplayer.status == 'playing'

	def getLive(self):
		return self.live

	def getTimeInfo(self):
		try:
			self._ExternalRenderer__renderer_time_info.current_time = self.live.chunk_info.getTimeFromOffset(self.bytesPos())
			self._ExternalRenderer__renderer_time_info.min_available_time = self.live.chunk_info.getMinimumTimeshiftTime()
			self._ExternalRenderer__renderer_time_info.max_available_time = self.live.chunk_info.getMaximumTimeshiftTime()
		except:
			self._ExternalRenderer__renderer_time_info.current_time = 0
			self._ExternalRenderer__renderer_time_info.max_available_time = 0
			self._ExternalRenderer__renderer_time_info.min_available_time = 0
			log.debug('failed to read chunkingo')
		return self._ExternalRenderer__renderer_time_info

	def savePausePosition(self):
		self.on_pause = True
		if self.wyplayer:
			pos = self.wyplayer.byte_pos
			if self.live:
				self.live.saveReadOffset(pos['video'])
		return None

	def resetPositionSaving(self):
		self.on_pause = False
		if self.live:
			self.live.saveReadOffset(0)
		return None

	# return True if the player is playing the live.
	# False if not playing or playing Timeshift
	def isPlayingOnlive(self):
		ret = True
		if self.isPlaying():
			time_info = self.getTimeInfo()
			if abs(time_info.max_available_time - time_info.current_time) >= config.delta_time_for_playing:
				ret = False
		return ret

	def bytesPos(self):
		bytes_pos = 0
		if self.wyplayer:
			log.info("wyplayer.byte_pos['audio']")
			bytes_pos = self.wyplayer.byte_pos['audio']
		return bytes_pos
