# -*- coding: utf-8 -*- 
#
# Description:
#
# WyRecord Recording Class Definition
#
#
#
# Changes:
#
# 2014-03-26
# Initial Commit
#
#
# Copyright 2010-2014, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.


import xml.etree.cElementTree as ET
from peewee.analyse import Chrono
import datetime
import error
from chunkinfo import UriChunkToPath
from chunkinfo import ChunkInfo
from recordinfo import RecordInfo
from exceptions import *
from logger import log
import os
from config import *


RECORDING_ID_NULL = 0
PERIODICITY_RULE_ID_NULL = 0
RECORDING_TYPE_NORMAL = 0
RECORDING_TYPE_FLASHBACK = 1
RECORDING_TYPE_NOT_SCHEDULED = 2
RECORDING_TYPE_IS_LIVE = 3
RECORDING_STATUS_UNKNOWN = 0
RECORDING_STATUS_SCHEDULED = 1
RECORDING_STATUS_RUNNING = 2
RECORDING_STATUS_IN_CONFLICT = 3
RECORDING_STATUS_COMPLETED = 4
RECORDING_STATUS_CANCELED = 5
RECORDING_STATUS_MISSED = 6
RECORDING_STATUS_ABORTED = 7
RECORDING_STATUS_MACROVISION = 8
RECORDING_STATUS_DISK_SPACE_ERROR = 9
RECORDING_STATUS_SYSTEM_FAILURE = 10
RECORDING_DATE_STRING_FORMAT = '%Y%m%d_%H%M%S'
RECORDING_NAME_PREFIX = 'REC_'


# Live_manager and recording_launcher are needed to build a recording
# RecordingBuilder should be use to make instance of Recording where
# there shoud be no dependency of live_manager or  recording_launcher
class RecordingBuilder(object):
	
	def __init__(self, live_manager, external_dvb_manager, renderer_manager):
		self.live_manager = live_manager
		self.external_dvb_manager = external_dvb_manager
		self.renderer_manager = renderer_manager
		return None

	# Factory of recording.
	def buildNewRecording(self, strName='', oService=None, possible_deviceids=None, nStartTime=0, nStopTime=0, nStartPadding=0, nStopPadding=0, nMaxStartDelay=0, nType=RECORDING_TYPE_NORMAL, nAskRecordlauncherToStop=True):
		return Recording(self.renderer_manager, self.live_manager, self.external_dvb_manager, strName, oService, possible_deviceids, nStartTime, nStopTime, nStartPadding, nStopPadding, nMaxStartDelay, nType, nAskRecordlauncherToStop)



# This class contains all the conflict manager should know about a Recording.
class VirtualRecording(object):

	def __init__(self, deviceid=0, possible_deviceids=None, service_id=0, nStartTime=0, nStopTime=0, start_padding=0, stop_padding=0, id=RECORDING_ID_NULL, live=None):
		self.deviceid = 0
		if not possible_deviceids:
			self.possible_deviceids = []
		else:
			self.possible_deviceids = possible_deviceids
		self.service_id = service_id
		self.start_time = nStartTime
		self.stop_time = nStopTime
		self.start_padding = start_padding
		self.stop_padding = stop_padding
		self.id = id
		self.live = live
		self.type = RECORDING_TYPE_IS_LIVE
		return None


# Manage a recording.
# Recording can be timeshift recording or standard recording.
# This class is used even for instant recording
class Recording(object):

	def __init__(self, renderer_manager, live_manager, external_dvb_manager, strName='', oService=None, possible_deviceids=None, nStartTime=0, nStopTime=0, nStartPadding=0, nStopPadding=0, nMaxStartDelay=0, nType=RECORDING_TYPE_NORMAL, nAskRecordlauncherToStop=True):
		self.renderer_manager = renderer_manager
		self.external_dvb_manager = external_dvb_manager
		self.live_manager = live_manager
		self.id = RECORDING_ID_NULL
		self.periodicity_rule_id = PERIODICITY_RULE_ID_NULL
		self.status = RECORDING_STATUS_UNKNOWN
		self.type = nType
		self.name = strName
		self.start_time = nStartTime
		self.stop_time = nStopTime
		self.start_padding = nStartPadding
		self.stop_padding = nStopPadding
		self.service_id = 0
		if not possible_deviceids:
			self.possible_deviceids = []
		else:
			self.possible_deviceids = possible_deviceids
		self.deviceid = 0
		self.launcher_recordingid = 0
		self.max_start_delay = nMaxStartDelay
		self.internal_recordingid = 0
		self.real_start_time = 0
		self.real_stop_time = 0
		self.service_id = 0
		self.service_name = ''
		if oService != None:
			self.service_id = oService.id
			self.service_name = oService.name
		self.record_info = RecordInfo()
		self.urls = []
		self.instant_recording = config.recording_use_live
		self.live_id = 0
		self.first_chunk = ''
		self.last_chunk = ''
		self.live_uri = ''
		self.program_id = ''
		self.favorite = ''
		return None

	# Compute the scheduled start time taking care about padding.
	def GetScheduledStartTime(self):
		ret = self.start_time
		if ret:
			ret -= self.start_padding
		return ret

	# Compute the scheduled stop time taking care about padding.
	def GetScheduledStopTime(self):
		ret = self.stop_time
		if ret:
			ret += self.stop_padding
		return ret

	# Return an XML (cElementTree) node representing the current recording
	def SaveToXMLNode(self, oXMLNode):
		if oXMLNode == None:
			return False
		for attribute in ('id', 'program_id', 'favorite', 'periodicity_rule_id', 'status', 'type', 'start_time', 'stop_time', 'start_padding', 'stop_padding', 'name', 'stop_time', 'deviceid', 'launcher_recordingid', 'max_start_delay', 'real_start_time', 'real_stop_time', 'url', 'live_uri'):
			if hasattr(self, attribute):
				oXMLNode.attrib[attribute] = str(getattr(self, attribute))
		node_urls = ET.Element('urls')
		oXMLNode.append(node_urls)
		for url in self.urls:
			node_url = ET.Element('url')
			node_url.text = url
			node_urls.append(node_url)
		if self.record_info.info_file_path_name != '':
			oXMLNode.append(ET.Element('file_info', file=self.record_info.info_file_path_name))
		oXMLNode.append(ET.Element('service', id=str(self.service_id), name=self.service_name))
		node_possible_devices = ET.SubElement(oXMLNode, 'possible_devices')
		for deviceid in self.possible_deviceids:
			node_possible_devices.append(ET.Element('device', id=str(deviceid)))			
		return True

	# Fill Recording() object using oXMLNode (cElementTree) object
	def LoadFromXML(self, oXMLNode):
		if oXMLNode == None:
			return False
		for attribute in ('id', 'periodicity_rule_id', 'status', 'type', 'start_time', 'stop_time', 'start_padding', 'stop_padding', 'stop_time', 'deviceid', 'launcher_recordingid', 'max_start_delay', 'real_start_time', 'real_stop_time'):
			if hasattr(self, attribute):
				setattr(self, attribute, int(oXMLNode.attrib[attribute]))
		for attribute in ('name', 'favorite', 'program_id', 'url', 'live_uri'):
			if hasattr(self, attribute):
				setattr(self, attribute, str(oXMLNode.attrib[attribute]))
		self.urls = []
		node_urls = oXMLNode.find('urls')
		if node_urls != None:
			nodes_url = node_urls.getiterator('url')
			for node_url in nodes_url:
				self.urls.append(node_url.text)
		self.record_info.info_file_path_name = ''
		node_file_info = oXMLNode.find('file_info')
		if node_file_info != None:
			self.record_info.info_file_path_name = node_file_info.attrib['file']
			self.record_info.LoadFromFile(self.record_info.info_file_path_name)
		self.possible_deviceids = []
		node_possible_devices = oXMLNode.find('possible_devices')
		if node_possible_devices != None:
			nodes_devices = node_possible_devices.getiterator('device')
			for node_device in nodes_devices:
				self.possible_deviceids.append(int(node_device.attrib['id']))
		service = None
		self.service_id = 0
		self.service_name = ''
		node_service = oXMLNode.find('service')
		if node_service != None:
			self.service_id = int(node_service.attrib['id'])
			self.service_name = node_service.attrib['name']
		return True			

	def __str__(self):
		status = 'Unknown'
		if self.status == RECORDING_STATUS_CANCELED:
			status = 'CANCELED'
		elif self.status == RECORDING_STATUS_COMPLETED:
			status = 'COMPLETED'
		elif self.status == RECORDING_STATUS_IN_CONFLICT:
			status = 'IN_CONFLICT'
		elif self.status == RECORDING_STATUS_MISSED:
			status = 'MISSED'
		elif self.status == RECORDING_STATUS_RUNNING:
			status = 'RUNNING'
		elif self.status == RECORDING_STATUS_SCHEDULED:
			status = 'SCHEDULED'
		elif self.status == RECORDING_STATUS_ABORTED:
			status = 'ABORTED'
		elif self.status == RECORDING_STATUS_UNKNOWN:
			status = 'UNKNOWN'
		return 'Recording : id = %d, status = %s, name = %s, type = %d, start_time = %d, stop_time = %d, start_padding = %d, stop_padding = %d, service = %s (%s), device = %d, possible_devices = %s, real_start_time = %d, real_stop_time = %d' % (self.id, status, self.name, self.type, self.start_time, self.stop_time, self.start_padding, self.stop_padding, self.service_id, self.service_name, self.deviceid, self.possible_deviceids, self.real_start_time, self.real_stop_time)

	def _GetBaseName(self, live_count):
		strStartTime = ''
		if self.real_start_time != 0:
			strStartTime = datetime.datetime.fromtimestamp(self.real_start_time).strftime(RECORDING_DATE_STRING_FORMAT)
		strValidServiceName = self.service_name
		if len(strValidServiceName) > 20:
			strValidServiceName = strValidServiceName[0:20]
		strValidName = '_' + str(live_count)
		strBaseName = RECORDING_NAME_PREFIX + strStartTime + '_' + str(self.deviceid) + '_' + str(self.service_id) + '_' + strValidServiceName + strValidName
		return strBaseName.replace('/', '_')

	# Start the record in the timeshify way.
	#
	# Return False if error occurs
	@Chrono(['wyrecord'])
	def _Recording__StartTimeshiftRecord(self):
		start_live_result = self.live_manager.StartLive(self.service_id, self.deviceid)
		if start_live_result['status'] != error.WYRECORD_SUCCESS:
			return False
		self.live_id = start_live_result['live_id']
		live = self.live_manager._GetLiveFromLiveID(self.live_id)
		if live == None:
			return False
		if self.deviceid != live.deviceid:
			log.info('start recording self.deviceid != live.deviceid ' + str(self.deviceid) + ' != ' + str(live.deviceid))
			self.deviceid = live.deviceid
		if not live.isRunning():
			return False
		if not config.multiple_recording_per_live and live.isRecording():
			log.info('Live already recording and multiple recording per live not activated')
			return False
		live.updateTimeshiftSize(config.max_size_for_timeshift)
		self.first_chunk = ''
		self.last_chunk = ''
		if self.type == RECORDING_TYPE_NOT_SCHEDULED:
			renderer = self.renderer_manager.getRenderer(live)
			if renderer:
				self.first_chunk = live.chunk_info.getChunkFromOffset(renderer.bytesPos())
				log.info('current_time= ' + str(self.start_time))
				timeshifted_start_time = int(renderer.getTimeInfo().current_time)
				self.stop_time = timeshifted_start_time + self.stop_time - self.start_time
				self.start_time = timeshifted_start_time
				log.info('REAL timeshifted_time= ' + str(self.start_time))
				log.info('REAL duration= ' + str(self.start_time - self.start_time))
			else:		
				try:
					self.first_chunk = live.chunk_info._getSortedFilelist()[-1]
					log.info('first_chunk for rec is ' + self.first_chunk)
				except:
					pass
		if not live.recording_task_runner.beginRec(self):
			return False
		if play_the_rec:
			play_the_rec.play(live, recording=True, start_extern_eit=True)
		self.live_uri = live.dest_uri
		strRecordingBaseName = self._GetBaseName(live.LIVE_COUNT)
		real_dest_url = URL_PREFIX_TIMESHIFT + os.path.join(config.timeshift_records_base_folder_path, strRecordingBaseName)
		real_dest_url = os.path.join(real_dest_url, config.timeshift_chunk_file_name_format)
		self.urls = [real_dest_url]
		return True

	# Start recording
	@Chrono(['wyrecord'])
	def Start(self, force=True):
		log.info("Start Recording '%s'" % self.name)
		play_the_rec = False
		if self.status == RECORDING_STATUS_RUNNING:
			log.error('Recording.Start() : Recording %d already running !' % self.id)
			return False
		self.real_start_time = self.external_dvb_manager.GetCurrentUTCTime()
		_live = self.live_manager._GetLiveFromServiceID(self.service_id)
		if _live:
			self.deviceid = _live.id
			if _live.has_macrovision:
				self.status = RECORDING_STATUS_MACROVISION
				log.debug('MACROVISION: not possible to start record')
				return False
		else:
			try:
				self.deviceid = self.live_manager.GetDeviceForNewService(self.service_id)
			except LiveInConflictError, e:
				if force:
					for live in e.conflict_live_list:
						play_the_rec = self.renderer_manager.getRenderer(live)
						if play_the_rec:
							play_the_rec.stop()
						log.info('Stop live that are in conflict ' + str(live.id))
						if not live.stop():
							return False
					try:
						self.deviceid = self.live_manager.GetDeviceForNewService(self.service_id)
					except:
						return False
				else:
					return False
		if not self._Recording__StartTimeshiftRecord(play_the_rec):
			return False
		self.status = RECORDING_STATUS_RUNNING
		return True

	# Stop recording
	def Stop(self, stop_time, stop_at_player_pos=False, dbus_api=None):
		log.info("Stop Recording '%s'" % self.name)
		if self.status != RECORDING_STATUS_RUNNING and self.status != RECORDING_STATUS_SCHEDULED:
			log.error('Recording.Stop() : Recording %d was not running neither scheduled !' % self.id)
			return False
		if self.real_start_time != 0:
			self.real_stop_time = stop_time
		else:
			self.real_stop_time = 0
		if self.status == RECORDING_STATUS_RUNNING:
			live = self.live_manager._GetLiveFromLiveID(self.live_id)
			if live:
				if live.has_macrovision:
					self.status = RECORDING_STATUS_MACROVISION
					self.live_id = 0
					live.recording_task_runner.endRec(self)
					log.debug('MACROVISION: not possible to keep record')
					return False
				renderer = None
				try:
					renderer = self.renderer_manager.getRenderer(live)
					if stop_at_player_pos:
						if renderer:
							self.last_chunk = live.chunk_info.getChunkFromOffset(renderer.bytesPos())
				except:
					log.critical('failed to stop finalize record')
				self.live_id = 0
				self.status = RECORDING_STATUS_COMPLETED
				try:
					self.buildRecord()
					live.recording_task_runner.endRec(self)
				except:
					log.critical('buildRecord Failed => probably already done')
					live.recording_task_runner.endRec(self)
					if not renderer:
						self.live_manager.StopLive(live.id)
						return False
				if not renderer:
					self.live_manager.StopLive(live.id)
			else:
				log.debug('trying to stop a recording but live not running')
				log.debug('continue anyway => trying to recover')
				self.name = self.name + config.recover_string
				self.live_id = 0
				self.status = RECORDING_STATUS_ABORTED
				try:
					self.buildRecord()
				except:
					log.critical('buildRecord Failed => probably already done')
					return False
		else:
			self.status = RECORDING_STATUS_CANCELED
		self._CreateRecordInfo()
		if dbus_api:
			dbus_api.emitNewRecordInfo(self.record_info)
		return True

	def buildRecord(self):
		log.debug('buildRecord first_chunk ' + self.first_chunk)
		log.debug('buildRecord last_chunk ' + self.last_chunk)
		dest_dir = os.path.split(self.urls[0][len(URL_PREFIX_TIMESHIFT):])[0]
		log.debug('dest_dir record ' + dest_dir)
		os.makedirs(dest_dir)
		sorted_file_list = ChunkInfo(UriChunkToPath(self.live_uri))._getSortedFilelist()
		log.debug('buildrecord chunk list: ' + str(sorted_file_list))
		started = False
		for f in sorted_file_list:
			if not started:
				if f >= self.first_chunk or not self.first_chunk:
					started = True
				else:
					continue
			dest = os.path.join(dest_dir, os.path.split(f)[1])
			try:
				os.link(f, dest)
				log.debug('link to' + dest + ' ok')
			except:
				log.error('link to' + dest + ' FAILURE')
			if f == self.last_chunk:
				break
		return None

	# Used to specify that the recording should be done in the timeshift way.
	def MarkAsInstantRecording(self):
		self.instant_recording = True
		return None

	def _CreateRecordInfo(self):
		log.info('Create info file for recording %d' % self.id)
		url = ''
		for _url in self.urls:
			if _url.startswith(URL_PREFIX_TIMESHIFT):
				url = _url
				break
			log.critical("ERROR : BUG TO FIX : BAD URL Prefix for a recording ! : url='%s'" % url)
		if url == '':
			log.error('ERROR : Can not create Recording File Info for recording %d !' % self.id)
			return False
		self.record_info.name = self.name
		self.record_info.service_name = self.service_name
		self.record_info.start_time = self.real_start_time
		self.record_info.stop_time = self.real_stop_time
		dvb_service_id = self.service_id & 65535
		return self.record_info.Save(url, dvb_service_id)

	# Return record info for recording that are over.
	def GetRecordInfo(self):
		if self.status != RECORDING_STATUS_COMPLETED and self.status != RECORDING_STATUS_ABORTED:
			return None
		return self.record_info

	# Check the validity of the recording.
	def IsValid(self):
		return self.record_info.IsValid()

	# Remove the record from file system.
	def Delete(self):
		self.record_info.Delete()
		return None

	# Used to get the live in conflict.
	def GetLivesInConflict(self):
		return self.live_manager.GetLivesInConflictWithService(self.service_id)

	def GetRecLiveToStop(self):
		rec_to_stop = []
		live_list = []
		live_to_stop = []
		live = self.live_manager._GetLiveFromServiceID(self.service_id)
		if live:
			if self.instant_recording:
				live_list.append(live)
		else:
			live_list = self.live_manager.GetLivesInConflictWithService(self.service_id)
			live_to_stop = live_list
		for live in live_list:
			if live.current_recordingid != 0:
				rec_to_stop.append(live.current_recordingid)
		recording_live = self.live_manager.GetRecordingLiveList()
		rec_nb = len(recording_live) - len(rec_to_stop)
		for live in recording_live:
			if rec_nb < config.max_simultaneous_rec:
				break
			if live.current_recordingid not in rec_to_stop:
				rec_to_stop.append(live.current_recordingid)
		return (rec_to_stop, live_to_stop)

	# Set the new maximum time
	def updateStopTime(self, new_stop_time):
		if self.stop_time:
			self.stop_time = new_stop_time - self.stop_padding
		else:
			self.stop_padding = 0
			self.stop_time = new_stop_time
		return None

	# Set the start time
	def updateStartTime(self, new_start_time):
		if self.start_time:
			self.start_time = new_start_time + self.start_padding
		else:
			self.start_padding = 0
			self.start_time = new_start_time
		return None
