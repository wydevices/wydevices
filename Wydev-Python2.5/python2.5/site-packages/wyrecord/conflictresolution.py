# -*- coding: utf-8 -*- 
#
# Description:
#
# WyRecord Conflict Resolution Class Definition
#
#
#
# Changes:
#
# 2014-03-26
# Initial Commit
#
#
# Copyright 2010-2014, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.


from logger import log
from recording import RECORDING_TYPE_NORMAL
from recording import RECORDING_TYPE_FLASHBACK
from recording import RECORDING_TYPE_NOT_SCHEDULED
from recording import RECORDING_STATUS_ABORTED


def resolveFromAdjustTimeForRec(adjust):
	for rec in adjust.getRecToModify():
		rec.updateStopTime(adjust.new_rec_start)
	adjust.new_rec.updateStartTime(adjust.new_rec_start)
	return None


# Class used to dynamicly resolve conflict.
#
# A new rec need to start. A curren_rec_list are currently running.
# Modify on the fly padding in order to start the new rec.
class AdjustTimeForRec(object):

	# Init.
	# new_rec is the new rec that need to start.
	# current_rec_list is the list of record in conflict currently running.
	def __init__(self, new_rec, current_rec_list):
		self.new_rec = new_rec
		self.current_rec_list = current_rec_list
		self.result = []
		self.new_rec_start = self._AdjustTimeForRec__check()
		return None

	# Resolution algorithm.
	# Find an accurate start_time for the new rec.
	# Build the list of rec that must be modified
	def _AdjustTimeForRec__check(self):
		new_rec_start = self.new_rec.GetScheduledStartTime()
		for rec in self.current_rec_list:
			if self.new_rec.GetScheduledStartTime() < rec.GetScheduledStopTime():
				conflict_with_padding = self.new_rec.GetScheduledStartTime() < rec.GetScheduledStopTime()
			else:
				conflict_with_padding = rec.GetScheduledStopTime() == 0
			if self.new_rec.start_time < rec.stop_time:
				conflict_without_padding = self.new_rec.start_time < rec.stop_time
			else:
				conflict_without_padding = rec.stop_time == 0
			if conflict_with_padding and not conflict_without_padding:
				if rec.stop_time:
					half_time = int((self.new_rec.start_time - rec.stop_time) / 2) + rec.stop_time
				else:
					half_time = int(self.new_rec.start_padding / 2) + self.new_rec.start_time
				if half_time > new_rec_start:
					new_rec_start = half_time
				self.result.append(rec)
				continue
			if rec.type == RECORDING_TYPE_NOT_SCHEDULED:
				self.result.append(rec)
				continue
			if self.new_rec.type == RECORDING_TYPE_NOT_SCHEDULED:
				log.debug('trying to start an instant record during padding of a scheduled')
				self.new_rec.status = RECORDING_STATUS_ABORTED
				continue
			self.new_rec.status = RECORDING_STATUS_ABORTED
			log.critical('SHOULD NOT HAPPEN => BUG => CHECK ALGO')
		filter((lambda rec: new_rec_start < rec.GetScheduledStopTime() if new_rec_start < rec.GetScheduledStopTime() else rec.GetScheduledStopTime() == 0), self.result)
		return new_rec_start

	# Return the list of rec that need to be modified.
	def getRecToModify(self):
		return self.result

	# Return the computed start time for the new record
	def getTime(self):
		return self.new_rec_start
