# -*- coding: utf-8 -*- 
#
# Description:
#
# Peewee Range Class Definiton
#
#
#
# Changes:
#
# 2012-05-04
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

from __future__ import absolute_import

__all__ = ['Range', 'f_list']



# Offers a slice-like class but mutable and supporting some basic operations
class Range(object):

	__slots__ = ['start', 'stop']

	# Create a Range from a slice or two integers
	def __init__(self, start, stop=None):
		if isinstance(start, slice):
			self.start = start.start
			self.stop = start.stop
		else:
			self.start = start
			self.stop = stop
		return None

	def __repr__(self):
		return '[%d:%d]' % (self.start, self.stop)

	def __eq__(self, other):
		if self.start == other.start:
			return self.stop == other.stop
		return self.start == other.start

	def __ne__(self, other):
		if not self.start != other.start:
			return self.stop != other.stop
		return self.start != other.start

	def __lt__(self, other):
		return len(self) < len(other)

	def __gt__(self, other):
		return len(self) > len(other)

	def __len__(self):
		return self.stop - self.start

	def __nonzero__(self):
		return self.stop > self.start

	def __contains__(self, other):
		if isinstance(other, Range):
			if other.start >= self.start and other.stop <= self.stop:
				return True
		elif self.start <= other < self.stop:
			return True
		return False

	def __add__(self, other):
		if isinstance(other, (Range, slice)):
			return Range(min(self.start, other.start), max(self.stop, other.stop))
		else:
			raise RuntimeError("Range objects can't cope with %s !" % other)

	def __sub__(self, other):
		if isinstance(other, (Range, slice)):
			if self in other:
				return Range(0, 0)
			elif other.stop <= self.start or other.start >= self.stop:
				return self
			elif other.start <= self.start and other.stop <= self.stop:
				return Range(other.stop, self.stop)
			elif other.start <= self.stop and other.stop >= self.stop:
				return Range(self.start, other.start)
			else:
				raise RuntimeError("Range class don't handle this case (%s minus %s) !!" % (self, other))
		else:
			raise RuntimeError("Range objects can't cope with %s !" % other)
		return None

	def get_slice(self, offset=0, grow=0):
		return slice(max(0, self.start - offset - grow), self.stop - offset + grow)

	def get_range(self, offset=0, grow=0):
		return Range(max(0, self.start - offset - grow), self.stop - offset + grow)



# Offers a new list type supporting some basic operations
# but dedicated to float values. Most important change concern
# __contains__ method to manage imprecisions: 0.2000000008 == 0.2.
class f_list(list):

	# Create a list
	# delta_range is used to compare two items
	def __init__(self, *args, **kw):
		self._delta_range = kw.pop('range', 0.001)
		list.__init__(self, *args, **kw)
		return None

	def __contains__(self, item):
		if isinstance(item, (int, float)):
			for it in [_it for _it in self if isinstance(_it, (int, float))]:
				if abs(item - it) < self._delta_range:
					return True
			return False
		else:
			return list.__contains__(self, item)

	def index(self, item, **kw):
		if isinstance(item, (int, float)):
			for i, it in enumerate(self):
				if abs(item - it) < self._delta_range:
					return i
			raise ValueError
		else:
			return list.index(self, item, **kw)

	def __add__(self, other):
		return f_list(list.__add__(self, other))
