# -*- coding: utf-8 -*- 
#
# Description:
#
# Peewee Network Class Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

# Wybox network configuration.
# Wraps (currently throwaway) calls to the system\nnetwork configuration APIs.

from __future__ import absolute_import

import os
from peewee.debug import GET_LOGGER

log = GET_LOGGER('network')
RESOLV_CONF_IN = '/etc/params/resolv.conf'
RESOLV_CONF_OUTS = [RESOLV_CONF_IN]
WYNET_CONF_IN = '/etc/params/wynet.conf'
WYNET_CONF_OUTS = [WYNET_CONF_IN]
IFACES = dict()



def read_config():
	global IFACES
	for line in file(WYNET_CONF_IN):
		line = line.strip()
		print 'LINE',
		print line
		if line.lower().startswith('iface'):
			c_type, c_name = line.split('=', 1)
			IFACES[(c_type.strip('iface_') if c_type.strip('iface_') else 'default')] = c_name
		print IFACES
	return None

# Return whether the network configuration uses UPNP
def is_upnp():
	try:
		for line in file(WYNET_CONF_IN):
			if line.lower().startswith('mode'):
				mode = line.split('=', 1)[-1].strip().lower()
				return mode == 'upnp'
	except IOError:
		return False
	return False

# Activate/deactivate UPNP network configuration.
# If inactive, the network configuration is static/manual.
def set_upnp(upnp):
	mode = ('upnp' if upnp else 'static')
	iface = NetInterface()
	for out_name in WYNET_CONF_OUTS:
		try:
			out_file = open(out_name, 'w')
			out_file.write('mode=%s\n' % mode)
			out_file.write('address=%s\n' % iface.ip)
			out_file.write('netmask=%s\n' % iface.netmask)
			for name, val in IFACES.iteritems():
				if name == 'default':
					out_file.write('iface=%s\n' % val)
				else:
					out_file.write('iface_%s=%s\n' % (name, val))
			out_file.close()
		except IOError:
			log.error('Unable to set the UPNP network configuration -- write error to %s.', out_name)
	print 'restarting wynet....'
	os.system('/etc/init.d/wynet stop')
	os.system('/etc/init.d/wynet start')
	return None

# List all the DNS servers known to the system.
def dns_servers():
	try:
		resolv = open(RESOLV_CONF_IN)
		servers = [line.strip().split(None, 1)[1] for line in resolv if line.startswith('nameserver')]
		resolv.close()
	except IOError:
		servers = []
	return servers

# Replace a DNS entry in /etc/params/resolv.conf. If old is None or whitespace,
# add a DNS entry. If new is None or whitespace, remove a DNS entry.
def replace_dns(old, new):
	out = []
	try:
		in_file = open(RESOLV_CONF_IN)
		for line in in_file:
			if old and line.startswith('nameserver %s' % old):
				if new:
					out.append('nameserver %s\n' % new)
			else:
				out.append(line)
		in_file.close()
	except IOError:
		log.info( "%s doesn't exist. Creating it...", RESOLV_CONF_IN)
	if not old and new:
		out.append('nameserver %s\n' % new)
	for out_name in RESOLV_CONF_OUTS:
		try:
			out_file = open(out_name, 'w')
			out_file.writelines(out)
			out_file.close()
		except IOError:
			log.error('Unable to set the new DNS server -- write error to %s.', out_name)
	return None



# Wrapper around a system network interface.
class NetInterface(object):

	def __init__(self, _type='wired'):
		self.name = IFACES[_type]
		self._ip = None
		self._hwaddr = None
		self._netmask = None
		self._gateway = None
		self.update()
		return None

	# Write wynet config by calling set_upnp
	def save(self, upnp=True):
		set_upnp(upnp, self)
		return None

	# Stop the connection
	def stop(self):
		return None

	# Update the object data by parsing 'ifconfig' and 'route' commands
	def update(self):
		ifconfig = os.popen('/sbin/ifconfig')
		raw = ifconfig.read()
		ifconfig.close()
		data = [line for line in raw.split('\n\n') if line.startswith(self.name + ' ')]
		if not data:
			raise ValueError('The interface %s does not exist' % self.name)
		fields = filter(bool, (line.strip() for line in data[0].split('  ')))
		for line in fields:
			if line.startswith('HWaddr'):
				unused, self._hwaddr = line.split(None, 1)
			elif line.startswith('inet addr'):
				unused, self._ip = line.split(':', 1)
			elif line.startswith('Mask'):
				unused, self._netmask = line.split(':', 1)
		route = os.popen('/sbin/route -n')
		raw = route.read()
		route.close()
		data = [line for line in raw.split('\n') if line.startswith('0.0.0.0 ') and line.endswith(self.name)]
		fields = data[0].split(None, 2)
		self._gateway = fields[1]
		return None

	def _set_ip(self, ip):
		commmand = '/sbin/ifconfig %s %s' % (self.name, ip)
		if os.system(commmand):
			log.error('Unable to set the IP adress for %s', self.name)
		else:
			self._ip = ip
		return None

	def _set_netmask(self, netmask):
		command = '/sbin/ifconfig %s netmask %s' % (self.name, netmask)
		if os.system(command):
			log.error('Unable to set the netmask for %s', self.name)
		else:
			self._netmask = netmask
		return None

	def _set_gateway(self, gateway):
		os.system('/sbin/route del default')
		command = '/sbin/route add default gw %s dev %s' % (gateway, self.name)
		if os.system(command):
			log.error('Unable to set the gateway for %s', self.name)
			os.system('/sbin/route add default gw %s dev %s' % (self._gateway, self.name))
		else:
			self._gateway = gateway
		return None

	def _check_connected(self):
		self.update()
		if self.ip:
			return True
		return False

	ip = property((lambda self: self._ip), _set_ip, None, 'IP Address.')
	netmask = property((lambda self: self._netmask), _set_netmask, None, 'Subnet mask.')
	hwaddr = property((lambda self: self._hwaddr), None, None, 'Hardware (MAC) address. Cannot be changed.')
	gateway = property((lambda self: self._gateway), _set_gateway, None, 'Default gateway.')
	connected = property((lambda self: self._check_connected), None, None, 'is this interface working ?')

	def __repr__(self):
		return 'NetInterface <%s (%s)>' % (self.name, self.ip)



class WifiInterface(NetInterface):

	def __init__(self):
		NetInterface.__init__(self, 'wireless')
		self.networks = list()
		self.selected_net = None
		self.key_type = None
		self.private_key = None
		return None

	def scan(self):
		self.networks.append(dict(name='Wifi-1', signal=62, security=True, rate=54))
		self.networks.append(dict(name='Wifi-2', signal=96, security=True, rate=54))
		self.networks.append(dict(name='Wifi-3', signal=17, security=True, rate=54))
		self.networks.append(dict(name='Wifi-4', signal=80, security=True, rate=54))
		self.networks.append(dict(name='Wifi-5', signal=54, security=True, rate=54))
		self.networks.append(dict(name='Wifi-6', signal=38, security=False, rate=11))
		return None



read_config()
