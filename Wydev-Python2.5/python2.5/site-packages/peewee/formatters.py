# -*- coding: utf-8 -*- 
#
# Description:
#
# Peewee Formater Decorators and Class Definitons
#
#
#
# Changes:
#
# 2012-05-04
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

from __future__ import absolute_import

__all__ = ['bytes_to_human', 'bits_to_human', 'seconds_to_hhmm', 'seconds_to_hhmmss', 'seconds_to_mmss', 'seconds_to_hhmm_utc', 'seconds_to_mmss_utc', 'seconds_to_hhmmss_utc', 'ellipsize', 'html_format', 'tab_to_spaces', 'int_to_percent', 'percent_to_int', 'boolean', 'boolean_to_int', 'int_tuple', 'int_tuple_list', 'string_tuple', 'string_or_float']

import time



# ellipsize(unicode, int) -> unicode
# 
# If s is less than maxlen characters long, return it unchanged.
# Otherwise, truncate if to maxlen characters including
# a trailing ellipsis.
def ellipsize(s, maxlen):
	if len(s) <= maxlen:
		return s
	return u'%s\u2026' % s[:maxlen - 1]

# Return the size as a human readable string.
def bytes_to_human(filesize):
	decimators = ('k', 'M', 'G', 'T')
	unit = ''
	for dec in decimators:
		if abs(filesize) > 1100.0:
			filesize /= 1024.0
			unit = dec
	return '%.1f%sB' % (filesize, unit)

# Return the size as a human readable string.
def bits_to_human(rate):
	decimators = ('k', 'M', 'G', 'T')
	unit = ''
	for dec in decimators:
		if abs(rate) > 1100.0:
			rate /= 1024.0
			unit = dec
	return '%.1f%sb' % (rate, unit)

# Format a UNIX timestamp in the HH:MM format using the system's
# local time zone. Round to the nearest minute.
# 
# Do *not* use this function to format durations:
# use seconds_to_hhmm_utc instead.
# 
# Note: the rounding fails for negative values of t.
def seconds_to_hhmm(t):
	return time.strftime('%H:%M', time.localtime(t + 30))

# Format a UNIX timestamp in the HH:MM:SS format using the system's
# local time zone.
#
# Do not use to format durations: use seconds_to_hhmmss_utc instead.
def seconds_to_hhmmss(t):
	return time.strftime('%H:%M:%S', time.localtime(t))

# Format a UNIX timestamp in the MM:SS format using the system's
# local time zone.
#
# Do not use to format durations: use seconds_to_mmss_utc instead.
def seconds_to_mmss(t):
	return time.strftime('%M:%S', time.localtime(t))

# Format a duration in the HH:MM format, rounding to the nearest minute.
# 
# >>> seconds_to_hhmm_utc(30)
# "00:01"
# >>> seconds_to_hhmm_utc(1800)
# "00:30"
# >>> seconds_to_hhmm_utc(24*3600)
# "24:00"
# 
# Note: the rounding fails for negative values of t.
def seconds_to_hhmm_utc(t):
	minutes, seconds = divmod(t + 30, 60)
	return '%02i:%02i' % divmod(minutes, 60)

# Format a duration in the HH:MM:SS format.
# 
# >>> seconds_to_hhmmss_utc(30)
# "00:00:30"
# >>> seconds_to_hhmmss_utc(1800)
# "00:30:00"
# >>> seconds_to_hhmmss_utc(24*3600)
# "24:00:00"
def seconds_to_hhmmss_utc(t):
	minutes, seconds = divmod(t, 60)
	hours, minutes = divmod(minutes, 60)
	return '%02i:%02i:%02i' % (hours, minutes, seconds)

# Format a duration in the MM:SS format.
# 
# >>> seconds_to_mmss_utc(30)
# "00:30"
# >>> seconds_to_mmss_utc(60)
# "01:00"
# >>> seconds_to_mmss_utc(3600)
# "60:00"
def seconds_to_mmss_utc(t):
	return '%02i:%02i' % divmod(t, 60)

def html_format(src):
	return src.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;').replace('\n', '<\n>').replace('\\n', '<\n>').replace('\t', '    ')

def int_to_percent(n):
	return '%02d%%' % int(n)

def percent_to_int(n):
	if n.isdigit() and int(n):
		return int(n)
	return int(n.strip().strip('%'))

_TRUTH_VALUES = frozenset(('true', 'vrai', 'ok', 'yes', 'on', '1'))

def boolean(string):
	return string.lower() in _TRUTH_VALUES

def boolean_to_int(string):
	return int(string.lower() in _TRUTH_VALUES)

def int_tuple(string):
	return tuple((x.strip() if '%' in x else int(x) for x in string.split(',')))

def int_tuple_list(string):
	return tuple((int_tuple(i) for i in string.split()))

def string_tuple(string):
	return tuple((x.strip() for x in string.split(',')))

def xml_tag(tag, value=''):
	return '<%s>%s</>' % (tag, value)

def string_or_float(att):
	if '%' in att and att:
		return att
	return int(att)

