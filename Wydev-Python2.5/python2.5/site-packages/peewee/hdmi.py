# -*- coding: utf-8 -*- 
#
# Description:
#
# HDMI Decorators Class Definitions
#
#
#
# Changes:
#
# 2011-11-02
# Initial Commit
#
# 2011-11-08
# Handle HDMI sink EDID path setted by new STMFB kernel driver.
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.


from hashlib import md5
import os
import sys



# Representation of a video mode supported by an HDMI sink.
# The following attributes are exported:
#  - h: mode height in pixels
#  - w: mode width in pixels
#  - lace: interlacing (True if mode is interlaced)
#  - freq: refresh rate in Hertz
class VideoMode(object):

	def __init__(self, mstr):
		self.w = int(mstr.split(':', 1)[1].split('x', 1)[0])
		self.h = int(mstr.split('x', 1)[1].split('-', 1)[0].rstrip('ip'))
		self.lace = mstr.split('x', 1)[1].split('-', 1)[0].lstrip('01239456789')
		self.freq = int(mstr.split('-', 1)[1])
		self.tuple_repr = (self.w, self.h, (1 if self.lace == 'i' else 0), self.freq)
		return None

	# String representation of the mode.
	# Form: w + 'x' + h + '-' + freq + '[ip]'
	# ('[ip]' depending on lace attribute: 'i': interlaced, 'p': progressive)
	def __repr__(self):
		return '%ux%u-%u%s %s' % (self.w, self.h, self.freq, self.lace, self.tuple_repr)

	def set_fbset(self):
		if os.system('/usr/bin/fbset %s' % self) != 0:
			print "couldn't set video mode '%s'" % self
			return False
		else:
			return True

	def set_wyvas(self):
		self.wvs.set_resolution((self.w, self.h), self.lace, self.freq)
		return False

	def set(self):
		if self.wvs is not None:
			return self.set_wyvas()
		else:
			return self.set_fbset()
		return None

	def __eq__(self, other):
		if isinstance(other, VideoMode):
			if self.w == other.w and self.h == other.h and self.lace == other.lace and self.freq == other.freq:
				return True
			return False
		elif self.tuple_repr == other:
			return True
		else:
			return False

	def __cmp__(self, other):
		if isinstance(other, VideoMode):
			return cmp(self.h, other.h)
		else:
			return cmp(self.h, other[1])



# Class representing a sink (TV, projector, receiver, ...) plugged on the 710x's HDMI connector (TODO: support stx7200).
# Each specific sink brand/model is uniquely identified by making a MD5 hash of its EDID block data.
class HDMISink(object):

	# "display" specifies the display (primary or secondary) number to use.
	# On a STb710x this will always be 0
	def __init__(self, display=0):
		self.display = display
		self.syspath = '/sys/class/stmcoredisplay/display%d' % self.display
		hotplug = self.get_hpd()
		if hotplug == False:
			raise Exception, 'HDMI hotplug failed'
		self.id = self.get_id()
		if self.id is None:
			raise Exception, "couldn't get EDID info"
		self.modes = self.get_modes()
		if self.modes is None:
			raise Exception, "couldn't get modes list"
		return None

	# Return string representation of the sink.
	# This is a MD5 hash of the sink's EDID block data.
	def __str__(self):
		return self.id

	# Return hot-plug detect signal status.
	# True if an HDMI sink is plugged, False if not.
	def get_hpd(self):
		try:
			hpd = open('%s/hdmi0.0/hotplug' % self.syspath).readline()
		except:
			return False
		if hpd != 'y\n':
			return False
		else:
			return True

	# Return hot-plug detect signal status.
	# True if an HDMI sink is plugged, False if not.
	def get_hpd(self):
		if os.path.exists('%s/hdmi0.0/hotplug' % self.syspath):
			fd = open('%s/hdmi0.0/hotplug' % self.syspath)
			hotplug = fd.readline()
			fd.close()
			if hotplug != 'y\n':
				return False
			else:
				return True
		return False

	# Return the list of modes supported by the sink.
	# Each returned element is a VideoMode instance.
	def get_modes(self):
		if os.path.exists('%s/hdmi0.0/modes' % self.syspath):
			fd = open('%s/hdmi0.0/modes' % self.syspath)
			modes = [VideoMode(m.rstrip('\n')) for m in fd.readlines()]
			fd.close()
			return modes
		else:
			return None

	# Retrieve the sink's unique ID (MD5 hash of EDID block data).
	# This will not overwrite self.id, thus it is to be used in response to hotplug events to detect if the sink was changed.
	def get_id(self):
		if os.path.exists('%s/hdmi0.0/edid' % self.syspath):
			fd = open('%s/hdmi0.0/edid' % self.syspath)
			checksum = md5(fd.read())
			fd.close()
			return checksum.digest()
		elif os.path.exists('%s/hdmi0.0/rawedid' % self.syspath):
			fd = open('%s/hdmi0.0/rawedid' % self.syspath)
			checksum = md5(fd.read())
			fd.close()
			return checksum.digest()
		else:
			return None
