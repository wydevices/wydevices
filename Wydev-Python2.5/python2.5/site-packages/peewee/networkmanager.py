# -*- coding: utf-8 -*-
#
# Description:
#
# Peewee NetworkManager Decorators and Class Definitions
#
#
#
# Changes:
#
# 2012-05-03
# Initial Commit
#
#
# Copyright 2010-2014, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

from __future__ import absolute_import

import os
from socket import inet_ntoa, ntohl
from struct import pack
from functools import partial
from wydbus import WyDBus

try:
	from wynetwork import pynetwork
except ImportError:
	pynetwork = None

from peewee.debug import GET_LOGGER, PRINT_EXCEPTION
from peewee.misc_utils import MetaSingleton
from peewee.notifier import Task



NM_devices_type = ['unknown',
									 'ethernet',
									 'wireless']

NM_state = ['unknown',
						'asleep',
						'connecting',
						'connected',
						'disconnected']

NM_device_state = ['unknown',
									 'down',
									 'disconnected',
									 'prepare',
									 'config',
									 'need_auth',
									 'ip_config',
									 'activated',
									 'failed',
									 'cancelled']

NM_cyphers = {'NM_AUTH_TYPE_WPA_PSK_AUTO': 0,
							'NM_AUTH_TYPE_NONE': 1,
							'NM_AUTH_TYPE_WEP40': 2,
							'NM_AUTH_TYPE_WPA_PSK_TKIP': 4,
							'NM_AUTH_TYPE_WPA_PSK_CCMP': 8,
							'NM_AUTH_TYPE_WEP104': 16,
							'NM_AUTH_TYPE_WPA_EAP': 32,
							'NM_AUTH_TYPE_LEAP': 64}

IW_auth = {'IW_AUTH_ALG_OPEN_SYSTEM': 1,
					 'IW_AUTH_ALG_SHARED_KEY': 2,
					 'IW_AUTH_ALG_LEAP': 4}

IW_wpa_versions = {'IW_AUTH_WPA_VERSION_WPA': 2,
									 'IW_AUTH_WPA_VERSION_WPA2': 4}

IW_key_mgt = {'IW_AUTH_KEY_MGMT_802_1X': 1,
							'IW_AUTH_KEY_MGMT_PSK': 2}

PYNET_DEVICE = {'802.3': 'Ethernet',
								'Ethernet': '802.3',
								'802.11': 'Wireless',
								'Wireless': '802.11',
								None: 'Disconnected',
								'Disconnected': None}

PY_RANK_PARAMS = {'interface': 1,
									'type': 2,
									'mode': 3,
									'ip': 4,
									'netmask': 5,
									'gateway': 6,
									'dns1': 7,
									'dns2': 8,
									'network': 9,
									'cypher': 10,
									'auth': 11,
									'key': 12,
									'key_mgt': 13}

dbus_service = 'org.freedesktop.NetworkManager'
log = GET_LOGGER('network')



# Wrap DBUS call
def call(m):
	try:
		ret = m()
	except Exception, e:
		log.error('dbus error while calling %s: %s', m, e)
		PRINT_EXCEPTION(e)
		ret = None
	return ret



# TODO CHECK else '.'
FILTER = ''.join([chr(x) if len(repr(chr(x))) == 3 else '.' for x in range(256)])



# Make a hexdum of src
# Usefull for Wifi keys
def hexdump(src, length=8):
	result = []
	for i in xrange(0, len(src), length):
		s = src[i:i + length]
		hexa = ''.join(['%02X' % ord(x) for x in s])
		result.append('%s' % hexa)
	return ''.join(result)



# Main class to control networkmanager
class NetworkManager(object):

	__metaclass__ = MetaSingleton

	def __init__(self):
		from peewee.dbus import peewee_dbus
		self._pynet = None
		self._wdb = peewee_dbus
		self._nm = self._wdb.reference(dbus_service, '/org/freedesktop/NetworkManager', 'org.freedesktop.NetworkManager')
		self._nm_sig = self._wdb.instance('/org/freedesktop/NetworkManager')
		self._getDevices = self._nm.method('getDevices', '', 'ao')
		self._state = self._nm.method('state', '', 'i')
		self._setActiveEthDevice = self._nm.method('setActiveDevice', 'o', '')
		self._setActiveWlanDevice = self._nm.method('setActiveDevice', 'os', '')
		self._setActiveWepDevice = self._nm.method('setActiveDevice', 'osisi', '')
		self._setActiveWpaDevice = self._nm.method('setActiveDevice', 'osisii', '')
		self._obs = []
		self._nm_sig.signal('DeviceAdded', 'os', self.device_added, 0)
		self._nm_sig.signal('DeviceNowActive', 'os', self.wireless_now_active, 0)
		self._nm_sig.signal('DeviceActivationFailed', 'os', self.device_activation_failed, 0)
		self._nm_sig.signal('WirelessNetworkAppeared', 'oo', self.wireless_network_appeared, 0)
		self._nm_sig.signal('WirelessNetworkDisappeared', 'oo', self.wireless_network_disappeared, 0)
		self.get_wireless_configuration = partial(self.get_configuration_by_name, 'Wireless')
		self.get_wired_configuration = partial(self.get_configuration_by_name, 'Ethernet')
		return None

	def _get_pynet(self):
		if not self._pynet:
			try:
				self._pynet = pynetwork.WyNetworkModule_instance()
			except Exception, e:
				log.warn('Unable to contect wynetwork')
				PRINT_EXCEPTION(e)
				self._pynet = None
		return None

	pynet = property(_get_pynet)
	del _get_pynet

	def register_observer(self, obs):
		self._obs.append(obs)
		return None

	def unregister_observer(self, obj):
		self._obs.remove(obj)
		return None

	# Return MAC address for active interface
	def _get_hwaddr(self):
		ifconfig = os.popen('/sbin/ifconfig')
		raw = ifconfig.read()
		ifconfig.close()
		interface = self.get_active_configuration()['values']['interface']
		if interface is None:
			return '00:00:00:00:00:00'
		data = [line for line in raw.split('\n\n') if line.startswith(interface + ' ')]
		if not data:
			raise ValueError('The interface %s does not exist' % interface)
		fields = filter(bool, (line.strip() for line in data[0].split('  ')))
		for line in fields:
			if line.startswith('HWaddr'):
				unused, hwaddr = line.split(None, 1)
		return hwaddr

	def _get_dns_servers(self):
		try:
			resolv = open('/etc/resolv.conf')
			servers = [line.strip().split(None, 1)[1] for line in resolv if line.startswith('nameserver')]
			resolv.close()
			if not servers:
				servers = ['0.0.0.0', '0.0.0.0']
		except IOError:
			servers = ['0.0.0.0', '0.0.0.0']
		return servers

	# Update the object data by parsing 'ifconfig' and 'route' commands
	def _get_network_infos(self, ifname):
		_ip = '0.0.0.0'
		_hwaddr = '00:00:00:00:00:00'
		_netmask = '0.0.0.0'
		_gateway = '0.0.0.0'
		ifconfig = os.popen('/sbin/ifconfig')
		raw = ifconfig.read()
		ifconfig.close()
		data = [line for line in raw.split('\n\n') if line.startswith(ifname + ' ')]
		if not data:
			raise ValueError('The interface %s does not exist' % ifname)
		fields = filter(bool, (line.strip() for line in data[0].split('  ')))
		for line in fields:
			if line.startswith('inet addr'):
				unused, _ip = line.split(':', 1)
			elif line.startswith('Mask'):
				unused, _netmask = line.split(':', 1)
		route = os.popen('/sbin/route -n')
		raw = route.read()
		route.close()
		data = [line for line in raw.split('\n') if line.startswith('0.0.0.0 ') and line.endswith(ifname)]
		if data:
			fields = data[0].split(None, 2)
			_gateway = fields[1]
		dns_servs = self._get_dns_servers()
		if len(dns_servs) == 1:
			dns_servs.append('0.0.0.0')
		return {'ip': _ip, 'netmask': _netmask, 'hwaddr': _hwaddr, 'gateway': _gateway, 'dns1': dns_servs[0], 'dns2': dns_servs[1]}

	def get_active_configuration(self):
		try:
			for config in self.pynet.getConfigurations():
				params = self.pynet.getConfiguration(config)
				if params[0]:
					if params[3] == 'upnp':
						infos = self._get_network_infos(params[1])
						params[4] = infos['ip']
						params[5] = infos['netmask']
						params[6] = infos['gateway']
						params[7] = infos['dns1']
						params[8] = infos['dns2']
					return {'config': config, 'values': dict(((key, params[PY_RANK_PARAMS[key]]) for key in PY_RANK_PARAMS))}
		except Exception, e:
			PRINT_EXCEPTION(e)
		return {'config': None, 'values': dict(((key, None) for key in PY_RANK_PARAMS))}

	active_ip = property((lambda self: self.get_active_configuration()['values']['ip']))
	active_netmask = property((lambda self: self.get_active_configuration()['values']['netmask']))
	active_gateway = property((lambda self: self.get_active_configuration()['values']['gateway']))
	active_dns1 = property((lambda self: self.get_active_configuration()['values']['dns1']))
	active_dns2 = property((lambda self: self.get_active_configuration()['values']['dns2']))
	active_type = property((lambda self: self.get_active_configuration()['values']['type']))
	active_hwaddr = property((lambda self: self._get_hwaddr()))
	active_values = property((lambda self: self.get_active_configuration()['values']))

	def get_configuration_by_name(self, name):
		try:
			return self.pynet.getConfiguration(name)
		except Exception, e:
			log.error('Failed to get config: %s', name)
			PRINT_EXCEPTION(e)
		return None

	# Update wynetwork config using a dict of new parameters 'new_params'.
	# See PY_RANK_PARAMS for known params
	def set_configuration(self, config, new_params):
		config = PYNET_DEVICE[config]
		try:
			old_params = self.get_configuration_by_name(config)
		except Exception, e:
			PRINT_EXCEPTION(e)
		else:
			for k, v in new_params.iteritems():
				if k in PY_RANK_PARAMS:
					old_params[PY_RANK_PARAMS[k]] = v
			self.pynet.setConfiguration(config, *old_params[1:])
		return None

	# Set 'val' to 'where' parameter, for the specified configuration,
	# For instance, to put 'netmask' to '255.255.255.0' for 'Ethernet' config,
	# you have to call : set_value_config('Ethernet', 'netmask', '255.255.255.0')
	# See PY_RANK_PARAMS for available parameters
	def set_value_config(self, config, where, val):
		ret = self.get_configuration_by_name(config)
		if ret is not None and self.pynet:
			ret[PY_RANK_PARAMS[where]] = val
			try:
				self.pynet.setConfiguration(config, *ret[1:])
			except Exception, e:
				PRINT_EXCEPTION(e)
		return None

	def set_values_config(self, config, mapping_val):
		config = PYNET_DEVICE[config]
		for k, v in mapping_val.iteritems():
			if k in PY_RANK_PARAMS:
				self.set_value_config(config, k, v)
		return None

	def get_network_capabilities(self, ssid):
		auth, cypher, key_mgt = None, None, None
		net = self.get_net_by_name(ssid)
		if net is not None and self.pynet:
			net_path = net.object_path
			try:
				auth, cypher, key_mgt = self.pynet.getNetworkCapabilities(net_path)
			except Exception, e:
				PRINT_EXCEPTION(e)
		return (auth, cypher, key_mgt)

	# Set the 'config' as active
	# Be sure that config has been set before
	def connect_with_config(self, config):
		config = PYNET_DEVICE[config]
		ret = self.get_configuration_by_name(config)
		if ret is not None and self.pynet:
			try:
				self.pynet.setActiveConfiguration(config)
				log.debug('Set %s as active network configuration', config)
				return True
			except Exception, e:
				PRINT_EXCEPTION(e)
				return False
		else:
			return False

	# DeviceAdded sig handler
	def device_added(self, obj, name):
		log.debug('sig DeviceAdded(%s, %s)', obj, name)
		for o in self._obs:
			try:
				o.device_added
			except AttributeError:
				log.debug('%r has not device_added', o)
			else:
				Task(o.device_added).start(2)
		return None

	# WirelesNetworkAppeared sig handler
	def wireless_network_appeared(self, dev, net):
		log.debug('sig WirelessNetworkAppeared (%s) on (%s)', net, dev)
		for o in self._obs:
			try:
				o.wireless_network_appeared
			except AttributeError:
				log.debug('%r has not wireless_network_appeared', o)
			else:
				Task(o.wireless_network_appeared).start(0.5)
		return None

	# WirelesNetworkDisappeared sig hander
	def wireless_network_disappeared(self, dev, net):
		log.debug('sig WirelessNetworkDisappeared (%s) on (%s)', net, dev)
		for o in self._obs:
			try:
				o.wireless_network_disappeared
			except AttributeError:
				log.debug('%r has not wireless_network_disappeared', o)
			else:
				Task(o.wireless_network_disappeared).start(0.5)
		return None

	# DeviceNowActive sig handler
	def ethernet_now_active(self, dev):
		log.debug('sig DeviceNowActive (%s)', dev)
		for o in self._obs:
			try:
				o.device_now_active
			except AttributeError:
				log.debug('%r has not device_now_active', o)
			else:
				Task(o.device_now_active).start(0.5)
		return None

	# DeviceNowActive sig handler
	def wireless_now_active(self, dev, ssid):
		log.debug('sig DeviceNowActive (%s)', dev)
		for o in self._obs:
			try:
				o.device_now_active
			except AttributeError:
				log.debug('%r has not device_now_active', o)
			else:
				Task(o.device_now_active).start(0.5)
		return None

	# DeviceNoLongerActive sig handler
	def device_no_longer_active(self, dev):
		log.debug('sig DeviceNoLongerActive (%s)', dev)
		for o in self._obs:
			try:
				o.device_no_longer_active
			except AttributeError:
				log.debug('%r has not device_no_longer_active', o)
			else:
				Task(o.device_no_longer_active).start(0.5)
		return None

	# DeviceActivationFailed sig handler
	def device_activation_failed(self, dev, ssid):
		log.debug('sig DeviceActivationFailed (%s)', dev)
		for o in self._obs:
			try:
				o.device_activation_failed
			except AttributeError:
				log.debug('%r has not device_activation_failed', o)
			else:
				t = Task(o.device_activation_failed)
				t.args = (dev, ssid)
				t.start(0.5)
		return None

	# Get list of all devices (wired & wireless)
	def get_devices(self):
		devs = call(self._getDevices)
		if devs:
			return [Device(self._wdb, dev) for dev in devs]
		return []

	# Connect to an 'OPEN' wireless network
	def _NetworkManager__activate_wlan(self, dev_path, essid):
		try:
			self._setActiveWlanDevice(dev_path, essid)
			return True
		except Exception, e:
			PRINT_EXCEPTION(e)
			return False

	# Connect to a 'WEP' wireless network
	def _NetworkManager__activate_wep(self, dev_path, essid, cypher, key, auth_alg):
		try:
			self._setActiveWepDevice(dev_path, essid, NM_cyphers[cypher], key, IW_auth[auth_alg])
			return True
		except Exception, e:
			PRINT_EXCEPTION(e)
			return False

	# Connect to a 'WPA' wireless network
	def _NetworkManager__activate_wpa(self, dev_path, essid, cypher, key, wpa_version, key_mgt):
		try:
			self._setActiveWpaDevice(dev_path, essid, NM_cyphers[cypher], key, IW_wpa_versions[wpa_version], IW_key_mgt[key_mgt])
			return True
		except Exception, e:
			PRINT_EXCEPTION(e)
			return False

	# Connect to wire
	def _NetworkManager__activate_eth(self, dev_path):
		try:
			self._setActiveEthDevice(dev_path)
			return True
		except Exception, e:
			PRINT_EXCEPTION(e)
			return False

	# To activate a connection. will call the approriate '__active_***' method depending of parameters
	# 'device' and 'network' parameters must be Device and Network object or names (ex: eth1, wifi-toto)
	def set_active_device(self, device, network=None, cypher=None, key=None, auth_alg=None, wpa_version=None, key_mgt=None):
		log.debug('active_device device=%s network=%s cypher=%s key=%s auth_alg=%s wpa_version=%s key_mgt=%s', device, network, cypher, key, auth_alg, wpa_version, key_mgt)
		if isinstance(device, str):
			device = self.get_dev_by_name(device)
		if isinstance(device, Device):
			if network:
				essid = (network.get_name() if isinstance(network, Network) else network)
				if cypher is None or cypher == 'NM_AUTH_TYPE_NONE':
					return self._NetworkManager__activate_wlan(device.object_path, essid)
				elif 'WEP' in cypher:
					return self._NetworkManager__activate_wep(device.object_path, essid, cypher, key, auth_alg)
				elif 'WPA' in cypher:
					return self._NetworkManager__activate_wpa(device.object_path, essid, cypher, key, wpa_version, key_mgt)
			else:
				return self._NetworkManager__activate_eth(device.object_path)
		return False

	# Return the state of NM. See NM_state
	def get_state(self):
		state = call(self._state)
		if state:
			return NM_state[state]
		return None

	# Big dump of all wireless networks.
	# Return a list of dict
	def get_all_networks(self):
		networks = []
		devs = self.get_devices()
		for dev in devs:
			if dev.get_type() == 'wireless':
				nets = dev.get_networks()
				for net in nets:
					networks.append({'name': net.get_name(), 'strength': net.get_strength(), 'rate': net.get_rate(), 'encrypted': net.get_encrypted(), 'frequency': net.get_frequency(), 'device_obj': dev, 'network_obj': net})
		return networks

	# Return the first wired device
	def get_wire_device(self):
		for dev in self.get_devices():
			if dev.get_type() == 'ethernet':
				return dev
		return None

	# Print availables wireless networks
	def show_networks(self):
		for net in self.get_all_networks():
			print '%s\t%s\t%s\t%s' % (net['strength'], net['encrypted'], net['device_obj'].get_name(), net['name'])
		return None

	def get_dev_by_name(self, name):
		for dev in self.get_devices():
			if dev.get_name() == name:
				return dev
		return None

	def get_net_by_name(self, essid):
		for net in self.get_all_networks():
			if net['name'] == essid:
				return net['network_obj']
		return None

	def help(self):
		print 'NM.show_networks()\n'
		print 'ETH: NM.set_active_device(dev)'
		print 'OPE: NM.set_active_device(dev, net)'
		print 'WEP: NM.set_active_device(dev, net, cypher, key, auth_alg)'
		print 'WPA: NM.set_active_device(dev, net, cypher, key, wpa_version, key_mgt)\n'
		print 'dev: device object or device name (ra0)'
		print 'net: network object or essid (wifi-test)\n'
		print 'cyphers in:'
		print NM_cyphers.keys()
		print 'auth_alg in:'
		print IW_auth.keys()
		print 'wpa_version in:'
		print IW_wpa_versions.keys()
		print 'key_mgt in:'
		print IW_key_mgt.keys()
		print "\nEX: NM.set_active_device('eth1', 'wyplay-upnp', 'NM_AUTH_TYPE_WEP104', '852E2FB20D6756DC3DDF16CF9B', 'IW_AUTH_ALG_SHARED_KEY')"



class Device(object):

	def __init__(self, wdb, object_path):
		self._wdb = wdb
		self.object_path = object_path
		self._nm_device = self._wdb.reference(dbus_service, object_path, 'org.freedesktop.NetworkManager.Devices')
		self._getProperties = self._nm_device.method('getProperties', '', '(osusbusssssssiibiuusas)')
		self._getName = self._nm_device.method('getName', '', 's')
		self._getType = self._nm_device.method('getType', '', 'i')
		self._getHalUdi = self._nm_device.method('getHalUdi', '', 's')
		self._getIP4Address = self._nm_device.method('getIP4Address', '', 'u')
		self._getLinkActive = self._nm_device.method('getLinkActive', '', 'b')
		self._getActiveNetwork = self._nm_device.method('getActiveNetwork', '', 's')
		self._getNetworks = self._nm_device.method('getNetworks', '', 'ao')
		return None

	def get_name(self):
		return call(self._getName)

	def get_type(self):
		type = self._getType()
		if type:
			return NM_devices_type[type]
		return None

	def get_hal_udi(self):
		return call(self._getHalUdi)

	def get_ip_address(self):
		try:
			ip = inet_ntoa(pack('!I', ntohl(call(self._getIP4Address))))
		except Exception, e:
			PRINT_EXCEPTION(e)
			ip = None
		finally:
			return ip

	def get_link_active(self):
		return call(self._getLinkActive)

	def get_active_network(self):
		net = call(self._getActiveNetwork)
		if net:
			return Network(net)
		return None

	def get_networks(self):
		nets = call(self._getNetworks)
		net_list = []
		if nets:
			for net in nets:
				net_list.append(Network(self._wdb, net))
		return net_list



class Network(object):

	def __init__(self, wdb, object_path):
		self._wdb = wdb
		self.object_path = object_path
		self._nm_network = self._wdb.reference(dbus_service, object_path, 'org.freedesktop.NetworkManager.Devices')
		self._getName = self._nm_network.method('getName', '', 's')
		self._getAddress = self._nm_network.method('getAddress', '', 's')
		self._getStrength = self._nm_network.method('getStrength', '', 'i')
		self._getFrequency = self._nm_network.method('getFrequency', '', 'd')
		self._getRate = self._nm_network.method('getRate', '', 'i')
		self._getEncrypted = self._nm_network.method('getEncrypted', '', 'b')
		self._getProperties = self._nm_network.method('getProperties', '', '(ossidiiib)')
		return None

	def get_name(self):
		return call(self._getName)

	def get_strength(self):
		return call(self._getStrength)

	def get_frequency(self):
		return call(self._getFrequency)

	def get_rate(self):
		return call(self._getRate)

	def get_encrypted(self):
		return call(self._getEncrypted)

	def get_properties(self):
		return call(self._getProperties)



if __name__ == '__main__':
	NM.help()
	import pdb
	pdb.set_trace()
