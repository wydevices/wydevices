# -*- coding: utf-8 -*- 
#
# Description:
#
# Peewee Analyse Class Definitions
#
#
#
# Changes:
#
# 2011-12-07
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.


from __future__ import absolute_import

from peewee.debug import GET_LOGGER

log = GET_LOGGER('analyse')



class Cover(object):

	def start(self, main):
		print '*' * 100,
		print '\nCODE COVERAGE ANALYSIS STARTED\n',
		print '*' * 100
		import trace
		out_dir = 'wybox_code_coverage'
		out_file = '.wybox.trace'
		my_trace = trace.Trace(ignoremods=['wyvas', 'peewee'], trace=0, count=1, outfile=out_file)
		my_trace.runfunc(main)
		r = my_trace.results()
		r.write_results(show_missing=False, summary=False)
		try:
			import trace2html
			trace2html.main(['trace2html.py', '-f', out_file, '-o', out_dir])
		except Exception, e:
			print "WARNING trace2html not found : html code coverage won't be created : %s" % str(e)
		return None



class Profiler(object):

	def start(self, main):
		print '*' * 100,
		print '\nTIME PROFILER STARTED\n',
		print '*' * 100
		import hotshot
		import hotshot.stats
		my_profiler = hotshot.Profile('.wybox.prof')
		my_profiler.runcall(main)
		my_profiler.close()
		profiler_stats = hotshot.stats.load('.wybox.prof')
		profiler_stats.sort_stats('time', 'calls')
		profiler_stats.dump_stats('wybox_profiling_time_call.prof')
		profiler_stats.print_stats()
		return None



try:
	import pycallgraph
	import os
	# @CallGraph(stop_trace=True)
	# def test_func(*args, **kw):
	#  ...
	#
	# Write a file called /tmp/test_func.dot containing the call graph of decorated function.
	# To obtain a more readable view of this file, you can use the dot utility on your own PC:
	# "dot -T jpg/png/gif/ps -o your_file /tmp/test_func.dot"
	# N.B : dot utility is a part of the GraphViz project.
	#
	# pycallgraph can be installed by easy_install (pure python -> works with sh4):
	# easy_install pycallgraph
	class CallGraph(object):

		def __init__(self, stop_trace=True):
			self.stop_trace = stop_trace
			return None

		def __call__(self, f):
			def trace(*args, **kwds):
				res = None
				pycallgraph.start_trace()
				try:
					res = f(*args, **kwds)
					open(os.path.join('/tmp', '%s.dot' % f.__name__), 'w').write(pycallgraph.get_dot(stop=self.stop_trace))
				finally:
					return res
			return trace

except:
	class CallGraph(object):

		def __init__(self, stop_trace=True):
			self.stop_trace = stop_trace
			return None

		def __call__(self, f):
			def trace(*args, **kwds):
				res = None
				try:
					res = f(*args, **kwds)
				finally:
					log.warning('trace called but pycallgrah is not available')
					return res
			return trace



from time import time

WHAT_TO_CHRONO = set(['wyrecord', 'wyscan', 'gui', 'dvd', 'actions', 'wymedia'])
_decal = 0
_call_queue = list()



# Decorator which helps to control what aspects of a program to debug
# on per-function basis. Aspects are provided as list of arguments.
# It DOESN'T slowdown functions which aren't supposed to be debugged.
#
# Example:
# @Chrono(['johan'])
# def func_to_measure(*args, **kwargs):
# ...
#
# --> DEBUG : func_to_measure executed in ...s
class Chrono(object):

	def __init__(self, aspects=None, limit=0):
		self.aspects = set(aspects)
		self.limit = 0
		return None

	def __call__(self, f):
		if self.aspects & WHAT_TO_CHRONO:
			log.debug('trace call for %s' % f.func_name)
			def measure(*args, **kwds):
				global _decal
				global _call_queue
				_call_queue.append(list())
				_decal += 1
				_prefix = ' '.join(self.aspects) + ' ' + ('----' * _decal)
				log.debug('%s %s called' % (_prefix + '>', f.func_name))
				t = time()
				f_result = f(*args, **kwds)
				res = time() - t
				if res > self.limit:
					log.debug('%s %s executed in %fs' % (_prefix, f.func_name, res))
				_call_queue[_decal - 1].append((f.func_name, res))
				_dec = ' ' * len(_prefix)
				factor = 100.0 / res
				if _decal < len(_call_queue):
					for func_timed in _call_queue[_decal]:
						log.debug('%s %s : %.1f%% with %fs' % (_dec, func_timed[0], func_timed[1] * factor, func_timed[1]))
					_call_queue.pop()
				_decal -= 1
				return f_result
			return measure
		else:
			return f



chrono_dvd = Chrono(['dvd'])
chrono_gui = Chrono(['gui'])
chrono_actions = Chrono(['actions'])
chrono_wymedia = Chrono(['wymedia'])



__ts = time()

def timestep(what='step', logger=log):
	global __ts
	now = time()
	logger.debug('TIMESTEP: %s %.3f' % (what, now - __ts))
	__ts = now
	return None



import sys
import timeit

bench_repeat, bench_number = 10, timeit.Timer.repeat.im_func.func_defaults[1]



# Set repeat to r * n iterations
# Generally, N < R
def set_bench_values(r=None, n=None):
	global bench_repeat
	global bench_number
	if n is not None:
		bench_number = n
	if r is not None:
		bench_repeat = r
	return None



# Benchmark function.
# Pass a 2 arguments (code, setup_code) or a list of them.
# 
# Working example:
# benchmark((
#     ('p_time()', 'from time import time as p_time'),
#     ('g_time()', 'from time import gmtime as g_time'),
#     ('l_time()', 'from time import localtime as l_time'),
#     ('clock()', 'from time import clock'),
#     ))
def benchmark(expression_setup_list, prepare=None):
	scores_dict = dict()
	if prepare is not None:
		expression_setup_list = [expression_setup_list, prepare]
	for expression, setup in expression_setup_list:
		sys.stdout.write('%s..' % expression)
		sys.stdout.flush()
		v = sum(timeit.Timer(expression, setup).repeat(bench_repeat, bench_number))
		scores_dict[expression] = v
		sys.stdout.write('.')
	print '\nScores (bigger is slower):\n'
	score_expr_list = [(k, v) for k, v in scores_dict.iteritems()]
	score_expr_list.sort()
	reference = score_expr_list[0][0]
	total_iterations = bench_repeat * bench_number
	for score, expr in score_expr_list:
		print '%s: %s (%.1f%%) (%fms/call)' % (expr, score, 100 * score / reference, score * 1000 / total_iterations)
	return None



def test_benchmark():
	set_bench_values(100, 10000)
	print "Legend:\n    p_time = python library's time.time\n    g_time = python library's time.gmtime\n    l_time = python library's time.localtime\n    c_time = peewee's clock_gettime wrapper\n    clock = python library's time.clock\n    "
	benchmark((('p_time()', 'from time import time as p_time'),
						 ('g_time()', 'from time import gmtime as g_time'),
						 ('l_time()', 'from time import localtime as l_time'),
						 ('c_time()', 'from peewee.gettime import time as c_time'),
						 ('clock()', 'from time import clock')))
	return None



import imp
import types
from operator import itemgetter

# The loader takes a name and info about the module to load and
# "loads" it - in this case write to definied output some data, such as
# module name, time taken to import it.
class VerboseLoader(object):

	def __init__(self, name, file, pathname, desc, output=None):
		self.file = file
		self.name = name
		self.pathname = pathname
		self.desc = desc
		self.output = (output if output is not None else sys.stdout)
		return None

	def load_module(self, fullname):
		try:
			t_init = time()
			mod = imp.load_module(self.name, self.file, self.pathname, self.desc)
			t_fin = time() - t_init
			self.output.write('-> %s ( %.4f sec ) --- %s\n' % (fullname, t_fin, self.pathname))
			VerboseImporter.imported.append((fullname, t_fin))
		except:
			mod = None
		finally:
			if self.file:
				self.file.close()
		sys.modules[fullname] = mod
		return mod



class VerboseImporter(object):

	imported = []

	def __init__(self, output=None, report=True, report_output=None, report_threshold=0.10000000000000001):
		self.output = (output if output is not None else sys.stdout)
		self.report = report
		self.report_output = (report_output if report_output is not None else sys.stdout)
		self.report_threshold = report_threshold
		return None

	def __enter__(self):
		sys.meta_path.append(self)
		return None

	def __exit__(self, exc_type, exc_val, exc_tb):
		sys.meta_path.remove(self)
		l = VerboseImporter.imported
		if self.report and l:
			output = self.report_output
			threshold = self.report_threshold
			output.write('\n\n##########################\nIMPORTS REPORTING\n\n')
			for elt in sorted(l, key=itemgetter(1), reverse=True):
				if elt[1] > threshold:
					output.write('| %s %.4f\n' % (elt[0].ljust(50, '.'), elt[1]))
			VerboseImporter.imported = []
		return None

	def find_module(self, fullname, path=None):
		origName = fullname
		if not path:
			mod = sys.modules.get(fullname, False)
			if mod is None or (mod and isinstance(mod, types.ModuleType)):
				return mod
		if '.' in fullname:
			head, fullname = fullname.rsplit('.', 1)
			mod = sys.modules.get(head, None)
			if mod is None:
				return None
			if hasattr(mod, '__path__'):
				path = mod.__path__
		try:
			file, pathname, desc = imp.find_module(fullname, path)
			return VerboseLoader(origName, file, pathname, desc, self.output)
		except ImportError:
			pass
		return None



def install_importer(output=None, report=True, report_output=None, report_threshold=0.10000000000000001):
	sys.meta_path.append(VerboseImporter(output, report, report_output, report_threshold))
	return None



if __name__ == '__main__':
	test_benchmark()
