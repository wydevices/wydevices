# -*- coding: utf-8 -*- 
#
# Description:
#
# Debug & Logging Class Definitions
#
#
#
# Changes:
#
# 2011-10-02
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.


from __future__ import absolute_import

import pdb
from time import asctime, sleep
import traceback
import sys
import logging
import os

log_level = logging.ERROR # 0, logging.DEBUG, logging.INFO, logging.WARNING, logging.ERROR, logging.CRITICAL
log_filter = os.getenv('pygui_LOG_FILTER')

if log_level:
	logging.basicConfig(level=log_level, format=' %(levelname)s.%(threadName)s[%(relativeCreated).8s]  %(name)s::%(filename)s:%(funcName)s:%(lineno)s %(message)s', datefmt='%m-%d %H:%M')

log = logging.getLogger('peewee')

DEBUG_MODE = False
CALLS_ONLY = False



class MultiFilter(object):
	def __init__(self, name):
		self.names = name.split('|')
		self.filters = []
		for n in self.names:
			self.filters.append(logging.Filter(n))
		return None

	def filter(self, record):
		for f in self.filters:
			if f.filter(record):
				return 1
		return 0


# Silent every logger but "name"
def FILTER(name):
	f = MultiFilter(name)
	for h in logging.getLogger().handlers:
		h.filters = [f]
	return None

if log_filter:
	FILTER(log_filter)



def DEBUG(force=False):
	if force or (DEBUG_MODE and log_level):
		pdb.set_trace()



def TRACE(limit=20):
	if DEBUG_MODE and log_level:
		traceback.print_stack(limit=limit)



def _attribute_catcher(self, attr):
	if not DEBUG_MODE:
		return object.__getattribute__(self, attr)
	try:
		attribute = object.__getattribute__(self, attr)
		class ProxyCatcher(object, attr):
			def __init__(self, obj):
				self._proxy_obj_ = obj
				return None

			def __getattribute__(self, name):
				if DEBUG_MODE and not CALLS_ONLY:
					lof.waring('  ** self.%s.%s', attr, name)
				return object.__getattribute__(self, _proxy_obj_().__getattribute__(name))

			def __call__(self, *args, **kw):
				if DEBUG_MODE:
					params = []
					if args:
						params.extend((str(x) for x in args))
					if kw:
						params.extend((('%s=%s'%(k, v)) for k, v in kw.items()))
					log.warning('  ** self.%s(%s)', attr, ', '.join(params))
				return object.__getattribute__(self, _proxy_obj_(), *args, **kw)

		if __call__ in dir(attribute):
			attribute = ProxyCatcher(attribute)
		elif not CALLS_ONLY:
			log.warning('  ** self.%s', attr)
		return attribute
	except Exception, e:
		raise log.error('  !! self.%s : %s', attr, e)



def WATCH_CLASS(*args):
	if log_level:
		for cls in args:
			setattr(cls, '__getattribute__', _attribute_catcher)


# Normalize a name so that its form complies with Pygui's logger standards.      
#                                                                           
# That form is such that the name is split .-wise, its first component       
# kept whole, its last removed, and the others reduced to their first letter,
# e.g. foo.bravo.alpha.romeo.baz will end up as foo.b.a.r.                   
#                                                                           
# Names with only a single component ("foo") are unchanged.                  
#                                                                           
# You'll probably want to use this function with FILTER, e.g.                
# FILTER(normalize_name(__name__)) when the module's logger was created      
# with GET_LOGGER(__name__).                                                 
def normalize_name(name):
	components = name.split('.')
	stripped_components = []
	for i in components[1:-1]:
		if i:
			stripped_components.append(i[0])
	stripped_components.insert(0, components[0])
	return '.'.join(stripped_components)


# Obtain a logger.
#
# Arguments:
#     - name: used to filter the logging traces on stdout with the FILTER function.
#         Defaults to DEBUG, but if you don't know what to put in there,           
#         just use your module's __name__.                                         
#     - file: Not used.                                                            
#                                                                                 
# The name is normalized with normalize_name.                                      
def GET_LOGGER(name='DEBUG', file=None):
	return logging.getLogger(normalize_name(name))



def PRINT_EXCEPTION(e=None, stop=False):
	if log_level:
		traceback.extract_stack()[-1][1]
		traceback.print_exc()
		if stop:
			pdb.set_trace()



def SLOW_PRINT(message='[slow step]', delay=1):
	log.warning(message)
	sleep(delay)



__all__ = ['DEBUG_MODE', 'DEBUG', 'WATCH_CLASS', 'TRACE', 'GET_LOGGER', 'log', 'PRINT_EXCEPTION', 'SLOW_PRINT']
