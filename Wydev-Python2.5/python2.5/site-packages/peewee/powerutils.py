# -*- coding: utf-8 -*- 
#
# Description:
#
# Peewee Power Utils Class Definitons
#
#
#
# Changes:
#
# 2012-05-04
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

from __future__ import absolute_import

__all__ = ['PowerManager', 'PowerManagerModule']

import platform
from peewee.dbus import peewee_dbus
from peewee.debug import log
from peewee.misc_utils import MetaSingleton
from peewee.notifier import Task
from wydbus import WDB_AS_THREAD



# This class is a wrapper provided to manage communications between the wystandby
# module and other modules who use the peewee notifier.
# Dbus instances can't be dispatched among all receivers if the receivers are using
# the same dbus loop.
class PowerManager(object):

	__metaclass__ = MetaSingleton

	def __init__(self):
		self.apm_state_dict = {0: 'apm_ready', 1: 'apm_standby', 2: 'apm_suspend', 3: 'apm_off'}
		_wystandby = peewee_dbus.reference('com.wyplay.wycrs', '/com/wyplay/wycrs/wystandby', 'com.wyplay.wycrs')
		self._add_standby_module = _wystandby.method('AddStandbyModule', 's', 's')
		self._remove_standby_module = _wystandby.method('RemoveStandbyModule', 's', 'i')
		self._change_apm_state = _wystandby.method('ChangeGlobalPowerState', 'i', '')
		self._get_apm_state = _wystandby.method('GetGlobalPowerState', '', 'i')
		self.notify_new_max_power_state = _wystandby.method('NotifyNewMaxPowerState', 'si', '')
		self.notify_power_state_changed = _wystandby.method('NotifyPowerStateChanged', 'si', '')
		self.set_alarm = _wystandby.method('SetAlarm', 'x', '')
		self.inst = peewee_dbus.instance('/com/wyplay/wycrs/wystandby')
		self.inst.signal('ChangePowerState', 'i', self.wms_change_power_state, WDB_AS_THREAD)
		self._apm_interested_modules = []
		return None

	apm_state = property((lambda self: self._get_apm_state()), (lambda self, state: self._change_apm_state(state)))

	def wms_change_power_state(self, apm_state):
		str_state = self.apm_state_dict[apm_state]
		for module in self._apm_interested_modules:
			Task(getattr(module, str_state)).start(0.01)
		return None

	def add_module(self, module, name):
		name = self._add_standby_module(name)
		self._apm_interested_modules.append(module)
		return name

	def remove_module(self, module):
		if module in self._apm_interested_modules:
			self._remove_standby_module(module.name)
			self._apm_interested_modules.delete(module)
		return None



class PowerManagerModule(object):

	def __init__(self, name):
		self.pm = PowerManager()
		self.name = self.pm.add_module(self, name)
		return None

	def notify_power_state_changed(self, state):
		return self.pm.notify_power_state_changed(self.name, state)

	def notify_new_max_power_state(self, state):
		return self.pm.notify_new_max_power_state(self.name, state)

	def apm_ready(self):
		self.notify_power_state_changed(0)
		return None

	def apm_standby(self):
		self.notify_power_state_changed(1)
		return None

	def apm_suspend(self):
		self.notify_power_state_changed(2)
		return None

	def apm_off(self):
		self.notify_power_state_changed(3)
		return None
