# -*- coding: utf-8 -*- 
#
# Description:
#
# WyPlayer Client Interface Class Definition
#
#
#
# Changes:
#
# 2011-10-20
# Initial Commit
#
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.


from wyplayer_dbus import WyPlayerProxy
import urllib
import wydbus



# WyPlayer client interface.
#
#
#  Example usage:
#
#  >>> from wyplayer import WyPlayer
#  >>> wpl = Wyplayer()
#
#  >>> def status_cb(status):
#       ...
#       print "hello status! '%s'" % (status)
#
#  >>> wpl.watch_property('status', status_cb)
#
#  >>> print "status='%s'" % (status)
#  status='closed'
#
#  >>> wpl.open(video=True, audio=True, subtitles=True)
#  hello status! 'idle'
#
#  >>> wpl.load_uri("file:///path/to/file.avi")
#  hello status! 'loading'
#  hello status! 'idle'
#
#  >>> wpl.play_loaded()
#  hello status! 'playing'
#
#  >>> print "uri='%s', status='%s', speed=%f" % (wpl.uri, wpl.status, wpl.speed)
#  uri='file:///path/to/file.mpg', status='playing', speed=1.0
#
#  >>> wpl.stop()
#  hello status: 'idle'
#
#  >>> wpl.close()
#  hello status: 'closed'
#
#  TODO: full reference for URI types and properties
class WyPlayer(object):

	# Create WyPlayer client object.
	#
	# "havana_adapter" is a specific parameter for use with the "havana" audio/video decoding driver.
	# The specified number defines the 'X' in '/dev/dvb/adapterX/audio0' and '/dev/dvb/adapterX/video0'.
	#
	# "arch" specifies which rendering drivers are to be used depending on the platform the daemon is running on.
	# By default, "stb7100" uses the "havana" driver for audio and video.
	# Any other value currently uses the "dummy" driver for audio and video.
	# Subtitles drivers are not currently affected by this parameter.
	def __init__(self, havana_adapter=0, arch='stb7100'):
		self.dpl = WyPlayerProxy()
		self.wpl = self.dpl.wyplayer
		self.havana_adapter = havana_adapter
		self._WyPlayer__aspect_ratio = None
		self._WyPlayer__display_format = None
		if arch == 'stb7100':
			self.drivers = (('dummy', 'dummy', 'dummy', 'dummy'), ('havana2:adapter=%u:avsync=%%u' % havana_adapter, 'havana2:adapter=%u' % havana_adapter, 'softsub', 'havana2'))
		elif arch == 'softdec':
			self.drivers = (('dummy', 'dummy', 'dummy', 'dummy'), ('softdec', 'softdec', 'softsub', 'dummy'))
		else:
			self.drivers = (('dummy', 'dummy', 'dummy', 'dummy'), ('dummy', 'dummy', 'dummy', 'dummy'))
		return None

	def watch_property(self, name, cb):
		try:
			self.dpl.props[name].set_notify(cb)
		except KeyError:
			pass
		return None

	def _WyPlayer__get_status(self):
		try:
			return self.dpl.props['status'].get()
		except:
			return 'unknown'

	# Current player status.
	#
	#  Possible values:
	#   - "closed"
	#   - "loading"
	#   - "idle"
	#   - "playing"
	status = property(_WyPlayer__get_status)

	def _WyPlayer__get_exception(self):
		return self.dpl.props['exception'].get()

	# Last occured exception during loading or playback.
	#
	#  Possible values and meanings:
	#   - "" (empty string): no exception occurred
	#   - "media:" + some text: an error occurred during stream loading
	#   - "decode:" + some text: an error occurred during playback
	exception = property(_WyPlayer__get_exception)

	def _WyPlayer__get_speed(self):
		try:
			return self.dpl.props['speed'].get()
		except:
			return 0.0

	def _WyPlayer__set_speed(self, value):
		self.dpl.props['speed'].set(value)
		return None

	# Floating point number indicating the current playback speed.
	#
	#  Playback state is converted from speed as follows:
	#   - speed < -1.0: fast backward playback
	#   - speed = -1.0: normal speed backward playback
	#   - -1.0 < speed < 0.0: slow backward playback
	#   - speed = 0.0: pause
	#   - 0.0 < speed < 1.0: slow forward playback
	#   - speed = 1.0: normal speed forward playback
	#   - 1.0 < speed: fast forward playback
	#
	# Note: in the current wyplayer implementation, backward playback
	# supports only a single speed which is dependent on the specific
	# media stream (depends on spacing between key video frames).
	speed = property(fget=_WyPlayer__get_speed, fset=_WyPlayer__set_speed)

	def _WyPlayer__get_uri(self):
		return self.dpl.props['uri'].get()

	# URI of the currently loaded media stream.
	uri = property(fget=_WyPlayer__get_uri)

	def _WyPlayer__get_duration(self):
		return self.dpl.props['duration'].get()

	# Duration of the currently loaded media stream in milliseconds.
	duration = property(fget=_WyPlayer__get_duration)

	def _WyPlayer__get_container(self):
		return self.dpl.props['container'].get()

	# Container type of the currently loaded media stream.
	container = property(fget=_WyPlayer__get_container)

	def _WyPlayer__get_aid(self):
		return self.dpl.props['aid'].get()

	def _WyPlayer__set_aid(self, value):
		self.dpl.props['aid'].set(value)
		return None

	# ID number of the currently selected audio sub-stream.
	# Frames from other sub-streams are dropped during playback.
	aid = property(fget=_WyPlayer__get_aid, fset=_WyPlayer__set_aid)

	def _WyPlayer__get_vid(self):
		return self.dpl.props['vid'].get()

	def _WyPlayer__set_vid(self, value):
		self.dpl.props['vid'].set(value)
		return None

	# ID number of the currently selected video sub-stream.
	# Frames from other sub-streams are dropped during playback.
	vid = property(fget=_WyPlayer__get_vid, fset=_WyPlayer__set_vid)

	def _WyPlayer__get_sid(self):
		return self.dpl.props['sid'].get()

	def _WyPlayer__set_sid(self, value):
		self.dpl.props['sid'].set(value)
		return None

	# ID number of the currently selected subtitles sub-stream.
	# Frames from other sub-streams are dropped during playback.
	sid = property(fget=_WyPlayer__get_sid, fset=_WyPlayer__set_sid)

	def _WyPlayer__get_scrambled(self):
		return self.dpl.props['scrambled'].get()

	# True if currently playing media stream is scrambled.
	scrambled = property(fget=_WyPlayer__get_scrambled)

	def _WyPlayer__get_pos(self, transform, pts, rel, tb):
		return dict(map(transform, ('audio', 'video', 'sub', 'data'), self.wpl.playback.pos(pts, rel, tb[0], tb[1])))

	def _WyPlayer__get_byte_pos(self):
		return self._WyPlayer__get_pos(None, False, False, (1, 0))

	# Current offsets in bytes from the start of the stream.
	# All returned values in the table are the same.
	#
	#  Return a dict keyed with the following values:
	#   'audio', 'video', 'sub', 'data'
	byte_pos = property(fget=_WyPlayer__get_byte_pos)

	def _WyPlayer__get_sec_pos(self):
		return self._WyPlayer__get_pos((lambda x, y: (x, y / 1000.0)), True, False, (1, 1000))

	# Absolute playback positions (A/V/S) from the start of the stream, in seconds.
	#
	#  Return a dict keyed with the following values:
	#   'audio', 'video', 'sub', 'data'
	sec_pos = property(fget=_WyPlayer__get_sec_pos)

	def _WyPlayer__get_pts(self):
		return self._WyPlayer__get_pos(None, True, False, (1, 90000))

	# PTS (presentation time-stamp) of the latest rendered A/V/S frames, in 90Khz units.
	#
	#  Return a dict keyed with the following values:
	#   'audio', 'video', 'sub', 'data'
	pts = property(fget=_WyPlayer__get_pts)

	def _WyPlayer__get_rel_pos(self):
		return self._WyPlayer__get_pos((lambda x, y: (x, y / 1000.0)), True, True, (1, 1000))

	# Relative playback positions (A/V/S) from the start of the stream, in seconds.
	#
	#  Return a dict keyed with the following values:
	#   'audio', 'video', 'sub', 'data'
	rel_pos = property(fget=_WyPlayer__get_rel_pos)

	def _WyPlayer__set_display_format(self, format):
		if format not in ('pan_scan', 'letter_box', 'center_cut_out', 'fullscreen'):
			return None
		self._WyPlayer__display_format = format
		self.wpl.set_vopts('display_format=%s' % format)
		return None

	def _WyPlayer__get_display_format(self):
		return self._WyPlayer__display_format

	# Set aspect ratio adaptation method.
	#
	#  Valid values are:
	#   "pan_scan", "letter_box", "center_cut_out", or "fullscreen"
	display_format = property(fget=_WyPlayer__get_display_format, fset=_WyPlayer__set_display_format)

	def _WyPlayer__set_aspect_ratio(self, ratio):
		if ratio not in ('4_3', '16_9'):
			return None
		self._WyPlayer__aspect_ratio = ratio
		self.wpl.set_vopts('tv_aspect_ratio=%s' % ratio)
		return None

	def _WyPlayer__get_aspect_ratio(self):
		return self._WyPlayer__aspect_ratio

	# Set monitor's aspect ratio.
	#
	#  Use "4_3" for a 4/3 TV.
	#  Use "16_9" for a 16/9 TV.
	aspect_ratio = property(fget=_WyPlayer__get_aspect_ratio, fset=_WyPlayer__set_aspect_ratio)

	def _WyPlayer__set_spdif_surround(self, enable):
		if enable not in (False, True):
			return None
		self.wpl.set_aopts('spdif_es=%u' % int(enable))
		return None

	# Enable or disable sending raw surround data to the SP/DIF output.
	#
	#  If False, send PCM audio data.
	#  If True, send raw undecoded audio frames. may be AC3, DTS, or
	#  any audio codec supported by an external amplifier connected through SP/DIF or HDMI.
	spdif_surround = property(fset=_WyPlayer__set_spdif_surround)

	def _WyPlayer__get_drvs(self, audio=True, video=True, subtitles=True, data=True, osd=True, outwin=None, adrv=None, vdrv=None):
		if not adrv:
			adrv = self.drivers[audio][0]
		if not vdrv:
			vdrv = self.drivers[video][1]
		if adrv.startswith('havana'):
			if vdrv == 'dummy':
				adrv = adrv % 0
			else:
				adrv = adrv % 1
		elif vdrv.startswith('softdec') and outwin != None:
			vdrv += ':outwin=%g,%g,%g,%g' % outwin
		return '%s %s %s %s' % (adrv, vdrv, self.drivers[subtitles][2], self.drivers[data][3])

	# Load a media stream from an URI with associated properties.
	# 
	# "properties" can be used to alter WyPlayer's default behaviors on selected URIs.
	# "properties" must be a dict containing elements with only strings as keys and values.
	# 
	# Allowed "properties" are as follow:
	# 
	#  ifmt: force input file format (ffmpeg demuxer name)
	#  probe: enable/disable av_find_stream_info (1/0)
	#  bufsize: input buffer size in bytes
	#  subfile: external subtitles file URI
	#  sublang: external subtitles language (ISO 639 code)
	#  norm_speed: norm_speed (XXX)
	#  live: 'live' mode use this on live DVB and streamed URIs (including DLNA)
	#  wyts: use the wyts demuxer for MPEG TS streams
	#  service: set DVB service ID to pass to wyts (decimal)
	#  dlna_profile: set stream's DLNA profile ID
	#  mime_type: set stream's MIME type
	#  upnp_udn: specify origin DMS's UDN for UPnP transports
	#  wpl_sample_rate: force audio sample rate. XXX: OBSOLETE
	#  wpl_channels: force number of channels in audio. XXX: OBSOLETE
	def load_uri(self, uri, properties={}):
		self.wpl.media.load(uri, properties)
		return None

	# THIS METHOD IS OBSOLETE!
	def load(self, path, scheme='file', properties=()):
		self.load_uri('%s://%s' % (scheme, path), dict([p.split('=') for p in properties]))
		return None

	# Play a media stream.
	# 
	# Same semantics as play(), except the URI must be properly encoded, including scheme, path and options.
	# "kwargs" semantics are the same as in play().
	def play_uri(self, uri):
		self.load_uri(uri)
		self.play_loaded()
		return None

	# Play a media stream.
	#
	# If a media stream was previously loaded or is still playing,
	# it is flushed and everything (playback stop + drivers close) is reinitialised before doing it.
	# 
	# An URI is generated from the scheme, path, and options arguments and
	# passed to the wyplayer daemon to play the file.
	#
	# "scheme" may be any URI scheme supported by libavformat or wyffmpeg
	# (eg. 'file', 'unix', 'chunk', 'rec', 'http', ...)
	#
	# "options" is a tuple containing options to be encoded in the URI.
	# eg. options=("ifmt=mpegts", "probe=0") is translated to "?ifmt=mpegts&probe=0" and is appended to the URI.
	#
	# "kwargs" may contain one or more boolean options to be passed for drivers initialization:
	#
	#  - adrv: select a different audio driver than the default one
	#  - vdrv: select a different video driver than the default one
	#  - audio: enable or disable audio playback
	#  - video: enable or disable video playback
	#  - subtitles: enable or disable subtitles playback
	#  - outwin: select output window placement, argument is a tuple (x,y,w,h) with normalized to 1 coordinates
	def play(self, path, scheme='file', options=(), **kwargs):
		self.load(path, scheme, options)
		self.play_loaded()
		return None

	def open(self, **kwargs):
		self.wpl.open(self._WyPlayer__get_drvs(**kwargs))
		return None

	def close(self):
		self.wpl.close()
		return None

	def play_loaded(self, start_pos=0.0, bytes=False):
		self.wpl.playback.play(start_pos, bytes)
		return None

	# Play MPEG Transport Stream from a wyffmpeg/wyrec rec:// URI.
	#
	# Implicit options are ("wyts=1", "probe=0", "norm_speed=1", "live=1")
	#
	# "kwargs" semantics are the same as in play().
	def play_rec(self, id, options=(), **kwargs):
		opts = ('wyts=1', 'probe=0', 'norm_speed=1', 'live=1') + options
		self.play(id, scheme='rec', options=opts, **kwargs)
		return None

	# stop playback.
	# 
	# If a media stream is currently playing, stop playback and cleanup all initialized drivers.
	# The stream will have to be reloaded (implying a loading delay!) to be played again using play().
	def stop(self):
		self.wpl.playback.stop()
		self.wpl.media.flush()
		return None

	# Jump in the currently playing stream.
	# 
	# Perform a jump of offset seconds relative to the current playing position.
	# "offset" may be negative for backward jumps.
	# If offset jumps to a position after the end of the playing stream, playback is directly stopped.
	# 
	# Note: This has no effect on streaming URIs such as "unix://" or "http://"
	def seek(self, offset):
		self.wpl.playback.seek(float(offset))
		return None

	# Return a list of video sub-streams present in the current media stream.
	# 
	# The list elements are dicts containing the following items:
	#
	#  - id: stream ID of the sub-stream
	#  - codec: libavcodec name of the sub-stream's codec
	#  - bitrate: bit rate in bits per second
	#  - width: picture width in pixels
	#  - height: picture height in pixels
	#  - framerate: number of frames per second
	def vlist(self):
		fields = ['id', 'codec', 'bitrate', 'width', 'height', 'framerate']
		return [dict(map(None, fields, s)) for s in self.wpl.media.vlist()]

	# Return a list of audio sub-streams present in the current media stream.
	# 
	# The list elements are dicts containing the following items:
	# 
	#  - id: stream ID of the sub-stream
	#  - codec: libavcodec name of the sub-stream's codec
	#  - bitrate: bit rate in bits per second
	#  - lang: ISO 639 language code
	#  - channels: number of channels (eg. 1 = mono, 2 = stereo, 6 = 5.1)
	#  - samplerate: audio sampling frequency in Hz (eg. 44100 for an audio CD)
	def alist(self):
		fields = ['id', 'codec', 'bitrate', 'lang', 'channels', 'samplerate']
		return [dict(map(None, fields, s)) for s in self.wpl.media.alist()]

	# Return a list of subtitles sub-streams present in the current media stream.
	# 
	# The list elements are dicts containing the following items:
	# 
	#  - id: stream ID of the sub-stream
	#  - codec: libavcodec name of the sub-stream's codec
	#  - lang: ISO 639 language code
	def slist(self):
		fields = ['id', 'codec', 'lang']
		return [dict(map(None, fields, s)) for s in self.wpl.media.slist()]

	# Find out if video stream is 'cinema' format, meaning the display
	# can be switched to 1080p@24hz for better viewing quality
	def is_cinema(self):
		for v in self.vlist():
			if v['width'] != 1920:
				continue
			elif v['framerate'] > 24 or v['framerate'] < 23:
				continue
			else:
				return True
		return False
