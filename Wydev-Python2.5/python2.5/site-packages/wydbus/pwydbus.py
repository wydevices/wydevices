# -*- coding: utf-8 -*- 
#
# Description:
#
# WyDBus Class Definitions
#
#
#
# Changes:
#
# 2011-10-20
# Initial Commit
#
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.


from _wydbus import *
from ctypes import py_object, c_char_p, c_void_p, c_int, Structure, CDLL
from ctypes import byref, pointer, POINTER, CFUNCTYPE
from time import sleep
import exceptions
import sys



libmarshal = CDLL(__file__[:__file__.rfind('/')] + '/_py_marshal.so')
pymarshal = wydbus_marshal_t.in_dll(libmarshal, 'python_marshal')


def _sigiter(elements, sig):
	sigiter = pointer(DBusSignatureIter())
	dbus_signature_iter_init(sigiter, sig)
	while True:
		t = dbus_signature_iter_get_current_type(sigiter)
		if t == DBUS_TYPE_INVALID:
			break
		elements.append(py_object)
		if dbus_signature_iter_next(sigiter) == 0:
			break


def _sig2func(rsig, asig):
	rtypes = []
	real_restype = None
	_sigiter(rtypes, rsig)
	try:
		restype = rtypes[0]
		if len(rtypes) > 1:
			print 'warning: method return signatures should have only one element!'
	except IndexError:
		restype = None
	argtypes = []
	_sigiter(argtypes, asig)
	return CFUNCTYPE(restype, *argtypes)



class WyDbusProxy(object):

	def __init__(self, proxy):
		self._proxy = proxy
		self.free = wydbus_free_proxy
		return None

	def __call__(self, *args):
		if not self._proxy:
			return None
		else:
			ret = self._proxy(*args)
			if isinstance(ret, type) and issubclass(ret, BaseException):
				raise ret(ret.__error__)
			return ret
		return None

	def __del__(self):
		if self._proxy != None and self.free != None:
			self.free(self._proxy)
		return None



class WyDbusReference(object):

	def __init__(self, parent, name, path, interface):
		self._ref = wydbus_reference2(parent._bus, name, path, interface)
		self._path = path
		return None

	def method(self, name, asig, rsig):
		px = _sig2func(rsig, asig)(_wydbus_proxy(self._ref, name, asig, rsig, pointer(pymarshal)))
		return WyDbusProxy(px)



class WyDbusInstance(object):

	def __init__(self, bus, path):
		self._obj = wydbus_instance(bus, path)
		self._handlers = {}
		self._path = path
		return None

	def _handler(self, name, asig, rsig, cb, flags, htype):
		ccb = _sig2func(rsig, asig)
		handler_t = type('%s_%s' % (rsig, asig), (Structure,), {})
		handler_t._fields_ = [('name', c_char_p), ('sig', c_char_p * 2), ('fn', ccb), ('data', c_void_p), ('flags', c_int), ('free', CFUNCTYPE(None, c_void_p)), ('m', POINTER(wydbus_marshal_t))]
		h = handler_t()
		h.name = name
		h.sig[0] = asig
		h.sig[1] = rsig
		h.fn = ccb(cb)
		h.flags = flags
		h.data = None
		h.m = pointer(pymarshal)
		wydbus_register_handler(self._obj, byref(h), None, htype)
		self._handlers[name] = h.fn
		return None

	def method(self, name, asig, rsig, cb, flags):
		self._handler(name, asig, rsig, cb, flags | WDB_FREE_ARGS, 0)
		return None

	def signal(self, name, asig, cb, flags):
		self._handler(name, asig, '', cb, flags, 1)
		return None



class WyDbusSingleton(type):

	def __init__(klass, name, bases, dikt):
		super(WyDbusSingleton, klass).__init__(name, bases, dikt)
		klass._s_instances_ = {}
		return None

	def __call__(klass, name='', *args, **kw):
		if not klass._s_instances_.has_key(name):
			klass._s_instances_[name] = super(WyDbusSingleton, klass).__call__(name, *args, **kw)
		return klass._s_instances_[name]



class WyDbus(object):

	__metaclass__ = WyDbusSingleton

	def __init__(self, name='', system=True):
		self.free = wydbus_free
		if system:
			type = DBUS_BUS_SYSTEM
		else:
			type = DBUS_BUS_SESSION
		self._bus = wydbus_new(type, name)
		wydbus_run(self._bus)
		if not self._bus:
			raise OSError('unable to get a dbus connection')
		return None

	def reference(self, name, path, interface=None):
		return WyDbusReference(self, name, path, interface)

	def instance(self, path):
		return WyDbusInstance(self._bus, path)

	def signal(self, path, name, sig, interface='com.wyplay.XXX_USE_WYDBUS_SIGNAL_PROPERLY'):
		px = _sig2func('', sig)(_wydbus_proxy(self._bus, path, name, sig, pointer(pymarshal), interface))
		return WyDbusProxy(px)

	def __del__(self):
		self.free(self._bus)
		return None



WyDBus = WyDbus
