# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 6
n 6(None)[]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75f8e8c>}
nname: 0
n 0(None)[self.player = player
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75ff80c>}
nname: 246
n 246(None)[]:
	i: 170(), 215()
	o: 

nname: 215
n 215(None)[log.debug("Can't perform event %s : %r is held" % (callback_name, self.player))
return True
]:
	i: 27(t)
	o: 246()

nname: 170
n 170(None)[EventDispatcher.led.on()
ret = callback(event)
EventDispatcher.led.off()
return ret
]:
	i: 71(), 129(), 168(AE)
	o: 246()

nname: 168
n 168(None)[]:
	i: 119(f)
	o: 170(AE)

nname: 129
n 129(None)[log.debug('event not catched by %s, calling default event.' % self.__class__.__name__)
callback = self.event_DEFAULT
]:
	i: 119(t)
	o: 170()

nname: 119
n 119(<dummy_ex3> EXC_MATCH AttributeError)[]:
	i: 67(except)
	o: 129(t), 168(f)

nname: 71
n 71(None)[log.debug(('[ %s received ]' % callback_name).center(60, '#'))
callback = getattr(self, callback_name)
]:
	i: 67(try)
	o: 170()

nname: 67
n 67(None)[]:
	i: 27(f)
	o: 71(try), 119(except)

nname: 27
n 27(self.player.hold)[event_short_name = str(event).lower()
callback_name = 'event_' + event_short_name
]:
	i: 9(), 26()
	o: 67(f), 215(t)

nname: 26
n 26(None)[]:
	i: 0(f)
	o: 27()

nname: 9
n 9(None)[EventDispatcher._disable_next_input = False
return True
]:
	i: 0(t)
	o: 27()

nname: 0
n 0(EventDispatcher._disable_next_input)[]:
	i: 
	o: 9(t), 26(f)

nname: 246
n 246(None)[]:
	i: 119(), 215()
	o: 

nname: 215
n 215(None)[log.debug("Can't perform event %s : %r is held" % (callback_name, self.player))
return True
]:
	i: 0(t)
	o: 246()

nname: 119
n 119(None)[except AttributeError:
	log.debug('event not catched by %s, calling default event.' % self.__class__.__name__)
	callback = self.event_DEFAULT
EventDispatcher.led.on()
ret = callback(event)
EventDispatcher.led.off()
return ret
]:
	i: 67()
	o: 246()

nname: 67
n 67(None)[try:
	log.debug(('[ %s received ]' % callback_name).center(60, '#'))
	callback = getattr(self, callback_name)
]:
	i: 0(f)
	o: 119()

nname: 0
n 0(self.player.hold)[if EventDispatcher._disable_next_input:
	EventDispatcher._disable_next_input = False
	return True
event_short_name = str(event).lower()
callback_name = 'event_' + event_short_name
]:
	i: 
	o: 67(f), 215(t)

nname: 246
n 246(None)[]:
	i: 67(), 215()
	o: 

nname: 215
n 215(None)[log.debug("Can't perform event %s : %r is held" % (callback_name, self.player))
return True
]:
	i: 0(t)
	o: 246()

nname: 67
n 67(None)[try:
	log.debug(('[ %s received ]' % callback_name).center(60, '#'))
	callback = getattr(self, callback_name)
except AttributeError:
	log.debug('event not catched by %s, calling default event.' % self.__class__.__name__)
	callback = self.event_DEFAULT
EventDispatcher.led.on()
ret = callback(event)
EventDispatcher.led.off()
return ret
]:
	i: 0(f)
	o: 246()

nname: 0
n 0(self.player.hold)[if EventDispatcher._disable_next_input:
	EventDispatcher._disable_next_input = False
	return True
event_short_name = str(event).lower()
callback_name = 'event_' + event_short_name
]:
	i: 
	o: 67(f), 215(t)

nname: 0
n 0(None)[if EventDispatcher._disable_next_input:
	EventDispatcher._disable_next_input = False
	return True
event_short_name = str(event).lower()
callback_name = 'event_' + event_short_name
if not self.player.hold:
	try:
		log.debug(('[ %s received ]' % callback_name).center(60, '#'))
		callback = getattr(self, callback_name)
	except AttributeError:
		log.debug('event not catched by %s, calling default event.' % self.__class__.__name__)
		callback = self.event_DEFAULT
	EventDispatcher.led.on()
	ret = callback(event)
	EventDispatcher.led.off()
	return ret
else:
	log.debug("Can't perform event %s : %r is held" % (callback_name, self.player))
	return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb760df8c>}
nname: 0
n 0(None)[log.debug('Unknown Event: "%s"', str(event))
return False
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75ffa8c>}
nname: 135
n 135(None)[return True
]:
	i: 100(JA), 121(), 124()
	o: 

nname: 124
n 124(None)[ms.back_to_home()
]:
	i: 0(f)
	o: 135()

nname: 121
n 121(None)[]:
	i: 86(JA), 104()
	o: 135()

nname: 104
n 104(None)[HomeMenu().show(False)
]:
	i: 25(f)
	o: 121()

nname: 100
n 100(None)[]:
	i: 64(f)
	o: 135(JA)

nname: 86
n 86(None)[ms.back_one_menu()
]:
	i: 64(t)
	o: 121(JA)

nname: 64
n 64(len(ms.menus_stack) > 2)[]:
	i: 25(t)
	o: 86(t), 100(f)

nname: 25
n 25(ms.menus_stack[-1].type == 'switcher')[from pygui.menu.menu.home import HomeMenu
]:
	i: 0(t)
	o: 64(t), 104(f)

nname: 0
n 0('universe_switcher' in config.plugins)[ms = pygui_globs['menustack']
]:
	i: 
	o: 25(t), 124(f)

nname: 135
n 135(None)[return True
]:
	i: 124(), 64(f), 86(JA), 104()
	o: 

nname: 124
n 124(None)[ms.back_to_home()
]:
	i: 0(f)
	o: 135()

nname: 104
n 104(None)[HomeMenu().show(False)
]:
	i: 25(f)
	o: 135()

nname: 86
n 86(None)[ms.back_one_menu()
]:
	i: 64(t)
	o: 135(JA)

nname: 64
n 64(len(ms.menus_stack) > 2)[]:
	i: 25(t)
	o: 86(t), 135(f)

nname: 25
n 25(ms.menus_stack[-1].type == 'switcher')[from pygui.menu.menu.home import HomeMenu
]:
	i: 0(t)
	o: 64(t), 104(f)

nname: 0
n 0('universe_switcher' in config.plugins)[ms = pygui_globs['menustack']
]:
	i: 
	o: 25(t), 124(f)

nname: 0
n 0(None)[ms = pygui_globs['menustack']
if 'universe_switcher' in config.plugins:
	from pygui.menu.menu.home import HomeMenu
	if ms.menus_stack[-1].type == 'switcher':
		if len(ms.menus_stack) > 2:
			ms.back_one_menu()
	else:
		HomeMenu().show(False)
else:
	ms.back_to_home()
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb760d2ec>}
nname: 6
n 6(None)[__doc__ = "Event dispatcher. This is the base class for all event managers.\n\n    Handlers should implement event_<event name> methods.\n    The only parameter to an event_* method is the event itself,\n    other objects should be passed to L{__init__} and stored.\n\n    If the event_* method, specific to an event type, can't be found,\n    L{event_DEFAULT} is called instead.\n\n    If an event_* method returns True or None, the event is consumed and\n    its processing is halted.\n\n    If it returns False, the event will also be processed by handlers\n    below in the stack.\n\n    returning None is a bad idea ! returns True instead\n    "
led = WyLed()
power_mgr = None
_disable_next_input = False
def __init__(self, player):
	self.player = player

def __call__(self, event):
	if EventDispatcher._disable_next_input:
		EventDispatcher._disable_next_input = False
		return True
	event_short_name = str(event).lower()
	callback_name = 'event_' + event_short_name
	if not self.player.hold:
		try:
			log.debug(('[ %s received ]' % callback_name).center(60, '#'))
			callback = getattr(self, callback_name)
		except AttributeError:
			log.debug('event not catched by %s, calling default event.' % self.__class__.__name__)
			callback = self.event_DEFAULT
		EventDispatcher.led.on()
		ret = callback(event)
		EventDispatcher.led.off()
		return ret
	else:
		log.debug("Can't perform event %s : %r is held" % (callback_name, self.player))
		return True

def event_DEFAULT(self, event):
	log.debug('Unknown Event: "%s"', str(event))
	return False

def event_home(self, event):
	ms = pygui_globs['menustack']
	if 'universe_switcher' in config.plugins:
		from pygui.menu.menu.home import HomeMenu
		if ms.menus_stack[-1].type == 'switcher':
			if len(ms.menus_stack) > 2:
				ms.back_one_menu()
		else:
			HomeMenu().show(False)
	else:
		ms.back_to_home()
	return True

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75ff52c>}
nname: 0
n 0(None)[return False
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb760d42c>}
nname: 6
n 6(None)[__doc__ = 'Event handler that lets all events pass through.'
def event_DEFAULT(self, event):
	return False

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75f8dac>}
nname: 0
n 0(None)[return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb760d26c>}
nname: 6
n 6(None)[__doc__ = 'Event handler that blocks all events.'
def event_DEFAULT(self, event):
	return True

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75f8dac>}
nname: 0
n 0(None)[from __future__ import absolute_import
__all__ = ['EventDispatcher', 'UnknownEventError', 'NullEventHandler']
from pygui import config
from peewee.debug import GET_LOGGER, DEBUG
from pygui.shared import pygui_globs
from .events import events as event_map
from pygui.facilities.wylight import WyLed
log = GET_LOGGER(__name__)
class UnknownEventError(Exception):
	pass

class EventDispatcher(object):
	__doc__ = "Event dispatcher. This is the base class for all event managers.\n\n    Handlers should implement event_<event name> methods.\n    The only parameter to an event_* method is the event itself,\n    other objects should be passed to L{__init__} and stored.\n\n    If the event_* method, specific to an event type, can't be found,\n    L{event_DEFAULT} is called instead.\n\n    If an event_* method returns True or None, the event is consumed and\n    its processing is halted.\n\n    If it returns False, the event will also be processed by handlers\n    below in the stack.\n\n    returning None is a bad idea ! returns True instead\n    "
	led = WyLed()
	power_mgr = None
	_disable_next_input = False
	def __init__(self, player):
		self.player = player

	def __call__(self, event):
		if EventDispatcher._disable_next_input:
			EventDispatcher._disable_next_input = False
			return True
		event_short_name = str(event).lower()
		callback_name = 'event_' + event_short_name
		if not self.player.hold:
			try:
				log.debug(('[ %s received ]' % callback_name).center(60, '#'))
				callback = getattr(self, callback_name)
			except AttributeError:
				log.debug('event not catched by %s, calling default event.' % self.__class__.__name__)
				callback = self.event_DEFAULT
			EventDispatcher.led.on()
			ret = callback(event)
			EventDispatcher.led.off()
			return ret
		else:
			log.debug("Can't perform event %s : %r is held" % (callback_name, self.player))
			return True

	def event_DEFAULT(self, event):
		log.debug('Unknown Event: "%s"', str(event))
		return False

	def event_home(self, event):
		ms = pygui_globs['menustack']
		if 'universe_switcher' in config.plugins:
			from pygui.menu.menu.home import HomeMenu
			if ms.menus_stack[-1].type == 'switcher':
				if len(ms.menus_stack) > 2:
					ms.back_one_menu()
			else:
				HomeMenu().show(False)
		else:
			ms.back_to_home()
		return True



class NullEventHandler(EventDispatcher):
	__doc__ = 'Event handler that lets all events pass through.'
	def event_DEFAULT(self, event):
		return False



class CatchEventHandler(EventDispatcher):
	__doc__ = 'Event handler that blocks all events.'
	def event_DEFAULT(self, event):
		return True



]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75f1f6c>}
from __future__ import absolute_import
__all__ = ['EventDispatcher', 'UnknownEventError', 'NullEventHandler']
from pygui import config
from peewee.debug import GET_LOGGER, DEBUG
from pygui.shared import pygui_globs
from .events import events as event_map
from pygui.facilities.wylight import WyLed
log = GET_LOGGER(__name__)
class UnknownEventError(Exception):
	pass

class EventDispatcher(object):
	__doc__ = "Event dispatcher. This is the base class for all event managers.\n\n    Handlers should implement event_<event name> methods.\n    The only parameter to an event_* method is the event itself,\n    other objects should be passed to L{__init__} and stored.\n\n    If the event_* method, specific to an event type, can't be found,\n    L{event_DEFAULT} is called instead.\n\n    If an event_* method returns True or None, the event is consumed and\n    its processing is halted.\n\n    If it returns False, the event will also be processed by handlers\n    below in the stack.\n\n    returning None is a bad idea ! returns True instead\n    "
	led = WyLed()
	power_mgr = None
	_disable_next_input = False
	def __init__(self, player):
		self.player = player

	def __call__(self, event):
		if EventDispatcher._disable_next_input:
			EventDispatcher._disable_next_input = False
			return True
		event_short_name = str(event).lower()
		callback_name = 'event_' + event_short_name
		if not self.player.hold:
			try:
				log.debug(('[ %s received ]' % callback_name).center(60, '#'))
				callback = getattr(self, callback_name)
			except AttributeError:
				log.debug('event not catched by %s, calling default event.' % self.__class__.__name__)
				callback = self.event_DEFAULT
			EventDispatcher.led.on()
			ret = callback(event)
			EventDispatcher.led.off()
			return ret
		else:
			log.debug("Can't perform event %s : %r is held" % (callback_name, self.player))
			return True

	def event_DEFAULT(self, event):
		log.debug('Unknown Event: "%s"', str(event))
		return False

	def event_home(self, event):
		ms = pygui_globs['menustack']
		if 'universe_switcher' in config.plugins:
			from pygui.menu.menu.home import HomeMenu
			if ms.menus_stack[-1].type == 'switcher':
				if len(ms.menus_stack) > 2:
					ms.back_one_menu()
			else:
				HomeMenu().show(False)
		else:
			ms.back_to_home()
		return True



class NullEventHandler(EventDispatcher):
	__doc__ = 'Event handler that lets all events pass through.'
	def event_DEFAULT(self, event):
		return False



class CatchEventHandler(EventDispatcher):
	__doc__ = 'Event handler that blocks all events.'
	def event_DEFAULT(self, event):
		return True



