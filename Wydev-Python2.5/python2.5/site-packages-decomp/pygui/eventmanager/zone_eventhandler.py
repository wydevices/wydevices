# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 0
n 0(None)[self._handler = handler
self._zone = zone
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb759298c>}
nname: 0
n 0(None)[self._handler(self._zone)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7592aec>}
nname: 6
n 6(None)[__slots__ = ('_handler', '_zone')
def __init__(self, handler, zone):
	self._handler = handler
	self._zone = zone

def __call__(self):
	self._handler(self._zone)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75924ec>}
nname: 291
n 291(None)[del _[2]
for self.zones in xzones:
return None
]:
	i: 198(AF), 284()
	o: 

nname: 284
n 284(None)[del _[3]
]:
	i: 221(AF), 250()
	o: 291()

nname: 250
n 250(None)[]:
	i: 221(for)
	o: 284()

nname: 221
n 221(None)[]:
	i: 198(for)
	o: 250(for), 284(AF)

nname: 198
n 198(None)[del _[1]
for self._handlers in xzones:
]:
	i: 0(AF), 172()
	o: 221(for), 291(AF)

nname: 172
n 172(None)[for e in xzones:
]:
	i: 0(for)
	o: 198()

nname: 0
n 0(None)[seps = [0] + list(xseps) + [100]
xzones = tuple(<genexpr>(xrange(len(seps) - 1)))
self._xzones = xzones
seps = [0] + list(yseps) + [100]
yzones = tuple(<genexpr>(xrange(len(seps) - 1)))
self._yzones = yzones
]:
	i: 
	o: 172(for), 198(AF)

nname: 291
n 291(None)[del _[2]
for self.zones in xzones:
return None
]:
	i: 198(AF), 284()
	o: 

nname: 284
n 284(None)[del _[3]
]:
	i: 221(AF), 221(for)
	o: 291()

nname: 221
n 221(None)[]:
	i: 198(for)
	o: 284(AF)

nname: 198
n 198(None)[del _[1]
for self._handlers in xzones:
]:
	i: 0(AF), 172()
	o: 221(for), 291(AF)

nname: 172
n 172(None)[for e in xzones:
]:
	i: 0(for)
	o: 198()

nname: 0
n 0(None)[seps = [0] + list(xseps) + [100]
xzones = tuple(<genexpr>(xrange(len(seps) - 1)))
self._xzones = xzones
seps = [0] + list(yseps) + [100]
yzones = tuple(<genexpr>(xrange(len(seps) - 1)))
self._yzones = yzones
]:
	i: 
	o: 172(for), 198(AF)

nname: 291
n 291(None)[del _[2]
for self.zones in xzones:
return None
]:
	i: 198(AF), 284()
	o: 

nname: 284
n 284(None)[del _[3]
]:
	i: 221(for), 198(for)
	o: 291()

nname: 198
n 198(None)[del _[1]
for self._handlers in xzones:
]:
	i: 0(AF), 172()
	o: 284(for), 291(AF)

nname: 172
n 172(None)[for e in xzones:
]:
	i: 0(for)
	o: 198()

nname: 0
n 0(None)[seps = [0] + list(xseps) + [100]
xzones = tuple(<genexpr>(xrange(len(seps) - 1)))
self._xzones = xzones
seps = [0] + list(yseps) + [100]
yzones = tuple(<genexpr>(xrange(len(seps) - 1)))
self._yzones = yzones
]:
	i: 
	o: 172(for), 198(AF)

self.nodes: {0: <unpyclib.structure.node instance at 0xb7596bcc>, 291: <unpyclib.structure.node instance at 0xb7596e4c>, 198: <unpyclib.structure.node instance at 0xb7596c4c>, 172: <unpyclib.structure.node instance at 0xb7596c0c>, 284: <unpyclib.structure.node instance at 0xb7596dcc>}
nname: 73
n 73(None)[del _[1]
for self._handlers[column][line] in handlers:
return None
]:
	i: 34(AF), 51()
	o: 

nname: 51
n 51(None)[for handler in handlers:
]:
	i: 34(for)
	o: 73()

nname: 34
n 34(None)[zone = self.zones[column][line]
]:
	i: 12(), 19()
	o: 51(for), 73(AF)

nname: 19
n 19(None)[]:
	i: 0(f)
	o: 34()

nname: 12
n 12(None)[]:
	i: 0(t)
	o: 34()

nname: 0
n 0(zone is not None)[]:
	i: 
	o: 12(t), 19(f)

nname: 73
n 73(None)[del _[1]
for self._handlers[column][line] in handlers:
return None
]:
	i: 0(AF), 51()
	o: 

nname: 51
n 51(None)[for handler in handlers:
]:
	i: 0(for)
	o: 73()

nname: 0
n 0(None)[if zone is not None:
	pass
zone = self.zones[column][line]
]:
	i: 
	o: 51(for), 73(AF)

self.nodes: {0: <unpyclib.structure.node instance at 0xb759626c>, 73: <unpyclib.structure.node instance at 0xb759632c>, 51: <unpyclib.structure.node instance at 0xb75962ec>}
nname: 237
n 237(None)[return False
]:
	i: 0(AL), 236()
	o: 

nname: 236
n 236(None)[]:
	i: 41(AF), 233()
	o: 237()

nname: 233
n 233(None)[]:
	i: 75(AL), 232()
	o: 236()

nname: 232
n 232(None)[]:
	i: 51(f), 228()
	o: 233()

nname: 228
n 228(None)[continue
]:
	i: 79(AF), 224()
	o: 232()

nname: 224
n 224(None)[]:
	i: 86(f), 217()
	o: 228()

nname: 217
n 217(None)[return True
continue
]:
	i: 205(), 216()
	o: 224()

nname: 216
n 216(None)[]:
	i: 193(f)
	o: 217()

nname: 205
n 205(None)[handler()
]:
	i: 193(t)
	o: 217()

nname: 193
n 193(handler is not None)[]:
	i: 126(), 167(), 192()
	o: 205(t), 216(f)

nname: 192
n 192(None)[]:
	i: 151(f)
	o: 193()

nname: 167
n 167(None)[handler = self._handlers[column][line][1]
]:
	i: 151(t)
	o: 193()

nname: 151
n 151(event.name == 'BUTTON0')[]:
	i: 110(f)
	o: 167(t), 192(f)

nname: 126
n 126(None)[handler = self._handlers[column][line][0]
]:
	i: 110(t)
	o: 193()

nname: 110
n 110(event.name == 'MOUSE')[]:
	i: 86(t)
	o: 126(t), 151(f)

nname: 86
n 86(y < ymax)[for line, ymin, ymax in yzones:
]:
	i: 79(for)
	o: 110(t), 224(f)

nname: 79
n 79(None)[]:
	i: 75(loop)
	o: 86(for), 228(AF)

nname: 75
n 75(None)[]:
	i: 51(t)
	o: 79(loop), 233(AL)

nname: 51
n 51(x < xmax)[for column, xmin, xmax in self._xzones:
]:
	i: 41(for)
	o: 75(t), 232(f)

nname: 41
n 41(None)[]:
	i: 0(loop)
	o: 51(for), 236(AF)

nname: 0
n 0(None)[arg = event.arg
x = arg['x']
y = arg['y']
yzones = self._yzones
]:
	i: 
	o: 41(loop), 237(AL)

nname: 237
n 237(None)[return False
]:
	i: 0(AL), 41(AF), 75(AL), 51(f), 228()
	o: 

nname: 228
n 228(None)[continue
]:
	i: 79(AF), 86(f), 217()
	o: 237()

nname: 217
n 217(None)[return True
continue
]:
	i: 110()
	o: 228()

nname: 110
n 110(None)[if event.name == 'MOUSE':
	handler = self._handlers[column][line][0]
else:
	if event.name == 'BUTTON0':
		handler = self._handlers[column][line][1]
if handler is not None:
	handler()
]:
	i: 86(t)
	o: 217()

nname: 86
n 86(y < ymax)[for line, ymin, ymax in yzones:
]:
	i: 79(for)
	o: 110(t), 228(f)

nname: 79
n 79(None)[]:
	i: 75(loop)
	o: 86(for), 228(AF)

nname: 75
n 75(None)[]:
	i: 51(t)
	o: 79(loop), 237(AL)

nname: 51
n 51(x < xmax)[for column, xmin, xmax in self._xzones:
]:
	i: 41(for)
	o: 75(t), 237(f)

nname: 41
n 41(None)[]:
	i: 0(loop)
	o: 51(for), 237(AF)

nname: 0
n 0(None)[arg = event.arg
x = arg['x']
y = arg['y']
yzones = self._yzones
]:
	i: 
	o: 41(loop), 237(AL)

nname: 237
n 237(None)[return False
]:
	i: 0(AL), 41(AF), 75(AL), 51(f), 228()
	o: 

nname: 228
n 228(None)[continue
]:
	i: 79(AF), 86(f), 110()
	o: 237()

nname: 110
n 110(None)[if event.name == 'MOUSE':
	handler = self._handlers[column][line][0]
else:
	if event.name == 'BUTTON0':
		handler = self._handlers[column][line][1]
if handler is not None:
	handler()
return True
continue
]:
	i: 86(t)
	o: 228()

nname: 86
n 86(y < ymax)[for line, ymin, ymax in yzones:
]:
	i: 79(for)
	o: 110(t), 228(f)

nname: 79
n 79(None)[]:
	i: 75(loop)
	o: 86(for), 228(AF)

nname: 75
n 75(None)[]:
	i: 51(t)
	o: 79(loop), 237(AL)

nname: 51
n 51(x < xmax)[for column, xmin, xmax in self._xzones:
]:
	i: 41(for)
	o: 75(t), 237(f)

nname: 41
n 41(None)[]:
	i: 0(loop)
	o: 51(for), 237(AF)

nname: 0
n 0(None)[arg = event.arg
x = arg['x']
y = arg['y']
yzones = self._yzones
]:
	i: 
	o: 41(loop), 237(AL)

nname: 237
n 237(None)[return False
]:
	i: 0(AL), 41(AF), 51(f), 86()
	o: 

nname: 86
n 86(None)[for line, ymin, ymax in yzones:
	if y < ymax:
		if event.name == 'MOUSE':
			handler = self._handlers[column][line][0]
		else:
			if event.name == 'BUTTON0':
				handler = self._handlers[column][line][1]
		if handler is not None:
			handler()
		return True
		continue
else:
	continue
]:
	i: 75(for)
	o: 237()

nname: 75
n 75(None)[]:
	i: 51(t)
	o: 86(for)

nname: 51
n 51(x < xmax)[for column, xmin, xmax in self._xzones:
]:
	i: 41(for)
	o: 75(t), 237(f)

nname: 41
n 41(None)[]:
	i: 0(loop)
	o: 51(for), 237(AF)

nname: 0
n 0(None)[arg = event.arg
x = arg['x']
y = arg['y']
yzones = self._yzones
]:
	i: 
	o: 41(loop), 237(AL)

nname: 237
n 237(None)[return False
]:
	i: 0(AL), 41(AF), 51(f), 75()
	o: 

nname: 75
n 75(None)[for line, ymin, ymax in yzones:
	if y < ymax:
		if event.name == 'MOUSE':
			handler = self._handlers[column][line][0]
		else:
			if event.name == 'BUTTON0':
				handler = self._handlers[column][line][1]
		if handler is not None:
			handler()
		return True
		continue
else:
	continue
]:
	i: 51(t)
	o: 237()

nname: 51
n 51(x < xmax)[for column, xmin, xmax in self._xzones:
]:
	i: 41(for)
	o: 75(t), 237(f)

nname: 41
n 41(None)[]:
	i: 0(loop)
	o: 51(for), 237(AF)

nname: 0
n 0(None)[arg = event.arg
x = arg['x']
y = arg['y']
yzones = self._yzones
]:
	i: 
	o: 41(loop), 237(AL)

nname: 51
n 51(None)[for column, xmin, xmax in self._xzones:
	if x < xmax:
		for line, ymin, ymax in yzones:
			if y < ymax:
				if event.name == 'MOUSE':
					handler = self._handlers[column][line][0]
				else:
					if event.name == 'BUTTON0':
						handler = self._handlers[column][line][1]
				if handler is not None:
					handler()
				return True
				continue
		else:
			continue
return False
]:
	i: 0(for)
	o: 

nname: 0
n 0(None)[arg = event.arg
x = arg['x']
y = arg['y']
yzones = self._yzones
]:
	i: 
	o: 51(for)

nname: 0
n 0(None)[arg = event.arg
x = arg['x']
y = arg['y']
yzones = self._yzones
for column, xmin, xmax in self._xzones:
	if x < xmax:
		for line, ymin, ymax in yzones:
			if y < ymax:
				if event.name == 'MOUSE':
					handler = self._handlers[column][line][0]
				else:
					if event.name == 'BUTTON0':
						handler = self._handlers[column][line][1]
				if handler is not None:
					handler()
				return True
				continue
		else:
			continue
return False
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75990ec>}
nname: 24
n 24(None)[self.handle_button1()
return True
]:
	i: 15(), 23()
	o: 

nname: 23
n 23(None)[]:
	i: 0(t)
	o: 24()

nname: 15
n 15(None)[return False
]:
	i: 0(f)
	o: 24()

nname: 0
n 0(hasattr(self, 'handle_button1'))[]:
	i: 
	o: 15(f), 23(t)

nname: 0
n 0(None)[if not hasattr(self, 'handle_button1'):
	return False
self.handle_button1()
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7592f4c>}
nname: 6
n 6(None)[__doc__ = ' Manage a set of handlers of zones.\n    A zone is a tuple (xmin , xmax, ymin, ymax), ie an axis-aligned bounding\n    box (AABB). Coordinates are between 0 and 100.\n    '
def __init__(self, xseps=(20, 80), yseps=(20, 80)):
	seps = [0] + list(xseps) + [100]
	xzones = tuple(<genexpr>(xrange(len(seps) - 1)))
	self._xzones = xzones
	seps = [0] + list(yseps) + [100]
	yzones = tuple(<genexpr>(xrange(len(seps) - 1)))
	self._yzones = yzones

def set_handler(self, column, line, handlers, zone=None):
	if zone is not None:
		pass
	zone = self.zones[column][line]

def _manage_event(self, event):
	arg = event.arg
	x = arg['x']
	y = arg['y']
	yzones = self._yzones
	for column, xmin, xmax in self._xzones:
		if x < xmax:
			for line, ymin, ymax in yzones:
				if y < ymax:
					if event.name == 'MOUSE':
						handler = self._handlers[column][line][0]
					else:
						if event.name == 'BUTTON0':
							handler = self._handlers[column][line][1]
					if handler is not None:
						handler()
					return True
					continue
			else:
				continue
	return False

def event_button1(self, event):
	if not hasattr(self, 'handle_button1'):
		return False
	self.handle_button1()
	return True

event_mouse = _manage_event
event_button0 = _manage_event
]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb7592b8c>}
nname: 0
n 0(None)[return 100 * (x - x0) / (x1 - x0)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb759224c>}
nname: 0
n 0(None)[return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb759204c>}
nname: 0
n 0(None)[return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb759c96c>}
nname: 0
n 0(None)[return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb759ca6c>}
nname: 0
n 0(None)[return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb759cecc>}
nname: 0
n 0(None)[return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb759c44c>}
nname: 0
n 0(None)[return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb759c18c>}
nname: 0
n 0(None)[return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb759c96c>}
nname: 0
n 0(None)[return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb759ca6c>}
nname: 0
n 0(None)[return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb759cecc>}
nname: 0
n 0(None)[return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb759c44c>}
nname: 0
n 0(None)[return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb759c18c>}
nname: 32
n 32(None)[self._zone = (0, 0, 0, 0)
self._margin = margin
self._pick_on_click = pick_on_click
self._button0_task = Task((lambda : None))
self._button1_task = Task((lambda : None))
self._button2_task = Task((lambda : None))
self._button3_task = Task((lambda : None))
self._button4_task = Task((lambda : None))
self.handle_click = do_nothing
self.handle_pressed = do_nothing
self.handle_long_click = do_nothing
return None
]:
	i: 21(), 28()
	o: 

nname: 28
n 28(None)[]:
	i: 0(f)
	o: 32()

nname: 21
n 21(None)[]:
	i: 0(t)
	o: 32()

nname: 0
n 0(zone is not None)[self.player = player
]:
	i: 
	o: 21(t), 28(f)

nname: 0
n 0(None)[self.player = player
if zone is not None:
	pass
self._zone = (0, 0, 0, 0)
self._margin = margin
self._pick_on_click = pick_on_click
self._button0_task = Task((lambda : None))
self._button1_task = Task((lambda : None))
self._button2_task = Task((lambda : None))
self._button3_task = Task((lambda : None))
self._button4_task = Task((lambda : None))
self.handle_click = do_nothing
self.handle_pressed = do_nothing
self.handle_long_click = do_nothing
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb759c78c>}
nname: 160
n 160(None)[return ret
]:
	i: 146(), 159()
	o: 

nname: 159
n 159(None)[]:
	i: 0(f)
	o: 160()

nname: 146
n 146(None)[handler(arg)
]:
	i: 60(), 145()
	o: 160()

nname: 145
n 145(None)[]:
	i: 53(f)
	o: 146()

nname: 60
n 60(None)[zone = self._zone
arg[xkey] = min(zone[1], max(zone[0], x))
arg[ykey] = min(zone[3], max(zone[2], y))
]:
	i: 53(t)
	o: 146()

nname: 53
n 53(remap_coord)[]:
	i: 0(t)
	o: 60(t), 145(f)

nname: 0
n 0(ret)[arg = event.arg
x = arg[xkey]
y = arg[ykey]
ret = self._in_zone(x, y)
]:
	i: 
	o: 53(t), 159(f)

nname: 160
n 160(None)[return ret
]:
	i: 53(), 0(f)
	o: 

nname: 53
n 53(None)[if remap_coord:
	zone = self._zone
	arg[xkey] = min(zone[1], max(zone[0], x))
	arg[ykey] = min(zone[3], max(zone[2], y))
handler(arg)
]:
	i: 0(t)
	o: 160()

nname: 0
n 0(ret)[arg = event.arg
x = arg[xkey]
y = arg[ykey]
ret = self._in_zone(x, y)
]:
	i: 
	o: 53(t), 160(f)

nname: 0
n 0(None)[arg = event.arg
x = arg[xkey]
y = arg[ykey]
ret = self._in_zone(x, y)
if ret:
	if remap_coord:
		zone = self._zone
		arg[xkey] = min(zone[1], max(zone[0], x))
		arg[ykey] = min(zone[3], max(zone[2], y))
	handler(arg)
return ret
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb759c80c>}
nname: 106
n 106(None)[return zone[0] - margin <= x
]:
	i: 60(f), 86(), 104()
	o: 

nname: 104
n 104(None)[y
]:
	i: 63(f)
	o: 106()

nname: 86
n 86(None)[]:
	i: 63(t)
	o: 106()

nname: 63
n 63(zone[2] - margin <= y)[]:
	i: 60(t)
	o: 86(t), 104(f)

nname: 60
n 60(zone[0] - margin <= x)[]:
	i: 40(), 58()
	o: 63(t), 106(f)

nname: 58
n 58(None)[x
]:
	i: 0(f)
	o: 60()

nname: 40
n 40(None)[]:
	i: 0(t)
	o: 60()

nname: 0
n 0(zone[0] - margin <= x)[zone = self._zone
margin = self._margin
]:
	i: 
	o: 40(t), 58(f)

nname: 106
n 106(None)[return zone[0] - margin <= x
]:
	i: 0(f)
	o: 

nname: 0
n 0(None)[zone = self._zone
margin = self._margin
if zone[0] - margin <= x:
	pass
else:
	x
if zone[0] - margin <= x:
	if zone[2] - margin <= y:
		pass
	else:
		y
]:
	i: 
	o: 106()

nname: 0
n 0(None)[zone = self._zone
margin = self._margin
if zone[0] - margin <= x:
	pass
else:
	x
if zone[0] - margin <= x:
	if zone[2] - margin <= y:
		pass
	else:
		y
return zone[0] - margin <= x
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7599a2c>}
nname: 65
n 65(None)[]:
	i: 12(), 44()
	o: 

nname: 44
n 44(None)[log.warn('%s Dropped because button0 task is running', event)
return True
]:
	i: 0(t)
	o: 65()

nname: 12
n 12(None)[return self._check_zone(event, self._manage_mouse, 'x', 'y', True)
]:
	i: 0(f)
	o: 65()

nname: 0
n 0(self._button0_task.running)[]:
	i: 
	o: 12(f), 44(t)

nname: 0
n 0(None)[if not self._button0_task.running:
	return self._check_zone(event, self._manage_mouse, 'x', 'y', True)
else:
	log.warn('%s Dropped because button0 task is running', event)
	return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb759920c>}
nname: 0
n 0(None)[return self._check_zone(event, self._manage_button0, 'start_x', 'start_y', False)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7599d8c>}
nname: 24
n 24(None)[self._manage_button1(event.arg)
return True
]:
	i: 15(), 23()
	o: 

nname: 23
n 23(None)[]:
	i: 0(t)
	o: 24()

nname: 15
n 15(None)[return False
]:
	i: 0(f)
	o: 24()

nname: 0
n 0(hasattr(self, 'handle_button1'))[]:
	i: 
	o: 15(f), 23(t)

nname: 0
n 0(None)[if not hasattr(self, 'handle_button1'):
	return False
self._manage_button1(event.arg)
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75997ec>}
nname: 24
n 24(None)[self._manage_button2(event.arg)
return True
]:
	i: 15(), 23()
	o: 

nname: 23
n 23(None)[]:
	i: 0(t)
	o: 24()

nname: 15
n 15(None)[return False
]:
	i: 0(f)
	o: 24()

nname: 0
n 0(hasattr(self, 'handle_button2'))[]:
	i: 
	o: 15(f), 23(t)

nname: 0
n 0(None)[if not hasattr(self, 'handle_button2'):
	return False
self._manage_button2(event.arg)
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75993ac>}
nname: 24
n 24(None)[self._manage_button3(event.arg)
return True
]:
	i: 15(), 23()
	o: 

nname: 23
n 23(None)[]:
	i: 0(t)
	o: 24()

nname: 15
n 15(None)[return False
]:
	i: 0(f)
	o: 24()

nname: 0
n 0(hasattr(self, 'handle_button3'))[]:
	i: 
	o: 15(f), 23(t)

nname: 0
n 0(None)[if not hasattr(self, 'handle_button3'):
	return False
self._manage_button3(event.arg)
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb759920c>}
nname: 24
n 24(None)[self._manage_button4(event.arg)
return True
]:
	i: 15(), 23()
	o: 

nname: 23
n 23(None)[]:
	i: 0(t)
	o: 24()

nname: 15
n 15(None)[return False
]:
	i: 0(f)
	o: 24()

nname: 0
n 0(hasattr(self, 'handle_button4'))[]:
	i: 
	o: 15(f), 23(t)

nname: 0
n 0(None)[if not hasattr(self, 'handle_button4'):
	return False
self._manage_button4(event.arg)
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7599a8c>}
nname: 200
n 200(None)[]:
	i: 124(), 162()
	o: 

nname: 162
n 162(None)[task.fn = self._manage_long_click
task.args = (event_arg,)
task.start(BUTTONS_CLICK_TIMEOUT)
]:
	i: 70&116(f)
	o: 200()

nname: 124
n 124(None)[task.fn = self.handle_click
task.args = ()
task.start(BUTTONS_CLICK_TIMEOUT)
]:
	i: 70&116(t)
	o: 200()

nname: 70&116
n 70&116(count < LONGCLIC_THRESHOLD and not move_detected)[task = self._button0_task
move_detected = self._check_button_move(event_arg)
self.handle_pressed()
]:
	i: 52(), 69()
	o: 124(t), 162(f)

nname: 69
n 69(None)[]:
	i: 43(f)
	o: 70&116()

nname: 52
n 52(None)[self._pick(event_arg)
]:
	i: 43(t)
	o: 70&116()

nname: 43
n 43(self._pick_on_click)[]:
	i: 22(), 42()
	o: 52(t), 69(f)

nname: 42
n 42(None)[]:
	i: 0(f)
	o: 43()

nname: 22
n 22(None)[self.player._autohide_timeout.start()
]:
	i: 0(t)
	o: 43()

nname: 0
n 0(self.player._autohide_timeout)[count = event_arg['count']
]:
	i: 
	o: 22(t), 42(f)

nname: 70&116
n 70&116(None)[task = self._button0_task
move_detected = self._check_button_move(event_arg)
self.handle_pressed()
if count < LONGCLIC_THRESHOLD and not move_detected:
	task.fn = self.handle_click
	task.args = ()
	task.start(BUTTONS_CLICK_TIMEOUT)
else:
	task.fn = self._manage_long_click
	task.args = (event_arg,)
	task.start(BUTTONS_CLICK_TIMEOUT)
]:
	i: 0()
	o: 

nname: 0
n 0(None)[count = event_arg['count']
if self.player._autohide_timeout:
	self.player._autohide_timeout.start()
if self._pick_on_click:
	self._pick(event_arg)
]:
	i: 
	o: 70&116()

nname: 0
n 0(None)[count = event_arg['count']
if self.player._autohide_timeout:
	self.player._autohide_timeout.start()
if self._pick_on_click:
	self._pick(event_arg)
task = self._button0_task
move_detected = self._check_button_move(event_arg)
self.handle_pressed()
if count < LONGCLIC_THRESHOLD and not move_detected:
	task.fn = self.handle_click
	task.args = ()
	task.start(BUTTONS_CLICK_TIMEOUT)
else:
	task.fn = self._manage_long_click
	task.args = (event_arg,)
	task.start(BUTTONS_CLICK_TIMEOUT)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb759c04c>}
nname: 33
n 33(None)[self._pick(event_arg)
]:
	i: 12(), 32()
	o: 

nname: 32
n 32(None)[]:
	i: 0(f)
	o: 33()

nname: 12
n 12(None)[self.player._autohide_timeout.start()
]:
	i: 0(t)
	o: 33()

nname: 0
n 0(self.player._autohide_timeout)[]:
	i: 
	o: 12(t), 32(f)

nname: 0
n 0(None)[if self.player._autohide_timeout:
	self.player._autohide_timeout.start()
self._pick(event_arg)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb759960c>}
nname: 0
n 0(None)[self._button1_task.fn = self.handle_button1
self._button1_task.start(BUTTONS_REPEAT_TIMEOUT)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7599e0c>}
nname: 0
n 0(None)[self._button2_task.fn = self.handle_button2
self._button2_task.start(BUTTONS_REPEAT_TIMEOUT)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7599acc>}
nname: 0
n 0(None)[self._button3_task.fn = self.handle_button3
self._button3_task.start(BUTTONS_REPEAT_TIMEOUT)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75992ec>}
nname: 0
n 0(None)[self._button4_task.fn = self.handle_button4
self._button4_task.start(BUTTONS_REPEAT_TIMEOUT)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75994cc>}
nname: 0
n 0(None)[]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7599f8c>}
nname: 0
n 0(None)[print 'ERROR: _pick() NOT IMPLEMENTED'
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75995ac>}
nname: 58
n 58(None)[return abs(event_arg['x'] - event_arg['start_x']) > EPSILON
]:
	i: 0(t), 30()
	o: 

nname: 30
n 30(None)[]:
	i: 0(f)
	o: 58()

nname: 0
n 0(abs(event_arg['x'] - event_arg['start_x']) > EPSILON)[]:
	i: 
	o: 30(f), 58(t)

nname: 0
n 0(None)[if not abs(event_arg['x'] - event_arg['start_x']) > EPSILON:
	pass
return abs(event_arg['x'] - event_arg['start_x']) > EPSILON
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb759914c>}
nname: 6
n 6(None)[def __init__(self, player, zone, margin=DEFAULT_MARGIN, pick_on_click=False):
	self.player = player
	if zone is not None:
		pass
	self._zone = (0, 0, 0, 0)
	self._margin = margin
	self._pick_on_click = pick_on_click
	self._button0_task = Task((lambda : None))
	self._button1_task = Task((lambda : None))
	self._button2_task = Task((lambda : None))
	self._button3_task = Task((lambda : None))
	self._button4_task = Task((lambda : None))
	self.handle_click = do_nothing
	self.handle_pressed = do_nothing
	self.handle_long_click = do_nothing
	return None

def _check_zone(self, event, handler, xkey, ykey, remap_coord):
	arg = event.arg
	x = arg[xkey]
	y = arg[ykey]
	ret = self._in_zone(x, y)
	if ret:
		if remap_coord:
			zone = self._zone
			arg[xkey] = min(zone[1], max(zone[0], x))
			arg[ykey] = min(zone[3], max(zone[2], y))
		handler(arg)
	return ret

def _in_zone(self, x, y):
	zone = self._zone
	margin = self._margin
	if zone[0] - margin <= x:
		pass
	else:
		x
	if zone[0] - margin <= x:
		if zone[2] - margin <= y:
			pass
		else:
			y
	return zone[0] - margin <= x

def event_mouse(self, event):
	if not self._button0_task.running:
		return self._check_zone(event, self._manage_mouse, 'x', 'y', True)
	else:
		log.warn('%s Dropped because button0 task is running', event)
		return True

def event_button0(self, event):
	return self._check_zone(event, self._manage_button0, 'start_x', 'start_y', False)

def event_button1(self, event):
	if not hasattr(self, 'handle_button1'):
		return False
	self._manage_button1(event.arg)
	return True

def event_button2(self, event):
	if not hasattr(self, 'handle_button2'):
		return False
	self._manage_button2(event.arg)
	return True

def event_button3(self, event):
	if not hasattr(self, 'handle_button3'):
		return False
	self._manage_button3(event.arg)
	return True

def event_button4(self, event):
	if not hasattr(self, 'handle_button4'):
		return False
	self._manage_button4(event.arg)
	return True

def _manage_button0(self, event_arg):
	count = event_arg['count']
	if self.player._autohide_timeout:
		self.player._autohide_timeout.start()
	if self._pick_on_click:
		self._pick(event_arg)
	task = self._button0_task
	move_detected = self._check_button_move(event_arg)
	self.handle_pressed()
	if count < LONGCLIC_THRESHOLD and not move_detected:
		task.fn = self.handle_click
		task.args = ()
		task.start(BUTTONS_CLICK_TIMEOUT)
	else:
		task.fn = self._manage_long_click
		task.args = (event_arg,)
		task.start(BUTTONS_CLICK_TIMEOUT)

def _manage_mouse(self, event_arg):
	if self.player._autohide_timeout:
		self.player._autohide_timeout.start()
	self._pick(event_arg)

def _manage_button1(self, event_arg):
	self._button1_task.fn = self.handle_button1
	self._button1_task.start(BUTTONS_REPEAT_TIMEOUT)

def _manage_button2(self, event_arg):
	self._button2_task.fn = self.handle_button2
	self._button2_task.start(BUTTONS_REPEAT_TIMEOUT)

def _manage_button3(self, event_arg):
	self._button3_task.fn = self.handle_button3
	self._button3_task.start(BUTTONS_REPEAT_TIMEOUT)

def _manage_button4(self, event_arg):
	self._button4_task.fn = self.handle_button4
	self._button4_task.start(BUTTONS_REPEAT_TIMEOUT)

def _manage_long_click(self, event_arg):
	pass

def _pick(self, event_arg):
	print 'ERROR: _pick() NOT IMPLEMENTED'

def _check_button_move(self, event_arg):
	if not abs(event_arg['x'] - event_arg['start_x']) > EPSILON:
		pass
	return abs(event_arg['x'] - event_arg['start_x']) > EPSILON

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb7592eac>}
nname: 0
n 0(None)[return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75922ac>}
nname: 0
n 0(None)[ZoneEventHandler.__init__(self, player, zone, margin, pick_on_click)
self._vertical = vertical
self.handle_forward_click = do_nothing
self.handle_backward_click = do_nothing
self.handle_transversal_click = do_nothing
self.handle_pick_coord = null_pick_coord
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7592d6c>}
nname: 83
n 83(None)[self.handle_pick_coord(coord)
]:
	i: 18(), 52()
	o: 

nname: 52
n 52(None)[coord = compute_linear_coordinate(event_arg['x'], zone[0], zone[1])
]:
	i: 0(f)
	o: 83()

nname: 18
n 18(None)[coord = compute_linear_coordinate(event_arg['y'], zone[2], zone[3])
]:
	i: 0(t)
	o: 83()

nname: 0
n 0(self._vertical)[zone = self._zone
]:
	i: 
	o: 18(t), 52(f)

nname: 0
n 0(None)[zone = self._zone
if self._vertical:
	coord = compute_linear_coordinate(event_arg['y'], zone[2], zone[3])
else:
	coord = compute_linear_coordinate(event_arg['x'], zone[0], zone[1])
self.handle_pick_coord(coord)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7592fcc>}
nname: 227
n 227(None)[]:
	i: 134(JA), 161(JA), 175(), 202(), 216()
	o: 

nname: 216
n 216(None)[self.handle_transversal_click()
]:
	i: 189(f)
	o: 227()

nname: 202
n 202(None)[self.handle_long_click()
]:
	i: 189(t)
	o: 227()

nname: 189
n 189(abs_minordiff < EPSILON)[]:
	i: 63(f)
	o: 202(t), 216(f)

nname: 175
n 175(None)[self.handle_backward_click()
]:
	i: 148(f)
	o: 227()

nname: 161
n 161(None)[self.handle_forward_click()
]:
	i: 148(t)
	o: 227(JA)

nname: 148
n 148(majordiff > 0)[]:
	i: 121(f)
	o: 161(t), 175(f)

nname: 134
n 134(None)[self.handle_long_click()
]:
	i: 121(t)
	o: 227(JA)

nname: 121
n 121(abs_majordiff < EPSILON)[]:
	i: 63(t)
	o: 134(t), 148(f)

nname: 63
n 63(abs_majordiff >= abs_minordiff)[abs_majordiff = abs(majordiff)
abs_minordiff = abs(minordiff)
log.debug('LONGCLIC: event_arg: %s abs_major=%s abs_minor=%s', event_arg, abs_majordiff, abs_minordiff)
]:
	i: 45(), 62()
	o: 121(t), 189(f)

nname: 62
n 62(None)[]:
	i: 0(f)
	o: 63()

nname: 45
n 45(None)[majordiff, minordiff = minordiff, majordiff
]:
	i: 0(t)
	o: 63()

nname: 0
n 0(self._vertical)[majordiff = event_arg['x'] - event_arg['start_x']
minordiff = event_arg['y'] - event_arg['start_y']
]:
	i: 
	o: 45(t), 62(f)

nname: 227
n 227(None)[]:
	i: 0(JA)
	o: 

nname: 0
n 0(None)[majordiff = event_arg['x'] - event_arg['start_x']
minordiff = event_arg['y'] - event_arg['start_y']
if self._vertical:
	majordiff, minordiff = minordiff, majordiff
abs_majordiff = abs(majordiff)
abs_minordiff = abs(minordiff)
log.debug('LONGCLIC: event_arg: %s abs_major=%s abs_minor=%s', event_arg, abs_majordiff, abs_minordiff)
if abs_majordiff >= abs_minordiff:
	if abs_majordiff < EPSILON:
		self.handle_long_click()
	else:
		if majordiff > 0:
			self.handle_forward_click()
		else:
			self.handle_backward_click()
else:
	if abs_minordiff < EPSILON:
		self.handle_long_click()
	else:
		self.handle_transversal_click()
]:
	i: 
	o: 227(JA)

nname: 0
n 0(None)[majordiff = event_arg['x'] - event_arg['start_x']
minordiff = event_arg['y'] - event_arg['start_y']
if self._vertical:
	majordiff, minordiff = minordiff, majordiff
abs_majordiff = abs(majordiff)
abs_minordiff = abs(minordiff)
log.debug('LONGCLIC: event_arg: %s abs_major=%s abs_minor=%s', event_arg, abs_majordiff, abs_minordiff)
if abs_majordiff >= abs_minordiff:
	if abs_majordiff < EPSILON:
		self.handle_long_click()
	else:
		if majordiff > 0:
			self.handle_forward_click()
		else:
			self.handle_backward_click()
else:
	if abs_minordiff < EPSILON:
		self.handle_long_click()
	else:
		self.handle_transversal_click()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb759cd4c>}
nname: 6
n 6(None)[def __init__(self, player, zone, vertical=True, margin=DEFAULT_MARGIN, pick_on_click=False):
	ZoneEventHandler.__init__(self, player, zone, margin, pick_on_click)
	self._vertical = vertical
	self.handle_forward_click = do_nothing
	self.handle_backward_click = do_nothing
	self.handle_transversal_click = do_nothing
	self.handle_pick_coord = null_pick_coord

def _pick(self, event_arg):
	zone = self._zone
	if self._vertical:
		coord = compute_linear_coordinate(event_arg['y'], zone[2], zone[3])
	else:
		coord = compute_linear_coordinate(event_arg['x'], zone[0], zone[1])
	self.handle_pick_coord(coord)

def _manage_long_click(self, event_arg):
	majordiff = event_arg['x'] - event_arg['start_x']
	minordiff = event_arg['y'] - event_arg['start_y']
	if self._vertical:
		majordiff, minordiff = minordiff, majordiff
	abs_majordiff = abs(majordiff)
	abs_minordiff = abs(minordiff)
	log.debug('LONGCLIC: event_arg: %s abs_major=%s abs_minor=%s', event_arg, abs_majordiff, abs_minordiff)
	if abs_majordiff >= abs_minordiff:
		if abs_majordiff < EPSILON:
			self.handle_long_click()
		else:
			if majordiff > 0:
				self.handle_forward_click()
			else:
				self.handle_backward_click()
	else:
		if abs_minordiff < EPSILON:
			self.handle_long_click()
		else:
			self.handle_transversal_click()

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75925cc>}
nname: 0
n 0(None)[return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7592c0c>}
nname: 0
n 0(None)[ZoneEventHandler.__init__(self, player, zone, margin, pick_on_click)
self.handle_pick_x_y = null_pick_x_y
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7592b6c>}
nname: 0
n 0(None)[zone = self._zone
x = compute_linear_coordinate(event_arg['x'], zone[0], zone[1])
y = compute_linear_coordinate(event_arg['y'], zone[2], zone[3])
self.handle_pick_x_y(x, y)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7592fec>}
nname: 6
n 6(None)[def __init__(self, player, zone, vertical=True, margin=DEFAULT_MARGIN, pick_on_click=False):
	ZoneEventHandler.__init__(self, player, zone, margin, pick_on_click)
	self.handle_pick_x_y = null_pick_x_y

def _pick(self, event_arg):
	zone = self._zone
	x = compute_linear_coordinate(event_arg['x'], zone[0], zone[1])
	y = compute_linear_coordinate(event_arg['y'], zone[2], zone[3])
	self.handle_pick_x_y(x, y)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb759220c>}
nname: 0
n 0(None)[ZoneEventHandler.__init__(self, player, zone, margin, pick_on_click)
self.handle_hover = do_nothing
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7592eac>}
nname: 33
n 33(None)[self.handle_hover()
]:
	i: 12(), 32()
	o: 

nname: 32
n 32(None)[]:
	i: 0(f)
	o: 33()

nname: 12
n 12(None)[self.player._autohide_timeout.start()
]:
	i: 0(t)
	o: 33()

nname: 0
n 0(self.player._autohide_timeout)[]:
	i: 
	o: 12(t), 32(f)

nname: 0
n 0(None)[if self.player._autohide_timeout:
	self.player._autohide_timeout.start()
self.handle_hover()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb759298c>}
nname: 0
n 0(None)[self.handle_click()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb759248c>}
nname: 6
n 6(None)[def __init__(self, player, zone, margin=DEFAULT_MARGIN, pick_on_click=False):
	ZoneEventHandler.__init__(self, player, zone, margin, pick_on_click)
	self.handle_hover = do_nothing

def _manage_mouse(self, event_arg):
	if self.player._autohide_timeout:
		self.player._autohide_timeout.start()
	self.handle_hover()

def _manage_long_click(self, event_arg):
	self.handle_click()

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75923ec>}
nname: 0
n 0(None)[ZoneEventHandler.__init__(self, player, zone, margin, pick_on_click)
self.start_pos = []
self.start_count = 0
self.move_repeat_delay = HMI_BASE['rcu_move_repeat_delay']
self.handle_x_gesture = do_nothing
self.handle_y_gesture = do_nothing
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7592e0c>}
nname: 364
n 364(None)[]:
	i: 16(), 355(JA), 360(), 363()
	o: 

nname: 363
n 363(None)[]:
	i: 52(f)
	o: 364()

nname: 360
n 360(None)[]:
	i: 300(JA), 359()
	o: 364()

nname: 359
n 359(None)[]:
	i: 211(f)
	o: 360()

nname: 355
n 355(None)[]:
	i: 223(f)
	o: 364(JA)

nname: 300
n 300(None)[move = -move
callback(move, speed)
self.start_pos = [event_arg['x'], event_arg['y']]
self.start_count = event_arg['count']
]:
	i: 288(), 295()
	o: 360(JA)

nname: 295
n 295(None)[]:
	i: 275(f)
	o: 300()

nname: 288
n 288(None)[]:
	i: 275(t)
	o: 300()

nname: 275
n 275(majordiff > 0)[]:
	i: 223(t)
	o: 288(t), 295(f)

nname: 223
n 223(move >= 1)[move = int(round(abs_majordiff / GESTURE_THRESHOLD))
speed = abs_majordiff / count * self.move_repeat_delay
]:
	i: 211(t)
	o: 275(t), 355(f)

nname: 211
n 211(abs_majordiff > GESTURE_THRESHOLD)[]:
	i: 164(), 189()
	o: 223(t), 359(f)

nname: 189
n 189(None)[majordiff = y_diff
abs_majordiff = abs_y_diff
callback = self.handle_y_gesture
]:
	i: 62(f)
	o: 211()

nname: 164
n 164(None)[majordiff = x_diff
abs_majordiff = abs_x_diff
callback = self.handle_x_gesture
]:
	i: 62(t)
	o: 211()

nname: 62
n 62(abs_x_diff >= abs_y_diff)[x_diff = event_arg['x'] - self.start_pos[0]
y_diff = event_arg['y'] - self.start_pos[1]
count = event_arg['count'] - self.start_count
abs_x_diff = abs(x_diff)
abs_y_diff = abs(y_diff)
callback = do_nothing
]:
	i: 52(t)
	o: 164(t), 189(f)

nname: 52
n 52(self.start_pos)[]:
	i: 0(f)
	o: 62(t), 363(f)

nname: 16
n 16(None)[self.start_pos = [event_arg['x'], event_arg['y']]
self.start_count = 1
]:
	i: 0(t)
	o: 364()

nname: 0
n 0(event_arg['count'] == 1)[]:
	i: 
	o: 16(t), 52(f)

nname: 364
n 364(None)[]:
	i: 16(), 223(f), 275(JA), 62(f), 52(f)
	o: 

nname: 275
n 275(None)[if majordiff > 0:
	pass
move = -move
callback(move, speed)
self.start_pos = [event_arg['x'], event_arg['y']]
self.start_count = event_arg['count']
]:
	i: 223(t)
	o: 364(JA)

nname: 223
n 223(move >= 1)[move = int(round(abs_majordiff / GESTURE_THRESHOLD))
speed = abs_majordiff / count * self.move_repeat_delay
]:
	i: 62(t)
	o: 275(t), 364(f)

nname: 62
n 62(abs_majordiff > GESTURE_THRESHOLD)[x_diff = event_arg['x'] - self.start_pos[0]
y_diff = event_arg['y'] - self.start_pos[1]
count = event_arg['count'] - self.start_count
abs_x_diff = abs(x_diff)
abs_y_diff = abs(y_diff)
callback = do_nothing
if abs_x_diff >= abs_y_diff:
	majordiff = x_diff
	abs_majordiff = abs_x_diff
	callback = self.handle_x_gesture
else:
	majordiff = y_diff
	abs_majordiff = abs_y_diff
	callback = self.handle_y_gesture
]:
	i: 52(t)
	o: 223(t), 364(f)

nname: 52
n 52(self.start_pos)[]:
	i: 0(f)
	o: 62(t), 364(f)

nname: 16
n 16(None)[self.start_pos = [event_arg['x'], event_arg['y']]
self.start_count = 1
]:
	i: 0(t)
	o: 364()

nname: 0
n 0(event_arg['count'] == 1)[]:
	i: 
	o: 16(t), 52(f)

nname: 0
n 0(None)[if event_arg['count'] == 1:
	self.start_pos = [event_arg['x'], event_arg['y']]
	self.start_count = 1
else:
	if self.start_pos:
		x_diff = event_arg['x'] - self.start_pos[0]
		y_diff = event_arg['y'] - self.start_pos[1]
		count = event_arg['count'] - self.start_count
		abs_x_diff = abs(x_diff)
		abs_y_diff = abs(y_diff)
		callback = do_nothing
		if abs_x_diff >= abs_y_diff:
			majordiff = x_diff
			abs_majordiff = abs_x_diff
			callback = self.handle_x_gesture
		else:
			majordiff = y_diff
			abs_majordiff = abs_y_diff
			callback = self.handle_y_gesture
		if abs_majordiff > GESTURE_THRESHOLD:
			move = int(round(abs_majordiff / GESTURE_THRESHOLD))
			speed = abs_majordiff / count * self.move_repeat_delay
			if move >= 1:
				if majordiff > 0:
					pass
				move = -move
				callback(move, speed)
				self.start_pos = [event_arg['x'], event_arg['y']]
				self.start_count = event_arg['count']
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75969ac>}
nname: 6
n 6(None)[def __init__(self, player, zone, margin=DEFAULT_MARGIN, pick_on_click=True):
	ZoneEventHandler.__init__(self, player, zone, margin, pick_on_click)
	self.start_pos = []
	self.start_count = 0
	self.move_repeat_delay = HMI_BASE['rcu_move_repeat_delay']
	self.handle_x_gesture = do_nothing
	self.handle_y_gesture = do_nothing

def _manage_mouse(self, event_arg):
	if event_arg['count'] == 1:
		self.start_pos = [event_arg['x'], event_arg['y']]
		self.start_count = 1
	else:
		if self.start_pos:
			x_diff = event_arg['x'] - self.start_pos[0]
			y_diff = event_arg['y'] - self.start_pos[1]
			count = event_arg['count'] - self.start_count
			abs_x_diff = abs(x_diff)
			abs_y_diff = abs(y_diff)
			callback = do_nothing
			if abs_x_diff >= abs_y_diff:
				majordiff = x_diff
				abs_majordiff = abs_x_diff
				callback = self.handle_x_gesture
			else:
				majordiff = y_diff
				abs_majordiff = abs_y_diff
				callback = self.handle_y_gesture
			if abs_majordiff > GESTURE_THRESHOLD:
				move = int(round(abs_majordiff / GESTURE_THRESHOLD))
				speed = abs_majordiff / count * self.move_repeat_delay
				if move >= 1:
					if majordiff > 0:
						pass
					move = -move
					callback(move, speed)
					self.start_pos = [event_arg['x'], event_arg['y']]
					self.start_count = event_arg['count']

_manage_button0 = _manage_mouse
]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75921ac>}
nname: 0
n 0(None)[SliderEventHandler.__init__(self, player, zone, vertical, margin, pick_on_click)
self.handle_released = do_nothing
self.handle_pressed = do_nothing
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75927ac>}
nname: 104
n 104(None)[task.fn = self.handle_released
task.args = ()
task.start(BUTTONS_REPEAT_TIMEOUT * 3)
]:
	i: 87(), 97()
	o: 

nname: 97
n 97(None)[]:
	i: 43(f)
	o: 104()

nname: 87
n 87(None)[]:
	i: 43(t)
	o: 104()

nname: 43
n 43(count < LONGCLIC_THRESHOLD)[self._pick(event_arg)
self.handle_pressed()
task = self._button0_task
]:
	i: 22(), 42()
	o: 87(t), 97(f)

nname: 42
n 42(None)[]:
	i: 0(f)
	o: 43()

nname: 22
n 22(None)[self.player._autohide_timeout.start()
]:
	i: 0(t)
	o: 43()

nname: 0
n 0(self.player._autohide_timeout)[count = event_arg['count']
]:
	i: 
	o: 22(t), 42(f)

nname: 104
n 104(None)[task.fn = self.handle_released
task.args = ()
task.start(BUTTONS_REPEAT_TIMEOUT * 3)
]:
	i: 0()
	o: 

nname: 0
n 0(None)[count = event_arg['count']
if self.player._autohide_timeout:
	self.player._autohide_timeout.start()
self._pick(event_arg)
self.handle_pressed()
task = self._button0_task
if count < LONGCLIC_THRESHOLD:
	pass
]:
	i: 
	o: 104()

nname: 0
n 0(None)[count = event_arg['count']
if self.player._autohide_timeout:
	self.player._autohide_timeout.start()
self._pick(event_arg)
self.handle_pressed()
task = self._button0_task
if count < LONGCLIC_THRESHOLD:
	pass
task.fn = self.handle_released
task.args = ()
task.start(BUTTONS_REPEAT_TIMEOUT * 3)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7592c6c>}
nname: 6
n 6(None)[def __init__(self, player, zone, vertical=True, margin=DEFAULT_MARGIN, pick_on_click=False):
	SliderEventHandler.__init__(self, player, zone, vertical, margin, pick_on_click)
	self.handle_released = do_nothing
	self.handle_pressed = do_nothing

def _manage_button0(self, event_arg):
	count = event_arg['count']
	if self.player._autohide_timeout:
		self.player._autohide_timeout.start()
	self._pick(event_arg)
	self.handle_pressed()
	task = self._button0_task
	if count < LONGCLIC_THRESHOLD:
		pass
	task.fn = self.handle_released
	task.args = ()
	task.start(BUTTONS_REPEAT_TIMEOUT * 3)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75920ec>}
nname: 0
n 0(None)[self.handler = handler
self.active = active
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb759202c>}
nname: 6
n 6(None)[__slots__ = ('handler', 'active')
def __init__(self, handler, active=True):
	self.handler = handler
	self.active = active

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb759206c>}
nname: 0
n 0(None)[ZoneEventHandler.__init__(self, player, zone, margin, pick_on_click)
self._subzone_handlers = []
self._vertical = vertical
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb759268c>}
nname: 0
n 0(None)[zone_event_handler._margin = 0
self._subzone_handlers.append(SubZoneHandler(zone_event_handler, active))
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7592cac>}
nname: 0
n 0(None)[self._subzone_handlers[zone_id].active = active
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7592a2c>}
nname: 418
n 418(None)[return None
]:
	i: 95(AL), 417()
	o: 

nname: 417
n 417(None)[]:
	i: 179(AF), 414()
	o: 418()

nname: 414
n 414(None)[]:
	i: 238(JA), 413()
	o: 417()

nname: 413
n 413(None)[]:
	i: 250(f), 384()
	o: 414()

nname: 384
n 384(None)[getattr(zone.handler, method_name)(event)
return True
continue
]:
	i: 335(), 383()
	o: 413()

nname: 383
n 383(None)[]:
	i: 272(f)
	o: 384()

nname: 335
n 335(None)[event_arg[xkey2remap] = event_arg[xkey2remap] + new_x - x
event_arg[ykey2remap] = event_arg[ykey2remap] + new_y - y
]:
	i: 272(t)
	o: 384()

nname: 272
n 272(xkey2remap is not None)[zone, new_x, new_y = self._search_active_zone(i, x, y)
event_arg[xkey] = new_x
event_arg[ykey] = new_y
]:
	i: 250(t)
	o: 335(t), 383(f)

nname: 250
n 250(zeh.handler._in_zone(x, y))[]:
	i: 195(f), 246()
	o: 272(t), 413(f)

nname: 246
n 246(None)[continue
]:
	i: 213(f)
	o: 250()

nname: 238
n 238(None)[return True
]:
	i: 213(t)
	o: 414(JA)

nname: 213
n 213(getattr(zeh.handler, method_name)(event))[]:
	i: 195(t)
	o: 238(t), 246(f)

nname: 195
n 195(zeh.active)[for i, zeh in enumerate(self._subzone_handlers):
]:
	i: 179(for)
	o: 213(t), 250(f)

nname: 179
n 179(None)[]:
	i: 95(loop)
	o: 195(for), 417(AF)

nname: 95
n 95(None)[zone = self._zone
event_arg[xkey] = min(zone[1], max(zone[0], x))
event_arg[ykey] = min(zone[3], max(zone[2], y))
]:
	i: 56(AL), 90()
	o: 179(loop), 418(AL)

nname: 90
n 90(None)[return True
]:
	i: 59(AF), 86()
	o: 95()

nname: 86
n 86(None)[]:
	i: 69(f), 81()
	o: 90()

nname: 81
n 81(None)[break
continue
]:
	i: 69(t)
	o: 86()

nname: 69
n 69(zeh.active)[for zeh in self._subzone_handlers:
]:
	i: 59(for)
	o: 81(t), 86(f)

nname: 59
n 59(None)[]:
	i: 56(loop)
	o: 69(for), 90(AF)

nname: 56
n 56(None)[]:
	i: 47(), 55()
	o: 59(loop), 95(AL)

nname: 55
n 55(None)[]:
	i: 0(t)
	o: 56()

nname: 47
n 47(None)[return False
]:
	i: 0(f)
	o: 56()

nname: 0
n 0(self._in_zone(x, y))[event_arg = event.arg
x = event_arg[xkey]
y = event_arg[ykey]
]:
	i: 
	o: 47(f), 55(t)

nname: 418
n 418(None)[return None
]:
	i: 95(AL), 179(AF), 238(JA), 250(f), 272()
	o: 

nname: 272
n 272(None)[zone, new_x, new_y = self._search_active_zone(i, x, y)
event_arg[xkey] = new_x
event_arg[ykey] = new_y
if xkey2remap is not None:
	event_arg[xkey2remap] = event_arg[xkey2remap] + new_x - x
	event_arg[ykey2remap] = event_arg[ykey2remap] + new_y - y
getattr(zone.handler, method_name)(event)
return True
continue
]:
	i: 250(t)
	o: 418()

nname: 250
n 250(zeh.handler._in_zone(x, y))[]:
	i: 195(f), 246()
	o: 272(t), 418(f)

nname: 246
n 246(None)[continue
]:
	i: 213(f)
	o: 250()

nname: 238
n 238(None)[return True
]:
	i: 213(t)
	o: 418(JA)

nname: 213
n 213(getattr(zeh.handler, method_name)(event))[]:
	i: 195(t)
	o: 238(t), 246(f)

nname: 195
n 195(zeh.active)[for i, zeh in enumerate(self._subzone_handlers):
]:
	i: 179(for)
	o: 213(t), 250(f)

nname: 179
n 179(None)[]:
	i: 95(loop)
	o: 195(for), 418(AF)

nname: 95
n 95(None)[zone = self._zone
event_arg[xkey] = min(zone[1], max(zone[0], x))
event_arg[ykey] = min(zone[3], max(zone[2], y))
]:
	i: 0(AL), 90()
	o: 179(loop), 418(AL)

nname: 90
n 90(None)[return True
]:
	i: 59(AF), 69()
	o: 95()

nname: 69
n 69(None)[for zeh in self._subzone_handlers:
if zeh.active:
	break
	continue
]:
	i: 59(for)
	o: 90()

nname: 59
n 59(None)[]:
	i: 0(loop)
	o: 69(for), 90(AF)

nname: 0
n 0(None)[event_arg = event.arg
x = event_arg[xkey]
y = event_arg[ykey]
if not self._in_zone(x, y):
	return False
]:
	i: 
	o: 59(loop), 95(AL)

nname: 418
n 418(None)[return None
]:
	i: 95(AL), 179(AF), 238(JA), 250(f)
	o: 

nname: 250
n 250(None)[if zeh.handler._in_zone(x, y):
	zone, new_x, new_y = self._search_active_zone(i, x, y)
	event_arg[xkey] = new_x
	event_arg[ykey] = new_y
	if xkey2remap is not None:
		event_arg[xkey2remap] = event_arg[xkey2remap] + new_x - x
		event_arg[ykey2remap] = event_arg[ykey2remap] + new_y - y
	getattr(zone.handler, method_name)(event)
	return True
	continue
]:
	i: 195(f), 246()
	o: 418()

nname: 246
n 246(None)[continue
]:
	i: 213(f)
	o: 250()

nname: 238
n 238(None)[return True
]:
	i: 213(t)
	o: 418(JA)

nname: 213
n 213(getattr(zeh.handler, method_name)(event))[]:
	i: 195(t)
	o: 238(t), 246(f)

nname: 195
n 195(zeh.active)[for i, zeh in enumerate(self._subzone_handlers):
]:
	i: 179(for)
	o: 213(t), 250(f)

nname: 179
n 179(None)[]:
	i: 95(loop)
	o: 195(for), 418(AF)

nname: 95
n 95(None)[zone = self._zone
event_arg[xkey] = min(zone[1], max(zone[0], x))
event_arg[ykey] = min(zone[3], max(zone[2], y))
]:
	i: 0(AL), 90()
	o: 179(loop), 418(AL)

nname: 90
n 90(None)[return True
]:
	i: 59(AF), 69()
	o: 95()

nname: 69
n 69(None)[for zeh in self._subzone_handlers:
if zeh.active:
	break
	continue
]:
	i: 59(for)
	o: 90()

nname: 59
n 59(None)[]:
	i: 0(loop)
	o: 69(for), 90(AF)

nname: 0
n 0(None)[event_arg = event.arg
x = event_arg[xkey]
y = event_arg[ykey]
if not self._in_zone(x, y):
	return False
]:
	i: 
	o: 59(loop), 95(AL)

self.nodes: {0: <unpyclib.structure.node instance at 0xb7599a6c>, 418: <unpyclib.structure.node instance at 0xb759ca2c>, 179: <unpyclib.structure.node instance at 0xb759c18c>, 59: <unpyclib.structure.node instance at 0xb759c6ac>, 195: <unpyclib.structure.node instance at 0xb759cb6c>, 69: <unpyclib.structure.node instance at 0xb75990ec>, 213: <unpyclib.structure.node instance at 0xb759cf0c>, 90: <unpyclib.structure.node instance at 0xb759cf6c>, 95: <unpyclib.structure.node instance at 0xb759c10c>, 238: <unpyclib.structure.node instance at 0xb759ce6c>, 246: <unpyclib.structure.node instance at 0xb759c4ac>, 250: <unpyclib.structure.node instance at 0xb759906c>}
nname: 0
n 0(None)[return self._manage_event_aux('x', 'y', event, 'event_mouse')
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb759650c>}
nname: 0
n 0(None)[return self._manage_event_aux('start_x', 'start_y', event, 'event_button0', 'x', 'y')
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7596f4c>}
nname: 298
n 298(None)[return None
]:
	i: 247(), 274()
	o: 

nname: 274
n 274(None)[return self._remap_by_sup(x, y, subzones[sup])
]:
	i: 227(f)
	o: 298()

nname: 247
n 247(None)[return self._remap_by_inf(x, y, subzones[inf])
]:
	i: 227(t)
	o: 298()

nname: 227
n 227(i - inf < sup - i)[]:
	i: 159(), 199(), 226()
	o: 247(t), 274(f)

nname: 226
n 226(None)[]:
	i: 186(f)
	o: 227()

nname: 199
n 199(None)[return self._remap_by_inf(x, y, subzones[inf])
]:
	i: 186(t)
	o: 227()

nname: 186
n 186(sup is None)[]:
	i: 147(f)
	o: 199(t), 226(f)

nname: 159
n 159(None)[return self._remap_by_sup(x, y, subzones[sup])
]:
	i: 147(t)
	o: 227()

nname: 147
n 147(inf is None)[]:
	i: 75(AL), 139()
	o: 159(t), 186(f)

nname: 139
n 139(None)[sup = None
]:
	i: 88(f), 126()
	o: 147()

nname: 126
n 126(None)[sup += 1
]:
	i: 120(), 125()
	o: 139()

nname: 125
n 125(None)[]:
	i: 106(f)
	o: 126()

nname: 120
n 120(None)[break
]:
	i: 106(t)
	o: 126()

nname: 106
n 106(subzones[sup].active)[]:
	i: 88(t)
	o: 120(t), 125(f)

nname: 88
n 88(sup < len(subzones))[]:
	i: 75(loop)
	o: 106(t), 139(f)

nname: 75
n 75(None)[sup = i + 1
]:
	i: 0(AL), 67()
	o: 88(loop), 147(AL)

nname: 67
n 67(None)[inf = None
]:
	i: 22(f), 54()
	o: 75()

nname: 54
n 54(None)[inf -= 1
]:
	i: 48(), 53()
	o: 67()

nname: 53
n 53(None)[]:
	i: 34(f)
	o: 54()

nname: 48
n 48(None)[break
]:
	i: 34(t)
	o: 54()

nname: 34
n 34(subzones[inf].active)[]:
	i: 22(t)
	o: 48(t), 53(f)

nname: 22
n 22(inf >= 0)[]:
	i: 0(loop)
	o: 34(t), 67(f)

nname: 0
n 0(None)[subzones = self._subzone_handlers
inf = i - 1
]:
	i: 
	o: 22(loop), 75(AL)

nname: 298
n 298(None)[return None
]:
	i: 147()
	o: 

nname: 147
n 147(None)[if inf is None:
	return self._remap_by_sup(x, y, subzones[sup])
else:
	if sup is None:
		return self._remap_by_inf(x, y, subzones[inf])
if i - inf < sup - i:
	return self._remap_by_inf(x, y, subzones[inf])
else:
	return self._remap_by_sup(x, y, subzones[sup])
]:
	i: 75(AL), 139()
	o: 298()

nname: 139
n 139(None)[sup = None
]:
	i: 88(f), 106()
	o: 147()

nname: 106
n 106(None)[if subzones[sup].active:
	break
sup += 1
]:
	i: 88(t)
	o: 139()

nname: 88
n 88(sup < len(subzones))[]:
	i: 75(loop)
	o: 106(t), 139(f)

nname: 75
n 75(None)[sup = i + 1
]:
	i: 0(AL), 67()
	o: 88(loop), 147(AL)

nname: 67
n 67(None)[inf = None
]:
	i: 22(f), 34()
	o: 75()

nname: 34
n 34(None)[if subzones[inf].active:
	break
inf -= 1
]:
	i: 22(t)
	o: 67()

nname: 22
n 22(inf >= 0)[]:
	i: 0(loop)
	o: 34(t), 67(f)

nname: 0
n 0(None)[subzones = self._subzone_handlers
inf = i - 1
]:
	i: 
	o: 22(loop), 75(AL)

nname: 147
n 147(None)[if inf is None:
	return self._remap_by_sup(x, y, subzones[sup])
else:
	if sup is None:
		return self._remap_by_inf(x, y, subzones[inf])
if i - inf < sup - i:
	return self._remap_by_inf(x, y, subzones[inf])
else:
	return self._remap_by_sup(x, y, subzones[sup])
return None
]:
	i: 106()
	o: 

nname: 106
n 106(None)[	if subzones[sup].active:
		break
	sup += 1
else:
	sup = None
]:
	i: 75(t)
	o: 147()

nname: 75
n 75(sup < len(subzones))[sup = i + 1
while sup < len(subzones):
]:
	i: 34()
	o: 106(t)

nname: 34
n 34(None)[	if subzones[inf].active:
		break
	inf -= 1
else:
	inf = None
]:
	i: 0(t)
	o: 75()

nname: 0
n 0(inf >= 0)[subzones = self._subzone_handlers
inf = i - 1
while inf >= 0:
]:
	i: 
	o: 34(t)

nname: 147
n 147(None)[if inf is None:
	return self._remap_by_sup(x, y, subzones[sup])
else:
	if sup is None:
		return self._remap_by_inf(x, y, subzones[inf])
if i - inf < sup - i:
	return self._remap_by_inf(x, y, subzones[inf])
else:
	return self._remap_by_sup(x, y, subzones[sup])
return None
]:
	i: 75()
	o: 

nname: 75
n 75(None)[sup = i + 1
while sup < len(subzones):
	if subzones[sup].active:
		break
	sup += 1
else:
	sup = None
]:
	i: 0()
	o: 147()

nname: 0
n 0(None)[subzones = self._subzone_handlers
inf = i - 1
while inf >= 0:
	if subzones[inf].active:
		break
	inf -= 1
else:
	inf = None
]:
	i: 
	o: 75()

nname: 147
n 147(None)[if inf is None:
	return self._remap_by_sup(x, y, subzones[sup])
else:
	if sup is None:
		return self._remap_by_inf(x, y, subzones[inf])
if i - inf < sup - i:
	return self._remap_by_inf(x, y, subzones[inf])
else:
	return self._remap_by_sup(x, y, subzones[sup])
return None
]:
	i: 0()
	o: 

nname: 0
n 0(None)[subzones = self._subzone_handlers
inf = i - 1
while inf >= 0:
	if subzones[inf].active:
		break
	inf -= 1
else:
	inf = None
sup = i + 1
while sup < len(subzones):
	if subzones[sup].active:
		break
	sup += 1
else:
	sup = None
]:
	i: 
	o: 147()

nname: 0
n 0(None)[subzones = self._subzone_handlers
inf = i - 1
while inf >= 0:
	if subzones[inf].active:
		break
	inf -= 1
else:
	inf = None
sup = i + 1
while sup < len(subzones):
	if subzones[sup].active:
		break
	sup += 1
else:
	sup = None
if inf is None:
	return self._remap_by_sup(x, y, subzones[sup])
else:
	if sup is None:
		return self._remap_by_inf(x, y, subzones[inf])
if i - inf < sup - i:
	return self._remap_by_inf(x, y, subzones[inf])
else:
	return self._remap_by_sup(x, y, subzones[sup])
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7592d8c>}
nname: 60
n 60(None)[]:
	i: 9(), 36()
	o: 

nname: 36
n 36(None)[return (newzone, newzone.handler._zone[0], y)
]:
	i: 0(f)
	o: 60()

nname: 9
n 9(None)[return (newzone, x, newzone.handler._zone[2])
]:
	i: 0(t)
	o: 60()

nname: 0
n 0(self._vertical)[]:
	i: 
	o: 9(t), 36(f)

nname: 0
n 0(None)[if self._vertical:
	return (newzone, x, newzone.handler._zone[2])
else:
	return (newzone, newzone.handler._zone[0], y)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75961ec>}
nname: 60
n 60(None)[]:
	i: 9(), 36()
	o: 

nname: 36
n 36(None)[return (newzone, newzone.handler._zone[1], y)
]:
	i: 0(f)
	o: 60()

nname: 9
n 9(None)[return (newzone, x, newzone.handler._zone[3])
]:
	i: 0(t)
	o: 60()

nname: 0
n 0(self._vertical)[]:
	i: 
	o: 9(t), 36(f)

nname: 0
n 0(None)[if self._vertical:
	return (newzone, x, newzone.handler._zone[3])
else:
	return (newzone, newzone.handler._zone[1], y)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb759696c>}
nname: 6
n 6(None)[__doc__ = ' A ZoneEventHandler that manages several inner zones aligned horizontally or vertically.\n\n        Each zone has its own zone_event_handler (with event_mouse() and\n        event_button0()) and can be active or inactive. An inactive zone\n        forwards all events which are for it to the nearest active zone.\n        So there can be several active zones and several inactive zones.\n    '
def __init__(self, player, zone, vertical=True, margin=DEFAULT_MARGIN, pick_on_click=False):
	ZoneEventHandler.__init__(self, player, zone, margin, pick_on_click)
	self._subzone_handlers = []
	self._vertical = vertical

def add_subzone_handler(self, zone_event_handler, active=True):
	zone_event_handler._margin = 0
	self._subzone_handlers.append(SubZoneHandler(zone_event_handler, active))

def set_subzone_active(self, zone_id, active):
	self._subzone_handlers[zone_id].active = active

def _manage_event_aux(self, xkey, ykey, event, method_name, xkey2remap=None, ykey2remap=None):
	event_arg = event.arg
	x = event_arg[xkey]
	y = event_arg[ykey]
	if not self._in_zone(x, y):
		return False

def event_mouse(self, event):
	return self._manage_event_aux('x', 'y', event, 'event_mouse')

def event_button0(self, event):
	return self._manage_event_aux('start_x', 'start_y', event, 'event_button0', 'x', 'y')

def _search_active_zone(self, i, x, y):
	subzones = self._subzone_handlers
	inf = i - 1
	while inf >= 0:
		if subzones[inf].active:
			break
		inf -= 1
	else:
		inf = None
	sup = i + 1
	while sup < len(subzones):
		if subzones[sup].active:
			break
		sup += 1
	else:
		sup = None
	if inf is None:
		return self._remap_by_sup(x, y, subzones[sup])
	else:
		if sup is None:
			return self._remap_by_inf(x, y, subzones[inf])
	if i - inf < sup - i:
		return self._remap_by_inf(x, y, subzones[inf])
	else:
		return self._remap_by_sup(x, y, subzones[sup])
	return None

def _remap_by_sup(self, x, y, newzone):
	if self._vertical:
		return (newzone, x, newzone.handler._zone[2])
	else:
		return (newzone, newzone.handler._zone[0], y)

def _remap_by_inf(self, x, y, newzone):
	if self._vertical:
		return (newzone, x, newzone.handler._zone[3])
	else:
		return (newzone, newzone.handler._zone[1], y)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb7592f6c>}
nname: 0
n 0(None)[return (xmin, xmax, ymin, ymax)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7592f2c>}
nname: 0
n 0(None)[return (xmin, xmax, ymin, ymax)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb759668c>}
nname: 180
n 180(None)[return res
]:
	i: 89(AL), 179()
	o: 

nname: 179
n 179(None)[]:
	i: 122(AF), 135()
	o: 180()

nname: 135
n 135(None)[for i in xrange(parts):
res.append(build_subzone(coordmin, coordmax))
coordmin = coordmax
coordmax += lenght
]:
	i: 122(for)
	o: 179()

nname: 122
n 122(None)[]:
	i: 89(loop)
	o: 135(for), 179(AF)

nname: 89
n 89(None)[lenght = (coordmax - coordmin) // parts
coordmax = coordmin + lenght
res = []
]:
	i: 24(), 58()
	o: 122(loop), 180(AL)

nname: 58
n 58(None)[def build_subzone(xmin, xmax):
	return (xmin, xmax, ymin, ymax)

coordmin = xmin
coordmax = xmax
]:
	i: 0(f)
	o: 89()

nname: 24
n 24(None)[def build_subzone(ymin, ymax):
	return (xmin, xmax, ymin, ymax)

coordmin = ymin
coordmax = ymax
]:
	i: 0(t)
	o: 89()

nname: 0
n 0(vertical)[xmin, xmax, ymin, ymax = zone
]:
	i: 
	o: 24(t), 58(f)

nname: 179
n 179(None)[return res
]:
	i: 122()
	o: 

nname: 122
n 122(None)[for i in xrange(parts):
	res.append(build_subzone(coordmin, coordmax))
	coordmin = coordmax
	coordmax += lenght
]:
	i: 0(loop)
	o: 179()

nname: 0
n 0(None)[xmin, xmax, ymin, ymax = zone
if vertical:
	def build_subzone(ymin, ymax):
		return (xmin, xmax, ymin, ymax)

	coordmin = ymin
	coordmax = ymax
else:
	def build_subzone(xmin, xmax):
		return (xmin, xmax, ymin, ymax)

	coordmin = xmin
	coordmax = xmax
lenght = (coordmax - coordmin) // parts
coordmax = coordmin + lenght
res = []
]:
	i: 
	o: 122(loop)

nname: 179
n 179(None)[return res
]:
	i: 0()
	o: 

nname: 0
n 0(None)[xmin, xmax, ymin, ymax = zone
if vertical:
	def build_subzone(ymin, ymax):
		return (xmin, xmax, ymin, ymax)

	coordmin = ymin
	coordmax = ymax
else:
	def build_subzone(xmin, xmax):
		return (xmin, xmax, ymin, ymax)

	coordmin = xmin
	coordmax = xmax
lenght = (coordmax - coordmin) // parts
coordmax = coordmin + lenght
res = []
for i in xrange(parts):
	res.append(build_subzone(coordmin, coordmax))
	coordmin = coordmax
	coordmax += lenght
]:
	i: 
	o: 179()

nname: 0
n 0(None)[xmin, xmax, ymin, ymax = zone
if vertical:
	def build_subzone(ymin, ymax):
		return (xmin, xmax, ymin, ymax)

	coordmin = ymin
	coordmax = ymax
else:
	def build_subzone(xmin, xmax):
		return (xmin, xmax, ymin, ymax)

	coordmin = xmin
	coordmax = xmax
lenght = (coordmax - coordmin) // parts
coordmax = coordmin + lenght
res = []
for i in xrange(parts):
	res.append(build_subzone(coordmin, coordmax))
	coordmin = coordmax
	coordmax += lenght
return res
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75967ac>}
nname: 0
n 0(None)[from __future__ import absolute_import
__all__ = ['UPSLIDER_ZONE', 'RIGHTSLIDER_ZONE', 'DOWNSLIDER_ZONE', 'ZonesMapEventHandler', 'SliderEventHandler', 'GridEventHandler', 'ButtonEventHandler', 'GestureEventHandler', 'TrickmodeSliderEventHandler', 'MultiZoneEventHandler', 'split_zone']
from peewee.debug import GET_LOGGER, PRINT_EXCEPTION
from peewee.notifier import Task
from pygui.config import HMI_BASE
log = GET_LOGGER(__name__)
UPSLIDER_ZONE = (0, 100, 0, 20)
RIGHTSLIDER_ZONE = (80, 100, 0, 100)
DOWNSLIDER_ZONE = (0, 100, 80, 100)
LEFTSLIDER_ZONE = (0, 20, 0, 100)
GRID_ZONE = (20, 80, 20, 80)
KBDGRID_ZONE = (20, 80, 20, 100)
UPLEFT_ZONE = (0, 20, 0, 20)
COMPLETE_ZONE = (0, 100, 0, 100)
THUMBNAIL_ZONE = (0, 100, 0, 80)
EPSILON = HMI_BASE['rcu_move_threshold']
GESTURE_THRESHOLD = HMI_BASE.get('rcu_gesture_threshold', 15.0)
LONGCLIC_THRESHOLD = HMI_BASE['rcu_longclic_threshold']
BUTTONS_REPEAT_TIMEOUT = HMI_BASE['rcu_buttons_repeat_timeout']
BUTTONS_REPEAT_DELAY = HMI_BASE['rcu_buttons_repeat_delay']
DEFAULT_MARGIN = HMI_BASE.get('rcu_default_margin', 10)
BUTTONS_CLICK_TIMEOUT = BUTTONS_REPEAT_DELAY + BUTTONS_REPEAT_DELAY / 10
class ZoneHandler(object):
	__slots__ = ('_handler', '_zone')
	def __init__(self, handler, zone):
		self._handler = handler
		self._zone = zone

	def __call__(self):
		self._handler(self._zone)



class ZonesMapEventHandler(object):
	__doc__ = ' Manage a set of handlers of zones.\n    A zone is a tuple (xmin , xmax, ymin, ymax), ie an axis-aligned bounding\n    box (AABB). Coordinates are between 0 and 100.\n    '
	def __init__(self, xseps=(20, 80), yseps=(20, 80)):
		seps = [0] + list(xseps) + [100]
		xzones = tuple(<genexpr>(xrange(len(seps) - 1)))
		self._xzones = xzones
		seps = [0] + list(yseps) + [100]
		yzones = tuple(<genexpr>(xrange(len(seps) - 1)))
		self._yzones = yzones

	def set_handler(self, column, line, handlers, zone=None):
		if zone is not None:
			pass
		zone = self.zones[column][line]

	def _manage_event(self, event):
		arg = event.arg
		x = arg['x']
		y = arg['y']
		yzones = self._yzones
		for column, xmin, xmax in self._xzones:
			if x < xmax:
				for line, ymin, ymax in yzones:
					if y < ymax:
						if event.name == 'MOUSE':
							handler = self._handlers[column][line][0]
						else:
							if event.name == 'BUTTON0':
								handler = self._handlers[column][line][1]
						if handler is not None:
							handler()
						return True
						continue
				else:
					continue
		return False

	def event_button1(self, event):
		if not hasattr(self, 'handle_button1'):
			return False
		self.handle_button1()
		return True

	event_mouse = _manage_event
	event_button0 = _manage_event


def compute_linear_coordinate(x, x0, x1):
	return 100 * (x - x0) / (x1 - x0)

def do_nothing(*args):
	return None

class ZoneEventHandler(object):
	def __init__(self, player, zone, margin=DEFAULT_MARGIN, pick_on_click=False):
		self.player = player
		if zone is not None:
			pass
		self._zone = (0, 0, 0, 0)
		self._margin = margin
		self._pick_on_click = pick_on_click
		self._button0_task = Task((lambda : None))
		self._button1_task = Task((lambda : None))
		self._button2_task = Task((lambda : None))
		self._button3_task = Task((lambda : None))
		self._button4_task = Task((lambda : None))
		self.handle_click = do_nothing
		self.handle_pressed = do_nothing
		self.handle_long_click = do_nothing
		return None

	def _check_zone(self, event, handler, xkey, ykey, remap_coord):
		arg = event.arg
		x = arg[xkey]
		y = arg[ykey]
		ret = self._in_zone(x, y)
		if ret:
			if remap_coord:
				zone = self._zone
				arg[xkey] = min(zone[1], max(zone[0], x))
				arg[ykey] = min(zone[3], max(zone[2], y))
			handler(arg)
		return ret

	def _in_zone(self, x, y):
		zone = self._zone
		margin = self._margin
		if zone[0] - margin <= x:
			pass
		else:
			x
		if zone[0] - margin <= x:
			if zone[2] - margin <= y:
				pass
			else:
				y
		return zone[0] - margin <= x

	def event_mouse(self, event):
		if not self._button0_task.running:
			return self._check_zone(event, self._manage_mouse, 'x', 'y', True)
		else:
			log.warn('%s Dropped because button0 task is running', event)
			return True

	def event_button0(self, event):
		return self._check_zone(event, self._manage_button0, 'start_x', 'start_y', False)

	def event_button1(self, event):
		if not hasattr(self, 'handle_button1'):
			return False
		self._manage_button1(event.arg)
		return True

	def event_button2(self, event):
		if not hasattr(self, 'handle_button2'):
			return False
		self._manage_button2(event.arg)
		return True

	def event_button3(self, event):
		if not hasattr(self, 'handle_button3'):
			return False
		self._manage_button3(event.arg)
		return True

	def event_button4(self, event):
		if not hasattr(self, 'handle_button4'):
			return False
		self._manage_button4(event.arg)
		return True

	def _manage_button0(self, event_arg):
		count = event_arg['count']
		if self.player._autohide_timeout:
			self.player._autohide_timeout.start()
		if self._pick_on_click:
			self._pick(event_arg)
		task = self._button0_task
		move_detected = self._check_button_move(event_arg)
		self.handle_pressed()
		if count < LONGCLIC_THRESHOLD and not move_detected:
			task.fn = self.handle_click
			task.args = ()
			task.start(BUTTONS_CLICK_TIMEOUT)
		else:
			task.fn = self._manage_long_click
			task.args = (event_arg,)
			task.start(BUTTONS_CLICK_TIMEOUT)

	def _manage_mouse(self, event_arg):
		if self.player._autohide_timeout:
			self.player._autohide_timeout.start()
		self._pick(event_arg)

	def _manage_button1(self, event_arg):
		self._button1_task.fn = self.handle_button1
		self._button1_task.start(BUTTONS_REPEAT_TIMEOUT)

	def _manage_button2(self, event_arg):
		self._button2_task.fn = self.handle_button2
		self._button2_task.start(BUTTONS_REPEAT_TIMEOUT)

	def _manage_button3(self, event_arg):
		self._button3_task.fn = self.handle_button3
		self._button3_task.start(BUTTONS_REPEAT_TIMEOUT)

	def _manage_button4(self, event_arg):
		self._button4_task.fn = self.handle_button4
		self._button4_task.start(BUTTONS_REPEAT_TIMEOUT)

	def _manage_long_click(self, event_arg):
		pass

	def _pick(self, event_arg):
		print 'ERROR: _pick() NOT IMPLEMENTED'

	def _check_button_move(self, event_arg):
		if not abs(event_arg['x'] - event_arg['start_x']) > EPSILON:
			pass
		return abs(event_arg['x'] - event_arg['start_x']) > EPSILON



def null_pick_coord(coord):
	return None

class SliderEventHandler(ZoneEventHandler):
	def __init__(self, player, zone, vertical=True, margin=DEFAULT_MARGIN, pick_on_click=False):
		ZoneEventHandler.__init__(self, player, zone, margin, pick_on_click)
		self._vertical = vertical
		self.handle_forward_click = do_nothing
		self.handle_backward_click = do_nothing
		self.handle_transversal_click = do_nothing
		self.handle_pick_coord = null_pick_coord

	def _pick(self, event_arg):
		zone = self._zone
		if self._vertical:
			coord = compute_linear_coordinate(event_arg['y'], zone[2], zone[3])
		else:
			coord = compute_linear_coordinate(event_arg['x'], zone[0], zone[1])
		self.handle_pick_coord(coord)

	def _manage_long_click(self, event_arg):
		majordiff = event_arg['x'] - event_arg['start_x']
		minordiff = event_arg['y'] - event_arg['start_y']
		if self._vertical:
			majordiff, minordiff = minordiff, majordiff
		abs_majordiff = abs(majordiff)
		abs_minordiff = abs(minordiff)
		log.debug('LONGCLIC: event_arg: %s abs_major=%s abs_minor=%s', event_arg, abs_majordiff, abs_minordiff)
		if abs_majordiff >= abs_minordiff:
			if abs_majordiff < EPSILON:
				self.handle_long_click()
			else:
				if majordiff > 0:
					self.handle_forward_click()
				else:
					self.handle_backward_click()
		else:
			if abs_minordiff < EPSILON:
				self.handle_long_click()
			else:
				self.handle_transversal_click()



def null_pick_x_y(x, y):
	return None

class GridEventHandler(ZoneEventHandler):
	def __init__(self, player, zone, vertical=True, margin=DEFAULT_MARGIN, pick_on_click=False):
		ZoneEventHandler.__init__(self, player, zone, margin, pick_on_click)
		self.handle_pick_x_y = null_pick_x_y

	def _pick(self, event_arg):
		zone = self._zone
		x = compute_linear_coordinate(event_arg['x'], zone[0], zone[1])
		y = compute_linear_coordinate(event_arg['y'], zone[2], zone[3])
		self.handle_pick_x_y(x, y)



class ButtonEventHandler(ZoneEventHandler):
	def __init__(self, player, zone, margin=DEFAULT_MARGIN, pick_on_click=False):
		ZoneEventHandler.__init__(self, player, zone, margin, pick_on_click)
		self.handle_hover = do_nothing

	def _manage_mouse(self, event_arg):
		if self.player._autohide_timeout:
			self.player._autohide_timeout.start()
		self.handle_hover()

	def _manage_long_click(self, event_arg):
		self.handle_click()



class GestureEventHandler(ZoneEventHandler):
	def __init__(self, player, zone, margin=DEFAULT_MARGIN, pick_on_click=True):
		ZoneEventHandler.__init__(self, player, zone, margin, pick_on_click)
		self.start_pos = []
		self.start_count = 0
		self.move_repeat_delay = HMI_BASE['rcu_move_repeat_delay']
		self.handle_x_gesture = do_nothing
		self.handle_y_gesture = do_nothing

	def _manage_mouse(self, event_arg):
		if event_arg['count'] == 1:
			self.start_pos = [event_arg['x'], event_arg['y']]
			self.start_count = 1
		else:
			if self.start_pos:
				x_diff = event_arg['x'] - self.start_pos[0]
				y_diff = event_arg['y'] - self.start_pos[1]
				count = event_arg['count'] - self.start_count
				abs_x_diff = abs(x_diff)
				abs_y_diff = abs(y_diff)
				callback = do_nothing
				if abs_x_diff >= abs_y_diff:
					majordiff = x_diff
					abs_majordiff = abs_x_diff
					callback = self.handle_x_gesture
				else:
					majordiff = y_diff
					abs_majordiff = abs_y_diff
					callback = self.handle_y_gesture
				if abs_majordiff > GESTURE_THRESHOLD:
					move = int(round(abs_majordiff / GESTURE_THRESHOLD))
					speed = abs_majordiff / count * self.move_repeat_delay
					if move >= 1:
						if majordiff > 0:
							pass
						move = -move
						callback(move, speed)
						self.start_pos = [event_arg['x'], event_arg['y']]
						self.start_count = event_arg['count']

	_manage_button0 = _manage_mouse


class TrickmodeSliderEventHandler(SliderEventHandler):
	def __init__(self, player, zone, vertical=True, margin=DEFAULT_MARGIN, pick_on_click=False):
		SliderEventHandler.__init__(self, player, zone, vertical, margin, pick_on_click)
		self.handle_released = do_nothing
		self.handle_pressed = do_nothing

	def _manage_button0(self, event_arg):
		count = event_arg['count']
		if self.player._autohide_timeout:
			self.player._autohide_timeout.start()
		self._pick(event_arg)
		self.handle_pressed()
		task = self._button0_task
		if count < LONGCLIC_THRESHOLD:
			pass
		task.fn = self.handle_released
		task.args = ()
		task.start(BUTTONS_REPEAT_TIMEOUT * 3)



class SubZoneHandler(object):
	__slots__ = ('handler', 'active')
	def __init__(self, handler, active=True):
		self.handler = handler
		self.active = active



class MultiZoneEventHandler(ZoneEventHandler):
	__doc__ = ' A ZoneEventHandler that manages several inner zones aligned horizontally or vertically.\n\n        Each zone has its own zone_event_handler (with event_mouse() and\n        event_button0()) and can be active or inactive. An inactive zone\n        forwards all events which are for it to the nearest active zone.\n        So there can be several active zones and several inactive zones.\n    '
	def __init__(self, player, zone, vertical=True, margin=DEFAULT_MARGIN, pick_on_click=False):
		ZoneEventHandler.__init__(self, player, zone, margin, pick_on_click)
		self._subzone_handlers = []
		self._vertical = vertical

	def add_subzone_handler(self, zone_event_handler, active=True):
		zone_event_handler._margin = 0
		self._subzone_handlers.append(SubZoneHandler(zone_event_handler, active))

	def set_subzone_active(self, zone_id, active):
		self._subzone_handlers[zone_id].active = active

	def _manage_event_aux(self, xkey, ykey, event, method_name, xkey2remap=None, ykey2remap=None):
		event_arg = event.arg
		x = event_arg[xkey]
		y = event_arg[ykey]
		if not self._in_zone(x, y):
			return False

	def event_mouse(self, event):
		return self._manage_event_aux('x', 'y', event, 'event_mouse')

	def event_button0(self, event):
		return self._manage_event_aux('start_x', 'start_y', event, 'event_button0', 'x', 'y')

	def _search_active_zone(self, i, x, y):
		subzones = self._subzone_handlers
		inf = i - 1
		while inf >= 0:
			if subzones[inf].active:
				break
			inf -= 1
		else:
			inf = None
		sup = i + 1
		while sup < len(subzones):
			if subzones[sup].active:
				break
			sup += 1
		else:
			sup = None
		if inf is None:
			return self._remap_by_sup(x, y, subzones[sup])
		else:
			if sup is None:
				return self._remap_by_inf(x, y, subzones[inf])
		if i - inf < sup - i:
			return self._remap_by_inf(x, y, subzones[inf])
		else:
			return self._remap_by_sup(x, y, subzones[sup])
		return None

	def _remap_by_sup(self, x, y, newzone):
		if self._vertical:
			return (newzone, x, newzone.handler._zone[2])
		else:
			return (newzone, newzone.handler._zone[0], y)

	def _remap_by_inf(self, x, y, newzone):
		if self._vertical:
			return (newzone, x, newzone.handler._zone[3])
		else:
			return (newzone, newzone.handler._zone[1], y)



def split_zone(zone, parts, vertical):
	xmin, xmax, ymin, ymax = zone
	if vertical:
		def build_subzone(ymin, ymax):
			return (xmin, xmax, ymin, ymax)

		coordmin = ymin
		coordmax = ymax
	else:
		def build_subzone(xmin, xmax):
			return (xmin, xmax, ymin, ymax)

		coordmin = xmin
		coordmax = xmax
	lenght = (coordmax - coordmin) // parts
	coordmax = coordmin + lenght
	res = []
	for i in xrange(parts):
		res.append(build_subzone(coordmin, coordmax))
		coordmin = coordmax
		coordmax += lenght
	return res

]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb758068c>}
from __future__ import absolute_import
__all__ = ['UPSLIDER_ZONE', 'RIGHTSLIDER_ZONE', 'DOWNSLIDER_ZONE', 'ZonesMapEventHandler', 'SliderEventHandler', 'GridEventHandler', 'ButtonEventHandler', 'GestureEventHandler', 'TrickmodeSliderEventHandler', 'MultiZoneEventHandler', 'split_zone']
from peewee.debug import GET_LOGGER, PRINT_EXCEPTION
from peewee.notifier import Task
from pygui.config import HMI_BASE
log = GET_LOGGER(__name__)
UPSLIDER_ZONE = (0, 100, 0, 20)
RIGHTSLIDER_ZONE = (80, 100, 0, 100)
DOWNSLIDER_ZONE = (0, 100, 80, 100)
LEFTSLIDER_ZONE = (0, 20, 0, 100)
GRID_ZONE = (20, 80, 20, 80)
KBDGRID_ZONE = (20, 80, 20, 100)
UPLEFT_ZONE = (0, 20, 0, 20)
COMPLETE_ZONE = (0, 100, 0, 100)
THUMBNAIL_ZONE = (0, 100, 0, 80)
EPSILON = HMI_BASE['rcu_move_threshold']
GESTURE_THRESHOLD = HMI_BASE.get('rcu_gesture_threshold', 15.0)
LONGCLIC_THRESHOLD = HMI_BASE['rcu_longclic_threshold']
BUTTONS_REPEAT_TIMEOUT = HMI_BASE['rcu_buttons_repeat_timeout']
BUTTONS_REPEAT_DELAY = HMI_BASE['rcu_buttons_repeat_delay']
DEFAULT_MARGIN = HMI_BASE.get('rcu_default_margin', 10)
BUTTONS_CLICK_TIMEOUT = BUTTONS_REPEAT_DELAY + BUTTONS_REPEAT_DELAY / 10
class ZoneHandler(object):
	__slots__ = ('_handler', '_zone')
	def __init__(self, handler, zone):
		self._handler = handler
		self._zone = zone

	def __call__(self):
		self._handler(self._zone)



class ZonesMapEventHandler(object):
	__doc__ = ' Manage a set of handlers of zones.\n    A zone is a tuple (xmin , xmax, ymin, ymax), ie an axis-aligned bounding\n    box (AABB). Coordinates are between 0 and 100.\n    '
	def __init__(self, xseps=(20, 80), yseps=(20, 80)):
		seps = [0] + list(xseps) + [100]
		xzones = tuple(<genexpr>(xrange(len(seps) - 1)))
		self._xzones = xzones
		seps = [0] + list(yseps) + [100]
		yzones = tuple(<genexpr>(xrange(len(seps) - 1)))
		self._yzones = yzones

	def set_handler(self, column, line, handlers, zone=None):
		if zone is not None:
			pass
		zone = self.zones[column][line]

	def _manage_event(self, event):
		arg = event.arg
		x = arg['x']
		y = arg['y']
		yzones = self._yzones
		for column, xmin, xmax in self._xzones:
			if x < xmax:
				for line, ymin, ymax in yzones:
					if y < ymax:
						if event.name == 'MOUSE':
							handler = self._handlers[column][line][0]
						else:
							if event.name == 'BUTTON0':
								handler = self._handlers[column][line][1]
						if handler is not None:
							handler()
						return True
						continue
				else:
					continue
		return False

	def event_button1(self, event):
		if not hasattr(self, 'handle_button1'):
			return False
		self.handle_button1()
		return True

	event_mouse = _manage_event
	event_button0 = _manage_event


def compute_linear_coordinate(x, x0, x1):
	return 100 * (x - x0) / (x1 - x0)

def do_nothing(*args):
	return None

class ZoneEventHandler(object):
	def __init__(self, player, zone, margin=DEFAULT_MARGIN, pick_on_click=False):
		self.player = player
		if zone is not None:
			pass
		self._zone = (0, 0, 0, 0)
		self._margin = margin
		self._pick_on_click = pick_on_click
		self._button0_task = Task((lambda : None))
		self._button1_task = Task((lambda : None))
		self._button2_task = Task((lambda : None))
		self._button3_task = Task((lambda : None))
		self._button4_task = Task((lambda : None))
		self.handle_click = do_nothing
		self.handle_pressed = do_nothing
		self.handle_long_click = do_nothing
		return None

	def _check_zone(self, event, handler, xkey, ykey, remap_coord):
		arg = event.arg
		x = arg[xkey]
		y = arg[ykey]
		ret = self._in_zone(x, y)
		if ret:
			if remap_coord:
				zone = self._zone
				arg[xkey] = min(zone[1], max(zone[0], x))
				arg[ykey] = min(zone[3], max(zone[2], y))
			handler(arg)
		return ret

	def _in_zone(self, x, y):
		zone = self._zone
		margin = self._margin
		if zone[0] - margin <= x:
			pass
		else:
			x
		if zone[0] - margin <= x:
			if zone[2] - margin <= y:
				pass
			else:
				y
		return zone[0] - margin <= x

	def event_mouse(self, event):
		if not self._button0_task.running:
			return self._check_zone(event, self._manage_mouse, 'x', 'y', True)
		else:
			log.warn('%s Dropped because button0 task is running', event)
			return True

	def event_button0(self, event):
		return self._check_zone(event, self._manage_button0, 'start_x', 'start_y', False)

	def event_button1(self, event):
		if not hasattr(self, 'handle_button1'):
			return False
		self._manage_button1(event.arg)
		return True

	def event_button2(self, event):
		if not hasattr(self, 'handle_button2'):
			return False
		self._manage_button2(event.arg)
		return True

	def event_button3(self, event):
		if not hasattr(self, 'handle_button3'):
			return False
		self._manage_button3(event.arg)
		return True

	def event_button4(self, event):
		if not hasattr(self, 'handle_button4'):
			return False
		self._manage_button4(event.arg)
		return True

	def _manage_button0(self, event_arg):
		count = event_arg['count']
		if self.player._autohide_timeout:
			self.player._autohide_timeout.start()
		if self._pick_on_click:
			self._pick(event_arg)
		task = self._button0_task
		move_detected = self._check_button_move(event_arg)
		self.handle_pressed()
		if count < LONGCLIC_THRESHOLD and not move_detected:
			task.fn = self.handle_click
			task.args = ()
			task.start(BUTTONS_CLICK_TIMEOUT)
		else:
			task.fn = self._manage_long_click
			task.args = (event_arg,)
			task.start(BUTTONS_CLICK_TIMEOUT)

	def _manage_mouse(self, event_arg):
		if self.player._autohide_timeout:
			self.player._autohide_timeout.start()
		self._pick(event_arg)

	def _manage_button1(self, event_arg):
		self._button1_task.fn = self.handle_button1
		self._button1_task.start(BUTTONS_REPEAT_TIMEOUT)

	def _manage_button2(self, event_arg):
		self._button2_task.fn = self.handle_button2
		self._button2_task.start(BUTTONS_REPEAT_TIMEOUT)

	def _manage_button3(self, event_arg):
		self._button3_task.fn = self.handle_button3
		self._button3_task.start(BUTTONS_REPEAT_TIMEOUT)

	def _manage_button4(self, event_arg):
		self._button4_task.fn = self.handle_button4
		self._button4_task.start(BUTTONS_REPEAT_TIMEOUT)

	def _manage_long_click(self, event_arg):
		pass

	def _pick(self, event_arg):
		print 'ERROR: _pick() NOT IMPLEMENTED'

	def _check_button_move(self, event_arg):
		if not abs(event_arg['x'] - event_arg['start_x']) > EPSILON:
			pass
		return abs(event_arg['x'] - event_arg['start_x']) > EPSILON



def null_pick_coord(coord):
	return None

class SliderEventHandler(ZoneEventHandler):
	def __init__(self, player, zone, vertical=True, margin=DEFAULT_MARGIN, pick_on_click=False):
		ZoneEventHandler.__init__(self, player, zone, margin, pick_on_click)
		self._vertical = vertical
		self.handle_forward_click = do_nothing
		self.handle_backward_click = do_nothing
		self.handle_transversal_click = do_nothing
		self.handle_pick_coord = null_pick_coord

	def _pick(self, event_arg):
		zone = self._zone
		if self._vertical:
			coord = compute_linear_coordinate(event_arg['y'], zone[2], zone[3])
		else:
			coord = compute_linear_coordinate(event_arg['x'], zone[0], zone[1])
		self.handle_pick_coord(coord)

	def _manage_long_click(self, event_arg):
		majordiff = event_arg['x'] - event_arg['start_x']
		minordiff = event_arg['y'] - event_arg['start_y']
		if self._vertical:
			majordiff, minordiff = minordiff, majordiff
		abs_majordiff = abs(majordiff)
		abs_minordiff = abs(minordiff)
		log.debug('LONGCLIC: event_arg: %s abs_major=%s abs_minor=%s', event_arg, abs_majordiff, abs_minordiff)
		if abs_majordiff >= abs_minordiff:
			if abs_majordiff < EPSILON:
				self.handle_long_click()
			else:
				if majordiff > 0:
					self.handle_forward_click()
				else:
					self.handle_backward_click()
		else:
			if abs_minordiff < EPSILON:
				self.handle_long_click()
			else:
				self.handle_transversal_click()



def null_pick_x_y(x, y):
	return None

class GridEventHandler(ZoneEventHandler):
	def __init__(self, player, zone, vertical=True, margin=DEFAULT_MARGIN, pick_on_click=False):
		ZoneEventHandler.__init__(self, player, zone, margin, pick_on_click)
		self.handle_pick_x_y = null_pick_x_y

	def _pick(self, event_arg):
		zone = self._zone
		x = compute_linear_coordinate(event_arg['x'], zone[0], zone[1])
		y = compute_linear_coordinate(event_arg['y'], zone[2], zone[3])
		self.handle_pick_x_y(x, y)



class ButtonEventHandler(ZoneEventHandler):
	def __init__(self, player, zone, margin=DEFAULT_MARGIN, pick_on_click=False):
		ZoneEventHandler.__init__(self, player, zone, margin, pick_on_click)
		self.handle_hover = do_nothing

	def _manage_mouse(self, event_arg):
		if self.player._autohide_timeout:
			self.player._autohide_timeout.start()
		self.handle_hover()

	def _manage_long_click(self, event_arg):
		self.handle_click()



class GestureEventHandler(ZoneEventHandler):
	def __init__(self, player, zone, margin=DEFAULT_MARGIN, pick_on_click=True):
		ZoneEventHandler.__init__(self, player, zone, margin, pick_on_click)
		self.start_pos = []
		self.start_count = 0
		self.move_repeat_delay = HMI_BASE['rcu_move_repeat_delay']
		self.handle_x_gesture = do_nothing
		self.handle_y_gesture = do_nothing

	def _manage_mouse(self, event_arg):
		if event_arg['count'] == 1:
			self.start_pos = [event_arg['x'], event_arg['y']]
			self.start_count = 1
		else:
			if self.start_pos:
				x_diff = event_arg['x'] - self.start_pos[0]
				y_diff = event_arg['y'] - self.start_pos[1]
				count = event_arg['count'] - self.start_count
				abs_x_diff = abs(x_diff)
				abs_y_diff = abs(y_diff)
				callback = do_nothing
				if abs_x_diff >= abs_y_diff:
					majordiff = x_diff
					abs_majordiff = abs_x_diff
					callback = self.handle_x_gesture
				else:
					majordiff = y_diff
					abs_majordiff = abs_y_diff
					callback = self.handle_y_gesture
				if abs_majordiff > GESTURE_THRESHOLD:
					move = int(round(abs_majordiff / GESTURE_THRESHOLD))
					speed = abs_majordiff / count * self.move_repeat_delay
					if move >= 1:
						if majordiff > 0:
							pass
						move = -move
						callback(move, speed)
						self.start_pos = [event_arg['x'], event_arg['y']]
						self.start_count = event_arg['count']

	_manage_button0 = _manage_mouse


class TrickmodeSliderEventHandler(SliderEventHandler):
	def __init__(self, player, zone, vertical=True, margin=DEFAULT_MARGIN, pick_on_click=False):
		SliderEventHandler.__init__(self, player, zone, vertical, margin, pick_on_click)
		self.handle_released = do_nothing
		self.handle_pressed = do_nothing

	def _manage_button0(self, event_arg):
		count = event_arg['count']
		if self.player._autohide_timeout:
			self.player._autohide_timeout.start()
		self._pick(event_arg)
		self.handle_pressed()
		task = self._button0_task
		if count < LONGCLIC_THRESHOLD:
			pass
		task.fn = self.handle_released
		task.args = ()
		task.start(BUTTONS_REPEAT_TIMEOUT * 3)



class SubZoneHandler(object):
	__slots__ = ('handler', 'active')
	def __init__(self, handler, active=True):
		self.handler = handler
		self.active = active



class MultiZoneEventHandler(ZoneEventHandler):
	__doc__ = ' A ZoneEventHandler that manages several inner zones aligned horizontally or vertically.\n\n        Each zone has its own zone_event_handler (with event_mouse() and\n        event_button0()) and can be active or inactive. An inactive zone\n        forwards all events which are for it to the nearest active zone.\n        So there can be several active zones and several inactive zones.\n    '
	def __init__(self, player, zone, vertical=True, margin=DEFAULT_MARGIN, pick_on_click=False):
		ZoneEventHandler.__init__(self, player, zone, margin, pick_on_click)
		self._subzone_handlers = []
		self._vertical = vertical

	def add_subzone_handler(self, zone_event_handler, active=True):
		zone_event_handler._margin = 0
		self._subzone_handlers.append(SubZoneHandler(zone_event_handler, active))

	def set_subzone_active(self, zone_id, active):
		self._subzone_handlers[zone_id].active = active

	def _manage_event_aux(self, xkey, ykey, event, method_name, xkey2remap=None, ykey2remap=None):
		event_arg = event.arg
		x = event_arg[xkey]
		y = event_arg[ykey]
		if not self._in_zone(x, y):
			return False

	def event_mouse(self, event):
		return self._manage_event_aux('x', 'y', event, 'event_mouse')

	def event_button0(self, event):
		return self._manage_event_aux('start_x', 'start_y', event, 'event_button0', 'x', 'y')

	def _search_active_zone(self, i, x, y):
		subzones = self._subzone_handlers
		inf = i - 1
		while inf >= 0:
			if subzones[inf].active:
				break
			inf -= 1
		else:
			inf = None
		sup = i + 1
		while sup < len(subzones):
			if subzones[sup].active:
				break
			sup += 1
		else:
			sup = None
		if inf is None:
			return self._remap_by_sup(x, y, subzones[sup])
		else:
			if sup is None:
				return self._remap_by_inf(x, y, subzones[inf])
		if i - inf < sup - i:
			return self._remap_by_inf(x, y, subzones[inf])
		else:
			return self._remap_by_sup(x, y, subzones[sup])
		return None

	def _remap_by_sup(self, x, y, newzone):
		if self._vertical:
			return (newzone, x, newzone.handler._zone[2])
		else:
			return (newzone, newzone.handler._zone[0], y)

	def _remap_by_inf(self, x, y, newzone):
		if self._vertical:
			return (newzone, x, newzone.handler._zone[3])
		else:
			return (newzone, newzone.handler._zone[1], y)



def split_zone(zone, parts, vertical):
	xmin, xmax, ymin, ymax = zone
	if vertical:
		def build_subzone(ymin, ymax):
			return (xmin, xmax, ymin, ymax)

		coordmin = ymin
		coordmax = ymax
	else:
		def build_subzone(xmin, xmax):
			return (xmin, xmax, ymin, ymax)

		coordmin = xmin
		coordmax = xmax
	lenght = (coordmax - coordmin) // parts
	coordmax = coordmin + lenght
	res = []
	for i in xrange(parts):
		res.append(build_subzone(coordmin, coordmax))
		coordmin = coordmax
		coordmax += lenght
	return res

