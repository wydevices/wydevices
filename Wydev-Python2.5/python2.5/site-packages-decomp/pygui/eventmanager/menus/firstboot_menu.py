# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 202
n 202(None)[return True
]:
	i: 184(), 201()
	o: 

nname: 201
n 201(None)[]:
	i: 139&157(f)
	o: 202()

nname: 184
n 184(None)[self.player.back_previous()
]:
	i: 139&157(t)
	o: 202()

nname: 139&157
n 139&157(self.player.active_list == 'options1_list' and self.player.available_choices[idx - 1] == 'options0_list')[]:
	i: 121(), 138()
	o: 184(t), 201(f)

nname: 138
n 138(None)[]:
	i: 76&94(f)
	o: 139&157()

nname: 121
n 121(None)[self.player.back_previous()
]:
	i: 76&94(t)
	o: 139&157()

nname: 76&94
n 76&94(self.player.active_list == 'date0_list' and self.player.available_choices[idx - 1] == 'options4_list')[]:
	i: 45(), 62()
	o: 121(t), 138(f)

nname: 62
n 62(None)[self.player.back_previous()
]:
	i: 0(f)
	o: 76&94()

nname: 45
n 45(None)[self.player.focus_previous()
]:
	i: 0(t)
	o: 76&94()

nname: 0
n 0(self.player.active_list not in ('options0_list', 'aspect_ratio_list'))[idx = self.player.available_choices.index(self.player.active_list)
]:
	i: 
	o: 45(t), 62(f)

nname: 139&157
n 139&157(None)[if self.player.active_list == 'options1_list' and self.player.available_choices[idx - 1] == 'options0_list':
	self.player.back_previous()
return True
]:
	i: 0()
	o: 

nname: 0
n 0(None)[idx = self.player.available_choices.index(self.player.active_list)
if self.player.active_list not in ('options0_list', 'aspect_ratio_list'):
	self.player.focus_previous()
else:
	self.player.back_previous()
if self.player.active_list == 'date0_list' and self.player.available_choices[idx - 1] == 'options4_list':
	self.player.back_previous()
]:
	i: 
	o: 139&157()

nname: 0
n 0(None)[idx = self.player.available_choices.index(self.player.active_list)
if self.player.active_list not in ('options0_list', 'aspect_ratio_list'):
	self.player.focus_previous()
else:
	self.player.back_previous()
if self.player.active_list == 'date0_list' and self.player.available_choices[idx - 1] == 'options4_list':
	self.player.back_previous()
if self.player.active_list == 'options1_list' and self.player.available_choices[idx - 1] == 'options0_list':
	self.player.back_previous()
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7718e4c>}
nname: 184
n 184(None)[return True
]:
	i: 45(), 81(), 147(), 167()
	o: 

nname: 167
n 167(None)[self.player.selected.execute()
]:
	i: 101&120(f)
	o: 184()

nname: 147
n 147(None)[self.player.selected.execute()
]:
	i: 101&120(t)
	o: 184()

nname: 101&120
n 101&120(self.player.active_list == 'options4_list' and self.player.available_choices[idx + 1] == 'date0_list')[]:
	i: 62(f)
	o: 147(t), 167(f)

nname: 81
n 81(None)[self.player.selected.execute()
]:
	i: 62(t)
	o: 184()

nname: 62
n 62(self.player.active_list == 'date4_list')[]:
	i: 0(f)
	o: 81(t), 101&120(f)

nname: 45
n 45(None)[self.player.focus_next()
]:
	i: 0(t)
	o: 184()

nname: 0
n 0(self.player.active_list not in ('options0_list', 'date4_list', 'options4_list', 'aspect_ratio_list'))[idx = self.player.available_choices.index(self.player.active_list)
]:
	i: 
	o: 45(t), 62(f)

nname: 0
n 0(None)[idx = self.player.available_choices.index(self.player.active_list)
if self.player.active_list not in ('options0_list', 'date4_list', 'options4_list', 'aspect_ratio_list'):
	self.player.focus_next()
else:
	if self.player.active_list == 'date4_list':
		self.player.selected.execute()
	else:
		if self.player.active_list == 'options4_list' and self.player.available_choices[idx + 1] == 'date0_list':
			self.player.selected.execute()
		else:
			self.player.selected.execute()
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb771834c>}
nname: 56
n 56(None)[return True
]:
	i: 15(), 39()
	o: 

nname: 39
n 39(None)[MenuEventHandler.event_up(self, event)
]:
	i: 0(f)
	o: 56()

nname: 15
n 15(None)[self._move(event.arg['count'])
]:
	i: 0(t)
	o: 56()

nname: 0
n 0(self.player.is_reversed())[]:
	i: 
	o: 15(t), 39(f)

nname: 0
n 0(None)[if self.player.is_reversed():
	self._move(event.arg['count'])
else:
	MenuEventHandler.event_up(self, event)
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb771806c>}
nname: 57
n 57(None)[return True
]:
	i: 15(), 40()
	o: 

nname: 40
n 40(None)[MenuEventHandler.event_down(self, event)
]:
	i: 0(f)
	o: 57()

nname: 15
n 15(None)[self._move(-event.arg['count'])
]:
	i: 0(t)
	o: 57()

nname: 0
n 0(self.player.is_reversed())[]:
	i: 
	o: 15(t), 40(f)

nname: 0
n 0(None)[if self.player.is_reversed():
	self._move(-event.arg['count'])
else:
	MenuEventHandler.event_down(self, event)
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7718c8c>}
nname: 0
n 0(None)[self.player.selected.execute()
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb77183cc>}
nname: 0
n 0(None)[return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb77185ac>}
nname: 0
n 0(None)[return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb77183cc>}
nname: 0
n 0(None)[self.player.back_previous()
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb77187ac>}
nname: 6
n 6(None)[def event_left(self, event):
	idx = self.player.available_choices.index(self.player.active_list)
	if self.player.active_list not in ('options0_list', 'aspect_ratio_list'):
		self.player.focus_previous()
	else:
		self.player.back_previous()
	if self.player.active_list == 'date0_list' and self.player.available_choices[idx - 1] == 'options4_list':
		self.player.back_previous()
	if self.player.active_list == 'options1_list' and self.player.available_choices[idx - 1] == 'options0_list':
		self.player.back_previous()
	return True

def event_right(self, event):
	idx = self.player.available_choices.index(self.player.active_list)
	if self.player.active_list not in ('options0_list', 'date4_list', 'options4_list', 'aspect_ratio_list'):
		self.player.focus_next()
	else:
		if self.player.active_list == 'date4_list':
			self.player.selected.execute()
		else:
			if self.player.active_list == 'options4_list' and self.player.available_choices[idx + 1] == 'date0_list':
				self.player.selected.execute()
			else:
				self.player.selected.execute()
	return True

def event_up(self, event):
	if self.player.is_reversed():
		self._move(event.arg['count'])
	else:
		MenuEventHandler.event_up(self, event)
	return True

def event_down(self, event):
	if self.player.is_reversed():
		self._move(-event.arg['count'])
	else:
		MenuEventHandler.event_down(self, event)
	return True

def event_select(self, event):
	self.player.selected.execute()
	return True

def event_home(self, event):
	return True

def event_toggle_menu(self, event):
	return True

def event_stop(self, event):
	self.player.back_previous()
	return True

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb770de2c>}
nname: 0
n 0(None)[self.player.execute()
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb770df0c>}
nname: 0
n 0(None)[pygui_globs['menustack'].back_one_menu()
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb770dc8c>}
nname: 6
n 6(None)[def event_select(self, event):
	self.player.execute()
	return True

def event_stop(self, event):
	pygui_globs['menustack'].back_one_menu()
	return True

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb770d86c>}
nname: 0
n 0(None)[self.player.execute()
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb770d5ec>}
nname: 0
n 0(None)[pygui_globs['menustack'].back_one_menu()
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb770da6c>}
nname: 6
n 6(None)[def event_select(self, event):
	self.player.execute()
	return True

def event_stop(self, event):
	pygui_globs['menustack'].back_one_menu()
	return True

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb770d80c>}
nname: 0
n 0(None)[from .core import MenuEventHandler
from pygui.shared import pygui_globs
class FirstBootMenuEventHandler(MenuEventHandler):
	def event_left(self, event):
		idx = self.player.available_choices.index(self.player.active_list)
		if self.player.active_list not in ('options0_list', 'aspect_ratio_list'):
			self.player.focus_previous()
		else:
			self.player.back_previous()
		if self.player.active_list == 'date0_list' and self.player.available_choices[idx - 1] == 'options4_list':
			self.player.back_previous()
		if self.player.active_list == 'options1_list' and self.player.available_choices[idx - 1] == 'options0_list':
			self.player.back_previous()
		return True

	def event_right(self, event):
		idx = self.player.available_choices.index(self.player.active_list)
		if self.player.active_list not in ('options0_list', 'date4_list', 'options4_list', 'aspect_ratio_list'):
			self.player.focus_next()
		else:
			if self.player.active_list == 'date4_list':
				self.player.selected.execute()
			else:
				if self.player.active_list == 'options4_list' and self.player.available_choices[idx + 1] == 'date0_list':
					self.player.selected.execute()
				else:
					self.player.selected.execute()
		return True

	def event_up(self, event):
		if self.player.is_reversed():
			self._move(event.arg['count'])
		else:
			MenuEventHandler.event_up(self, event)
		return True

	def event_down(self, event):
		if self.player.is_reversed():
			self._move(-event.arg['count'])
		else:
			MenuEventHandler.event_down(self, event)
		return True

	def event_select(self, event):
		self.player.selected.execute()
		return True

	def event_home(self, event):
		return True

	def event_toggle_menu(self, event):
		return True

	def event_stop(self, event):
		self.player.back_previous()
		return True



class DateSetupMenuEventHandler(FirstBootMenuEventHandler):
	def event_select(self, event):
		self.player.execute()
		return True

	def event_stop(self, event):
		pygui_globs['menustack'].back_one_menu()
		return True



class TimeZoneMenuEventHandler(MenuEventHandler):
	def event_select(self, event):
		self.player.execute()
		return True

	def event_stop(self, event):
		pygui_globs['menustack'].back_one_menu()
		return True



]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7704eec>}
from .core import MenuEventHandler
from pygui.shared import pygui_globs
class FirstBootMenuEventHandler(MenuEventHandler):
	def event_left(self, event):
		idx = self.player.available_choices.index(self.player.active_list)
		if self.player.active_list not in ('options0_list', 'aspect_ratio_list'):
			self.player.focus_previous()
		else:
			self.player.back_previous()
		if self.player.active_list == 'date0_list' and self.player.available_choices[idx - 1] == 'options4_list':
			self.player.back_previous()
		if self.player.active_list == 'options1_list' and self.player.available_choices[idx - 1] == 'options0_list':
			self.player.back_previous()
		return True

	def event_right(self, event):
		idx = self.player.available_choices.index(self.player.active_list)
		if self.player.active_list not in ('options0_list', 'date4_list', 'options4_list', 'aspect_ratio_list'):
			self.player.focus_next()
		else:
			if self.player.active_list == 'date4_list':
				self.player.selected.execute()
			else:
				if self.player.active_list == 'options4_list' and self.player.available_choices[idx + 1] == 'date0_list':
					self.player.selected.execute()
				else:
					self.player.selected.execute()
		return True

	def event_up(self, event):
		if self.player.is_reversed():
			self._move(event.arg['count'])
		else:
			MenuEventHandler.event_up(self, event)
		return True

	def event_down(self, event):
		if self.player.is_reversed():
			self._move(-event.arg['count'])
		else:
			MenuEventHandler.event_down(self, event)
		return True

	def event_select(self, event):
		self.player.selected.execute()
		return True

	def event_home(self, event):
		return True

	def event_toggle_menu(self, event):
		return True

	def event_stop(self, event):
		self.player.back_previous()
		return True



class DateSetupMenuEventHandler(FirstBootMenuEventHandler):
	def event_select(self, event):
		self.player.execute()
		return True

	def event_stop(self, event):
		pygui_globs['menustack'].back_one_menu()
		return True



class TimeZoneMenuEventHandler(MenuEventHandler):
	def event_select(self, event):
		self.player.execute()
		return True

	def event_stop(self, event):
		pygui_globs['menustack'].back_one_menu()
		return True



