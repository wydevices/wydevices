# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 70
n 70(None)[return EventDispatcher.event_home(self, event)
]:
	i: 0(AL), 69()
	o: 

nname: 69
n 69(None)[]:
	i: 19(AF), 65()
	o: 70()

nname: 65
n 65(None)[]:
	i: 39(f), 57()
	o: 69()

nname: 57
n 57(None)[return True
continue
]:
	i: 39(t)
	o: 65()

nname: 39
n 39(isinstance(menu, FirstBootMenu))[for menu in reversed(pygui_globs['menustack'].menus_stack):
]:
	i: 19(for)
	o: 57(t), 65(f)

nname: 19
n 19(None)[]:
	i: 0(loop)
	o: 39(for), 69(AF)

nname: 0
n 0(None)[from pygui.menu.menu.firstboot import FirstBootMenu
]:
	i: 
	o: 19(loop), 70(AL)

nname: 70
n 70(None)[return EventDispatcher.event_home(self, event)
]:
	i: 0(AL), 19(AF), 39()
	o: 

nname: 39
n 39(None)[for menu in reversed(pygui_globs['menustack'].menus_stack):
if isinstance(menu, FirstBootMenu):
	return True
	continue
]:
	i: 19(for)
	o: 70()

nname: 19
n 19(None)[]:
	i: 0(loop)
	o: 39(for), 70(AF)

nname: 0
n 0(None)[from pygui.menu.menu.firstboot import FirstBootMenu
]:
	i: 
	o: 19(loop), 70(AL)

nname: 39
n 39(None)[for menu in reversed(pygui_globs['menustack'].menus_stack):
	if isinstance(menu, FirstBootMenu):
		return True
		continue
return EventDispatcher.event_home(self, event)
]:
	i: 0(for)
	o: 

nname: 0
n 0(None)[from pygui.menu.menu.firstboot import FirstBootMenu
]:
	i: 
	o: 39(for)

nname: 0
n 0(None)[from pygui.menu.menu.firstboot import FirstBootMenu
for menu in reversed(pygui_globs['menustack'].menus_stack):
	if isinstance(menu, FirstBootMenu):
		return True
		continue
return EventDispatcher.event_home(self, event)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb760134c>}
nname: 6
n 6(None)[def event_home(self, event):
	from pygui.menu.menu.firstboot import FirstBootMenu
	for menu in reversed(pygui_globs['menustack'].menus_stack):
		if isinstance(menu, FirstBootMenu):
			return True
			continue
	return EventDispatcher.event_home(self, event)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75ffb8c>}
nname: 0
n 0(None)[return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76017ec>}
nname: 73
n 73(None)[return True
]:
	i: 55(), 72()
	o: 

nname: 72
n 72(None)[]:
	i: 36(f)
	o: 73()

nname: 55
n 55(None)[play.button.emit()
]:
	i: 36(t)
	o: 73()

nname: 36
n 36(play.button)[play.hide()
]:
	i: 18(), 35()
	o: 55(t), 72(f)

nname: 35
n 35(None)[]:
	i: 0(f)
	o: 36()

nname: 18
n 18(None)[play._timeout_timer.stop()
]:
	i: 0(t)
	o: 36()

nname: 0
n 0(play._timeout_timer)[play = self.player
]:
	i: 
	o: 18(t), 35(f)

nname: 73
n 73(None)[return True
]:
	i: 0()
	o: 

nname: 0
n 0(None)[play = self.player
if play._timeout_timer:
	play._timeout_timer.stop()
play.hide()
if play.button:
	play.button.emit()
]:
	i: 
	o: 73()

nname: 0
n 0(None)[play = self.player
if play._timeout_timer:
	play._timeout_timer.stop()
play.hide()
if play.button:
	play.button.emit()
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7601d8c>}
nname: 54
n 54(None)[play.hide()
play.timeout_callback()
return True
]:
	i: 36(), 53()
	o: 

nname: 53
n 53(None)[]:
	i: 27(f)
	o: 54()

nname: 36
n 36(None)[play._timeout_timer.stop()
]:
	i: 27(t)
	o: 54()

nname: 27
n 27(play._timeout_timer)[]:
	i: 18(), 26()
	o: 36(t), 53(f)

nname: 26
n 26(None)[]:
	i: 0(t)
	o: 27()

nname: 18
n 18(None)[return False
]:
	i: 0(f)
	o: 27()

nname: 0
n 0(play.timeout_callback)[play = self.player
]:
	i: 
	o: 18(f), 26(t)

nname: 54
n 54(None)[play.hide()
play.timeout_callback()
return True
]:
	i: 0()
	o: 

nname: 0
n 0(None)[play = self.player
if not play.timeout_callback:
	return False
if play._timeout_timer:
	play._timeout_timer.stop()
]:
	i: 
	o: 54()

nname: 0
n 0(None)[play = self.player
if not play.timeout_callback:
	return False
if play._timeout_timer:
	play._timeout_timer.stop()
play.hide()
play.timeout_callback()
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7601e4c>}
nname: 6
n 6(None)[def catch_event(self, event):
	return True

event_left, event_right, event_up, event_down, event_wheel_rwd, event_wheel_fwd = catch_event, catch_event, catch_event, catch_event, catch_event, catch_event
def event_select(self, event):
	play = self.player
	if play._timeout_timer:
		play._timeout_timer.stop()
	play.hide()
	if play.button:
		play.button.emit()
	return True

def event_stop(self, event):
	play = self.player
	if not play.timeout_callback:
		return False
	if play._timeout_timer:
		play._timeout_timer.stop()
	play.hide()
	play.timeout_callback()
	return True

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75ffeac>}
nname: 83
n 83(None)[return True
]:
	i: 22(JA), 46(JA), 79(), 82()
	o: 

nname: 82
n 82(None)[]:
	i: 0(f)
	o: 83()

nname: 79
n 79(None)[]:
	i: 77(AE)
	o: 83()

nname: 77
n 77(None)[]:
	i: 36(f)
	o: 79(AE)

nname: 46
n 46(None)[#, e
log.error('Cancel action failed: %s', str(e))
]:
	i: 36(t)
	o: 83(JA)

nname: 36
n 36(<dummy_ex3> EXC_MATCH Exception)[]:
	i: 18(except)
	o: 46(t), 77(f)

nname: 22
n 22(None)[play._cancel_fn()
]:
	i: 18(try)
	o: 83(JA)

nname: 18
n 18(None)[]:
	i: 0(t)
	o: 22(try), 36(except)

nname: 0
n 0(play._cancel_fn)[play = self.player
]:
	i: 
	o: 18(t), 82(f)

nname: 83
n 83(None)[return True
]:
	i: 22(JA), 46(JA), 36(f), 77(AE), 0(f)
	o: 

nname: 46
n 46(None)[#, e
log.error('Cancel action failed: %s', str(e))
]:
	i: 36(t)
	o: 83(JA)

nname: 36
n 36(<dummy_ex3> EXC_MATCH Exception)[]:
	i: 18(except)
	o: 46(t), 83(f)

nname: 22
n 22(None)[play._cancel_fn()
]:
	i: 18(try)
	o: 83(JA)

nname: 18
n 18(None)[]:
	i: 0(t)
	o: 22(try), 36(except)

nname: 0
n 0(play._cancel_fn)[play = self.player
]:
	i: 
	o: 18(t), 83(f)

nname: 83
n 83(None)[return True
]:
	i: 36(f), 0(f)
	o: 

nname: 36
n 36(None)[except Exception, e:
	log.error('Cancel action failed: %s', str(e))
]:
	i: 18()
	o: 83(JA)

nname: 18
n 18(None)[try:
	play._cancel_fn()
]:
	i: 0(t)
	o: 36()

nname: 0
n 0(play._cancel_fn)[play = self.player
]:
	i: 
	o: 18(t), 83(f)

nname: 83
n 83(None)[return True
]:
	i: 18(f), 0(f)
	o: 

nname: 18
n 18(None)[try:
	play._cancel_fn()
except Exception, e:
	log.error('Cancel action failed: %s', str(e))
]:
	i: 0(t)
	o: 83(JA)

nname: 0
n 0(play._cancel_fn)[play = self.player
]:
	i: 
	o: 18(t), 83(f)

nname: 0
n 0(None)[play = self.player
if play._cancel_fn:
	try:
		play._cancel_fn()
	except Exception, e:
		log.error('Cancel action failed: %s', str(e))
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76013ac>}
nname: 6
n 6(None)[def event_stop(self, event):
	play = self.player
	if play._cancel_fn:
		try:
			play._cancel_fn()
		except Exception, e:
			log.error('Cancel action failed: %s', str(e))
	return True

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75ffc4c>}
nname: 0
n 0(None)[return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75ffeac>}
nname: 6
n 6(None)[def event_home(self, event):
	return True

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75ffa2c>}
nname: 67
n 67(None)[pygui_globs['menustack'].update_window(play)
return True
]:
	i: 42(), 66()
	o: 

nname: 66
n 66(None)[]:
	i: 0(f)
	o: 67()

nname: 42
n 42(None)[play.selected = play.buttons[sel_idx - 1]
]:
	i: 0(t)
	o: 67()

nname: 0
n 0(sel_idx > 0)[play = self.player
sel_idx = play.buttons.index(play.selected)
]:
	i: 
	o: 42(t), 66(f)

nname: 0
n 0(None)[play = self.player
sel_idx = play.buttons.index(play.selected)
if sel_idx > 0:
	play.selected = play.buttons[sel_idx - 1]
pygui_globs['menustack'].update_window(play)
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76017ec>}
nname: 86
n 86(None)[pygui_globs['menustack'].update_window(play)
return True
]:
	i: 61(), 85()
	o: 

nname: 85
n 85(None)[]:
	i: 0(f)
	o: 86()

nname: 61
n 61(None)[play.selected = play.buttons[sel_idx + 1]
]:
	i: 0(t)
	o: 86()

nname: 0
n 0(sel_idx < max_idx)[play = self.player
sel_idx = play.buttons.index(play.selected)
max_idx = len(play.buttons) - 1
]:
	i: 
	o: 61(t), 85(f)

nname: 0
n 0(None)[play = self.player
sel_idx = play.buttons.index(play.selected)
max_idx = len(play.buttons) - 1
if sel_idx < max_idx:
	play.selected = play.buttons[sel_idx + 1]
pygui_globs['menustack'].update_window(play)
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb760156c>}
nname: 0
n 0(None)[self.player.hide()
self.player.selected.emit()
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb760110c>}
nname: 0
n 0(None)[return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76011ac>}
nname: 6
n 6(None)[def event_left(self, event):
	play = self.player
	sel_idx = play.buttons.index(play.selected)
	if sel_idx > 0:
		play.selected = play.buttons[sel_idx - 1]
	pygui_globs['menustack'].update_window(play)
	return True

def event_right(self, event):
	play = self.player
	sel_idx = play.buttons.index(play.selected)
	max_idx = len(play.buttons) - 1
	if sel_idx < max_idx:
		play.selected = play.buttons[sel_idx + 1]
	pygui_globs['menustack'].update_window(play)
	return True

def event_select(self, event):
	self.player.hide()
	self.player.selected.emit()
	return True

def event_stop(self, event):
	return True

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75ffd8c>}
nname: 0
n 0(None)[self.player.hide()
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75fff4c>}
nname: 6
n 6(None)[def event_stop(self, event):
	self.player.hide()
	return True

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75ffeac>}
nname: 0
n 0(None)[EventDispatcher.__call__(self, event)
pygui_globs['menustack'].update_window(self.player)
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76018ec>}
nname: 0
n 0(None)[sel_idx = self.player.buttons.index(self.player.selected)
self.player.selected = self.player.buttons[sel_idx - 1]
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76015ec>}
nname: 0
n 0(None)[sel_idx = self.player.buttons.index(self.player.selected)
nb_elts = len(self.player.buttons)
new_idx = (sel_idx + 1) % nb_elts
self.player.selected = self.player.buttons[new_idx]
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76014ac>}
nname: 166
n 166(None)[return True
]:
	i: 100(), 143()
	o: 

nname: 143
n 143(None)[self.player.selected = self.player.buttons[new_sel]
]:
	i: 0&71(f)
	o: 166()

nname: 100
n 100(None)[self.player.selected = self.player.buttons[-len(self.player.action_buttons) - 1]
]:
	i: 0&71(t)
	o: 166()

nname: 0&71
n 0&71(self.player.buttons[sel_idx] in self.player.action_buttons and self.player.buttons[new_sel] not in self.player.action_buttons)[sel_idx = self.player.buttons.index(self.player.selected)
new_sel = sel_idx - self.player.columns
]:
	i: 
	o: 100(t), 143(f)

nname: 0&71
n 0&71(None)[sel_idx = self.player.buttons.index(self.player.selected)
new_sel = sel_idx - self.player.columns
if self.player.buttons[sel_idx] in self.player.action_buttons and self.player.buttons[new_sel] not in self.player.action_buttons:
	self.player.selected = self.player.buttons[-len(self.player.action_buttons) - 1]
else:
	self.player.selected = self.player.buttons[new_sel]
return True
]:
	i: 
	o: 

self.nodes: {'0&71': <unpyclib.structure.node instance at 0xb76054cc>}
nname: 184
n 184(None)[return True
]:
	i: 135(), 161()
	o: 

nname: 161
n 161(None)[self.player.selected = self.player.buttons[new_sel]
]:
	i: 0&93&106(f)
	o: 184()

nname: 135
n 135(None)[self.player.selected = self.player.action_buttons[0]
]:
	i: 0&93&106(t)
	o: 184()

nname: 0&93&106
n 0&93&106(self.player.buttons[sel_idx] not in self.player.action_buttons and (new_sel < sel_idx or self.player.buttons[new_sel] in self.player.action_buttons))[sel_idx = self.player.buttons.index(self.player.selected)
nb_elts = len(self.player.buttons)
new_sel = (sel_idx + self.player.columns) % nb_elts
]:
	i: 
	o: 135(t), 161(f)

nname: 0&93&106
n 0&93&106(None)[sel_idx = self.player.buttons.index(self.player.selected)
nb_elts = len(self.player.buttons)
new_sel = (sel_idx + self.player.columns) % nb_elts
if self.player.buttons[sel_idx] not in self.player.action_buttons and (new_sel < sel_idx or self.player.buttons[new_sel] in self.player.action_buttons):
	self.player.selected = self.player.action_buttons[0]
else:
	self.player.selected = self.player.buttons[new_sel]
return True
]:
	i: 
	o: 

self.nodes: {'0&93&106': <unpyclib.structure.node instance at 0xb7605e0c>}
nname: 0
n 0(None)[self.player.selected.emit()
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76011ec>}
nname: 0
n 0(None)[self.player._text_cursor_pos = max(self.player._text_cursor_pos - 1, 0)
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb760168c>}
nname: 0
n 0(None)[self.player._text_cursor_pos = min(self.player._text_cursor_pos + 1, len(self.player.text))
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76018ec>}
nname: 0
n 0(None)[idx = self.player.buttons.index(self.player.selected)
self.player.selected = None
self.player.change_special_char(-1)
self.player.selected = self.player.buttons[idx]
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76014ac>}
nname: 0
n 0(None)[idx = self.player.buttons.index(self.player.selected)
self.player.selected = None
self.player.change_special_char()
self.player.selected = self.player.buttons[idx]
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb760152c>}
nname: 0
n 0(None)[self.player.delete_char()
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7601a8c>}
nname: 6
n 6(None)[def __call__(self, event):
	EventDispatcher.__call__(self, event)
	pygui_globs['menustack'].update_window(self.player)
	return True

def event_left(self, event):
	sel_idx = self.player.buttons.index(self.player.selected)
	self.player.selected = self.player.buttons[sel_idx - 1]
	return True

def event_right(self, event):
	sel_idx = self.player.buttons.index(self.player.selected)
	nb_elts = len(self.player.buttons)
	new_idx = (sel_idx + 1) % nb_elts
	self.player.selected = self.player.buttons[new_idx]
	return True

def event_up(self, event):
	sel_idx = self.player.buttons.index(self.player.selected)
	new_sel = sel_idx - self.player.columns
	if self.player.buttons[sel_idx] in self.player.action_buttons and self.player.buttons[new_sel] not in self.player.action_buttons:
		self.player.selected = self.player.buttons[-len(self.player.action_buttons) - 1]
	else:
		self.player.selected = self.player.buttons[new_sel]
	return True

def event_down(self, event):
	sel_idx = self.player.buttons.index(self.player.selected)
	nb_elts = len(self.player.buttons)
	new_sel = (sel_idx + self.player.columns) % nb_elts
	if self.player.buttons[sel_idx] not in self.player.action_buttons and (new_sel < sel_idx or self.player.buttons[new_sel] in self.player.action_buttons):
		self.player.selected = self.player.action_buttons[0]
	else:
		self.player.selected = self.player.buttons[new_sel]
	return True

def event_select(self, event):
	self.player.selected.emit()
	return True

def event_wheel_rwd(self, event):
	self.player._text_cursor_pos = max(self.player._text_cursor_pos - 1, 0)
	return True

def event_wheel_fwd(self, event):
	self.player._text_cursor_pos = min(self.player._text_cursor_pos + 1, len(self.player.text))
	return True

def event_marker(self, event):
	idx = self.player.buttons.index(self.player.selected)
	self.player.selected = None
	self.player.change_special_char(-1)
	self.player.selected = self.player.buttons[idx]
	return True

def event_action_menu(self, event):
	idx = self.player.buttons.index(self.player.selected)
	self.player.selected = None
	self.player.change_special_char()
	self.player.selected = self.player.buttons[idx]
	return True

def event_stop(self, event):
	self.player.delete_char()
	return True

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75fff8c>}
nname: 0
n 0(None)[self.player.hide()
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75ffeec>}
nname: 6
n 6(None)[def event_toggle_menu(self, event):
	self.player.hide()
	return True

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75ffd8c>}
nname: 0
n 0(None)[self.player.hide(hide_search_menu=True)
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75fff0c>}
nname: 6
n 6(None)[def event_action_menu(self, event):
	self.player.hide(hide_search_menu=True)
	return True

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75ff9cc>}
nname: 0
n 0(None)[KeyboardEventHandler.__init__(self, player)
self.num_buttons = num_buttons
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7601f6c>}
nname: 93
n 93(None)[return True
]:
	i: 59(), 92()
	o: 

nname: 92
n 92(None)[]:
	i: 56(f)
	o: 93()

nname: 59
n 59(None)[self.player.selected.upper()
self.player.update()
]:
	i: 56(t)
	o: 93()

nname: 56
n 56(0 <= sel_idx)[]:
	i: 41(), 54()
	o: 59(t), 92(f)

nname: 54
n 54(None)[sel_idx
]:
	i: 0(f)
	o: 56()

nname: 41
n 41(None)[]:
	i: 0(t)
	o: 56()

nname: 0
n 0(0 <= sel_idx)[sel_idx = self.player.buttons.index(self.player.selected)
]:
	i: 
	o: 41(t), 54(f)

nname: 93
n 93(None)[return True
]:
	i: 0()
	o: 

nname: 0
n 0(None)[sel_idx = self.player.buttons.index(self.player.selected)
if 0 <= sel_idx:
	pass
else:
	sel_idx
if 0 <= sel_idx:
	self.player.selected.upper()
	self.player.update()
]:
	i: 
	o: 93()

nname: 0
n 0(None)[sel_idx = self.player.buttons.index(self.player.selected)
if 0 <= sel_idx:
	pass
else:
	sel_idx
if 0 <= sel_idx:
	self.player.selected.upper()
	self.player.update()
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76011ac>}
nname: 93
n 93(None)[return True
]:
	i: 59(), 92()
	o: 

nname: 92
n 92(None)[]:
	i: 56(f)
	o: 93()

nname: 59
n 59(None)[self.player.selected.lower()
self.player.update()
]:
	i: 56(t)
	o: 93()

nname: 56
n 56(0 <= sel_idx)[]:
	i: 41(), 54()
	o: 59(t), 92(f)

nname: 54
n 54(None)[sel_idx
]:
	i: 0(f)
	o: 56()

nname: 41
n 41(None)[]:
	i: 0(t)
	o: 56()

nname: 0
n 0(0 <= sel_idx)[sel_idx = self.player.buttons.index(self.player.selected)
]:
	i: 
	o: 41(t), 54(f)

nname: 93
n 93(None)[return True
]:
	i: 0()
	o: 

nname: 0
n 0(None)[sel_idx = self.player.buttons.index(self.player.selected)
if 0 <= sel_idx:
	pass
else:
	sel_idx
if 0 <= sel_idx:
	self.player.selected.lower()
	self.player.update()
]:
	i: 
	o: 93()

nname: 0
n 0(None)[sel_idx = self.player.buttons.index(self.player.selected)
if 0 <= sel_idx:
	pass
else:
	sel_idx
if 0 <= sel_idx:
	self.player.selected.lower()
	self.player.update()
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb760166c>}
nname: 6
n 6(None)[def __init__(self, num_buttons, player):
	KeyboardEventHandler.__init__(self, player)
	self.num_buttons = num_buttons

def event_up(self, event):
	sel_idx = self.player.buttons.index(self.player.selected)
	if 0 <= sel_idx:
		pass
	else:
		sel_idx
	if 0 <= sel_idx:
		self.player.selected.upper()
		self.player.update()
	return True

def event_down(self, event):
	sel_idx = self.player.buttons.index(self.player.selected)
	if 0 <= sel_idx:
		pass
	else:
		sel_idx
	if 0 <= sel_idx:
		self.player.selected.lower()
		self.player.update()
	return True

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75fff4c>}
nname: 0
n 0(None)[from __future__ import absolute_import
from pygui.eventmanager import EventDispatcher
from pygui.shared import pygui_globs
from peewee.debug import GET_LOGGER
log = GET_LOGGER(__name__)
class WindowEventHandler(EventDispatcher):
	def event_home(self, event):
		from pygui.menu.menu.firstboot import FirstBootMenu
		for menu in reversed(pygui_globs['menustack'].menus_stack):
			if isinstance(menu, FirstBootMenu):
				return True
				continue
		return EventDispatcher.event_home(self, event)



class MessageEventHandler(WindowEventHandler):
	def catch_event(self, event):
		return True

	event_left, event_right, event_up, event_down, event_wheel_rwd, event_wheel_fwd = catch_event, catch_event, catch_event, catch_event, catch_event, catch_event
	def event_select(self, event):
		play = self.player
		if play._timeout_timer:
			play._timeout_timer.stop()
		play.hide()
		if play.button:
			play.button.emit()
		return True

	def event_stop(self, event):
		play = self.player
		if not play.timeout_callback:
			return False
		if play._timeout_timer:
			play._timeout_timer.stop()
		play.hide()
		play.timeout_callback()
		return True



class CancelOnlyEventHandler(WindowEventHandler):
	def event_stop(self, event):
		play = self.player
		if play._cancel_fn:
			try:
				play._cancel_fn()
			except Exception, e:
				log.error('Cancel action failed: %s', str(e))
		return True



class NoHomeEventHandler(CancelOnlyEventHandler):
	def event_home(self, event):
		return True



class ButtonListEventHandler(WindowEventHandler):
	def event_left(self, event):
		play = self.player
		sel_idx = play.buttons.index(play.selected)
		if sel_idx > 0:
			play.selected = play.buttons[sel_idx - 1]
		pygui_globs['menustack'].update_window(play)
		return True

	def event_right(self, event):
		play = self.player
		sel_idx = play.buttons.index(play.selected)
		max_idx = len(play.buttons) - 1
		if sel_idx < max_idx:
			play.selected = play.buttons[sel_idx + 1]
		pygui_globs['menustack'].update_window(play)
		return True

	def event_select(self, event):
		self.player.hide()
		self.player.selected.emit()
		return True

	def event_stop(self, event):
		return True



class DismissableButtonListEventHandler(ButtonListEventHandler):
	def event_stop(self, event):
		self.player.hide()
		return True



class KeyboardEventHandler(WindowEventHandler):
	def __call__(self, event):
		EventDispatcher.__call__(self, event)
		pygui_globs['menustack'].update_window(self.player)
		return True

	def event_left(self, event):
		sel_idx = self.player.buttons.index(self.player.selected)
		self.player.selected = self.player.buttons[sel_idx - 1]
		return True

	def event_right(self, event):
		sel_idx = self.player.buttons.index(self.player.selected)
		nb_elts = len(self.player.buttons)
		new_idx = (sel_idx + 1) % nb_elts
		self.player.selected = self.player.buttons[new_idx]
		return True

	def event_up(self, event):
		sel_idx = self.player.buttons.index(self.player.selected)
		new_sel = sel_idx - self.player.columns
		if self.player.buttons[sel_idx] in self.player.action_buttons and self.player.buttons[new_sel] not in self.player.action_buttons:
			self.player.selected = self.player.buttons[-len(self.player.action_buttons) - 1]
		else:
			self.player.selected = self.player.buttons[new_sel]
		return True

	def event_down(self, event):
		sel_idx = self.player.buttons.index(self.player.selected)
		nb_elts = len(self.player.buttons)
		new_sel = (sel_idx + self.player.columns) % nb_elts
		if self.player.buttons[sel_idx] not in self.player.action_buttons and (new_sel < sel_idx or self.player.buttons[new_sel] in self.player.action_buttons):
			self.player.selected = self.player.action_buttons[0]
		else:
			self.player.selected = self.player.buttons[new_sel]
		return True

	def event_select(self, event):
		self.player.selected.emit()
		return True

	def event_wheel_rwd(self, event):
		self.player._text_cursor_pos = max(self.player._text_cursor_pos - 1, 0)
		return True

	def event_wheel_fwd(self, event):
		self.player._text_cursor_pos = min(self.player._text_cursor_pos + 1, len(self.player.text))
		return True

	def event_marker(self, event):
		idx = self.player.buttons.index(self.player.selected)
		self.player.selected = None
		self.player.change_special_char(-1)
		self.player.selected = self.player.buttons[idx]
		return True

	def event_action_menu(self, event):
		idx = self.player.buttons.index(self.player.selected)
		self.player.selected = None
		self.player.change_special_char()
		self.player.selected = self.player.buttons[idx]
		return True

	def event_stop(self, event):
		self.player.delete_char()
		return True



class SilentKeyboardEventHandler(KeyboardEventHandler):
	def event_toggle_menu(self, event):
		self.player.hide()
		return True



class SearchKeyboardEventHandler(KeyboardEventHandler):
	def event_action_menu(self, event):
		self.player.hide(hide_search_menu=True)
		return True



class MultiIntegerButtonsEventHandler(KeyboardEventHandler):
	def __init__(self, num_buttons, player):
		KeyboardEventHandler.__init__(self, player)
		self.num_buttons = num_buttons

	def event_up(self, event):
		sel_idx = self.player.buttons.index(self.player.selected)
		if 0 <= sel_idx:
			pass
		else:
			sel_idx
		if 0 <= sel_idx:
			self.player.selected.upper()
			self.player.update()
		return True

	def event_down(self, event):
		sel_idx = self.player.buttons.index(self.player.selected)
		if 0 <= sel_idx:
			pass
		else:
			sel_idx
		if 0 <= sel_idx:
			self.player.selected.lower()
			self.player.update()
		return True



]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb767282c>}
from __future__ import absolute_import
from pygui.eventmanager import EventDispatcher
from pygui.shared import pygui_globs
from peewee.debug import GET_LOGGER
log = GET_LOGGER(__name__)
class WindowEventHandler(EventDispatcher):
	def event_home(self, event):
		from pygui.menu.menu.firstboot import FirstBootMenu
		for menu in reversed(pygui_globs['menustack'].menus_stack):
			if isinstance(menu, FirstBootMenu):
				return True
				continue
		return EventDispatcher.event_home(self, event)



class MessageEventHandler(WindowEventHandler):
	def catch_event(self, event):
		return True

	event_left, event_right, event_up, event_down, event_wheel_rwd, event_wheel_fwd = catch_event, catch_event, catch_event, catch_event, catch_event, catch_event
	def event_select(self, event):
		play = self.player
		if play._timeout_timer:
			play._timeout_timer.stop()
		play.hide()
		if play.button:
			play.button.emit()
		return True

	def event_stop(self, event):
		play = self.player
		if not play.timeout_callback:
			return False
		if play._timeout_timer:
			play._timeout_timer.stop()
		play.hide()
		play.timeout_callback()
		return True



class CancelOnlyEventHandler(WindowEventHandler):
	def event_stop(self, event):
		play = self.player
		if play._cancel_fn:
			try:
				play._cancel_fn()
			except Exception, e:
				log.error('Cancel action failed: %s', str(e))
		return True



class NoHomeEventHandler(CancelOnlyEventHandler):
	def event_home(self, event):
		return True



class ButtonListEventHandler(WindowEventHandler):
	def event_left(self, event):
		play = self.player
		sel_idx = play.buttons.index(play.selected)
		if sel_idx > 0:
			play.selected = play.buttons[sel_idx - 1]
		pygui_globs['menustack'].update_window(play)
		return True

	def event_right(self, event):
		play = self.player
		sel_idx = play.buttons.index(play.selected)
		max_idx = len(play.buttons) - 1
		if sel_idx < max_idx:
			play.selected = play.buttons[sel_idx + 1]
		pygui_globs['menustack'].update_window(play)
		return True

	def event_select(self, event):
		self.player.hide()
		self.player.selected.emit()
		return True

	def event_stop(self, event):
		return True



class DismissableButtonListEventHandler(ButtonListEventHandler):
	def event_stop(self, event):
		self.player.hide()
		return True



class KeyboardEventHandler(WindowEventHandler):
	def __call__(self, event):
		EventDispatcher.__call__(self, event)
		pygui_globs['menustack'].update_window(self.player)
		return True

	def event_left(self, event):
		sel_idx = self.player.buttons.index(self.player.selected)
		self.player.selected = self.player.buttons[sel_idx - 1]
		return True

	def event_right(self, event):
		sel_idx = self.player.buttons.index(self.player.selected)
		nb_elts = len(self.player.buttons)
		new_idx = (sel_idx + 1) % nb_elts
		self.player.selected = self.player.buttons[new_idx]
		return True

	def event_up(self, event):
		sel_idx = self.player.buttons.index(self.player.selected)
		new_sel = sel_idx - self.player.columns
		if self.player.buttons[sel_idx] in self.player.action_buttons and self.player.buttons[new_sel] not in self.player.action_buttons:
			self.player.selected = self.player.buttons[-len(self.player.action_buttons) - 1]
		else:
			self.player.selected = self.player.buttons[new_sel]
		return True

	def event_down(self, event):
		sel_idx = self.player.buttons.index(self.player.selected)
		nb_elts = len(self.player.buttons)
		new_sel = (sel_idx + self.player.columns) % nb_elts
		if self.player.buttons[sel_idx] not in self.player.action_buttons and (new_sel < sel_idx or self.player.buttons[new_sel] in self.player.action_buttons):
			self.player.selected = self.player.action_buttons[0]
		else:
			self.player.selected = self.player.buttons[new_sel]
		return True

	def event_select(self, event):
		self.player.selected.emit()
		return True

	def event_wheel_rwd(self, event):
		self.player._text_cursor_pos = max(self.player._text_cursor_pos - 1, 0)
		return True

	def event_wheel_fwd(self, event):
		self.player._text_cursor_pos = min(self.player._text_cursor_pos + 1, len(self.player.text))
		return True

	def event_marker(self, event):
		idx = self.player.buttons.index(self.player.selected)
		self.player.selected = None
		self.player.change_special_char(-1)
		self.player.selected = self.player.buttons[idx]
		return True

	def event_action_menu(self, event):
		idx = self.player.buttons.index(self.player.selected)
		self.player.selected = None
		self.player.change_special_char()
		self.player.selected = self.player.buttons[idx]
		return True

	def event_stop(self, event):
		self.player.delete_char()
		return True



class SilentKeyboardEventHandler(KeyboardEventHandler):
	def event_toggle_menu(self, event):
		self.player.hide()
		return True



class SearchKeyboardEventHandler(KeyboardEventHandler):
	def event_action_menu(self, event):
		self.player.hide(hide_search_menu=True)
		return True



class MultiIntegerButtonsEventHandler(KeyboardEventHandler):
	def __init__(self, num_buttons, player):
		KeyboardEventHandler.__init__(self, player)
		self.num_buttons = num_buttons

	def event_up(self, event):
		sel_idx = self.player.buttons.index(self.player.selected)
		if 0 <= sel_idx:
			pass
		else:
			sel_idx
		if 0 <= sel_idx:
			self.player.selected.upper()
			self.player.update()
		return True

	def event_down(self, event):
		sel_idx = self.player.buttons.index(self.player.selected)
		if 0 <= sel_idx:
			pass
		else:
			sel_idx
		if 0 <= sel_idx:
			self.player.selected.lower()
			self.player.update()
		return True



