# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 0
n 0(None)[GenericPlayerEventHandler.event_action_menu(self, event)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76f9eac>}
nname: 163
n 163(None)[return True
]:
	i: 104(JA), 124(), 127()
	o: 

nname: 127
n 127(None)[ret = Menu.select(self.player, -event.arg['count'], list_name=al)
]:
	i: 0(f)
	o: 163()

nname: 124
n 124(None)[]:
	i: 88(JA), 108()
	o: 163()

nname: 108
n 108(None)[ret = self.player.select_random()
]:
	i: 24(t)
	o: 124()

nname: 104
n 104(None)[]:
	i: 37(f)
	o: 163(JA)

nname: 88
n 88(None)[self.player.repeat_mode = False
]:
	i: 37(t)
	o: 124(JA)

nname: 37
n 37(self.player.repeat_mode == 'track')[ret = self.player.select(-event.arg['count'], list_name=al)
]:
	i: 24(f)
	o: 88(t), 104(f)

nname: 24
n 24(self.player.random_mode)[]:
	i: 0(t)
	o: 37(f), 108(t)

nname: 0
n 0(al == 'main_list')[al = self.player.active_list
]:
	i: 
	o: 24(t), 127(f)

nname: 163
n 163(None)[return True
]:
	i: 127(), 37(f), 88(JA), 108()
	o: 

nname: 127
n 127(None)[ret = Menu.select(self.player, -event.arg['count'], list_name=al)
]:
	i: 0(f)
	o: 163()

nname: 108
n 108(None)[ret = self.player.select_random()
]:
	i: 24(t)
	o: 163()

nname: 88
n 88(None)[self.player.repeat_mode = False
]:
	i: 37(t)
	o: 163(JA)

nname: 37
n 37(self.player.repeat_mode == 'track')[ret = self.player.select(-event.arg['count'], list_name=al)
]:
	i: 24(f)
	o: 88(t), 163(f)

nname: 24
n 24(self.player.random_mode)[]:
	i: 0(t)
	o: 37(f), 108(t)

nname: 0
n 0(al == 'main_list')[al = self.player.active_list
]:
	i: 
	o: 24(t), 127(f)

nname: 0
n 0(None)[al = self.player.active_list
if al == 'main_list':
	if not self.player.random_mode:
		ret = self.player.select(-event.arg['count'], list_name=al)
		if self.player.repeat_mode == 'track':
			self.player.repeat_mode = False
	else:
		ret = self.player.select_random()
else:
	ret = Menu.select(self.player, -event.arg['count'], list_name=al)
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7701b4c>}
nname: 161
n 161(None)[return True
]:
	i: 103(JA), 123(), 126()
	o: 

nname: 126
n 126(None)[ret = Menu.select(self.player, event.arg['count'], list_name=al)
]:
	i: 0(f)
	o: 161()

nname: 123
n 123(None)[]:
	i: 87(JA), 107()
	o: 161()

nname: 107
n 107(None)[ret = self.player.select_random()
]:
	i: 24(t)
	o: 123()

nname: 103
n 103(None)[]:
	i: 37(f)
	o: 161(JA)

nname: 87
n 87(None)[self.player.repeat_mode = False
]:
	i: 37(t)
	o: 123(JA)

nname: 37
n 37(self.player.repeat_mode == 'track')[ret = self.player.select(event.arg['count'], list_name=al)
]:
	i: 24(f)
	o: 87(t), 103(f)

nname: 24
n 24(self.player.random_mode)[]:
	i: 0(t)
	o: 37(f), 107(t)

nname: 0
n 0(al == 'main_list')[al = self.player.active_list
]:
	i: 
	o: 24(t), 126(f)

nname: 161
n 161(None)[return True
]:
	i: 126(), 37(f), 87(JA), 107()
	o: 

nname: 126
n 126(None)[ret = Menu.select(self.player, event.arg['count'], list_name=al)
]:
	i: 0(f)
	o: 161()

nname: 107
n 107(None)[ret = self.player.select_random()
]:
	i: 24(t)
	o: 161()

nname: 87
n 87(None)[self.player.repeat_mode = False
]:
	i: 37(t)
	o: 161(JA)

nname: 37
n 37(self.player.repeat_mode == 'track')[ret = self.player.select(event.arg['count'], list_name=al)
]:
	i: 24(f)
	o: 87(t), 161(f)

nname: 24
n 24(self.player.random_mode)[]:
	i: 0(t)
	o: 37(f), 107(t)

nname: 0
n 0(al == 'main_list')[al = self.player.active_list
]:
	i: 
	o: 24(t), 126(f)

nname: 0
n 0(None)[al = self.player.active_list
if al == 'main_list':
	if not self.player.random_mode:
		ret = self.player.select(event.arg['count'], list_name=al)
		if self.player.repeat_mode == 'track':
			self.player.repeat_mode = False
	else:
		ret = self.player.select_random()
else:
	ret = Menu.select(self.player, event.arg['count'], list_name=al)
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7701d8c>}
nname: 129
n 129(None)[]:
	i: 61(), 112()
	o: 

nname: 112
n 112(None)[return GenericPlayerEventHandler.event_stop(self, event)
]:
	i: 0(f)
	o: 129()

nname: 61
n 61(None)[play.choices.edited = False
play.selected.vfs_delete()
del play.choices[play.selected_pos]
play.song_changed()
]:
	i: 52(), 60()
	o: 129()

nname: 60
n 60(None)[]:
	i: 24(f)
	o: 61()

nname: 52
n 52(None)[return True
]:
	i: 24(t)
	o: 61()

nname: 24
n 24(play.selected == play.get_item_list('main_list').selected)[]:
	i: 0(t)
	o: 52(t), 60(f)

nname: 0
n 0(play.active_list == 'edit_list')[play = self.player
]:
	i: 
	o: 24(t), 112(f)

nname: 129
n 129(None)[]:
	i: 24(), 112()
	o: 

nname: 112
n 112(None)[return GenericPlayerEventHandler.event_stop(self, event)
]:
	i: 0(f)
	o: 129()

nname: 24
n 24(None)[if play.selected == play.get_item_list('main_list').selected:
	return True
play.choices.edited = False
play.selected.vfs_delete()
del play.choices[play.selected_pos]
play.song_changed()
]:
	i: 0(t)
	o: 129()

nname: 0
n 0(play.active_list == 'edit_list')[play = self.player
]:
	i: 
	o: 24(t), 112(f)

nname: 0
n 0(None)[play = self.player
if play.active_list == 'edit_list':
	if play.selected == play.get_item_list('main_list').selected:
		return True
	play.choices.edited = False
	play.selected.vfs_delete()
	del play.choices[play.selected_pos]
	play.song_changed()
else:
	return GenericPlayerEventHandler.event_stop(self, event)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb77016cc>}
nname: 58
n 58(None)[return True
]:
	i: 18(), 44()
	o: 

nname: 44
n 44(None)[self.player.action_play()
]:
	i: 0(f)
	o: 58()

nname: 18
n 18(None)[self.player.select(self.player.selected)
]:
	i: 0(t)
	o: 58()

nname: 0
n 0(self.player.active_list == 'edit_list')[]:
	i: 
	o: 18(t), 44(f)

nname: 0
n 0(None)[if self.player.active_list == 'edit_list':
	self.player.select(self.player.selected)
else:
	self.player.action_play()
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb770118c>}
nname: 169
n 169(None)[return True
]:
	i: 49(JA), 62(), 168()
	o: 

nname: 168
n 168(None)[]:
	i: 0(f)
	o: 169()

nname: 62
n 62(None)[main_list = play.get_item_list('main_list')
old_selection = main_list.selected
main_list.set_items(el, old_selection)
el.set_items([])
play.focus_previous()
self.player.tasks['hide_help'].stop()
louie_send('hide_help_playlist', sender=self.player)
]:
	i: 24(f)
	o: 169()

nname: 49
n 49(None)[el.edited = False
]:
	i: 24(t)
	o: 169(JA)

nname: 24
n 24(el.edited)[el = play.get_item_list('edit_list')
]:
	i: 0(t)
	o: 49(t), 62(f)

nname: 0
n 0(play.active_list == 'edit_list')[play = self.player
]:
	i: 
	o: 24(t), 168(f)

nname: 0
n 0(None)[play = self.player
if play.active_list == 'edit_list':
	el = play.get_item_list('edit_list')
	if el.edited:
		el.edited = False
	else:
		main_list = play.get_item_list('main_list')
		old_selection = main_list.selected
		main_list.set_items(el, old_selection)
		el.set_items([])
		play.focus_previous()
		self.player.tasks['hide_help'].stop()
		louie_send('hide_help_playlist', sender=self.player)
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb770152c>}
nname: 129
n 129(None)[return True
]:
	i: 24(), 110()
	o: 

nname: 110
n 110(None)[play.get_item_list('edit_list').edited = True
]:
	i: 0(f)
	o: 129()

nname: 24
n 24(None)[main_list = play.get_item_list('main_list')
edit_list = play.get_item_list('edit_list')
edit_list.set_items(main_list)
edit_list.select(play.selected)
play.focus_next()
self.player.show_help_playlist()
]:
	i: 0(t)
	o: 129()

nname: 0
n 0(play.active_list == 'main_list')[play = self.player
]:
	i: 
	o: 24(t), 110(f)

nname: 0
n 0(None)[play = self.player
if play.active_list == 'main_list':
	main_list = play.get_item_list('main_list')
	edit_list = play.get_item_list('edit_list')
	edit_list.set_items(main_list)
	edit_list.select(play.selected)
	play.focus_next()
	self.player.show_help_playlist()
else:
	play.get_item_list('edit_list').edited = True
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb770132c>}
nname: 254
n 254(None)[return True
]:
	i: 139(), 184(JA), 200(), 239(), 253(AE)
	o: 

nname: 239
n 239(None)[PRINT_EXCEPTION()
]:
	i: 143(f)
	o: 254()

nname: 200
n 200(None)[_idx = max(idx - 1, 0)
self.player.speed = mirror_speeds[_idx]
]:
	i: 153(f)
	o: 254()

nname: 184
n 184(None)[self.player.speed = reference_speed
]:
	i: 153(t)
	o: 254(JA)

nname: 153
n 153(idx == 0)[idx = mirror_speeds.index(sm)
]:
	i: 143(t)
	o: 184(t), 200(f)

nname: 143
n 143(<dummy_ex3> EXC_MATCH ValueError)[]:
	i: 59(except)
	o: 153(t), 239(f)

nname: 139
n 139(None)[]:
	i: 118(), 138()
	o: 254()

nname: 138
n 138(None)[]:
	i: 62(t)
	o: 139()

nname: 118
n 118(None)[self.player.speed = wanted_speeds[_idx]
]:
	i: 62(f)
	o: 139()

nname: 62
n 62(idx == _idx)[idx = wanted_speeds.index(sm)
_idx = min(idx + 1, len(wanted_speeds) - 1)
]:
	i: 59(try)
	o: 118(f), 138(t)

nname: 59
n 59(None)[]:
	i: 34(), 58()
	o: 62(try), 143(except)

nname: 58
n 58(None)[]:
	i: 0(f)
	o: 59()

nname: 34
n 34(None)[self.player.speed = wanted_speeds[0]
return True
]:
	i: 0(t)
	o: 59()

nname: 0
n 0(abs(sm - reference_speed) < 0.01)[sm = self.player.speed
]:
	i: 
	o: 34(t), 58(f)

nname: 254
n 254(None)[return True
]:
	i: 143(JA), 62()
	o: 

nname: 143
n 143(None)[except ValueError:
	idx = mirror_speeds.index(sm)
	if idx == 0:
		self.player.speed = reference_speed
	else:
		_idx = max(idx - 1, 0)
		self.player.speed = mirror_speeds[_idx]
except:
	PRINT_EXCEPTION()
]:
	i: 62()
	o: 254(JA)

nname: 254
n 254(None)[return True
]:
	i: 143(JA), 62()
	o: 

nname: 62
n 62(None)[try:
	idx = wanted_speeds.index(sm)
	_idx = min(idx + 1, len(wanted_speeds) - 1)
	if not idx == _idx:
		self.player.speed = wanted_speeds[_idx]
]:
	i: 0(try)
	o: 254(), 143()

nname: 0
n 0(None)[sm = self.player.speed
if abs(sm - reference_speed) < 0.01:
	self.player.speed = wanted_speeds[0]
	return True
]:
	i: 
	o: 62(try)

nname: 254
n 254(None)[return True
]:
	i: 143(JA), 0()
	o: 

nname: 143
n 143(None)[except ValueError:
	idx = mirror_speeds.index(sm)
	if idx == 0:
		self.player.speed = reference_speed
	else:
		_idx = max(idx - 1, 0)
		self.player.speed = mirror_speeds[_idx]
except:
	PRINT_EXCEPTION()
]:
	i: 0()
	o: 254(JA)

nname: 254
n 254(None)[return True
]:
	i: 143(JA), 0()
	o: 

nname: 0
n 0(None)[sm = self.player.speed
if abs(sm - reference_speed) < 0.01:
	self.player.speed = wanted_speeds[0]
	return True
try:
	idx = wanted_speeds.index(sm)
	_idx = min(idx + 1, len(wanted_speeds) - 1)
	if not idx == _idx:
		self.player.speed = wanted_speeds[_idx]
]:
	i: 
	o: 254(), 143()

self.nodes: {0: <unpyclib.structure.node instance at 0xb770160c>, 143: <unpyclib.structure.node instance at 0xb770176c>, 254: <unpyclib.structure.node instance at 0xb7705a4c>}
nname: 53
n 53(None)[self.player.action_seek(HMI_MUSIC['left'])
return True
]:
	i: 24(), 52()
	o: 

nname: 52
n 52(None)[]:
	i: 0(f)
	o: 53()

nname: 24
n 24(None)[return Menu.select(play, -event.arg['count'])
]:
	i: 0(t)
	o: 53()

nname: 0
n 0(play.active_list == 'edit_list')[play = self.player
]:
	i: 
	o: 24(t), 52(f)

nname: 0
n 0(None)[play = self.player
if play.active_list == 'edit_list':
	return Menu.select(play, -event.arg['count'])
self.player.action_seek(HMI_MUSIC['left'])
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7701e8c>}
nname: 56
n 56(None)[self.player.action_seek(HMI_MUSIC['right'])
return True
]:
	i: 24(), 55()
	o: 

nname: 55
n 55(None)[]:
	i: 0(f)
	o: 56()

nname: 24
n 24(None)[Menu.select(play, event.arg['count'])
return True
]:
	i: 0(t)
	o: 56()

nname: 0
n 0(play.active_list == 'edit_list')[play = self.player
]:
	i: 
	o: 24(t), 55(f)

nname: 0
n 0(None)[play = self.player
if play.active_list == 'edit_list':
	Menu.select(play, event.arg['count'])
	return True
self.player.action_seek(HMI_MUSIC['right'])
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7701c6c>}
nname: 27
n 27(None)[return GenericPlayerEventHandler.event_toggle_menu(self, event)
]:
	i: 18(), 26()
	o: 

nname: 26
n 26(None)[]:
	i: 0(f)
	o: 27()

nname: 18
n 18(None)[return True
]:
	i: 0(t)
	o: 27()

nname: 0
n 0(self.player.get_item_list('edit_list'))[]:
	i: 
	o: 18(t), 26(f)

nname: 0
n 0(None)[if self.player.get_item_list('edit_list'):
	return True
return GenericPlayerEventHandler.event_toggle_menu(self, event)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb770108c>}
nname: 6
n 6(None)[__doc__ = '\n    Event manager for Music universe\n    '
forward_steps = f_list(HMI_MUSIC['forward'])
backward_steps = f_list(HMI_MUSIC['backward'])
def event_action_menu(self, event):
	GenericPlayerEventHandler.event_action_menu(self, event)

def event_up(self, event):
	al = self.player.active_list
	if al == 'main_list':
		if not self.player.random_mode:
			ret = self.player.select(-event.arg['count'], list_name=al)
			if self.player.repeat_mode == 'track':
				self.player.repeat_mode = False
		else:
			ret = self.player.select_random()
	else:
		ret = Menu.select(self.player, -event.arg['count'], list_name=al)
	return True

def event_down(self, event):
	al = self.player.active_list
	if al == 'main_list':
		if not self.player.random_mode:
			ret = self.player.select(event.arg['count'], list_name=al)
			if self.player.repeat_mode == 'track':
				self.player.repeat_mode = False
		else:
			ret = self.player.select_random()
	else:
		ret = Menu.select(self.player, event.arg['count'], list_name=al)
	return True

def event_stop(self, event):
	play = self.player
	if play.active_list == 'edit_list':
		if play.selected == play.get_item_list('main_list').selected:
			return True
		play.choices.edited = False
		play.selected.vfs_delete()
		del play.choices[play.selected_pos]
		play.song_changed()
	else:
		return GenericPlayerEventHandler.event_stop(self, event)

def event_select(self, event):
	if self.player.active_list == 'edit_list':
		self.player.select(self.player.selected)
	else:
		self.player.action_play()
	return True

def event_left(self, event):
	play = self.player
	if play.active_list == 'edit_list':
		el = play.get_item_list('edit_list')
		if el.edited:
			el.edited = False
		else:
			main_list = play.get_item_list('main_list')
			old_selection = main_list.selected
			main_list.set_items(el, old_selection)
			el.set_items([])
			play.focus_previous()
			self.player.tasks['hide_help'].stop()
			louie_send('hide_help_playlist', sender=self.player)
	return True

def event_right(self, event):
	play = self.player
	if play.active_list == 'main_list':
		main_list = play.get_item_list('main_list')
		edit_list = play.get_item_list('edit_list')
		edit_list.set_items(main_list)
		edit_list.select(play.selected)
		play.focus_next()
		self.player.show_help_playlist()
	else:
		play.get_item_list('edit_list').edited = True
	return True

def _change_speed(self, wanted_speeds, mirror_speeds, reference_speed=1):
	sm = self.player.speed
	if abs(sm - reference_speed) < 0.01:
		self.player.speed = wanted_speeds[0]
		return True
	try:
		idx = wanted_speeds.index(sm)
		_idx = min(idx + 1, len(wanted_speeds) - 1)
		if not idx == _idx:
			self.player.speed = wanted_speeds[_idx]

def event_wheel_rwd(self, event):
	play = self.player
	if play.active_list == 'edit_list':
		return Menu.select(play, -event.arg['count'])
	self.player.action_seek(HMI_MUSIC['left'])
	return True

def event_wheel_fwd(self, event):
	play = self.player
	if play.active_list == 'edit_list':
		Menu.select(play, event.arg['count'])
		return True
	self.player.action_seek(HMI_MUSIC['right'])
	return True

def event_toggle_menu(self, event):
	if self.player.get_item_list('edit_list'):
		return True
	return GenericPlayerEventHandler.event_toggle_menu(self, event)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb76f99ac>}
nname: 0
n 0(None)[from __future__ import absolute_import
from peewee.debug import PRINT_EXCEPTION, DEBUG
from peewee.messages import send as louie_send
from peewee.ranges import f_list
from pygui.config import HMI_MUSIC
from pygui.eventmanager.players import GenericPlayerEventHandler
from pygui.menu.menu import Menu
class AudioEventHandler(GenericPlayerEventHandler):
	__doc__ = '\n    Event manager for Music universe\n    '
	forward_steps = f_list(HMI_MUSIC['forward'])
	backward_steps = f_list(HMI_MUSIC['backward'])
	def event_action_menu(self, event):
		GenericPlayerEventHandler.event_action_menu(self, event)

	def event_up(self, event):
		al = self.player.active_list
		if al == 'main_list':
			if not self.player.random_mode:
				ret = self.player.select(-event.arg['count'], list_name=al)
				if self.player.repeat_mode == 'track':
					self.player.repeat_mode = False
			else:
				ret = self.player.select_random()
		else:
			ret = Menu.select(self.player, -event.arg['count'], list_name=al)
		return True

	def event_down(self, event):
		al = self.player.active_list
		if al == 'main_list':
			if not self.player.random_mode:
				ret = self.player.select(event.arg['count'], list_name=al)
				if self.player.repeat_mode == 'track':
					self.player.repeat_mode = False
			else:
				ret = self.player.select_random()
		else:
			ret = Menu.select(self.player, event.arg['count'], list_name=al)
		return True

	def event_stop(self, event):
		play = self.player
		if play.active_list == 'edit_list':
			if play.selected == play.get_item_list('main_list').selected:
				return True
			play.choices.edited = False
			play.selected.vfs_delete()
			del play.choices[play.selected_pos]
			play.song_changed()
		else:
			return GenericPlayerEventHandler.event_stop(self, event)

	def event_select(self, event):
		if self.player.active_list == 'edit_list':
			self.player.select(self.player.selected)
		else:
			self.player.action_play()
		return True

	def event_left(self, event):
		play = self.player
		if play.active_list == 'edit_list':
			el = play.get_item_list('edit_list')
			if el.edited:
				el.edited = False
			else:
				main_list = play.get_item_list('main_list')
				old_selection = main_list.selected
				main_list.set_items(el, old_selection)
				el.set_items([])
				play.focus_previous()
				self.player.tasks['hide_help'].stop()
				louie_send('hide_help_playlist', sender=self.player)
		return True

	def event_right(self, event):
		play = self.player
		if play.active_list == 'main_list':
			main_list = play.get_item_list('main_list')
			edit_list = play.get_item_list('edit_list')
			edit_list.set_items(main_list)
			edit_list.select(play.selected)
			play.focus_next()
			self.player.show_help_playlist()
		else:
			play.get_item_list('edit_list').edited = True
		return True

	def _change_speed(self, wanted_speeds, mirror_speeds, reference_speed=1):
		sm = self.player.speed
		if abs(sm - reference_speed) < 0.01:
			self.player.speed = wanted_speeds[0]
			return True
		try:
			idx = wanted_speeds.index(sm)
			_idx = min(idx + 1, len(wanted_speeds) - 1)
			if not idx == _idx:
				self.player.speed = wanted_speeds[_idx]

	def event_wheel_rwd(self, event):
		play = self.player
		if play.active_list == 'edit_list':
			return Menu.select(play, -event.arg['count'])
		self.player.action_seek(HMI_MUSIC['left'])
		return True

	def event_wheel_fwd(self, event):
		play = self.player
		if play.active_list == 'edit_list':
			Menu.select(play, event.arg['count'])
			return True
		self.player.action_seek(HMI_MUSIC['right'])
		return True

	def event_toggle_menu(self, event):
		if self.player.get_item_list('edit_list'):
			return True
		return GenericPlayerEventHandler.event_toggle_menu(self, event)



]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76f26ec>}
from __future__ import absolute_import
from peewee.debug import PRINT_EXCEPTION, DEBUG
from peewee.messages import send as louie_send
from peewee.ranges import f_list
from pygui.config import HMI_MUSIC
from pygui.eventmanager.players import GenericPlayerEventHandler
from pygui.menu.menu import Menu
class AudioEventHandler(GenericPlayerEventHandler):
	__doc__ = '\n    Event manager for Music universe\n    '
	forward_steps = f_list(HMI_MUSIC['forward'])
	backward_steps = f_list(HMI_MUSIC['backward'])
	def event_action_menu(self, event):
		GenericPlayerEventHandler.event_action_menu(self, event)

	def event_up(self, event):
		al = self.player.active_list
		if al == 'main_list':
			if not self.player.random_mode:
				ret = self.player.select(-event.arg['count'], list_name=al)
				if self.player.repeat_mode == 'track':
					self.player.repeat_mode = False
			else:
				ret = self.player.select_random()
		else:
			ret = Menu.select(self.player, -event.arg['count'], list_name=al)
		return True

	def event_down(self, event):
		al = self.player.active_list
		if al == 'main_list':
			if not self.player.random_mode:
				ret = self.player.select(event.arg['count'], list_name=al)
				if self.player.repeat_mode == 'track':
					self.player.repeat_mode = False
			else:
				ret = self.player.select_random()
		else:
			ret = Menu.select(self.player, event.arg['count'], list_name=al)
		return True

	def event_stop(self, event):
		play = self.player
		if play.active_list == 'edit_list':
			if play.selected == play.get_item_list('main_list').selected:
				return True
			play.choices.edited = False
			play.selected.vfs_delete()
			del play.choices[play.selected_pos]
			play.song_changed()
		else:
			return GenericPlayerEventHandler.event_stop(self, event)

	def event_select(self, event):
		if self.player.active_list == 'edit_list':
			self.player.select(self.player.selected)
		else:
			self.player.action_play()
		return True

	def event_left(self, event):
		play = self.player
		if play.active_list == 'edit_list':
			el = play.get_item_list('edit_list')
			if el.edited:
				el.edited = False
			else:
				main_list = play.get_item_list('main_list')
				old_selection = main_list.selected
				main_list.set_items(el, old_selection)
				el.set_items([])
				play.focus_previous()
				self.player.tasks['hide_help'].stop()
				louie_send('hide_help_playlist', sender=self.player)
		return True

	def event_right(self, event):
		play = self.player
		if play.active_list == 'main_list':
			main_list = play.get_item_list('main_list')
			edit_list = play.get_item_list('edit_list')
			edit_list.set_items(main_list)
			edit_list.select(play.selected)
			play.focus_next()
			self.player.show_help_playlist()
		else:
			play.get_item_list('edit_list').edited = True
		return True

	def _change_speed(self, wanted_speeds, mirror_speeds, reference_speed=1):
		sm = self.player.speed
		if abs(sm - reference_speed) < 0.01:
			self.player.speed = wanted_speeds[0]
			return True
		try:
			idx = wanted_speeds.index(sm)
			_idx = min(idx + 1, len(wanted_speeds) - 1)
			if not idx == _idx:
				self.player.speed = wanted_speeds[_idx]

	def event_wheel_rwd(self, event):
		play = self.player
		if play.active_list == 'edit_list':
			return Menu.select(play, -event.arg['count'])
		self.player.action_seek(HMI_MUSIC['left'])
		return True

	def event_wheel_fwd(self, event):
		play = self.player
		if play.active_list == 'edit_list':
			Menu.select(play, event.arg['count'])
			return True
		self.player.action_seek(HMI_MUSIC['right'])
		return True

	def event_toggle_menu(self, event):
		if self.player.get_item_list('edit_list'):
			return True
		return GenericPlayerEventHandler.event_toggle_menu(self, event)



