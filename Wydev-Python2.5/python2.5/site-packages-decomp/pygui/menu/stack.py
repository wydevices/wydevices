# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 0
n 0(None)[self.menus_stack = MenuStack()
self.windows = []
self.engines = []
self._home_timestamp = None
self._failsafe_log = []
events_watch(self.handle)
self._on_idle = False
pygui_globs['menustack'] = self
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76fac4c>}
nname: 38
n 38(None)[]:
	i: 0(AL), 37()
	o: 

nname: 37
n 37(None)[]:
	i: 12(AF), 22()
	o: 38()

nname: 22
n 22(None)[for engine in self.engines:
engine.on_idle = val
]:
	i: 12(for)
	o: 37()

nname: 12
n 12(None)[]:
	i: 0(loop)
	o: 22(for), 37(AF)

nname: 0
n 0(None)[self._on_idle = val
]:
	i: 
	o: 12(loop), 38(AL)

nname: 38
n 38(None)[]:
	i: 22()
	o: 

nname: 22
n 22(None)[for engine in self.engines:
	engine.on_idle = val
]:
	i: 0(for)
	o: 38()

nname: 0
n 0(None)[self._on_idle = val
]:
	i: 
	o: 22(for)

nname: 38
n 38(None)[]:
	i: 0()
	o: 

nname: 0
n 0(None)[self._on_idle = val
for engine in self.engines:
	engine.on_idle = val
]:
	i: 
	o: 38()

nname: 0
n 0(None)[self._on_idle = val
for engine in self.engines:
	engine.on_idle = val
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76fa78c>}
nname: 0
n 0(None)[return self._on_idle
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76fa52c>}
nname: 0
n 0(None)[return self._on_idle
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76fa54c>}
nname: 0
n 0(None)[return 'windows: [%s]\nmenus: [%s]\n' % (', '.join(<genexpr>(self.windows)), ', '.join(<genexpr>(self.menus_stack)))
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76fae6c>}
nname: 0
n 0(None)[return len(self.menus_stack)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76fa50c>}
nname: 0
n 0(None)[return m in self.menus_stack
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76fa4cc>}
nname: 553
n 553(None)[return None
]:
	i: 523(), 537(), 551(AE)
	o: 

nname: 551
n 551(None)[]:
	i: 527(f)
	o: 553(AE)

nname: 537
n 537(None)[PRINT_EXCEPTION()
]:
	i: 527(t)
	o: 553()

nname: 527
n 527(<dummy_ex3> EXC_MATCH Exception)[]:
	i: 266(except)
	o: 537(t), 551(f)

nname: 523
n 523(None)[]:
	i: 396(AL), 522()
	o: 553()

nname: 522
n 522(None)[]:
	i: 399(AF), 518()
	o: 523()

nname: 518
n 518(None)[]:
	i: 415&467(f), 511()
	o: 522()

nname: 511
n 511(None)[return True
continue
]:
	i: 493(), 510()
	o: 518()

nname: 510
n 510(None)[]:
	i: 480(f)
	o: 511()

nname: 493
n 493(None)[log.warn('EventHandlers should not return None, use True instead !!')
]:
	i: 480(t)
	o: 511()

nname: 480
n 480(ret is None)[]:
	i: 415&467(t)
	o: 493(t), 510(f)

nname: 415&467
n 415&467(ret is True or ret is None)[for m in reversed(self.menus_stack):
ret = m.eventhandler(event)
log.debug('%s -> %s -> %s', event, m, ret)
]:
	i: 399(for)
	o: 480(t), 518(f)

nname: 399
n 399(None)[]:
	i: 396(loop)
	o: 415&467(for), 522(AF)

nname: 396
n 396(None)[]:
	i: 269(AL), 395()
	o: 399(loop), 523(AL)

nname: 395
n 395(None)[]:
	i: 272(AF), 391()
	o: 396()

nname: 391
n 391(None)[]:
	i: 288&340(f), 384()
	o: 395()

nname: 384
n 384(None)[return True
continue
]:
	i: 366(), 383()
	o: 391()

nname: 383
n 383(None)[]:
	i: 353(f)
	o: 384()

nname: 366
n 366(None)[log.warn('EventHandlers should not return None, use True instead !!')
]:
	i: 353(t)
	o: 384()

nname: 353
n 353(ret is None)[]:
	i: 288&340(t)
	o: 366(t), 383(f)

nname: 288&340
n 288&340(ret is True or ret is None)[for win in reversed(self.windows):
ret = win.eventhandler(event)
log.debug('%s -> %s -> %s', event, win, ret)
]:
	i: 272(for)
	o: 353(t), 391(f)

nname: 272
n 272(None)[]:
	i: 269(loop)
	o: 288&340(for), 395(AF)

nname: 269
n 269(None)[]:
	i: 266(try)
	o: 272(loop), 396(AL)

nname: 266
n 266(None)[]:
	i: 248(), 265()
	o: 269(try), 527(except)

nname: 265
n 265(None)[]:
	i: 206(f)
	o: 266()

nname: 248
n 248(None)[plugins.add('logselected')
]:
	i: 206(t)
	o: 266()

nname: 206
n 206(bl == ['RECORD', 'HOME', 'RECORD', 'HOME', 'RECORD', 'HOME', 'RECORD', 'HOME', 'RECORD', 'HOME'])[]:
	i: 47(JA), 141(JA), 177(), 181()
	o: 248(t), 265(f)

nname: 181
n 181(None)[self._failsafe_log = []
self._home_timestamp = None
bl = []
]:
	i: 0(f)
	o: 206()

nname: 177
n 177(None)[]:
	i: 67&94&113(f)
	o: 206()

nname: 141
n 141(None)[self._home_timestamp = None
bl = []
self.menus_stack[0].launch_failsafe()
]:
	i: 67&94&113(t)
	o: 206(JA)

nname: 67&94&113
n 67&94&113(event.arg['timeout'] - self._home_timestamp < 5.0 and len(bl) > 10 and set(bl) == set(['HOME']))[]:
	i: 15(t)
	o: 141(t), 177(f)

nname: 47
n 47(None)[self._home_timestamp = event.arg['timeout']
]:
	i: 15(f)
	o: 206(JA)

nname: 15
n 15(self._home_timestamp)[bl = self._failsafe_log
bl.append('HOME')
]:
	i: 0(t)
	o: 47(f), 67&94&113(t)

nname: 0
n 0(event.name == 'HOME')[]:
	i: 
	o: 15(t), 181(f)

nname: 553
n 553(None)[return None
]:
	i: 527(), 396(AL), 399(AF), 415&467(f), 480()
	o: 

nname: 527
n 527(None)[except Exception:
	PRINT_EXCEPTION()
]:
	i: 266()
	o: 553()

nname: 480
n 480(None)[if ret is None:
	log.warn('EventHandlers should not return None, use True instead !!')
return True
continue
]:
	i: 415&467(t)
	o: 553()

nname: 415&467
n 415&467(ret is True or ret is None)[for m in reversed(self.menus_stack):
ret = m.eventhandler(event)
log.debug('%s -> %s -> %s', event, m, ret)
]:
	i: 399(for)
	o: 480(t), 553(f)

nname: 399
n 399(None)[]:
	i: 396(loop)
	o: 415&467(for), 553(AF)

nname: 396
n 396(None)[]:
	i: 266(AL), 272(AF), 288&340(f), 353()
	o: 399(loop), 553(AL)

nname: 353
n 353(None)[if ret is None:
	log.warn('EventHandlers should not return None, use True instead !!')
return True
continue
]:
	i: 288&340(t)
	o: 396()

nname: 288&340
n 288&340(ret is True or ret is None)[for win in reversed(self.windows):
ret = win.eventhandler(event)
log.debug('%s -> %s -> %s', event, win, ret)
]:
	i: 272(for)
	o: 353(t), 396(f)

nname: 272
n 272(None)[]:
	i: 266(loop)
	o: 288&340(for), 396(AF)

nname: 266
n 266(None)[try:
]:
	i: 0()
	o: 272(loop), 396(AL), 527()

nname: 0
n 0(None)[if event.name == 'HOME':
	bl = self._failsafe_log
	bl.append('HOME')
	if not self._home_timestamp:
		self._home_timestamp = event.arg['timeout']
	else:
		if event.arg['timeout'] - self._home_timestamp < 5.0 and len(bl) > 10 and set(bl) == set(['HOME']):
			self._home_timestamp = None
			bl = []
			self.menus_stack[0].launch_failsafe()
else:
	self._failsafe_log = []
	self._home_timestamp = None
	bl = []
if bl == ['RECORD', 'HOME', 'RECORD', 'HOME', 'RECORD', 'HOME', 'RECORD', 'HOME', 'RECORD', 'HOME']:
	plugins.add('logselected')
]:
	i: 
	o: 266()

nname: 553
n 553(None)[return None
]:
	i: 527(), 415&467(f)
	o: 

nname: 527
n 527(None)[except Exception:
	PRINT_EXCEPTION()
]:
	i: 0()
	o: 553()

nname: 415&467
n 415&467(None)[for m in reversed(self.menus_stack):
	ret = m.eventhandler(event)
	log.debug('%s -> %s -> %s', event, m, ret)
	if ret is True or ret is None:
		if ret is None:
			log.warn('EventHandlers should not return None, use True instead !!')
		return True
		continue
]:
	i: 396(for)
	o: 553()

nname: 396
n 396(None)[]:
	i: 0(AL), 272(AF), 288&340(f)
	o: 415&467(for)

nname: 288&340
n 288&340(None)[for win in reversed(self.windows):
ret = win.eventhandler(event)
log.debug('%s -> %s -> %s', event, win, ret)
if ret is True or ret is None:
	if ret is None:
		log.warn('EventHandlers should not return None, use True instead !!')
	return True
	continue
]:
	i: 272(for)
	o: 396()

nname: 272
n 272(None)[]:
	i: 0(loop)
	o: 288&340(for), 396(AF)

nname: 0
n 0(None)[if event.name == 'HOME':
	bl = self._failsafe_log
	bl.append('HOME')
	if not self._home_timestamp:
		self._home_timestamp = event.arg['timeout']
	else:
		if event.arg['timeout'] - self._home_timestamp < 5.0 and len(bl) > 10 and set(bl) == set(['HOME']):
			self._home_timestamp = None
			bl = []
			self.menus_stack[0].launch_failsafe()
else:
	self._failsafe_log = []
	self._home_timestamp = None
	bl = []
if bl == ['RECORD', 'HOME', 'RECORD', 'HOME', 'RECORD', 'HOME', 'RECORD', 'HOME', 'RECORD', 'HOME']:
	plugins.add('logselected')
try:
]:
	i: 
	o: 272(loop), 396(AL), 527()

nname: 553
n 553(None)[return None
]:
	i: 527(), 396(f)
	o: 

nname: 527
n 527(None)[except Exception:
	PRINT_EXCEPTION()
]:
	i: 0()
	o: 553()

nname: 396
n 396(None)[for m in reversed(self.menus_stack):
	ret = m.eventhandler(event)
	log.debug('%s -> %s -> %s', event, m, ret)
	if ret is True or ret is None:
		if ret is None:
			log.warn('EventHandlers should not return None, use True instead !!')
		return True
		continue
]:
	i: 0(AL), 272(AF), 288&340(f)
	o: 553()

nname: 288&340
n 288&340(None)[for win in reversed(self.windows):
ret = win.eventhandler(event)
log.debug('%s -> %s -> %s', event, win, ret)
if ret is True or ret is None:
	if ret is None:
		log.warn('EventHandlers should not return None, use True instead !!')
	return True
	continue
]:
	i: 272(for)
	o: 396()

nname: 272
n 272(None)[]:
	i: 0(loop)
	o: 288&340(for), 396(AF)

nname: 0
n 0(None)[if event.name == 'HOME':
	bl = self._failsafe_log
	bl.append('HOME')
	if not self._home_timestamp:
		self._home_timestamp = event.arg['timeout']
	else:
		if event.arg['timeout'] - self._home_timestamp < 5.0 and len(bl) > 10 and set(bl) == set(['HOME']):
			self._home_timestamp = None
			bl = []
			self.menus_stack[0].launch_failsafe()
else:
	self._failsafe_log = []
	self._home_timestamp = None
	bl = []
if bl == ['RECORD', 'HOME', 'RECORD', 'HOME', 'RECORD', 'HOME', 'RECORD', 'HOME', 'RECORD', 'HOME']:
	plugins.add('logselected')
try:
]:
	i: 
	o: 272(loop), 396(AL), 527()

self.nodes: {0: <unpyclib.structure.node instance at 0xb770b70c>, 396: <unpyclib.structure.node instance at 0xb770bfec>, 272: <unpyclib.structure.node instance at 0xb7700d8c>, 553: <unpyclib.structure.node instance at 0xb770a76c>, '288&340': <unpyclib.structure.node instance at 0xb770bbcc>, 527: <unpyclib.structure.node instance at 0xb770a8ac>}
nname: 49
n 49(None)[]:
	i: 0(AL), 48()
	o: 

nname: 48
n 48(None)[]:
	i: 19(AF), 29()
	o: 49()

nname: 29
n 29(None)[for engine in self.engines:
engine.add_window(window)
]:
	i: 19(for)
	o: 48()

nname: 19
n 19(None)[]:
	i: 0(loop)
	o: 29(for), 48(AF)

nname: 0
n 0(None)[self.windows.append(window)
]:
	i: 
	o: 19(loop), 49(AL)

nname: 49
n 49(None)[]:
	i: 29()
	o: 

nname: 29
n 29(None)[for engine in self.engines:
	engine.add_window(window)
]:
	i: 0(for)
	o: 49()

nname: 0
n 0(None)[self.windows.append(window)
]:
	i: 
	o: 29(for)

nname: 49
n 49(None)[]:
	i: 0()
	o: 

nname: 0
n 0(None)[self.windows.append(window)
for engine in self.engines:
	engine.add_window(window)
]:
	i: 
	o: 49()

nname: 0
n 0(None)[self.windows.append(window)
for engine in self.engines:
	engine.add_window(window)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76fa6ec>}
nname: 49
n 49(None)[]:
	i: 0(AL), 48()
	o: 

nname: 48
n 48(None)[]:
	i: 19(AF), 29()
	o: 49()

nname: 29
n 29(None)[for engine in self.engines:
engine.remove_window(window)
]:
	i: 19(for)
	o: 48()

nname: 19
n 19(None)[]:
	i: 0(loop)
	o: 29(for), 48(AF)

nname: 0
n 0(None)[self.windows.remove(window)
]:
	i: 
	o: 19(loop), 49(AL)

nname: 49
n 49(None)[]:
	i: 29()
	o: 

nname: 29
n 29(None)[for engine in self.engines:
	engine.remove_window(window)
]:
	i: 0(for)
	o: 49()

nname: 0
n 0(None)[self.windows.remove(window)
]:
	i: 
	o: 29(for)

nname: 49
n 49(None)[]:
	i: 0()
	o: 

nname: 0
n 0(None)[self.windows.remove(window)
for engine in self.engines:
	engine.remove_window(window)
]:
	i: 
	o: 49()

nname: 0
n 0(None)[self.windows.remove(window)
for engine in self.engines:
	engine.remove_window(window)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76faf0c>}
nname: 33
n 33(None)[]:
	i: 0(AL), 32()
	o: 

nname: 32
n 32(None)[]:
	i: 3(AF), 13()
	o: 33()

nname: 13
n 13(None)[for engine in self.engines:
engine.update_window(win)
]:
	i: 3(for)
	o: 32()

nname: 3
n 3(None)[]:
	i: 0(loop)
	o: 13(for), 32(AF)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 33(AL)

nname: 33
n 33(None)[]:
	i: 13()
	o: 

nname: 13
n 13(None)[for engine in self.engines:
	engine.update_window(win)
]:
	i: 0(for)
	o: 33()

nname: 0
n 0(None)[]:
	i: 
	o: 13(for)

nname: 33
n 33(None)[]:
	i: 0()
	o: 

nname: 0
n 0(None)[for engine in self.engines:
	engine.update_window(win)
]:
	i: 
	o: 33()

nname: 0
n 0(None)[for engine in self.engines:
	engine.update_window(win)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76fae2c>}
nname: 117
n 117(None)[]:
	i: 65(AL), 116()
	o: 

nname: 116
n 116(None)[]:
	i: 84(AF), 94()
	o: 117()

nname: 94
n 94(None)[for engine in self.engines:
engine.push_menu(menu, hide_previous_menu)
]:
	i: 84(for)
	o: 116()

nname: 84
n 84(None)[]:
	i: 65(loop)
	o: 94(for), 116(AF)

nname: 65
n 65(None)[self.menus_stack.push_menu(menu)
]:
	i: 42(), 56(), 63(AE)
	o: 84(loop), 117(AL)

nname: 63
n 63(None)[]:
	i: 46(f)
	o: 65(AE)

nname: 56
n 56(None)[]:
	i: 46(t)
	o: 65()

nname: 46
n 46(<dummy_ex3> EXC_MATCH AttributeError)[]:
	i: 0(except)
	o: 56(t), 63(f)

nname: 42
n 42(None)[]:
	i: 12(), 41()
	o: 65()

nname: 41
n 41(None)[]:
	i: 3(f)
	o: 42()

nname: 12
n 12(None)[self.menus_stack[-1].grouped_menu = True
menu.toggleable = False
]:
	i: 3(t)
	o: 42()

nname: 3
n 3(menu.groupeable)[]:
	i: 0(try)
	o: 12(t), 41(f)

nname: 0
n 0(None)[]:
	i: 
	o: 3(try), 46(except)

nname: 117
n 117(None)[]:
	i: 94()
	o: 

nname: 94
n 94(None)[for engine in self.engines:
	engine.push_menu(menu, hide_previous_menu)
]:
	i: 65(for)
	o: 117()

nname: 65
n 65(None)[self.menus_stack.push_menu(menu)
]:
	i: 46(), 0()
	o: 94(for)

nname: 46
n 46(None)[except AttributeError:
	pass
]:
	i: 0()
	o: 65()

nname: 65
n 65(None)[self.menus_stack.push_menu(menu)
]:
	i: 46(), 0()
	o: 94(for)

nname: 0
n 0(None)[try:
	if menu.groupeable:
		self.menus_stack[-1].grouped_menu = True
		menu.toggleable = False
]:
	i: 
	o: 65(), 46()

nname: 117
n 117(None)[]:
	i: 65()
	o: 

nname: 65
n 65(None)[self.menus_stack.push_menu(menu)
for engine in self.engines:
	engine.push_menu(menu, hide_previous_menu)
]:
	i: 46(), 0()
	o: 117()

nname: 46
n 46(None)[except AttributeError:
	pass
]:
	i: 0()
	o: 65()

nname: 65
n 65(None)[self.menus_stack.push_menu(menu)
for engine in self.engines:
	engine.push_menu(menu, hide_previous_menu)
]:
	i: 46(), 0()
	o: 117()

nname: 0
n 0(None)[try:
	if menu.groupeable:
		self.menus_stack[-1].grouped_menu = True
		menu.toggleable = False
]:
	i: 
	o: 65(), 46()

nname: 65
n 65(None)[self.menus_stack.push_menu(menu)
for engine in self.engines:
	engine.push_menu(menu, hide_previous_menu)
]:
	i: 46(), 0()
	o: 

nname: 46
n 46(None)[except AttributeError:
	pass
]:
	i: 0()
	o: 65()

nname: 65
n 65(None)[self.menus_stack.push_menu(menu)
for engine in self.engines:
	engine.push_menu(menu, hide_previous_menu)
]:
	i: 46(), 0()
	o: 

nname: 0
n 0(None)[try:
	if menu.groupeable:
		self.menus_stack[-1].grouped_menu = True
		menu.toggleable = False
]:
	i: 
	o: 65(), 46()

self.nodes: {0: <unpyclib.structure.node instance at 0xb76fabac>, 65: <unpyclib.structure.node instance at 0xb76facec>, 46: <unpyclib.structure.node instance at 0xb76fad0c>}
nname: 227
n 227(None)[return None
]:
	i: 189(AL), 222(), 226()
	o: 

nname: 226
n 226(None)[]:
	i: 171(f)
	o: 227()

nname: 222
n 222(None)[]:
	i: 193(AF), 203()
	o: 227()

nname: 203
n 203(None)[for engine in self.engines:
engine.back_to_menu(menu)
]:
	i: 193(for)
	o: 222()

nname: 193
n 193(None)[]:
	i: 189(loop)
	o: 203(for), 222(AF)

nname: 189
n 189(None)[]:
	i: 171(t)
	o: 193(loop), 227(AL)

nname: 171
n 171(self.menus_stack.back_to_menu(menu))[]:
	i: 93(AL), 166(), 170()
	o: 189(t), 226(f)

nname: 170
n 170(None)[]:
	i: 0(f)
	o: 171()

nname: 166
n 166(None)[]:
	i: 96(AF), 163()
	o: 171()

nname: 163
n 163(None)[]:
	i: 109(AL), 162()
	o: 166()

nname: 162
n 162(None)[]:
	i: 133(AF), 143()
	o: 163()

nname: 143
n 143(None)[for engine in self.engines:
engine.remove_window(win)
]:
	i: 133(for)
	o: 162()

nname: 133
n 133(None)[]:
	i: 109(loop)
	o: 143(for), 162(AF)

nname: 109
n 109(None)[for rank in reversed(win_to_remove):
win = self.windows.pop(rank)
]:
	i: 96(for)
	o: 133(loop), 163(AL)

nname: 96
n 96(None)[]:
	i: 93(loop)
	o: 109(for), 166(AF)

nname: 93
n 93(None)[]:
	i: 12(AL), 92()
	o: 96(loop), 171(AL)

nname: 92
n 92(None)[]:
	i: 22(AF), 88()
	o: 93()

nname: 88
n 88(None)[]:
	i: 38(t), 71()
	o: 92()

nname: 71
n 71(None)[win_to_remove.append(i)
continue
]:
	i: 38(f)
	o: 88()

nname: 38
n 38(persistent)[for i, w in enumerate(self.windows):
persistent = getattr(w, 'persistent', False)
]:
	i: 22(for)
	o: 71(f), 88(t)

nname: 22
n 22(None)[]:
	i: 12(loop)
	o: 38(for), 92(AF)

nname: 12
n 12(None)[win_to_remove = []
]:
	i: 0(t)
	o: 22(loop), 93(AL)

nname: 0
n 0(menu is None)[]:
	i: 
	o: 12(t), 170(f)

nname: 227
n 227(None)[return None
]:
	i: 203(), 171(f)
	o: 

nname: 203
n 203(None)[for engine in self.engines:
	engine.back_to_menu(menu)
]:
	i: 189(for)
	o: 227()

nname: 189
n 189(None)[]:
	i: 171(t)
	o: 203(for)

nname: 171
n 171(self.menus_stack.back_to_menu(menu))[]:
	i: 93(AL), 96(AF), 143(), 0(f)
	o: 189(t), 227(f)

nname: 143
n 143(None)[for engine in self.engines:
	engine.remove_window(win)
]:
	i: 109(for)
	o: 171()

nname: 109
n 109(None)[for rank in reversed(win_to_remove):
win = self.windows.pop(rank)
]:
	i: 96(for)
	o: 143(for)

nname: 96
n 96(None)[]:
	i: 93(loop)
	o: 109(for), 171(AF)

nname: 93
n 93(None)[]:
	i: 12(AL), 22(AF), 38()
	o: 96(loop), 171(AL)

nname: 38
n 38(None)[for i, w in enumerate(self.windows):
persistent = getattr(w, 'persistent', False)
if not persistent:
	win_to_remove.append(i)
	continue
]:
	i: 22(for)
	o: 93()

nname: 22
n 22(None)[]:
	i: 12(loop)
	o: 38(for), 93(AF)

nname: 12
n 12(None)[win_to_remove = []
]:
	i: 0(t)
	o: 22(loop), 93(AL)

nname: 0
n 0(menu is None)[]:
	i: 
	o: 12(t), 171(f)

nname: 227
n 227(None)[return None
]:
	i: 189(), 171(f)
	o: 

nname: 189
n 189(None)[for engine in self.engines:
	engine.back_to_menu(menu)
]:
	i: 171(t)
	o: 227()

nname: 171
n 171(self.menus_stack.back_to_menu(menu))[]:
	i: 38(AL), 96(AF), 109(), 0(f)
	o: 189(t), 227(f)

nname: 109
n 109(None)[for rank in reversed(win_to_remove):
win = self.windows.pop(rank)
for engine in self.engines:
	engine.remove_window(win)
]:
	i: 96(for)
	o: 171()

nname: 96
n 96(None)[]:
	i: 38(loop)
	o: 109(for), 171(AF)

nname: 38
n 38(None)[for i, w in enumerate(self.windows):
	persistent = getattr(w, 'persistent', False)
	if not persistent:
		win_to_remove.append(i)
		continue
]:
	i: 12(for)
	o: 96(loop), 171(AL)

nname: 12
n 12(None)[win_to_remove = []
]:
	i: 0(t)
	o: 38(for)

nname: 0
n 0(menu is None)[]:
	i: 
	o: 12(t), 171(f)

nname: 171
n 171(None)[if self.menus_stack.back_to_menu(menu):
	for engine in self.engines:
		engine.back_to_menu(menu)
return None
]:
	i: 12(AL), 96(AF), 109(), 0(f)
	o: 

nname: 109
n 109(None)[for rank in reversed(win_to_remove):
win = self.windows.pop(rank)
for engine in self.engines:
	engine.remove_window(win)
]:
	i: 96(for)
	o: 171()

nname: 96
n 96(None)[]:
	i: 12(loop)
	o: 109(for), 171(AF)

nname: 12
n 12(None)[win_to_remove = []
for i, w in enumerate(self.windows):
	persistent = getattr(w, 'persistent', False)
	if not persistent:
		win_to_remove.append(i)
		continue
]:
	i: 0(t)
	o: 96(loop), 171(AL)

nname: 0
n 0(menu is None)[]:
	i: 
	o: 12(t), 171(f)

self.nodes: {0: <unpyclib.structure.node instance at 0xb770bf6c>, 12: <unpyclib.structure.node instance at 0xb770ba8c>, 171: <unpyclib.structure.node instance at 0xb770b06c>, 96: <unpyclib.structure.node instance at 0xb770b14c>, 109: <unpyclib.structure.node instance at 0xb770b32c>}
nname: 46
n 46(None)[]:
	i: 0(AL), 45()
	o: 

nname: 45
n 45(None)[]:
	i: 19(AF), 29()
	o: 46()

nname: 29
n 29(None)[for engine in self.engines:
engine.back_one_menu()
]:
	i: 19(for)
	o: 45()

nname: 19
n 19(None)[]:
	i: 0(loop)
	o: 29(for), 45(AF)

nname: 0
n 0(None)[self.menus_stack.back_one_menu(refresh)
]:
	i: 
	o: 19(loop), 46(AL)

nname: 46
n 46(None)[]:
	i: 29()
	o: 

nname: 29
n 29(None)[for engine in self.engines:
	engine.back_one_menu()
]:
	i: 0(for)
	o: 46()

nname: 0
n 0(None)[self.menus_stack.back_one_menu(refresh)
]:
	i: 
	o: 29(for)

nname: 46
n 46(None)[]:
	i: 0()
	o: 

nname: 0
n 0(None)[self.menus_stack.back_one_menu(refresh)
for engine in self.engines:
	engine.back_one_menu()
]:
	i: 
	o: 46()

nname: 0
n 0(None)[self.menus_stack.back_one_menu(refresh)
for engine in self.engines:
	engine.back_one_menu()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76faf0c>}
nname: 0
n 0(None)[idx = self.menus_stack.index(player)
return all(<genexpr>(self.menus_stack[idx + 1:]))
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76faeec>}
nname: 54
n 54(None)[return False
]:
	i: 0(AL), 53()
	o: 

nname: 53
n 53(None)[]:
	i: 3(AF), 40()
	o: 54()

nname: 40
n 40(None)[self.toggle()
]:
	i: 31(), 39()
	o: 53()

nname: 39
n 39(None)[]:
	i: 13(f)
	o: 40()

nname: 31
n 31(None)[return True
]:
	i: 13(t)
	o: 40()

nname: 13
n 13(self.is_on_top(player))[for i in self.menus_stack:
]:
	i: 3(for)
	o: 31(t), 39(f)

nname: 3
n 3(None)[]:
	i: 0(loop)
	o: 13(for), 53(AF)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 54(AL)

nname: 54
n 54(None)[return False
]:
	i: 0(AL), 3(AF), 13()
	o: 

nname: 13
n 13(None)[for i in self.menus_stack:
if self.is_on_top(player):
	return True
self.toggle()
]:
	i: 3(for)
	o: 54()

nname: 3
n 3(None)[]:
	i: 0(loop)
	o: 13(for), 54(AF)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 54(AL)

nname: 13
n 13(None)[for i in self.menus_stack:
	if self.is_on_top(player):
		return True
	self.toggle()
return False
]:
	i: 0(for)
	o: 

nname: 0
n 0(None)[]:
	i: 
	o: 13(for)

nname: 0
n 0(None)[for i in self.menus_stack:
	if self.is_on_top(player):
		return True
	self.toggle()
return False
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76fa70c>}
nname: 167
n 167(None)[return groups
]:
	i: 100(AL), 165()
	o: 

nname: 165
n 165(None)[]:
	i: 103&123(f), 145()
	o: 167()

nname: 145
n 145(None)[groups[1] += 1
]:
	i: 103&123(t)
	o: 165()

nname: 103&123
n 103&123(last + groups[1] < ms_len and ms[last + groups[1]].grouped_menu)[]:
	i: 100(loop)
	o: 145(t), 165(f)

nname: 100
n 100(None)[]:
	i: 0(AL), 98()
	o: 103&123(loop), 167(AL)

nname: 98
n 98(None)[]:
	i: 36&56(f), 78()
	o: 100()

nname: 78
n 78(None)[groups[0] += 1
]:
	i: 36&56(t)
	o: 98()

nname: 36&56
n 36&56(first + groups[0] < last and ms[first + groups[0]].grouped_menu)[]:
	i: 0(loop)
	o: 78(t), 98(f)

nname: 0
n 0(None)[groups = [0, 0]
ms = self.menus_stack
ms_len = len(ms)
]:
	i: 
	o: 36&56(loop), 100(AL)

nname: 167
n 167(None)[return groups
]:
	i: 145()
	o: 

nname: 145
n 145(None)[	groups[1] += 1
]:
	i: 100(t)
	o: 167()

nname: 100
n 100(last + groups[1] < ms_len and ms[last + groups[1]].grouped_menu)[while last + groups[1] < ms_len and ms[last + groups[1]].grouped_menu:
]:
	i: 78()
	o: 145(t)

nname: 78
n 78(None)[	groups[0] += 1
]:
	i: 0(t)
	o: 100()

nname: 0
n 0(first + groups[0] < last and ms[first + groups[0]].grouped_menu)[groups = [0, 0]
ms = self.menus_stack
ms_len = len(ms)
while first + groups[0] < last and ms[first + groups[0]].grouped_menu:
]:
	i: 
	o: 78(t)

nname: 167
n 167(None)[return groups
]:
	i: 100()
	o: 

nname: 100
n 100(None)[while last + groups[1] < ms_len and ms[last + groups[1]].grouped_menu:
	groups[1] += 1
]:
	i: 0()
	o: 167()

nname: 0
n 0(None)[groups = [0, 0]
ms = self.menus_stack
ms_len = len(ms)
while first + groups[0] < last and ms[first + groups[0]].grouped_menu:
	groups[0] += 1
]:
	i: 
	o: 100()

nname: 167
n 167(None)[return groups
]:
	i: 0()
	o: 

nname: 0
n 0(None)[groups = [0, 0]
ms = self.menus_stack
ms_len = len(ms)
while first + groups[0] < last and ms[first + groups[0]].grouped_menu:
	groups[0] += 1
while last + groups[1] < ms_len and ms[last + groups[1]].grouped_menu:
	groups[1] += 1
]:
	i: 
	o: 167()

nname: 0
n 0(None)[groups = [0, 0]
ms = self.menus_stack
ms_len = len(ms)
while first + groups[0] < last and ms[first + groups[0]].grouped_menu:
	groups[0] += 1
while last + groups[1] < ms_len and ms[last + groups[1]].grouped_menu:
	groups[1] += 1
return groups
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76fac0c>}
nname: 222
n 222(None)[return False
]:
	i: 214(), 221()
	o: 

nname: 221
n 221(None)[]:
	i: 62(f)
	o: 222()

nname: 214
n 214(None)[return True
]:
	i: 86(AL), 213()
	o: 222()

nname: 213
n 213(None)[]:
	i: 163(AF), 185()
	o: 214()

nname: 185
n 185(None)[for engine in chain((ms,), self.engines):
engine.swap(first, last, group_first, group_last)
]:
	i: 163(for)
	o: 213()

nname: 163
n 163(None)[]:
	i: 86(loop)
	o: 185(for), 213(AF)

nname: 86
n 86(None)[ms[first].on_foreground()
ms[last].on_background()
]:
	i: 62(t)
	o: 163(loop), 214(AL)

nname: 62
n 62(len(toggling_list) > 1)[del _[1]
for toggling_list in enumerate(ms):
]:
	i: 0(AF), 58()
	o: 86(t), 221(f)

nname: 58
n 58(None)[]:
	i: 29(f), 47()
	o: 62()

nname: 47
n 47(None)[continue
]:
	i: 29(t)
	o: 58()

nname: 29
n 29(m.toggleable)[]:
	i: 0(for)
	o: 47(t), 58(f)

nname: 0
n 0(None)[ms = self.menus_stack
]:
	i: 
	o: 29(for), 62(AF)

nname: 222
n 222(None)[return False
]:
	i: 214(), 62(f)
	o: 

nname: 214
n 214(None)[return True
]:
	i: 185()
	o: 222()

nname: 185
n 185(None)[for engine in chain((ms,), self.engines):
	engine.swap(first, last, group_first, group_last)
]:
	i: 86(for)
	o: 214()

nname: 86
n 86(None)[ms[first].on_foreground()
ms[last].on_background()
]:
	i: 62(t)
	o: 185(for)

nname: 62
n 62(len(toggling_list) > 1)[del _[1]
for toggling_list in enumerate(ms):
]:
	i: 0(AF), 29()
	o: 86(t), 222(f)

nname: 29
n 29(None)[if m.toggleable:
	continue
]:
	i: 0(for)
	o: 62()

nname: 0
n 0(None)[ms = self.menus_stack
]:
	i: 
	o: 29(for), 62(AF)

nname: 222
n 222(None)[return False
]:
	i: 214(), 62(f)
	o: 

nname: 214
n 214(None)[return True
]:
	i: 86()
	o: 222()

nname: 86
n 86(None)[ms[first].on_foreground()
ms[last].on_background()
for engine in chain((ms,), self.engines):
	engine.swap(first, last, group_first, group_last)
]:
	i: 62(t)
	o: 214()

nname: 62
n 62(len(toggling_list) > 1)[del _[1]
for toggling_list in enumerate(ms):
]:
	i: 0(AF), 29()
	o: 86(t), 222(f)

nname: 29
n 29(None)[if m.toggleable:
	continue
]:
	i: 0(for)
	o: 62()

nname: 0
n 0(None)[ms = self.menus_stack
]:
	i: 
	o: 29(for), 62(AF)

nname: 222
n 222(None)[return False
]:
	i: 86(), 62(f)
	o: 

nname: 86
n 86(None)[ms[first].on_foreground()
ms[last].on_background()
for engine in chain((ms,), self.engines):
	engine.swap(first, last, group_first, group_last)
return True
]:
	i: 62(t)
	o: 222()

nname: 62
n 62(len(toggling_list) > 1)[del _[1]
for toggling_list in enumerate(ms):
]:
	i: 0(AF), 29()
	o: 86(t), 222(f)

nname: 29
n 29(None)[if m.toggleable:
	continue
]:
	i: 0(for)
	o: 62()

nname: 0
n 0(None)[ms = self.menus_stack
]:
	i: 
	o: 29(for), 62(AF)

nname: 62
n 62(None)[del _[1]
for toggling_list in enumerate(ms):
if len(toggling_list) > 1:
	ms[first].on_foreground()
	ms[last].on_background()
	for engine in chain((ms,), self.engines):
		engine.swap(first, last, group_first, group_last)
	return True
return False
]:
	i: 0(AF), 29()
	o: 

nname: 29
n 29(None)[if m.toggleable:
	continue
]:
	i: 0(for)
	o: 62()

nname: 0
n 0(None)[ms = self.menus_stack
]:
	i: 
	o: 29(for), 62(AF)

self.nodes: {0: <unpyclib.structure.node instance at 0xb770bbcc>, 29: <unpyclib.structure.node instance at 0xb770b26c>, 62: <unpyclib.structure.node instance at 0xb770bbac>}
nname: 77
n 77(None)[]:
	i: 0(AL), 76()
	o: 

nname: 76
n 76(None)[]:
	i: 28(AF), 50()
	o: 77()

nname: 50
n 50(None)[for engine in chain((ms,), self.engines):
engine.swap(top_rank - 1, top_rank)
]:
	i: 28(for)
	o: 76()

nname: 28
n 28(None)[]:
	i: 0(loop)
	o: 50(for), 76(AF)

nname: 0
n 0(None)[ms = self.menus_stack
top_rank = len(ms) - 1
]:
	i: 
	o: 28(loop), 77(AL)

nname: 77
n 77(None)[]:
	i: 50()
	o: 

nname: 50
n 50(None)[for engine in chain((ms,), self.engines):
	engine.swap(top_rank - 1, top_rank)
]:
	i: 0(for)
	o: 77()

nname: 0
n 0(None)[ms = self.menus_stack
top_rank = len(ms) - 1
]:
	i: 
	o: 50(for)

nname: 77
n 77(None)[]:
	i: 0()
	o: 

nname: 0
n 0(None)[ms = self.menus_stack
top_rank = len(ms) - 1
for engine in chain((ms,), self.engines):
	engine.swap(top_rank - 1, top_rank)
]:
	i: 
	o: 77()

nname: 0
n 0(None)[ms = self.menus_stack
top_rank = len(ms) - 1
for engine in chain((ms,), self.engines):
	engine.swap(top_rank - 1, top_rank)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76fadac>}
nname: 51
n 51(None)[]:
	i: 0(AL), 50()
	o: 

nname: 50
n 50(None)[]:
	i: 3(AF), 28()
	o: 51()

nname: 28
n 28(None)[for engine in chain((self.menus_stack,), self.engines):
engine.switch_sub_menu(menu, pos)
]:
	i: 3(for)
	o: 50()

nname: 3
n 3(None)[]:
	i: 0(loop)
	o: 28(for), 50(AF)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 51(AL)

nname: 51
n 51(None)[]:
	i: 28()
	o: 

nname: 28
n 28(None)[for engine in chain((self.menus_stack,), self.engines):
	engine.switch_sub_menu(menu, pos)
]:
	i: 0(for)
	o: 51()

nname: 0
n 0(None)[]:
	i: 
	o: 28(for)

nname: 51
n 51(None)[]:
	i: 0()
	o: 

nname: 0
n 0(None)[for engine in chain((self.menus_stack,), self.engines):
	engine.switch_sub_menu(menu, pos)
]:
	i: 
	o: 51()

nname: 0
n 0(None)[for engine in chain((self.menus_stack,), self.engines):
	engine.switch_sub_menu(menu, pos)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76fadac>}
nname: 101
n 101(None)[]:
	i: 0(AL), 100()
	o: 

nname: 100
n 100(None)[]:
	i: 31(AF), 96()
	o: 101()

nname: 96
n 96(None)[]:
	i: 47&71(f), 88()
	o: 100()

nname: 88
n 88(None)[return probable_nav
continue
]:
	i: 47&71(t)
	o: 96()

nname: 47&71
n 47&71(isinstance(probable_nav, (Navigator, ThumbnailNavigator)) and not isinstance(probable_nav, MarkerNavigator))[for probable_nav in reversed(self.menus_stack):
]:
	i: 31(for)
	o: 88(t), 96(f)

nname: 31
n 31(None)[]:
	i: 0(loop)
	o: 47&71(for), 100(AF)

nname: 0
n 0(None)[from pygui.menu.menu import Navigator, MarkerNavigator, ThumbnailNavigator
]:
	i: 
	o: 31(loop), 101(AL)

nname: 101
n 101(None)[]:
	i: 0(AL), 31(AF), 47&71(f)
	o: 

nname: 47&71
n 47&71(None)[for probable_nav in reversed(self.menus_stack):
if isinstance(probable_nav, (Navigator, ThumbnailNavigator)) and not isinstance(probable_nav, MarkerNavigator):
	return probable_nav
	continue
]:
	i: 31(for)
	o: 101()

nname: 31
n 31(None)[]:
	i: 0(loop)
	o: 47&71(for), 101(AF)

nname: 0
n 0(None)[from pygui.menu.menu import Navigator, MarkerNavigator, ThumbnailNavigator
]:
	i: 
	o: 31(loop), 101(AL)

nname: 47&71
n 47&71(None)[for probable_nav in reversed(self.menus_stack):
	if isinstance(probable_nav, (Navigator, ThumbnailNavigator)) and not isinstance(probable_nav, MarkerNavigator):
		return probable_nav
		continue
]:
	i: 0(for)
	o: 

nname: 0
n 0(None)[from pygui.menu.menu import Navigator, MarkerNavigator, ThumbnailNavigator
]:
	i: 
	o: 47&71(for)

nname: 0
n 0(None)[from pygui.menu.menu import Navigator, MarkerNavigator, ThumbnailNavigator
for probable_nav in reversed(self.menus_stack):
	if isinstance(probable_nav, (Navigator, ThumbnailNavigator)) and not isinstance(probable_nav, MarkerNavigator):
		return probable_nav
		continue
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76fae8c>}
nname: 59
n 59(None)[return None
]:
	i: 43(), 48(), 58(AE)
	o: 

nname: 48
n 48(None)[return None
]:
	i: 0(except)
	o: 59()

nname: 43
n 43(None)[return None
]:
	i: 25(), 39()
	o: 59()

nname: 39
n 39(None)[]:
	i: 3(f)
	o: 43()

nname: 25
n 25(None)[]:
	i: 3(t)
	o: 43()

nname: 3
n 3(self.menus_stack[1].type in ('main', 'switcher'))[]:
	i: 0(try)
	o: 25(t), 39(f)

nname: 0
n 0(None)[]:
	i: 
	o: 3(try), 48(except)

nname: 59
n 59(None)[return None
]:
	i: 43(), 48()
	o: 

nname: 48
n 48(None)[except:
	return None
]:
	i: 0()
	o: 59()

nname: 43
n 43(None)[return None
]:
	i: 0()
	o: 59()

nname: 0
n 0(None)[try:
	if self.menus_stack[1].type in ('main', 'switcher'):
		pass
]:
	i: 
	o: 43(), 48()

self.nodes: {0: <unpyclib.structure.node instance at 0xb76faa6c>, 43: <unpyclib.structure.node instance at 0xb76fa8cc>, 48: <unpyclib.structure.node instance at 0xb76fa96c>, 59: <unpyclib.structure.node instance at 0xb76fabcc>}
nname: 0
n 0(None)[return self.menus_stack[0]
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76fa52c>}
nname: 151
n 151(None)[return None
]:
	i: 0(AL), 150()
	o: 

nname: 150
n 150(None)[]:
	i: 19(AF), 147()
	o: 151()

nname: 147
n 147(None)[]:
	i: 60(JA), 97(JA), 134(JA), 146()
	o: 150()

nname: 146
n 146(None)[]:
	i: 29(f), 142()
	o: 147()

nname: 142
n 142(None)[continue
]:
	i: 105&118(f)
	o: 146()

nname: 134
n 134(None)[return some_menu
]:
	i: 105&118(t)
	o: 147(JA)

nname: 105&118
n 105&118('video' in type and some_menu.type == 'videoplayer')[]:
	i: 68&81(f)
	o: 134(t), 142(f)

nname: 97
n 97(None)[return some_menu
]:
	i: 68&81(t)
	o: 147(JA)

nname: 68&81
n 68&81('audio' in type and some_menu.type == 'audioplayer')[]:
	i: 47(f)
	o: 97(t), 105&118(f)

nname: 60
n 60(None)[return some_menu
]:
	i: 47(t)
	o: 147(JA)

nname: 47
n 47(type is None)[]:
	i: 29(t)
	o: 60(t), 68&81(f)

nname: 29
n 29(isinstance(some_menu, Player))[for some_menu in self.menus_stack:
]:
	i: 19(for)
	o: 47(t), 146(f)

nname: 19
n 19(None)[]:
	i: 0(loop)
	o: 29(for), 150(AF)

nname: 0
n 0(None)[from pygui.menu.players.core import Player
]:
	i: 
	o: 19(loop), 151(AL)

nname: 151
n 151(None)[return None
]:
	i: 0(AL), 19(AF), 60(JA), 97(JA), 134(JA), 29(f), 142()
	o: 

nname: 142
n 142(None)[continue
]:
	i: 105&118(f)
	o: 151()

nname: 134
n 134(None)[return some_menu
]:
	i: 105&118(t)
	o: 151(JA)

nname: 105&118
n 105&118('video' in type and some_menu.type == 'videoplayer')[]:
	i: 68&81(f)
	o: 134(t), 142(f)

nname: 97
n 97(None)[return some_menu
]:
	i: 68&81(t)
	o: 151(JA)

nname: 68&81
n 68&81('audio' in type and some_menu.type == 'audioplayer')[]:
	i: 47(f)
	o: 97(t), 105&118(f)

nname: 60
n 60(None)[return some_menu
]:
	i: 47(t)
	o: 151(JA)

nname: 47
n 47(type is None)[]:
	i: 29(t)
	o: 60(t), 68&81(f)

nname: 29
n 29(isinstance(some_menu, Player))[for some_menu in self.menus_stack:
]:
	i: 19(for)
	o: 47(t), 151(f)

nname: 19
n 19(None)[]:
	i: 0(loop)
	o: 29(for), 151(AF)

nname: 0
n 0(None)[from pygui.menu.players.core import Player
]:
	i: 
	o: 19(loop), 151(AL)

nname: 29
n 29(None)[for some_menu in self.menus_stack:
	if isinstance(some_menu, Player):
		if type is None:
			return some_menu
		else:
			if 'audio' in type and some_menu.type == 'audioplayer':
				return some_menu
			else:
				if 'video' in type and some_menu.type == 'videoplayer':
					return some_menu
				else:
					continue
return None
]:
	i: 0(for)
	o: 

nname: 0
n 0(None)[from pygui.menu.players.core import Player
]:
	i: 
	o: 29(for)

nname: 0
n 0(None)[from pygui.menu.players.core import Player
for some_menu in self.menus_stack:
	if isinstance(some_menu, Player):
		if type is None:
			return some_menu
		else:
			if 'audio' in type and some_menu.type == 'audioplayer':
				return some_menu
			else:
				if 'video' in type and some_menu.type == 'videoplayer':
					return some_menu
				else:
					continue
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb770bfac>}
nname: 88
n 88(None)[return None
]:
	i: 54(), 87()
	o: 

nname: 87
n 87(None)[]:
	i: 0&46(f)
	o: 88()

nname: 54
n 54(None)[from pygui.menu.menu import HomeMenu
HomeMenu().show()
]:
	i: 0&46(t)
	o: 88()

nname: 0&46
n 0&46(safe and not home)[home = self.get_home()
self.back_to_menu(home)
self.get_root().active_univ = None
]:
	i: 
	o: 54(t), 87(f)

nname: 0&46
n 0&46(None)[home = self.get_home()
self.back_to_menu(home)
self.get_root().active_univ = None
if safe and not home:
	from pygui.menu.menu import HomeMenu
	HomeMenu().show()
return None
]:
	i: 
	o: 

self.nodes: {'0&46': <unpyclib.structure.node instance at 0xb770b44c>}
nname: 36
n 36(None)[]:
	i: 18(), 35()
	o: 

nname: 35
n 35(None)[]:
	i: 0(f)
	o: 36()

nname: 18
n 18(None)[self.back_to_menu(nav)
]:
	i: 0(t)
	o: 36()

nname: 0
n 0(nav)[nav = self.get_navigator()
]:
	i: 
	o: 18(t), 35(f)

nname: 0
n 0(None)[nav = self.get_navigator()
if nav:
	self.back_to_menu(nav)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb770b76c>}
nname: 36
n 36(None)[]:
	i: 18(), 35()
	o: 

nname: 35
n 35(None)[]:
	i: 0(f)
	o: 36()

nname: 18
n 18(None)[self.back_to_menu(player)
]:
	i: 0(t)
	o: 36()

nname: 0
n 0(player)[player = self.get_player()
]:
	i: 
	o: 18(t), 35(f)

nname: 0
n 0(None)[player = self.get_player()
if player:
	self.back_to_menu(player)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb770bb0c>}
nname: 295
n 295(None)[return None
]:
	i: 223(AL), 274(), 278()
	o: 

nname: 278
n 278(None)[log.warning('No player (%s) is found.', player)
]:
	i: 76&82(f)
	o: 295()

nname: 274
n 274(None)[]:
	i: 226(AF), 248()
	o: 295()

nname: 248
n 248(None)[for menu in chain((ms,), self.engines):
menu.pop_group(rank_min, rank_max - rank_min)
]:
	i: 226(for)
	o: 274()

nname: 226
n 226(None)[]:
	i: 223(loop)
	o: 248(for), 274(AF)

nname: 223
n 223(None)[]:
	i: 203(), 216()
	o: 226(loop), 295(AL)

nname: 216
n 216(None)[rank_max = rank_min
]:
	i: 95(f)
	o: 223()

nname: 203
n 203(None)[rank_max = rank_min + i
]:
	i: 118(AL), 201()
	o: 223()

nname: 201
n 201(None)[]:
	i: 141(f), 170()
	o: 203()

nname: 170
n 170(None)[ms[rank_min + 1].grouped_menu = False
i += 1
]:
	i: 147(t), 165()
	o: 201()

nname: 165
n 165(None)[break
continue
]:
	i: 147(f)
	o: 170()

nname: 147
n 147(ms[rank_min + i].grouped_menu)[]:
	i: 141(t)
	o: 165(f), 170(t)

nname: 141
n 141(True)[]:
	i: 118(loop)
	o: 147(t), 201(f)

nname: 118
n 118(None)[ms[rank_min].grouped_menu = False
i = 1
]:
	i: 95(t)
	o: 141(loop), 203(AL)

nname: 95
n 95(ms[rank_min].grouped_menu)[ms = self.menus_stack
]:
	i: 76&82(t)
	o: 118(t), 216(f)

nname: 76&82
n 76&82(player and rank_min is not None)[]:
	i: 44(), 63(), 75(AE)
	o: 95(t), 278(f)

nname: 63
n 63(None)[rank_min = None
]:
	i: 41(except)
	o: 76&82()

nname: 44
n 44(None)[rank_min = ms.index(player)
]:
	i: 41(try)
	o: 76&82()

nname: 41
n 41(None)[]:
	i: 21(), 40()
	o: 44(try), 63(except)

nname: 40
n 40(None)[]:
	i: 0(f)
	o: 41()

nname: 21
n 21(None)[player = self.get_player(type)
]:
	i: 0(t)
	o: 41()

nname: 0
n 0(player is None)[ms = self.menus_stack
]:
	i: 
	o: 21(t), 40(f)

nname: 295
n 295(None)[return None
]:
	i: 248(), 278()
	o: 

nname: 278
n 278(None)[log.warning('No player (%s) is found.', player)
]:
	i: 76&82(f)
	o: 295()

nname: 248
n 248(None)[for menu in chain((ms,), self.engines):
	menu.pop_group(rank_min, rank_max - rank_min)
]:
	i: 223(for)
	o: 295()

nname: 223
n 223(None)[]:
	i: 203(), 216()
	o: 248(for)

nname: 216
n 216(None)[rank_max = rank_min
]:
	i: 95(f)
	o: 223()

nname: 203
n 203(None)[rank_max = rank_min + i
]:
	i: 118(AL), 141(f), 147()
	o: 223()

nname: 147
n 147(None)[if not ms[rank_min + i].grouped_menu:
	break
	continue
ms[rank_min + 1].grouped_menu = False
i += 1
]:
	i: 141(t)
	o: 203()

nname: 141
n 141(True)[]:
	i: 118(loop)
	o: 147(t), 203(f)

nname: 118
n 118(None)[ms[rank_min].grouped_menu = False
i = 1
]:
	i: 95(t)
	o: 141(loop), 203(AL)

nname: 95
n 95(ms[rank_min].grouped_menu)[ms = self.menus_stack
]:
	i: 76&82(t)
	o: 118(t), 216(f)

nname: 76&82
n 76&82(player and rank_min is not None)[]:
	i: 44()
	o: 95(t), 278(f)

nname: 44
n 44(None)[try:
	rank_min = ms.index(player)
except:
	rank_min = None
]:
	i: 0(try)
	o: 76&82()

nname: 0
n 0(None)[ms = self.menus_stack
if player is None:
	player = self.get_player(type)
]:
	i: 
	o: 44(try)

nname: 295
n 295(None)[return None
]:
	i: 223(), 278()
	o: 

nname: 278
n 278(None)[log.warning('No player (%s) is found.', player)
]:
	i: 76&82(f)
	o: 295()

nname: 223
n 223(None)[for menu in chain((ms,), self.engines):
	menu.pop_group(rank_min, rank_max - rank_min)
]:
	i: 147(), 216()
	o: 295()

nname: 216
n 216(None)[rank_max = rank_min
]:
	i: 95(f)
	o: 223()

nname: 147
n 147(None)[	if not ms[rank_min + i].grouped_menu:
		break
		continue
	ms[rank_min + 1].grouped_menu = False
	i += 1
rank_max = rank_min + i
]:
	i: 118(t)
	o: 223()

nname: 118
n 118(True)[ms[rank_min].grouped_menu = False
i = 1
while True:
]:
	i: 95(t)
	o: 147(t)

nname: 95
n 95(ms[rank_min].grouped_menu)[ms = self.menus_stack
]:
	i: 76&82(t)
	o: 118(t), 216(f)

nname: 76&82
n 76&82(player and rank_min is not None)[]:
	i: 0()
	o: 95(t), 278(f)

nname: 0
n 0(None)[ms = self.menus_stack
if player is None:
	player = self.get_player(type)
try:
	rank_min = ms.index(player)
except:
	rank_min = None
]:
	i: 
	o: 76&82()

nname: 295
n 295(None)[return None
]:
	i: 223(), 278()
	o: 

nname: 278
n 278(None)[log.warning('No player (%s) is found.', player)
]:
	i: 0(f)
	o: 295()

nname: 223
n 223(None)[for menu in chain((ms,), self.engines):
	menu.pop_group(rank_min, rank_max - rank_min)
]:
	i: 118(), 216()
	o: 295()

nname: 216
n 216(None)[rank_max = rank_min
]:
	i: 95(f)
	o: 223()

nname: 118
n 118(None)[ms[rank_min].grouped_menu = False
i = 1
while True:
	if not ms[rank_min + i].grouped_menu:
		break
		continue
	ms[rank_min + 1].grouped_menu = False
	i += 1
rank_max = rank_min + i
]:
	i: 95(t)
	o: 223()

nname: 95
n 95(ms[rank_min].grouped_menu)[ms = self.menus_stack
]:
	i: 0(t)
	o: 118(t), 216(f)

nname: 0
n 0(player and rank_min is not None)[ms = self.menus_stack
if player is None:
	player = self.get_player(type)
try:
	rank_min = ms.index(player)
except:
	rank_min = None
]:
	i: 
	o: 95(t), 278(f)

nname: 295
n 295(None)[return None
]:
	i: 95(), 278()
	o: 

nname: 278
n 278(None)[log.warning('No player (%s) is found.', player)
]:
	i: 0(f)
	o: 295()

nname: 95
n 95(None)[ms = self.menus_stack
if ms[rank_min].grouped_menu:
	ms[rank_min].grouped_menu = False
	i = 1
	while True:
		if not ms[rank_min + i].grouped_menu:
			break
			continue
		ms[rank_min + 1].grouped_menu = False
		i += 1
	rank_max = rank_min + i
else:
	rank_max = rank_min
for menu in chain((ms,), self.engines):
	menu.pop_group(rank_min, rank_max - rank_min)
]:
	i: 0(t)
	o: 295()

nname: 0
n 0(player and rank_min is not None)[ms = self.menus_stack
if player is None:
	player = self.get_player(type)
try:
	rank_min = ms.index(player)
except:
	rank_min = None
]:
	i: 
	o: 95(t), 278(f)

nname: 0
n 0(None)[ms = self.menus_stack
if player is None:
	player = self.get_player(type)
try:
	rank_min = ms.index(player)
except:
	rank_min = None
if player and rank_min is not None:
	ms = self.menus_stack
	if ms[rank_min].grouped_menu:
		ms[rank_min].grouped_menu = False
		i = 1
		while True:
			if not ms[rank_min + i].grouped_menu:
				break
				continue
			ms[rank_min + 1].grouped_menu = False
			i += 1
		rank_max = rank_min + i
	else:
		rank_max = rank_min
	for menu in chain((ms,), self.engines):
		menu.pop_group(rank_min, rank_max - rank_min)
else:
	log.warning('No player (%s) is found.', player)
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb770a3cc>}
nname: 60
n 60(None)[return False
]:
	i: 0(AL), 59()
	o: 

nname: 59
n 59(None)[]:
	i: 19(AF), 55()
	o: 60()

nname: 55
n 55(None)[]:
	i: 29(f), 47()
	o: 59()

nname: 47
n 47(None)[return m
continue
]:
	i: 29(t)
	o: 55()

nname: 29
n 29(isinstance(m, FirstBootMenu))[for m in self.menus_stack:
]:
	i: 19(for)
	o: 47(t), 55(f)

nname: 19
n 19(None)[]:
	i: 0(loop)
	o: 29(for), 59(AF)

nname: 0
n 0(None)[from pygui.menu.menu.firstboot import FirstBootMenu
]:
	i: 
	o: 19(loop), 60(AL)

nname: 60
n 60(None)[return False
]:
	i: 0(AL), 19(AF), 29()
	o: 

nname: 29
n 29(None)[for m in self.menus_stack:
if isinstance(m, FirstBootMenu):
	return m
	continue
]:
	i: 19(for)
	o: 60()

nname: 19
n 19(None)[]:
	i: 0(loop)
	o: 29(for), 60(AF)

nname: 0
n 0(None)[from pygui.menu.menu.firstboot import FirstBootMenu
]:
	i: 
	o: 19(loop), 60(AL)

nname: 29
n 29(None)[for m in self.menus_stack:
	if isinstance(m, FirstBootMenu):
		return m
		continue
return False
]:
	i: 0(for)
	o: 

nname: 0
n 0(None)[from pygui.menu.menu.firstboot import FirstBootMenu
]:
	i: 
	o: 29(for)

nname: 0
n 0(None)[from pygui.menu.menu.firstboot import FirstBootMenu
for m in self.menus_stack:
	if isinstance(m, FirstBootMenu):
		return m
		continue
return False
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb770b2ec>}
nname: 6
n 6(None)[__doc__ = '\n    Main class that manages views and controllers\n\n    self.windows and self.menus_stack are the controllers\n    self.engines is a list of views\n    '
__metaclass__ = MetaSingleton
def __init__(self, *args, **args):
	self.menus_stack = MenuStack()
	self.windows = []
	self.engines = []
	self._home_timestamp = None
	self._failsafe_log = []
	events_watch(self.handle)
	self._on_idle = False
	pygui_globs['menustack'] = self
	return None

def _set_idle_engines(self, val):
	self._on_idle = val
	for engine in self.engines:
		engine.on_idle = val

on_idle = property((lambda : self._on_idle), _set_idle_engines)
del _set_idle_engines
def __repr__(self):
	return 'windows: [%s]\nmenus: [%s]\n' % (', '.join(<genexpr>(self.windows)), ', '.join(<genexpr>(self.menus_stack)))

def __len__(self):
	return len(self.menus_stack)

def __contains__(self, m):
	return m in self.menus_stack

def handle(self, event):
	if event.name == 'HOME':
		bl = self._failsafe_log
		bl.append('HOME')
		if not self._home_timestamp:
			self._home_timestamp = event.arg['timeout']
		else:
			if event.arg['timeout'] - self._home_timestamp < 5.0 and len(bl) > 10 and set(bl) == set(['HOME']):
				self._home_timestamp = None
				bl = []
				self.menus_stack[0].launch_failsafe()
	else:
		self._failsafe_log = []
		self._home_timestamp = None
		bl = []
	if bl == ['RECORD', 'HOME', 'RECORD', 'HOME', 'RECORD', 'HOME', 'RECORD', 'HOME', 'RECORD', 'HOME']:
		plugins.add('logselected')
	try:

def add_window(self, window):
	self.windows.append(window)
	for engine in self.engines:
		engine.add_window(window)

def remove_window(self, window):
	self.windows.remove(window)
	for engine in self.engines:
		engine.remove_window(window)

def update_window(self, win):
	for engine in self.engines:
		engine.update_window(win)

def push_menu(self, menu, hide_previous_menu=True):
	try:
		if menu.groupeable:
			self.menus_stack[-1].grouped_menu = True
			menu.toggleable = False

def back_to_menu(self, menu=None, refresh=True):
	pass

def back_one_menu(self, refresh=True):
	self.menus_stack.back_one_menu(refresh)
	for engine in self.engines:
		engine.back_one_menu()

def is_on_top(self, player):
	idx = self.menus_stack.index(player)
	return all(<genexpr>(self.menus_stack[idx + 1:]))

def bubble_raise(self, player):
	for i in self.menus_stack:
		if self.is_on_top(player):
			return True
		self.toggle()
	return False

def _get_groups(self, first, last):
	groups = [0, 0]
	ms = self.menus_stack
	ms_len = len(ms)
	while first + groups[0] < last and ms[first + groups[0]].grouped_menu:
		groups[0] += 1
	while last + groups[1] < ms_len and ms[last + groups[1]].grouped_menu:
		groups[1] += 1
	return groups

def toggle(self):
	ms = self.menus_stack

def swap_notebook_page(self):
	ms = self.menus_stack
	top_rank = len(ms) - 1
	for engine in chain((ms,), self.engines):
		engine.swap(top_rank - 1, top_rank)

def switch_sub_menu(self, menu, pos):
	for engine in chain((self.menus_stack,), self.engines):
		engine.switch_sub_menu(menu, pos)

def get_navigator(self):
	from pygui.menu.menu import Navigator, MarkerNavigator, ThumbnailNavigator
	for probable_nav in reversed(self.menus_stack):
		if isinstance(probable_nav, (Navigator, ThumbnailNavigator)) and not isinstance(probable_nav, MarkerNavigator):
			return probable_nav
			continue

def get_home(self):
	try:
		if self.menus_stack[1].type in ('main', 'switcher'):
			pass

def get_root(self):
	return self.menus_stack[0]

def get_player(self, type=None):
	from pygui.menu.players.core import Player
	for some_menu in self.menus_stack:
		if isinstance(some_menu, Player):
			if type is None:
				return some_menu
			else:
				if 'audio' in type and some_menu.type == 'audioplayer':
					return some_menu
				else:
					if 'video' in type and some_menu.type == 'videoplayer':
						return some_menu
					else:
						continue
	return None

def back_to_home(self, safe=True):
	home = self.get_home()
	self.back_to_menu(home)
	self.get_root().active_univ = None
	if safe and not home:
		from pygui.menu.menu import HomeMenu
		HomeMenu().show()
	return None

def back_to_navigator(self):
	nav = self.get_navigator()
	if nav:
		self.back_to_menu(nav)

def back_to_player(self):
	player = self.get_player()
	if player:
		self.back_to_menu(player)

def close_player(self, player=None, type=None):
	ms = self.menus_stack
	if player is None:
		player = self.get_player(type)
	try:
		rank_min = ms.index(player)
	except:
		rank_min = None
	if player and rank_min is not None:
		ms = self.menus_stack
		if ms[rank_min].grouped_menu:
			ms[rank_min].grouped_menu = False
			i = 1
			while True:
				if not ms[rank_min + i].grouped_menu:
					break
					continue
				ms[rank_min + 1].grouped_menu = False
				i += 1
			rank_max = rank_min + i
		else:
			rank_max = rank_min
		for menu in chain((ms,), self.engines):
			menu.pop_group(rank_min, rank_max - rank_min)
	else:
		log.warning('No player (%s) is found.', player)
	return None

def is_on_firstboot(self):
	from pygui.menu.menu.firstboot import FirstBootMenu
	for m in self.menus_stack:
		if isinstance(m, FirstBootMenu):
			return m
			continue
	return False

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb76ef58c>}
nname: 32
n 32(None)[MenuStack.instances_counter += 1
list.__init__(self)
]:
	i: 15(), 31()
	o: 

nname: 31
n 31(None)[]:
	i: 0(f)
	o: 32()

nname: 15
n 15(None)[raise RuntimeError('MenuStack is a singleton !')
]:
	i: 0(t)
	o: 32()

nname: 0
n 0(MenuStack.instances_counter != 0)[]:
	i: 
	o: 15(t), 31(f)

nname: 0
n 0(None)[if MenuStack.instances_counter != 0:
	raise RuntimeError('MenuStack is a singleton !')
MenuStack.instances_counter += 1
list.__init__(self)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb770b98c>}
nname: 0
n 0(None)[self[-1].reload_func()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb770bc6c>}
nname: 131
n 131(None)[]:
	i: 30(AL), 130()
	o: 

nname: 130
n 130(None)[]:
	i: 64(AF), 77()
	o: 131()

nname: 77
n 77(None)[for i in xrange(len_group_last):
list.insert(self, i1 + 1 + i, list.pop(self, i2 + 1 + i))
]:
	i: 64(for)
	o: 130()

nname: 64
n 64(None)[]:
	i: 30(loop)
	o: 77(for), 130(AF)

nname: 30
n 30(None)[list.insert(self, i1, list.pop(self, i2))
]:
	i: 12(), 29()
	o: 64(loop), 131(AL)

nname: 29
n 29(None)[]:
	i: 0(f)
	o: 30()

nname: 12
n 12(None)[i1, i2 = i2, i1
]:
	i: 0(t)
	o: 30()

nname: 0
n 0(i1 > i2)[]:
	i: 
	o: 12(t), 29(f)

nname: 130
n 130(None)[]:
	i: 64()
	o: 

nname: 64
n 64(None)[for i in xrange(len_group_last):
	list.insert(self, i1 + 1 + i, list.pop(self, i2 + 1 + i))
]:
	i: 0(loop)
	o: 130()

nname: 0
n 0(None)[if i1 > i2:
	i1, i2 = i2, i1
list.insert(self, i1, list.pop(self, i2))
]:
	i: 
	o: 64(loop)

nname: 130
n 130(None)[]:
	i: 0()
	o: 

nname: 0
n 0(None)[if i1 > i2:
	i1, i2 = i2, i1
list.insert(self, i1, list.pop(self, i2))
for i in xrange(len_group_last):
	list.insert(self, i1 + 1 + i, list.pop(self, i2 + 1 + i))
]:
	i: 
	o: 130()

nname: 0
n 0(None)[if i1 > i2:
	i1, i2 = i2, i1
list.insert(self, i1, list.pop(self, i2))
for i in xrange(len_group_last):
	list.insert(self, i1 + 1 + i, list.pop(self, i2 + 1 + i))
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb770b9cc>}
nname: 95
n 95(None)[return old_menu
]:
	i: 37(JA), 61(JA), 91(), 94()
	o: 

nname: 94
n 94(None)[]:
	i: 0(f)
	o: 95()

nname: 91
n 91(None)[]:
	i: 89(AE)
	o: 95()

nname: 89
n 89(None)[]:
	i: 51(f)
	o: 91(AE)

nname: 61
n 61(None)[#, e
log.error('stop() of %s failed: %s', old_menu, e)
]:
	i: 51(t)
	o: 95(JA)

nname: 51
n 51(<dummy_ex3> EXC_MATCH Exception)[]:
	i: 33(except)
	o: 61(t), 89(f)

nname: 37
n 37(None)[old_menu.stop()
]:
	i: 33(try)
	o: 95(JA)

nname: 33
n 33(None)[]:
	i: 0(t)
	o: 37(try), 51(except)

nname: 0
n 0(hasattr(old_menu, 'stop'))[old_menu = list.pop(self, idx)
]:
	i: 
	o: 33(t), 94(f)

nname: 95
n 95(None)[return old_menu
]:
	i: 37(JA), 61(JA), 51(f), 89(AE), 0(f)
	o: 

nname: 61
n 61(None)[#, e
log.error('stop() of %s failed: %s', old_menu, e)
]:
	i: 51(t)
	o: 95(JA)

nname: 51
n 51(<dummy_ex3> EXC_MATCH Exception)[]:
	i: 33(except)
	o: 61(t), 95(f)

nname: 37
n 37(None)[old_menu.stop()
]:
	i: 33(try)
	o: 95(JA)

nname: 33
n 33(None)[]:
	i: 0(t)
	o: 37(try), 51(except)

nname: 0
n 0(hasattr(old_menu, 'stop'))[old_menu = list.pop(self, idx)
]:
	i: 
	o: 33(t), 95(f)

nname: 95
n 95(None)[return old_menu
]:
	i: 51(f), 0(f)
	o: 

nname: 51
n 51(None)[except Exception, e:
	log.error('stop() of %s failed: %s', old_menu, e)
]:
	i: 33()
	o: 95(JA)

nname: 33
n 33(None)[try:
	old_menu.stop()
]:
	i: 0(t)
	o: 51()

nname: 0
n 0(hasattr(old_menu, 'stop'))[old_menu = list.pop(self, idx)
]:
	i: 
	o: 33(t), 95(f)

nname: 95
n 95(None)[return old_menu
]:
	i: 33(f), 0(f)
	o: 

nname: 33
n 33(None)[try:
	old_menu.stop()
except Exception, e:
	log.error('stop() of %s failed: %s', old_menu, e)
]:
	i: 0(t)
	o: 95(JA)

nname: 0
n 0(hasattr(old_menu, 'stop'))[old_menu = list.pop(self, idx)
]:
	i: 
	o: 33(t), 95(f)

nname: 0
n 0(None)[old_menu = list.pop(self, idx)
if hasattr(old_menu, 'stop'):
	try:
		old_menu.stop()
	except Exception, e:
		log.error('stop() of %s failed: %s', old_menu, e)
return old_menu
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb770b96c>}
nname: 40
n 40(None)[self.refresh_top()
]:
	i: 0(AL), 39()
	o: 

nname: 39
n 39(None)[]:
	i: 3(AF), 20()
	o: 40()

nname: 20
n 20(None)[for i in xrange(1 + range):
self.pop(rank)
]:
	i: 3(for)
	o: 39()

nname: 3
n 3(None)[]:
	i: 0(loop)
	o: 20(for), 39(AF)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 40(AL)

nname: 40
n 40(None)[self.refresh_top()
]:
	i: 20()
	o: 

nname: 20
n 20(None)[for i in xrange(1 + range):
	self.pop(rank)
]:
	i: 0(for)
	o: 40()

nname: 0
n 0(None)[]:
	i: 
	o: 20(for)

nname: 40
n 40(None)[self.refresh_top()
]:
	i: 0()
	o: 

nname: 0
n 0(None)[for i in xrange(1 + range):
	self.pop(rank)
]:
	i: 
	o: 40()

nname: 0
n 0(None)[for i in xrange(1 + range):
	self.pop(rank)
self.refresh_top()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb770b98c>}
nname: 66
n 66(None)[return changed
]:
	i: 0(AL), 64()
	o: 

nname: 64
n 64(None)[]:
	i: 9&27(f), 44()
	o: 66()

nname: 44
n 44(None)[self.back_one_menu()
changed = True
]:
	i: 9&27(t)
	o: 64()

nname: 9&27
n 9&27(len(self) > 1 and self[-1] != menu)[]:
	i: 0(loop)
	o: 44(t), 64(f)

nname: 0
n 0(None)[changed = False
]:
	i: 
	o: 9&27(loop), 66(AL)

nname: 66
n 66(None)[return changed
]:
	i: 44()
	o: 

nname: 44
n 44(None)[	self.back_one_menu()
	changed = True
]:
	i: 0(t)
	o: 66()

nname: 0
n 0(len(self) > 1 and self[-1] != menu)[changed = False
while len(self) > 1 and self[-1] != menu:
]:
	i: 
	o: 44(t)

nname: 66
n 66(None)[return changed
]:
	i: 0()
	o: 

nname: 0
n 0(None)[changed = False
while len(self) > 1 and self[-1] != menu:
	self.back_one_menu()
	changed = True
]:
	i: 
	o: 66()

nname: 0
n 0(None)[changed = False
while len(self) > 1 and self[-1] != menu:
	self.back_one_menu()
	changed = True
return changed
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb770be4c>}
nname: 102
n 102(None)[]:
	i: 84(), 101()
	o: 

nname: 101
n 101(None)[]:
	i: 71(f)
	o: 102()

nname: 84
n 84(None)[self[-1].grouped_menu = False
]:
	i: 71(t)
	o: 102()

nname: 71
n 71(self[-1].grouped_menu)[]:
	i: 56(), 70()
	o: 84(t), 101(f)

nname: 70
n 70(None)[]:
	i: 40(f)
	o: 71()

nname: 56
n 56(None)[self.refresh_top()
]:
	i: 40(t)
	o: 71()

nname: 40
n 40(refresh)[self.pop()
]:
	i: 18(), 39()
	o: 56(t), 70(f)

nname: 39
n 39(None)[]:
	i: 0(f)
	o: 40()

nname: 18
n 18(None)[log.warn('Nothing in menu stack!')
]:
	i: 0(t)
	o: 40()

nname: 0
n 0(len(self) <= 1)[]:
	i: 
	o: 18(t), 39(f)

nname: 71
n 71(None)[if self[-1].grouped_menu:
	self[-1].grouped_menu = False
]:
	i: 0()
	o: 

nname: 0
n 0(None)[if len(self) <= 1:
	log.warn('Nothing in menu stack!')
self.pop()
if refresh:
	self.refresh_top()
]:
	i: 
	o: 71()

nname: 0
n 0(None)[if len(self) <= 1:
	log.warn('Nothing in menu stack!')
self.pop()
if refresh:
	self.refresh_top()
if self[-1].grouped_menu:
	self[-1].grouped_menu = False
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb770b42c>}
nname: 0
n 0(None)[self.append(menu)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb770b4ec>}
nname: 0
n 0(None)[self[pos] = menu
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb770b60c>}
nname: 0
n 0(None)[return self[-1].eventhandler(event)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb770bb0c>}
nname: 6
n 6(None)[__doc__ = '\n    The MenuStack handles a stack of Menus\n    '
instances_counter = 0
def __init__(self):
	if MenuStack.instances_counter != 0:
		raise RuntimeError('MenuStack is a singleton !')
	MenuStack.instances_counter += 1
	list.__init__(self)

def refresh_top(self):
	self[-1].reload_func()

def swap(self, i1, i2, len_group_first=0, len_group_last=0):
	if i1 > i2:
		i1, i2 = i2, i1
	list.insert(self, i1, list.pop(self, i2))
	for i in xrange(len_group_last):
		list.insert(self, i1 + 1 + i, list.pop(self, i2 + 1 + i))

def pop(self, idx=-1):
	old_menu = list.pop(self, idx)
	if hasattr(old_menu, 'stop'):
		try:
			old_menu.stop()
		except Exception, e:
			log.error('stop() of %s failed: %s', old_menu, e)
	return old_menu

def pop_group(self, rank, range):
	for i in xrange(1 + range):
		self.pop(rank)
	self.refresh_top()

def back_to_menu(self, menu):
	changed = False
	while len(self) > 1 and self[-1] != menu:
		self.back_one_menu()
		changed = True
	return changed

def back_one_menu(self, refresh=True):
	if len(self) <= 1:
		log.warn('Nothing in menu stack!')
	self.pop()
	if refresh:
		self.refresh_top()
	if self[-1].grouped_menu:
		self[-1].grouped_menu = False

def push_menu(self, menu):
	self.append(menu)

def switch_sub_menu(self, menu, pos):
	self[pos] = menu

def eventhandler(self, event):
	return self[-1].eventhandler(event)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb76eeccc>}
nname: 0
n 0(None)[from __future__ import absolute_import
__all__ = ['MenuStack', 'MenuManager']
from itertools import chain
from peewee.debug import GET_LOGGER, PRINT_EXCEPTION
from peewee.misc_utils import MetaSingleton
from peewee.notifier import events_watch
from pygui.shared import pygui_globs
log = GET_LOGGER('stack')
class MenuManager(object):
	__doc__ = '\n    Main class that manages views and controllers\n\n    self.windows and self.menus_stack are the controllers\n    self.engines is a list of views\n    '
	__metaclass__ = MetaSingleton
	def __init__(self, *args, **args):
		self.menus_stack = MenuStack()
		self.windows = []
		self.engines = []
		self._home_timestamp = None
		self._failsafe_log = []
		events_watch(self.handle)
		self._on_idle = False
		pygui_globs['menustack'] = self
		return None

	def _set_idle_engines(self, val):
		self._on_idle = val
		for engine in self.engines:
			engine.on_idle = val

	on_idle = property((lambda : self._on_idle), _set_idle_engines)
	del _set_idle_engines
	def __repr__(self):
		return 'windows: [%s]\nmenus: [%s]\n' % (', '.join(<genexpr>(self.windows)), ', '.join(<genexpr>(self.menus_stack)))

	def __len__(self):
		return len(self.menus_stack)

	def __contains__(self, m):
		return m in self.menus_stack

	def handle(self, event):
		if event.name == 'HOME':
			bl = self._failsafe_log
			bl.append('HOME')
			if not self._home_timestamp:
				self._home_timestamp = event.arg['timeout']
			else:
				if event.arg['timeout'] - self._home_timestamp < 5.0 and len(bl) > 10 and set(bl) == set(['HOME']):
					self._home_timestamp = None
					bl = []
					self.menus_stack[0].launch_failsafe()
		else:
			self._failsafe_log = []
			self._home_timestamp = None
			bl = []
		if bl == ['RECORD', 'HOME', 'RECORD', 'HOME', 'RECORD', 'HOME', 'RECORD', 'HOME', 'RECORD', 'HOME']:
			plugins.add('logselected')
		try:

	def add_window(self, window):
		self.windows.append(window)
		for engine in self.engines:
			engine.add_window(window)

	def remove_window(self, window):
		self.windows.remove(window)
		for engine in self.engines:
			engine.remove_window(window)

	def update_window(self, win):
		for engine in self.engines:
			engine.update_window(win)

	def push_menu(self, menu, hide_previous_menu=True):
		try:
			if menu.groupeable:
				self.menus_stack[-1].grouped_menu = True
				menu.toggleable = False

	def back_to_menu(self, menu=None, refresh=True):
		pass

	def back_one_menu(self, refresh=True):
		self.menus_stack.back_one_menu(refresh)
		for engine in self.engines:
			engine.back_one_menu()

	def is_on_top(self, player):
		idx = self.menus_stack.index(player)
		return all(<genexpr>(self.menus_stack[idx + 1:]))

	def bubble_raise(self, player):
		for i in self.menus_stack:
			if self.is_on_top(player):
				return True
			self.toggle()
		return False

	def _get_groups(self, first, last):
		groups = [0, 0]
		ms = self.menus_stack
		ms_len = len(ms)
		while first + groups[0] < last and ms[first + groups[0]].grouped_menu:
			groups[0] += 1
		while last + groups[1] < ms_len and ms[last + groups[1]].grouped_menu:
			groups[1] += 1
		return groups

	def toggle(self):
		ms = self.menus_stack

	def swap_notebook_page(self):
		ms = self.menus_stack
		top_rank = len(ms) - 1
		for engine in chain((ms,), self.engines):
			engine.swap(top_rank - 1, top_rank)

	def switch_sub_menu(self, menu, pos):
		for engine in chain((self.menus_stack,), self.engines):
			engine.switch_sub_menu(menu, pos)

	def get_navigator(self):
		from pygui.menu.menu import Navigator, MarkerNavigator, ThumbnailNavigator
		for probable_nav in reversed(self.menus_stack):
			if isinstance(probable_nav, (Navigator, ThumbnailNavigator)) and not isinstance(probable_nav, MarkerNavigator):
				return probable_nav
				continue

	def get_home(self):
		try:
			if self.menus_stack[1].type in ('main', 'switcher'):
				pass

	def get_root(self):
		return self.menus_stack[0]

	def get_player(self, type=None):
		from pygui.menu.players.core import Player
		for some_menu in self.menus_stack:
			if isinstance(some_menu, Player):
				if type is None:
					return some_menu
				else:
					if 'audio' in type and some_menu.type == 'audioplayer':
						return some_menu
					else:
						if 'video' in type and some_menu.type == 'videoplayer':
							return some_menu
						else:
							continue
		return None

	def back_to_home(self, safe=True):
		home = self.get_home()
		self.back_to_menu(home)
		self.get_root().active_univ = None
		if safe and not home:
			from pygui.menu.menu import HomeMenu
			HomeMenu().show()
		return None

	def back_to_navigator(self):
		nav = self.get_navigator()
		if nav:
			self.back_to_menu(nav)

	def back_to_player(self):
		player = self.get_player()
		if player:
			self.back_to_menu(player)

	def close_player(self, player=None, type=None):
		ms = self.menus_stack
		if player is None:
			player = self.get_player(type)
		try:
			rank_min = ms.index(player)
		except:
			rank_min = None
		if player and rank_min is not None:
			ms = self.menus_stack
			if ms[rank_min].grouped_menu:
				ms[rank_min].grouped_menu = False
				i = 1
				while True:
					if not ms[rank_min + i].grouped_menu:
						break
						continue
					ms[rank_min + 1].grouped_menu = False
					i += 1
				rank_max = rank_min + i
			else:
				rank_max = rank_min
			for menu in chain((ms,), self.engines):
				menu.pop_group(rank_min, rank_max - rank_min)
		else:
			log.warning('No player (%s) is found.', player)
		return None

	def is_on_firstboot(self):
		from pygui.menu.menu.firstboot import FirstBootMenu
		for m in self.menus_stack:
			if isinstance(m, FirstBootMenu):
				return m
				continue
		return False



class MenuStack(list):
	__doc__ = '\n    The MenuStack handles a stack of Menus\n    '
	instances_counter = 0
	def __init__(self):
		if MenuStack.instances_counter != 0:
			raise RuntimeError('MenuStack is a singleton !')
		MenuStack.instances_counter += 1
		list.__init__(self)

	def refresh_top(self):
		self[-1].reload_func()

	def swap(self, i1, i2, len_group_first=0, len_group_last=0):
		if i1 > i2:
			i1, i2 = i2, i1
		list.insert(self, i1, list.pop(self, i2))
		for i in xrange(len_group_last):
			list.insert(self, i1 + 1 + i, list.pop(self, i2 + 1 + i))

	def pop(self, idx=-1):
		old_menu = list.pop(self, idx)
		if hasattr(old_menu, 'stop'):
			try:
				old_menu.stop()
			except Exception, e:
				log.error('stop() of %s failed: %s', old_menu, e)
		return old_menu

	def pop_group(self, rank, range):
		for i in xrange(1 + range):
			self.pop(rank)
		self.refresh_top()

	def back_to_menu(self, menu):
		changed = False
		while len(self) > 1 and self[-1] != menu:
			self.back_one_menu()
			changed = True
		return changed

	def back_one_menu(self, refresh=True):
		if len(self) <= 1:
			log.warn('Nothing in menu stack!')
		self.pop()
		if refresh:
			self.refresh_top()
		if self[-1].grouped_menu:
			self[-1].grouped_menu = False

	def push_menu(self, menu):
		self.append(menu)

	def switch_sub_menu(self, menu, pos):
		self[pos] = menu

	def eventhandler(self, event):
		return self[-1].eventhandler(event)



]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76e3bec>}
from __future__ import absolute_import
__all__ = ['MenuStack', 'MenuManager']
from itertools import chain
from peewee.debug import GET_LOGGER, PRINT_EXCEPTION
from peewee.misc_utils import MetaSingleton
from peewee.notifier import events_watch
from pygui.shared import pygui_globs
log = GET_LOGGER('stack')
class MenuManager(object):
	__doc__ = '\n    Main class that manages views and controllers\n\n    self.windows and self.menus_stack are the controllers\n    self.engines is a list of views\n    '
	__metaclass__ = MetaSingleton
	def __init__(self, *args, **args):
		self.menus_stack = MenuStack()
		self.windows = []
		self.engines = []
		self._home_timestamp = None
		self._failsafe_log = []
		events_watch(self.handle)
		self._on_idle = False
		pygui_globs['menustack'] = self
		return None

	def _set_idle_engines(self, val):
		self._on_idle = val
		for engine in self.engines:
			engine.on_idle = val

	on_idle = property((lambda : self._on_idle), _set_idle_engines)
	del _set_idle_engines
	def __repr__(self):
		return 'windows: [%s]\nmenus: [%s]\n' % (', '.join(<genexpr>(self.windows)), ', '.join(<genexpr>(self.menus_stack)))

	def __len__(self):
		return len(self.menus_stack)

	def __contains__(self, m):
		return m in self.menus_stack

	def handle(self, event):
		if event.name == 'HOME':
			bl = self._failsafe_log
			bl.append('HOME')
			if not self._home_timestamp:
				self._home_timestamp = event.arg['timeout']
			else:
				if event.arg['timeout'] - self._home_timestamp < 5.0 and len(bl) > 10 and set(bl) == set(['HOME']):
					self._home_timestamp = None
					bl = []
					self.menus_stack[0].launch_failsafe()
		else:
			self._failsafe_log = []
			self._home_timestamp = None
			bl = []
		if bl == ['RECORD', 'HOME', 'RECORD', 'HOME', 'RECORD', 'HOME', 'RECORD', 'HOME', 'RECORD', 'HOME']:
			plugins.add('logselected')
		try:

	def add_window(self, window):
		self.windows.append(window)
		for engine in self.engines:
			engine.add_window(window)

	def remove_window(self, window):
		self.windows.remove(window)
		for engine in self.engines:
			engine.remove_window(window)

	def update_window(self, win):
		for engine in self.engines:
			engine.update_window(win)

	def push_menu(self, menu, hide_previous_menu=True):
		try:
			if menu.groupeable:
				self.menus_stack[-1].grouped_menu = True
				menu.toggleable = False

	def back_to_menu(self, menu=None, refresh=True):
		pass

	def back_one_menu(self, refresh=True):
		self.menus_stack.back_one_menu(refresh)
		for engine in self.engines:
			engine.back_one_menu()

	def is_on_top(self, player):
		idx = self.menus_stack.index(player)
		return all(<genexpr>(self.menus_stack[idx + 1:]))

	def bubble_raise(self, player):
		for i in self.menus_stack:
			if self.is_on_top(player):
				return True
			self.toggle()
		return False

	def _get_groups(self, first, last):
		groups = [0, 0]
		ms = self.menus_stack
		ms_len = len(ms)
		while first + groups[0] < last and ms[first + groups[0]].grouped_menu:
			groups[0] += 1
		while last + groups[1] < ms_len and ms[last + groups[1]].grouped_menu:
			groups[1] += 1
		return groups

	def toggle(self):
		ms = self.menus_stack

	def swap_notebook_page(self):
		ms = self.menus_stack
		top_rank = len(ms) - 1
		for engine in chain((ms,), self.engines):
			engine.swap(top_rank - 1, top_rank)

	def switch_sub_menu(self, menu, pos):
		for engine in chain((self.menus_stack,), self.engines):
			engine.switch_sub_menu(menu, pos)

	def get_navigator(self):
		from pygui.menu.menu import Navigator, MarkerNavigator, ThumbnailNavigator
		for probable_nav in reversed(self.menus_stack):
			if isinstance(probable_nav, (Navigator, ThumbnailNavigator)) and not isinstance(probable_nav, MarkerNavigator):
				return probable_nav
				continue

	def get_home(self):
		try:
			if self.menus_stack[1].type in ('main', 'switcher'):
				pass

	def get_root(self):
		return self.menus_stack[0]

	def get_player(self, type=None):
		from pygui.menu.players.core import Player
		for some_menu in self.menus_stack:
			if isinstance(some_menu, Player):
				if type is None:
					return some_menu
				else:
					if 'audio' in type and some_menu.type == 'audioplayer':
						return some_menu
					else:
						if 'video' in type and some_menu.type == 'videoplayer':
							return some_menu
						else:
							continue
		return None

	def back_to_home(self, safe=True):
		home = self.get_home()
		self.back_to_menu(home)
		self.get_root().active_univ = None
		if safe and not home:
			from pygui.menu.menu import HomeMenu
			HomeMenu().show()
		return None

	def back_to_navigator(self):
		nav = self.get_navigator()
		if nav:
			self.back_to_menu(nav)

	def back_to_player(self):
		player = self.get_player()
		if player:
			self.back_to_menu(player)

	def close_player(self, player=None, type=None):
		ms = self.menus_stack
		if player is None:
			player = self.get_player(type)
		try:
			rank_min = ms.index(player)
		except:
			rank_min = None
		if player and rank_min is not None:
			ms = self.menus_stack
			if ms[rank_min].grouped_menu:
				ms[rank_min].grouped_menu = False
				i = 1
				while True:
					if not ms[rank_min + i].grouped_menu:
						break
						continue
					ms[rank_min + 1].grouped_menu = False
					i += 1
				rank_max = rank_min + i
			else:
				rank_max = rank_min
			for menu in chain((ms,), self.engines):
				menu.pop_group(rank_min, rank_max - rank_min)
		else:
			log.warning('No player (%s) is found.', player)
		return None

	def is_on_firstboot(self):
		from pygui.menu.menu.firstboot import FirstBootMenu
		for m in self.menus_stack:
			if isinstance(m, FirstBootMenu):
				return m
				continue
		return False



class MenuStack(list):
	__doc__ = '\n    The MenuStack handles a stack of Menus\n    '
	instances_counter = 0
	def __init__(self):
		if MenuStack.instances_counter != 0:
			raise RuntimeError('MenuStack is a singleton !')
		MenuStack.instances_counter += 1
		list.__init__(self)

	def refresh_top(self):
		self[-1].reload_func()

	def swap(self, i1, i2, len_group_first=0, len_group_last=0):
		if i1 > i2:
			i1, i2 = i2, i1
		list.insert(self, i1, list.pop(self, i2))
		for i in xrange(len_group_last):
			list.insert(self, i1 + 1 + i, list.pop(self, i2 + 1 + i))

	def pop(self, idx=-1):
		old_menu = list.pop(self, idx)
		if hasattr(old_menu, 'stop'):
			try:
				old_menu.stop()
			except Exception, e:
				log.error('stop() of %s failed: %s', old_menu, e)
		return old_menu

	def pop_group(self, rank, range):
		for i in xrange(1 + range):
			self.pop(rank)
		self.refresh_top()

	def back_to_menu(self, menu):
		changed = False
		while len(self) > 1 and self[-1] != menu:
			self.back_one_menu()
			changed = True
		return changed

	def back_one_menu(self, refresh=True):
		if len(self) <= 1:
			log.warn('Nothing in menu stack!')
		self.pop()
		if refresh:
			self.refresh_top()
		if self[-1].grouped_menu:
			self[-1].grouped_menu = False

	def push_menu(self, menu):
		self.append(menu)

	def switch_sub_menu(self, menu, pos):
		self[pos] = menu

	def eventhandler(self, event):
		return self[-1].eventhandler(event)



