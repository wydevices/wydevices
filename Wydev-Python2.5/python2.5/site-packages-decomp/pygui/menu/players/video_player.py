# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 0
n 0(None)[Player.__init__(self, type_=type_)
WPlayer.__init__(self)
self.eventhandler = VideoEventHandler(self)
self._getitems_keywords['hd_info_icon'] = self._get_hd_info_icon
self._getitems_keywords['snd_info_icon'] = self._get_snd_info_icon
self.subserver = pygui_globs['subserver']
self.playmode = 'all'
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75d486c>}
nname: 83
n 83(None)[return ico
]:
	i: 72(), 82()
	o: 

nname: 82
n 82(None)[]:
	i: 0&42(f)
	o: 83()

nname: 72
n 72(None)[ico = 'tvplayer_videoformathd.png'
]:
	i: 0&42(t)
	o: 83()

nname: 0&42
n 0&42(len(self.wpl.vlist()) > 0 and self.wpl.vlist()[0]['height'] >= 720)[sel = self.selected
ico = None
]:
	i: 
	o: 72(t), 82(f)

nname: 0&42
n 0&42(None)[sel = self.selected
ico = None
if len(self.wpl.vlist()) > 0 and self.wpl.vlist()[0]['height'] >= 720:
	ico = 'tvplayer_videoformathd.png'
return ico
]:
	i: 
	o: 

self.nodes: {'0&42': <unpyclib.structure.node instance at 0xb75d448c>}
nname: 70
n 70(None)[return ico
]:
	i: 55(JA), 65(), 69()
	o: 

nname: 69
n 69(None)[]:
	i: 0&21(f)
	o: 70()

nname: 65
n 65(None)[]:
	i: 32(f)
	o: 70()

nname: 55
n 55(None)[ico = 'tvplayer_audio51.png'
]:
	i: 32(t)
	o: 70(JA)

nname: 32
n 32(int(sel['nrAudioChannels']) > 5)[]:
	i: 0&21(t)
	o: 55(t), 65(f)

nname: 0&21
n 0&21(sel and sel['nrAudioChannels'])[sel = self.selected
ico = None
]:
	i: 
	o: 32(t), 69(f)

nname: 0&21
n 0&21(None)[sel = self.selected
ico = None
if sel and sel['nrAudioChannels']:
	if int(sel['nrAudioChannels']) > 5:
		ico = 'tvplayer_audio51.png'
return ico
]:
	i: 
	o: 

self.nodes: {'0&21': <unpyclib.structure.node instance at 0xb75d44cc>}
nname: 141
n 141(None)[]:
	i: 27(), 70(), 140()
	o: 

nname: 140
n 140(None)[return ret
]:
	i: 129(), 136()
	o: 141()

nname: 136
n 136(None)[]:
	i: 100&113(f)
	o: 140()

nname: 129
n 129(None)[]:
	i: 100&113(t)
	o: 140()

nname: 100&113
n 100&113(ret == 'play' and self.playmode == 'all')[]:
	i: 57(f)
	o: 129(t), 136(f)

nname: 70
n 70(None)[return backward_tricks_icons[self.eventhandler.backward_steps.index(self.speed)]
]:
	i: 57(t)
	o: 141()

nname: 57
n 57(ret == 'fast_rewind')[]:
	i: 0(f)
	o: 70(t), 100&113(f)

nname: 27
n 27(None)[return forward_tricks_icons[self.eventhandler.forward_steps.index(self.speed)]
]:
	i: 0(t)
	o: 141()

nname: 0
n 0(ret == 'fast_forward')[ret = WPlayer._get_status(self)
]:
	i: 
	o: 27(t), 57(f)

nname: 141
n 141(None)[]:
	i: 27(), 70(), 100&113()
	o: 

nname: 100&113
n 100&113(None)[if ret == 'play' and self.playmode == 'all':
	pass
return ret
]:
	i: 57(f)
	o: 141()

nname: 70
n 70(None)[return backward_tricks_icons[self.eventhandler.backward_steps.index(self.speed)]
]:
	i: 57(t)
	o: 141()

nname: 57
n 57(ret == 'fast_rewind')[]:
	i: 0(f)
	o: 70(t), 100&113(f)

nname: 27
n 27(None)[return forward_tricks_icons[self.eventhandler.forward_steps.index(self.speed)]
]:
	i: 0(t)
	o: 141()

nname: 0
n 0(ret == 'fast_forward')[ret = WPlayer._get_status(self)
]:
	i: 
	o: 27(t), 57(f)

nname: 0
n 0(None)[ret = WPlayer._get_status(self)
if ret == 'fast_forward':
	return forward_tricks_icons[self.eventhandler.forward_steps.index(self.speed)]
else:
	if ret == 'fast_rewind':
		return backward_tricks_icons[self.eventhandler.backward_steps.index(self.speed)]
	else:
		if ret == 'play' and self.playmode == 'all':
			pass
		return ret
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75d4acc>}
nname: 52
n 52(None)[]:
	i: 15(), 39(), 47()
	o: 

nname: 47
n 47(None)[return 'none'
]:
	i: 23(f)
	o: 52()

nname: 39
n 39(None)[return 'video_loop_list'
]:
	i: 23(t)
	o: 52()

nname: 23
n 23(self.repeat_mode == 'all')[]:
	i: 0(f)
	o: 39(t), 47(f)

nname: 15
n 15(None)[return 'video_loop'
]:
	i: 0(t)
	o: 52()

nname: 0
n 0(self.repeat_mode == 'track')[]:
	i: 
	o: 15(t), 23(f)

nname: 0
n 0(None)[if self.repeat_mode == 'track':
	return 'video_loop'
else:
	if self.repeat_mode == 'all':
		return 'video_loop_list'
	else:
		return 'none'
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75d45ac>}
nname: 0
n 0(None)[dasubs = '\n'.join(subs)
louie_send('subtitles', sender=self, value=dasubs)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75d4c0c>}
nname: 272
n 272(None)[]:
	i: 203(AE)
	o: 

nname: 203
n 203(None)[WPlayer.stop(self)
Player.stop(self)
self._start_playing.task.stop()
self.subserver.unregister_txt_render()
self._render_subtitle(u'')
]:
	i: 0(finally), 199()
	o: 272(AE)

nname: 199
n 199(None)[]:
	i: 124(), 198()
	o: 203()

nname: 198
n 198(None)[]:
	i: 62(f)
	o: 199()

nname: 124
n 124(None)[unref_link = 'refid' in self.selected.wymedia_resource
self.selected.vfs_set_metas(_unref_link=unref_link, playbackStatus=repr(resume_pos))
log.debug('%s save resume position at %s', self.selected, resume_pos)
]:
	i: 94(), 114()
	o: 199()

nname: 114
n 114(None)[resume_pos = self.time_elapsed
]:
	i: 71(f)
	o: 124()

nname: 94
n 94(None)[resume_pos = self.wpl.byte_pos['data']
]:
	i: 71(t)
	o: 124()

nname: 71
n 71(self.selected['class'].endswith('tvRecord'))[]:
	i: 62(t)
	o: 94(t), 114(f)

nname: 62
n 62(config.resume_video)[]:
	i: 34(JA), 57(), 61()
	o: 71(t), 198(f)

nname: 61
n 61(None)[]:
	i: 3(f)
	o: 62()

nname: 57
n 57(None)[]:
	i: 18(f)
	o: 62()

nname: 34
n 34(None)[self.stop_transcode(0)
del self.stop_transcode
]:
	i: 18(t)
	o: 62(JA)

nname: 18
n 18(hasattr(self, 'stop_transcode'))[]:
	i: 3(t)
	o: 34(t), 57(f)

nname: 3
n 3('transcode' in config.plugins)[]:
	i: 0(ASF)
	o: 18(t), 61(f)

nname: 0
n 0(None)[]:
	i: 
	o: 3(ASF), 203(finally)

nname: 272
n 272(None)[]:
	i: 203(AE)
	o: 

nname: 203
n 203(None)[WPlayer.stop(self)
Player.stop(self)
self._start_playing.task.stop()
self.subserver.unregister_txt_render()
self._render_subtitle(u'')
]:
	i: 0(finally), 71(), 3(f)
	o: 272(AE)

nname: 71
n 71(None)[if self.selected['class'].endswith('tvRecord'):
	resume_pos = self.wpl.byte_pos['data']
else:
	resume_pos = self.time_elapsed
unref_link = 'refid' in self.selected.wymedia_resource
self.selected.vfs_set_metas(_unref_link=unref_link, playbackStatus=repr(resume_pos))
log.debug('%s save resume position at %s', self.selected, resume_pos)
]:
	i: 3(t)
	o: 203()

nname: 3
n 3(config.resume_video)[if 'transcode' in config.plugins:
	if hasattr(self, 'stop_transcode'):
		self.stop_transcode(0)
		del self.stop_transcode
]:
	i: 0(ASF)
	o: 71(t), 203(f)

nname: 0
n 0(None)[]:
	i: 
	o: 3(ASF), 203(finally)

nname: 203
n 203(None)[finally:
	WPlayer.stop(self)
	Player.stop(self)
	self._start_playing.task.stop()
	self.subserver.unregister_txt_render()
	self._render_subtitle(u'')
]:
	i: 0(f)
	o: 

nname: 0
n 0(None)[try:
	if 'transcode' in config.plugins:
		if hasattr(self, 'stop_transcode'):
			self.stop_transcode(0)
			del self.stop_transcode
	if config.resume_video:
		if self.selected['class'].endswith('tvRecord'):
			resume_pos = self.wpl.byte_pos['data']
		else:
			resume_pos = self.time_elapsed
		unref_link = 'refid' in self.selected.wymedia_resource
		self.selected.vfs_set_metas(_unref_link=unref_link, playbackStatus=repr(resume_pos))
		log.debug('%s save resume position at %s', self.selected, resume_pos)
]:
	i: 
	o: 203()

nname: 0
n 0(None)[try:
	if 'transcode' in config.plugins:
		if hasattr(self, 'stop_transcode'):
			self.stop_transcode(0)
			del self.stop_transcode
	if config.resume_video:
		if self.selected['class'].endswith('tvRecord'):
			resume_pos = self.wpl.byte_pos['data']
		else:
			resume_pos = self.time_elapsed
		unref_link = 'refid' in self.selected.wymedia_resource
		self.selected.vfs_set_metas(_unref_link=unref_link, playbackStatus=repr(resume_pos))
		log.debug('%s save resume position at %s', self.selected, resume_pos)
finally:
	WPlayer.stop(self)
	Player.stop(self)
	self._start_playing.task.stop()
	self.subserver.unregister_txt_render()
	self._render_subtitle(u'')
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75d75cc>}
nname: 0
n 0(None)[return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75d4d6c>}
nname: 0
n 0(None)[return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75d4f6c>}
nname: 56
n 56(None)[]:
	i: 22(), 36()
	o: 

nname: 36
n 36(None)[user_action((lambda self: None))(self)
]:
	i: 0&9(f)
	o: 56()

nname: 22
n 22(None)[user_action.force_ending()
]:
	i: 0&9(t)
	o: 56()

nname: 0&9
n 0&9(user_action._timer and user_action._timer.running)[]:
	i: 
	o: 22(t), 36(f)

nname: 0&9
n 0&9(None)[if user_action._timer and user_action._timer.running:
	user_action.force_ending()
else:
	user_action((lambda self: None))(self)
]:
	i: 
	o: 

self.nodes: {'0&9': <unpyclib.structure.node instance at 0xb75d410c>}
nname: 6
n 6(None)[media = 'video'
_audio_stream = True
_video_stream = True
_sub_stream = True
def __init__(self, type_='videoplayer'):
	Player.__init__(self, type_=type_)
	WPlayer.__init__(self)
	self.eventhandler = VideoEventHandler(self)
	self._getitems_keywords['hd_info_icon'] = self._get_hd_info_icon
	self._getitems_keywords['snd_info_icon'] = self._get_snd_info_icon
	self.subserver = pygui_globs['subserver']
	self.playmode = 'all'

def _get_hd_info_icon(self):
	sel = self.selected
	ico = None
	if len(self.wpl.vlist()) > 0 and self.wpl.vlist()[0]['height'] >= 720:
		ico = 'tvplayer_videoformathd.png'
	return ico

def _get_snd_info_icon(self):
	sel = self.selected
	ico = None
	if sel and sel['nrAudioChannels']:
		if int(sel['nrAudioChannels']) > 5:
			ico = 'tvplayer_audio51.png'
	return ico

_status_change_callback = tasked(0.10000000000000001)()
def _get_status(self):
	ret = WPlayer._get_status(self)
	if ret == 'fast_forward':
		return forward_tricks_icons[self.eventhandler.forward_steps.index(self.speed)]
	else:
		if ret == 'fast_rewind':
			return backward_tricks_icons[self.eventhandler.backward_steps.index(self.speed)]
		else:
			if ret == 'play' and self.playmode == 'all':
				pass
			return ret

def _get_playmode(self):
	if self.repeat_mode == 'track':
		return 'video_loop'
	else:
		if self.repeat_mode == 'all':
			return 'video_loop_list'
		else:
			return 'none'

tick_callback = selective_gui_updater('progressbar', 'time_remaining', 'time_elapsed', 'time_total', 'status_icon', 'playmode_icon')()
update_media_info = tasked(0.40000000000000002)(selective_gui_updater('progressbar', 'time_remaining', 'time_elapsed', 'time_total')())
def _render_subtitle(self, subs):
	dasubs = '\n'.join(subs)
	louie_send('subtitles', sender=self, value=dasubs)

select = selective_gui_updater('progressbar', 'time_remaining', 'time_elapsed', 'time_total', 'item_name', 'info_icon')()
play = user_action(selective_gui_updater('progressbar', 'time_remaining', 'time_elapsed', 'time_total', 'item_name', 'info_icon', 'snd_info_icon', 'hd_info_icon')())
action_play = user_action()
_start_playing = tasked(config.HMI_VIDEO['lazy_selection'])(user_action(selective_gui_updater('snd_info_icon', 'hd_info_icon')()))
def stop(self):
	try:
		if 'transcode' in config.plugins:
			if hasattr(self, 'stop_transcode'):
				self.stop_transcode(0)
				del self.stop_transcode
		if config.resume_video:
			if self.selected['class'].endswith('tvRecord'):
				resume_pos = self.wpl.byte_pos['data']
			else:
				resume_pos = self.time_elapsed
			unref_link = 'refid' in self.selected.wymedia_resource
			self.selected.vfs_set_metas(_unref_link=unref_link, playbackStatus=repr(resume_pos))
			log.debug('%s save resume position at %s', self.selected, resume_pos)
	finally:
		WPlayer.stop(self)
		Player.stop(self)
		self._start_playing.task.stop()
		self.subserver.unregister_txt_render()
		self._render_subtitle(u'')

def action_info(self):
	if user_action._timer and user_action._timer.running:
		user_action.force_ending()
	else:
		user_action((lambda self: None))(self)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75c1c6c>}
nname: 0
n 0(None)[VideoPlayer.__init__(self)
self.eventhandler = YoutubeEventHandler(self)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75c7f6c>}
nname: 6
n 6(None)[def __init__(self):
	VideoPlayer.__init__(self)
	self.eventhandler = YoutubeEventHandler(self)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75c7d0c>}
nname: 0
n 0(None)[return self.selected['rating']
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75c1a6c>}
nname: 0
n 0(None)[return self.selected['view_count']
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75c19ec>}
nname: 0
n 0(None)[VideoPlayer.__init__(self, type_=type_)
self.eventhandler = YoutubeEventHandler(self)
def self._getitems_keywords['rating']():
	return self.selected['rating']

def self._getitems_keywords['view_count']():
	return self.selected['view_count']

]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75c17cc>}
nname: 6
n 6(None)[def __init__(self, type_='dailymotionvideoplayer'):
	VideoPlayer.__init__(self, type_=type_)
	self.eventhandler = YoutubeEventHandler(self)
	def self._getitems_keywords['rating']():
		return self.selected['rating']

	def self._getitems_keywords['view_count']():
		return self.selected['view_count']


select = selective_gui_updater('rating', 'view_count')()
]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75c7f6c>}
nname: 0
n 0(None)[from __future__ import absolute_import
__all__ = ['VideoPlayer', 'YoutubePlayer', 'DailyMotionPlayer']
from peewee.debug import GET_LOGGER, PRINT_EXCEPTION
from peewee.messages import send as louie_send
from peewee.notifier import tasked
from peewee.ranges import f_list
import pygui.config as config
from pygui.eventmanager.players import VideoEventHandler
from pygui.shared import pygui_globs
from pygui.menu import selective_gui_updater
from pygui.menu.players.core import user_action, Player, WPlayer
from . import forward_tricks_icons, backward_tricks_icons
log = GET_LOGGER(__name__)
class VideoPlayer(Player, WPlayer):
	media = 'video'
	_audio_stream = True
	_video_stream = True
	_sub_stream = True
	def __init__(self, type_='videoplayer'):
		Player.__init__(self, type_=type_)
		WPlayer.__init__(self)
		self.eventhandler = VideoEventHandler(self)
		self._getitems_keywords['hd_info_icon'] = self._get_hd_info_icon
		self._getitems_keywords['snd_info_icon'] = self._get_snd_info_icon
		self.subserver = pygui_globs['subserver']
		self.playmode = 'all'

	def _get_hd_info_icon(self):
		sel = self.selected
		ico = None
		if len(self.wpl.vlist()) > 0 and self.wpl.vlist()[0]['height'] >= 720:
			ico = 'tvplayer_videoformathd.png'
		return ico

	def _get_snd_info_icon(self):
		sel = self.selected
		ico = None
		if sel and sel['nrAudioChannels']:
			if int(sel['nrAudioChannels']) > 5:
				ico = 'tvplayer_audio51.png'
		return ico

	_status_change_callback = tasked(0.10000000000000001)()
	def _get_status(self):
		ret = WPlayer._get_status(self)
		if ret == 'fast_forward':
			return forward_tricks_icons[self.eventhandler.forward_steps.index(self.speed)]
		else:
			if ret == 'fast_rewind':
				return backward_tricks_icons[self.eventhandler.backward_steps.index(self.speed)]
			else:
				if ret == 'play' and self.playmode == 'all':
					pass
				return ret

	def _get_playmode(self):
		if self.repeat_mode == 'track':
			return 'video_loop'
		else:
			if self.repeat_mode == 'all':
				return 'video_loop_list'
			else:
				return 'none'

	tick_callback = selective_gui_updater('progressbar', 'time_remaining', 'time_elapsed', 'time_total', 'status_icon', 'playmode_icon')()
	update_media_info = tasked(0.40000000000000002)(selective_gui_updater('progressbar', 'time_remaining', 'time_elapsed', 'time_total')())
	def _render_subtitle(self, subs):
		dasubs = '\n'.join(subs)
		louie_send('subtitles', sender=self, value=dasubs)

	select = selective_gui_updater('progressbar', 'time_remaining', 'time_elapsed', 'time_total', 'item_name', 'info_icon')()
	play = user_action(selective_gui_updater('progressbar', 'time_remaining', 'time_elapsed', 'time_total', 'item_name', 'info_icon', 'snd_info_icon', 'hd_info_icon')())
	action_play = user_action()
	_start_playing = tasked(config.HMI_VIDEO['lazy_selection'])(user_action(selective_gui_updater('snd_info_icon', 'hd_info_icon')()))
	def stop(self):
		try:
			if 'transcode' in config.plugins:
				if hasattr(self, 'stop_transcode'):
					self.stop_transcode(0)
					del self.stop_transcode
			if config.resume_video:
				if self.selected['class'].endswith('tvRecord'):
					resume_pos = self.wpl.byte_pos['data']
				else:
					resume_pos = self.time_elapsed
				unref_link = 'refid' in self.selected.wymedia_resource
				self.selected.vfs_set_metas(_unref_link=unref_link, playbackStatus=repr(resume_pos))
				log.debug('%s save resume position at %s', self.selected, resume_pos)
		finally:
			WPlayer.stop(self)
			Player.stop(self)
			self._start_playing.task.stop()
			self.subserver.unregister_txt_render()
			self._render_subtitle(u'')

	def action_info(self):
		if user_action._timer and user_action._timer.running:
			user_action.force_ending()
		else:
			user_action((lambda self: None))(self)



from pygui.eventmanager.players.video_player import YoutubeEventHandler
class YoutubePlayer(VideoPlayer):
	def __init__(self):
		VideoPlayer.__init__(self)
		self.eventhandler = YoutubeEventHandler(self)



class DailyMotionPlayer(VideoPlayer):
	def __init__(self, type_='dailymotionvideoplayer'):
		VideoPlayer.__init__(self, type_=type_)
		self.eventhandler = YoutubeEventHandler(self)
		def self._getitems_keywords['rating']():
			return self.selected['rating']

		def self._getitems_keywords['view_count']():
			return self.selected['view_count']


	select = selective_gui_updater('rating', 'view_count')()


]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb763b94c>}
from __future__ import absolute_import
__all__ = ['VideoPlayer', 'YoutubePlayer', 'DailyMotionPlayer']
from peewee.debug import GET_LOGGER, PRINT_EXCEPTION
from peewee.messages import send as louie_send
from peewee.notifier import tasked
from peewee.ranges import f_list
import pygui.config as config
from pygui.eventmanager.players import VideoEventHandler
from pygui.shared import pygui_globs
from pygui.menu import selective_gui_updater
from pygui.menu.players.core import user_action, Player, WPlayer
from . import forward_tricks_icons, backward_tricks_icons
log = GET_LOGGER(__name__)
class VideoPlayer(Player, WPlayer):
	media = 'video'
	_audio_stream = True
	_video_stream = True
	_sub_stream = True
	def __init__(self, type_='videoplayer'):
		Player.__init__(self, type_=type_)
		WPlayer.__init__(self)
		self.eventhandler = VideoEventHandler(self)
		self._getitems_keywords['hd_info_icon'] = self._get_hd_info_icon
		self._getitems_keywords['snd_info_icon'] = self._get_snd_info_icon
		self.subserver = pygui_globs['subserver']
		self.playmode = 'all'

	def _get_hd_info_icon(self):
		sel = self.selected
		ico = None
		if len(self.wpl.vlist()) > 0 and self.wpl.vlist()[0]['height'] >= 720:
			ico = 'tvplayer_videoformathd.png'
		return ico

	def _get_snd_info_icon(self):
		sel = self.selected
		ico = None
		if sel and sel['nrAudioChannels']:
			if int(sel['nrAudioChannels']) > 5:
				ico = 'tvplayer_audio51.png'
		return ico

	_status_change_callback = tasked(0.10000000000000001)()
	def _get_status(self):
		ret = WPlayer._get_status(self)
		if ret == 'fast_forward':
			return forward_tricks_icons[self.eventhandler.forward_steps.index(self.speed)]
		else:
			if ret == 'fast_rewind':
				return backward_tricks_icons[self.eventhandler.backward_steps.index(self.speed)]
			else:
				if ret == 'play' and self.playmode == 'all':
					pass
				return ret

	def _get_playmode(self):
		if self.repeat_mode == 'track':
			return 'video_loop'
		else:
			if self.repeat_mode == 'all':
				return 'video_loop_list'
			else:
				return 'none'

	tick_callback = selective_gui_updater('progressbar', 'time_remaining', 'time_elapsed', 'time_total', 'status_icon', 'playmode_icon')()
	update_media_info = tasked(0.40000000000000002)(selective_gui_updater('progressbar', 'time_remaining', 'time_elapsed', 'time_total')())
	def _render_subtitle(self, subs):
		dasubs = '\n'.join(subs)
		louie_send('subtitles', sender=self, value=dasubs)

	select = selective_gui_updater('progressbar', 'time_remaining', 'time_elapsed', 'time_total', 'item_name', 'info_icon')()
	play = user_action(selective_gui_updater('progressbar', 'time_remaining', 'time_elapsed', 'time_total', 'item_name', 'info_icon', 'snd_info_icon', 'hd_info_icon')())
	action_play = user_action()
	_start_playing = tasked(config.HMI_VIDEO['lazy_selection'])(user_action(selective_gui_updater('snd_info_icon', 'hd_info_icon')()))
	def stop(self):
		try:
			if 'transcode' in config.plugins:
				if hasattr(self, 'stop_transcode'):
					self.stop_transcode(0)
					del self.stop_transcode
			if config.resume_video:
				if self.selected['class'].endswith('tvRecord'):
					resume_pos = self.wpl.byte_pos['data']
				else:
					resume_pos = self.time_elapsed
				unref_link = 'refid' in self.selected.wymedia_resource
				self.selected.vfs_set_metas(_unref_link=unref_link, playbackStatus=repr(resume_pos))
				log.debug('%s save resume position at %s', self.selected, resume_pos)
		finally:
			WPlayer.stop(self)
			Player.stop(self)
			self._start_playing.task.stop()
			self.subserver.unregister_txt_render()
			self._render_subtitle(u'')

	def action_info(self):
		if user_action._timer and user_action._timer.running:
			user_action.force_ending()
		else:
			user_action((lambda self: None))(self)



from pygui.eventmanager.players.video_player import YoutubeEventHandler
class YoutubePlayer(VideoPlayer):
	def __init__(self):
		VideoPlayer.__init__(self)
		self.eventhandler = YoutubeEventHandler(self)



class DailyMotionPlayer(VideoPlayer):
	def __init__(self, type_='dailymotionvideoplayer'):
		VideoPlayer.__init__(self, type_=type_)
		self.eventhandler = YoutubeEventHandler(self)
		def self._getitems_keywords['rating']():
			return self.selected['rating']

		def self._getitems_keywords['view_count']():
			return self.selected['view_count']


	select = selective_gui_updater('rating', 'view_count')()


