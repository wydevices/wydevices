# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 0
n 0(None)[return self.get_item_list('words_list')
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7642b4c>}
nname: 0
n 0(None)[return '%s/%s' % (self.selected_pos + 1, len(self.choices))
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7642e6c>}
nname: 27
n 27(None)[return u''
]:
	i: 9(), 23()
	o: 

nname: 23
n 23(None)[]:
	i: 0(f)
	o: 27()

nname: 9
n 9(None)[]:
	i: 0(t)
	o: 27()

nname: 0
n 0(self.selected)[]:
	i: 
	o: 9(t), 23(f)

nname: 0
n 0(None)[if self.selected:
	pass
return u''
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7642a0c>}
nname: 27
n 27(None)[return u''
]:
	i: 9(), 23()
	o: 

nname: 23
n 23(None)[]:
	i: 0(f)
	o: 27()

nname: 9
n 9(None)[]:
	i: 0(t)
	o: 27()

nname: 0
n 0(self.selected)[]:
	i: 
	o: 9(t), 23(f)

nname: 0
n 0(None)[if self.selected:
	pass
return u''
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76429ec>}
nname: 27
n 27(None)[return u''
]:
	i: 9(), 23()
	o: 

nname: 23
n 23(None)[]:
	i: 0(f)
	o: 27()

nname: 9
n 9(None)[]:
	i: 0(t)
	o: 27()

nname: 0
n 0(self.selected)[]:
	i: 
	o: 9(t), 23(f)

nname: 0
n 0(None)[if self.selected:
	pass
return u''
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7642cec>}
nname: 0
n 0(None)[Player.__init__(self, 'netplayer')
self.eventhandler = NetPlayerEventHandler(self)
self._getitems_keywords.update(title=(lambda : .selected:
	pass
return u''), author=(lambda : .selected:
	pass
return u''), date=self._get_date, link=(lambda : .selected:
	pass
return u''), preview=self._get_preview, embedded_media=self._get_embedded_media, item_numbering=(lambda : '%s/%s' % (self.selected_pos + 1, len(self.choices))), words_list=(lambda : self.get_item_list('words_list')))
self.set_items([], 'words_list')
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb763eb4c>}
nname: 0
n 0(None)[Player.play(self, item, playlist, hide_previous_menu)
self._update_words_list()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb763e6cc>}
nname: 113
n 113(None)[]:
	i: 34(AL), 108(), 112()
	o: 

nname: 112
n 112(None)[]:
	i: 0(f)
	o: 113()

nname: 108
n 108(None)[]:
	i: 48(AF), 76()
	o: 113()

nname: 76
n 76(None)[for key in ['title', 'author', 'date', 'link', 'preview', 'embedded_media', 'item_numbering']:
send(key, sender=self, value=self[key])
]:
	i: 48(for)
	o: 108()

nname: 48
n 48(None)[]:
	i: 34(loop)
	o: 76(for), 108(AF)

nname: 34
n 34(None)[self._update_words_list()
]:
	i: 0(t)
	o: 48(loop), 113(AL)

nname: 0
n 0(list_name == 'main_list')[Player.select(self, val, list_name=list_name)
]:
	i: 
	o: 34(t), 112(f)

nname: 113
n 113(None)[]:
	i: 76(), 0(f)
	o: 

nname: 76
n 76(None)[for key in ['title', 'author', 'date', 'link', 'preview', 'embedded_media', 'item_numbering']:
	send(key, sender=self, value=self[key])
]:
	i: 34(for)
	o: 113()

nname: 34
n 34(None)[self._update_words_list()
]:
	i: 0(t)
	o: 76(for)

nname: 0
n 0(list_name == 'main_list')[Player.select(self, val, list_name=list_name)
]:
	i: 
	o: 34(t), 113(f)

nname: 113
n 113(None)[]:
	i: 34(), 0(f)
	o: 

nname: 34
n 34(None)[self._update_words_list()
for key in ['title', 'author', 'date', 'link', 'preview', 'embedded_media', 'item_numbering']:
	send(key, sender=self, value=self[key])
]:
	i: 0(t)
	o: 113()

nname: 0
n 0(list_name == 'main_list')[Player.select(self, val, list_name=list_name)
]:
	i: 
	o: 34(t), 113(f)

nname: 0
n 0(None)[Player.select(self, val, list_name=list_name)
if list_name == 'main_list':
	self._update_words_list()
	for key in ['title', 'author', 'date', 'link', 'preview', 'embedded_media', 'item_numbering']:
		send(key, sender=self, value=self[key])
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb763ea8c>}
nname: 52
n 52(None)[]:
	i: 31(), 51()
	o: 

nname: 51
n 51(None)[]:
	i: 0(f)
	o: 52()

nname: 31
n 31(None)[self.select(value, 'words_list')
]:
	i: 0(t)
	o: 52()

nname: 0
n 0(len_words_list > self.BLOCKER_POS)[len_words_list = len(self['words_list'])
]:
	i: 
	o: 31(t), 51(f)

nname: 0
n 0(None)[len_words_list = len(self['words_list'])
if len_words_list > self.BLOCKER_POS:
	self.select(value, 'words_list')
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb763e74c>}
nname: 87
n 87(None)[self.set_items(items, 'words_list')
]:
	i: 23(AL), 86()
	o: 

nname: 86
n 86(None)[]:
	i: 35(AF), 42()
	o: 87()

nname: 42
n 42(None)[for line in lines:
items.extend(<genexpr>(textwrap.wrap(line, self.FRAGMENT_LENGTH)))
]:
	i: 35(for)
	o: 86()

nname: 35
n 35(None)[]:
	i: 23(loop)
	o: 42(for), 86(AF)

nname: 23
n 23(None)[lines = self.selected['description'].splitlines()
]:
	i: 0(t), 19()
	o: 35(loop), 87(AL)

nname: 19
n 19(None)[]:
	i: 0(f)
	o: 23()

nname: 0
n 0(self.selected['description'])[items = []
]:
	i: 
	o: 19(f), 23(t)

nname: 86
n 86(None)[self.set_items(items, 'words_list')
]:
	i: 35()
	o: 

nname: 35
n 35(None)[for line in lines:
	items.extend(<genexpr>(textwrap.wrap(line, self.FRAGMENT_LENGTH)))
]:
	i: 0(loop)
	o: 86()

nname: 0
n 0(None)[items = []
if not self.selected['description']:
	pass
lines = self.selected['description'].splitlines()
]:
	i: 
	o: 35(loop)

nname: 86
n 86(None)[self.set_items(items, 'words_list')
]:
	i: 0()
	o: 

nname: 0
n 0(None)[items = []
if not self.selected['description']:
	pass
lines = self.selected['description'].splitlines()
for line in lines:
	items.extend(<genexpr>(textwrap.wrap(line, self.FRAGMENT_LENGTH)))
]:
	i: 
	o: 86()

nname: 0
n 0(None)[items = []
if not self.selected['description']:
	pass
lines = self.selected['description'].splitlines()
for line in lines:
	items.extend(<genexpr>(textwrap.wrap(line, self.FRAGMENT_LENGTH)))
self.set_items(items, 'words_list')
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb763e86c>}
nname: 25
n 25(None)[return u''
]:
	i: 9(), 24()
	o: 

nname: 24
n 24(None)[]:
	i: 0(f)
	o: 25()

nname: 9
n 9(None)[return self.selected['date']
]:
	i: 0(t)
	o: 25()

nname: 0
n 0(self.selected)[]:
	i: 
	o: 9(t), 24(f)

nname: 0
n 0(None)[if self.selected:
	return self.selected['date']
return u''
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb763e50c>}
nname: 32
n 32(None)[return None
]:
	i: 27(), 31()
	o: 

nname: 31
n 31(None)[]:
	i: 0(f)
	o: 32()

nname: 27
n 27(None)[return self.selected['preview']
]:
	i: 9(t), 23()
	o: 32()

nname: 23
n 23(None)[]:
	i: 9(f)
	o: 27()

nname: 9
n 9(self.selected['preview'])[]:
	i: 0(t)
	o: 23(f), 27(t)

nname: 0
n 0(self.selected)[]:
	i: 
	o: 9(t), 31(f)

nname: 32
n 32(None)[return None
]:
	i: 9(), 0(f)
	o: 

nname: 9
n 9(None)[if not self.selected['preview']:
	pass
return self.selected['preview']
]:
	i: 0(t)
	o: 32()

nname: 0
n 0(self.selected)[]:
	i: 
	o: 9(t), 32(f)

nname: 0
n 0(None)[if self.selected:
	if not self.selected['preview']:
		pass
	return self.selected['preview']
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb763e5cc>}
nname: 56
n 56(None)[return None
]:
	i: 43(JA), 51(), 55()
	o: 

nname: 55
n 55(None)[]:
	i: 0&9(f)
	o: 56()

nname: 51
n 51(None)[]:
	i: 23(f)
	o: 56()

nname: 43
n 43(None)[return 'embedded_media.png'
]:
	i: 23(t)
	o: 56(JA)

nname: 23
n 23(self.selected['uri'] != '::online::')[]:
	i: 0&9(t)
	o: 43(t), 51(f)

nname: 0&9
n 0&9(self.selected and self.selected['uri'])[]:
	i: 
	o: 23(t), 55(f)

nname: 0&9
n 0&9(None)[if self.selected and self.selected['uri']:
	if self.selected['uri'] != '::online::':
		return 'embedded_media.png'
return None
]:
	i: 
	o: 

self.nodes: {'0&9': <unpyclib.structure.node instance at 0xb763e60c>}
nname: 6
n 6(None)[__doc__ = "Basic player for Internet services. It's a text+thumbnail visualizer for\n    RSS feeds. Extra options are included in its hand menu that will enable the\n    user to trigger the playback of an item as sound/video/photo.\n    "
AUTOSCROLL_DELAY = 3
FRAGMENT_LENGTH = 50
BLOCKER_POS = 15
def __init__(self):
	Player.__init__(self, 'netplayer')
	self.eventhandler = NetPlayerEventHandler(self)
	self._getitems_keywords.update(title=(lambda : .selected:
		pass
	return u''), author=(lambda : .selected:
		pass
	return u''), date=self._get_date, link=(lambda : .selected:
		pass
	return u''), preview=self._get_preview, embedded_media=self._get_embedded_media, item_numbering=(lambda : '%s/%s' % (self.selected_pos + 1, len(self.choices))), words_list=(lambda : self.get_item_list('words_list')))
	self.set_items([], 'words_list')

def play(self, item=None, playlist=None, hide_previous_menu=True):
	Player.play(self, item, playlist, hide_previous_menu)
	self._update_words_list()

def select(self, val, list_name='main_list'):
	Player.select(self, val, list_name=list_name)
	if list_name == 'main_list':
		self._update_words_list()
		for key in ['title', 'author', 'date', 'link', 'preview', 'embedded_media', 'item_numbering']:
			send(key, sender=self, value=self[key])

def scroll_description(self, value):
	len_words_list = len(self['words_list'])
	if len_words_list > self.BLOCKER_POS:
		self.select(value, 'words_list')

def _update_words_list(self):
	items = []
	if not self.selected['description']:
		pass
	lines = self.selected['description'].splitlines()
	for line in lines:
		items.extend(<genexpr>(textwrap.wrap(line, self.FRAGMENT_LENGTH)))
	self.set_items(items, 'words_list')

def _get_date(self):
	if self.selected:
		return self.selected['date']
	return u''

def _get_preview(self):
	if self.selected:
		if not self.selected['preview']:
			pass
		return self.selected['preview']
	return None

def _get_embedded_media(self):
	if self.selected and self.selected['uri']:
		if self.selected['uri'] != '::online::':
			return 'embedded_media.png'
	return None

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb7638ccc>}
nname: 0
n 0(None)[from __future__ import absolute_import
import textwrap
from peewee.messages import send
from peewee.notifier import Task
from pygui.eventmanager.players.net_player import NetPlayerEventHandler
from pygui.item.core import Item
from pygui.menu import selective_gui_updater
from pygui.menu.players.core import Player
class NetPlayer(Player):
	__doc__ = "Basic player for Internet services. It's a text+thumbnail visualizer for\n    RSS feeds. Extra options are included in its hand menu that will enable the\n    user to trigger the playback of an item as sound/video/photo.\n    "
	AUTOSCROLL_DELAY = 3
	FRAGMENT_LENGTH = 50
	BLOCKER_POS = 15
	def __init__(self):
		Player.__init__(self, 'netplayer')
		self.eventhandler = NetPlayerEventHandler(self)
		self._getitems_keywords.update(title=(lambda : .selected:
			pass
		return u''), author=(lambda : .selected:
			pass
		return u''), date=self._get_date, link=(lambda : .selected:
			pass
		return u''), preview=self._get_preview, embedded_media=self._get_embedded_media, item_numbering=(lambda : '%s/%s' % (self.selected_pos + 1, len(self.choices))), words_list=(lambda : self.get_item_list('words_list')))
		self.set_items([], 'words_list')

	def play(self, item=None, playlist=None, hide_previous_menu=True):
		Player.play(self, item, playlist, hide_previous_menu)
		self._update_words_list()

	def select(self, val, list_name='main_list'):
		Player.select(self, val, list_name=list_name)
		if list_name == 'main_list':
			self._update_words_list()
			for key in ['title', 'author', 'date', 'link', 'preview', 'embedded_media', 'item_numbering']:
				send(key, sender=self, value=self[key])

	def scroll_description(self, value):
		len_words_list = len(self['words_list'])
		if len_words_list > self.BLOCKER_POS:
			self.select(value, 'words_list')

	def _update_words_list(self):
		items = []
		if not self.selected['description']:
			pass
		lines = self.selected['description'].splitlines()
		for line in lines:
			items.extend(<genexpr>(textwrap.wrap(line, self.FRAGMENT_LENGTH)))
		self.set_items(items, 'words_list')

	def _get_date(self):
		if self.selected:
			return self.selected['date']
		return u''

	def _get_preview(self):
		if self.selected:
			if not self.selected['preview']:
				pass
			return self.selected['preview']
		return None

	def _get_embedded_media(self):
		if self.selected and self.selected['uri']:
			if self.selected['uri'] != '::online::':
				return 'embedded_media.png'
		return None



]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7630e0c>}
from __future__ import absolute_import
import textwrap
from peewee.messages import send
from peewee.notifier import Task
from pygui.eventmanager.players.net_player import NetPlayerEventHandler
from pygui.item.core import Item
from pygui.menu import selective_gui_updater
from pygui.menu.players.core import Player
class NetPlayer(Player):
	__doc__ = "Basic player for Internet services. It's a text+thumbnail visualizer for\n    RSS feeds. Extra options are included in its hand menu that will enable the\n    user to trigger the playback of an item as sound/video/photo.\n    "
	AUTOSCROLL_DELAY = 3
	FRAGMENT_LENGTH = 50
	BLOCKER_POS = 15
	def __init__(self):
		Player.__init__(self, 'netplayer')
		self.eventhandler = NetPlayerEventHandler(self)
		self._getitems_keywords.update(title=(lambda : .selected:
			pass
		return u''), author=(lambda : .selected:
			pass
		return u''), date=self._get_date, link=(lambda : .selected:
			pass
		return u''), preview=self._get_preview, embedded_media=self._get_embedded_media, item_numbering=(lambda : '%s/%s' % (self.selected_pos + 1, len(self.choices))), words_list=(lambda : self.get_item_list('words_list')))
		self.set_items([], 'words_list')

	def play(self, item=None, playlist=None, hide_previous_menu=True):
		Player.play(self, item, playlist, hide_previous_menu)
		self._update_words_list()

	def select(self, val, list_name='main_list'):
		Player.select(self, val, list_name=list_name)
		if list_name == 'main_list':
			self._update_words_list()
			for key in ['title', 'author', 'date', 'link', 'preview', 'embedded_media', 'item_numbering']:
				send(key, sender=self, value=self[key])

	def scroll_description(self, value):
		len_words_list = len(self['words_list'])
		if len_words_list > self.BLOCKER_POS:
			self.select(value, 'words_list')

	def _update_words_list(self):
		items = []
		if not self.selected['description']:
			pass
		lines = self.selected['description'].splitlines()
		for line in lines:
			items.extend(<genexpr>(textwrap.wrap(line, self.FRAGMENT_LENGTH)))
		self.set_items(items, 'words_list')

	def _get_date(self):
		if self.selected:
			return self.selected['date']
		return u''

	def _get_preview(self):
		if self.selected:
			if not self.selected['preview']:
				pass
			return self.selected['preview']
		return None

	def _get_embedded_media(self):
		if self.selected and self.selected['uri']:
			if self.selected['uri'] != '::online::':
				return 'embedded_media.png'
		return None



