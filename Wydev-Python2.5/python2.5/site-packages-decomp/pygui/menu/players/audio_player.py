# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 0
n 0(None)[return self.get_item_list('edit_list')
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75cff0c>}
nname: 23
n 23(None)[return self.selected['metadata_title']
]:
	i: 0(t), 13()
	o: 

nname: 13
n 13(None)[]:
	i: 0(f)
	o: 23()

nname: 0
n 0(self.selected['metadata_title'])[]:
	i: 
	o: 13(f), 23(t)

nname: 0
n 0(None)[if not self.selected['metadata_title']:
	pass
return self.selected['metadata_title']
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75d804c>}
nname: 0
n 0(None)[return self.selected['author']
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75cff8c>}
nname: 0
n 0(None)[return self.selected['album']
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75cfeec>}
nname: 17
n 17(None)[return self.selected['track']
]:
	i: 0(t), 13()
	o: 

nname: 13
n 13(None)[]:
	i: 0(f)
	o: 17()

nname: 0
n 0(self.selected['track'])[]:
	i: 
	o: 13(f), 17(t)

nname: 0
n 0(None)[if not self.selected['track']:
	pass
return self.selected['track']
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75d80cc>}
nname: 313
n 313(None)[self._status_change_callback.task._considered_idle = True
self._start_playing.task._considered_idle = True
self.update_media_info.task._considered_idle = True
return None
]:
	i: 0(AL), 312()
	o: 

nname: 312
n 312(None)[]:
	i: 268(AF), 278()
	o: 313()

nname: 278
n 278(None)[for sig in AudioPlayer.caching_sig:
louie_connect(receiver=self._callback_fill_list, sender='audio', signal=sig)
]:
	i: 268(for)
	o: 312()

nname: 268
n 268(None)[]:
	i: 0(loop)
	o: 278(for), 312(AF)

nname: 0
n 0(None)[Player.__init__(self, 'audioplayer')
WPlayer.__init__(self)
def self._getitems_keywords['edit_list']():
	return self.get_item_list('edit_list')

def self._getitems_keywords['title']():
	if not self.selected['metadata_title']:
		pass
	return self.selected['metadata_title']

def self._getitems_keywords['artist']():
	return self.selected['author']

def self._getitems_keywords['album']():
	return self.selected['album']

def self._getitems_keywords['track']():
	if not self.selected['track']:
		pass
	return self.selected['track']

self.tasks.update({'show_help_playlist': Task(self._show_help_playlist), 'hide_help_playlist': Task(self._hide_help_playlist)})
self.set_items([], 'edit_list')
self.eventhandler = AudioEventHandler(self)
self.available_choices.append('edit_list')
self._old_played_dt = None
self._old_played = None
self._current_played = None
]:
	i: 
	o: 268(loop), 313(AL)

nname: 313
n 313(None)[self._status_change_callback.task._considered_idle = True
self._start_playing.task._considered_idle = True
self.update_media_info.task._considered_idle = True
return None
]:
	i: 278()
	o: 

nname: 278
n 278(None)[for sig in AudioPlayer.caching_sig:
	louie_connect(receiver=self._callback_fill_list, sender='audio', signal=sig)
]:
	i: 0(for)
	o: 313()

nname: 0
n 0(None)[Player.__init__(self, 'audioplayer')
WPlayer.__init__(self)
def self._getitems_keywords['edit_list']():
	return self.get_item_list('edit_list')

def self._getitems_keywords['title']():
	if not self.selected['metadata_title']:
		pass
	return self.selected['metadata_title']

def self._getitems_keywords['artist']():
	return self.selected['author']

def self._getitems_keywords['album']():
	return self.selected['album']

def self._getitems_keywords['track']():
	if not self.selected['track']:
		pass
	return self.selected['track']

self.tasks.update({'show_help_playlist': Task(self._show_help_playlist), 'hide_help_playlist': Task(self._hide_help_playlist)})
self.set_items([], 'edit_list')
self.eventhandler = AudioEventHandler(self)
self.available_choices.append('edit_list')
self._old_played_dt = None
self._old_played = None
self._current_played = None
]:
	i: 
	o: 278(for)

nname: 313
n 313(None)[self._status_change_callback.task._considered_idle = True
self._start_playing.task._considered_idle = True
self.update_media_info.task._considered_idle = True
return None
]:
	i: 0()
	o: 

nname: 0
n 0(None)[Player.__init__(self, 'audioplayer')
WPlayer.__init__(self)
def self._getitems_keywords['edit_list']():
	return self.get_item_list('edit_list')

def self._getitems_keywords['title']():
	if not self.selected['metadata_title']:
		pass
	return self.selected['metadata_title']

def self._getitems_keywords['artist']():
	return self.selected['author']

def self._getitems_keywords['album']():
	return self.selected['album']

def self._getitems_keywords['track']():
	if not self.selected['track']:
		pass
	return self.selected['track']

self.tasks.update({'show_help_playlist': Task(self._show_help_playlist), 'hide_help_playlist': Task(self._hide_help_playlist)})
self.set_items([], 'edit_list')
self.eventhandler = AudioEventHandler(self)
self.available_choices.append('edit_list')
self._old_played_dt = None
self._old_played = None
self._current_played = None
for sig in AudioPlayer.caching_sig:
	louie_connect(receiver=self._callback_fill_list, sender='audio', signal=sig)
]:
	i: 
	o: 313()

nname: 0
n 0(None)[Player.__init__(self, 'audioplayer')
WPlayer.__init__(self)
def self._getitems_keywords['edit_list']():
	return self.get_item_list('edit_list')

def self._getitems_keywords['title']():
	if not self.selected['metadata_title']:
		pass
	return self.selected['metadata_title']

def self._getitems_keywords['artist']():
	return self.selected['author']

def self._getitems_keywords['album']():
	return self.selected['album']

def self._getitems_keywords['track']():
	if not self.selected['track']:
		pass
	return self.selected['track']

self.tasks.update({'show_help_playlist': Task(self._show_help_playlist), 'hide_help_playlist': Task(self._hide_help_playlist)})
self.set_items([], 'edit_list')
self.eventhandler = AudioEventHandler(self)
self.available_choices.append('edit_list')
self._old_played_dt = None
self._old_played = None
self._current_played = None
for sig in AudioPlayer.caching_sig:
	louie_connect(receiver=self._callback_fill_list, sender='audio', signal=sig)
self._status_change_callback.task._considered_idle = True
self._start_playing.task._considered_idle = True
self.update_media_info.task._considered_idle = True
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75c8aac>}
nname: 0
n 0(None)[self.tasks['tick'].start(self._timers_interval, loop=True, consider_idle=True)
self.tasks['screensaver_block'].start(delay=config.user_config['power']['screensaver_threshold'] - 1, loop=True, consider_idle=True)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75c9c6c>}
nname: 0
n 0(None)[return False
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75c984c>}
nname: 203
n 203(None)[return ret
]:
	i: 108(), 145(), 177(), 202(AE)
	o: 

nname: 177
n 177(None)[log.warn('error removing current position from unplayed_positions: %s', self.selected_pos)
]:
	i: 141(except)
	o: 203()

nname: 145
n 145(None)[idx = self._unplayed_positions.index(pos)
del self._unplayed_positions[idx]
]:
	i: 141(try)
	o: 203()

nname: 141
n 141(None)[]:
	i: 66(t)
	o: 145(try), 177(except)

nname: 108
n 108(None)[log.error('unable to select track %s', pos)
self.stack.close_player()
]:
	i: 66(f)
	o: 203()

nname: 66
n 66(ret)[pos = choice(self._unplayed_positions)
ret = self.select(pos, force_pos=True)
]:
	i: 25(JA), 48(), 65()
	o: 108(f), 141(t)

nname: 65
n 65(None)[]:
	i: 0(t)
	o: 66()

nname: 48
n 48(None)[self.stack.close_player()
]:
	i: 9(f)
	o: 66()

nname: 25
n 25(None)[self.random_mode = False
self.go_random()
]:
	i: 9(t)
	o: 66(JA)

nname: 9
n 9(self.repeat_mode == 'all')[]:
	i: 0(f)
	o: 25(t), 48(f)

nname: 0
n 0(self._unplayed_positions)[]:
	i: 
	o: 9(f), 65(t)

nname: 203
n 203(None)[return ret
]:
	i: 108(), 177()
	o: 

nname: 177
n 177(None)[except:
	log.warn('error removing current position from unplayed_positions: %s', self.selected_pos)
]:
	i: 141()
	o: 203()

nname: 141
n 141(None)[try:
	idx = self._unplayed_positions.index(pos)
	del self._unplayed_positions[idx]
]:
	i: 0(t)
	o: 177()

nname: 108
n 108(None)[log.error('unable to select track %s', pos)
self.stack.close_player()
]:
	i: 0(f)
	o: 203()

nname: 0
n 0(ret)[if not self._unplayed_positions:
	if self.repeat_mode == 'all':
		self.random_mode = False
		self.go_random()
	else:
		self.stack.close_player()
pos = choice(self._unplayed_positions)
ret = self.select(pos, force_pos=True)
]:
	i: 
	o: 108(f), 141(t)

nname: 203
n 203(None)[return ret
]:
	i: 108(), 141()
	o: 

nname: 141
n 141(None)[try:
	idx = self._unplayed_positions.index(pos)
	del self._unplayed_positions[idx]
except:
	log.warn('error removing current position from unplayed_positions: %s', self.selected_pos)
]:
	i: 0(t)
	o: 203()

nname: 108
n 108(None)[log.error('unable to select track %s', pos)
self.stack.close_player()
]:
	i: 0(f)
	o: 203()

nname: 0
n 0(ret)[if not self._unplayed_positions:
	if self.repeat_mode == 'all':
		self.random_mode = False
		self.go_random()
	else:
		self.stack.close_player()
pos = choice(self._unplayed_positions)
ret = self.select(pos, force_pos=True)
]:
	i: 
	o: 108(f), 141(t)

nname: 0
n 0(None)[if not self._unplayed_positions:
	if self.repeat_mode == 'all':
		self.random_mode = False
		self.go_random()
	else:
		self.stack.close_player()
pos = choice(self._unplayed_positions)
ret = self.select(pos, force_pos=True)
if not ret:
	log.error('unable to select track %s', pos)
	self.stack.close_player()
else:
	try:
		idx = self._unplayed_positions.index(pos)
		del self._unplayed_positions[idx]
	except:
		log.warn('error removing current position from unplayed_positions: %s', self.selected_pos)
return ret
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75c84ec>}
nname: 308
n 308(None)[return None
]:
	i: 9(), 291(JA), 303(), 307()
	o: 

nname: 307
n 307(None)[]:
	i: 31(f)
	o: 308()

nname: 303
n 303(None)[]:
	i: 164(f)
	o: 308()

nname: 291
n 291(None)[self.random_mode = True
]:
	i: 230(), 265(), 290(AE)
	o: 308(JA)

nname: 265
n 265(None)[log.warn('error removing current position from unplayed_positions: %s', self.selected_pos)
]:
	i: 170(except)
	o: 291()

nname: 230
n 230(None)[idx = self._unplayed_positions.index(self.selected_pos)
del self._unplayed_positions[idx]
]:
	i: 170(try)
	o: 291()

nname: 170
n 170(None)[npl.wymedia_resource['childCount'] = str(npl.get_child_count())
self._unplayed_positions = range(0, int(npl.wymedia_resource['childCount']))
]:
	i: 164(t)
	o: 230(try), 265(except)

nname: 164
n 164(npl)[]:
	i: 73(), 150(), 163()
	o: 170(t), 303(f)

nname: 163
n 163(None)[]:
	i: 100(f)
	o: 164()

nname: 150
n 150(None)[npl = fl.now_playing
]:
	i: 100(t)
	o: 164()

nname: 100
n 100(fl is not None)[from pygui.markerlist import markerlists
fl = markerlists().get(self.universe)
]:
	i: 41(f)
	o: 150(t), 163(f)

nname: 73
n 73(None)[npl = self.selected.npl_dict[self.universe + ':npl']
]:
	i: 41(t)
	o: 164()

nname: 41
n 41(self.universe + ':npl' in self.selected.npl_dict)[npl = None
]:
	i: 31(t)
	o: 73(t), 100(f)

nname: 31
n 31(self.selected)[]:
	i: 0(f)
	o: 41(t), 307(f)

nname: 9
n 9(None)[self.random_mode = False
self._unplayed_positions = []
]:
	i: 0(t)
	o: 308()

nname: 0
n 0(self.random_mode)[]:
	i: 
	o: 9(t), 31(f)

nname: 308
n 308(None)[return None
]:
	i: 9(), 265(JA), 41(f), 31(f)
	o: 

nname: 265
n 265(None)[except:
	log.warn('error removing current position from unplayed_positions: %s', self.selected_pos)
self.random_mode = True
]:
	i: 170()
	o: 308(JA)

nname: 170
n 170(None)[npl.wymedia_resource['childCount'] = str(npl.get_child_count())
self._unplayed_positions = range(0, int(npl.wymedia_resource['childCount']))
try:
	idx = self._unplayed_positions.index(self.selected_pos)
	del self._unplayed_positions[idx]
]:
	i: 41(t)
	o: 265()

nname: 41
n 41(npl)[npl = None
if self.universe + ':npl' in self.selected.npl_dict:
	npl = self.selected.npl_dict[self.universe + ':npl']
else:
	from pygui.markerlist import markerlists
	fl = markerlists().get(self.universe)
	if fl is not None:
		npl = fl.now_playing
]:
	i: 31(t)
	o: 170(t), 308(f)

nname: 31
n 31(self.selected)[]:
	i: 0(f)
	o: 41(t), 308(f)

nname: 9
n 9(None)[self.random_mode = False
self._unplayed_positions = []
]:
	i: 0(t)
	o: 308()

nname: 0
n 0(self.random_mode)[]:
	i: 
	o: 9(t), 31(f)

nname: 308
n 308(None)[return None
]:
	i: 9(), 170(JA), 41(f), 31(f)
	o: 

nname: 170
n 170(None)[npl.wymedia_resource['childCount'] = str(npl.get_child_count())
self._unplayed_positions = range(0, int(npl.wymedia_resource['childCount']))
try:
	idx = self._unplayed_positions.index(self.selected_pos)
	del self._unplayed_positions[idx]
except:
	log.warn('error removing current position from unplayed_positions: %s', self.selected_pos)
self.random_mode = True
]:
	i: 41(t)
	o: 308(JA)

nname: 41
n 41(npl)[npl = None
if self.universe + ':npl' in self.selected.npl_dict:
	npl = self.selected.npl_dict[self.universe + ':npl']
else:
	from pygui.markerlist import markerlists
	fl = markerlists().get(self.universe)
	if fl is not None:
		npl = fl.now_playing
]:
	i: 31(t)
	o: 170(t), 308(f)

nname: 31
n 31(self.selected)[]:
	i: 0(f)
	o: 41(t), 308(f)

nname: 9
n 9(None)[self.random_mode = False
self._unplayed_positions = []
]:
	i: 0(t)
	o: 308()

nname: 0
n 0(self.random_mode)[]:
	i: 
	o: 9(t), 31(f)

nname: 0
n 0(None)[if self.random_mode:
	self.random_mode = False
	self._unplayed_positions = []
else:
	if self.selected:
		npl = None
		if self.universe + ':npl' in self.selected.npl_dict:
			npl = self.selected.npl_dict[self.universe + ':npl']
		else:
			from pygui.markerlist import markerlists
			fl = markerlists().get(self.universe)
			if fl is not None:
				npl = fl.now_playing
		if npl:
			npl.wymedia_resource['childCount'] = str(npl.get_child_count())
			self._unplayed_positions = range(0, int(npl.wymedia_resource['childCount']))
			try:
				idx = self._unplayed_positions.index(self.selected_pos)
				del self._unplayed_positions[idx]
			except:
				log.warn('error removing current position from unplayed_positions: %s', self.selected_pos)
			self.random_mode = True
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75cfa0c>}
nname: 236
n 236(None)[return None
]:
	i: 162(), 211(), 234(AE)
	o: 

nname: 234
n 234(None)[]:
	i: 201(f)
	o: 236(AE)

nname: 211
n 211(None)[log.warn('%s.watch failed !', sel)
]:
	i: 201(t)
	o: 236()

nname: 201
n 201(<dummy_ex3> EXC_MATCH AttributeError)[]:
	i: 66(except)
	o: 211(t), 234(f)

nname: 162
n 162(None)[sel = main_list.selected
sel.watch(self._selection_changed)
sel.async_media_update()
]:
	i: 66(try)
	o: 236()

nname: 66
n 66(None)[self._old_played_dt = main_list.selected.display_type
main_list.selected.display_type = 'audioplayer_audio_playing'
log.debug('loudspeaker icon %s -> %s', self._old_played, main_list.selected)
louie_send('edit_list', sender=self, action='reset', value=edit_list)
self._selection_changed(None)
]:
	i: 53(), 65()
	o: 162(try), 201(except)

nname: 65
n 65(None)[]:
	i: 0(f)
	o: 66()

nname: 53
n 53(None)[self._old_played.display_type = self._old_played_dt
]:
	i: 39(t), 49()
	o: 66()

nname: 49
n 49(None)[]:
	i: 39(f)
	o: 53()

nname: 39
n 39(self._old_played_dt)[]:
	i: 0(t)
	o: 49(f), 53(t)

nname: 0
n 0(self._old_played)[main_list = self.get_item_list('main_list')
edit_list = self.get_item_list('edit_list')
]:
	i: 
	o: 39(t), 65(f)

nname: 201
n 201(None)[except AttributeError:
	log.warn('%s.watch failed !', sel)
return None
]:
	i: 66()
	o: 

nname: 66
n 66(None)[self._old_played_dt = main_list.selected.display_type
main_list.selected.display_type = 'audioplayer_audio_playing'
log.debug('loudspeaker icon %s -> %s', self._old_played, main_list.selected)
louie_send('edit_list', sender=self, action='reset', value=edit_list)
self._selection_changed(None)
try:
	sel = main_list.selected
	sel.watch(self._selection_changed)
	sel.async_media_update()
]:
	i: 39(), 0(f)
	o: 201()

nname: 39
n 39(None)[if not self._old_played_dt:
	pass
self._old_played.display_type = self._old_played_dt
]:
	i: 0(t)
	o: 66()

nname: 0
n 0(self._old_played)[main_list = self.get_item_list('main_list')
edit_list = self.get_item_list('edit_list')
]:
	i: 
	o: 39(t), 66(f)

nname: 201
n 201(None)[except AttributeError:
	log.warn('%s.watch failed !', sel)
return None
]:
	i: 0()
	o: 

nname: 0
n 0(None)[main_list = self.get_item_list('main_list')
edit_list = self.get_item_list('edit_list')
if self._old_played:
	if not self._old_played_dt:
		pass
	self._old_played.display_type = self._old_played_dt
self._old_played_dt = main_list.selected.display_type
main_list.selected.display_type = 'audioplayer_audio_playing'
log.debug('loudspeaker icon %s -> %s', self._old_played, main_list.selected)
louie_send('edit_list', sender=self, action='reset', value=edit_list)
self._selection_changed(None)
try:
	sel = main_list.selected
	sel.watch(self._selection_changed)
	sel.async_media_update()
]:
	i: 
	o: 201()

nname: 0
n 0(None)[main_list = self.get_item_list('main_list')
edit_list = self.get_item_list('edit_list')
if self._old_played:
	if not self._old_played_dt:
		pass
	self._old_played.display_type = self._old_played_dt
self._old_played_dt = main_list.selected.display_type
main_list.selected.display_type = 'audioplayer_audio_playing'
log.debug('loudspeaker icon %s -> %s', self._old_played, main_list.selected)
louie_send('edit_list', sender=self, action='reset', value=edit_list)
self._selection_changed(None)
try:
	sel = main_list.selected
	sel.watch(self._selection_changed)
	sel.async_media_update()
except AttributeError:
	log.warn('%s.watch failed !', sel)
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75c818c>}
nname: 189
n 189(None)[return None
]:
	i: 153(), 188()
	o: 

nname: 188
n 188(None)[]:
	i: 131(f)
	o: 189()

nname: 153
n 153(None)[screensaver.refresh_metadata(self['title'], self['artist'], self['album'])
]:
	i: 131(t)
	o: 189()

nname: 131
n 131(screensaver is not None)[screensaver = pygui_globs['screensaver']
]:
	i: 3(), 111(), 130(AE)
	o: 153(t), 188(f)

nname: 111
n 111(None)[log.error('Tags error')
]:
	i: 0(except)
	o: 131()

nname: 3
n 3(None)[louie_send('title', sender=self, value=self['title'])
louie_send('artist', sender=self, value=self['artist'])
louie_send('album', sender=self, value=self['album'])
louie_send('track', sender=self, value=self['track'])
]:
	i: 0(try)
	o: 131()

nname: 0
n 0(None)[]:
	i: 
	o: 3(try), 111(except)

nname: 189
n 189(None)[return None
]:
	i: 111()
	o: 

nname: 111
n 111(None)[except:
	log.error('Tags error')
screensaver = pygui_globs['screensaver']
if screensaver is not None:
	screensaver.refresh_metadata(self['title'], self['artist'], self['album'])
]:
	i: 0()
	o: 189()

nname: 0
n 0(None)[try:
	louie_send('title', sender=self, value=self['title'])
	louie_send('artist', sender=self, value=self['artist'])
	louie_send('album', sender=self, value=self['album'])
	louie_send('track', sender=self, value=self['track'])
]:
	i: 
	o: 111()

nname: 189
n 189(None)[return None
]:
	i: 0()
	o: 

nname: 0
n 0(None)[try:
	louie_send('title', sender=self, value=self['title'])
	louie_send('artist', sender=self, value=self['artist'])
	louie_send('album', sender=self, value=self['album'])
	louie_send('track', sender=self, value=self['track'])
except:
	log.error('Tags error')
screensaver = pygui_globs['screensaver']
if screensaver is not None:
	screensaver.refresh_metadata(self['title'], self['artist'], self['album'])
]:
	i: 
	o: 189()

nname: 0
n 0(None)[try:
	louie_send('title', sender=self, value=self['title'])
	louie_send('artist', sender=self, value=self['artist'])
	louie_send('album', sender=self, value=self['album'])
	louie_send('track', sender=self, value=self['track'])
except:
	log.error('Tags error')
screensaver = pygui_globs['screensaver']
if screensaver is not None:
	screensaver.refresh_metadata(self['title'], self['artist'], self['album'])
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75c808c>}
nname: 233
n 233(None)[return sel_ret
]:
	i: 202(), 232()
	o: 

nname: 232
n 232(None)[]:
	i: 163(f)
	o: 233()

nname: 202
n 202(None)[louie_send('event_up', self)
self.song_changed()
self._start_playing()
]:
	i: 175&191(t), 198()
	o: 233()

nname: 198
n 198(None)[]:
	i: 175&191(f)
	o: 202()

nname: 175&191
n 175&191(val > 0 and 'event_down')[]:
	i: 163(t)
	o: 198(f), 202(t)

nname: 163
n 163(sel_ret is True)[]:
	i: 154(), 162()
	o: 175&191(t), 232(f)

nname: 162
n 162(None)[]:
	i: 112(f)
	o: 163()

nname: 154
n 154(None)[return sel_ret
]:
	i: 112(t)
	o: 163()

nname: 112
n 112(list_name != 'main_list')[sel_ret = Player.select(self, val, list_name=list_name, force_pos=force_pos)
]:
	i: 47(JA), 80(JA), 108(), 111()
	o: 154(t), 162(f)

nname: 111
n 111(None)[]:
	i: 22(f)
	o: 112()

nname: 108
n 108(None)[]:
	i: 106(AE)
	o: 112()

nname: 106
n 106(None)[]:
	i: 70(f)
	o: 108(AE)

nname: 80
n 80(None)[log.info('Item %s is not unwatchable', self._old_played)
]:
	i: 70(t)
	o: 112(JA)

nname: 70
n 70(<dummy_ex3> EXC_MATCH AttributeError)[]:
	i: 43(except)
	o: 80(t), 106(f)

nname: 47
n 47(None)[self._old_played.unwatch(self._selection_changed)
]:
	i: 43(try)
	o: 112(JA)

nname: 43
n 43(None)[]:
	i: 22(t)
	o: 47(try), 70(except)

nname: 22
n 22(self._old_played is not None)[self._old_played = self.get_item_list('main_list').selected
]:
	i: 0(t), 18()
	o: 43(t), 111(f)

nname: 18
n 18(None)[]:
	i: 0(f)
	o: 22()

nname: 0
n 0(self.get_item_list('main_list').selected)[]:
	i: 
	o: 18(f), 22(t)

nname: 233
n 233(None)[return sel_ret
]:
	i: 175&191(), 112(f)
	o: 

nname: 175&191
n 175&191(None)[if not(val > 0 and 'event_down'):
	pass
louie_send('event_up', self)
self.song_changed()
self._start_playing()
]:
	i: 112(t)
	o: 233()

nname: 112
n 112(sel_ret is True)[sel_ret = Player.select(self, val, list_name=list_name, force_pos=force_pos)
if list_name != 'main_list':
	return sel_ret
]:
	i: 47(JA), 80(JA), 70(f), 106(AE), 0(f)
	o: 175&191(t), 233(f)

nname: 80
n 80(None)[log.info('Item %s is not unwatchable', self._old_played)
]:
	i: 70(t)
	o: 112(JA)

nname: 70
n 70(<dummy_ex3> EXC_MATCH AttributeError)[]:
	i: 43(except)
	o: 80(t), 112(f)

nname: 47
n 47(None)[self._old_played.unwatch(self._selection_changed)
]:
	i: 43(try)
	o: 112(JA)

nname: 43
n 43(None)[]:
	i: 0(t)
	o: 47(try), 70(except)

nname: 0
n 0(self._old_played is not None)[if not self.get_item_list('main_list').selected:
	pass
self._old_played = self.get_item_list('main_list').selected
]:
	i: 
	o: 43(t), 112(f)

nname: 112
n 112(None)[sel_ret = Player.select(self, val, list_name=list_name, force_pos=force_pos)
if list_name != 'main_list':
	return sel_ret
if sel_ret is True:
	if not(val > 0 and 'event_down'):
		pass
	louie_send('event_up', self)
	self.song_changed()
	self._start_playing()
return sel_ret
]:
	i: 70(f), 0(f)
	o: 

nname: 70
n 70(None)[except AttributeError:
	log.info('Item %s is not unwatchable', self._old_played)
]:
	i: 43()
	o: 112(JA)

nname: 43
n 43(None)[try:
	self._old_played.unwatch(self._selection_changed)
]:
	i: 0(t)
	o: 70()

nname: 0
n 0(self._old_played is not None)[if not self.get_item_list('main_list').selected:
	pass
self._old_played = self.get_item_list('main_list').selected
]:
	i: 
	o: 43(t), 112(f)

nname: 112
n 112(None)[sel_ret = Player.select(self, val, list_name=list_name, force_pos=force_pos)
if list_name != 'main_list':
	return sel_ret
if sel_ret is True:
	if not(val > 0 and 'event_down'):
		pass
	louie_send('event_up', self)
	self.song_changed()
	self._start_playing()
return sel_ret
]:
	i: 43(f), 0(f)
	o: 

nname: 43
n 43(None)[try:
	self._old_played.unwatch(self._selection_changed)
except AttributeError:
	log.info('Item %s is not unwatchable', self._old_played)
]:
	i: 0(t)
	o: 112(JA)

nname: 0
n 0(self._old_played is not None)[if not self.get_item_list('main_list').selected:
	pass
self._old_played = self.get_item_list('main_list').selected
]:
	i: 
	o: 43(t), 112(f)

nname: 0
n 0(None)[if not self.get_item_list('main_list').selected:
	pass
self._old_played = self.get_item_list('main_list').selected
if self._old_played is not None:
	try:
		self._old_played.unwatch(self._selection_changed)
	except AttributeError:
		log.info('Item %s is not unwatchable', self._old_played)
sel_ret = Player.select(self, val, list_name=list_name, force_pos=force_pos)
if list_name != 'main_list':
	return sel_ret
if sel_ret is True:
	if not(val > 0 and 'event_down'):
		pass
	louie_send('event_up', self)
	self.song_changed()
	self._start_playing()
return sel_ret
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75c80cc>}
nname: 127
n 127(None)[self.song_changed()
self._start_playing()
]:
	i: 30(), 100(JA), 122(), 126(AE)
	o: 

nname: 122
n 122(None)[]:
	i: 69(f)
	o: 127()

nname: 100
n 100(None)[pygui_globs['menustack'].close_player()
]:
	i: 69(t)
	o: 127(JA)

nname: 69
n 69(self._check_exception(_("Can't find media")))[PRINT_EXCEPTION()
]:
	i: 0(except)
	o: 100(t), 122(f)

nname: 30
n 30(None)[log.debug('PLAY(%s)', item)
Player.play(self, item, playlist)
]:
	i: 0(try)
	o: 127()

nname: 0
n 0(None)[self.time_elapsed = 0.0
self.random_mode = False
self._unplayed_positions = []
]:
	i: 
	o: 30(try), 69(except)

nname: 69
n 69(None)[except:
	PRINT_EXCEPTION()
	if self._check_exception(_("Can't find media")):
		pygui_globs['menustack'].close_player()
self.song_changed()
self._start_playing()
]:
	i: 0()
	o: 

nname: 0
n 0(None)[self.time_elapsed = 0.0
self.random_mode = False
self._unplayed_positions = []
try:
	log.debug('PLAY(%s)', item)
	Player.play(self, item, playlist)
]:
	i: 
	o: 69()

nname: 0
n 0(None)[self.time_elapsed = 0.0
self.random_mode = False
self._unplayed_positions = []
try:
	log.debug('PLAY(%s)', item)
	Player.play(self, item, playlist)
except:
	PRINT_EXCEPTION()
	if self._check_exception(_("Can't find media")):
		pygui_globs['menustack'].close_player()
self.song_changed()
self._start_playing()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75c970c>}
nname: 233
n 233(None)[]:
	i: 143(AL), 232()
	o: 

nname: 232
n 232(None)[]:
	i: 188(AF), 198()
	o: 233()

nname: 198
n 198(None)[for sig in AudioPlayer.caching_sig:
louie_disconnect(receiver=self._callback_fill_list, signal=sig, sender='audio')
]:
	i: 188(for)
	o: 232()

nname: 188
n 188(None)[]:
	i: 143(loop)
	o: 198(for), 232(AF)

nname: 143
n 143(None)[self._start_playing.task.stop()
WPlayer.stop(self)
Player.stop(self)
]:
	i: 64(), 106(), 141(AE)
	o: 188(loop), 233(AL)

nname: 141
n 141(None)[]:
	i: 96(f)
	o: 143(AE)

nname: 106
n 106(None)[log.info('Item %s is not unwatchable', self.get_item_list('main_list').selected)
]:
	i: 96(t)
	o: 143()

nname: 96
n 96(<dummy_ex3> EXC_MATCH AttributeError)[]:
	i: 61(except)
	o: 106(t), 141(f)

nname: 64
n 64(None)[self.get_item_list('main_list').selected.unwatch(self._selection_changed)
]:
	i: 61(try)
	o: 143()

nname: 61
n 61(None)[]:
	i: 28(), 60()
	o: 64(try), 96(except)

nname: 60
n 60(None)[]:
	i: 0(f)
	o: 61()

nname: 28
n 28(None)[self.get_item_list('edit_list').edited = False
self.focus_previous()
]:
	i: 0(t)
	o: 61()

nname: 0
n 0(self.active_list == 'edit_list')[log.debug('stop() on MMI PLAYER')
]:
	i: 
	o: 28(t), 60(f)

nname: 233
n 233(None)[]:
	i: 198()
	o: 

nname: 198
n 198(None)[for sig in AudioPlayer.caching_sig:
	louie_disconnect(receiver=self._callback_fill_list, signal=sig, sender='audio')
]:
	i: 143(for)
	o: 233()

nname: 143
n 143(None)[self._start_playing.task.stop()
WPlayer.stop(self)
Player.stop(self)
]:
	i: 64()
	o: 198(for)

nname: 64
n 64(None)[try:
	self.get_item_list('main_list').selected.unwatch(self._selection_changed)
except AttributeError:
	log.info('Item %s is not unwatchable', self.get_item_list('main_list').selected)
]:
	i: 0(try)
	o: 143()

nname: 0
n 0(None)[log.debug('stop() on MMI PLAYER')
if self.active_list == 'edit_list':
	self.get_item_list('edit_list').edited = False
	self.focus_previous()
]:
	i: 
	o: 64(try)

nname: 233
n 233(None)[]:
	i: 143()
	o: 

nname: 143
n 143(None)[self._start_playing.task.stop()
WPlayer.stop(self)
Player.stop(self)
for sig in AudioPlayer.caching_sig:
	louie_disconnect(receiver=self._callback_fill_list, signal=sig, sender='audio')
]:
	i: 0()
	o: 233()

nname: 0
n 0(None)[log.debug('stop() on MMI PLAYER')
if self.active_list == 'edit_list':
	self.get_item_list('edit_list').edited = False
	self.focus_previous()
try:
	self.get_item_list('main_list').selected.unwatch(self._selection_changed)
except AttributeError:
	log.info('Item %s is not unwatchable', self.get_item_list('main_list').selected)
]:
	i: 
	o: 143()

nname: 233
n 233(None)[]:
	i: 0()
	o: 

nname: 0
n 0(None)[log.debug('stop() on MMI PLAYER')
if self.active_list == 'edit_list':
	self.get_item_list('edit_list').edited = False
	self.focus_previous()
try:
	self.get_item_list('main_list').selected.unwatch(self._selection_changed)
except AttributeError:
	log.info('Item %s is not unwatchable', self.get_item_list('main_list').selected)
self._start_playing.task.stop()
WPlayer.stop(self)
Player.stop(self)
for sig in AudioPlayer.caching_sig:
	louie_disconnect(receiver=self._callback_fill_list, signal=sig, sender='audio')
]:
	i: 
	o: 233()

nname: 0
n 0(None)[log.debug('stop() on MMI PLAYER')
if self.active_list == 'edit_list':
	self.get_item_list('edit_list').edited = False
	self.focus_previous()
try:
	self.get_item_list('main_list').selected.unwatch(self._selection_changed)
except AttributeError:
	log.info('Item %s is not unwatchable', self.get_item_list('main_list').selected)
self._start_playing.task.stop()
WPlayer.stop(self)
Player.stop(self)
for sig in AudioPlayer.caching_sig:
	louie_disconnect(receiver=self._callback_fill_list, signal=sig, sender='audio')
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75cf7ac>}
nname: 0
n 0(None)[edit_list.set_items(self.get_item_list('main_list'))
edit_list.select(self.selected)
self.focus_next()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75c9bec>}
nname: 48
n 48(None)[]:
	i: 17(), 47()
	o: 

nname: 47
n 47(None)[]:
	i: 0(f)
	o: 48()

nname: 17
n 17(None)[louie_send('show_help_playlist', sender=self)
self.hide_help_playlist()
]:
	i: 0(t)
	o: 48()

nname: 0
n 0(config.user_config['base']['help_banner'])[]:
	i: 
	o: 17(t), 47(f)

nname: 0
n 0(None)[if config.user_config['base']['help_banner']:
	louie_send('show_help_playlist', sender=self)
	self.hide_help_playlist()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75c9d0c>}
nname: 34
n 34(None)[]:
	i: 9(), 33()
	o: 

nname: 33
n 33(None)[]:
	i: 0(f)
	o: 34()

nname: 9
n 9(None)[self.tasks['show_help_playlist'].start(0.5)
]:
	i: 0(t)
	o: 34()

nname: 0
n 0(self.show_help_banner)[]:
	i: 
	o: 9(t), 33(f)

nname: 0
n 0(None)[if self.show_help_banner:
	self.tasks['show_help_playlist'].start(0.5)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75c9a0c>}
nname: 41
n 41(None)[]:
	i: 23(), 40()
	o: 

nname: 40
n 40(None)[]:
	i: 0(f)
	o: 41()

nname: 23
n 23(None)[louie_send('hide_help_playlist', self)
]:
	i: 0(t)
	o: 41()

nname: 0
n 0(config.user_config['base']['help_banner'] != 1)[]:
	i: 
	o: 23(t), 40(f)

nname: 0
n 0(None)[if config.user_config['base']['help_banner'] != 1:
	louie_send('hide_help_playlist', self)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75c9ecc>}
nname: 41
n 41(None)[]:
	i: 9(), 40()
	o: 

nname: 40
n 40(None)[]:
	i: 0(f)
	o: 41()

nname: 9
n 9(None)[self.tasks['hide_help_playlist'].start(config.HMI_BASE['helpbanner_duration'])
]:
	i: 0(t)
	o: 41()

nname: 0
n 0(self.show_help_banner)[]:
	i: 
	o: 9(t), 40(f)

nname: 0
n 0(None)[if self.show_help_banner:
	self.tasks['hide_help_playlist'].start(config.HMI_BASE['helpbanner_duration'])
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75c9a2c>}
nname: 72
n 72(None)[]:
	i: 15(AL), 67(), 71()
	o: 

nname: 71
n 71(None)[]:
	i: 0(f)
	o: 72()

nname: 67
n 67(None)[]:
	i: 28(AF), 63()
	o: 72()

nname: 63
n 63(None)[]:
	i: 35(f), 50()
	o: 67()

nname: 50
n 50(None)[it.display_type = 'audioplayer_audio_playing'
continue
]:
	i: 35(t)
	o: 63()

nname: 35
n 35(it == on_air_item)[for it in items:
]:
	i: 28(for)
	o: 50(t), 63(f)

nname: 28
n 28(None)[]:
	i: 15(loop)
	o: 35(for), 67(AF)

nname: 15
n 15(None)[on_air_item = self._current_played
]:
	i: 0(t)
	o: 28(loop), 72(AL)

nname: 0
n 0(self.active_list == 'edit_list')[]:
	i: 
	o: 15(t), 71(f)

nname: 72
n 72(None)[]:
	i: 15(AL), 28(AF), 35(), 0(f)
	o: 

nname: 35
n 35(None)[for it in items:
if it == on_air_item:
	it.display_type = 'audioplayer_audio_playing'
	continue
]:
	i: 28(for)
	o: 72()

nname: 28
n 28(None)[]:
	i: 15(loop)
	o: 35(for), 72(AF)

nname: 15
n 15(None)[on_air_item = self._current_played
]:
	i: 0(t)
	o: 28(loop), 72(AL)

nname: 0
n 0(self.active_list == 'edit_list')[]:
	i: 
	o: 15(t), 72(f)

nname: 72
n 72(None)[]:
	i: 35(), 0(f)
	o: 

nname: 35
n 35(None)[for it in items:
	if it == on_air_item:
		it.display_type = 'audioplayer_audio_playing'
		continue
]:
	i: 15(for)
	o: 72()

nname: 15
n 15(None)[on_air_item = self._current_played
]:
	i: 0(t)
	o: 35(for)

nname: 0
n 0(self.active_list == 'edit_list')[]:
	i: 
	o: 15(t), 72(f)

nname: 72
n 72(None)[]:
	i: 15(), 0(f)
	o: 

nname: 15
n 15(None)[on_air_item = self._current_played
for it in items:
	if it == on_air_item:
		it.display_type = 'audioplayer_audio_playing'
		continue
]:
	i: 0(t)
	o: 72()

nname: 0
n 0(self.active_list == 'edit_list')[]:
	i: 
	o: 15(t), 72(f)

nname: 0
n 0(None)[if self.active_list == 'edit_list':
	on_air_item = self._current_played
	for it in items:
		if it == on_air_item:
			it.display_type = 'audioplayer_audio_playing'
			continue
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75c9dac>}
nname: 6
n 6(None)[media = 'audio'
_audio_stream = True
_video_stream = False
_sub_stream = False
caching_sig = ('scroll_up', 'scroll_down', 'everything')
def __init__(self):
	Player.__init__(self, 'audioplayer')
	WPlayer.__init__(self)
	def self._getitems_keywords['edit_list']():
		return self.get_item_list('edit_list')

	def self._getitems_keywords['title']():
		if not self.selected['metadata_title']:
			pass
		return self.selected['metadata_title']

	def self._getitems_keywords['artist']():
		return self.selected['author']

	def self._getitems_keywords['album']():
		return self.selected['album']

	def self._getitems_keywords['track']():
		if not self.selected['track']:
			pass
		return self.selected['track']

	self.tasks.update({'show_help_playlist': Task(self._show_help_playlist), 'hide_help_playlist': Task(self._hide_help_playlist)})
	self.set_items([], 'edit_list')
	self.eventhandler = AudioEventHandler(self)
	self.available_choices.append('edit_list')
	self._old_played_dt = None
	self._old_played = None
	self._current_played = None
	for sig in AudioPlayer.caching_sig:
		louie_connect(receiver=self._callback_fill_list, sender='audio', signal=sig)
	self._status_change_callback.task._considered_idle = True
	self._start_playing.task._considered_idle = True
	self.update_media_info.task._considered_idle = True
	return None

def _start_timers(self):
	self.tasks['tick'].start(self._timers_interval, loop=True, consider_idle=True)
	self.tasks['screensaver_block'].start(delay=config.user_config['power']['screensaver_threshold'] - 1, loop=True, consider_idle=True)

def could_remove_banner(self):
	return False

_status_change_callback = tasked(0.10000000000000001)()
def select_random(self):
	if not self._unplayed_positions:
		if self.repeat_mode == 'all':
			self.random_mode = False
			self.go_random()
		else:
			self.stack.close_player()
	pos = choice(self._unplayed_positions)
	ret = self.select(pos, force_pos=True)
	if not ret:
		log.error('unable to select track %s', pos)
		self.stack.close_player()
	else:
		try:
			idx = self._unplayed_positions.index(pos)
			del self._unplayed_positions[idx]
		except:
			log.warn('error removing current position from unplayed_positions: %s', self.selected_pos)
	return ret

def go_random(self):
	if self.random_mode:
		self.random_mode = False
		self._unplayed_positions = []
	else:
		if self.selected:
			npl = None
			if self.universe + ':npl' in self.selected.npl_dict:
				npl = self.selected.npl_dict[self.universe + ':npl']
			else:
				from pygui.markerlist import markerlists
				fl = markerlists().get(self.universe)
				if fl is not None:
					npl = fl.now_playing
			if npl:
				npl.wymedia_resource['childCount'] = str(npl.get_child_count())
				self._unplayed_positions = range(0, int(npl.wymedia_resource['childCount']))
				try:
					idx = self._unplayed_positions.index(self.selected_pos)
					del self._unplayed_positions[idx]
				except:
					log.warn('error removing current position from unplayed_positions: %s', self.selected_pos)
				self.random_mode = True
	return None

tick_callback = selective_gui_updater('progressbar', 'time_remaining', 'time_elapsed', 'time_total', 'status_icon', 'playmode_icon')()
update_media_info = tasked(0.40000000000000002)(selective_gui_updater('progressbar', 'time_remaining', 'time_elapsed', 'time_total')())
def song_changed(self):
	main_list = self.get_item_list('main_list')
	edit_list = self.get_item_list('edit_list')
	if self._old_played:
		if not self._old_played_dt:
			pass
		self._old_played.display_type = self._old_played_dt
	self._old_played_dt = main_list.selected.display_type
	main_list.selected.display_type = 'audioplayer_audio_playing'
	log.debug('loudspeaker icon %s -> %s', self._old_played, main_list.selected)
	louie_send('edit_list', sender=self, action='reset', value=edit_list)
	self._selection_changed(None)
	try:
		sel = main_list.selected
		sel.watch(self._selection_changed)
		sel.async_media_update()
	except AttributeError:
		log.warn('%s.watch failed !', sel)
	return None

def _selection_changed(self, item):
	try:
		louie_send('title', sender=self, value=self['title'])
		louie_send('artist', sender=self, value=self['artist'])
		louie_send('album', sender=self, value=self['album'])
		louie_send('track', sender=self, value=self['track'])
	except:
		log.error('Tags error')
	screensaver = pygui_globs['screensaver']
	if screensaver is not None:
		screensaver.refresh_metadata(self['title'], self['artist'], self['album'])
	return None

def select(self, val, list_name='main_list', force_pos=False):
	if not self.get_item_list('main_list').selected:
		pass
	self._old_played = self.get_item_list('main_list').selected
	if self._old_played is not None:
		try:
			self._old_played.unwatch(self._selection_changed)
		except AttributeError:
			log.info('Item %s is not unwatchable', self._old_played)
	sel_ret = Player.select(self, val, list_name=list_name, force_pos=force_pos)
	if list_name != 'main_list':
		return sel_ret
	if sel_ret is True:
		if not(val > 0 and 'event_down'):
			pass
		louie_send('event_up', self)
		self.song_changed()
		self._start_playing()
	return sel_ret

def play(self, item=None, playlist=None):
	self.time_elapsed = 0.0
	self.random_mode = False
	self._unplayed_positions = []
	try:
		log.debug('PLAY(%s)', item)
		Player.play(self, item, playlist)
	except:
		PRINT_EXCEPTION()
		if self._check_exception(_("Can't find media")):
			pygui_globs['menustack'].close_player()
	self.song_changed()
	self._start_playing()

action_play = user_action()
_start_playing = tasked(config.HMI_MUSIC['lazy_selection'])()
def stop(self):
	log.debug('stop() on MMI PLAYER')
	if self.active_list == 'edit_list':
		self.get_item_list('edit_list').edited = False
		self.focus_previous()
	try:
		self.get_item_list('main_list').selected.unwatch(self._selection_changed)
	except AttributeError:
		log.info('Item %s is not unwatchable', self.get_item_list('main_list').selected)
	self._start_playing.task.stop()
	WPlayer.stop(self)
	Player.stop(self)
	for sig in AudioPlayer.caching_sig:
		louie_disconnect(receiver=self._callback_fill_list, signal=sig, sender='audio')

def refresh_edit_list(self, edit_list):
	edit_list.set_items(self.get_item_list('main_list'))
	edit_list.select(self.selected)
	self.focus_next()

def _show_help_playlist(self):
	if config.user_config['base']['help_banner']:
		louie_send('show_help_playlist', sender=self)
		self.hide_help_playlist()

def show_help_playlist(self):
	if self.show_help_banner:
		self.tasks['show_help_playlist'].start(0.5)

def _hide_help_playlist(self):
	if config.user_config['base']['help_banner'] != 1:
		louie_send('hide_help_playlist', self)

def hide_help_playlist(self):
	if self.show_help_banner:
		self.tasks['hide_help_playlist'].start(config.HMI_BASE['helpbanner_duration'])

def _callback_fill_list(self, signal, sender, items):
	if self.active_list == 'edit_list':
		on_air_item = self._current_played
		for it in items:
			if it == on_air_item:
				it.display_type = 'audioplayer_audio_playing'
				continue

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75b678c>}
nname: 0
n 0(None)[from __future__ import absolute_import
__all__ = ['AudioPlayer']
import pygui.config as config
from .core import user_action, Player, WPlayer
from peewee.debug import GET_LOGGER, PRINT_EXCEPTION
from peewee.messages import send as louie_send
from peewee.messages import connect as louie_connect
from peewee.messages import disconnect as louie_disconnect
from peewee.notifier import tasked
from peewee.notifier import Task
from pygui.eventmanager.players import AudioEventHandler
from pygui.shared import pygui_globs
from pygui.menu import selective_gui_updater
from random import choice
log = GET_LOGGER(__name__)
class AudioPlayer(Player, WPlayer):
	media = 'audio'
	_audio_stream = True
	_video_stream = False
	_sub_stream = False
	caching_sig = ('scroll_up', 'scroll_down', 'everything')
	def __init__(self):
		Player.__init__(self, 'audioplayer')
		WPlayer.__init__(self)
		def self._getitems_keywords['edit_list']():
			return self.get_item_list('edit_list')

		def self._getitems_keywords['title']():
			if not self.selected['metadata_title']:
				pass
			return self.selected['metadata_title']

		def self._getitems_keywords['artist']():
			return self.selected['author']

		def self._getitems_keywords['album']():
			return self.selected['album']

		def self._getitems_keywords['track']():
			if not self.selected['track']:
				pass
			return self.selected['track']

		self.tasks.update({'show_help_playlist': Task(self._show_help_playlist), 'hide_help_playlist': Task(self._hide_help_playlist)})
		self.set_items([], 'edit_list')
		self.eventhandler = AudioEventHandler(self)
		self.available_choices.append('edit_list')
		self._old_played_dt = None
		self._old_played = None
		self._current_played = None
		for sig in AudioPlayer.caching_sig:
			louie_connect(receiver=self._callback_fill_list, sender='audio', signal=sig)
		self._status_change_callback.task._considered_idle = True
		self._start_playing.task._considered_idle = True
		self.update_media_info.task._considered_idle = True
		return None

	def _start_timers(self):
		self.tasks['tick'].start(self._timers_interval, loop=True, consider_idle=True)
		self.tasks['screensaver_block'].start(delay=config.user_config['power']['screensaver_threshold'] - 1, loop=True, consider_idle=True)

	def could_remove_banner(self):
		return False

	_status_change_callback = tasked(0.10000000000000001)()
	def select_random(self):
		if not self._unplayed_positions:
			if self.repeat_mode == 'all':
				self.random_mode = False
				self.go_random()
			else:
				self.stack.close_player()
		pos = choice(self._unplayed_positions)
		ret = self.select(pos, force_pos=True)
		if not ret:
			log.error('unable to select track %s', pos)
			self.stack.close_player()
		else:
			try:
				idx = self._unplayed_positions.index(pos)
				del self._unplayed_positions[idx]
			except:
				log.warn('error removing current position from unplayed_positions: %s', self.selected_pos)
		return ret

	def go_random(self):
		if self.random_mode:
			self.random_mode = False
			self._unplayed_positions = []
		else:
			if self.selected:
				npl = None
				if self.universe + ':npl' in self.selected.npl_dict:
					npl = self.selected.npl_dict[self.universe + ':npl']
				else:
					from pygui.markerlist import markerlists
					fl = markerlists().get(self.universe)
					if fl is not None:
						npl = fl.now_playing
				if npl:
					npl.wymedia_resource['childCount'] = str(npl.get_child_count())
					self._unplayed_positions = range(0, int(npl.wymedia_resource['childCount']))
					try:
						idx = self._unplayed_positions.index(self.selected_pos)
						del self._unplayed_positions[idx]
					except:
						log.warn('error removing current position from unplayed_positions: %s', self.selected_pos)
					self.random_mode = True
		return None

	tick_callback = selective_gui_updater('progressbar', 'time_remaining', 'time_elapsed', 'time_total', 'status_icon', 'playmode_icon')()
	update_media_info = tasked(0.40000000000000002)(selective_gui_updater('progressbar', 'time_remaining', 'time_elapsed', 'time_total')())
	def song_changed(self):
		main_list = self.get_item_list('main_list')
		edit_list = self.get_item_list('edit_list')
		if self._old_played:
			if not self._old_played_dt:
				pass
			self._old_played.display_type = self._old_played_dt
		self._old_played_dt = main_list.selected.display_type
		main_list.selected.display_type = 'audioplayer_audio_playing'
		log.debug('loudspeaker icon %s -> %s', self._old_played, main_list.selected)
		louie_send('edit_list', sender=self, action='reset', value=edit_list)
		self._selection_changed(None)
		try:
			sel = main_list.selected
			sel.watch(self._selection_changed)
			sel.async_media_update()
		except AttributeError:
			log.warn('%s.watch failed !', sel)
		return None

	def _selection_changed(self, item):
		try:
			louie_send('title', sender=self, value=self['title'])
			louie_send('artist', sender=self, value=self['artist'])
			louie_send('album', sender=self, value=self['album'])
			louie_send('track', sender=self, value=self['track'])
		except:
			log.error('Tags error')
		screensaver = pygui_globs['screensaver']
		if screensaver is not None:
			screensaver.refresh_metadata(self['title'], self['artist'], self['album'])
		return None

	def select(self, val, list_name='main_list', force_pos=False):
		if not self.get_item_list('main_list').selected:
			pass
		self._old_played = self.get_item_list('main_list').selected
		if self._old_played is not None:
			try:
				self._old_played.unwatch(self._selection_changed)
			except AttributeError:
				log.info('Item %s is not unwatchable', self._old_played)
		sel_ret = Player.select(self, val, list_name=list_name, force_pos=force_pos)
		if list_name != 'main_list':
			return sel_ret
		if sel_ret is True:
			if not(val > 0 and 'event_down'):
				pass
			louie_send('event_up', self)
			self.song_changed()
			self._start_playing()
		return sel_ret

	def play(self, item=None, playlist=None):
		self.time_elapsed = 0.0
		self.random_mode = False
		self._unplayed_positions = []
		try:
			log.debug('PLAY(%s)', item)
			Player.play(self, item, playlist)
		except:
			PRINT_EXCEPTION()
			if self._check_exception(_("Can't find media")):
				pygui_globs['menustack'].close_player()
		self.song_changed()
		self._start_playing()

	action_play = user_action()
	_start_playing = tasked(config.HMI_MUSIC['lazy_selection'])()
	def stop(self):
		log.debug('stop() on MMI PLAYER')
		if self.active_list == 'edit_list':
			self.get_item_list('edit_list').edited = False
			self.focus_previous()
		try:
			self.get_item_list('main_list').selected.unwatch(self._selection_changed)
		except AttributeError:
			log.info('Item %s is not unwatchable', self.get_item_list('main_list').selected)
		self._start_playing.task.stop()
		WPlayer.stop(self)
		Player.stop(self)
		for sig in AudioPlayer.caching_sig:
			louie_disconnect(receiver=self._callback_fill_list, signal=sig, sender='audio')

	def refresh_edit_list(self, edit_list):
		edit_list.set_items(self.get_item_list('main_list'))
		edit_list.select(self.selected)
		self.focus_next()

	def _show_help_playlist(self):
		if config.user_config['base']['help_banner']:
			louie_send('show_help_playlist', sender=self)
			self.hide_help_playlist()

	def show_help_playlist(self):
		if self.show_help_banner:
			self.tasks['show_help_playlist'].start(0.5)

	def _hide_help_playlist(self):
		if config.user_config['base']['help_banner'] != 1:
			louie_send('hide_help_playlist', self)

	def hide_help_playlist(self):
		if self.show_help_banner:
			self.tasks['hide_help_playlist'].start(config.HMI_BASE['helpbanner_duration'])

	def _callback_fill_list(self, signal, sender, items):
		if self.active_list == 'edit_list':
			on_air_item = self._current_played
			for it in items:
				if it == on_air_item:
					it.display_type = 'audioplayer_audio_playing'
					continue



]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75b076c>}
from __future__ import absolute_import
__all__ = ['AudioPlayer']
import pygui.config as config
from .core import user_action, Player, WPlayer
from peewee.debug import GET_LOGGER, PRINT_EXCEPTION
from peewee.messages import send as louie_send
from peewee.messages import connect as louie_connect
from peewee.messages import disconnect as louie_disconnect
from peewee.notifier import tasked
from peewee.notifier import Task
from pygui.eventmanager.players import AudioEventHandler
from pygui.shared import pygui_globs
from pygui.menu import selective_gui_updater
from random import choice
log = GET_LOGGER(__name__)
class AudioPlayer(Player, WPlayer):
	media = 'audio'
	_audio_stream = True
	_video_stream = False
	_sub_stream = False
	caching_sig = ('scroll_up', 'scroll_down', 'everything')
	def __init__(self):
		Player.__init__(self, 'audioplayer')
		WPlayer.__init__(self)
		def self._getitems_keywords['edit_list']():
			return self.get_item_list('edit_list')

		def self._getitems_keywords['title']():
			if not self.selected['metadata_title']:
				pass
			return self.selected['metadata_title']

		def self._getitems_keywords['artist']():
			return self.selected['author']

		def self._getitems_keywords['album']():
			return self.selected['album']

		def self._getitems_keywords['track']():
			if not self.selected['track']:
				pass
			return self.selected['track']

		self.tasks.update({'show_help_playlist': Task(self._show_help_playlist), 'hide_help_playlist': Task(self._hide_help_playlist)})
		self.set_items([], 'edit_list')
		self.eventhandler = AudioEventHandler(self)
		self.available_choices.append('edit_list')
		self._old_played_dt = None
		self._old_played = None
		self._current_played = None
		for sig in AudioPlayer.caching_sig:
			louie_connect(receiver=self._callback_fill_list, sender='audio', signal=sig)
		self._status_change_callback.task._considered_idle = True
		self._start_playing.task._considered_idle = True
		self.update_media_info.task._considered_idle = True
		return None

	def _start_timers(self):
		self.tasks['tick'].start(self._timers_interval, loop=True, consider_idle=True)
		self.tasks['screensaver_block'].start(delay=config.user_config['power']['screensaver_threshold'] - 1, loop=True, consider_idle=True)

	def could_remove_banner(self):
		return False

	_status_change_callback = tasked(0.10000000000000001)()
	def select_random(self):
		if not self._unplayed_positions:
			if self.repeat_mode == 'all':
				self.random_mode = False
				self.go_random()
			else:
				self.stack.close_player()
		pos = choice(self._unplayed_positions)
		ret = self.select(pos, force_pos=True)
		if not ret:
			log.error('unable to select track %s', pos)
			self.stack.close_player()
		else:
			try:
				idx = self._unplayed_positions.index(pos)
				del self._unplayed_positions[idx]
			except:
				log.warn('error removing current position from unplayed_positions: %s', self.selected_pos)
		return ret

	def go_random(self):
		if self.random_mode:
			self.random_mode = False
			self._unplayed_positions = []
		else:
			if self.selected:
				npl = None
				if self.universe + ':npl' in self.selected.npl_dict:
					npl = self.selected.npl_dict[self.universe + ':npl']
				else:
					from pygui.markerlist import markerlists
					fl = markerlists().get(self.universe)
					if fl is not None:
						npl = fl.now_playing
				if npl:
					npl.wymedia_resource['childCount'] = str(npl.get_child_count())
					self._unplayed_positions = range(0, int(npl.wymedia_resource['childCount']))
					try:
						idx = self._unplayed_positions.index(self.selected_pos)
						del self._unplayed_positions[idx]
					except:
						log.warn('error removing current position from unplayed_positions: %s', self.selected_pos)
					self.random_mode = True
		return None

	tick_callback = selective_gui_updater('progressbar', 'time_remaining', 'time_elapsed', 'time_total', 'status_icon', 'playmode_icon')()
	update_media_info = tasked(0.40000000000000002)(selective_gui_updater('progressbar', 'time_remaining', 'time_elapsed', 'time_total')())
	def song_changed(self):
		main_list = self.get_item_list('main_list')
		edit_list = self.get_item_list('edit_list')
		if self._old_played:
			if not self._old_played_dt:
				pass
			self._old_played.display_type = self._old_played_dt
		self._old_played_dt = main_list.selected.display_type
		main_list.selected.display_type = 'audioplayer_audio_playing'
		log.debug('loudspeaker icon %s -> %s', self._old_played, main_list.selected)
		louie_send('edit_list', sender=self, action='reset', value=edit_list)
		self._selection_changed(None)
		try:
			sel = main_list.selected
			sel.watch(self._selection_changed)
			sel.async_media_update()
		except AttributeError:
			log.warn('%s.watch failed !', sel)
		return None

	def _selection_changed(self, item):
		try:
			louie_send('title', sender=self, value=self['title'])
			louie_send('artist', sender=self, value=self['artist'])
			louie_send('album', sender=self, value=self['album'])
			louie_send('track', sender=self, value=self['track'])
		except:
			log.error('Tags error')
		screensaver = pygui_globs['screensaver']
		if screensaver is not None:
			screensaver.refresh_metadata(self['title'], self['artist'], self['album'])
		return None

	def select(self, val, list_name='main_list', force_pos=False):
		if not self.get_item_list('main_list').selected:
			pass
		self._old_played = self.get_item_list('main_list').selected
		if self._old_played is not None:
			try:
				self._old_played.unwatch(self._selection_changed)
			except AttributeError:
				log.info('Item %s is not unwatchable', self._old_played)
		sel_ret = Player.select(self, val, list_name=list_name, force_pos=force_pos)
		if list_name != 'main_list':
			return sel_ret
		if sel_ret is True:
			if not(val > 0 and 'event_down'):
				pass
			louie_send('event_up', self)
			self.song_changed()
			self._start_playing()
		return sel_ret

	def play(self, item=None, playlist=None):
		self.time_elapsed = 0.0
		self.random_mode = False
		self._unplayed_positions = []
		try:
			log.debug('PLAY(%s)', item)
			Player.play(self, item, playlist)
		except:
			PRINT_EXCEPTION()
			if self._check_exception(_("Can't find media")):
				pygui_globs['menustack'].close_player()
		self.song_changed()
		self._start_playing()

	action_play = user_action()
	_start_playing = tasked(config.HMI_MUSIC['lazy_selection'])()
	def stop(self):
		log.debug('stop() on MMI PLAYER')
		if self.active_list == 'edit_list':
			self.get_item_list('edit_list').edited = False
			self.focus_previous()
		try:
			self.get_item_list('main_list').selected.unwatch(self._selection_changed)
		except AttributeError:
			log.info('Item %s is not unwatchable', self.get_item_list('main_list').selected)
		self._start_playing.task.stop()
		WPlayer.stop(self)
		Player.stop(self)
		for sig in AudioPlayer.caching_sig:
			louie_disconnect(receiver=self._callback_fill_list, signal=sig, sender='audio')

	def refresh_edit_list(self, edit_list):
		edit_list.set_items(self.get_item_list('main_list'))
		edit_list.select(self.selected)
		self.focus_next()

	def _show_help_playlist(self):
		if config.user_config['base']['help_banner']:
			louie_send('show_help_playlist', sender=self)
			self.hide_help_playlist()

	def show_help_playlist(self):
		if self.show_help_banner:
			self.tasks['show_help_playlist'].start(0.5)

	def _hide_help_playlist(self):
		if config.user_config['base']['help_banner'] != 1:
			louie_send('hide_help_playlist', self)

	def hide_help_playlist(self):
		if self.show_help_banner:
			self.tasks['hide_help_playlist'].start(config.HMI_BASE['helpbanner_duration'])

	def _callback_fill_list(self, signal, sender, items):
		if self.active_list == 'edit_list':
			on_air_item = self._current_played
			for it in items:
				if it == on_air_item:
					it.display_type = 'audioplayer_audio_playing'
					continue



