# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 55
n 55(None)[self.player = config.no_PLAYERS
]:
	i: 30(t), 39()
	o: 

nname: 39
n 39(None)[]:
	i: 30(f)
	o: 55()

nname: 30
n 30(config.no_PLAYERS)[]:
	i: 9(), 29()
	o: 39(f), 55(t)

nname: 29
n 29(None)[]:
	i: 0(t)
	o: 30()

nname: 9
n 9(None)[from wyplayer import WyPlayer
]:
	i: 0(f)
	o: 30()

nname: 0
n 0(config.no_PLAYERS)[]:
	i: 
	o: 9(f), 29(t)

nname: 55
n 55(None)[self.player = config.no_PLAYERS
]:
	i: 0(t)
	o: 

nname: 0
n 0(None)[if not config.no_PLAYERS:
	from wyplayer import WyPlayer
if not config.no_PLAYERS:
	pass
]:
	i: 
	o: 55()

nname: 0
n 0(None)[if not config.no_PLAYERS:
	from wyplayer import WyPlayer
if not config.no_PLAYERS:
	pass
self.player = config.no_PLAYERS
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7639f6c>}
nname: 6
n 6(None)[__metaclass__ = MetaSingleton
def __init__(self):
	if not config.no_PLAYERS:
		from wyplayer import WyPlayer
	if not config.no_PLAYERS:
		pass
	self.player = config.no_PLAYERS

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb76396cc>}
nname: 0
n 0(None)[return _WyPlayerWrap().player
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb763942c>}
nname: 0
n 0(None)[return '%d:%02d:%02d' % tuple(gmtime(time_val)[3:6])
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76397ec>}
nname: 0
n 0(None)[return '%d:%02d' % tuple(gmtime(time_val)[3:5])
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb763964c>}
nname: 46
n 46(None)[return '%d:%02d:%02d' % tuple(gmtime(time_val)[3:6])
]:
	i: 12(), 19()
	o: 

nname: 19
n 19(None)[]:
	i: 0(f)
	o: 46()

nname: 12
n 12(None)[]:
	i: 0(t)
	o: 46()

nname: 0
n 0(time_val <= 0)[]:
	i: 
	o: 12(t), 19(f)

nname: 0
n 0(None)[if time_val <= 0:
	pass
return '%d:%02d:%02d' % tuple(gmtime(time_val)[3:6])
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb763970c>}
nname: 0
n 0(None)[self.signals = signals
self._timer = Task(self.handler)
self._delay = delay
self._sender = None
self._check = _check
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb763432c>}
nname: 35
n 35(None)[self._timer.stop()
louie_send(self.signals[1], sender=self._sender)
self._sender.tasks['tick'].stop()
]:
	i: 26(), 34()
	o: 

nname: 34
n 34(None)[]:
	i: 0&9(f)
	o: 35()

nname: 26
n 26(None)[]:
	i: 0&9(t)
	o: 35()

nname: 0&9
n 0&9(self._check and not self._sender.could_remove_banner())[]:
	i: 
	o: 26(t), 34(f)

nname: 0&9
n 0&9(None)[if self._check and not self._sender.could_remove_banner():
	pass
self._timer.stop()
louie_send(self.signals[1], sender=self._sender)
self._sender.tasks['tick'].stop()
]:
	i: 
	o: 

self.nodes: {'0&9': <unpyclib.structure.node instance at 0xb763416c>}
nname: 189
n 189(None)[return ret
]:
	i: 89(), 118()
	o: 

nname: 118
n 118(None)[self._timer.start(self._delay, loop=True, consider_idle=True)
self._sender._start_timers()
louie_send(self.signals[0], sender=self._sender)
]:
	i: 68(f)
	o: 189()

nname: 89
n 89(None)[self._timer.start(loop=True, consider_idle=True)
]:
	i: 68(t)
	o: 189()

nname: 68
n 68(self._timer.running)[self._sender = menu
]:
	i: 9(), 41(), 66(AE)
	o: 89(t), 118(f)

nname: 66
n 66(None)[]:
	i: 31(f)
	o: 68(AE)

nname: 41
n 41(None)[#, e
log.warn('%s', e)
]:
	i: 31(t)
	o: 68()

nname: 31
n 31(<dummy_ex3> EXC_MATCH Exception)[]:
	i: 0(except)
	o: 41(t), 66(f)

nname: 9
n 9(None)[ret = func(menu, *args, **kw)
]:
	i: 0(try)
	o: 68()

nname: 0
n 0(None)[ret = None
]:
	i: 
	o: 9(try), 31(except)

nname: 189
n 189(None)[return ret
]:
	i: 31()
	o: 

nname: 31
n 31(None)[except Exception, e:
	log.warn('%s', e)
self._sender = menu
if self._timer.running:
	self._timer.start(loop=True, consider_idle=True)
else:
	self._timer.start(self._delay, loop=True, consider_idle=True)
	self._sender._start_timers()
	louie_send(self.signals[0], sender=self._sender)
]:
	i: 0()
	o: 189()

nname: 0
n 0(None)[ret = None
try:
	ret = func(menu, *args, **kw)
]:
	i: 
	o: 31()

nname: 189
n 189(None)[return ret
]:
	i: 0()
	o: 

nname: 0
n 0(None)[ret = None
try:
	ret = func(menu, *args, **kw)
except Exception, e:
	log.warn('%s', e)
self._sender = menu
if self._timer.running:
	self._timer.start(loop=True, consider_idle=True)
else:
	self._timer.start(self._delay, loop=True, consider_idle=True)
	self._sender._start_timers()
	louie_send(self.signals[0], sender=self._sender)
]:
	i: 
	o: 189()

nname: 0
n 0(None)[ret = None
try:
	ret = func(menu, *args, **kw)
except Exception, e:
	log.warn('%s', e)
self._sender = menu
if self._timer.running:
	self._timer.start(loop=True, consider_idle=True)
else:
	self._timer.start(self._delay, loop=True, consider_idle=True)
	self._sender._start_timers()
	louie_send(self.signals[0], sender=self._sender)
return ret
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb763e46c>}
nname: 0
n 0(None)[def _exec(menu, *args, **args):
	ret = None
	try:
		ret = func(menu, *args, **kw)
	except Exception, e:
		log.warn('%s', e)
	self._sender = menu
	if self._timer.running:
		self._timer.start(loop=True, consider_idle=True)
	else:
		self._timer.start(self._delay, loop=True, consider_idle=True)
		self._sender._start_timers()
		louie_send(self.signals[0], sender=self._sender)
	return ret

return _exec
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7639a8c>}
nname: 87
n 87(None)[]:
	i: 32(JA), 82(), 86()
	o: 

nname: 86
n 86(None)[]:
	i: 0(f)
	o: 87()

nname: 82
n 82(None)[]:
	i: 12(t)
	o: 87()

nname: 32
n 32(None)[louie_send(self.signals[1], sender=self._sender)
self._sender.tasks['tick'].stop()
]:
	i: 12(f)
	o: 87(JA)

nname: 12
n 12(mute)[self._timer.stop()
]:
	i: 0(t)
	o: 32(f), 82(t)

nname: 0
n 0(self._timer.running)[]:
	i: 
	o: 12(t), 86(f)

nname: 0
n 0(None)[if self._timer.running:
	self._timer.stop()
	if not mute:
		louie_send(self.signals[1], sender=self._sender)
		self._sender.tasks['tick'].stop()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb763edac>}
nname: 6
n 6(None)[__doc__ = "OO and slightly more flexible replacement for user_action and friends.\n    Doesn't replace them all yet, but soon will. Trust me.\n\n    XXX user_action = TimerActivator(signals=('on_user_event', 'on_user_idle'), _check=True)\n    "
def __init__(self, signals=('on_start', 'on_stop'), delay=2, _check=False):
	self.signals = signals
	self._timer = Task(self.handler)
	self._delay = delay
	self._sender = None
	self._check = _check
	return None

def handler(self):
	if self._check and not self._sender.could_remove_banner():
		pass
	self._timer.stop()
	louie_send(self.signals[1], sender=self._sender)
	self._sender.tasks['tick'].stop()

def __call__(self, func):
	def _exec(menu, *args, **args):
		ret = None
		try:
			ret = func(menu, *args, **kw)
		except Exception, e:
			log.warn('%s', e)
		self._sender = menu
		if self._timer.running:
			self._timer.start(loop=True, consider_idle=True)
		else:
			self._timer.start(self._delay, loop=True, consider_idle=True)
			self._sender._start_timers()
			louie_send(self.signals[0], sender=self._sender)
		return ret

	return _exec

def force_ending(self, mute=False):
	if self._timer.running:
		self._timer.stop()
		if not mute:
			louie_send(self.signals[1], sender=self._sender)
			self._sender.tasks['tick'].stop()

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb7639f0c>}
nname: 0
n 0(None)[return ''
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76447cc>}
nname: 0
n 0(None)[return _guarded_seconds_to_hhmmss(round(self.total_time))
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76447ac>}
nname: 0
n 0(None)[return _guarded_seconds_to_hhmmss(round(self.total_time) - round(self.time_elapsed))
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76447ec>}
nname: 0
n 0(None)[return _seconds_to_hhmmss(round(self.time_elapsed))
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb764474c>}
nname: 0
n 0(None)[return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76444ac>}
nname: 0
n 0(None)[return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76444ec>}
nname: 0
n 0(None)[self.stack = pygui_globs['menustack']
self.total_time = 0.0
self.time_elapsed = 0.0
Menu.__init__(self, [], type=type_, universe=universe)
self._getitems_keywords.update(dict(time_elapsed=(lambda : _seconds_to_hhmmss(round(self.time_elapsed))), time_remaining=(lambda : _guarded_seconds_to_hhmmss(round(self.total_time) - round(self.time_elapsed))), time_total=(lambda : _guarded_seconds_to_hhmmss(round(self.total_time))), progressbar=self._get_progressbar, status_icon=self._get_status_icon, playmode_icon=self._get_playmode_icon, subtitles=(lambda : '')))
self.tasks['tick'] = Task(self.tick_callback)
self.tasks['screensaver_block'] = Task((lambda : None))
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7634fac>}
nname: 0
n 0(None)[return self.speed in (0, 1)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb763e58c>}
nname: 101
n 101(None)[]:
	i: 22(), 63()
	o: 

nname: 63
n 63(None)[return dict(pos=round(self.total_time), max=round(self.total_time))
]:
	i: 0(f)
	o: 101()

nname: 22
n 22(None)[return dict(pos=round(self.time_elapsed), max=round(self.total_time))
]:
	i: 0(t)
	o: 101()

nname: 0
n 0(self.total_time - self.time_elapsed >= 1.0)[]:
	i: 
	o: 22(t), 63(f)

nname: 0
n 0(None)[if self.total_time - self.time_elapsed >= 1.0:
	return dict(pos=round(self.time_elapsed), max=round(self.total_time))
else:
	return dict(pos=round(self.total_time), max=round(self.total_time))
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb763412c>}
nname: 0
n 0(None)[]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb763e58c>}
nname: 0
n 0(None)[self.tasks['tick'].start(self._timers_interval, loop=True, init_delay=0)
self.tasks['screensaver_block'].start(delay=config.user_config['power']['screensaver_threshold'] - 1, loop=True)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7634fcc>}
nname: 63
n 63(None)[return None
]:
	i: 50(), 62()
	o: 

nname: 62
n 62(None)[]:
	i: 44(f)
	o: 63()

nname: 50
n 50(None)[return status + '.png'
]:
	i: 44(t)
	o: 63()

nname: 44
n 44(status)[]:
	i: 3(), 29(), 42(AE)
	o: 50(t), 62(f)

nname: 42
n 42(None)[]:
	i: 19(f)
	o: 44(AE)

nname: 29
n 29(None)[status = None
]:
	i: 19(t)
	o: 44()

nname: 19
n 19(<dummy_ex3> EXC_MATCH AttributeError)[]:
	i: 0(except)
	o: 29(t), 42(f)

nname: 3
n 3(None)[status = self._get_status()
]:
	i: 0(try)
	o: 44()

nname: 0
n 0(None)[]:
	i: 
	o: 3(try), 19(except)

nname: 63
n 63(None)[return None
]:
	i: 19()
	o: 

nname: 19
n 19(None)[except AttributeError:
	status = None
if status:
	return status + '.png'
]:
	i: 0()
	o: 63()

nname: 0
n 0(None)[try:
	status = self._get_status()
]:
	i: 
	o: 19()

nname: 63
n 63(None)[return None
]:
	i: 0()
	o: 

nname: 0
n 0(None)[try:
	status = self._get_status()
except AttributeError:
	status = None
if status:
	return status + '.png'
]:
	i: 
	o: 63()

nname: 0
n 0(None)[try:
	status = self._get_status()
except AttributeError:
	status = None
if status:
	return status + '.png'
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7634a0c>}
nname: 31
n 31(None)[]:
	i: 18(), 30()
	o: 

nname: 30
n 30(None)[]:
	i: 0(f)
	o: 31()

nname: 18
n 18(None)[return status + '.png'
]:
	i: 0(t)
	o: 31()

nname: 0
n 0(status)[status = self._get_playmode()
]:
	i: 
	o: 18(t), 30(f)

nname: 0
n 0(None)[status = self._get_playmode()
if status:
	return status + '.png'
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb763ee6c>}
nname: 100
n 100(None)[return new_playlist
]:
	i: 50(), 64(), 98(AE)
	o: 

nname: 98
n 98(None)[]:
	i: 54(f)
	o: 100(AE)

nname: 64
n 64(None)[#, e
log.warn(' **Warning** Cannot get playlist: %s', e)
new_playlist = [item]
]:
	i: 54(t)
	o: 100()

nname: 54
n 54(<dummy_ex3> EXC_MATCH Exception)[]:
	i: 0(except)
	o: 64(t), 98(f)

nname: 50
n 50(None)[]:
	i: 36(), 49()
	o: 100()

nname: 49
n 49(None)[]:
	i: 3(t)
	o: 50()

nname: 36
n 36(None)[new_playlist = new_playlist.playlist
]:
	i: 3(f)
	o: 50()

nname: 3
n 3(isinstance(new_playlist, (list, tuple)))[new_playlist = item.get_playlist()
]:
	i: 0(try)
	o: 36(f), 49(t)

nname: 0
n 0(None)[]:
	i: 
	o: 3(try), 54(except)

nname: 100
n 100(None)[return new_playlist
]:
	i: 54(), 0()
	o: 

nname: 54
n 54(None)[except Exception, e:
	log.warn(' **Warning** Cannot get playlist: %s', e)
	new_playlist = [item]
]:
	i: 0()
	o: 100()

nname: 100
n 100(None)[return new_playlist
]:
	i: 54(), 0()
	o: 

nname: 0
n 0(None)[try:
	new_playlist = item.get_playlist()
	if not isinstance(new_playlist, (list, tuple)):
		new_playlist = new_playlist.playlist
]:
	i: 
	o: 100(), 54()

self.nodes: {0: <unpyclib.structure.node instance at 0xb76341ec>, 54: <unpyclib.structure.node instance at 0xb763422c>, 100: <unpyclib.structure.node instance at 0xb763414c>}
nname: 152
n 152(None)[louie_send('main_list', sender=self, action='reset', value=self['main_list'], position=self['main_list'].selected_pos)
return ret
]:
	i: 131(), 151()
	o: 

nname: 151
n 151(None)[]:
	i: 113(f)
	o: 152()

nname: 131
n 131(None)[self.stack.back_to_menu(self)
]:
	i: 113(t)
	o: 152()

nname: 113
n 113(self.stack.is_on_top(self))[]:
	i: 90(), 112()
	o: 131(t), 151(f)

nname: 112
n 112(None)[]:
	i: 84(f)
	o: 113()

nname: 90
n 90(None)[self.time_elapsed = 0.0
self.total_time = 0.0
]:
	i: 84(t)
	o: 113()

nname: 84
n 84(ret)[]:
	i: 75(), 83()
	o: 90(t), 112(f)

nname: 83
n 83(None)[]:
	i: 33(f)
	o: 84()

nname: 75
n 75(None)[]:
	i: 33(t)
	o: 84()

nname: 33
n 33(list_name != 'main_list')[ret = Menu.select(self, item_or_pos, list_name=list_name, force_pos=force_pos)
]:
	i: 24(), 32()
	o: 75(t), 83(f)

nname: 32
n 32(None)[]:
	i: 0(f)
	o: 33()

nname: 24
n 24(None)[return False
]:
	i: 0(t)
	o: 33()

nname: 0
n 0(self.get_item_list(list_name).selected == item_or_pos)[]:
	i: 
	o: 24(t), 32(f)

nname: 152
n 152(None)[louie_send('main_list', sender=self, action='reset', value=self['main_list'], position=self['main_list'].selected_pos)
return ret
]:
	i: 84()
	o: 

nname: 84
n 84(None)[if ret:
	self.time_elapsed = 0.0
	self.total_time = 0.0
if self.stack.is_on_top(self):
	self.stack.back_to_menu(self)
]:
	i: 0()
	o: 152()

nname: 0
n 0(None)[if self.get_item_list(list_name).selected == item_or_pos:
	return False
ret = Menu.select(self, item_or_pos, list_name=list_name, force_pos=force_pos)
if list_name != 'main_list':
	pass
]:
	i: 
	o: 84()

nname: 152
n 152(None)[louie_send('main_list', sender=self, action='reset', value=self['main_list'], position=self['main_list'].selected_pos)
return ret
]:
	i: 0()
	o: 

nname: 0
n 0(None)[if self.get_item_list(list_name).selected == item_or_pos:
	return False
ret = Menu.select(self, item_or_pos, list_name=list_name, force_pos=force_pos)
if list_name != 'main_list':
	pass
if ret:
	self.time_elapsed = 0.0
	self.total_time = 0.0
if self.stack.is_on_top(self):
	self.stack.back_to_menu(self)
]:
	i: 
	o: 152()

nname: 0
n 0(None)[if self.get_item_list(list_name).selected == item_or_pos:
	return False
ret = Menu.select(self, item_or_pos, list_name=list_name, force_pos=force_pos)
if list_name != 'main_list':
	pass
if ret:
	self.time_elapsed = 0.0
	self.total_time = 0.0
if self.stack.is_on_top(self):
	self.stack.back_to_menu(self)
louie_send('main_list', sender=self, action='reset', value=self['main_list'], position=self['main_list'].selected_pos)
return ret
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7634f6c>}
nname: 73
n 73(None)[return None
]:
	i: 15(AL), 68(), 72()
	o: 

nname: 72
n 72(None)[]:
	i: 0(f)
	o: 73()

nname: 68
n 68(None)[]:
	i: 32(AF), 42()
	o: 73()

nname: 42
n 42(None)[for k in self.item_lists_dict:
self.item_lists_dict[k].set_items([])
]:
	i: 32(for)
	o: 68()

nname: 32
n 32(None)[]:
	i: 15(loop)
	o: 42(for), 68(AF)

nname: 15
n 15(None)[log.debug('Clearing player...')
]:
	i: 0(t)
	o: 32(loop), 73(AL)

nname: 0
n 0(self.status is None)[]:
	i: 
	o: 15(t), 72(f)

nname: 73
n 73(None)[return None
]:
	i: 42(), 0(f)
	o: 

nname: 42
n 42(None)[for k in self.item_lists_dict:
	self.item_lists_dict[k].set_items([])
]:
	i: 15(for)
	o: 73()

nname: 15
n 15(None)[log.debug('Clearing player...')
]:
	i: 0(t)
	o: 42(for)

nname: 0
n 0(self.status is None)[]:
	i: 
	o: 15(t), 73(f)

nname: 73
n 73(None)[return None
]:
	i: 15(), 0(f)
	o: 

nname: 15
n 15(None)[log.debug('Clearing player...')
for k in self.item_lists_dict:
	self.item_lists_dict[k].set_items([])
]:
	i: 0(t)
	o: 73()

nname: 0
n 0(self.status is None)[]:
	i: 
	o: 15(t), 73(f)

nname: 0
n 0(None)[if self.status is None:
	log.debug('Clearing player...')
	for k in self.item_lists_dict:
		self.item_lists_dict[k].set_items([])
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76346ac>}
nname: 182
n 182(None)[]:
	i: 117(), 164(), 181()
	o: 

nname: 181
n 181(None)[]:
	i: 157(f)
	o: 182()

nname: 164
n 164(None)[stack.bubble_raise(self)
]:
	i: 157(t)
	o: 182()

nname: 157
n 157(hide_previous_menu)[]:
	i: 105(f)
	o: 164(t), 181(f)

nname: 117
n 117(None)[stack.close_player()
self.show(hide_previous_menu=hide_previous_menu)
self._start_timers()
]:
	i: 105(t)
	o: 182()

nname: 105
n 105(self not in stack)[]:
	i: 81(), 104()
	o: 117(t), 157(f)

nname: 104
n 104(None)[]:
	i: 48(f)
	o: 105()

nname: 81
n 81(None)[self.set_items(playlist, 'main_list', item)
]:
	i: 48(t)
	o: 105()

nname: 48
n 48(playlist != self.choices)[item = item
self.universe = item.menu.universe
]:
	i: 31(t), 40()
	o: 81(t), 104(f)

nname: 40
n 40(None)[]:
	i: 31(f)
	o: 48()

nname: 31
n 31(item)[playlist = playlist
]:
	i: 0(t), 24()
	o: 40(f), 48(t)

nname: 24
n 24(None)[]:
	i: 0(f)
	o: 31()

nname: 0
n 0(playlist)[self.status = True
stack = self.stack
]:
	i: 
	o: 24(f), 31(t)

nname: 182
n 182(None)[]:
	i: 48()
	o: 

nname: 48
n 48(None)[item = item
self.universe = item.menu.universe
if playlist != self.choices:
	self.set_items(playlist, 'main_list', item)
if self not in stack:
	stack.close_player()
	self.show(hide_previous_menu=hide_previous_menu)
	self._start_timers()
else:
	if hide_previous_menu:
		stack.bubble_raise(self)
]:
	i: 0(t)
	o: 182()

nname: 0
n 0(None)[self.status = True
stack = self.stack
if not playlist:
	pass
playlist = playlist
if not item:
	pass
]:
	i: 
	o: 48()

nname: 182
n 182(None)[]:
	i: 0()
	o: 

nname: 0
n 0(None)[self.status = True
stack = self.stack
if not playlist:
	pass
playlist = playlist
if not item:
	pass
item = item
self.universe = item.menu.universe
if playlist != self.choices:
	self.set_items(playlist, 'main_list', item)
if self not in stack:
	stack.close_player()
	self.show(hide_previous_menu=hide_previous_menu)
	self._start_timers()
else:
	if hide_previous_menu:
		stack.bubble_raise(self)
]:
	i: 
	o: 182()

nname: 0
n 0(None)[self.status = True
stack = self.stack
if not playlist:
	pass
playlist = playlist
if not item:
	pass
item = item
self.universe = item.menu.universe
if playlist != self.choices:
	self.set_items(playlist, 'main_list', item)
if self not in stack:
	stack.close_player()
	self.show(hide_previous_menu=hide_previous_menu)
	self._start_timers()
else:
	if hide_previous_menu:
		stack.bubble_raise(self)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76343cc>}
nname: 99
n 99(None)[Menu.stop(self)
return None
]:
	i: 63(), 85(), 98(AE)
	o: 

nname: 85
n 85(None)[PRINT_EXCEPTION()
]:
	i: 60(except)
	o: 99()

nname: 63
n 63(None)[self.stack.get_navigator().force_preview = True
]:
	i: 60(try)
	o: 99()

nname: 60
n 60(None)[]:
	i: 42(), 59()
	o: 63(try), 85(except)

nname: 59
n 59(None)[]:
	i: 0(f)
	o: 60()

nname: 42
n 42(None)[self._idle_timer.stop()
]:
	i: 0(t)
	o: 60()

nname: 0
n 0(self._idle_timer is not None)[self.status = None
self.total_time = 0.0
self.time_elapsed = 0.0
]:
	i: 
	o: 42(t), 59(f)

nname: 99
n 99(None)[Menu.stop(self)
return None
]:
	i: 63()
	o: 

nname: 63
n 63(None)[try:
	self.stack.get_navigator().force_preview = True
except:
	PRINT_EXCEPTION()
]:
	i: 0(try)
	o: 99()

nname: 0
n 0(None)[self.status = None
self.total_time = 0.0
self.time_elapsed = 0.0
if self._idle_timer is not None:
	self._idle_timer.stop()
]:
	i: 
	o: 63(try)

nname: 99
n 99(None)[Menu.stop(self)
return None
]:
	i: 0()
	o: 

nname: 0
n 0(None)[self.status = None
self.total_time = 0.0
self.time_elapsed = 0.0
if self._idle_timer is not None:
	self._idle_timer.stop()
try:
	self.stack.get_navigator().force_preview = True
except:
	PRINT_EXCEPTION()
]:
	i: 
	o: 99()

nname: 0
n 0(None)[self.status = None
self.total_time = 0.0
self.time_elapsed = 0.0
if self._idle_timer is not None:
	self._idle_timer.stop()
try:
	self.stack.get_navigator().force_preview = True
except:
	PRINT_EXCEPTION()
Menu.stop(self)
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb763412c>}
nname: 113
n 113(None)[]:
	i: 68(JA), 99(), 112()
	o: 

nname: 112
n 112(None)[]:
	i: 0(f)
	o: 113()

nname: 99
n 99(None)[info_menu.show()
]:
	i: 29(), 97(AE)
	o: 113()

nname: 97
n 97(None)[]:
	i: 58(f)
	o: 99(AE)

nname: 68
n 68(None)[log.warn('No InfoMeun defined for type %s', self.selected.type)
]:
	i: 58(t)
	o: 113(JA)

nname: 58
n 58(<dummy_ex3> EXC_MATCH KeyError)[]:
	i: 9(except)
	o: 68(t), 97(f)

nname: 29
n 29(None)[info_menu = item_info_menu_dict[self.selected.type](self.selected)
]:
	i: 9(try)
	o: 99()

nname: 9
n 9(None)[from pygui.menu.menu.info import item_info_menu_dict
]:
	i: 0(t)
	o: 29(try), 58(except)

nname: 0
n 0(self.selected)[]:
	i: 
	o: 9(t), 112(f)

nname: 113
n 113(None)[]:
	i: 68(JA), 99(), 58(f), 0(f)
	o: 

nname: 68
n 68(None)[log.warn('No InfoMeun defined for type %s', self.selected.type)
]:
	i: 58(t)
	o: 113(JA)

nname: 58
n 58(<dummy_ex3> EXC_MATCH KeyError)[]:
	i: 9(except)
	o: 68(t), 113(f)

nname: 99
n 99(None)[info_menu.show()
]:
	i: 29(), 97(AE)
	o: 113()

nname: 29
n 29(None)[info_menu = item_info_menu_dict[self.selected.type](self.selected)
]:
	i: 9(try)
	o: 99()

nname: 9
n 9(None)[from pygui.menu.menu.info import item_info_menu_dict
]:
	i: 0(t)
	o: 29(try), 58(except)

nname: 0
n 0(self.selected)[]:
	i: 
	o: 9(t), 113(f)

nname: 113
n 113(None)[]:
	i: 58(), 0(f)
	o: 

nname: 58
n 58(None)[except KeyError:
	log.warn('No InfoMeun defined for type %s', self.selected.type)
else:
	info_menu.show()
]:
	i: 9()
	o: 113()

nname: 9
n 9(None)[from pygui.menu.menu.info import item_info_menu_dict
try:
	info_menu = item_info_menu_dict[self.selected.type](self.selected)
]:
	i: 0(t)
	o: 58()

nname: 0
n 0(self.selected)[]:
	i: 
	o: 9(t), 113(f)

nname: 113
n 113(None)[]:
	i: 9(), 0(f)
	o: 

nname: 9
n 9(None)[from pygui.menu.menu.info import item_info_menu_dict
try:
	info_menu = item_info_menu_dict[self.selected.type](self.selected)
except KeyError:
	log.warn('No InfoMeun defined for type %s', self.selected.type)
else:
	info_menu.show()
]:
	i: 0(t)
	o: 113()

nname: 0
n 0(self.selected)[]:
	i: 
	o: 9(t), 113(f)

nname: 0
n 0(None)[if self.selected:
	from pygui.menu.menu.info import item_info_menu_dict
	try:
		info_menu = item_info_menu_dict[self.selected.type](self.selected)
	except KeyError:
		log.warn('No InfoMeun defined for type %s', self.selected.type)
	else:
		info_menu.show()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76347cc>}
nname: 6
n 6(None)[__doc__ = '\n    Class base for Player application\n\n    A Player is a specialized Menu which can (dis)play media such as Audio,\n    Video or Image,...\n    When we want to play something, a playlist may be passed. So the Player will\n    sequentially play all media present in the playlist.\n    '
toggleable = True
_timers_interval = 1
_idle_timer = None
def __init__(self, type_, universe=None):
	self.stack = pygui_globs['menustack']
	self.total_time = 0.0
	self.time_elapsed = 0.0
	Menu.__init__(self, [], type=type_, universe=universe)
	self._getitems_keywords.update(dict(time_elapsed=(lambda : _seconds_to_hhmmss(round(self.time_elapsed))), time_remaining=(lambda : _guarded_seconds_to_hhmmss(round(self.total_time) - round(self.time_elapsed))), time_total=(lambda : _guarded_seconds_to_hhmmss(round(self.total_time))), progressbar=self._get_progressbar, status_icon=self._get_status_icon, playmode_icon=self._get_playmode_icon, subtitles=(lambda : '')))
	self.tasks['tick'] = Task(self.tick_callback)
	self.tasks['screensaver_block'] = Task((lambda : None))

def could_remove_banner(self):
	return self.speed in (0, 1)

def _get_progressbar(self):
	if self.total_time - self.time_elapsed >= 1.0:
		return dict(pos=round(self.time_elapsed), max=round(self.total_time))
	else:
		return dict(pos=round(self.total_time), max=round(self.total_time))

def tick_callback(self):
	pass

def _start_timers(self):
	self.tasks['tick'].start(self._timers_interval, loop=True, init_delay=0)
	self.tasks['screensaver_block'].start(delay=config.user_config['power']['screensaver_threshold'] - 1, loop=True)

def _get_status_icon(self):
	try:
		status = self._get_status()
	except AttributeError:
		status = None
	if status:
		return status + '.png'
	return None

def _get_playmode_icon(self):
	status = self._get_playmode()
	if status:
		return status + '.png'

def _playlist_from_item(self, item):
	try:
		new_playlist = item.get_playlist()
		if not isinstance(new_playlist, (list, tuple)):
			new_playlist = new_playlist.playlist

def select(self, item_or_pos, list_name='main_list', force_pos=False):
	if self.get_item_list(list_name).selected == item_or_pos:
		return False
	ret = Menu.select(self, item_or_pos, list_name=list_name, force_pos=force_pos)
	if list_name != 'main_list':
		pass
	if ret:
		self.time_elapsed = 0.0
		self.total_time = 0.0
	if self.stack.is_on_top(self):
		self.stack.back_to_menu(self)
	louie_send('main_list', sender=self, action='reset', value=self['main_list'], position=self['main_list'].selected_pos)
	return ret

def clear(self):
	if self.status is None:
		log.debug('Clearing player...')
		for k in self.item_lists_dict:
			self.item_lists_dict[k].set_items([])
	return None

def play(self, item=None, playlist=None, hide_previous_menu=True):
	self.status = True
	stack = self.stack
	if not playlist:
		pass
	playlist = playlist
	if not item:
		pass
	item = item
	self.universe = item.menu.universe
	if playlist != self.choices:
		self.set_items(playlist, 'main_list', item)
	if self not in stack:
		stack.close_player()
		self.show(hide_previous_menu=hide_previous_menu)
		self._start_timers()
	else:
		if hide_previous_menu:
			stack.bubble_raise(self)

def stop(self):
	self.status = None
	self.total_time = 0.0
	self.time_elapsed = 0.0
	if self._idle_timer is not None:
		self._idle_timer.stop()
	try:
		self.stack.get_navigator().force_preview = True
	except:
		PRINT_EXCEPTION()
	Menu.stop(self)
	return None

def action_info(self):
	if self.selected:
		from pygui.menu.menu.info import item_info_menu_dict
		try:
			info_menu = item_info_menu_dict[self.selected.type](self.selected)
		except KeyError:
			log.warn('No InfoMeun defined for type %s', self.selected.type)
		else:
			info_menu.show()

_play_next = tasked(1)()
]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb763e1ec>}
nname: 0
n 0(None)[return self.wpl.duration
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb764be6c>}
nname: 0
n 0(None)[return self.wpl.slist()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb764be6c>}
nname: 0
n 0(None)[return self.wpl.alist()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb764becc>}
nname: 0
n 0(None)[return self.wpl.vlist()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb764be2c>}
nname: 192
n 192(None)[]:
	i: 167(), 191()
	o: 

nname: 191
n 191(None)[]:
	i: 0(f)
	o: 192()

nname: 167
n 167(None)[self.last_video_resolution = config.user_config['connections']['resolution']
]:
	i: 0(t)
	o: 192()

nname: 0
n 0(self._video_stream)[self.time_elapsed = 0.0
self._getitems_keywords.update(dict(video_substream_list=(lambda : self.wpl.vlist()), audio_substream_list=(lambda : self.wpl.alist()), subtitle_substream_list=(lambda : self.wpl.slist()), speed=self._formatted_speed, duration=(lambda : self.wpl.duration)))
self.wpl = wyplayer_instance()
self._old_status, self.status = self.wpl.status, self.wpl.status
self._speed = 1
self.repeat_mode = False
self.random_mode = False
]:
	i: 
	o: 167(t), 191(f)

nname: 0
n 0(None)[self.time_elapsed = 0.0
self._getitems_keywords.update(dict(video_substream_list=(lambda : self.wpl.vlist()), audio_substream_list=(lambda : self.wpl.alist()), subtitle_substream_list=(lambda : self.wpl.slist()), speed=self._formatted_speed, duration=(lambda : self.wpl.duration)))
self.wpl = wyplayer_instance()
self._old_status, self.status = self.wpl.status, self.wpl.status
self._speed = 1
self.repeat_mode = False
self.random_mode = False
if self._video_stream:
	self.last_video_resolution = config.user_config['connections']['resolution']
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb764b1cc>}
nname: 0
n 0(None)[return self.status in ('idle', 'closed')
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76443cc>}
nname: 0
n 0(None)[return self.status in ('idle', 'closed')
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7644a2c>}
nname: 0
n 0(None)[return self._speed
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7644a2c>}
nname: 161
n 161(None)[]:
	i: 0(AL), 160()
	o: 

nname: 160
n 160(None)[]:
	i: 43(AF), 141()
	o: 161()

nname: 141
n 141(None)[log.debug("Got expected signal '%s' !", sig)
]:
	i: 114(), 140()
	o: 160()

nname: 140
n 140(None)[]:
	i: 50&94(f)
	o: 141()

nname: 114
n 114(None)[log.debug("Expected signal '%s' never caught, raise Overflow exception!", sig)
raise OverflowError
]:
	i: 50&94(t)
	o: 141()

nname: 50&94
n 50&94(timeout and time() - t > timeout)[for sig in sig_list:
sig_handler = WPlayer._signals[sig]
t = time()
sig_handler.wait(timeout)
]:
	i: 43(for)
	o: 114(t), 140(f)

nname: 43
n 43(None)[]:
	i: 0(loop)
	o: 50&94(for), 160(AF)

nname: 0
n 0(None)[log.debug('Waiting for status %r', sig_list)
timeout = float(kw.get('timeout', 120))
]:
	i: 
	o: 43(loop), 161(AL)

nname: 161
n 161(None)[]:
	i: 0(AL), 43(AF), 50&94()
	o: 

nname: 50&94
n 50&94(None)[for sig in sig_list:
sig_handler = WPlayer._signals[sig]
t = time()
sig_handler.wait(timeout)
if timeout and time() - t > timeout:
	log.debug("Expected signal '%s' never caught, raise Overflow exception!", sig)
	raise OverflowError
log.debug("Got expected signal '%s' !", sig)
]:
	i: 43(for)
	o: 161()

nname: 43
n 43(None)[]:
	i: 0(loop)
	o: 50&94(for), 161(AF)

nname: 0
n 0(None)[log.debug('Waiting for status %r', sig_list)
timeout = float(kw.get('timeout', 120))
]:
	i: 
	o: 43(loop), 161(AL)

nname: 50&94
n 50&94(None)[for sig in sig_list:
	sig_handler = WPlayer._signals[sig]
	t = time()
	sig_handler.wait(timeout)
	if timeout and time() - t > timeout:
		log.debug("Expected signal '%s' never caught, raise Overflow exception!", sig)
		raise OverflowError
	log.debug("Got expected signal '%s' !", sig)
]:
	i: 0(for)
	o: 

nname: 0
n 0(None)[log.debug('Waiting for status %r', sig_list)
timeout = float(kw.get('timeout', 120))
]:
	i: 
	o: 50&94(for)

nname: 0
n 0(None)[log.debug('Waiting for status %r', sig_list)
timeout = float(kw.get('timeout', 120))
for sig in sig_list:
	sig_handler = WPlayer._signals[sig]
	t = time()
	sig_handler.wait(timeout)
	if timeout and time() - t > timeout:
		log.debug("Expected signal '%s' never caught, raise Overflow exception!", sig)
		raise OverflowError
	log.debug("Got expected signal '%s' !", sig)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb764b18c>}
nname: 63
n 63(None)[]:
	i: 49(), 62()
	o: 

nname: 62
n 62(None)[]:
	i: 0(f)
	o: 63()

nname: 49
n 49(None)[self.repeat_mode = False
]:
	i: 0(t)
	o: 63()

nname: 0
n 0(self.repeat_mode == 'track')[duration = self.wpl.duration / 1000.0
self.time_elapsed = 0.0
self.total_time = duration
]:
	i: 
	o: 49(t), 62(f)

nname: 0
n 0(None)[duration = self.wpl.duration / 1000.0
self.time_elapsed = 0.0
self.total_time = duration
if self.repeat_mode == 'track':
	self.repeat_mode = False
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7644acc>}
nname: 85
n 85(None)[self.old_status = self.status
self.status = status
self._status_change_callback(status)
]:
	i: 0(AL), 84()
	o: 

nname: 84
n 84(None)[]:
	i: 19(AF), 70()
	o: 85()

nname: 70
n 70(None)[e_sig.clear()
]:
	i: 35(f), 56()
	o: 84()

nname: 56
n 56(None)[e_sig.set()
continue
]:
	i: 35(t)
	o: 70()

nname: 35
n 35(e_name == status)[for e_name, e_sig in self._signals.iteritems():
]:
	i: 19(for)
	o: 56(t), 70(f)

nname: 19
n 19(None)[]:
	i: 0(loop)
	o: 35(for), 84(AF)

nname: 0
n 0(None)[log.debug('Status change: %s', status)
]:
	i: 
	o: 19(loop), 85(AL)

nname: 85
n 85(None)[self.old_status = self.status
self.status = status
self._status_change_callback(status)
]:
	i: 0(AL), 19(AF), 35()
	o: 

nname: 35
n 35(None)[for e_name, e_sig in self._signals.iteritems():
if e_name == status:
	e_sig.set()
	continue
e_sig.clear()
]:
	i: 19(for)
	o: 85()

nname: 19
n 19(None)[]:
	i: 0(loop)
	o: 35(for), 85(AF)

nname: 0
n 0(None)[log.debug('Status change: %s', status)
]:
	i: 
	o: 19(loop), 85(AL)

nname: 35
n 35(None)[for e_name, e_sig in self._signals.iteritems():
	if e_name == status:
		e_sig.set()
		continue
	e_sig.clear()
self.old_status = self.status
self.status = status
self._status_change_callback(status)
]:
	i: 0(for)
	o: 

nname: 0
n 0(None)[log.debug('Status change: %s', status)
]:
	i: 
	o: 35(for)

nname: 0
n 0(None)[log.debug('Status change: %s', status)
for e_name, e_sig in self._signals.iteritems():
	if e_name == status:
		e_sig.set()
		continue
	e_sig.clear()
self.old_status = self.status
self.status = status
self._status_change_callback(status)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76446ac>}
nname: 27
n 27(None)[]:
	i: 12(), 26()
	o: 

nname: 26
n 26(None)[]:
	i: 0(f)
	o: 27()

nname: 12
n 12(None)[self.update_media_info()
]:
	i: 0(t)
	o: 27()

nname: 0
n 0(status == 'playing')[]:
	i: 
	o: 12(t), 26(f)

nname: 0
n 0(None)[if status == 'playing':
	self.update_media_info()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7644b0c>}
nname: 189
n 189(None)[return 'stop'
]:
	i: 176(JA), 184(), 188()
	o: 

nname: 188
n 188(None)[]:
	i: 0(f)
	o: 189()

nname: 184
n 184(None)[]:
	i: 164(f)
	o: 189()

nname: 176
n 176(None)[return 'fast_rewind'
]:
	i: 164(t)
	o: 189(JA)

nname: 164
n 164(speed < -1)[]:
	i: 155(), 163()
	o: 176(t), 184(f)

nname: 163
n 163(None)[]:
	i: 143(f)
	o: 164()

nname: 155
n 155(None)[return 'fast_forward'
]:
	i: 143(t)
	o: 164()

nname: 143
n 143(speed > 1)[]:
	i: 134(), 142()
	o: 155(t), 163(f)

nname: 142
n 142(None)[]:
	i: 131(f)
	o: 143()

nname: 134
n 134(None)[return 'slow_motion_forward'
]:
	i: 131(t)
	o: 143()

nname: 131
n 131(0 < speed)[]:
	i: 119(), 129()
	o: 134(t), 142(f)

nname: 129
n 129(None)[speed
]:
	i: 105(f)
	o: 131()

nname: 119
n 119(None)[]:
	i: 105(t)
	o: 131()

nname: 105
n 105(0 < speed)[]:
	i: 96(), 104()
	o: 119(t), 129(f)

nname: 104
n 104(None)[]:
	i: 93(f)
	o: 105()

nname: 96
n 96(None)[return 'slow_motion_rewind'
]:
	i: 93(t)
	o: 105()

nname: 93
n 93(-1 <= speed)[]:
	i: 81(), 91()
	o: 96(t), 104(f)

nname: 91
n 91(None)[speed
]:
	i: 67(f)
	o: 93()

nname: 81
n 81(None)[]:
	i: 67(t)
	o: 93()

nname: 67
n 67(-1 <= speed)[]:
	i: 58(), 66()
	o: 81(t), 91(f)

nname: 66
n 66(None)[]:
	i: 46(f)
	o: 67()

nname: 58
n 58(None)[return 'play'
]:
	i: 46(t)
	o: 67()

nname: 46
n 46(speed == 1)[]:
	i: 37(), 45()
	o: 58(t), 66(f)

nname: 45
n 45(None)[]:
	i: 24(f)
	o: 46()

nname: 37
n 37(None)[return 'pause'
]:
	i: 24(t)
	o: 46()

nname: 24
n 24(speed == 0)[]:
	i: 0(t)
	o: 37(t), 45(f)

nname: 0
n 0(self.status == 'playing')[speed = self.speed
]:
	i: 
	o: 24(t), 188(f)

nname: 189
n 189(None)[return 'stop'
]:
	i: 143(JA), 0(f)
	o: 

nname: 143
n 143(None)[if speed > 1:
	return 'fast_forward'
if speed < -1:
	return 'fast_rewind'
]:
	i: 105()
	o: 189(JA)

nname: 105
n 105(None)[if 0 < speed:
	pass
else:
	speed
if 0 < speed:
	return 'slow_motion_forward'
]:
	i: 67()
	o: 143()

nname: 67
n 67(None)[if -1 <= speed:
	pass
else:
	speed
if -1 <= speed:
	return 'slow_motion_rewind'
]:
	i: 24()
	o: 105()

nname: 24
n 24(None)[if speed == 0:
	return 'pause'
if speed == 1:
	return 'play'
]:
	i: 0(t)
	o: 67()

nname: 0
n 0(self.status == 'playing')[speed = self.speed
]:
	i: 
	o: 24(t), 189(f)

nname: 189
n 189(None)[return 'stop'
]:
	i: 105(JA), 0(f)
	o: 

nname: 105
n 105(None)[if 0 < speed:
	pass
else:
	speed
if 0 < speed:
	return 'slow_motion_forward'
if speed > 1:
	return 'fast_forward'
if speed < -1:
	return 'fast_rewind'
]:
	i: 24()
	o: 189(JA)

nname: 24
n 24(None)[if speed == 0:
	return 'pause'
if speed == 1:
	return 'play'
if -1 <= speed:
	pass
else:
	speed
if -1 <= speed:
	return 'slow_motion_rewind'
]:
	i: 0(t)
	o: 105()

nname: 0
n 0(self.status == 'playing')[speed = self.speed
]:
	i: 
	o: 24(t), 189(f)

nname: 189
n 189(None)[return 'stop'
]:
	i: 24(JA), 0(f)
	o: 

nname: 24
n 24(None)[if speed == 0:
	return 'pause'
if speed == 1:
	return 'play'
if -1 <= speed:
	pass
else:
	speed
if -1 <= speed:
	return 'slow_motion_rewind'
if 0 < speed:
	pass
else:
	speed
if 0 < speed:
	return 'slow_motion_forward'
if speed > 1:
	return 'fast_forward'
if speed < -1:
	return 'fast_rewind'
]:
	i: 0(t)
	o: 189(JA)

nname: 0
n 0(self.status == 'playing')[speed = self.speed
]:
	i: 
	o: 24(t), 189(f)

nname: 0
n 0(None)[speed = self.speed
if self.status == 'playing':
	if speed == 0:
		return 'pause'
	if speed == 1:
		return 'play'
	if -1 <= speed:
		pass
	else:
		speed
	if -1 <= speed:
		return 'slow_motion_rewind'
	if 0 < speed:
		pass
	else:
		speed
	if 0 < speed:
		return 'slow_motion_forward'
	if speed > 1:
		return 'fast_forward'
	if speed < -1:
		return 'fast_rewind'
return 'stop'
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb764f64c>}
nname: 104
n 104(None)[]:
	i: 46(JA), 77(), 91(), 99()
	o: 

nname: 99
n 99(None)[return 'none'
]:
	i: 81(f)
	o: 104()

nname: 91
n 91(None)[return 'random'
]:
	i: 81(t)
	o: 104()

nname: 81
n 81(self.random_mode)[]:
	i: 0(f)
	o: 91(t), 99(f)

nname: 77
n 77(None)[return 'loop_track'
]:
	i: 66(), 73()
	o: 104()

nname: 73
n 73(None)[]:
	i: 50(f)
	o: 77()

nname: 66
n 66(None)[]:
	i: 50(t)
	o: 77()

nname: 50
n 50(self.repeat_mode == 'all')[]:
	i: 9(f)
	o: 66(t), 73(f)

nname: 46
n 46(None)[return 'loop_track_random'
]:
	i: 35(), 42()
	o: 104(JA)

nname: 42
n 42(None)[]:
	i: 19(f)
	o: 46()

nname: 35
n 35(None)[]:
	i: 19(t)
	o: 46()

nname: 19
n 19(self.repeat_mode == 'all')[]:
	i: 9(t)
	o: 35(t), 42(f)

nname: 9
n 9(self.random_mode)[]:
	i: 0(t)
	o: 19(t), 50(f)

nname: 0
n 0(self.repeat_mode)[]:
	i: 
	o: 9(t), 81(f)

nname: 104
n 104(None)[]:
	i: 19(JA), 50(), 81()
	o: 

nname: 81
n 81(None)[if self.random_mode:
	return 'random'
else:
	return 'none'
]:
	i: 0(f)
	o: 104()

nname: 50
n 50(None)[if self.repeat_mode == 'all':
	pass
return 'loop_track'
]:
	i: 9(f)
	o: 104()

nname: 19
n 19(None)[if self.repeat_mode == 'all':
	pass
return 'loop_track_random'
]:
	i: 9(t)
	o: 104(JA)

nname: 9
n 9(self.random_mode)[]:
	i: 0(t)
	o: 19(t), 50(f)

nname: 0
n 0(self.repeat_mode)[]:
	i: 
	o: 9(t), 81(f)

nname: 0
n 0(None)[if self.repeat_mode:
	if self.random_mode:
		if self.repeat_mode == 'all':
			pass
		return 'loop_track_random'
	else:
		if self.repeat_mode == 'all':
			pass
		return 'loop_track'
else:
	if self.random_mode:
		return 'random'
	else:
		return 'none'
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb763e74c>}
nname: 72
n 72(None)[return '%dx' % s
]:
	i: 63(), 71()
	o: 

nname: 71
n 71(None)[]:
	i: 51(f)
	o: 72()

nname: 63
n 63(None)[return ''
]:
	i: 51(t)
	o: 72()

nname: 51
n 51(s in (0, 1))[]:
	i: 38(), 50()
	o: 63(t), 71(f)

nname: 50
n 50(None)[]:
	i: 35(f)
	o: 51()

nname: 38
n 38(None)[return '%.1fx' % s
]:
	i: 35(t)
	o: 51()

nname: 35
n 35(0 < s)[]:
	i: 23(), 33()
	o: 38(t), 50(f)

nname: 33
n 33(None)[s
]:
	i: 0(f)
	o: 35()

nname: 23
n 23(None)[]:
	i: 0(t)
	o: 35()

nname: 0
n 0(0 < s)[s = self.speed
]:
	i: 
	o: 23(t), 33(f)

nname: 51
n 51(None)[if s in (0, 1):
	return ''
return '%dx' % s
]:
	i: 0()
	o: 

nname: 0
n 0(None)[s = self.speed
if 0 < s:
	pass
else:
	s
if 0 < s:
	return '%.1fx' % s
]:
	i: 
	o: 51()

nname: 0
n 0(None)[s = self.speed
if 0 < s:
	pass
else:
	s
if 0 < s:
	return '%.1fx' % s
if s in (0, 1):
	return ''
return '%dx' % s
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb763468c>}
nname: 1099
n 1099(None)[]:
	i: 1084(), 1098()
	o: 

nname: 1098
n 1098(None)[]:
	i: 1065&1071(f)
	o: 1099()

nname: 1084
n 1084(None)[self._play_next()
]:
	i: 1065&1071(t)
	o: 1099()

nname: 1065&1071
n 1065&1071(error or self._check_exception())[]:
	i: 1050(), 1064()
	o: 1084(t), 1098(f)

nname: 1064
n 1064(None)[]:
	i: 1044(f)
	o: 1065&1071()

nname: 1050
n 1050(None)[win.hide()
]:
	i: 1044(t)
	o: 1065&1071()

nname: 1044
n 1044(show_loading)[]:
	i: 891(AL), 1043()
	o: 1050(t), 1064(f)

nname: 1043
n 1043(None)[]:
	i: 938(AF), 1040()
	o: 1044()

nname: 1040
n 1040(None)[]:
	i: 1022(JA), 1039()
	o: 1043()

nname: 1039
n 1039(None)[break
]:
	i: 973(), 1037(AE)
	o: 1040()

nname: 1037
n 1037(None)[]:
	i: 996(f), 1033()
	o: 1039(AE)

nname: 1033
n 1033(None)[continue
]:
	i: 1006(f)
	o: 1037()

nname: 1022
n 1022(None)[error = True
break
]:
	i: 1006(t)
	o: 1040(JA)

nname: 1006
n 1006(self._check_exception())[]:
	i: 996(t)
	o: 1022(t), 1033(f)

nname: 996
n 996(<dummy_ex3> EXC_MATCH OverflowError)[]:
	i: 951(except)
	o: 1006(t), 1037(f)

nname: 973
n 973(None)[self._wait_for_status('playing', timeout=1)
]:
	i: 951(try)
	o: 1039()

nname: 951
n 951(None)[for n in xrange(100):
log.warning("It's the player countdown ! %d...", n)
]:
	i: 938(for)
	o: 973(try), 996(except)

nname: 938
n 938(None)[]:
	i: 891(loop)
	o: 951(for), 1043(AF)

nname: 891
n 891(None)[log.debug('PLAY LOADED!')
self.wpl.play_loaded(start_pos=offset, bytes=use_bytes)
error = False
]:
	i: 876(), 890()
	o: 938(loop), 1044(AL)

nname: 890
n 890(None)[]:
	i: 864(f)
	o: 891()

nname: 876
n 876(None)[self._set_framerate()
]:
	i: 864(t)
	o: 891()

nname: 864
n 864(self._video_stream)[use_bytes = False
]:
	i: 840(), 860()
	o: 876(t), 890(f)

nname: 860
n 860(None)[]:
	i: 831(f)
	o: 864()

nname: 840
n 840(None)[]:
	i: 831(t)
	o: 864()

nname: 831
n 831(item.wymedia_resource)[]:
	i: 589(AL), 830()
	o: 840(t), 860(f)

nname: 830
n 830(None)[]:
	i: 744(AF), 826()
	o: 831()

nname: 826
n 826(None)[]:
	i: 760(f), 789()
	o: 830()

nname: 789
n 789(None)[self.wpl.aid = a_track['id']
log.info('audio: %s', a_track)
break
continue
]:
	i: 760(t)
	o: 826()

nname: 760
n 760(a_track['lang'][:preferred_len].lower() == preferred_language)[for a_track in self.wpl.alist():
]:
	i: 744(for)
	o: 789(t), 826(f)

nname: 744
n 744(None)[]:
	i: 589(loop)
	o: 760(for), 830(AF)

nname: 589
n 589(None)[self.wpl.spdif_surround = config.user_config['connections']['spdif_surround']
log.debug('LOAD URI: %s (%s)', item['uri'], uri_options)
self.wpl.load_uri(item['uri'], uri_options)
self._wait_for_status('loading', timeout=3)
self._wait_for_status('idle', timeout=20)
preferred_language = config.user_config['video']['language']
preferred_len = len(preferred_language)
log.info('preferred: %s', preferred_language)
]:
	i: 560(), 588()
	o: 744(loop), 831(AL)

nname: 588
n 588(None)[]:
	i: 544(f)
	o: 589()

nname: 560
n 560(None)[uri_options['dlna_profile'] = dlna
uri_options['mime_type'] = item['mimeType']
]:
	i: 544(t)
	o: 589()

nname: 544
n 544(dlna)[dlna = item['dlnaProfile']
]:
	i: 529(JA), 539(), 543()
	o: 560(t), 588(f)

nname: 543
n 543(None)[]:
	i: 452(f)
	o: 544()

nname: 539
n 539(None)[]:
	i: 461(f)
	o: 544()

nname: 529
n 529(None)[uri_options['sublang'] = default_sub
]:
	i: 478(t), 525()
	o: 544(JA)

nname: 525
n 525(None)[]:
	i: 478(f)
	o: 529()

nname: 478
n 478(default_sub)[sub_path = subs[0]['uri'].split('//', 1)[1]
uri_options['subfile'] = sub_path
]:
	i: 461(t)
	o: 525(f), 529(t)

nname: 461
n 461(subs)[subs = item['subtitles']
]:
	i: 452(t)
	o: 478(t), 539(f)

nname: 452
n 452(self._sub_stream)[]:
	i: 272(), 404(), 451()
	o: 461(t), 543(f)

nname: 451
n 451(None)[]:
	i: 388(f)
	o: 452()

nname: 404
n 404(None)[log.debug('STATUS IS NOT IDLE , stopping...')
self._signals['playing'].clear()
self.wpl.stop()
]:
	i: 388(t)
	o: 452()

nname: 388
n 388(self.status != 'idle')[]:
	i: 216(f)
	o: 404(t), 451(f)

nname: 272
n 272(None)[log.debug('STATUS IS CLOSED, opening...')
options['audio'] = self._audio_stream
options['video'] = self._video_stream
options['subtitles'] = self._sub_stream
self.wpl.open(**options)
self.aspect_ratio = player_aspect_ratio_dict[config.user_config['video']['aspect_ratio']]
self.display_format = config.user_config['video']['display_format']
]:
	i: 216(t)
	o: 452()

nname: 216
n 216(self.status == 'closed')[self.old_status, self.status = self.wpl.status, self.wpl.status
log.info('STATUS: %s', self.status)
]:
	i: 129(AL), 215()
	o: 272(t), 388(f)

nname: 215
n 215(None)[]:
	i: 150(AF), 201()
	o: 216()

nname: 201
n 201(None)[uri_options[k] = v
]:
	i: 166(f), 187()
	o: 215()

nname: 187
n 187(None)[options[k] = v
continue
]:
	i: 166(t)
	o: 201()

nname: 166
n 166(k in ('data', 'osd', 'outwin', 'adrv', 'vdrv'))[for k, v in item.wpl_options.iteritems():
]:
	i: 150(for)
	o: 187(t), 201(f)

nname: 150
n 150(None)[]:
	i: 129(loop)
	o: 166(for), 215(AF)

nname: 129
n 129(None)[options = dict()
uri_options = dict()
]:
	i: 80(), 104(), 127(AE)
	o: 150(loop), 216(AL)

nname: 127
n 127(None)[]:
	i: 94(f)
	o: 129(AE)

nname: 104
n 104(None)[log.warning('item %s is not updatable', item)
]:
	i: 94(t)
	o: 129()

nname: 94
n 94(<dummy_ex3> EXC_MATCH AttributeError)[]:
	i: 33(except)
	o: 104(t), 127(f)

nname: 80
n 80(None)[item.media_update()
]:
	i: 33(try)
	o: 129()

nname: 33
n 33(None)[self.wpl.watch_property('status', self.status_change_callback)
self.wpl.watch_property('speed', self.speed_change_callback)
]:
	i: 6(), 32()
	o: 80(try), 94(except)

nname: 32
n 32(None)[]:
	i: 0(f)
	o: 33()

nname: 6
n 6(None)[win = MessageWindow('Loading...')
win.show()
]:
	i: 0(t)
	o: 33()

nname: 0
n 0(show_loading)[]:
	i: 
	o: 6(t), 32(f)

nname: 1099
n 1099(None)[]:
	i: 1044()
	o: 

nname: 1044
n 1044(None)[if show_loading:
	win.hide()
if error or self._check_exception():
	self._play_next()
]:
	i: 891(AL), 938(AF), 1022(JA), 1039()
	o: 1099()

nname: 1039
n 1039(None)[break
]:
	i: 973(), 1037(AE)
	o: 1044()

nname: 1037
n 1037(None)[]:
	i: 996(f), 1033()
	o: 1039(AE)

nname: 1033
n 1033(None)[continue
]:
	i: 1006(f)
	o: 1037()

nname: 1022
n 1022(None)[error = True
break
]:
	i: 1006(t)
	o: 1044(JA)

nname: 1006
n 1006(self._check_exception())[]:
	i: 996(t)
	o: 1022(t), 1033(f)

nname: 996
n 996(<dummy_ex3> EXC_MATCH OverflowError)[]:
	i: 951(except)
	o: 1006(t), 1037(f)

nname: 973
n 973(None)[self._wait_for_status('playing', timeout=1)
]:
	i: 951(try)
	o: 1039()

nname: 951
n 951(None)[for n in xrange(100):
log.warning("It's the player countdown ! %d...", n)
]:
	i: 938(for)
	o: 973(try), 996(except)

nname: 938
n 938(None)[]:
	i: 891(loop)
	o: 951(for), 1044(AF)

nname: 891
n 891(None)[log.debug('PLAY LOADED!')
self.wpl.play_loaded(start_pos=offset, bytes=use_bytes)
error = False
]:
	i: 831()
	o: 938(loop), 1044(AL)

nname: 831
n 831(None)[if item.wymedia_resource:
	pass
use_bytes = False
if self._video_stream:
	self._set_framerate()
]:
	i: 544(AL), 744(AF), 760()
	o: 891()

nname: 760
n 760(None)[for a_track in self.wpl.alist():
if a_track['lang'][:preferred_len].lower() == preferred_language:
	self.wpl.aid = a_track['id']
	log.info('audio: %s', a_track)
	break
	continue
]:
	i: 744(for)
	o: 831()

nname: 744
n 744(None)[]:
	i: 544(loop)
	o: 760(for), 831(AF)

nname: 544
n 544(None)[dlna = item['dlnaProfile']
if dlna:
	uri_options['dlna_profile'] = dlna
	uri_options['mime_type'] = item['mimeType']
self.wpl.spdif_surround = config.user_config['connections']['spdif_surround']
log.debug('LOAD URI: %s (%s)', item['uri'], uri_options)
self.wpl.load_uri(item['uri'], uri_options)
self._wait_for_status('loading', timeout=3)
self._wait_for_status('idle', timeout=20)
preferred_language = config.user_config['video']['language']
preferred_len = len(preferred_language)
log.info('preferred: %s', preferred_language)
]:
	i: 478(JA), 461(f), 216(f)
	o: 744(loop), 831(AL)

nname: 478
n 478(None)[sub_path = subs[0]['uri'].split('//', 1)[1]
uri_options['subfile'] = sub_path
if not default_sub:
	pass
uri_options['sublang'] = default_sub
]:
	i: 461(t)
	o: 544(JA)

nname: 461
n 461(subs)[subs = item['subtitles']
]:
	i: 216(t)
	o: 478(t), 544(f)

nname: 216
n 216(self._sub_stream)[self.old_status, self.status = self.wpl.status, self.wpl.status
log.info('STATUS: %s', self.status)
if self.status == 'closed':
	log.debug('STATUS IS CLOSED, opening...')
	options['audio'] = self._audio_stream
	options['video'] = self._video_stream
	options['subtitles'] = self._sub_stream
	self.wpl.open(**options)
	self.aspect_ratio = player_aspect_ratio_dict[config.user_config['video']['aspect_ratio']]
	self.display_format = config.user_config['video']['display_format']
else:
	if self.status != 'idle':
		log.debug('STATUS IS NOT IDLE , stopping...')
		self._signals['playing'].clear()
		self.wpl.stop()
]:
	i: 129(AL), 150(AF), 166()
	o: 461(t), 544(f)

nname: 166
n 166(None)[for k, v in item.wpl_options.iteritems():
if k in ('data', 'osd', 'outwin', 'adrv', 'vdrv'):
	options[k] = v
	continue
uri_options[k] = v
]:
	i: 150(for)
	o: 216()

nname: 150
n 150(None)[]:
	i: 129(loop)
	o: 166(for), 216(AF)

nname: 129
n 129(None)[options = dict()
uri_options = dict()
]:
	i: 80()
	o: 150(loop), 216(AL)

nname: 80
n 80(None)[try:
	item.media_update()
except AttributeError:
	log.warning('item %s is not updatable', item)
]:
	i: 0(try)
	o: 129()

nname: 0
n 0(None)[if show_loading:
	win = MessageWindow('Loading...')
	win.show()
self.wpl.watch_property('status', self.status_change_callback)
self.wpl.watch_property('speed', self.speed_change_callback)
]:
	i: 
	o: 80(try)

nname: 1044
n 1044(None)[if show_loading:
	win.hide()
if error or self._check_exception():
	self._play_next()
]:
	i: 831(AL), 938(AF), 1022(JA), 1039()
	o: 

nname: 1039
n 1039(None)[break
]:
	i: 973(), 1037(AE)
	o: 1044()

nname: 1037
n 1037(None)[]:
	i: 996(f), 1033()
	o: 1039(AE)

nname: 1033
n 1033(None)[continue
]:
	i: 1006(f)
	o: 1037()

nname: 1022
n 1022(None)[error = True
break
]:
	i: 1006(t)
	o: 1044(JA)

nname: 1006
n 1006(self._check_exception())[]:
	i: 996(t)
	o: 1022(t), 1033(f)

nname: 996
n 996(<dummy_ex3> EXC_MATCH OverflowError)[]:
	i: 951(except)
	o: 1006(t), 1037(f)

nname: 973
n 973(None)[self._wait_for_status('playing', timeout=1)
]:
	i: 951(try)
	o: 1039()

nname: 951
n 951(None)[for n in xrange(100):
log.warning("It's the player countdown ! %d...", n)
]:
	i: 938(for)
	o: 973(try), 996(except)

nname: 938
n 938(None)[]:
	i: 831(loop)
	o: 951(for), 1044(AF)

nname: 831
n 831(None)[if item.wymedia_resource:
	pass
use_bytes = False
if self._video_stream:
	self._set_framerate()
log.debug('PLAY LOADED!')
self.wpl.play_loaded(start_pos=offset, bytes=use_bytes)
error = False
]:
	i: 544(AL), 744(AF), 760()
	o: 938(loop), 1044(AL)

nname: 760
n 760(None)[for a_track in self.wpl.alist():
if a_track['lang'][:preferred_len].lower() == preferred_language:
	self.wpl.aid = a_track['id']
	log.info('audio: %s', a_track)
	break
	continue
]:
	i: 744(for)
	o: 831()

nname: 744
n 744(None)[]:
	i: 544(loop)
	o: 760(for), 831(AF)

nname: 544
n 544(None)[dlna = item['dlnaProfile']
if dlna:
	uri_options['dlna_profile'] = dlna
	uri_options['mime_type'] = item['mimeType']
self.wpl.spdif_surround = config.user_config['connections']['spdif_surround']
log.debug('LOAD URI: %s (%s)', item['uri'], uri_options)
self.wpl.load_uri(item['uri'], uri_options)
self._wait_for_status('loading', timeout=3)
self._wait_for_status('idle', timeout=20)
preferred_language = config.user_config['video']['language']
preferred_len = len(preferred_language)
log.info('preferred: %s', preferred_language)
]:
	i: 166(f)
	o: 744(loop), 831(AL)

nname: 166
n 166(None)[for k, v in item.wpl_options.iteritems():
	if k in ('data', 'osd', 'outwin', 'adrv', 'vdrv'):
		options[k] = v
		continue
	uri_options[k] = v
self.old_status, self.status = self.wpl.status, self.wpl.status
log.info('STATUS: %s', self.status)
if self.status == 'closed':
	log.debug('STATUS IS CLOSED, opening...')
	options['audio'] = self._audio_stream
	options['video'] = self._video_stream
	options['subtitles'] = self._sub_stream
	self.wpl.open(**options)
	self.aspect_ratio = player_aspect_ratio_dict[config.user_config['video']['aspect_ratio']]
	self.display_format = config.user_config['video']['display_format']
else:
	if self.status != 'idle':
		log.debug('STATUS IS NOT IDLE , stopping...')
		self._signals['playing'].clear()
		self.wpl.stop()
if self._sub_stream:
	subs = item['subtitles']
	if subs:
		sub_path = subs[0]['uri'].split('//', 1)[1]
		uri_options['subfile'] = sub_path
		if not default_sub:
			pass
		uri_options['sublang'] = default_sub
]:
	i: 129(for)
	o: 544(JA)

nname: 129
n 129(None)[options = dict()
uri_options = dict()
]:
	i: 0()
	o: 166(for)

nname: 0
n 0(None)[if show_loading:
	win = MessageWindow('Loading...')
	win.show()
self.wpl.watch_property('status', self.status_change_callback)
self.wpl.watch_property('speed', self.speed_change_callback)
try:
	item.media_update()
except AttributeError:
	log.warning('item %s is not updatable', item)
]:
	i: 
	o: 129()

nname: 1044
n 1044(None)[if show_loading:
	win.hide()
if error or self._check_exception():
	self._play_next()
]:
	i: 831(AL), 938(AF), 1022(JA), 1039()
	o: 

nname: 1039
n 1039(None)[break
]:
	i: 973(), 1037(AE)
	o: 1044()

nname: 1037
n 1037(None)[]:
	i: 996(f), 1033()
	o: 1039(AE)

nname: 1033
n 1033(None)[continue
]:
	i: 1006(f)
	o: 1037()

nname: 1022
n 1022(None)[error = True
break
]:
	i: 1006(t)
	o: 1044(JA)

nname: 1006
n 1006(self._check_exception())[]:
	i: 996(t)
	o: 1022(t), 1033(f)

nname: 996
n 996(<dummy_ex3> EXC_MATCH OverflowError)[]:
	i: 951(except)
	o: 1006(t), 1037(f)

nname: 973
n 973(None)[self._wait_for_status('playing', timeout=1)
]:
	i: 951(try)
	o: 1039()

nname: 951
n 951(None)[for n in xrange(100):
log.warning("It's the player countdown ! %d...", n)
]:
	i: 938(for)
	o: 973(try), 996(except)

nname: 938
n 938(None)[]:
	i: 831(loop)
	o: 951(for), 1044(AF)

nname: 831
n 831(None)[if item.wymedia_resource:
	pass
use_bytes = False
if self._video_stream:
	self._set_framerate()
log.debug('PLAY LOADED!')
self.wpl.play_loaded(start_pos=offset, bytes=use_bytes)
error = False
]:
	i: 166(AL), 744(AF), 760()
	o: 938(loop), 1044(AL)

nname: 760
n 760(None)[for a_track in self.wpl.alist():
if a_track['lang'][:preferred_len].lower() == preferred_language:
	self.wpl.aid = a_track['id']
	log.info('audio: %s', a_track)
	break
	continue
]:
	i: 744(for)
	o: 831()

nname: 744
n 744(None)[]:
	i: 166(loop)
	o: 760(for), 831(AF)

nname: 166
n 166(None)[for k, v in item.wpl_options.iteritems():
	if k in ('data', 'osd', 'outwin', 'adrv', 'vdrv'):
		options[k] = v
		continue
	uri_options[k] = v
self.old_status, self.status = self.wpl.status, self.wpl.status
log.info('STATUS: %s', self.status)
if self.status == 'closed':
	log.debug('STATUS IS CLOSED, opening...')
	options['audio'] = self._audio_stream
	options['video'] = self._video_stream
	options['subtitles'] = self._sub_stream
	self.wpl.open(**options)
	self.aspect_ratio = player_aspect_ratio_dict[config.user_config['video']['aspect_ratio']]
	self.display_format = config.user_config['video']['display_format']
else:
	if self.status != 'idle':
		log.debug('STATUS IS NOT IDLE , stopping...')
		self._signals['playing'].clear()
		self.wpl.stop()
if self._sub_stream:
	subs = item['subtitles']
	if subs:
		sub_path = subs[0]['uri'].split('//', 1)[1]
		uri_options['subfile'] = sub_path
		if not default_sub:
			pass
		uri_options['sublang'] = default_sub
dlna = item['dlnaProfile']
if dlna:
	uri_options['dlna_profile'] = dlna
	uri_options['mime_type'] = item['mimeType']
self.wpl.spdif_surround = config.user_config['connections']['spdif_surround']
log.debug('LOAD URI: %s (%s)', item['uri'], uri_options)
self.wpl.load_uri(item['uri'], uri_options)
self._wait_for_status('loading', timeout=3)
self._wait_for_status('idle', timeout=20)
preferred_language = config.user_config['video']['language']
preferred_len = len(preferred_language)
log.info('preferred: %s', preferred_language)
]:
	i: 0(for)
	o: 744(loop), 831(AL)

nname: 0
n 0(None)[if show_loading:
	win = MessageWindow('Loading...')
	win.show()
self.wpl.watch_property('status', self.status_change_callback)
self.wpl.watch_property('speed', self.speed_change_callback)
try:
	item.media_update()
except AttributeError:
	log.warning('item %s is not updatable', item)
options = dict()
uri_options = dict()
]:
	i: 
	o: 166(for)

nname: 1044
n 1044(None)[if show_loading:
	win.hide()
if error or self._check_exception():
	self._play_next()
]:
	i: 831(AL), 938(AF), 1022(JA), 1039()
	o: 

nname: 1039
n 1039(None)[break
]:
	i: 973(), 1037(AE)
	o: 1044()

nname: 1037
n 1037(None)[]:
	i: 996(f), 1033()
	o: 1039(AE)

nname: 1033
n 1033(None)[continue
]:
	i: 1006(f)
	o: 1037()

nname: 1022
n 1022(None)[error = True
break
]:
	i: 1006(t)
	o: 1044(JA)

nname: 1006
n 1006(self._check_exception())[]:
	i: 996(t)
	o: 1022(t), 1033(f)

nname: 996
n 996(<dummy_ex3> EXC_MATCH OverflowError)[]:
	i: 951(except)
	o: 1006(t), 1037(f)

nname: 973
n 973(None)[self._wait_for_status('playing', timeout=1)
]:
	i: 951(try)
	o: 1039()

nname: 951
n 951(None)[for n in xrange(100):
log.warning("It's the player countdown ! %d...", n)
]:
	i: 938(for)
	o: 973(try), 996(except)

nname: 938
n 938(None)[]:
	i: 831(loop)
	o: 951(for), 1044(AF)

nname: 831
n 831(None)[if item.wymedia_resource:
	pass
use_bytes = False
if self._video_stream:
	self._set_framerate()
log.debug('PLAY LOADED!')
self.wpl.play_loaded(start_pos=offset, bytes=use_bytes)
error = False
]:
	i: 0(AL), 744(AF), 760()
	o: 938(loop), 1044(AL)

nname: 760
n 760(None)[for a_track in self.wpl.alist():
if a_track['lang'][:preferred_len].lower() == preferred_language:
	self.wpl.aid = a_track['id']
	log.info('audio: %s', a_track)
	break
	continue
]:
	i: 744(for)
	o: 831()

nname: 744
n 744(None)[]:
	i: 0(loop)
	o: 760(for), 831(AF)

nname: 0
n 0(None)[if show_loading:
	win = MessageWindow('Loading...')
	win.show()
self.wpl.watch_property('status', self.status_change_callback)
self.wpl.watch_property('speed', self.speed_change_callback)
try:
	item.media_update()
except AttributeError:
	log.warning('item %s is not updatable', item)
options = dict()
uri_options = dict()
for k, v in item.wpl_options.iteritems():
	if k in ('data', 'osd', 'outwin', 'adrv', 'vdrv'):
		options[k] = v
		continue
	uri_options[k] = v
self.old_status, self.status = self.wpl.status, self.wpl.status
log.info('STATUS: %s', self.status)
if self.status == 'closed':
	log.debug('STATUS IS CLOSED, opening...')
	options['audio'] = self._audio_stream
	options['video'] = self._video_stream
	options['subtitles'] = self._sub_stream
	self.wpl.open(**options)
	self.aspect_ratio = player_aspect_ratio_dict[config.user_config['video']['aspect_ratio']]
	self.display_format = config.user_config['video']['display_format']
else:
	if self.status != 'idle':
		log.debug('STATUS IS NOT IDLE , stopping...')
		self._signals['playing'].clear()
		self.wpl.stop()
if self._sub_stream:
	subs = item['subtitles']
	if subs:
		sub_path = subs[0]['uri'].split('//', 1)[1]
		uri_options['subfile'] = sub_path
		if not default_sub:
			pass
		uri_options['sublang'] = default_sub
dlna = item['dlnaProfile']
if dlna:
	uri_options['dlna_profile'] = dlna
	uri_options['mime_type'] = item['mimeType']
self.wpl.spdif_surround = config.user_config['connections']['spdif_surround']
log.debug('LOAD URI: %s (%s)', item['uri'], uri_options)
self.wpl.load_uri(item['uri'], uri_options)
self._wait_for_status('loading', timeout=3)
self._wait_for_status('idle', timeout=20)
preferred_language = config.user_config['video']['language']
preferred_len = len(preferred_language)
log.info('preferred: %s', preferred_language)
]:
	i: 
	o: 744(loop), 831(AL)

self.nodes: {0: <unpyclib.structure.node instance at 0xb764c9ec>, 1033: <unpyclib.structure.node instance at 0x84b0f0c>, 1039: <unpyclib.structure.node instance at 0x84b02ec>, 938: <unpyclib.structure.node instance at 0x84b0c0c>, 1037: <unpyclib.structure.node instance at 0x84b0f8c>, 951: <unpyclib.structure.node instance at 0x84b0c8c>, 831: <unpyclib.structure.node instance at 0xb764cd6c>, 973: <unpyclib.structure.node instance at 0x84b0d0c>, 996: <unpyclib.structure.node instance at 0x84b0d8c>, 1006: <unpyclib.structure.node instance at 0x84b0e0c>, 744: <unpyclib.structure.node instance at 0x84b060c>, 760: <unpyclib.structure.node instance at 0x84bc1ec>, 1044: <unpyclib.structure.node instance at 0xb764c52c>, 1022: <unpyclib.structure.node instance at 0x84b0e8c>}
nname: 0
n 0(None)[log.debug('calling wpl.close() / wpl.open() ...')
options = dict()
options['audio'] = self._audio_stream
options['video'] = self._video_stream
options['subtitles'] = self._sub_stream
self.wpl.close()
self.wpl.open(**options)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb764492c>}
nname: 496
n 496(None)[return None
]:
	i: 474(JA), 478(JA), 492(), 495()
	o: 

nname: 495
n 495(None)[]:
	i: 331&337&353(f)
	o: 496()

nname: 478
n 478(None)[PRINT_EXCEPTION()
]:
	i: 369(except)
	o: 496(JA)

nname: 474
n 474(None)[]:
	i: 440(JA), 453(), 473()
	o: 496(JA)

nname: 473
n 473(None)[]:
	i: 373(f)
	o: 474()

nname: 453
n 453(None)[log.warn('auto_framerate failed. %s not supported', new_mode)
]:
	i: 414(f)
	o: 474()

nname: 440
n 440(None)[self.last_video_resolution = new_mode
]:
	i: 414(t)
	o: 474(JA)

nname: 414
n 414(vm.secure_set_resolution(new_mode))[self._clear_wpl()
]:
	i: 373(t)
	o: 440(t), 453(f)

nname: 373
n 373(vm.hdmi_sink)[log.debug('auto_framerate: change mode %s  ->  %s', self.last_video_resolution, new_mode)
vm = pygui_globs['videomodes']
]:
	i: 369(try)
	o: 414(t), 473(f)

nname: 369
n 369(None)[]:
	i: 331&337&353(t)
	o: 373(try), 478(except)

nname: 331&337&353
n 331&337&353(new_mode and self.status != 'playing' and self.last_video_resolution != new_mode)[]:
	i: 39(JA), 273(JA), 282(), 330()
	o: 369(t), 495(f)

nname: 330
n 330(None)[]:
	i: 0(f)
	o: 331&337&353()

nname: 282
n 282(None)[new_mode = list(config.user_config['connections']['resolution'])
new_mode[-1] = framerate
new_mode = tuple(new_mode)
]:
	i: 259(), 280(AE)
	o: 331&337&353()

nname: 280
n 280(None)[]:
	i: 263(f)
	o: 282(AE)

nname: 273
n 273(None)[]:
	i: 263(t)
	o: 331&337&353(JA)

nname: 263
n 263(<dummy_ex3> EXC_MATCH IndexError)[]:
	i: 62(except)
	o: 273(t), 280(f)

nname: 259
n 259(None)[]:
	i: 221(JA), 227(), 237()
	o: 282()

nname: 237
n 237(None)[framerate = config.user_config['connections']['resolution'][3]
]:
	i: 79(f)
	o: 259()

nname: 227
n 227(None)[raise IndexError
]:
	i: 194(f)
	o: 259()

nname: 221
n 221(None)[framerate = 59
]:
	i: 210(), 217()
	o: 259(JA)

nname: 217
n 217(None)[]:
	i: 197(f)
	o: 221()

nname: 210
n 210(None)[]:
	i: 197(t)
	o: 221()

nname: 197
n 197(framerate in fuzzy_list)[]:
	i: 194(t)
	o: 210(t), 217(f)

nname: 194
n 194(10 < framerate)[]:
	i: 182(), 192()
	o: 197(t), 227(f)

nname: 192
n 192(None)[framerate
]:
	i: 137(f)
	o: 194()

nname: 182
n 182(None)[]:
	i: 137(t)
	o: 194()

nname: 137
n 137(10 < framerate)[framerate = vlist[0]['framerate']
log.debug('auto_framerate: wpl.framerate: %s', framerate)
]:
	i: 79(t)
	o: 182(t), 192(f)

nname: 79
n 79(vlist)[from peewee.ranges import f_list
fuzzy_list = f_list([25.0], range=2)
vlist = self.wpl.vlist()
]:
	i: 62(try)
	o: 137(t), 237(f)

nname: 62
n 62(None)[log.debug('wpl.is_cinema() returned False')
]:
	i: 23(f)
	o: 79(try), 263(except)

nname: 39
n 39(None)[new_mode = (1920, 1080, 0, 24)
log.debug('wpl.is_cinema() returned True: new_mode = (1920, 1080, 0, 24)')
]:
	i: 23(t)
	o: 331&337&353(JA)

nname: 23
n 23(self.wpl.is_cinema())[]:
	i: 0(t)
	o: 39(t), 62(f)

nname: 0
n 0(config.user_config['connections']['auto_frame_rate'])[new_mode = None
]:
	i: 
	o: 23(t), 330(f)

nname: 496
n 496(None)[return None
]:
	i: 478(JA), 492(), 331&337&353(f)
	o: 

nname: 478
n 478(None)[except:
	PRINT_EXCEPTION()
else:
	pass
]:
	i: 369()
	o: 496(JA)

nname: 369
n 369(None)[try:
	log.debug('auto_framerate: change mode %s  ->  %s', self.last_video_resolution, new_mode)
	vm = pygui_globs['videomodes']
	if vm.hdmi_sink:
		self._clear_wpl()
		if vm.secure_set_resolution(new_mode):
			self.last_video_resolution = new_mode
		else:
			log.warn('auto_framerate failed. %s not supported', new_mode)
]:
	i: 331&337&353(t)
	o: 478()

nname: 331&337&353
n 331&337&353(new_mode and self.status != 'playing' and self.last_video_resolution != new_mode)[]:
	i: 39(JA), 282(), 263(f), 263(t), 0(f)
	o: 369(t), 496(f)

nname: 263
n 263(<dummy_ex3> EXC_MATCH IndexError)[]:
	i: 62(except)
	o: 331&337&353(f)

nname: 282
n 282(None)[new_mode = list(config.user_config['connections']['resolution'])
new_mode[-1] = framerate
new_mode = tuple(new_mode)
]:
	i: 280(AE), 197(JA), 227(), 237()
	o: 331&337&353()

nname: 237
n 237(None)[framerate = config.user_config['connections']['resolution'][3]
]:
	i: 79(f)
	o: 282()

nname: 227
n 227(None)[raise IndexError
]:
	i: 137(f)
	o: 282()

nname: 197
n 197(None)[if framerate in fuzzy_list:
	pass
framerate = 59
]:
	i: 137(t)
	o: 282(JA)

nname: 137
n 137(10 < framerate)[framerate = vlist[0]['framerate']
log.debug('auto_framerate: wpl.framerate: %s', framerate)
if 10 < framerate:
	pass
else:
	framerate
]:
	i: 79(t)
	o: 197(t), 227(f)

nname: 79
n 79(vlist)[from peewee.ranges import f_list
fuzzy_list = f_list([25.0], range=2)
vlist = self.wpl.vlist()
]:
	i: 62(try)
	o: 137(t), 237(f)

nname: 62
n 62(None)[log.debug('wpl.is_cinema() returned False')
]:
	i: 23(f)
	o: 79(try), 263(except)

structureSingleExcept Exception 'NoneType' object has no attribute 'toNode'
nname: 39
n 39(None)[new_mode = (1920, 1080, 0, 24)
log.debug('wpl.is_cinema() returned True: new_mode = (1920, 1080, 0, 24)')
]:
	i: 23(t)
	o: 331&337&353(JA)

nname: 23
n 23(self.wpl.is_cinema())[]:
	i: 0(t)
	o: 39(t), 62(f)

nname: 0
n 0(config.user_config['connections']['auto_frame_rate'])[new_mode = None
]:
	i: 
	o: 23(t), 331&337&353(f)

nname: 496
n 496(None)[return None
]:
	i: 369(JA), 492(), 331&337&353(f)
	o: 

nname: 369
n 369(None)[try:
	log.debug('auto_framerate: change mode %s  ->  %s', self.last_video_resolution, new_mode)
	vm = pygui_globs['videomodes']
	if vm.hdmi_sink:
		self._clear_wpl()
		if vm.secure_set_resolution(new_mode):
			self.last_video_resolution = new_mode
		else:
			log.warn('auto_framerate failed. %s not supported', new_mode)
except:
	PRINT_EXCEPTION()
else:
	pass
]:
	i: 331&337&353(t)
	o: 496(JA)

nname: 331&337&353
n 331&337&353(new_mode and self.status != 'playing' and self.last_video_resolution != new_mode)[]:
	i: 39(JA), 282(), 263(t), 0(f), 62(except)
	o: 369(t), 496(f)

nname: 282
n 282(None)[new_mode = list(config.user_config['connections']['resolution'])
new_mode[-1] = framerate
new_mode = tuple(new_mode)
]:
	i: 280(AE), 79(JA)
	o: 331&337&353()

nname: 79
n 79(None)[from peewee.ranges import f_list
fuzzy_list = f_list([25.0], range=2)
vlist = self.wpl.vlist()
if vlist:
	framerate = vlist[0]['framerate']
	log.debug('auto_framerate: wpl.framerate: %s', framerate)
	if 10 < framerate:
		pass
	else:
		framerate
	if 10 < framerate:
		if framerate in fuzzy_list:
			pass
		framerate = 59
	else:
		raise IndexError
else:
	framerate = config.user_config['connections']['resolution'][3]
]:
	i: 62(try)
	o: 282(JA)

nname: 62
n 62(None)[log.debug('wpl.is_cinema() returned False')
]:
	i: 23(f)
	o: 79(try), 331&337&353(except)

nname: 39
n 39(None)[new_mode = (1920, 1080, 0, 24)
log.debug('wpl.is_cinema() returned True: new_mode = (1920, 1080, 0, 24)')
]:
	i: 23(t)
	o: 331&337&353(JA)

nname: 23
n 23(self.wpl.is_cinema())[]:
	i: 0(t)
	o: 39(t), 62(f)

nname: 0
n 0(config.user_config['connections']['auto_frame_rate'])[new_mode = None
]:
	i: 
	o: 23(t), 331&337&353(f)

nname: 496
n 496(None)[return None
]:
	i: 492(), 331&337&353(f)
	o: 

nname: 331&337&353
n 331&337&353(None)[except:
	if new_mode and self.status != 'playing' and self.last_video_resolution != new_mode:
		try:
			log.debug('auto_framerate: change mode %s  ->  %s', self.last_video_resolution, new_mode)
			vm = pygui_globs['videomodes']
			if vm.hdmi_sink:
				self._clear_wpl()
				if vm.secure_set_resolution(new_mode):
					self.last_video_resolution = new_mode
				else:
					log.warn('auto_framerate failed. %s not supported', new_mode)
		except:
			PRINT_EXCEPTION()
		else:
			pass
]:
	i: 39(JA), 282(), 263(t), 0(f), 62(except)
	o: 496(JA)

nname: 282
n 282(None)[new_mode = list(config.user_config['connections']['resolution'])
new_mode[-1] = framerate
new_mode = tuple(new_mode)
]:
	i: 280(AE), 79(JA)
	o: 331&337&353()

nname: 79
n 79(None)[from peewee.ranges import f_list
fuzzy_list = f_list([25.0], range=2)
vlist = self.wpl.vlist()
if vlist:
	framerate = vlist[0]['framerate']
	log.debug('auto_framerate: wpl.framerate: %s', framerate)
	if 10 < framerate:
		pass
	else:
		framerate
	if 10 < framerate:
		if framerate in fuzzy_list:
			pass
		framerate = 59
	else:
		raise IndexError
else:
	framerate = config.user_config['connections']['resolution'][3]
]:
	i: 62(try)
	o: 282(JA)

nname: 62
n 62(None)[log.debug('wpl.is_cinema() returned False')
]:
	i: 23(f)
	o: 79(try), 331&337&353(except)

nname: 39
n 39(None)[new_mode = (1920, 1080, 0, 24)
log.debug('wpl.is_cinema() returned True: new_mode = (1920, 1080, 0, 24)')
]:
	i: 23(t)
	o: 331&337&353(JA)

nname: 23
n 23(self.wpl.is_cinema())[]:
	i: 0(t)
	o: 39(t), 62(f)

nname: 0
n 0(config.user_config['connections']['auto_frame_rate'])[new_mode = None
]:
	i: 
	o: 23(t), 331&337&353(f)

self.nodes: {0: <unpyclib.structure.node instance at 0xb764f0ec>, '331&337&353': <unpyclib.structure.node instance at 0xb7651eec>, 23: <unpyclib.structure.node instance at 0xb764f10c>, 280: <unpyclib.structure.node instance at 0xb764f28c>, 282: <unpyclib.structure.node instance at 0xb764f82c>, 39: <unpyclib.structure.node instance at 0xb764f6ac>, 62: <unpyclib.structure.node instance at 0xb764f58c>, 79: <unpyclib.structure.node instance at 0xb76513cc>, 491: <unpyclib.structure.node instance at 0xb764f6cc>, 492: <unpyclib.structure.node instance at 0xb764fa6c>, 496: <unpyclib.structure.node instance at 0xb764fe2c>}
nname: 378
n 378(None)[return None
]:
	i: 331(), 373()
	o: 

nname: 373
n 373(None)[return False
]:
	i: 325(f)
	o: 378()

nname: 331
n 331(None)[Task(BigMessageWindow(message).show, timeout=5).start(0.10000000000000001)
return True
]:
	i: 325(t)
	o: 378()

nname: 325
n 325(message)[]:
	i: 86(), 109(), 138(), 167(), 196(), 219(), 275(), 308(), 324()
	o: 331(t), 373(f)

nname: 324
n 324(None)[]:
	i: 281&291(f)
	o: 325()

nname: 308
n 308(None)[message = _('Cannot Play this media (no video codec supported).')
]:
	i: 281&291(t)
	o: 325()

nname: 281&291
n 281&291(self._video_stream and not self.wpl.vlist())[]:
	i: 235(t)
	o: 308(t), 324(f)

nname: 275
n 275(None)[message = ''
]:
	i: 258(), 271()
	o: 325()

nname: 271
n 271(None)[]:
	i: 251(t)
	o: 275()

nname: 258
n 258(None)[]:
	i: 251(f)
	o: 275()

nname: 251
n 251(ignore)[]:
	i: 235(f)
	o: 258(f), 271(t)

nname: 235
n 235(self.wpl.alist())[]:
	i: 212(f)
	o: 251(f), 281&291(t)

nname: 219
n 219(None)[message = _('Cannot play this media (bad container).')
]:
	i: 212(t)
	o: 325()

nname: 212
n 212(ex)[]:
	i: 183(f)
	o: 219(t), 235(f)

nname: 196
n 196(None)[message = _('Cannot Play this media (no audio codec supported).')
]:
	i: 183(t)
	o: 325()

nname: 183
n 183(ex == 'decode: no recognized stream')[]:
	i: 154(f)
	o: 196(t), 212(f)

nname: 167
n 167(None)[message = _('Cannot play this media (bad container).')
]:
	i: 154(t)
	o: 325()

nname: 154
n 154(ex == 'media: unsupported container')[]:
	i: 125(f)
	o: 167(t), 183(f)

nname: 138
n 138(None)[message = _('The server is not responding. Please try to access the content later.')
]:
	i: 125(t)
	o: 325()

nname: 125
n 125(ex == 'media: timeout')[]:
	i: 96(f)
	o: 138(t), 154(f)

nname: 109
n 109(None)[message = _('The content you requested was not found.')
]:
	i: 96(t)
	o: 325()

nname: 96
n 96(ex == "media: couldn't open input file")[]:
	i: 59(f)
	o: 109(t), 125(f)

nname: 86
n 86(None)[message = force
]:
	i: 59(t)
	o: 325()

nname: 59
n 59(force)[ignore = True
message = None
ex = self.wpl.exception
]:
	i: 48(), 55()
	o: 86(t), 96(f)

nname: 55
n 55(None)[]:
	i: 0&32(f)
	o: 59()

nname: 48
n 48(None)[]:
	i: 0&32(t)
	o: 59()

nname: 0&32
n 0&32(uri.startswith('http://') or uri.startswith('dlna+http://'))[uri = self['main_list'].selected['uri']
]:
	i: 
	o: 48(t), 55(f)

nname: 325
n 325(None)[if message:
	Task(BigMessageWindow(message).show, timeout=5).start(0.10000000000000001)
	return True
else:
	return False
return None
]:
	i: 86(), 109(), 138(), 167(), 196(), 219(), 251(), 281&291()
	o: 

nname: 281&291
n 281&291(None)[if self._video_stream and not self.wpl.vlist():
	message = _('Cannot Play this media (no video codec supported).')
]:
	i: 235(t)
	o: 325()

nname: 251
n 251(None)[if not ignore:
	pass
message = ''
]:
	i: 235(f)
	o: 325()

nname: 235
n 235(self.wpl.alist())[]:
	i: 212(f)
	o: 251(f), 281&291(t)

nname: 219
n 219(None)[message = _('Cannot play this media (bad container).')
]:
	i: 212(t)
	o: 325()

nname: 212
n 212(ex)[]:
	i: 183(f)
	o: 219(t), 235(f)

nname: 196
n 196(None)[message = _('Cannot Play this media (no audio codec supported).')
]:
	i: 183(t)
	o: 325()

nname: 183
n 183(ex == 'decode: no recognized stream')[]:
	i: 154(f)
	o: 196(t), 212(f)

nname: 167
n 167(None)[message = _('Cannot play this media (bad container).')
]:
	i: 154(t)
	o: 325()

nname: 154
n 154(ex == 'media: unsupported container')[]:
	i: 125(f)
	o: 167(t), 183(f)

nname: 138
n 138(None)[message = _('The server is not responding. Please try to access the content later.')
]:
	i: 125(t)
	o: 325()

nname: 125
n 125(ex == 'media: timeout')[]:
	i: 96(f)
	o: 138(t), 154(f)

nname: 109
n 109(None)[message = _('The content you requested was not found.')
]:
	i: 96(t)
	o: 325()

nname: 96
n 96(ex == "media: couldn't open input file")[]:
	i: 0&32(f)
	o: 109(t), 125(f)

nname: 86
n 86(None)[message = force
]:
	i: 0&32(t)
	o: 325()

nname: 0&32
n 0&32(force)[uri = self['main_list'].selected['uri']
if uri.startswith('http://') or uri.startswith('dlna+http://'):
	pass
ignore = True
message = None
ex = self.wpl.exception
]:
	i: 
	o: 86(t), 96(f)

nname: 0&32
n 0&32(None)[uri = self['main_list'].selected['uri']
if uri.startswith('http://') or uri.startswith('dlna+http://'):
	pass
ignore = True
message = None
ex = self.wpl.exception
if force:
	message = force
else:
	if ex == "media: couldn't open input file":
		message = _('The content you requested was not found.')
	else:
		if ex == 'media: timeout':
			message = _('The server is not responding. Please try to access the content later.')
		else:
			if ex == 'media: unsupported container':
				message = _('Cannot play this media (bad container).')
			else:
				if ex == 'decode: no recognized stream':
					message = _('Cannot Play this media (no audio codec supported).')
				else:
					if ex:
						message = _('Cannot play this media (bad container).')
					else:
						if not self.wpl.alist():
							if not ignore:
								pass
							message = ''
						else:
							if self._video_stream and not self.wpl.vlist():
								message = _('Cannot Play this media (no video codec supported).')
if message:
	Task(BigMessageWindow(message).show, timeout=5).start(0.10000000000000001)
	return True
else:
	return False
return None
]:
	i: 
	o: 

self.nodes: {'0&32': <unpyclib.structure.node instance at 0xb764ff6c>}
nname: 331
n 331(None)[self.wpl.watch_property('status', None)
return None
]:
	i: 278(JA), 326(), 330()
	o: 

nname: 330
n 330(None)[]:
	i: 0&123(f)
	o: 331()

nname: 326
n 326(None)[]:
	i: 232(f)
	o: 331()

nname: 278
n 278(None)[vm.secure_set_resolution(config.user_config['connections']['resolution'])
self.last_video_resolution = config.user_config['connections']['resolution']
]:
	i: 232(t)
	o: 331(JA)

nname: 232
n 232(vm.hdmi_sink)[log.debug('auto_framerate: setting back previous mode: %s', config.user_config['connections']['resolution'])
vm = pygui_globs['videomodes']
]:
	i: 150(AL), 230()
	o: 278(t), 326(f)

nname: 230
n 230(None)[]:
	i: 179&197(f), 216()
	o: 232()

nname: 216
n 216(None)[sleep(0.10000000000000001)
]:
	i: 179&197(t)
	o: 230()

nname: 179&197
n 179&197(self.wpl.status == 'playing' and retries.next() < 100)[]:
	i: 150(loop)
	o: 216(t), 230(f)

nname: 150
n 150(None)[from itertools import count
retries = count()
]:
	i: 0&123(t)
	o: 179&197(loop), 232(AL)

nname: 0&123
n 0&123(self._video_stream and self.last_video_resolution != config.user_config['connections']['resolution'])[self.repeat_mode = False
self.random_mode = False
self.wpl.watch_property('uri', None)
self.wpl.watch_property('speed', None)
log.debug('calling stop & close')
self.wpl.stop()
self.wpl.close()
self._wait_for_status('idle', timeout=30)
]:
	i: 
	o: 150(t), 330(f)

nname: 331
n 331(None)[self.wpl.watch_property('status', None)
return None
]:
	i: 232(JA), 0&123(f)
	o: 

nname: 232
n 232(None)[log.debug('auto_framerate: setting back previous mode: %s', config.user_config['connections']['resolution'])
vm = pygui_globs['videomodes']
if vm.hdmi_sink:
	vm.secure_set_resolution(config.user_config['connections']['resolution'])
	self.last_video_resolution = config.user_config['connections']['resolution']
]:
	i: 216()
	o: 331(JA)

nname: 216
n 216(None)[	sleep(0.10000000000000001)
]:
	i: 150(t)
	o: 232()

nname: 150
n 150(self.wpl.status == 'playing' and retries.next() < 100)[from itertools import count
retries = count()
while self.wpl.status == 'playing' and retries.next() < 100:
]:
	i: 0&123(t)
	o: 216(t)

nname: 0&123
n 0&123(self._video_stream and self.last_video_resolution != config.user_config['connections']['resolution'])[self.repeat_mode = False
self.random_mode = False
self.wpl.watch_property('uri', None)
self.wpl.watch_property('speed', None)
log.debug('calling stop & close')
self.wpl.stop()
self.wpl.close()
self._wait_for_status('idle', timeout=30)
]:
	i: 
	o: 150(t), 331(f)

nname: 331
n 331(None)[self.wpl.watch_property('status', None)
return None
]:
	i: 232(JA), 0&123(f)
	o: 

nname: 232
n 232(None)[log.debug('auto_framerate: setting back previous mode: %s', config.user_config['connections']['resolution'])
vm = pygui_globs['videomodes']
if vm.hdmi_sink:
	vm.secure_set_resolution(config.user_config['connections']['resolution'])
	self.last_video_resolution = config.user_config['connections']['resolution']
]:
	i: 150()
	o: 331(JA)

nname: 150
n 150(None)[from itertools import count
retries = count()
while self.wpl.status == 'playing' and retries.next() < 100:
	sleep(0.10000000000000001)
]:
	i: 0&123(t)
	o: 232()

nname: 0&123
n 0&123(self._video_stream and self.last_video_resolution != config.user_config['connections']['resolution'])[self.repeat_mode = False
self.random_mode = False
self.wpl.watch_property('uri', None)
self.wpl.watch_property('speed', None)
log.debug('calling stop & close')
self.wpl.stop()
self.wpl.close()
self._wait_for_status('idle', timeout=30)
]:
	i: 
	o: 150(t), 331(f)

nname: 331
n 331(None)[self.wpl.watch_property('status', None)
return None
]:
	i: 150(JA), 0&123(f)
	o: 

nname: 150
n 150(None)[from itertools import count
retries = count()
while self.wpl.status == 'playing' and retries.next() < 100:
	sleep(0.10000000000000001)
log.debug('auto_framerate: setting back previous mode: %s', config.user_config['connections']['resolution'])
vm = pygui_globs['videomodes']
if vm.hdmi_sink:
	vm.secure_set_resolution(config.user_config['connections']['resolution'])
	self.last_video_resolution = config.user_config['connections']['resolution']
]:
	i: 0&123(t)
	o: 331(JA)

nname: 0&123
n 0&123(self._video_stream and self.last_video_resolution != config.user_config['connections']['resolution'])[self.repeat_mode = False
self.random_mode = False
self.wpl.watch_property('uri', None)
self.wpl.watch_property('speed', None)
log.debug('calling stop & close')
self.wpl.stop()
self.wpl.close()
self._wait_for_status('idle', timeout=30)
]:
	i: 
	o: 150(t), 331(f)

nname: 0&123
n 0&123(None)[self.repeat_mode = False
self.random_mode = False
self.wpl.watch_property('uri', None)
self.wpl.watch_property('speed', None)
log.debug('calling stop & close')
self.wpl.stop()
self.wpl.close()
self._wait_for_status('idle', timeout=30)
if self._video_stream and self.last_video_resolution != config.user_config['connections']['resolution']:
	from itertools import count
	retries = count()
	while self.wpl.status == 'playing' and retries.next() < 100:
		sleep(0.10000000000000001)
	log.debug('auto_framerate: setting back previous mode: %s', config.user_config['connections']['resolution'])
	vm = pygui_globs['videomodes']
	if vm.hdmi_sink:
		vm.secure_set_resolution(config.user_config['connections']['resolution'])
		self.last_video_resolution = config.user_config['connections']['resolution']
self.wpl.watch_property('status', None)
return None
]:
	i: 
	o: 

self.nodes: {'0&123': <unpyclib.structure.node instance at 0xb764f82c>}
nname: 74
n 74(None)[]:
	i: 54(), 58(), 73(AE)
	o: 

nname: 58
n 58(None)[self.time_elapsed = 0
]:
	i: 0(except)
	o: 74()

nname: 54
n 54(None)[]:
	i: 40(), 53()
	o: 74()

nname: 53
n 53(None)[]:
	i: 3(f)
	o: 54()

nname: 40
n 40(None)[self.time_elapsed = 0.0
]:
	i: 3(t)
	o: 54()

nname: 3
n 3(self.time_elapsed < 0.0)[self.time_elapsed = self.wpl.rel_pos[self.media]
]:
	i: 0(try)
	o: 40(t), 53(f)

nname: 0
n 0(None)[]:
	i: 
	o: 3(try), 58(except)

nname: 74
n 74(None)[]:
	i: 58(), 0()
	o: 

nname: 58
n 58(None)[except:
	self.time_elapsed = 0
]:
	i: 0()
	o: 74()

nname: 74
n 74(None)[]:
	i: 58(), 0()
	o: 

nname: 0
n 0(None)[try:
	self.time_elapsed = self.wpl.rel_pos[self.media]
	if self.time_elapsed < 0.0:
		self.time_elapsed = 0.0
]:
	i: 
	o: 74(), 58()

self.nodes: {0: <unpyclib.structure.node instance at 0xb763e2cc>, 74: <unpyclib.structure.node instance at 0xb76440cc>, 58: <unpyclib.structure.node instance at 0xb764442c>}
nname: 108
n 108(None)[del _[1]
return [] + (subtitles_list)
]:
	i: 0(AF), 68()
	o: 

nname: 68
n 68(None)[for s in subtitles_list:
]:
	i: 0(for)
	o: 108()

nname: 0
n 0(None)[subtitles_list = self.wpl.slist()
sid = self.wpl.sid
]:
	i: 
	o: 68(for), 108(AF)

self.nodes: {0: <unpyclib.structure.node instance at 0xb7644a0c>, 108: <unpyclib.structure.node instance at 0xb7644b0c>, 68: <unpyclib.structure.node instance at 0xb764466c>}
nname: 0
n 0(None)[self.wpl.sid = sid
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7639cec>}
nname: 88
n 88(None)[del _[1]
return audiostreams_list
]:
	i: 0(AF), 41()
	o: 

nname: 41
n 41(None)[for s in audiostreams_list:
]:
	i: 0(for)
	o: 88()

nname: 0
n 0(None)[audiostreams_list = self.wpl.alist()
aid = self.wpl.aid
]:
	i: 
	o: 41(for), 88(AF)

self.nodes: {0: <unpyclib.structure.node instance at 0xb763492c>, 41: <unpyclib.structure.node instance at 0xb76342ac>, 88: <unpyclib.structure.node instance at 0xb763410c>}
nname: 0
n 0(None)[self.wpl.aid = aid
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7639c4c>}
nname: 0
n 0(None)[return self.wpl.aspect_ratio
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7639cec>}
nname: 0
n 0(None)[log.info('Setting aspect ratio to %s', aspect_ratio)
self.wpl.aspect_ratio = aspect_ratio
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb763e5ec>}
nname: 0
n 0(None)[return self.wpl.display_format
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7639c4c>}
nname: 0
n 0(None)[log.info('Setting display format to %s', display_format)
self.wpl.display_format = display_format
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb763ee8c>}
nname: 6
n 6(None)[_signals = dict(closed=Event(), idle=Event(), loading=Event(), playing=Event(), info=Event())
_audio_stream = False
_video_stream = False
def __init__(self):
	self.time_elapsed = 0.0
	self._getitems_keywords.update(dict(video_substream_list=(lambda : self.wpl.vlist()), audio_substream_list=(lambda : self.wpl.alist()), subtitle_substream_list=(lambda : self.wpl.slist()), speed=self._formatted_speed, duration=(lambda : self.wpl.duration)))
	self.wpl = wyplayer_instance()
	self._old_status, self.status = self.wpl.status, self.wpl.status
	self._speed = 1
	self.repeat_mode = False
	self.random_mode = False
	if self._video_stream:
		self.last_video_resolution = config.user_config['connections']['resolution']

stopped = property((lambda self: self.status in ('idle', 'closed')))
def _get_speed(self):
	return self._speed

_set_wpl_speed = tasked(0.5)()
_set_speed = selective_gui_updater('speed')(user_action())
speed = property(_get_speed, _set_speed)
del _get_speed
del _set_speed
def _wait_for_status(self, *sig_list, **sig_list):
	log.debug('Waiting for status %r', sig_list)
	timeout = float(kw.get('timeout', 120))
	for sig in sig_list:
		sig_handler = WPlayer._signals[sig]
		t = time()
		sig_handler.wait(timeout)
		if timeout and time() - t > timeout:
			log.debug("Expected signal '%s' never caught, raise Overflow exception!", sig)
			raise OverflowError
		log.debug("Got expected signal '%s' !", sig)

def update_media_info(self):
	duration = self.wpl.duration / 1000.0
	self.time_elapsed = 0.0
	self.total_time = duration
	if self.repeat_mode == 'track':
		self.repeat_mode = False

speed_change_callback = selective_gui_updater('speed')()
def status_change_callback(self, status):
	log.debug('Status change: %s', status)
	for e_name, e_sig in self._signals.iteritems():
		if e_name == status:
			e_sig.set()
			continue
		e_sig.clear()
	self.old_status = self.status
	self.status = status
	self._status_change_callback(status)

def _status_change_callback(self, status):
	if status == 'playing':
		self.update_media_info()

def _get_status(self):
	speed = self.speed
	if self.status == 'playing':
		if speed == 0:
			return 'pause'
		if speed == 1:
			return 'play'
		if -1 <= speed:
			pass
		else:
			speed
		if -1 <= speed:
			return 'slow_motion_rewind'
		if 0 < speed:
			pass
		else:
			speed
		if 0 < speed:
			return 'slow_motion_forward'
		if speed > 1:
			return 'fast_forward'
		if speed < -1:
			return 'fast_rewind'
	return 'stop'

def _get_playmode(self):
	if self.repeat_mode:
		if self.random_mode:
			if self.repeat_mode == 'all':
				pass
			return 'loop_track_random'
		else:
			if self.repeat_mode == 'all':
				pass
			return 'loop_track'
	else:
		if self.random_mode:
			return 'random'
		else:
			return 'none'

def _formatted_speed(self):
	s = self.speed
	if 0 < s:
		pass
	else:
		s
	if 0 < s:
		return '%.1fx' % s
	if s in (0, 1):
		return ''
	return '%dx' % s

def play(self, item, show_loading=False, offset=0, default_audio=None, default_video=None, default_sub=None):
	if show_loading:
		win = MessageWindow('Loading...')
		win.show()
	self.wpl.watch_property('status', self.status_change_callback)
	self.wpl.watch_property('speed', self.speed_change_callback)
	try:
		item.media_update()
	except AttributeError:
		log.warning('item %s is not updatable', item)
	options = dict()
	uri_options = dict()
	for k, v in item.wpl_options.iteritems():
		if k in ('data', 'osd', 'outwin', 'adrv', 'vdrv'):
			options[k] = v
			continue
		uri_options[k] = v
	self.old_status, self.status = self.wpl.status, self.wpl.status
	log.info('STATUS: %s', self.status)
	if self.status == 'closed':
		log.debug('STATUS IS CLOSED, opening...')
		options['audio'] = self._audio_stream
		options['video'] = self._video_stream
		options['subtitles'] = self._sub_stream
		self.wpl.open(**options)
		self.aspect_ratio = player_aspect_ratio_dict[config.user_config['video']['aspect_ratio']]
		self.display_format = config.user_config['video']['display_format']
	else:
		if self.status != 'idle':
			log.debug('STATUS IS NOT IDLE , stopping...')
			self._signals['playing'].clear()
			self.wpl.stop()
	if self._sub_stream:
		subs = item['subtitles']
		if subs:
			sub_path = subs[0]['uri'].split('//', 1)[1]
			uri_options['subfile'] = sub_path
			if not default_sub:
				pass
			uri_options['sublang'] = default_sub
	dlna = item['dlnaProfile']
	if dlna:
		uri_options['dlna_profile'] = dlna
		uri_options['mime_type'] = item['mimeType']
	self.wpl.spdif_surround = config.user_config['connections']['spdif_surround']
	log.debug('LOAD URI: %s (%s)', item['uri'], uri_options)
	self.wpl.load_uri(item['uri'], uri_options)
	self._wait_for_status('loading', timeout=3)
	self._wait_for_status('idle', timeout=20)
	preferred_language = config.user_config['video']['language']
	preferred_len = len(preferred_language)
	log.info('preferred: %s', preferred_language)

def _clear_wpl(self):
	log.debug('calling wpl.close() / wpl.open() ...')
	options = dict()
	options['audio'] = self._audio_stream
	options['video'] = self._video_stream
	options['subtitles'] = self._sub_stream
	self.wpl.close()
	self.wpl.open(**options)

def _set_framerate(self):
	new_mode = None

def _check_exception(self, force=False):
	uri = self['main_list'].selected['uri']
	if uri.startswith('http://') or uri.startswith('dlna+http://'):
		pass
	ignore = True
	message = None
	ex = self.wpl.exception
	if force:
		message = force
	else:
		if ex == "media: couldn't open input file":
			message = _('The content you requested was not found.')
		else:
			if ex == 'media: timeout':
				message = _('The server is not responding. Please try to access the content later.')
			else:
				if ex == 'media: unsupported container':
					message = _('Cannot play this media (bad container).')
				else:
					if ex == 'decode: no recognized stream':
						message = _('Cannot Play this media (no audio codec supported).')
					else:
						if ex:
							message = _('Cannot play this media (bad container).')
						else:
							if not self.wpl.alist():
								if not ignore:
									pass
								message = ''
							else:
								if self._video_stream and not self.wpl.vlist():
									message = _('Cannot Play this media (no video codec supported).')
	if message:
		Task(BigMessageWindow(message).show, timeout=5).start(0.10000000000000001)
		return True
	else:
		return False
	return None

action_seek = user_action()
def stop(self):
	self.repeat_mode = False
	self.random_mode = False
	self.wpl.watch_property('uri', None)
	self.wpl.watch_property('speed', None)
	log.debug('calling stop & close')
	self.wpl.stop()
	self.wpl.close()
	self._wait_for_status('idle', timeout=30)
	if self._video_stream and self.last_video_resolution != config.user_config['connections']['resolution']:
		from itertools import count
		retries = count()
		while self.wpl.status == 'playing' and retries.next() < 100:
			sleep(0.10000000000000001)
		log.debug('auto_framerate: setting back previous mode: %s', config.user_config['connections']['resolution'])
		vm = pygui_globs['videomodes']
		if vm.hdmi_sink:
			vm.secure_set_resolution(config.user_config['connections']['resolution'])
			self.last_video_resolution = config.user_config['connections']['resolution']
	self.wpl.watch_property('status', None)
	return None

def tick_callback(self):
	try:
		self.time_elapsed = self.wpl.rel_pos[self.media]
		if self.time_elapsed < 0.0:
			self.time_elapsed = 0.0

def get_subtitles(self):
	subtitles_list = self.wpl.slist()
	sid = self.wpl.sid

def set_subtitle(self, sid):
	self.wpl.sid = sid

def get_audio_substreams(self):
	audiostreams_list = self.wpl.alist()
	aid = self.wpl.aid

def set_audio_substream(self, aid):
	self.wpl.aid = aid

def _get_aspect_ratio(self):
	return self.wpl.aspect_ratio

def _set_aspect_ratio(self, aspect_ratio):
	log.info('Setting aspect ratio to %s', aspect_ratio)
	self.wpl.aspect_ratio = aspect_ratio

aspect_ratio = property(_get_aspect_ratio, _set_aspect_ratio, doc="The player's aspect ratio (4_3 or 16_9)")
def _get_display_format(self):
	return self.wpl.display_format

def _set_display_format(self, display_format):
	log.info('Setting display format to %s', display_format)
	self.wpl.display_format = display_format

display_format = property(_get_display_format, _set_display_format, doc="The player's display format (for use when the stream's aspect ratio differs from that of the display)")
]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb763412c>}
nname: 0
n 0(None)[from __future__ import absolute_import
__all__ = ['Player', 'WPlayer', 'wyplayer_instance']
from threading import Event
from time import gmtime, sleep, time
from peewee.debug import GET_LOGGER, PRINT_EXCEPTION
from peewee.messages import send as louie_send
from peewee.notifier import Task, sched, tasked
import pygui.config as config
from pygui.facilities.codemapping import player_aspect_ratio_dict
from pygui.shared import pygui_globs
from pygui.menu import selective_gui_updater
from pygui.menu.menu import Menu
from pygui.window import BigMessageWindow, MessageWindow
log = GET_LOGGER(__name__)
from peewee.misc_utils import MetaSingleton
class _WyPlayerWrap(object):
	__metaclass__ = MetaSingleton
	def __init__(self):
		if not config.no_PLAYERS:
			from wyplayer import WyPlayer
		if not config.no_PLAYERS:
			pass
		self.player = config.no_PLAYERS



def wyplayer_instance():
	return _WyPlayerWrap().player

def _seconds_to_hhmmss(time_val):
	return '%d:%02d:%02d' % tuple(gmtime(time_val)[3:6])

def _seconds_to_hhmm(time_val):
	return '%d:%02d' % tuple(gmtime(time_val)[3:5])

def _guarded_seconds_to_hhmmss(time_val):
	if time_val <= 0:
		pass
	return '%d:%02d:%02d' % tuple(gmtime(time_val)[3:6])

class TimerActivator(object):
	__doc__ = "OO and slightly more flexible replacement for user_action and friends.\n    Doesn't replace them all yet, but soon will. Trust me.\n\n    XXX user_action = TimerActivator(signals=('on_user_event', 'on_user_idle'), _check=True)\n    "
	def __init__(self, signals=('on_start', 'on_stop'), delay=2, _check=False):
		self.signals = signals
		self._timer = Task(self.handler)
		self._delay = delay
		self._sender = None
		self._check = _check
		return None

	def handler(self):
		if self._check and not self._sender.could_remove_banner():
			pass
		self._timer.stop()
		louie_send(self.signals[1], sender=self._sender)
		self._sender.tasks['tick'].stop()

	def __call__(self, func):
		def _exec(menu, *args, **args):
			ret = None
			try:
				ret = func(menu, *args, **kw)
			except Exception, e:
				log.warn('%s', e)
			self._sender = menu
			if self._timer.running:
				self._timer.start(loop=True, consider_idle=True)
			else:
				self._timer.start(self._delay, loop=True, consider_idle=True)
				self._sender._start_timers()
				louie_send(self.signals[0], sender=self._sender)
			return ret

		return _exec

	def force_ending(self, mute=False):
		if self._timer.running:
			self._timer.stop()
			if not mute:
				louie_send(self.signals[1], sender=self._sender)
				self._sender.tasks['tick'].stop()



user_action = TimerActivator(signals=('on_user_event', 'on_user_idle'), delay=config.HMI_VIDEO['idle_threshold'], _check=True)
class Player(Menu):
	__doc__ = '\n    Class base for Player application\n\n    A Player is a specialized Menu which can (dis)play media such as Audio,\n    Video or Image,...\n    When we want to play something, a playlist may be passed. So the Player will\n    sequentially play all media present in the playlist.\n    '
	toggleable = True
	_timers_interval = 1
	_idle_timer = None
	def __init__(self, type_, universe=None):
		self.stack = pygui_globs['menustack']
		self.total_time = 0.0
		self.time_elapsed = 0.0
		Menu.__init__(self, [], type=type_, universe=universe)
		self._getitems_keywords.update(dict(time_elapsed=(lambda : _seconds_to_hhmmss(round(self.time_elapsed))), time_remaining=(lambda : _guarded_seconds_to_hhmmss(round(self.total_time) - round(self.time_elapsed))), time_total=(lambda : _guarded_seconds_to_hhmmss(round(self.total_time))), progressbar=self._get_progressbar, status_icon=self._get_status_icon, playmode_icon=self._get_playmode_icon, subtitles=(lambda : '')))
		self.tasks['tick'] = Task(self.tick_callback)
		self.tasks['screensaver_block'] = Task((lambda : None))

	def could_remove_banner(self):
		return self.speed in (0, 1)

	def _get_progressbar(self):
		if self.total_time - self.time_elapsed >= 1.0:
			return dict(pos=round(self.time_elapsed), max=round(self.total_time))
		else:
			return dict(pos=round(self.total_time), max=round(self.total_time))

	def tick_callback(self):
		pass

	def _start_timers(self):
		self.tasks['tick'].start(self._timers_interval, loop=True, init_delay=0)
		self.tasks['screensaver_block'].start(delay=config.user_config['power']['screensaver_threshold'] - 1, loop=True)

	def _get_status_icon(self):
		try:
			status = self._get_status()
		except AttributeError:
			status = None
		if status:
			return status + '.png'
		return None

	def _get_playmode_icon(self):
		status = self._get_playmode()
		if status:
			return status + '.png'

	def _playlist_from_item(self, item):
		try:
			new_playlist = item.get_playlist()
			if not isinstance(new_playlist, (list, tuple)):
				new_playlist = new_playlist.playlist

	def select(self, item_or_pos, list_name='main_list', force_pos=False):
		if self.get_item_list(list_name).selected == item_or_pos:
			return False
		ret = Menu.select(self, item_or_pos, list_name=list_name, force_pos=force_pos)
		if list_name != 'main_list':
			pass
		if ret:
			self.time_elapsed = 0.0
			self.total_time = 0.0
		if self.stack.is_on_top(self):
			self.stack.back_to_menu(self)
		louie_send('main_list', sender=self, action='reset', value=self['main_list'], position=self['main_list'].selected_pos)
		return ret

	def clear(self):
		if self.status is None:
			log.debug('Clearing player...')
			for k in self.item_lists_dict:
				self.item_lists_dict[k].set_items([])
		return None

	def play(self, item=None, playlist=None, hide_previous_menu=True):
		self.status = True
		stack = self.stack
		if not playlist:
			pass
		playlist = playlist
		if not item:
			pass
		item = item
		self.universe = item.menu.universe
		if playlist != self.choices:
			self.set_items(playlist, 'main_list', item)
		if self not in stack:
			stack.close_player()
			self.show(hide_previous_menu=hide_previous_menu)
			self._start_timers()
		else:
			if hide_previous_menu:
				stack.bubble_raise(self)

	def stop(self):
		self.status = None
		self.total_time = 0.0
		self.time_elapsed = 0.0
		if self._idle_timer is not None:
			self._idle_timer.stop()
		try:
			self.stack.get_navigator().force_preview = True
		except:
			PRINT_EXCEPTION()
		Menu.stop(self)
		return None

	def action_info(self):
		if self.selected:
			from pygui.menu.menu.info import item_info_menu_dict
			try:
				info_menu = item_info_menu_dict[self.selected.type](self.selected)
			except KeyError:
				log.warn('No InfoMeun defined for type %s', self.selected.type)
			else:
				info_menu.show()

	_play_next = tasked(1)()


class WPlayer(object):
	_signals = dict(closed=Event(), idle=Event(), loading=Event(), playing=Event(), info=Event())
	_audio_stream = False
	_video_stream = False
	def __init__(self):
		self.time_elapsed = 0.0
		self._getitems_keywords.update(dict(video_substream_list=(lambda : self.wpl.vlist()), audio_substream_list=(lambda : self.wpl.alist()), subtitle_substream_list=(lambda : self.wpl.slist()), speed=self._formatted_speed, duration=(lambda : self.wpl.duration)))
		self.wpl = wyplayer_instance()
		self._old_status, self.status = self.wpl.status, self.wpl.status
		self._speed = 1
		self.repeat_mode = False
		self.random_mode = False
		if self._video_stream:
			self.last_video_resolution = config.user_config['connections']['resolution']

	stopped = property((lambda self: self.status in ('idle', 'closed')))
	def _get_speed(self):
		return self._speed

	_set_wpl_speed = tasked(0.5)()
	_set_speed = selective_gui_updater('speed')(user_action())
	speed = property(_get_speed, _set_speed)
	del _get_speed
	del _set_speed
	def _wait_for_status(self, *sig_list, **sig_list):
		log.debug('Waiting for status %r', sig_list)
		timeout = float(kw.get('timeout', 120))
		for sig in sig_list:
			sig_handler = WPlayer._signals[sig]
			t = time()
			sig_handler.wait(timeout)
			if timeout and time() - t > timeout:
				log.debug("Expected signal '%s' never caught, raise Overflow exception!", sig)
				raise OverflowError
			log.debug("Got expected signal '%s' !", sig)

	def update_media_info(self):
		duration = self.wpl.duration / 1000.0
		self.time_elapsed = 0.0
		self.total_time = duration
		if self.repeat_mode == 'track':
			self.repeat_mode = False

	speed_change_callback = selective_gui_updater('speed')()
	def status_change_callback(self, status):
		log.debug('Status change: %s', status)
		for e_name, e_sig in self._signals.iteritems():
			if e_name == status:
				e_sig.set()
				continue
			e_sig.clear()
		self.old_status = self.status
		self.status = status
		self._status_change_callback(status)

	def _status_change_callback(self, status):
		if status == 'playing':
			self.update_media_info()

	def _get_status(self):
		speed = self.speed
		if self.status == 'playing':
			if speed == 0:
				return 'pause'
			if speed == 1:
				return 'play'
			if -1 <= speed:
				pass
			else:
				speed
			if -1 <= speed:
				return 'slow_motion_rewind'
			if 0 < speed:
				pass
			else:
				speed
			if 0 < speed:
				return 'slow_motion_forward'
			if speed > 1:
				return 'fast_forward'
			if speed < -1:
				return 'fast_rewind'
		return 'stop'

	def _get_playmode(self):
		if self.repeat_mode:
			if self.random_mode:
				if self.repeat_mode == 'all':
					pass
				return 'loop_track_random'
			else:
				if self.repeat_mode == 'all':
					pass
				return 'loop_track'
		else:
			if self.random_mode:
				return 'random'
			else:
				return 'none'

	def _formatted_speed(self):
		s = self.speed
		if 0 < s:
			pass
		else:
			s
		if 0 < s:
			return '%.1fx' % s
		if s in (0, 1):
			return ''
		return '%dx' % s

	def play(self, item, show_loading=False, offset=0, default_audio=None, default_video=None, default_sub=None):
		if show_loading:
			win = MessageWindow('Loading...')
			win.show()
		self.wpl.watch_property('status', self.status_change_callback)
		self.wpl.watch_property('speed', self.speed_change_callback)
		try:
			item.media_update()
		except AttributeError:
			log.warning('item %s is not updatable', item)
		options = dict()
		uri_options = dict()
		for k, v in item.wpl_options.iteritems():
			if k in ('data', 'osd', 'outwin', 'adrv', 'vdrv'):
				options[k] = v
				continue
			uri_options[k] = v
		self.old_status, self.status = self.wpl.status, self.wpl.status
		log.info('STATUS: %s', self.status)
		if self.status == 'closed':
			log.debug('STATUS IS CLOSED, opening...')
			options['audio'] = self._audio_stream
			options['video'] = self._video_stream
			options['subtitles'] = self._sub_stream
			self.wpl.open(**options)
			self.aspect_ratio = player_aspect_ratio_dict[config.user_config['video']['aspect_ratio']]
			self.display_format = config.user_config['video']['display_format']
		else:
			if self.status != 'idle':
				log.debug('STATUS IS NOT IDLE , stopping...')
				self._signals['playing'].clear()
				self.wpl.stop()
		if self._sub_stream:
			subs = item['subtitles']
			if subs:
				sub_path = subs[0]['uri'].split('//', 1)[1]
				uri_options['subfile'] = sub_path
				if not default_sub:
					pass
				uri_options['sublang'] = default_sub
		dlna = item['dlnaProfile']
		if dlna:
			uri_options['dlna_profile'] = dlna
			uri_options['mime_type'] = item['mimeType']
		self.wpl.spdif_surround = config.user_config['connections']['spdif_surround']
		log.debug('LOAD URI: %s (%s)', item['uri'], uri_options)
		self.wpl.load_uri(item['uri'], uri_options)
		self._wait_for_status('loading', timeout=3)
		self._wait_for_status('idle', timeout=20)
		preferred_language = config.user_config['video']['language']
		preferred_len = len(preferred_language)
		log.info('preferred: %s', preferred_language)

	def _clear_wpl(self):
		log.debug('calling wpl.close() / wpl.open() ...')
		options = dict()
		options['audio'] = self._audio_stream
		options['video'] = self._video_stream
		options['subtitles'] = self._sub_stream
		self.wpl.close()
		self.wpl.open(**options)

	def _set_framerate(self):
		new_mode = None

	def _check_exception(self, force=False):
		uri = self['main_list'].selected['uri']
		if uri.startswith('http://') or uri.startswith('dlna+http://'):
			pass
		ignore = True
		message = None
		ex = self.wpl.exception
		if force:
			message = force
		else:
			if ex == "media: couldn't open input file":
				message = _('The content you requested was not found.')
			else:
				if ex == 'media: timeout':
					message = _('The server is not responding. Please try to access the content later.')
				else:
					if ex == 'media: unsupported container':
						message = _('Cannot play this media (bad container).')
					else:
						if ex == 'decode: no recognized stream':
							message = _('Cannot Play this media (no audio codec supported).')
						else:
							if ex:
								message = _('Cannot play this media (bad container).')
							else:
								if not self.wpl.alist():
									if not ignore:
										pass
									message = ''
								else:
									if self._video_stream and not self.wpl.vlist():
										message = _('Cannot Play this media (no video codec supported).')
		if message:
			Task(BigMessageWindow(message).show, timeout=5).start(0.10000000000000001)
			return True
		else:
			return False
		return None

	action_seek = user_action()
	def stop(self):
		self.repeat_mode = False
		self.random_mode = False
		self.wpl.watch_property('uri', None)
		self.wpl.watch_property('speed', None)
		log.debug('calling stop & close')
		self.wpl.stop()
		self.wpl.close()
		self._wait_for_status('idle', timeout=30)
		if self._video_stream and self.last_video_resolution != config.user_config['connections']['resolution']:
			from itertools import count
			retries = count()
			while self.wpl.status == 'playing' and retries.next() < 100:
				sleep(0.10000000000000001)
			log.debug('auto_framerate: setting back previous mode: %s', config.user_config['connections']['resolution'])
			vm = pygui_globs['videomodes']
			if vm.hdmi_sink:
				vm.secure_set_resolution(config.user_config['connections']['resolution'])
				self.last_video_resolution = config.user_config['connections']['resolution']
		self.wpl.watch_property('status', None)
		return None

	def tick_callback(self):
		try:
			self.time_elapsed = self.wpl.rel_pos[self.media]
			if self.time_elapsed < 0.0:
				self.time_elapsed = 0.0

	def get_subtitles(self):
		subtitles_list = self.wpl.slist()
		sid = self.wpl.sid

	def set_subtitle(self, sid):
		self.wpl.sid = sid

	def get_audio_substreams(self):
		audiostreams_list = self.wpl.alist()
		aid = self.wpl.aid

	def set_audio_substream(self, aid):
		self.wpl.aid = aid

	def _get_aspect_ratio(self):
		return self.wpl.aspect_ratio

	def _set_aspect_ratio(self, aspect_ratio):
		log.info('Setting aspect ratio to %s', aspect_ratio)
		self.wpl.aspect_ratio = aspect_ratio

	aspect_ratio = property(_get_aspect_ratio, _set_aspect_ratio, doc="The player's aspect ratio (4_3 or 16_9)")
	def _get_display_format(self):
		return self.wpl.display_format

	def _set_display_format(self, display_format):
		log.info('Setting display format to %s', display_format)
		self.wpl.display_format = display_format

	display_format = property(_get_display_format, _set_display_format, doc="The player's display format (for use when the stream's aspect ratio differs from that of the display)")


]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7626c4c>}
from __future__ import absolute_import
__all__ = ['Player', 'WPlayer', 'wyplayer_instance']
from threading import Event
from time import gmtime, sleep, time
from peewee.debug import GET_LOGGER, PRINT_EXCEPTION
from peewee.messages import send as louie_send
from peewee.notifier import Task, sched, tasked
import pygui.config as config
from pygui.facilities.codemapping import player_aspect_ratio_dict
from pygui.shared import pygui_globs
from pygui.menu import selective_gui_updater
from pygui.menu.menu import Menu
from pygui.window import BigMessageWindow, MessageWindow
log = GET_LOGGER(__name__)
from peewee.misc_utils import MetaSingleton
class _WyPlayerWrap(object):
	__metaclass__ = MetaSingleton
	def __init__(self):
		if not config.no_PLAYERS:
			from wyplayer import WyPlayer
		if not config.no_PLAYERS:
			pass
		self.player = config.no_PLAYERS



def wyplayer_instance():
	return _WyPlayerWrap().player

def _seconds_to_hhmmss(time_val):
	return '%d:%02d:%02d' % tuple(gmtime(time_val)[3:6])

def _seconds_to_hhmm(time_val):
	return '%d:%02d' % tuple(gmtime(time_val)[3:5])

def _guarded_seconds_to_hhmmss(time_val):
	if time_val <= 0:
		pass
	return '%d:%02d:%02d' % tuple(gmtime(time_val)[3:6])

class TimerActivator(object):
	__doc__ = "OO and slightly more flexible replacement for user_action and friends.\n    Doesn't replace them all yet, but soon will. Trust me.\n\n    XXX user_action = TimerActivator(signals=('on_user_event', 'on_user_idle'), _check=True)\n    "
	def __init__(self, signals=('on_start', 'on_stop'), delay=2, _check=False):
		self.signals = signals
		self._timer = Task(self.handler)
		self._delay = delay
		self._sender = None
		self._check = _check
		return None

	def handler(self):
		if self._check and not self._sender.could_remove_banner():
			pass
		self._timer.stop()
		louie_send(self.signals[1], sender=self._sender)
		self._sender.tasks['tick'].stop()

	def __call__(self, func):
		def _exec(menu, *args, **args):
			ret = None
			try:
				ret = func(menu, *args, **kw)
			except Exception, e:
				log.warn('%s', e)
			self._sender = menu
			if self._timer.running:
				self._timer.start(loop=True, consider_idle=True)
			else:
				self._timer.start(self._delay, loop=True, consider_idle=True)
				self._sender._start_timers()
				louie_send(self.signals[0], sender=self._sender)
			return ret

		return _exec

	def force_ending(self, mute=False):
		if self._timer.running:
			self._timer.stop()
			if not mute:
				louie_send(self.signals[1], sender=self._sender)
				self._sender.tasks['tick'].stop()



user_action = TimerActivator(signals=('on_user_event', 'on_user_idle'), delay=config.HMI_VIDEO['idle_threshold'], _check=True)
class Player(Menu):
	__doc__ = '\n    Class base for Player application\n\n    A Player is a specialized Menu which can (dis)play media such as Audio,\n    Video or Image,...\n    When we want to play something, a playlist may be passed. So the Player will\n    sequentially play all media present in the playlist.\n    '
	toggleable = True
	_timers_interval = 1
	_idle_timer = None
	def __init__(self, type_, universe=None):
		self.stack = pygui_globs['menustack']
		self.total_time = 0.0
		self.time_elapsed = 0.0
		Menu.__init__(self, [], type=type_, universe=universe)
		self._getitems_keywords.update(dict(time_elapsed=(lambda : _seconds_to_hhmmss(round(self.time_elapsed))), time_remaining=(lambda : _guarded_seconds_to_hhmmss(round(self.total_time) - round(self.time_elapsed))), time_total=(lambda : _guarded_seconds_to_hhmmss(round(self.total_time))), progressbar=self._get_progressbar, status_icon=self._get_status_icon, playmode_icon=self._get_playmode_icon, subtitles=(lambda : '')))
		self.tasks['tick'] = Task(self.tick_callback)
		self.tasks['screensaver_block'] = Task((lambda : None))

	def could_remove_banner(self):
		return self.speed in (0, 1)

	def _get_progressbar(self):
		if self.total_time - self.time_elapsed >= 1.0:
			return dict(pos=round(self.time_elapsed), max=round(self.total_time))
		else:
			return dict(pos=round(self.total_time), max=round(self.total_time))

	def tick_callback(self):
		pass

	def _start_timers(self):
		self.tasks['tick'].start(self._timers_interval, loop=True, init_delay=0)
		self.tasks['screensaver_block'].start(delay=config.user_config['power']['screensaver_threshold'] - 1, loop=True)

	def _get_status_icon(self):
		try:
			status = self._get_status()
		except AttributeError:
			status = None
		if status:
			return status + '.png'
		return None

	def _get_playmode_icon(self):
		status = self._get_playmode()
		if status:
			return status + '.png'

	def _playlist_from_item(self, item):
		try:
			new_playlist = item.get_playlist()
			if not isinstance(new_playlist, (list, tuple)):
				new_playlist = new_playlist.playlist

	def select(self, item_or_pos, list_name='main_list', force_pos=False):
		if self.get_item_list(list_name).selected == item_or_pos:
			return False
		ret = Menu.select(self, item_or_pos, list_name=list_name, force_pos=force_pos)
		if list_name != 'main_list':
			pass
		if ret:
			self.time_elapsed = 0.0
			self.total_time = 0.0
		if self.stack.is_on_top(self):
			self.stack.back_to_menu(self)
		louie_send('main_list', sender=self, action='reset', value=self['main_list'], position=self['main_list'].selected_pos)
		return ret

	def clear(self):
		if self.status is None:
			log.debug('Clearing player...')
			for k in self.item_lists_dict:
				self.item_lists_dict[k].set_items([])
		return None

	def play(self, item=None, playlist=None, hide_previous_menu=True):
		self.status = True
		stack = self.stack
		if not playlist:
			pass
		playlist = playlist
		if not item:
			pass
		item = item
		self.universe = item.menu.universe
		if playlist != self.choices:
			self.set_items(playlist, 'main_list', item)
		if self not in stack:
			stack.close_player()
			self.show(hide_previous_menu=hide_previous_menu)
			self._start_timers()
		else:
			if hide_previous_menu:
				stack.bubble_raise(self)

	def stop(self):
		self.status = None
		self.total_time = 0.0
		self.time_elapsed = 0.0
		if self._idle_timer is not None:
			self._idle_timer.stop()
		try:
			self.stack.get_navigator().force_preview = True
		except:
			PRINT_EXCEPTION()
		Menu.stop(self)
		return None

	def action_info(self):
		if self.selected:
			from pygui.menu.menu.info import item_info_menu_dict
			try:
				info_menu = item_info_menu_dict[self.selected.type](self.selected)
			except KeyError:
				log.warn('No InfoMeun defined for type %s', self.selected.type)
			else:
				info_menu.show()

	_play_next = tasked(1)()


class WPlayer(object):
	_signals = dict(closed=Event(), idle=Event(), loading=Event(), playing=Event(), info=Event())
	_audio_stream = False
	_video_stream = False
	def __init__(self):
		self.time_elapsed = 0.0
		self._getitems_keywords.update(dict(video_substream_list=(lambda : self.wpl.vlist()), audio_substream_list=(lambda : self.wpl.alist()), subtitle_substream_list=(lambda : self.wpl.slist()), speed=self._formatted_speed, duration=(lambda : self.wpl.duration)))
		self.wpl = wyplayer_instance()
		self._old_status, self.status = self.wpl.status, self.wpl.status
		self._speed = 1
		self.repeat_mode = False
		self.random_mode = False
		if self._video_stream:
			self.last_video_resolution = config.user_config['connections']['resolution']

	stopped = property((lambda self: self.status in ('idle', 'closed')))
	def _get_speed(self):
		return self._speed

	_set_wpl_speed = tasked(0.5)()
	_set_speed = selective_gui_updater('speed')(user_action())
	speed = property(_get_speed, _set_speed)
	del _get_speed
	del _set_speed
	def _wait_for_status(self, *sig_list, **sig_list):
		log.debug('Waiting for status %r', sig_list)
		timeout = float(kw.get('timeout', 120))
		for sig in sig_list:
			sig_handler = WPlayer._signals[sig]
			t = time()
			sig_handler.wait(timeout)
			if timeout and time() - t > timeout:
				log.debug("Expected signal '%s' never caught, raise Overflow exception!", sig)
				raise OverflowError
			log.debug("Got expected signal '%s' !", sig)

	def update_media_info(self):
		duration = self.wpl.duration / 1000.0
		self.time_elapsed = 0.0
		self.total_time = duration
		if self.repeat_mode == 'track':
			self.repeat_mode = False

	speed_change_callback = selective_gui_updater('speed')()
	def status_change_callback(self, status):
		log.debug('Status change: %s', status)
		for e_name, e_sig in self._signals.iteritems():
			if e_name == status:
				e_sig.set()
				continue
			e_sig.clear()
		self.old_status = self.status
		self.status = status
		self._status_change_callback(status)

	def _status_change_callback(self, status):
		if status == 'playing':
			self.update_media_info()

	def _get_status(self):
		speed = self.speed
		if self.status == 'playing':
			if speed == 0:
				return 'pause'
			if speed == 1:
				return 'play'
			if -1 <= speed:
				pass
			else:
				speed
			if -1 <= speed:
				return 'slow_motion_rewind'
			if 0 < speed:
				pass
			else:
				speed
			if 0 < speed:
				return 'slow_motion_forward'
			if speed > 1:
				return 'fast_forward'
			if speed < -1:
				return 'fast_rewind'
		return 'stop'

	def _get_playmode(self):
		if self.repeat_mode:
			if self.random_mode:
				if self.repeat_mode == 'all':
					pass
				return 'loop_track_random'
			else:
				if self.repeat_mode == 'all':
					pass
				return 'loop_track'
		else:
			if self.random_mode:
				return 'random'
			else:
				return 'none'

	def _formatted_speed(self):
		s = self.speed
		if 0 < s:
			pass
		else:
			s
		if 0 < s:
			return '%.1fx' % s
		if s in (0, 1):
			return ''
		return '%dx' % s

	def play(self, item, show_loading=False, offset=0, default_audio=None, default_video=None, default_sub=None):
		if show_loading:
			win = MessageWindow('Loading...')
			win.show()
		self.wpl.watch_property('status', self.status_change_callback)
		self.wpl.watch_property('speed', self.speed_change_callback)
		try:
			item.media_update()
		except AttributeError:
			log.warning('item %s is not updatable', item)
		options = dict()
		uri_options = dict()
		for k, v in item.wpl_options.iteritems():
			if k in ('data', 'osd', 'outwin', 'adrv', 'vdrv'):
				options[k] = v
				continue
			uri_options[k] = v
		self.old_status, self.status = self.wpl.status, self.wpl.status
		log.info('STATUS: %s', self.status)
		if self.status == 'closed':
			log.debug('STATUS IS CLOSED, opening...')
			options['audio'] = self._audio_stream
			options['video'] = self._video_stream
			options['subtitles'] = self._sub_stream
			self.wpl.open(**options)
			self.aspect_ratio = player_aspect_ratio_dict[config.user_config['video']['aspect_ratio']]
			self.display_format = config.user_config['video']['display_format']
		else:
			if self.status != 'idle':
				log.debug('STATUS IS NOT IDLE , stopping...')
				self._signals['playing'].clear()
				self.wpl.stop()
		if self._sub_stream:
			subs = item['subtitles']
			if subs:
				sub_path = subs[0]['uri'].split('//', 1)[1]
				uri_options['subfile'] = sub_path
				if not default_sub:
					pass
				uri_options['sublang'] = default_sub
		dlna = item['dlnaProfile']
		if dlna:
			uri_options['dlna_profile'] = dlna
			uri_options['mime_type'] = item['mimeType']
		self.wpl.spdif_surround = config.user_config['connections']['spdif_surround']
		log.debug('LOAD URI: %s (%s)', item['uri'], uri_options)
		self.wpl.load_uri(item['uri'], uri_options)
		self._wait_for_status('loading', timeout=3)
		self._wait_for_status('idle', timeout=20)
		preferred_language = config.user_config['video']['language']
		preferred_len = len(preferred_language)
		log.info('preferred: %s', preferred_language)

	def _clear_wpl(self):
		log.debug('calling wpl.close() / wpl.open() ...')
		options = dict()
		options['audio'] = self._audio_stream
		options['video'] = self._video_stream
		options['subtitles'] = self._sub_stream
		self.wpl.close()
		self.wpl.open(**options)

	def _set_framerate(self):
		new_mode = None

	def _check_exception(self, force=False):
		uri = self['main_list'].selected['uri']
		if uri.startswith('http://') or uri.startswith('dlna+http://'):
			pass
		ignore = True
		message = None
		ex = self.wpl.exception
		if force:
			message = force
		else:
			if ex == "media: couldn't open input file":
				message = _('The content you requested was not found.')
			else:
				if ex == 'media: timeout':
					message = _('The server is not responding. Please try to access the content later.')
				else:
					if ex == 'media: unsupported container':
						message = _('Cannot play this media (bad container).')
					else:
						if ex == 'decode: no recognized stream':
							message = _('Cannot Play this media (no audio codec supported).')
						else:
							if ex:
								message = _('Cannot play this media (bad container).')
							else:
								if not self.wpl.alist():
									if not ignore:
										pass
									message = ''
								else:
									if self._video_stream and not self.wpl.vlist():
										message = _('Cannot Play this media (no video codec supported).')
		if message:
			Task(BigMessageWindow(message).show, timeout=5).start(0.10000000000000001)
			return True
		else:
			return False
		return None

	action_seek = user_action()
	def stop(self):
		self.repeat_mode = False
		self.random_mode = False
		self.wpl.watch_property('uri', None)
		self.wpl.watch_property('speed', None)
		log.debug('calling stop & close')
		self.wpl.stop()
		self.wpl.close()
		self._wait_for_status('idle', timeout=30)
		if self._video_stream and self.last_video_resolution != config.user_config['connections']['resolution']:
			from itertools import count
			retries = count()
			while self.wpl.status == 'playing' and retries.next() < 100:
				sleep(0.10000000000000001)
			log.debug('auto_framerate: setting back previous mode: %s', config.user_config['connections']['resolution'])
			vm = pygui_globs['videomodes']
			if vm.hdmi_sink:
				vm.secure_set_resolution(config.user_config['connections']['resolution'])
				self.last_video_resolution = config.user_config['connections']['resolution']
		self.wpl.watch_property('status', None)
		return None

	def tick_callback(self):
		try:
			self.time_elapsed = self.wpl.rel_pos[self.media]
			if self.time_elapsed < 0.0:
				self.time_elapsed = 0.0

	def get_subtitles(self):
		subtitles_list = self.wpl.slist()
		sid = self.wpl.sid

	def set_subtitle(self, sid):
		self.wpl.sid = sid

	def get_audio_substreams(self):
		audiostreams_list = self.wpl.alist()
		aid = self.wpl.aid

	def set_audio_substream(self, aid):
		self.wpl.aid = aid

	def _get_aspect_ratio(self):
		return self.wpl.aspect_ratio

	def _set_aspect_ratio(self, aspect_ratio):
		log.info('Setting aspect ratio to %s', aspect_ratio)
		self.wpl.aspect_ratio = aspect_ratio

	aspect_ratio = property(_get_aspect_ratio, _set_aspect_ratio, doc="The player's aspect ratio (4_3 or 16_9)")
	def _get_display_format(self):
		return self.wpl.display_format

	def _set_display_format(self, display_format):
		log.info('Setting display format to %s', display_format)
		self.wpl.display_format = display_format

	display_format = property(_get_display_format, _set_display_format, doc="The player's display format (for use when the stream's aspect ratio differs from that of the display)")


