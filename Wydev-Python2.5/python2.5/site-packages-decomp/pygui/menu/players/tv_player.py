# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 49
n 49(None)[return 0 < abs(self._speed)
]:
	i: 35(f), 38()
	o: 

nname: 38
n 38(None)[]:
	i: 35(t)
	o: 49()

nname: 35
n 35(0 < abs(self._speed))[]:
	i: 23(), 33()
	o: 38(t), 49(f)

nname: 33
n 33(None)[abs(self._speed)
]:
	i: 0(f)
	o: 35()

nname: 23
n 23(None)[]:
	i: 0(t)
	o: 35()

nname: 0
n 0(0 < abs(self._speed))[]:
	i: 
	o: 23(t), 33(f)

nname: 49
n 49(None)[return 0 < abs(self._speed)
]:
	i: 0(f)
	o: 

nname: 0
n 0(None)[if 0 < abs(self._speed):
	pass
else:
	abs(self._speed)
if 0 < abs(self._speed):
	pass
]:
	i: 
	o: 49()

nname: 0
n 0(None)[if 0 < abs(self._speed):
	pass
else:
	abs(self._speed)
if 0 < abs(self._speed):
	pass
return 0 < abs(self._speed)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7434fac>}
nname: 0
n 0(None)[return self.player_info['program_maturity_rating']
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb743c12c>}
nname: 0
n 0(None)[return self.player_info['program_freeCaMode']
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb743efec>}
nname: 0
n 0(None)[return self.player_info['program_audioVisuallyImpaired']
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb743efac>}
nname: 0
n 0(None)[return self.player_info['program_audioHardOfHearing']
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb743efec>}
nname: 0
n 0(None)[return self.player_info['program_subtitleHardOfHearing']
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb743ef4c>}
nname: 0
n 0(None)[return self.player_info['program_nrSubtitleTracks']
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb743efac>}
nname: 0
n 0(None)[return self.player_info['program_nrAudioChannels']
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb743efec>}
nname: 0
n 0(None)[return self.player_info['program_videoFormatHD']
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb743ef4c>}
nname: 0
n 0(None)[return self.player_info['program_videoFormat_16_9']
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb743efac>}
nname: 45
n 45(None)[return ''
]:
	i: 27(), 41()
	o: 

nname: 41
n 41(None)[]:
	i: 0(f)
	o: 45()

nname: 27
n 27(None)[]:
	i: 0(t)
	o: 45()

nname: 0
n 0(self._speed not in f_list([0, 1]))[]:
	i: 
	o: 27(t), 41(f)

nname: 0
n 0(None)[if self._speed not in f_list([0, 1]):
	pass
return ''
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb743edcc>}
nname: 0
n 0(None)[return self.player_info['foreign_rec_channel_name']
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb743ef6c>}
nname: 0
n 0(None)[return self.player_info['foreign_rec_status']
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb743efcc>}
nname: 0
n 0(None)[return self.player_info['rec_status']
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb743ed2c>}
nname: 0
n 0(None)[return self.player_info['rec_remaining_time']
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb743ef6c>}
nname: 0
n 0(None)[return self.player_info['rec_elapsed_time']
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb743efcc>}
nname: 0
n 0(None)[return self.player_info['rec_duration']
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb743ed2c>}
nname: 0
n 0(None)[return seconds_to_hhmm(self.real_utc_time)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb743ef4c>}
nname: 0
n 0(None)[return self.player_info['program_elapsed_time']
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb743efcc>}
nname: 0
n 0(None)[return self.player_info['program_remaining_time']
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb743ed2c>}
nname: 0
n 0(None)[return self.player_info['program_duration']
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb743ef4c>}
nname: 0
n 0(None)[return self.player_info['program_stop_time']
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb743efcc>}
nname: 0
n 0(None)[return self.player_info['program_start_time']
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb743ed2c>}
nname: 0
n 0(None)[return self.player_info['program_content']
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb743ef4c>}
nname: 0
n 0(None)[return self.player_info['program_name']
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb743efcc>}
nname: 0
n 0(None)[return self.player_info['channel_type']
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb743ed2c>}
nname: 0
n 0(None)[return self.player_info['channel_name']
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb743ef4c>}
nname: 0
n 0(None)[return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb743e8ec>}
nname: 0
n 0(None)[self._navigator = TvNavigatorMenu(_('EPG Navigator Menu'), player=self, fill_root=False, type='tv_navigator')
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb743e9ec>}
nname: 0
n 0(None)[Player.__init__(self, type, universe='tv')
self.eventhandler = TVEventHandler(self)
self._getitems_keywords.update(dict(clock=(lambda : None), channel_name=(lambda : self.player_info['channel_name']), channel_type=(lambda : self.player_info['channel_type']), program_name=(lambda : self.player_info['program_name']), program_content=(lambda : self.player_info['program_content']), program_start_time=(lambda : self.player_info['program_start_time']), program_stop_time=(lambda : self.player_info['program_stop_time']), program_duration=(lambda : self.player_info['program_duration']), program_remaining_time=(lambda : self.player_info['program_remaining_time']), program_elapsed_time=(lambda : self.player_info['program_elapsed_time']), live_time=(lambda : seconds_to_hhmm(self.real_utc_time)), rec_duration=(lambda : self.player_info['rec_duration']), rec_elapsed_time=(lambda : self.player_info['rec_elapsed_time']), rec_remaining_time=(lambda : self.player_info['rec_remaining_time']), rec_status=(lambda : self.player_info['rec_status']), foreign_rec_status=(lambda : self.player_info['foreign_rec_status']), foreign_rec_channel_name=(lambda : self.player_info['foreign_rec_channel_name']), record_timeshift_programbar=self.get_record_timeshift_programbar, speed=(lambda : ._speed not in f_list([0, 1]):
	pass
return ''), videoformat_16_9_icon=(lambda : self.player_info['program_videoFormat_16_9']), videoformathd_icon=(lambda : self.player_info['program_videoFormatHD']), nraudiochannels_icon=(lambda : self.player_info['program_nrAudioChannels']), nrsubtitletracks_icon=(lambda : self.player_info['program_nrSubtitleTracks']), subtitlehardofhearing_icon=(lambda : self.player_info['program_subtitleHardOfHearing']), audiohardofhearing_icon=(lambda : self.player_info['program_audioHardOfHearing']), audiovisuallyimpaired_icon=(lambda : self.player_info['program_audioVisuallyImpaired']), freecamode_icon=(lambda : self.player_info['program_freeCaMode']), maturity_rating_icon=(lambda : self.player_info['program_maturity_rating'])))
_wyrec = WyRecord()
self.live_controller = _wyrec.getLiveController(player)
self.record_scheduler = _wyrec.scheduler
callbacks = _wyrec.callbacks
callbacks.new_present_epg.register(self.new_present_epg_handler)
callbacks.disk_space_alert.register(self.disk_space_alert_handler)
callbacks.start_playing.register(self.start_playing_event_handler)
self._new_present_epg_task = Task(self._new_present_epg_handler)
self._speed_change_task = Task(self._speed_change_event_handler)
self._scrambled_change_task = Task(self._scrambled_change_event_handler)
self._record = None
self._conflicting_rec = None
self._foreign_rec = None
def _build_navigator():
	self._navigator = TvNavigatorMenu(_('EPG Navigator Menu'), player=self, fill_root=False, type='tv_navigator')

Task(_build_navigator).start(0.01)
self._last_scrambled_status = None
self.code_check = None
self.shielded = False
self.previously_muted = False
self._favorite_list = TVRootItem().get_acl(self)
self._TVPlayer__zap_timer = Task(self.zap)
self._tick_can_refresh = False
self._speed = 1
self.program = None
self.player_info = {}
self._initialize_program_info()
self._initialize_record_info()
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb741f36c>}
nname: 359
n 359(None)[]:
	i: 312(AL), 354(), 358()
	o: 

nname: 358
n 358(None)[]:
	i: 0(f)
	o: 359()

nname: 354
n 354(None)[]:
	i: 315(AF), 322()
	o: 359()

nname: 322
n 322(None)[for key in ('program_duration', 'program_elapsed_time', 'program_remaining_time', 'record_timeshift_programbar', 'rec_duration', 'rec_elapsed_time', 'rec_remaining_time', 'status_icon'):
louie_send(key, sender=self, value=self[key])
]:
	i: 315(for)
	o: 354()

nname: 315
n 315(None)[]:
	i: 312(loop)
	o: 322(for), 354(AF)

nname: 312
n 312(None)[]:
	i: 197(), 287()
	o: 315(loop), 359(AL)

nname: 287
n 287(None)[self.player_info['rec_elapsed_time'], self.player_info['rec_remaining_time'] = '--:--', '--:--'
]:
	i: 188(f)
	o: 312()

nname: 197
n 197(None)[real_utc_time = self.real_utc_time
self.player_info['rec_elapsed_time'] = seconds_to_hhmm_utc(real_utc_time - self._record.start_time)
self.player_info['rec_remaining_time'] = seconds_to_hhmm_utc(max(0, self._record.stop_time + self._record.stop_padding - real_utc_time))
]:
	i: 188(t)
	o: 312()

nname: 188
n 188(self._record)[]:
	i: 47(), 114()
	o: 197(t), 287(f)

nname: 114
n 114(None)[elapsed = utc_time - time_info.min_available_time
timeshift_duration = user_config['tv']['timeshift_length'] * 60
self.player_info['program_remaining_time'] = seconds_to_hhmm_utc(timeshift_duration - elapsed)
self.player_info['program_elapsed_time'] = seconds_to_hhmm_utc(elapsed)
]:
	i: 9(f)
	o: 188()

nname: 47
n 47(None)[self.player_info['program_remaining_time'] = seconds_to_hhmm_utc(max(0, program['scheduledEndTime'] - utc_time))
self.player_info['program_elapsed_time'] = seconds_to_hhmm_utc(utc_time - program['scheduledStartTime'])
]:
	i: 9(t)
	o: 188()

nname: 9
n 9(program)[program, time_info = self.program, self._get_time_info()
utc_time = time_info.current_time
]:
	i: 0(t)
	o: 47(t), 114(f)

nname: 0
n 0(self._tick_can_refresh)[]:
	i: 
	o: 9(t), 358(f)

nname: 359
n 359(None)[]:
	i: 322(), 0(f)
	o: 

nname: 322
n 322(None)[for key in ('program_duration', 'program_elapsed_time', 'program_remaining_time', 'record_timeshift_programbar', 'rec_duration', 'rec_elapsed_time', 'rec_remaining_time', 'status_icon'):
	louie_send(key, sender=self, value=self[key])
]:
	i: 312(for)
	o: 359()

nname: 312
n 312(None)[]:
	i: 9()
	o: 322(for)

nname: 9
n 9(None)[program, time_info = self.program, self._get_time_info()
utc_time = time_info.current_time
if program:
	self.player_info['program_remaining_time'] = seconds_to_hhmm_utc(max(0, program['scheduledEndTime'] - utc_time))
	self.player_info['program_elapsed_time'] = seconds_to_hhmm_utc(utc_time - program['scheduledStartTime'])
else:
	elapsed = utc_time - time_info.min_available_time
	timeshift_duration = user_config['tv']['timeshift_length'] * 60
	self.player_info['program_remaining_time'] = seconds_to_hhmm_utc(timeshift_duration - elapsed)
	self.player_info['program_elapsed_time'] = seconds_to_hhmm_utc(elapsed)
if self._record:
	real_utc_time = self.real_utc_time
	self.player_info['rec_elapsed_time'] = seconds_to_hhmm_utc(real_utc_time - self._record.start_time)
	self.player_info['rec_remaining_time'] = seconds_to_hhmm_utc(max(0, self._record.stop_time + self._record.stop_padding - real_utc_time))
else:
	self.player_info['rec_elapsed_time'], self.player_info['rec_remaining_time'] = '--:--', '--:--'
]:
	i: 0(t)
	o: 312()

nname: 0
n 0(self._tick_can_refresh)[]:
	i: 
	o: 9(t), 359(f)

nname: 359
n 359(None)[]:
	i: 322(), 0(f)
	o: 

nname: 322
n 322(None)[for key in ('program_duration', 'program_elapsed_time', 'program_remaining_time', 'record_timeshift_programbar', 'rec_duration', 'rec_elapsed_time', 'rec_remaining_time', 'status_icon'):
	louie_send(key, sender=self, value=self[key])
]:
	i: 9(for)
	o: 359()

nname: 9
n 9(None)[program, time_info = self.program, self._get_time_info()
utc_time = time_info.current_time
if program:
	self.player_info['program_remaining_time'] = seconds_to_hhmm_utc(max(0, program['scheduledEndTime'] - utc_time))
	self.player_info['program_elapsed_time'] = seconds_to_hhmm_utc(utc_time - program['scheduledStartTime'])
else:
	elapsed = utc_time - time_info.min_available_time
	timeshift_duration = user_config['tv']['timeshift_length'] * 60
	self.player_info['program_remaining_time'] = seconds_to_hhmm_utc(timeshift_duration - elapsed)
	self.player_info['program_elapsed_time'] = seconds_to_hhmm_utc(elapsed)
if self._record:
	real_utc_time = self.real_utc_time
	self.player_info['rec_elapsed_time'] = seconds_to_hhmm_utc(real_utc_time - self._record.start_time)
	self.player_info['rec_remaining_time'] = seconds_to_hhmm_utc(max(0, self._record.stop_time + self._record.stop_padding - real_utc_time))
else:
	self.player_info['rec_elapsed_time'], self.player_info['rec_remaining_time'] = '--:--', '--:--'
]:
	i: 0(t)
	o: 322(for)

nname: 0
n 0(self._tick_can_refresh)[]:
	i: 
	o: 9(t), 359(f)

nname: 359
n 359(None)[]:
	i: 9(), 0(f)
	o: 

nname: 9
n 9(None)[program, time_info = self.program, self._get_time_info()
utc_time = time_info.current_time
if program:
	self.player_info['program_remaining_time'] = seconds_to_hhmm_utc(max(0, program['scheduledEndTime'] - utc_time))
	self.player_info['program_elapsed_time'] = seconds_to_hhmm_utc(utc_time - program['scheduledStartTime'])
else:
	elapsed = utc_time - time_info.min_available_time
	timeshift_duration = user_config['tv']['timeshift_length'] * 60
	self.player_info['program_remaining_time'] = seconds_to_hhmm_utc(timeshift_duration - elapsed)
	self.player_info['program_elapsed_time'] = seconds_to_hhmm_utc(elapsed)
if self._record:
	real_utc_time = self.real_utc_time
	self.player_info['rec_elapsed_time'] = seconds_to_hhmm_utc(real_utc_time - self._record.start_time)
	self.player_info['rec_remaining_time'] = seconds_to_hhmm_utc(max(0, self._record.stop_time + self._record.stop_padding - real_utc_time))
else:
	self.player_info['rec_elapsed_time'], self.player_info['rec_remaining_time'] = '--:--', '--:--'
for key in ('program_duration', 'program_elapsed_time', 'program_remaining_time', 'record_timeshift_programbar', 'rec_duration', 'rec_elapsed_time', 'rec_remaining_time', 'status_icon'):
	louie_send(key, sender=self, value=self[key])
]:
	i: 0(t)
	o: 359()

nname: 0
n 0(self._tick_can_refresh)[]:
	i: 
	o: 9(t), 359(f)

nname: 0
n 0(None)[if self._tick_can_refresh:
	program, time_info = self.program, self._get_time_info()
	utc_time = time_info.current_time
	if program:
		self.player_info['program_remaining_time'] = seconds_to_hhmm_utc(max(0, program['scheduledEndTime'] - utc_time))
		self.player_info['program_elapsed_time'] = seconds_to_hhmm_utc(utc_time - program['scheduledStartTime'])
	else:
		elapsed = utc_time - time_info.min_available_time
		timeshift_duration = user_config['tv']['timeshift_length'] * 60
		self.player_info['program_remaining_time'] = seconds_to_hhmm_utc(timeshift_duration - elapsed)
		self.player_info['program_elapsed_time'] = seconds_to_hhmm_utc(elapsed)
	if self._record:
		real_utc_time = self.real_utc_time
		self.player_info['rec_elapsed_time'] = seconds_to_hhmm_utc(real_utc_time - self._record.start_time)
		self.player_info['rec_remaining_time'] = seconds_to_hhmm_utc(max(0, self._record.stop_time + self._record.stop_padding - real_utc_time))
	else:
		self.player_info['rec_elapsed_time'], self.player_info['rec_remaining_time'] = '--:--', '--:--'
	for key in ('program_duration', 'program_elapsed_time', 'program_remaining_time', 'record_timeshift_programbar', 'rec_duration', 'rec_elapsed_time', 'rec_remaining_time', 'status_icon'):
		louie_send(key, sender=self, value=self[key])
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb743cdcc>}
nname: 202
n 202(None)[]:
	i: 144(), 177(), 200(AE)
	o: 

nname: 200
n 200(None)[]:
	i: 167(f)
	o: 202(AE)

nname: 177
n 177(None)[self.set_items(items, 'main_list')
]:
	i: 167(t)
	o: 202()

nname: 167
n 167(<dummy_ex3> EXC_MATCH ValueError)[]:
	i: 141(except)
	o: 177(t), 200(f)

nname: 144
n 144(None)[self.set_items(items, 'main_list', chan)
]:
	i: 141(try)
	o: 202()

nname: 141
n 141(None)[]:
	i: 63(), 83(), 139(AE)
	o: 144(try), 167(except)

nname: 139
n 139(None)[]:
	i: 67(f)
	o: 141(AE)

nname: 83
n 83(None)[log.info('Unable to browse current favorite -- falling back to ACL.')
self._favorite_list = TVRootItem().get_acl(self)
items = self._favorite_list.browse()
]:
	i: 67(t)
	o: 141()

nname: 67
n 67(<dummy_ex3> EXC_MATCH (BrowseError, ValueError))[]:
	i: 0(except)
	o: 83(t), 139(f)

nname: 63
n 63(None)[]:
	i: 46(), 62()
	o: 141()

nname: 62
n 62(None)[]:
	i: 25(t)
	o: 63()

nname: 46
n 46(None)[raise ValueError('Current favorite is empty')
]:
	i: 25(f)
	o: 63()

nname: 25
n 25(items)[items = self._favorite_list.browse()
]:
	i: 0(try)
	o: 46(f), 62(t)

nname: 0
n 0(None)[Player.on_foreground(self)
chan = self.selected
]:
	i: 
	o: 25(try), 67(except)

nname: 167
n 167(None)[except ValueError:
	self.set_items(items, 'main_list')
]:
	i: 141()
	o: 

nname: 141
n 141(None)[try:
	self.set_items(items, 'main_list', chan)
]:
	i: 67(), 0()
	o: 167()

nname: 67
n 67(None)[except (BrowseError, ValueError):
	log.info('Unable to browse current favorite -- falling back to ACL.')
	self._favorite_list = TVRootItem().get_acl(self)
	items = self._favorite_list.browse()
]:
	i: 0()
	o: 141()

nname: 141
n 141(None)[try:
	self.set_items(items, 'main_list', chan)
]:
	i: 67(), 0()
	o: 167()

nname: 0
n 0(None)[Player.on_foreground(self)
chan = self.selected
try:
	items = self._favorite_list.browse()
	if not items:
		raise ValueError('Current favorite is empty')
]:
	i: 
	o: 141(), 67()

nname: 141
n 141(None)[try:
	self.set_items(items, 'main_list', chan)
except ValueError:
	self.set_items(items, 'main_list')
]:
	i: 67(), 0()
	o: 

nname: 67
n 67(None)[except (BrowseError, ValueError):
	log.info('Unable to browse current favorite -- falling back to ACL.')
	self._favorite_list = TVRootItem().get_acl(self)
	items = self._favorite_list.browse()
]:
	i: 0()
	o: 141()

nname: 141
n 141(None)[try:
	self.set_items(items, 'main_list', chan)
except ValueError:
	self.set_items(items, 'main_list')
]:
	i: 67(), 0()
	o: 

nname: 0
n 0(None)[Player.on_foreground(self)
chan = self.selected
try:
	items = self._favorite_list.browse()
	if not items:
		raise ValueError('Current favorite is empty')
]:
	i: 
	o: 141(), 67()

self.nodes: {0: <unpyclib.structure.node instance at 0xb7497eac>, 67: <unpyclib.structure.node instance at 0xb7497f2c>, 141: <unpyclib.structure.node instance at 0xb7497e2c>}
nname: 112
n 112(None)[del _[1]
return subtitles_list
]:
	i: 0(AF), 72()
	o: 

nname: 72
n 72(None)[for s in subtitles_list:
]:
	i: 0(for)
	o: 112()

nname: 0
n 0(None)[subtitles_list = [{'lang': _('OFF'), 'id': -1}] + self.live_controller.slist()
sid = self.live_controller.sid
]:
	i: 
	o: 72(for), 112(AF)

self.nodes: {0: <unpyclib.structure.node instance at 0xb7497bac>, 72: <unpyclib.structure.node instance at 0xb749718c>, 112: <unpyclib.structure.node instance at 0xb74976ec>}
nname: 0
n 0(None)[self.live_controller.wyplayer.sid = sid
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7434bac>}
nname: 91
n 91(None)[del _[1]
return audiostreams_list
]:
	i: 0(AF), 44()
	o: 

nname: 44
n 44(None)[for s in audiostreams_list:
]:
	i: 0(for)
	o: 91()

nname: 0
n 0(None)[audiostreams_list = self.live_controller.alist()
aid = self.live_controller.wyplayer.aid
]:
	i: 
	o: 44(for), 91(AF)

self.nodes: {0: <unpyclib.structure.node instance at 0xb74978cc>, 91: <unpyclib.structure.node instance at 0xb74972cc>, 44: <unpyclib.structure.node instance at 0xb749708c>}
nname: 0
n 0(None)[self.live_controller.wyplayer.aid = aid
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7434bcc>}
nname: 0
n 0(None)[return self.live_controller.wyplayer.aspect_ratio
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7434cac>}
nname: 0
n 0(None)[log.info('Setting aspect ratio to %s', aspect_ratio)
self.live_controller.wyplayer.aspect_ratio = aspect_ratio
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7434aac>}
nname: 0
n 0(None)[return self.live_controller.wyplayer.display_format
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7434a6c>}
nname: 0
n 0(None)[log.info('Setting display format to %s', display_format)
self.live_controller.wyplayer.display_format = display_format
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7434a8c>}
nname: 0
n 0(None)[louie_send('hide_screen', sender=self)
mix = Mix()
self.previously_muted = mix.get_mute()
mix.set_mute(True)
self.shielded = True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7434aec>}
nname: 75
n 75(None)[self.code_check = None
self.shielded = False
return None
]:
	i: 57(), 74()
	o: 

nname: 74
n 74(None)[]:
	i: 0(f)
	o: 75()

nname: 57
n 57(None)[self.code_check.hide()
]:
	i: 0(t)
	o: 75()

nname: 0
n 0(self.code_check in pygui_globs['menustack'].menus_stack)[louie_send('show_screen', sender=self)
Mix().set_mute(self.previously_muted)
]:
	i: 
	o: 57(t), 74(f)

nname: 0
n 0(None)[louie_send('show_screen', sender=self)
Mix().set_mute(self.previously_muted)
if self.code_check in pygui_globs['menustack'].menus_stack:
	self.code_check.hide()
self.code_check = None
self.shielded = False
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb749754c>}
nname: 0
n 0(None)[self.code_check = SecretCodeCheckMenu(name=_('Check PIN Code'), action=self._pin_ok, cancel_action=self._pin_nok)
self.code_check.show()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7434eec>}
nname: 0
n 0(None)[user_config['security']['parent_mode'] = True
user_config.save()
self._unshield()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7434f6c>}
nname: 0
n 0(None)[self.code_check.hide()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7434e0c>}
nname: 276
n 276(None)[return None
]:
	i: 216(AL), 275()
	o: 

nname: 275
n 275(None)[]:
	i: 219(AF), 226()
	o: 276()

nname: 226
n 226(None)[for key in ('nrSubtitleTracks', 'nrAudioChannels', 'videoFormatHD'):
louie_send('%s_icon' % key.lower(), sender=self, value=self.player_info['program_' + key])
]:
	i: 219(for)
	o: 275()

nname: 219
n 219(None)[]:
	i: 216(loop)
	o: 226(for), 275(AF)

nname: 216
n 216(None)[]:
	i: 189(), 202()
	o: 219(loop), 276(AL)

nname: 202
n 202(None)[self.player_info['program_videoFormatHD'] = None
]:
	i: 86(f)
	o: 216()

nname: 189
n 189(None)[self.player_info['program_videoFormatHD'] = None
]:
	i: 178(), 185()
	o: 216()

nname: 185
n 185(None)[]:
	i: 123&161(f)
	o: 189()

nname: 178
n 178(None)[]:
	i: 123&161(t)
	o: 189()

nname: 123&161
n 123&161(len(stream_info) > 0 and stream_info['height'] >= 720)[stream_info = self.live_controller.vlist()[0]
]:
	i: 86(t)
	o: 178(t), 185(f)

nname: 86
n 86(len(self.live_controller.vlist()) > 0)[self.player_info['program_nrSubtitleTracks'] = None
]:
	i: 75(), 82()
	o: 123&161(t), 202(f)

nname: 82
n 82(None)[]:
	i: 38(f)
	o: 86()

nname: 75
n 75(None)[]:
	i: 38(t)
	o: 86()

nname: 38
n 38(len(self.live_controller.slist()) > 0)[self.player_info['program_nrAudioChannels'] = None
]:
	i: 27(), 34()
	o: 75(t), 82(f)

nname: 34
n 34(None)[]:
	i: 0(f)
	o: 38()

nname: 27
n 27(None)[]:
	i: 0(t)
	o: 38()

nname: 0
n 0(len(self.live_controller.alist()) > 1)[]:
	i: 
	o: 27(t), 34(f)

nname: 276
n 276(None)[return None
]:
	i: 226()
	o: 

nname: 226
n 226(None)[for key in ('nrSubtitleTracks', 'nrAudioChannels', 'videoFormatHD'):
	louie_send('%s_icon' % key.lower(), sender=self, value=self.player_info['program_' + key])
]:
	i: 216(for)
	o: 276()

nname: 216
n 216(None)[]:
	i: 123&161(), 202()
	o: 226(for)

nname: 202
n 202(None)[self.player_info['program_videoFormatHD'] = None
]:
	i: 86(f)
	o: 216()

nname: 123&161
n 123&161(None)[stream_info = self.live_controller.vlist()[0]
if len(stream_info) > 0 and stream_info['height'] >= 720:
	pass
self.player_info['program_videoFormatHD'] = None
]:
	i: 86(t)
	o: 216()

nname: 86
n 86(len(self.live_controller.vlist()) > 0)[self.player_info['program_nrSubtitleTracks'] = None
]:
	i: 0()
	o: 123&161(t), 202(f)

nname: 0
n 0(None)[if len(self.live_controller.alist()) > 1:
	pass
self.player_info['program_nrAudioChannels'] = None
if len(self.live_controller.slist()) > 0:
	pass
]:
	i: 
	o: 86()

nname: 276
n 276(None)[return None
]:
	i: 216()
	o: 

nname: 216
n 216(None)[for key in ('nrSubtitleTracks', 'nrAudioChannels', 'videoFormatHD'):
	louie_send('%s_icon' % key.lower(), sender=self, value=self.player_info['program_' + key])
]:
	i: 0()
	o: 276()

nname: 0
n 0(None)[if len(self.live_controller.alist()) > 1:
	pass
self.player_info['program_nrAudioChannels'] = None
if len(self.live_controller.slist()) > 0:
	pass
self.player_info['program_nrSubtitleTracks'] = None
if len(self.live_controller.vlist()) > 0:
	stream_info = self.live_controller.vlist()[0]
	if len(stream_info) > 0 and stream_info['height'] >= 720:
		pass
	self.player_info['program_videoFormatHD'] = None
else:
	self.player_info['program_videoFormatHD'] = None
]:
	i: 
	o: 216()

nname: 276
n 276(None)[return None
]:
	i: 0()
	o: 

nname: 0
n 0(None)[if len(self.live_controller.alist()) > 1:
	pass
self.player_info['program_nrAudioChannels'] = None
if len(self.live_controller.slist()) > 0:
	pass
self.player_info['program_nrSubtitleTracks'] = None
if len(self.live_controller.vlist()) > 0:
	stream_info = self.live_controller.vlist()[0]
	if len(stream_info) > 0 and stream_info['height'] >= 720:
		pass
	self.player_info['program_videoFormatHD'] = None
else:
	self.player_info['program_videoFormatHD'] = None
for key in ('nrSubtitleTracks', 'nrAudioChannels', 'videoFormatHD'):
	louie_send('%s_icon' % key.lower(), sender=self, value=self.player_info['program_' + key])
]:
	i: 
	o: 276()

nname: 0
n 0(None)[if len(self.live_controller.alist()) > 1:
	pass
self.player_info['program_nrAudioChannels'] = None
if len(self.live_controller.slist()) > 0:
	pass
self.player_info['program_nrSubtitleTracks'] = None
if len(self.live_controller.vlist()) > 0:
	stream_info = self.live_controller.vlist()[0]
	if len(stream_info) > 0 and stream_info['height'] >= 720:
		pass
	self.player_info['program_videoFormatHD'] = None
else:
	self.player_info['program_videoFormatHD'] = None
for key in ('nrSubtitleTracks', 'nrAudioChannels', 'videoFormatHD'):
	louie_send('%s_icon' % key.lower(), sender=self, value=self.player_info['program_' + key])
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7497d6c>}
nname: 0
n 0(None)[self._new_present_epg_task.args = args
self._new_present_epg_task.kw = kw
self._new_present_epg_task.start(-0.10000000000000001)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7434bec>}
nname: 107
n 107(None)[MessageWindow(message, title, button=None).show(timeout=5)
return None
]:
	i: 55(), 71()
	o: 

nname: 71
n 71(None)[message_pattern = _('Maximum timeshift duration has been reduced to %(duration)s.')
message = message_pattern % {'duration': '%i%%' % timeshift_ratio}
]:
	i: 0(f)
	o: 107()

nname: 55
n 55(None)[message = _('Disk space has run out. Timeshift and recordings have been disabled.')
]:
	i: 0(t)
	o: 107()

nname: 0
n 0(available_space <= 0)[log.warn('DISK SPACE ALERT: %s %s', needed_space, available_space)
message = _('Disk space is running low.')
title = _('Disk space warning')
]:
	i: 
	o: 55(t), 71(f)

nname: 0
n 0(None)[log.warn('DISK SPACE ALERT: %s %s', needed_space, available_space)
message = _('Disk space is running low.')
title = _('Disk space warning')
if available_space <= 0:
	message = _('Disk space has run out. Timeshift and recordings have been disabled.')
else:
	message_pattern = _('Maximum timeshift duration has been reduced to %(duration)s.')
	message = message_pattern % {'duration': '%i%%' % timeshift_ratio}
MessageWindow(message, title, button=None).show(timeout=5)
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb749710c>}
nname: 0
n 0(None)[return Task(self._disk_space_alert_handler, *args, **kw).start(0.10000000000000001)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7434d8c>}
nname: 0
n 0(None)[return Task(self._recording_event_handler, *args, **kw).start(0.20000000000000001)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7434e8c>}
nname: 0
n 0(None)[return Task(self._start_playing_event_handler, *args, **kw).start(0.050000000000000003)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7434aec>}
nname: 117
n 117(None)[]:
	i: 48(), 84()
	o: 

nname: 84
n 84(None)[log.info('Lost signal on device %s', device_id)
louie_send('signal_lost', sender=self)
]:
	i: 42(f)
	o: 117()

nname: 48
n 48(None)[log.info('Acquired signal on device %s', device_id)
louie_send('signal_acquired', sender=self)
]:
	i: 42(t)
	o: 117()

nname: 42
n 42(signal_status)[]:
	i: 24(), 41()
	o: 48(t), 84(f)

nname: 41
n 41(None)[]:
	i: 0(f)
	o: 42()

nname: 24
n 24(None)[log.info('Signal changed on other device -- ignoring...')
]:
	i: 0(t)
	o: 42()

nname: 0
n 0(device_id != self.live_controller.getCurrentlive().deviceid)[]:
	i: 
	o: 24(t), 41(f)

nname: 117
n 117(None)[]:
	i: 0()
	o: 

nname: 0
n 0(None)[if device_id != self.live_controller.getCurrentlive().deviceid:
	log.info('Signal changed on other device -- ignoring...')
if signal_status:
	log.info('Acquired signal on device %s', device_id)
	louie_send('signal_acquired', sender=self)
else:
	log.info('Lost signal on device %s', device_id)
	louie_send('signal_lost', sender=self)
]:
	i: 
	o: 117()

nname: 0
n 0(None)[if device_id != self.live_controller.getCurrentlive().deviceid:
	log.info('Signal changed on other device -- ignoring...')
if signal_status:
	log.info('Acquired signal on device %s', device_id)
	louie_send('signal_acquired', sender=self)
else:
	log.info('Lost signal on device %s', device_id)
	louie_send('signal_lost', sender=self)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb749780c>}
nname: 0
n 0(None)[return Task(self._device_signal_event_handler, *args, **kw).start(0.10000000000000001)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7434aac>}
nname: 0
n 0(None)[log.info('Added service %s', service_info)
title = _('New service detected')
text = _('%(channel_name)s added on channel #%(channel_number)i.') % service_info
MessageWindow(text, title, button=None).show(timeout=5)
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7434f8c>}
nname: 0
n 0(None)[log.info('Updated service %s', service_info)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7434a6c>}
nname: 63
n 63(None)[title = _('Service removed')
text = _('%(channel_name)s is not available anymore.') % service_info
MessageWindow(text, title, button=None).show(timeout=5)
return None
]:
	i: 45(), 62()
	o: 

nname: 62
n 62(None)[]:
	i: 0(f)
	o: 63()

nname: 45
n 45(None)[self.select(1)
]:
	i: 0(t)
	o: 63()

nname: 0
n 0(int(self.selected['serviceId']) == service_info['service_id'])[log.info('Removed service %s', service_info)
]:
	i: 
	o: 45(t), 62(f)

nname: 0
n 0(None)[log.info('Removed service %s', service_info)
if int(self.selected['serviceId']) == service_info['service_id']:
	self.select(1)
title = _('Service removed')
text = _('%(channel_name)s is not available anymore.') % service_info
MessageWindow(text, title, button=None).show(timeout=5)
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb749720c>}
nname: 105
n 105(None)[]:
	i: 0(AL), 104()
	o: 

nname: 104
n 104(None)[]:
	i: 45(AF), 52()
	o: 105()

nname: 52
n 52(None)[for service in service_info_list:
service_info = dict(zip(('service_id', 'channel_name', 'channel_number', 'channel_type'), service[0:3]))
dispatch[service[4]](service_info)
]:
	i: 45(for)
	o: 104()

nname: 45
n 45(None)[]:
	i: 0(loop)
	o: 52(for), 104(AF)

nname: 0
n 0(None)[dispatch = {UPDATE_SERVICE_ADDED: self._service_added, UPDATE_SERVICE_UPDATED: self._service_updated, UPDATE_SERVICE_REMOVED: self._service_removed}
]:
	i: 
	o: 45(loop), 105(AL)

nname: 105
n 105(None)[]:
	i: 52()
	o: 

nname: 52
n 52(None)[for service in service_info_list:
	service_info = dict(zip(('service_id', 'channel_name', 'channel_number', 'channel_type'), service[0:3]))
	dispatch[service[4]](service_info)
]:
	i: 0(for)
	o: 105()

nname: 0
n 0(None)[dispatch = {UPDATE_SERVICE_ADDED: self._service_added, UPDATE_SERVICE_UPDATED: self._service_updated, UPDATE_SERVICE_REMOVED: self._service_removed}
]:
	i: 
	o: 52(for)

nname: 105
n 105(None)[]:
	i: 0()
	o: 

nname: 0
n 0(None)[dispatch = {UPDATE_SERVICE_ADDED: self._service_added, UPDATE_SERVICE_UPDATED: self._service_updated, UPDATE_SERVICE_REMOVED: self._service_removed}
for service in service_info_list:
	service_info = dict(zip(('service_id', 'channel_name', 'channel_number', 'channel_type'), service[0:3]))
	dispatch[service[4]](service_info)
]:
	i: 
	o: 105()

nname: 0
n 0(None)[dispatch = {UPDATE_SERVICE_ADDED: self._service_added, UPDATE_SERVICE_UPDATED: self._service_updated, UPDATE_SERVICE_REMOVED: self._service_removed}
for service in service_info_list:
	service_info = dict(zip(('service_id', 'channel_name', 'channel_number', 'channel_type'), service[0:3]))
	dispatch[service[4]](service_info)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7497dcc>}
nname: 0
n 0(None)[return Task(self._service_update_event_handler, *args, **kw).start(0.10000000000000001)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7434fac>}
nname: 0
n 0(None)[self._speed_change_task.args = args
self._speed_change_task.kw = kw
self._speed_change_task.start(0.10000000000000001)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7434b6c>}
nname: 0
n 0(None)[self._scrambled_change_task.args = args
self._scrambled_change_task.kw = kw
self._scrambled_change_task.start(0.10000000000000001)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7434aac>}
nname: 0
n 0(None)[return self._speed
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7434b2c>}
nname: 30
n 30(None)[title = u'%02i %s' % (int(channel['logical_channel_number']), channel.name)
return ellipsize(title, 20)
]:
	i: 21(), 29()
	o: 

nname: 29
n 29(None)[]:
	i: 0(f)
	o: 30()

nname: 21
n 21(None)[return u''
]:
	i: 0(t)
	o: 30()

nname: 0
n 0(channel is None)[channel = self.selected
]:
	i: 
	o: 21(t), 29(f)

nname: 0
n 0(None)[channel = self.selected
if channel is None:
	return u''
title = u'%02i %s' % (int(channel['logical_channel_number']), channel.name)
return ellipsize(title, 20)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7434c4c>}
nname: 30
n 30(None)[return '%s.png' % channel.display_type
]:
	i: 21(), 29()
	o: 

nname: 29
n 29(None)[]:
	i: 0(f)
	o: 30()

nname: 21
n 21(None)[return None
]:
	i: 0(t)
	o: 30()

nname: 0
n 0(channel is None)[channel = self.selected
]:
	i: 
	o: 21(t), 29(f)

nname: 0
n 0(None)[channel = self.selected
if channel is None:
	return None
return '%s.png' % channel.display_type
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7434b6c>}
nname: 36
n 36(None)[return (time_info.max_available_time - time_info.min_available_time) / 10.0
]:
	i: 0(t), 32()
	o: 

nname: 32
n 32(None)[]:
	i: 0(f)
	o: 36()

nname: 0
n 0((time_info.max_available_time - time_info.min_available_time) / 10.0)[time_info = self._get_time_info()
]:
	i: 
	o: 32(f), 36(t)

nname: 0
n 0(None)[time_info = self._get_time_info()
if not (time_info.max_available_time - time_info.min_available_time) / 10.0:
	pass
return (time_info.max_available_time - time_info.min_available_time) / 10.0
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7434aec>}
nname: 204
n 204(None)[return dict(live=time_info.current_time, direct=direct, timeshift_begin=time_info.min_available_time, timeshift_end=direct, program_begin=begin, program_end=end, record_begin=None, record_end=None)
]:
	i: 187(), 200()
	o: 

nname: 200
n 200(None)[]:
	i: 175(f)
	o: 204()

nname: 187
n 187(None)[]:
	i: 175(t)
	o: 204()

nname: 175
n 175(self._record)[]:
	i: 158(), 171()
	o: 187(t), 200(f)

nname: 171
n 171(None)[]:
	i: 101(f)
	o: 175()

nname: 158
n 158(None)[]:
	i: 101(t)
	o: 175()

nname: 101
n 101(self._record)[]:
	i: 39(), 69()
	o: 158(t), 171(f)

nname: 69
n 69(None)[begin = time_info.min_available_time
end = begin + user_config['tv']['timeshift_length'] * 60
]:
	i: 0(f)
	o: 101()

nname: 39
n 39(None)[begin = self.program['scheduledStartTime']
end = self.program['scheduledEndTime']
]:
	i: 0(t)
	o: 101()

nname: 0
n 0(self.program)[_lc = self.live_controller
time_info = self._get_time_info()
direct = time_info.max_available_time
]:
	i: 
	o: 39(t), 69(f)

nname: 175
n 175(None)[if self._record:
	pass
return dict(live=time_info.current_time, direct=direct, timeshift_begin=time_info.min_available_time, timeshift_end=direct, program_begin=begin, program_end=end, record_begin=None, record_end=None)
]:
	i: 0()
	o: 

nname: 0
n 0(None)[_lc = self.live_controller
time_info = self._get_time_info()
direct = time_info.max_available_time
if self.program:
	begin = self.program['scheduledStartTime']
	end = self.program['scheduledEndTime']
else:
	begin = time_info.min_available_time
	end = begin + user_config['tv']['timeshift_length'] * 60
if self._record:
	pass
]:
	i: 
	o: 175()

nname: 0
n 0(None)[_lc = self.live_controller
time_info = self._get_time_info()
direct = time_info.max_available_time
if self.program:
	begin = self.program['scheduledStartTime']
	end = self.program['scheduledEndTime']
else:
	begin = time_info.min_available_time
	end = begin + user_config['tv']['timeshift_length'] * 60
if self._record:
	pass
if self._record:
	pass
return dict(live=time_info.current_time, direct=direct, timeshift_begin=time_info.min_available_time, timeshift_end=direct, program_begin=begin, program_end=end, record_begin=None, record_end=None)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb743ea2c>}
nname: 293
n 293(None)[]:
	i: 265(), 292()
	o: 

nname: 292
n 292(None)[]:
	i: 253(f)
	o: 293()

nname: 265
n 265(None)[return backward_tricks_icons[self.eventhandler.backward_steps.index(speed)]
]:
	i: 253(t)
	o: 293()

nname: 253
n 253(speed < -1)[]:
	i: 225(), 252()
	o: 265(t), 292(f)

nname: 252
n 252(None)[]:
	i: 213(f)
	o: 253()

nname: 225
n 225(None)[return forward_tricks_icons[self.eventhandler.forward_steps.index(speed)]
]:
	i: 213(t)
	o: 253()

nname: 213
n 213(speed > 1)[]:
	i: 204(), 212()
	o: 225(t), 252(f)

nname: 212
n 212(None)[]:
	i: 201(f)
	o: 213()

nname: 204
n 204(None)[return 'slow_motion_forward'
]:
	i: 201(t)
	o: 213()

nname: 201
n 201(0 < speed)[]:
	i: 189(), 199()
	o: 204(t), 212(f)

nname: 199
n 199(None)[speed
]:
	i: 175(f)
	o: 201()

nname: 189
n 189(None)[]:
	i: 175(t)
	o: 201()

nname: 175
n 175(0 < speed)[]:
	i: 166(), 174()
	o: 189(t), 199(f)

nname: 174
n 174(None)[]:
	i: 163(f)
	o: 175()

nname: 166
n 166(None)[return 'slow_motion_rewind'
]:
	i: 163(t)
	o: 175()

nname: 163
n 163(-1 <= speed)[]:
	i: 151(), 161()
	o: 166(t), 174(f)

nname: 161
n 161(None)[speed
]:
	i: 137(f)
	o: 163()

nname: 151
n 151(None)[]:
	i: 137(t)
	o: 163()

nname: 137
n 137(-1 <= speed)[]:
	i: 128(), 136()
	o: 151(t), 161(f)

nname: 136
n 136(None)[]:
	i: 116(f)
	o: 137()

nname: 128
n 128(None)[return 'pause'
]:
	i: 116(t)
	o: 137()

nname: 116
n 116(speed == 0)[]:
	i: 83(JA), 97(JA), 112(), 115()
	o: 128(t), 136(f)

nname: 115
n 115(None)[]:
	i: 27(f)
	o: 116()

nname: 112
n 112(None)[]:
	i: 110(AE)
	o: 116()

nname: 110
n 110(None)[]:
	i: 87(f)
	o: 112(AE)

nname: 97
n 97(None)[#, e
return 'unknown'
]:
	i: 87(t)
	o: 116(JA)

nname: 87
n 87(<dummy_ex3> EXC_MATCH Exception)[]:
	i: 48(except)
	o: 97(t), 110(f)

nname: 83
n 83(None)[]:
	i: 70(), 78()
	o: 116(JA)

nname: 78
n 78(None)[return 'timeshift'
]:
	i: 52(f)
	o: 83()

nname: 70
n 70(None)[return 'live'
]:
	i: 52(t)
	o: 83()

nname: 52
n 52(self.live_controller.default_renderer.isPlayingOnlive())[]:
	i: 48(try)
	o: 70(t), 78(f)

nname: 48
n 48(None)[]:
	i: 27(t)
	o: 52(try), 87(except)

nname: 27
n 27(speed == 1)[speed = self._speed
]:
	i: 18(), 26()
	o: 48(t), 115(f)

nname: 26
n 26(None)[]:
	i: 0(f)
	o: 27()

nname: 18
n 18(None)[return 'loading'
]:
	i: 0(t)
	o: 27()

nname: 0
n 0(self.live_controller.status in ('loading', 'idle'))[]:
	i: 
	o: 18(t), 26(f)

nname: 253
n 253(None)[if speed < -1:
	return backward_tricks_icons[self.eventhandler.backward_steps.index(speed)]
]:
	i: 201()
	o: 

nname: 201
n 201(None)[if 0 < speed:
	return 'slow_motion_forward'
if speed > 1:
	return forward_tricks_icons[self.eventhandler.forward_steps.index(speed)]
]:
	i: 163()
	o: 253()

nname: 163
n 163(None)[if -1 <= speed:
	return 'slow_motion_rewind'
if 0 < speed:
	pass
else:
	speed
]:
	i: 116()
	o: 201()

nname: 116
n 116(None)[if speed == 0:
	return 'pause'
if -1 <= speed:
	pass
else:
	speed
]:
	i: 52(JA), 97(JA), 87(f), 110(AE), 0(f)
	o: 163()

nname: 97
n 97(None)[#, e
return 'unknown'
]:
	i: 87(t)
	o: 116(JA)

nname: 87
n 87(<dummy_ex3> EXC_MATCH Exception)[]:
	i: 48(except)
	o: 97(t), 116(f)

nname: 52
n 52(None)[if self.live_controller.default_renderer.isPlayingOnlive():
	return 'live'
else:
	return 'timeshift'
]:
	i: 48(try)
	o: 116(JA)

nname: 48
n 48(None)[]:
	i: 0(t)
	o: 52(try), 87(except)

nname: 0
n 0(speed == 1)[if self.live_controller.status in ('loading', 'idle'):
	return 'loading'
speed = self._speed
]:
	i: 
	o: 48(t), 116(f)

nname: 201
n 201(None)[if 0 < speed:
	return 'slow_motion_forward'
if speed > 1:
	return forward_tricks_icons[self.eventhandler.forward_steps.index(speed)]
if speed < -1:
	return backward_tricks_icons[self.eventhandler.backward_steps.index(speed)]
]:
	i: 116()
	o: 

nname: 116
n 116(None)[if speed == 0:
	return 'pause'
if -1 <= speed:
	pass
else:
	speed
if -1 <= speed:
	return 'slow_motion_rewind'
if 0 < speed:
	pass
else:
	speed
]:
	i: 87(f), 0(f)
	o: 201()

nname: 87
n 87(None)[except Exception, e:
	return 'unknown'
]:
	i: 48()
	o: 116(JA)

nname: 48
n 48(None)[try:
	if self.live_controller.default_renderer.isPlayingOnlive():
		return 'live'
	else:
		return 'timeshift'
]:
	i: 0(t)
	o: 87()

nname: 0
n 0(speed == 1)[if self.live_controller.status in ('loading', 'idle'):
	return 'loading'
speed = self._speed
]:
	i: 
	o: 48(t), 116(f)

nname: 116
n 116(None)[if speed == 0:
	return 'pause'
if -1 <= speed:
	pass
else:
	speed
if -1 <= speed:
	return 'slow_motion_rewind'
if 0 < speed:
	pass
else:
	speed
if 0 < speed:
	return 'slow_motion_forward'
if speed > 1:
	return forward_tricks_icons[self.eventhandler.forward_steps.index(speed)]
if speed < -1:
	return backward_tricks_icons[self.eventhandler.backward_steps.index(speed)]
]:
	i: 48(f), 0(f)
	o: 

nname: 48
n 48(None)[try:
	if self.live_controller.default_renderer.isPlayingOnlive():
		return 'live'
	else:
		return 'timeshift'
except Exception, e:
	return 'unknown'
]:
	i: 0(t)
	o: 116(JA)

nname: 0
n 0(speed == 1)[if self.live_controller.status in ('loading', 'idle'):
	return 'loading'
speed = self._speed
]:
	i: 
	o: 48(t), 116(f)

nname: 0
n 0(None)[if self.live_controller.status in ('loading', 'idle'):
	return 'loading'
speed = self._speed
if speed == 1:
	try:
		if self.live_controller.default_renderer.isPlayingOnlive():
			return 'live'
		else:
			return 'timeshift'
	except Exception, e:
		return 'unknown'
if speed == 0:
	return 'pause'
if -1 <= speed:
	pass
else:
	speed
if -1 <= speed:
	return 'slow_motion_rewind'
if 0 < speed:
	pass
else:
	speed
if 0 < speed:
	return 'slow_motion_forward'
if speed > 1:
	return forward_tricks_icons[self.eventhandler.forward_steps.index(speed)]
if speed < -1:
	return backward_tricks_icons[self.eventhandler.backward_steps.index(speed)]
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb743c0cc>}
nname: 335
n 335(None)[return (channel, favorite, playlist)
]:
	i: 216(JA), 306(), 328()
	o: 

nname: 328
n 328(None)[channel = req_channel
]:
	i: 139&146(f)
	o: 335()

nname: 306
n 306(None)[log.info('Falling back to first service in playlist %s: %s', playlist, channel)
]:
	i: 291(), 305()
	o: 335()

nname: 305
n 305(None)[]:
	i: 242&272(f)
	o: 306()

nname: 291
n 291(None)[channel = playlist[1]
]:
	i: 242&272(t)
	o: 306()

nname: 242&272
n 242&272(channel['class'].endswith('videoCapture') and len(playlist) > 1)[channel = playlist[0]
]:
	i: 162&184&200(f)
	o: 291(t), 305(f)

nname: 216
n 216(None)[channel = lzs
log.info('Falling back to previous service: %s', channel)
]:
	i: 162&184&200(t)
	o: 335(JA)

nname: 162&184&200
n 162&184&200(lzs is not None and lzs.parent == favorite and lzs.name in favorite)[lzs = self._last_zap_service
]:
	i: 139&146(t)
	o: 216(t), 242&272(f)

nname: 139&146
n 139&146(not req_channel or req_channel.name not in favorite)[]:
	i: 61(), 87(), 137(AE)
	o: 162&184&200(t), 328(f)

nname: 137
n 137(None)[]:
	i: 77(f)
	o: 139&146(AE)

nname: 87
n 87(None)[log.info('Cannot browse requested favorite -- falling back to the ACL')
favorite = TVRootItem().get_acl(self)
playlist = favorite.browse()
]:
	i: 77(t)
	o: 139&146()

nname: 77
n 77(<dummy_ex3> EXC_MATCH BrowseError)[]:
	i: 58(except)
	o: 87(t), 137(f)

nname: 61
n 61(None)[playlist = favorite.browse()
]:
	i: 58(try)
	o: 139&146()

nname: 58
n 58(None)[]:
	i: 6(), 26(), 39()
	o: 61(try), 77(except)

nname: 39
n 39(None)[favorite = TVRootItem().get_acl(self)
]:
	i: 16(f)
	o: 58()

nname: 26
n 26(None)[favorite = self._favorite_list
]:
	i: 16(t)
	o: 58()

nname: 16
n 16(self._favorite_list)[]:
	i: 0(f)
	o: 26(t), 39(f)

nname: 6
n 6(None)[favorite = req_favorite
]:
	i: 0(t)
	o: 58()

nname: 0
n 0(req_favorite)[]:
	i: 
	o: 6(t), 16(f)

nname: 335
n 335(None)[return (channel, favorite, playlist)
]:
	i: 216(JA), 242&272(), 328()
	o: 

nname: 328
n 328(None)[channel = req_channel
]:
	i: 139&146(f)
	o: 335()

nname: 242&272
n 242&272(None)[channel = playlist[0]
if channel['class'].endswith('videoCapture') and len(playlist) > 1:
	channel = playlist[1]
log.info('Falling back to first service in playlist %s: %s', playlist, channel)
]:
	i: 162&184&200(f)
	o: 335()

nname: 216
n 216(None)[channel = lzs
log.info('Falling back to previous service: %s', channel)
]:
	i: 162&184&200(t)
	o: 335(JA)

nname: 162&184&200
n 162&184&200(lzs is not None and lzs.parent == favorite and lzs.name in favorite)[lzs = self._last_zap_service
]:
	i: 139&146(t)
	o: 216(t), 242&272(f)

nname: 139&146
n 139&146(not req_channel or req_channel.name not in favorite)[]:
	i: 61()
	o: 162&184&200(t), 328(f)

nname: 61
n 61(None)[try:
	playlist = favorite.browse()
except BrowseError:
	log.info('Cannot browse requested favorite -- falling back to the ACL')
	favorite = TVRootItem().get_acl(self)
	playlist = favorite.browse()
]:
	i: 0(try)
	o: 139&146()

nname: 0
n 0(None)[if req_favorite:
	favorite = req_favorite
else:
	if self._favorite_list:
		favorite = self._favorite_list
	else:
		favorite = TVRootItem().get_acl(self)
]:
	i: 
	o: 61(try)

nname: 139&146
n 139&146(None)[if not req_channel or req_channel.name not in favorite:
	lzs = self._last_zap_service
	if lzs is not None and lzs.parent == favorite and lzs.name in favorite:
		channel = lzs
		log.info('Falling back to previous service: %s', channel)
	else:
		channel = playlist[0]
		if channel['class'].endswith('videoCapture') and len(playlist) > 1:
			channel = playlist[1]
		log.info('Falling back to first service in playlist %s: %s', playlist, channel)
else:
	channel = req_channel
return (channel, favorite, playlist)
]:
	i: 0()
	o: 

nname: 0
n 0(None)[if req_favorite:
	favorite = req_favorite
else:
	if self._favorite_list:
		favorite = self._favorite_list
	else:
		favorite = TVRootItem().get_acl(self)
try:
	playlist = favorite.browse()
except BrowseError:
	log.info('Cannot browse requested favorite -- falling back to the ACL')
	favorite = TVRootItem().get_acl(self)
	playlist = favorite.browse()
]:
	i: 
	o: 139&146()

nname: 0
n 0(None)[if req_favorite:
	favorite = req_favorite
else:
	if self._favorite_list:
		favorite = self._favorite_list
	else:
		favorite = TVRootItem().get_acl(self)
try:
	playlist = favorite.browse()
except BrowseError:
	log.info('Cannot browse requested favorite -- falling back to the ACL')
	favorite = TVRootItem().get_acl(self)
	playlist = favorite.browse()
if not req_channel or req_channel.name not in favorite:
	lzs = self._last_zap_service
	if lzs is not None and lzs.parent == favorite and lzs.name in favorite:
		channel = lzs
		log.info('Falling back to previous service: %s', channel)
	else:
		channel = playlist[0]
		if channel['class'].endswith('videoCapture') and len(playlist) > 1:
			channel = playlist[1]
		log.info('Falling back to first service in playlist %s: %s', playlist, channel)
else:
	channel = req_channel
return (channel, favorite, playlist)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb74404ac>}
nname: 0
n 0(None)[return self.live_controller.canZap()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb743496c>}
nname: 234
n 234(None)[return None
]:
	i: 219(), 233()
	o: 

nname: 233
n 233(None)[]:
	i: 210(f)
	o: 234()

nname: 219
n 219(None)[self._unshield()
]:
	i: 210(t)
	o: 234()

nname: 210
n 210(self.shielded)[]:
	i: 174(), 201(), 208(AE)
	o: 219(t), 233(f)

nname: 208
n 208(None)[]:
	i: 191(f)
	o: 210(AE)

nname: 201
n 201(None)[]:
	i: 191(t)
	o: 210()

nname: 191
n 191(<dummy_ex3> EXC_MATCH LiveIsRecordingErrors)[]:
	i: 158(except)
	o: 201(t), 208(f)

nname: 174
n 174(None)[self.live_controller.close()
]:
	i: 158(try)
	o: 210()

nname: 158
n 158(None)[Player.stop(self)
]:
	i: 0(AL), 157()
	o: 174(try), 191(except)

nname: 157
n 157(None)[]:
	i: 125(AF), 132()
	o: 158()

nname: 132
n 132(None)[for i in ('speed', 'scrambled'):
self.live_controller.watch_property(i, None)
]:
	i: 125(for)
	o: 157()

nname: 125
n 125(None)[]:
	i: 0(loop)
	o: 132(for), 157(AF)

nname: 0
n 0(None)[self._TVPlayer__zap_timer.stop()
info_banner_activator.force_ending()
record_banner_activator.force_ending()
self._initialize_record_info()
self._initialize_program_info()
callbacks = WyRecord().callbacks
callbacks.device_signal.unregister(self.device_signal_event_handler)
callbacks.service_update.unregister(self.service_update_event_handler)
callbacks.recording_event.unregister(self.recording_event_handler)
]:
	i: 
	o: 125(loop), 158(AL)

nname: 234
n 234(None)[return None
]:
	i: 191()
	o: 

nname: 191
n 191(None)[except LiveIsRecordingErrors:
	pass
if self.shielded:
	self._unshield()
]:
	i: 158()
	o: 234()

nname: 158
n 158(None)[Player.stop(self)
try:
	self.live_controller.close()
]:
	i: 132()
	o: 191()

nname: 132
n 132(None)[for i in ('speed', 'scrambled'):
	self.live_controller.watch_property(i, None)
]:
	i: 0(for)
	o: 158()

nname: 0
n 0(None)[self._TVPlayer__zap_timer.stop()
info_banner_activator.force_ending()
record_banner_activator.force_ending()
self._initialize_record_info()
self._initialize_program_info()
callbacks = WyRecord().callbacks
callbacks.device_signal.unregister(self.device_signal_event_handler)
callbacks.service_update.unregister(self.service_update_event_handler)
callbacks.recording_event.unregister(self.recording_event_handler)
]:
	i: 
	o: 132(for)

nname: 234
n 234(None)[return None
]:
	i: 158()
	o: 

nname: 158
n 158(None)[Player.stop(self)
try:
	self.live_controller.close()
except LiveIsRecordingErrors:
	pass
if self.shielded:
	self._unshield()
]:
	i: 0()
	o: 234()

nname: 0
n 0(None)[self._TVPlayer__zap_timer.stop()
info_banner_activator.force_ending()
record_banner_activator.force_ending()
self._initialize_record_info()
self._initialize_program_info()
callbacks = WyRecord().callbacks
callbacks.device_signal.unregister(self.device_signal_event_handler)
callbacks.service_update.unregister(self.service_update_event_handler)
callbacks.recording_event.unregister(self.recording_event_handler)
for i in ('speed', 'scrambled'):
	self.live_controller.watch_property(i, None)
]:
	i: 
	o: 158()

nname: 234
n 234(None)[return None
]:
	i: 0()
	o: 

nname: 0
n 0(None)[self._TVPlayer__zap_timer.stop()
info_banner_activator.force_ending()
record_banner_activator.force_ending()
self._initialize_record_info()
self._initialize_program_info()
callbacks = WyRecord().callbacks
callbacks.device_signal.unregister(self.device_signal_event_handler)
callbacks.service_update.unregister(self.service_update_event_handler)
callbacks.recording_event.unregister(self.recording_event_handler)
for i in ('speed', 'scrambled'):
	self.live_controller.watch_property(i, None)
Player.stop(self)
try:
	self.live_controller.close()
except LiveIsRecordingErrors:
	pass
if self.shielded:
	self._unshield()
]:
	i: 
	o: 234()

nname: 0
n 0(None)[self._TVPlayer__zap_timer.stop()
info_banner_activator.force_ending()
record_banner_activator.force_ending()
self._initialize_record_info()
self._initialize_program_info()
callbacks = WyRecord().callbacks
callbacks.device_signal.unregister(self.device_signal_event_handler)
callbacks.service_update.unregister(self.service_update_event_handler)
callbacks.recording_event.unregister(self.recording_event_handler)
for i in ('speed', 'scrambled'):
	self.live_controller.watch_property(i, None)
Player.stop(self)
try:
	self.live_controller.close()
except LiveIsRecordingErrors:
	pass
if self.shielded:
	self._unshield()
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7440a6c>}
nname: 0
n 0(None)[player_info = self.player_info
player_info['rec_status'] = None
player_info['rec_duration'] = '--:--'
player_info['rec_remaining_time'] = '--:--'
player_info['rec_elapsed_time'] = '--:--'
player_info['foreign_rec_status'] = None
player_info['foreign_rec_channel_name'] = ''
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7434aac>}
nname: 0
n 0(None)[timeshift_duration = user_config['tv']['timeshift_length'] * 60
utc_time = time()
player_info = self.player_info
player_info['program_name'] = ''
player_info['program_content'] = ''
player_info['program_start_time'] = seconds_to_hhmm(utc_time)
player_info['program_stop_time'] = seconds_to_hhmm(utc_time + timeshift_duration)
player_info['program_duration'] = seconds_to_hhmm_utc(timeshift_duration)
player_info['program_remaining_time'] = seconds_to_hhmm_utc(timeshift_duration)
player_info['program_elapsed_time'] = '00:00'
player_info['program_videoFormat_16_9'] = None
player_info['program_videoFormatHD'] = None
player_info['program_nrAudioChannels'] = None
player_info['program_nrSubtitleTracks'] = None
player_info['program_subtitleHardOfHearing'] = None
player_info['program_audioHardOfHearing'] = None
player_info['program_audioVisuallyImpaired'] = None
player_info['program_freeCaMode'] = None
player_info['program_maturity_rating'] = None
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb744096c>}
nname: 170
n 170(None)[record_banner_activator.force_ending()
info_banner_activator.force_ending()
]:
	i: 53(), 146()
	o: 

nname: 146
n 146(None)[ms.toggle()
self._navigator.show_help()
]:
	i: 0(f)
	o: 170()

nname: 53
n 53(None)[self._navigator.show()
louie_send('show_program_info', sender=self._navigator)
louie_send('empty_preview', sender=self._navigator)
louie_send('hide_preview_program_bar', sender=self._navigator)
louie_send('show_program_bar', sender=self._navigator)
]:
	i: 0(t)
	o: 170()

nname: 0
n 0(self._navigator not in ms.menus_stack)[self._navigator.select_program(self._favorite_list, self.selected)
ms = pygui_globs['menustack']
]:
	i: 
	o: 53(t), 146(f)

nname: 0
n 0(None)[self._navigator.select_program(self._favorite_list, self.selected)
ms = pygui_globs['menustack']
if self._navigator not in ms.menus_stack:
	self._navigator.show()
	louie_send('show_program_info', sender=self._navigator)
	louie_send('empty_preview', sender=self._navigator)
	louie_send('hide_preview_program_bar', sender=self._navigator)
	louie_send('show_program_bar', sender=self._navigator)
else:
	ms.toggle()
	self._navigator.show_help()
record_banner_activator.force_ending()
info_banner_activator.force_ending()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb744088c>}
nname: 0
n 0(None)[self._tick_can_refresh = True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb744392c>}
nname: 811
n 811(None)[louie_send('signal_acquired', sender=self)
def turn_on_tick_delayed():
	self._tick_can_refresh = True

Task(turn_on_tick_delayed).start(1)
return None
]:
	i: 796(), 810()
	o: 

nname: 810
n 810(None)[]:
	i: 696(f)
	o: 811()

nname: 796
n 796(None)[self._unshield()
]:
	i: 696(t)
	o: 811()

nname: 696
n 696(self.shielded)[self._last_zap_service = self.selected
user_config['tv']['last_favorite_name'] = self._favorite_list['title']
user_config['tv']['last_channel_index'] = int(self.selected['index'])
Task(user_config.save).start(1)
self._last_scrambled_status = None
]:
	i: 121(), 491(JA), 562(JA), 592(), 615(), 667(), 694(AE)
	o: 796(t), 810(f)

nname: 694
n 694(None)[]:
	i: 656(f)
	o: 696(AE)

nname: 667
n 667(None)[PRINT_EXCEPTION()
self._record = None
return None
]:
	i: 656(t)
	o: 696()

nname: 656
n 656(<dummy_ex3> EXC_MATCH Exception)[]:
	i: 595(f)
	o: 667(t), 694(f)

nname: 615
n 615(None)[#, e
log.error('unable to start live for service %s', item.name)
self._record = None
return None
]:
	i: 595(t)
	o: 696()

nname: 595
n 595(<dummy_ex3> EXC_MATCH (StartingLiveErrors, StartLivePlayingErrors, NoDeviceForServiceErrors))[]:
	i: 231(f)
	o: 615(t), 656(f)

nname: 592
n 592(None)[]:
	i: 590(AE)
	o: 696()

nname: 590
n 590(None)[]:
	i: 552(f)
	o: 592(AE)

nname: 562
n 562(None)[#, e
PRINT_EXCEPTION(e)
self._record = None
]:
	i: 552(t)
	o: 696(JA)

nname: 552
n 552(<dummy_ex3> EXC_MATCH Exception)[]:
	i: 241(except)
	o: 562(t), 590(f)

nname: 491
n 491(None)[Player.select(self, service)
self._last_zap_service = self.selected
self.live_controller.zap(next_live.serviceid)
self._get_record()
]:
	i: 272(AL), 428()
	o: 696(JA)

nname: 428
n 428(None)[self.set_items(acl.browse(), 'main_list')
]:
	i: 365(AF), 424()
	o: 491()

nname: 424
n 424(None)[]:
	i: 384(f), 419()
	o: 428()

nname: 419
n 419(None)[break
continue
]:
	i: 384(t)
	o: 424()

nname: 384
n 384(int(service['serviceId']) == service_id)[for i in xrange(len(service_list)):
acl, self._favorite_list, service, service = TVRootItem().get_acl(self), TVRootItem().get_acl(self), acl.get_channel_from_service_id(service_id), service_list[i]
]:
	i: 365(for)
	o: 419(t), 424(f)

nname: 365
n 365(None)[]:
	i: 272(loop)
	o: 384(for), 428(AF)

nname: 272
n 272(None)[live_list = self.live_controller.getRunningLiveList()
old_index = live_list.index(self.live_controller.getCurrentlive())
next_live = live_list[(old_index + 1) % len(live_list)]
service_list = Player.get_item_list(self, 'main_list')
service_id = next_live.serviceid
]:
	i: 241(try)
	o: 365(loop), 491(AL)

nname: 241
n 241(None)[#, e
log.warn('too many live running %s', str(e))
]:
	i: 231(t)
	o: 272(try), 552(except)

nname: 231
n 231(<dummy_ex3> EXC_MATCH NoLiveAvailableError)[]:
	i: 118(except)
	o: 241(t), 595(f)

nname: 121
n 121(None)[options = dict(lang=country_dict[user_config['video']['language']]['iso-639-2'], aspect_ratio=player_aspect_ratio_dict[user_config['video']['aspect_ratio']], display_format=user_config['video']['display_format'], spdif_surround=user_config['connections']['spdif_surround'])
self.live_controller.zap(service_id, **options)
self._get_record()
]:
	i: 118(try)
	o: 696()

nname: 118
n 118(None)[]:
	i: 82(), 108()
	o: 121(try), 231(except)

nname: 108
n 108(None)[self.program = None
]:
	i: 13&56&72(f)
	o: 118()

nname: 82
n 82(None)[self.new_present_epg_handler(self.program.wymedia_resource, None)
]:
	i: 13&56&72(t)
	o: 118()

nname: 13&56&72
n 13&56&72(current_live and current_live.serviceid == service_id and self.program)[item = item
service_id = int(item['serviceId'])
current_live = self.live_controller.getCurrentlive(True)
]:
	i: 0(t), 6()
	o: 82(t), 108(f)

nname: 6
n 6(None)[]:
	i: 0(f)
	o: 13&56&72()

nname: 0
n 0(item)[]:
	i: 
	o: 6(f), 13&56&72(t)

nname: 696
n 696(None)[self._last_zap_service = self.selected
user_config['tv']['last_favorite_name'] = self._favorite_list['title']
user_config['tv']['last_channel_index'] = int(self.selected['index'])
Task(user_config.save).start(1)
self._last_scrambled_status = None
if self.shielded:
	self._unshield()
louie_send('signal_acquired', sender=self)
def turn_on_tick_delayed():
	self._tick_can_refresh = True

Task(turn_on_tick_delayed).start(1)
return None
]:
	i: 121(), 491(JA), 562(JA), 595(), 552(f), 590(AE)
	o: 

nname: 595
n 595(None)[except (StartingLiveErrors, StartLivePlayingErrors, NoDeviceForServiceErrors), e:
	log.error('unable to start live for service %s', item.name)
	self._record = None
	return None
except:
	except Exception:
		PRINT_EXCEPTION()
		self._record = None
		return None
]:
	i: 231(f)
	o: 696()

nname: 562
n 562(None)[#, e
PRINT_EXCEPTION(e)
self._record = None
]:
	i: 552(t)
	o: 696(JA)

nname: 552
n 552(<dummy_ex3> EXC_MATCH Exception)[]:
	i: 241(except)
	o: 562(t), 696(f)

nname: 491
n 491(None)[Player.select(self, service)
self._last_zap_service = self.selected
self.live_controller.zap(next_live.serviceid)
self._get_record()
]:
	i: 272(AL), 428()
	o: 696(JA)

nname: 428
n 428(None)[self.set_items(acl.browse(), 'main_list')
]:
	i: 365(AF), 384()
	o: 491()

nname: 384
n 384(None)[for i in xrange(len(service_list)):
acl, self._favorite_list, service, service = TVRootItem().get_acl(self), TVRootItem().get_acl(self), acl.get_channel_from_service_id(service_id), service_list[i]
if int(service['serviceId']) == service_id:
	break
	continue
]:
	i: 365(for)
	o: 428()

nname: 365
n 365(None)[]:
	i: 272(loop)
	o: 384(for), 428(AF)

nname: 272
n 272(None)[live_list = self.live_controller.getRunningLiveList()
old_index = live_list.index(self.live_controller.getCurrentlive())
next_live = live_list[(old_index + 1) % len(live_list)]
service_list = Player.get_item_list(self, 'main_list')
service_id = next_live.serviceid
]:
	i: 241(try)
	o: 365(loop), 491(AL)

nname: 241
n 241(None)[#, e
log.warn('too many live running %s', str(e))
]:
	i: 231(t)
	o: 272(try), 552(except)

nname: 231
n 231(<dummy_ex3> EXC_MATCH NoLiveAvailableError)[]:
	i: 118(except)
	o: 241(t), 595(f)

nname: 121
n 121(None)[options = dict(lang=country_dict[user_config['video']['language']]['iso-639-2'], aspect_ratio=player_aspect_ratio_dict[user_config['video']['aspect_ratio']], display_format=user_config['video']['display_format'], spdif_surround=user_config['connections']['spdif_surround'])
self.live_controller.zap(service_id, **options)
self._get_record()
]:
	i: 118(try)
	o: 696()

nname: 118
n 118(None)[]:
	i: 0()
	o: 121(try), 231(except)

nname: 0
n 0(None)[if not item:
	pass
item = item
service_id = int(item['serviceId'])
current_live = self.live_controller.getCurrentlive(True)
if current_live and current_live.serviceid == service_id and self.program:
	self.new_present_epg_handler(self.program.wymedia_resource, None)
else:
	self.program = None
]:
	i: 
	o: 118()

nname: 696
n 696(None)[self._last_zap_service = self.selected
user_config['tv']['last_favorite_name'] = self._favorite_list['title']
user_config['tv']['last_channel_index'] = int(self.selected['index'])
Task(user_config.save).start(1)
self._last_scrambled_status = None
if self.shielded:
	self._unshield()
louie_send('signal_acquired', sender=self)
def turn_on_tick_delayed():
	self._tick_can_refresh = True

Task(turn_on_tick_delayed).start(1)
return None
]:
	i: 121(), 428(JA), 595(), 552(f)
	o: 

nname: 595
n 595(None)[except (StartingLiveErrors, StartLivePlayingErrors, NoDeviceForServiceErrors), e:
	log.error('unable to start live for service %s', item.name)
	self._record = None
	return None
except:
	except Exception:
		PRINT_EXCEPTION()
		self._record = None
		return None
]:
	i: 231(f)
	o: 696()

nname: 552
n 552(None)[except Exception, e:
	PRINT_EXCEPTION(e)
	self._record = None
]:
	i: 241()
	o: 696(JA)

nname: 428
n 428(None)[else:
	self.set_items(acl.browse(), 'main_list')
Player.select(self, service)
self._last_zap_service = self.selected
self.live_controller.zap(next_live.serviceid)
self._get_record()
]:
	i: 365()
	o: 696(JA)

nname: 365
n 365(None)[for i in xrange(len(service_list)):
	acl, self._favorite_list, service, service = TVRootItem().get_acl(self), TVRootItem().get_acl(self), acl.get_channel_from_service_id(service_id), service_list[i]
	if int(service['serviceId']) == service_id:
		break
		continue
]:
	i: 241(loop)
	o: 428()

nname: 241
n 241(None)[#, e
log.warn('too many live running %s', str(e))
try:
	live_list = self.live_controller.getRunningLiveList()
	old_index = live_list.index(self.live_controller.getCurrentlive())
	next_live = live_list[(old_index + 1) % len(live_list)]
	service_list = Player.get_item_list(self, 'main_list')
	service_id = next_live.serviceid
]:
	i: 231(t)
	o: 365(loop), 552()

nname: 231
n 231(<dummy_ex3> EXC_MATCH NoLiveAvailableError)[]:
	i: 0(except)
	o: 241(t), 595(f)

nname: 121
n 121(None)[options = dict(lang=country_dict[user_config['video']['language']]['iso-639-2'], aspect_ratio=player_aspect_ratio_dict[user_config['video']['aspect_ratio']], display_format=user_config['video']['display_format'], spdif_surround=user_config['connections']['spdif_surround'])
self.live_controller.zap(service_id, **options)
self._get_record()
]:
	i: 0(try)
	o: 696()

nname: 0
n 0(None)[if not item:
	pass
item = item
service_id = int(item['serviceId'])
current_live = self.live_controller.getCurrentlive(True)
if current_live and current_live.serviceid == service_id and self.program:
	self.new_present_epg_handler(self.program.wymedia_resource, None)
else:
	self.program = None
]:
	i: 
	o: 121(try), 231(except)

nname: 696
n 696(None)[self._last_zap_service = self.selected
user_config['tv']['last_favorite_name'] = self._favorite_list['title']
user_config['tv']['last_channel_index'] = int(self.selected['index'])
Task(user_config.save).start(1)
self._last_scrambled_status = None
if self.shielded:
	self._unshield()
louie_send('signal_acquired', sender=self)
def turn_on_tick_delayed():
	self._tick_can_refresh = True

Task(turn_on_tick_delayed).start(1)
return None
]:
	i: 121(), 365(JA), 595(), 552(f)
	o: 

nname: 595
n 595(None)[except (StartingLiveErrors, StartLivePlayingErrors, NoDeviceForServiceErrors), e:
	log.error('unable to start live for service %s', item.name)
	self._record = None
	return None
except:
	except Exception:
		PRINT_EXCEPTION()
		self._record = None
		return None
]:
	i: 231(f)
	o: 696()

nname: 552
n 552(None)[except Exception, e:
	PRINT_EXCEPTION(e)
	self._record = None
]:
	i: 241()
	o: 696(JA)

nname: 365
n 365(None)[for i in xrange(len(service_list)):
	acl, self._favorite_list, service, service = TVRootItem().get_acl(self), TVRootItem().get_acl(self), acl.get_channel_from_service_id(service_id), service_list[i]
	if int(service['serviceId']) == service_id:
		break
		continue
else:
	self.set_items(acl.browse(), 'main_list')
Player.select(self, service)
self._last_zap_service = self.selected
self.live_controller.zap(next_live.serviceid)
self._get_record()
]:
	i: 241(loop)
	o: 696(JA)

nname: 241
n 241(None)[#, e
log.warn('too many live running %s', str(e))
try:
	live_list = self.live_controller.getRunningLiveList()
	old_index = live_list.index(self.live_controller.getCurrentlive())
	next_live = live_list[(old_index + 1) % len(live_list)]
	service_list = Player.get_item_list(self, 'main_list')
	service_id = next_live.serviceid
]:
	i: 231(t)
	o: 365(loop), 552()

nname: 231
n 231(<dummy_ex3> EXC_MATCH NoLiveAvailableError)[]:
	i: 0(except)
	o: 241(t), 595(f)

nname: 121
n 121(None)[options = dict(lang=country_dict[user_config['video']['language']]['iso-639-2'], aspect_ratio=player_aspect_ratio_dict[user_config['video']['aspect_ratio']], display_format=user_config['video']['display_format'], spdif_surround=user_config['connections']['spdif_surround'])
self.live_controller.zap(service_id, **options)
self._get_record()
]:
	i: 0(try)
	o: 696()

nname: 0
n 0(None)[if not item:
	pass
item = item
service_id = int(item['serviceId'])
current_live = self.live_controller.getCurrentlive(True)
if current_live and current_live.serviceid == service_id and self.program:
	self.new_present_epg_handler(self.program.wymedia_resource, None)
else:
	self.program = None
]:
	i: 
	o: 121(try), 231(except)

self.nodes: {0: <unpyclib.structure.node instance at 0xb743c6cc>, 552: <unpyclib.structure.node instance at 0xb743c5ac>, 696: <unpyclib.structure.node instance at 0xb743cfac>, 595: <unpyclib.structure.node instance at 0xb743c06c>, 231: <unpyclib.structure.node instance at 0xb7497e6c>, 365: <unpyclib.structure.node instance at 0xb743cf2c>, 241: <unpyclib.structure.node instance at 0xb743c3ac>, 121: <unpyclib.structure.node instance at 0xb74970cc>}
nname: 0
n 0(None)[record = self._foreign_rec
message_pattern = _('A recording is in progress on channel %(channel)s. %(remaining_time)s remaining. Stop it?')
data = {'channel': record.service_name, 'remaining_time': seconds_to_hhmm_utc(max(0, record.stop_time + record.stop_padding - self.real_utc_time))}
messbox = ConfirmWindow(text=message_pattern % data, confirm_action=self.stop_recording, confirm_args=[record])
messbox.show()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7434bec>}
nname: 113
n 113(None)[self.update_record_info()
return None
]:
	i: 35(AL), 103()
	o: 

nname: 103
n 103(None)[]:
	i: 38(AF), 99()
	o: 113()

nname: 99
n 99(None)[]:
	i: 54&72(f), 85()
	o: 103()

nname: 85
n 85(None)[self._foreign_rec = rec
break
continue
]:
	i: 54&72(t)
	o: 99()

nname: 54&72
n 54&72(rec and live != current_live)[for live in self.live_controller.getRunningLiveList():
self._foreign_rec, rec = None, live.current_rec
]:
	i: 38(for)
	o: 85(t), 99(f)

nname: 38
n 38(None)[]:
	i: 35(loop)
	o: 54&72(for), 103(AF)

nname: 35
n 35(None)[]:
	i: 18(), 34()
	o: 38(loop), 113(AL)

nname: 34
n 34(None)[]:
	i: 0(f)
	o: 35()

nname: 18
n 18(None)[self._record = current_live.current_rec
]:
	i: 0(t)
	o: 35()

nname: 0
n 0(current_live)[current_live = self.live_controller.current_live
]:
	i: 
	o: 18(t), 34(f)

nname: 113
n 113(None)[self.update_record_info()
return None
]:
	i: 0(AL), 38(AF), 54&72(f)
	o: 

nname: 54&72
n 54&72(None)[for live in self.live_controller.getRunningLiveList():
self._foreign_rec, rec = None, live.current_rec
if rec and live != current_live:
	self._foreign_rec = rec
	break
	continue
]:
	i: 38(for)
	o: 113()

nname: 38
n 38(None)[]:
	i: 0(loop)
	o: 54&72(for), 113(AF)

nname: 0
n 0(None)[current_live = self.live_controller.current_live
if current_live:
	self._record = current_live.current_rec
]:
	i: 
	o: 38(loop), 113(AL)

self.nodes: {0: <unpyclib.structure.node instance at 0xb743e9ac>, 38: <unpyclib.structure.node instance at 0xb743e50c>, '54&72': <unpyclib.structure.node instance at 0xb743e62c>, 113: <unpyclib.structure.node instance at 0xb743ebac>}
nname: 0
n 0(None)[self.live_controller.resume()
self._speed = 1
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7434fac>}
nname: 0
n 0(None)[self.live_controller.pause()
self._speed = 0
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7434a8c>}
nname: 0
n 0(None)[return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb743e5ec>}
nname: 0
n 0(None)[return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb743e2ac>}
nname: 64
n 64(None)[]:
	i: 30(), 44()
	o: 

nname: 44
n 44(None)[info_banner_activator((lambda self: None))(self)
]:
	i: 0&9&22(f)
	o: 64()

nname: 30
n 30(None)[info_banner_activator.force_ending()
]:
	i: 0&9&22(t)
	o: 64()

nname: 0&9&22
n 0&9&22(info_banner_activator._timer and info_banner_activator._timer.running and not refresh)[]:
	i: 
	o: 30(t), 44(f)

nname: 0&9&22
n 0&9&22(None)[if info_banner_activator._timer and info_banner_activator._timer.running and not refresh:
	info_banner_activator.force_ending()
else:
	info_banner_activator((lambda self: None))(self)
]:
	i: 
	o: 

self.nodes: {'0&9&22': <unpyclib.structure.node instance at 0xb7434e4c>}
nname: 58
n 58(None)[]:
	i: 19(), 43(), 57()
	o: 

nname: 57
n 57(None)[]:
	i: 33(f)
	o: 58()

nname: 43
n 43(None)[self._prompt_stop_foreign_rec()
]:
	i: 33(t)
	o: 58()

nname: 33
n 33(self._foreign_rec)[]:
	i: 0(f)
	o: 43(t), 57(f)

nname: 19
n 19(None)[self._prompt_stop_record()
]:
	i: 0(t)
	o: 58()

nname: 0
n 0(self._record)[self.update_record_info()
]:
	i: 
	o: 19(t), 33(f)

nname: 0
n 0(None)[self.update_record_info()
if self._record:
	self._prompt_stop_record()
else:
	if self._foreign_rec:
		self._prompt_stop_foreign_rec()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7434dac>}
nname: 184
n 184(None)[return None
]:
	i: 38(JA), 79(), 121(), 128()
	o: 

nname: 128
n 128(None)[title = _('A recording is in progress.')
message = _('Stop the recording before changing channels.')
MessageWindow(message, title, button=None).show(timeout=5)
]:
	i: 83(f)
	o: 184()

nname: 121
n 121(None)[self.select(offset)
]:
	i: 109(), 117()
	o: 184()

nname: 117
n 117(None)[]:
	i: 96(f)
	o: 121()

nname: 109
n 109(None)[]:
	i: 96(t)
	o: 121()

nname: 96
n 96(inverted)[]:
	i: 83(t)
	o: 109(t), 117(f)

nname: 83
n 83(self.can_zap())[]:
	i: 0(f)
	o: 96(t), 128(f)

nname: 79
n 79(None)[]:
	i: 22(f)
	o: 184()

nname: 38
n 38(None)[self.set_record_duration(offset * HMI_TV['record_duration_step'])
self.player_info['rec_duration'] = self._record
]:
	i: 22(t)
	o: 184(JA)

nname: 22
n 22(self._record is not None)[]:
	i: 0(t)
	o: 38(t), 79(f)

nname: 0
n 0(record_banner_activator._timer.running)[inverted = HMI_TV['invert_y_axis']
]:
	i: 
	o: 22(t), 83(f)

nname: 184
n 184(None)[return None
]:
	i: 22(JA), 96(), 128()
	o: 

nname: 128
n 128(None)[title = _('A recording is in progress.')
message = _('Stop the recording before changing channels.')
MessageWindow(message, title, button=None).show(timeout=5)
]:
	i: 83(f)
	o: 184()

nname: 96
n 96(None)[if inverted:
	pass
self.select(offset)
]:
	i: 83(t)
	o: 184()

nname: 83
n 83(self.can_zap())[]:
	i: 0(f)
	o: 96(t), 128(f)

nname: 22
n 22(None)[if self._record is not None:
	self.set_record_duration(offset * HMI_TV['record_duration_step'])
	self.player_info['rec_duration'] = self._record
]:
	i: 0(t)
	o: 184(JA)

nname: 0
n 0(record_banner_activator._timer.running)[inverted = HMI_TV['invert_y_axis']
]:
	i: 
	o: 22(t), 83(f)

nname: 0
n 0(None)[inverted = HMI_TV['invert_y_axis']
if record_banner_activator._timer.running:
	if self._record is not None:
		self.set_record_duration(offset * HMI_TV['record_duration_step'])
		self.player_info['rec_duration'] = self._record
else:
	if self.can_zap():
		if inverted:
			pass
		self.select(offset)
	else:
		title = _('A recording is in progress.')
		message = _('Stop the recording before changing channels.')
		MessageWindow(message, title, button=None).show(timeout=5)
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb743e1cc>}
nname: 0
n 0(None)[from pygui.menu.menu.tv.scheduled_record import ScheduledRecordMenu
_loading = LoadingWindow()
_loading.show()
menu = ScheduledRecordMenu()
menu.select_channel(self.selected, self._favorite_list)
date = self.real_utc_time
menu.select_date(date, date + 3600)
menu.show()
_loading.hide()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7434dec>}
nname: 0
n 0(None)[from pygui.menu.menu.tv.epg_grid import EpgGridMenu
menu = EpgGridMenu(player=self, channel_list=self._favorite_list, selected_chan=self.selected)
menu.show()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7434a2c>}
nname: 0
n 0(None)[self._last_zap_service, self._favorite_list = None, None
user_config['tv']['last_favorite_name'] = u'all_channels_list'
user_config['tv']['last_channel_index'] = None
Task(user_config.save).start(1)
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7434ccc>}
nname: 88
n 88(None)[]:
	i: 28(), 64()
	o: 

nname: 64
n 64(None)[ms.toggle()
self._navigator.select_schedule_recordings()
]:
	i: 0(f)
	o: 88()

nname: 28
n 28(None)[self._navigator.show(hide_previous_menu=False)
self._navigator.select_schedule_recordings()
]:
	i: 0(t)
	o: 88()

nname: 0
n 0(self._navigator not in ms.menus_stack)[ms = pygui_globs['menustack']
]:
	i: 
	o: 28(t), 64(f)

nname: 0
n 0(None)[ms = pygui_globs['menustack']
if self._navigator not in ms.menus_stack:
	self._navigator.show(hide_previous_menu=False)
	self._navigator.select_schedule_recordings()
else:
	ms.toggle()
	self._navigator.select_schedule_recordings()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb74349ec>}
nname: 6
n 6(None)[def could_remove_banner(self):
	if 0 < abs(self._speed):
		pass
	else:
		abs(self._speed)
	if 0 < abs(self._speed):
		pass
	return 0 < abs(self._speed)

def __init__(self, player=None, type='tvplayer'):
	Player.__init__(self, type, universe='tv')
	self.eventhandler = TVEventHandler(self)
	self._getitems_keywords.update(dict(clock=(lambda : None), channel_name=(lambda : self.player_info['channel_name']), channel_type=(lambda : self.player_info['channel_type']), program_name=(lambda : self.player_info['program_name']), program_content=(lambda : self.player_info['program_content']), program_start_time=(lambda : self.player_info['program_start_time']), program_stop_time=(lambda : self.player_info['program_stop_time']), program_duration=(lambda : self.player_info['program_duration']), program_remaining_time=(lambda : self.player_info['program_remaining_time']), program_elapsed_time=(lambda : self.player_info['program_elapsed_time']), live_time=(lambda : seconds_to_hhmm(self.real_utc_time)), rec_duration=(lambda : self.player_info['rec_duration']), rec_elapsed_time=(lambda : self.player_info['rec_elapsed_time']), rec_remaining_time=(lambda : self.player_info['rec_remaining_time']), rec_status=(lambda : self.player_info['rec_status']), foreign_rec_status=(lambda : self.player_info['foreign_rec_status']), foreign_rec_channel_name=(lambda : self.player_info['foreign_rec_channel_name']), record_timeshift_programbar=self.get_record_timeshift_programbar, speed=(lambda : ._speed not in f_list([0, 1]):
		pass
	return ''), videoformat_16_9_icon=(lambda : self.player_info['program_videoFormat_16_9']), videoformathd_icon=(lambda : self.player_info['program_videoFormatHD']), nraudiochannels_icon=(lambda : self.player_info['program_nrAudioChannels']), nrsubtitletracks_icon=(lambda : self.player_info['program_nrSubtitleTracks']), subtitlehardofhearing_icon=(lambda : self.player_info['program_subtitleHardOfHearing']), audiohardofhearing_icon=(lambda : self.player_info['program_audioHardOfHearing']), audiovisuallyimpaired_icon=(lambda : self.player_info['program_audioVisuallyImpaired']), freecamode_icon=(lambda : self.player_info['program_freeCaMode']), maturity_rating_icon=(lambda : self.player_info['program_maturity_rating'])))
	_wyrec = WyRecord()
	self.live_controller = _wyrec.getLiveController(player)
	self.record_scheduler = _wyrec.scheduler
	callbacks = _wyrec.callbacks
	callbacks.new_present_epg.register(self.new_present_epg_handler)
	callbacks.disk_space_alert.register(self.disk_space_alert_handler)
	callbacks.start_playing.register(self.start_playing_event_handler)
	self._new_present_epg_task = Task(self._new_present_epg_handler)
	self._speed_change_task = Task(self._speed_change_event_handler)
	self._scrambled_change_task = Task(self._scrambled_change_event_handler)
	self._record = None
	self._conflicting_rec = None
	self._foreign_rec = None
	def _build_navigator():
		self._navigator = TvNavigatorMenu(_('EPG Navigator Menu'), player=self, fill_root=False, type='tv_navigator')

	Task(_build_navigator).start(0.01)
	self._last_scrambled_status = None
	self.code_check = None
	self.shielded = False
	self.previously_muted = False
	self._favorite_list = TVRootItem().get_acl(self)
	self._TVPlayer__zap_timer = Task(self.zap)
	self._tick_can_refresh = False
	self._speed = 1
	self.program = None
	self.player_info = {}
	self._initialize_program_info()
	self._initialize_record_info()
	return None

_get_time_info = cache_result(validity=1)()
def tick_callback(self):
	if self._tick_can_refresh:
		program, time_info = self.program, self._get_time_info()
		utc_time = time_info.current_time
		if program:
			self.player_info['program_remaining_time'] = seconds_to_hhmm_utc(max(0, program['scheduledEndTime'] - utc_time))
			self.player_info['program_elapsed_time'] = seconds_to_hhmm_utc(utc_time - program['scheduledStartTime'])
		else:
			elapsed = utc_time - time_info.min_available_time
			timeshift_duration = user_config['tv']['timeshift_length'] * 60
			self.player_info['program_remaining_time'] = seconds_to_hhmm_utc(timeshift_duration - elapsed)
			self.player_info['program_elapsed_time'] = seconds_to_hhmm_utc(elapsed)
		if self._record:
			real_utc_time = self.real_utc_time
			self.player_info['rec_elapsed_time'] = seconds_to_hhmm_utc(real_utc_time - self._record.start_time)
			self.player_info['rec_remaining_time'] = seconds_to_hhmm_utc(max(0, self._record.stop_time + self._record.stop_padding - real_utc_time))
		else:
			self.player_info['rec_elapsed_time'], self.player_info['rec_remaining_time'] = '--:--', '--:--'
		for key in ('program_duration', 'program_elapsed_time', 'program_remaining_time', 'record_timeshift_programbar', 'rec_duration', 'rec_elapsed_time', 'rec_remaining_time', 'status_icon'):
			louie_send(key, sender=self, value=self[key])

def on_foreground(self):
	Player.on_foreground(self)
	chan = self.selected
	try:
		items = self._favorite_list.browse()
		if not items:
			raise ValueError('Current favorite is empty')

def get_subtitles(self):
	subtitles_list = [{'lang': _('OFF'), 'id': -1}] + self.live_controller.slist()
	sid = self.live_controller.sid

def set_subtitle(self, sid):
	self.live_controller.wyplayer.sid = sid

def get_audio_substreams(self):
	audiostreams_list = self.live_controller.alist()
	aid = self.live_controller.wyplayer.aid

def set_audio_substream(self, aid):
	self.live_controller.wyplayer.aid = aid

def _get_aspect_ratio(self):
	return self.live_controller.wyplayer.aspect_ratio

def _set_aspect_ratio(self, aspect_ratio):
	log.info('Setting aspect ratio to %s', aspect_ratio)
	self.live_controller.wyplayer.aspect_ratio = aspect_ratio

aspect_ratio = property(_get_aspect_ratio, _set_aspect_ratio, doc="The player's aspect ratio (4_3 or 16_9)")
def _get_display_format(self):
	return self.live_controller.wyplayer.display_format

def _set_display_format(self, display_format):
	log.info('Setting display format to %s', display_format)
	self.live_controller.wyplayer.display_format = display_format

display_format = property(_get_display_format, _set_display_format, doc="The player's display format (for use when the stream's aspect ratio differs from that of the display)")
def _shield(self):
	louie_send('hide_screen', sender=self)
	mix = Mix()
	self.previously_muted = mix.get_mute()
	mix.set_mute(True)
	self.shielded = True

def _unshield(self):
	louie_send('show_screen', sender=self)
	Mix().set_mute(self.previously_muted)
	if self.code_check in pygui_globs['menustack'].menus_stack:
		self.code_check.hide()
	self.code_check = None
	self.shielded = False
	return None

def prompt_for_pin(self):
	self.code_check = SecretCodeCheckMenu(name=_('Check PIN Code'), action=self._pin_ok, cancel_action=self._pin_nok)
	self.code_check.show()

def _pin_ok(self):
	user_config['security']['parent_mode'] = True
	user_config.save()
	self._unshield()

def _pin_nok(self):
	self.code_check.hide()

def _update_tracks_info(self):
	if len(self.live_controller.alist()) > 1:
		pass
	self.player_info['program_nrAudioChannels'] = None
	if len(self.live_controller.slist()) > 0:
		pass
	self.player_info['program_nrSubtitleTracks'] = None
	if len(self.live_controller.vlist()) > 0:
		stream_info = self.live_controller.vlist()[0]
		if len(stream_info) > 0 and stream_info['height'] >= 720:
			pass
		self.player_info['program_videoFormatHD'] = None
	else:
		self.player_info['program_videoFormatHD'] = None
	for key in ('nrSubtitleTracks', 'nrAudioChannels', 'videoFormatHD'):
		louie_send('%s_icon' % key.lower(), sender=self, value=self.player_info['program_' + key])
	return None

_new_present_epg_handler = selective_gui_updater('program_name', 'program_start_time', 'program_stop_time', 'program_duration', 'program_content', 'maturity_rating_icon')()
def new_present_epg_handler(self, *args, **args):
	self._new_present_epg_task.args = args
	self._new_present_epg_task.kw = kw
	self._new_present_epg_task.start(-0.10000000000000001)

def _disk_space_alert_handler(self, needed_space, available_space, timeshift_ratio):
	log.warn('DISK SPACE ALERT: %s %s', needed_space, available_space)
	message = _('Disk space is running low.')
	title = _('Disk space warning')
	if available_space <= 0:
		message = _('Disk space has run out. Timeshift and recordings have been disabled.')
	else:
		message_pattern = _('Maximum timeshift duration has been reduced to %(duration)s.')
		message = message_pattern % {'duration': '%i%%' % timeshift_ratio}
	MessageWindow(message, title, button=None).show(timeout=5)
	return None

def disk_space_alert_handler(self, *args, **args):
	return Task(self._disk_space_alert_handler, *args, **kw).start(0.10000000000000001)

_recording_event_handler = selective_gui_updater('record_timeshift_programbar')()
def recording_event_handler(self, *args, **args):
	return Task(self._recording_event_handler, *args, **kw).start(0.20000000000000001)

_start_playing_event_handler = info_banner_activator(selective_gui_updater('channel_name', 'channel_type', 'speed', 'status')())
def start_playing_event_handler(self, *args, **args):
	return Task(self._start_playing_event_handler, *args, **kw).start(0.050000000000000003)

def _device_signal_event_handler(self, device_id, signal_status):
	if device_id != self.live_controller.getCurrentlive().deviceid:
		log.info('Signal changed on other device -- ignoring...')
	if signal_status:
		log.info('Acquired signal on device %s', device_id)
		louie_send('signal_acquired', sender=self)
	else:
		log.info('Lost signal on device %s', device_id)
		louie_send('signal_lost', sender=self)

def device_signal_event_handler(self, *args, **args):
	return Task(self._device_signal_event_handler, *args, **kw).start(0.10000000000000001)

def _service_added(self, service_info):
	log.info('Added service %s', service_info)
	title = _('New service detected')
	text = _('%(channel_name)s added on channel #%(channel_number)i.') % service_info
	MessageWindow(text, title, button=None).show(timeout=5)
	return None

def _service_updated(self, service_info):
	log.info('Updated service %s', service_info)

def _service_removed(self, service_info):
	log.info('Removed service %s', service_info)
	if int(self.selected['serviceId']) == service_info['service_id']:
		self.select(1)
	title = _('Service removed')
	text = _('%(channel_name)s is not available anymore.') % service_info
	MessageWindow(text, title, button=None).show(timeout=5)
	return None

def _service_update_event_handler(self, device, service_info_list, tp_info):
	dispatch = {UPDATE_SERVICE_ADDED: self._service_added, UPDATE_SERVICE_UPDATED: self._service_updated, UPDATE_SERVICE_REMOVED: self._service_removed}
	for service in service_info_list:
		service_info = dict(zip(('service_id', 'channel_name', 'channel_number', 'channel_type'), service[0:3]))
		dispatch[service[4]](service_info)

def service_update_event_handler(self, *args, **args):
	return Task(self._service_update_event_handler, *args, **kw).start(0.10000000000000001)

_speed_change_event_handler = selective_gui_updater('status_icon', 'speed')()
def speed_change_event_handler(self, *args, **args):
	self._speed_change_task.args = args
	self._speed_change_task.kw = kw
	self._speed_change_task.start(0.10000000000000001)

_scrambled_change_event_handler = info_banner_activator()
def scrambled_change_event_handler(self, *args, **args):
	self._scrambled_change_task.args = args
	self._scrambled_change_task.kw = kw
	self._scrambled_change_task.start(0.10000000000000001)

_set_livecontroller_speed = tasked(0.5)()
_set_speed = selective_gui_updater('speed', 'status_icon')(info_banner_activator())
def _get_speed(self):
	return self._speed

speed = property(_get_speed, _set_speed)
del _get_speed
del _set_speed
def get_channel_name(self):
	channel = self.selected
	if channel is None:
		return u''
	title = u'%02i %s' % (int(channel['logical_channel_number']), channel.name)
	return ellipsize(title, 20)

def get_channel_type(self):
	channel = self.selected
	if channel is None:
		return None
	return '%s.png' % channel.display_type

def get_seek_step(self):
	time_info = self._get_time_info()
	if not (time_info.max_available_time - time_info.min_available_time) / 10.0:
		pass
	return (time_info.max_available_time - time_info.min_available_time) / 10.0

def get_record_timeshift_programbar(self, record=None):
	_lc = self.live_controller
	time_info = self._get_time_info()
	direct = time_info.max_available_time
	if self.program:
		begin = self.program['scheduledStartTime']
		end = self.program['scheduledEndTime']
	else:
		begin = time_info.min_available_time
		end = begin + user_config['tv']['timeshift_length'] * 60
	if self._record:
		pass
	if self._record:
		pass
	return dict(live=time_info.current_time, direct=direct, timeshift_begin=time_info.min_available_time, timeshift_end=direct, program_begin=begin, program_end=end, record_begin=None, record_end=None)

def _get_status(self):
	if self.live_controller.status in ('loading', 'idle'):
		return 'loading'
	speed = self._speed
	if speed == 1:
		try:
			if self.live_controller.default_renderer.isPlayingOnlive():
				return 'live'
			else:
				return 'timeshift'
		except Exception, e:
			return 'unknown'
	if speed == 0:
		return 'pause'
	if -1 <= speed:
		pass
	else:
		speed
	if -1 <= speed:
		return 'slow_motion_rewind'
	if 0 < speed:
		pass
	else:
		speed
	if 0 < speed:
		return 'slow_motion_forward'
	if speed > 1:
		return forward_tricks_icons[self.eventhandler.forward_steps.index(speed)]
	if speed < -1:
		return backward_tricks_icons[self.eventhandler.backward_steps.index(speed)]

def _request_channel(self, req_channel=None, req_favorite=None):
	if req_favorite:
		favorite = req_favorite
	else:
		if self._favorite_list:
			favorite = self._favorite_list
		else:
			favorite = TVRootItem().get_acl(self)
	try:
		playlist = favorite.browse()
	except BrowseError:
		log.info('Cannot browse requested favorite -- falling back to the ACL')
		favorite = TVRootItem().get_acl(self)
		playlist = favorite.browse()
	if not req_channel or req_channel.name not in favorite:
		lzs = self._last_zap_service
		if lzs is not None and lzs.parent == favorite and lzs.name in favorite:
			channel = lzs
			log.info('Falling back to previous service: %s', channel)
		else:
			channel = playlist[0]
			if channel['class'].endswith('videoCapture') and len(playlist) > 1:
				channel = playlist[1]
			log.info('Falling back to first service in playlist %s: %s', playlist, channel)
	else:
		channel = req_channel
	return (channel, favorite, playlist)

def can_zap(self):
	return self.live_controller.canZap()

play = info_banner_activator(selective_gui_updater('channel_name', 'channel_type')())
def stop(self):
	self._TVPlayer__zap_timer.stop()
	info_banner_activator.force_ending()
	record_banner_activator.force_ending()
	self._initialize_record_info()
	self._initialize_program_info()
	callbacks = WyRecord().callbacks
	callbacks.device_signal.unregister(self.device_signal_event_handler)
	callbacks.service_update.unregister(self.service_update_event_handler)
	callbacks.recording_event.unregister(self.recording_event_handler)
	for i in ('speed', 'scrambled'):
		self.live_controller.watch_property(i, None)
	Player.stop(self)
	try:
		self.live_controller.close()
	except LiveIsRecordingErrors:
		pass
	if self.shielded:
		self._unshield()
	return None

def _initialize_record_info(self):
	player_info = self.player_info
	player_info['rec_status'] = None
	player_info['rec_duration'] = '--:--'
	player_info['rec_remaining_time'] = '--:--'
	player_info['rec_elapsed_time'] = '--:--'
	player_info['foreign_rec_status'] = None
	player_info['foreign_rec_channel_name'] = ''
	return None

def _initialize_program_info(self):
	timeshift_duration = user_config['tv']['timeshift_length'] * 60
	utc_time = time()
	player_info = self.player_info
	player_info['program_name'] = ''
	player_info['program_content'] = ''
	player_info['program_start_time'] = seconds_to_hhmm(utc_time)
	player_info['program_stop_time'] = seconds_to_hhmm(utc_time + timeshift_duration)
	player_info['program_duration'] = seconds_to_hhmm_utc(timeshift_duration)
	player_info['program_remaining_time'] = seconds_to_hhmm_utc(timeshift_duration)
	player_info['program_elapsed_time'] = '00:00'
	player_info['program_videoFormat_16_9'] = None
	player_info['program_videoFormatHD'] = None
	player_info['program_nrAudioChannels'] = None
	player_info['program_nrSubtitleTracks'] = None
	player_info['program_subtitleHardOfHearing'] = None
	player_info['program_audioHardOfHearing'] = None
	player_info['program_audioVisuallyImpaired'] = None
	player_info['program_freeCaMode'] = None
	player_info['program_maturity_rating'] = None
	return None

clear_info_banner = selective_gui_updater('program_name', 'program_start_time', 'program_stop_time', 'maturity_rating_icon', 'program_content', 'program_duration', 'program_elapsed_time', 'program_remaining_time', 'rec_status')()
select = selective_gui_updater('channel_name', 'channel_type')(info_banner_activator())
def toggle_menu(self):
	self._navigator.select_program(self._favorite_list, self.selected)
	ms = pygui_globs['menustack']
	if self._navigator not in ms.menus_stack:
		self._navigator.show()
		louie_send('show_program_info', sender=self._navigator)
		louie_send('empty_preview', sender=self._navigator)
		louie_send('hide_preview_program_bar', sender=self._navigator)
		louie_send('show_program_bar', sender=self._navigator)
	else:
		ms.toggle()
		self._navigator.show_help()
	record_banner_activator.force_ending()
	info_banner_activator.force_ending()

real_utc_time = property()
timeshift_utc_time = property()
def zap(self, item=None):
	if not item:
		pass
	item = item
	service_id = int(item['serviceId'])
	current_live = self.live_controller.getCurrentlive(True)
	if current_live and current_live.serviceid == service_id and self.program:
		self.new_present_epg_handler(self.program.wymedia_resource, None)
	else:
		self.program = None

start_recording = selective_gui_updater('record_timeshift_programbar')()
stop_recording = selective_gui_updater('rec_duration', 'rec_status', 'rec_remaining_time', 'record_timeshift_programbar')()
_prompt_stop_record = record_banner_activator(selective_gui_updater('rec_duration', 'rec_remaining_time')())
def _prompt_stop_foreign_rec(self):
	record = self._foreign_rec
	message_pattern = _('A recording is in progress on channel %(channel)s. %(remaining_time)s remaining. Stop it?')
	data = {'channel': record.service_name, 'remaining_time': seconds_to_hhmm_utc(max(0, record.stop_time + record.stop_padding - self.real_utc_time))}
	messbox = ConfirmWindow(text=message_pattern % data, confirm_action=self.stop_recording, confirm_args=[record])
	messbox.show()

set_record_duration = record_banner_activator(info_banner_activator(selective_gui_updater('rec_duration', 'rec_remaining_time', 'record_timeshift_programbar')()))
def _get_record(self):
	current_live = self.live_controller.current_live
	if current_live:
		self._record = current_live.current_rec

update_record_info = selective_gui_updater('rec_status', 'foreign_rec_status', 'foreign_rec_channel_name', 'rec_duration', 'rec_remaining_time', 'rec_elapsed_time')()
def resume(self):
	self.live_controller.resume()
	self._speed = 1

def pause(self):
	self.live_controller.pause()
	self._speed = 0

action_seek = info_banner_activator(selective_gui_updater('status_icon')())
action_rec = selective_gui_updater('rec_duration', 'rec_remaining_time')()
action_play_pause = info_banner_activator(selective_gui_updater('speed', 'status_icon')())
def action_info(self, refresh=False):
	if info_banner_activator._timer and info_banner_activator._timer.running and not refresh:
		info_banner_activator.force_ending()
	else:
		info_banner_activator((lambda self: None))(self)

def action_stop(self):
	self.update_record_info()
	if self._record:
		self._prompt_stop_record()
	else:
		if self._foreign_rec:
			self._prompt_stop_foreign_rec()

def action_vertical(self, offset):
	inverted = HMI_TV['invert_y_axis']
	if record_banner_activator._timer.running:
		if self._record is not None:
			self.set_record_duration(offset * HMI_TV['record_duration_step'])
			self.player_info['rec_duration'] = self._record
	else:
		if self.can_zap():
			if inverted:
				pass
			self.select(offset)
		else:
			title = _('A recording is in progress.')
			message = _('Stop the recording before changing channels.')
			MessageWindow(message, title, button=None).show(timeout=5)
	return None

def schedule_record(self):
	from pygui.menu.menu.tv.scheduled_record import ScheduledRecordMenu
	_loading = LoadingWindow()
	_loading.show()
	menu = ScheduledRecordMenu()
	menu.select_channel(self.selected, self._favorite_list)
	date = self.real_utc_time
	menu.select_date(date, date + 3600)
	menu.show()
	_loading.hide()

def display_epg(self):
	from pygui.menu.menu.tv.epg_grid import EpgGridMenu
	menu = EpgGridMenu(player=self, channel_list=self._favorite_list, selected_chan=self.selected)
	menu.show()

zapping_rollback = gui_updater()
def clear_last_zap(self):
	self._last_zap_service, self._favorite_list = None, None
	user_config['tv']['last_favorite_name'] = u'all_channels_list'
	user_config['tv']['last_channel_index'] = None
	Task(user_config.save).start(1)
	return None

def goto_schedule_record(self):
	ms = pygui_globs['menustack']
	if self._navigator not in ms.menus_stack:
		self._navigator.show(hide_previous_menu=False)
		self._navigator.select_schedule_recordings()
	else:
		ms.toggle()
		self._navigator.select_schedule_recordings()

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb747858c>}
nname: 79
n 79(None)[from time import localtime, strftime, time
from wymedia.wmplus import BrowseError
from wyrecord import WyRecord
from wyrecord import RECORDING_EVENT_RECORD_STARTED, RECORDING_EVENT_RECORD_STOPPED, RECORDING_EVENT_RECORD_START_ERROR, RECORDING_EVENT_RECORD_GOING_TO_START, RECORDING_TYPE_NOT_SCHEDULED, RECORDING_EVENT_RECORD_DISK_SPACE_START_ERROR, RECORDING_EVENT_RECORD_MACROVISION_START_ERROR, RECORDING_EVENT_RECORD_MACROVISION_STOP_ERROR
from wyrecord.callbacks import UPDATE_SERVICE_ADDED, UPDATE_SERVICE_UPDATED, UPDATE_SERVICE_REMOVED
from wyrecord.exceptions import LiveIsRecordingErrors, LiveInConflictError, DefaultLiveControllerError, NoLiveAvailableError, StartingLiveErrors, StartLivePlayingErrors, NoDeviceForServiceErrors, SchedulingFailedOnConflictErrors, SchedulingDoneWithConflictErrors, SchedulingFailedOnDiskSpaceErrors
from peewee.debug import GET_LOGGER, PRINT_EXCEPTION
from peewee.cache_utils import cache_result
from peewee.formatters import ellipsize, seconds_to_hhmm, seconds_to_hhmm_utc
from peewee.messages import send as louie_send
from peewee.notifier import Task, tasked
from peewee.ranges import f_list
from pygui.eventmanager.players import TVEventHandler
from pygui.facilities.codemapping import country_dict, player_aspect_ratio_dict
from pygui.facilities.l10n import get_date_format
from pygui.facilities.mixer import Mix
from pygui.item.core import Item
from pygui.item.mediaitem.tv import TVRootItem, ProgramItem
from pygui.shared import pygui_globs
from pygui.menu import gui_updater, selective_gui_updater
from pygui.menu.menu.security import SecretCodeCheckMenu
from pygui.menu.menu.tv.navigator import TvNavigatorMenu
from pygui.menu.players.core import Player, TimerActivator
from pygui.window import ConfirmWindow, LoadingWindow, MessageWindow
from . import forward_tricks_icons, backward_tricks_icons
log = GET_LOGGER(__name__)
info_banner_activator = TimerActivator(signals=('on_user_event', 'on_user_idle'), delay=HMI_TV.get('banner_period', 2), _check=not add_tv_info_banner_idle_events)
record_banner_activator = TimerActivator(signals=('on_show_record', 'on_hide_record'), delay=HMI_TV.get('record_banner_period', 5))
INSTANT_RECORD_NAME_PATTERN = _('%(date)s %(channel)s %(start_time)s - %(end_time)s')
_EMPTY_RECORD_TIMESHIFT_PROGRAM_BAR = dict(live=0, direct=0, program_begin=0, program_end=100, timeshift_begin=0, timeshift_end=0, record_begin=None, record_end=None)
class TVPlayer(Player):
	def could_remove_banner(self):
		if 0 < abs(self._speed):
			pass
		else:
			abs(self._speed)
		if 0 < abs(self._speed):
			pass
		return 0 < abs(self._speed)

	def __init__(self, player=None, type='tvplayer'):
		Player.__init__(self, type, universe='tv')
		self.eventhandler = TVEventHandler(self)
		self._getitems_keywords.update(dict(clock=(lambda : None), channel_name=(lambda : self.player_info['channel_name']), channel_type=(lambda : self.player_info['channel_type']), program_name=(lambda : self.player_info['program_name']), program_content=(lambda : self.player_info['program_content']), program_start_time=(lambda : self.player_info['program_start_time']), program_stop_time=(lambda : self.player_info['program_stop_time']), program_duration=(lambda : self.player_info['program_duration']), program_remaining_time=(lambda : self.player_info['program_remaining_time']), program_elapsed_time=(lambda : self.player_info['program_elapsed_time']), live_time=(lambda : seconds_to_hhmm(self.real_utc_time)), rec_duration=(lambda : self.player_info['rec_duration']), rec_elapsed_time=(lambda : self.player_info['rec_elapsed_time']), rec_remaining_time=(lambda : self.player_info['rec_remaining_time']), rec_status=(lambda : self.player_info['rec_status']), foreign_rec_status=(lambda : self.player_info['foreign_rec_status']), foreign_rec_channel_name=(lambda : self.player_info['foreign_rec_channel_name']), record_timeshift_programbar=self.get_record_timeshift_programbar, speed=(lambda : ._speed not in f_list([0, 1]):
			pass
		return ''), videoformat_16_9_icon=(lambda : self.player_info['program_videoFormat_16_9']), videoformathd_icon=(lambda : self.player_info['program_videoFormatHD']), nraudiochannels_icon=(lambda : self.player_info['program_nrAudioChannels']), nrsubtitletracks_icon=(lambda : self.player_info['program_nrSubtitleTracks']), subtitlehardofhearing_icon=(lambda : self.player_info['program_subtitleHardOfHearing']), audiohardofhearing_icon=(lambda : self.player_info['program_audioHardOfHearing']), audiovisuallyimpaired_icon=(lambda : self.player_info['program_audioVisuallyImpaired']), freecamode_icon=(lambda : self.player_info['program_freeCaMode']), maturity_rating_icon=(lambda : self.player_info['program_maturity_rating'])))
		_wyrec = WyRecord()
		self.live_controller = _wyrec.getLiveController(player)
		self.record_scheduler = _wyrec.scheduler
		callbacks = _wyrec.callbacks
		callbacks.new_present_epg.register(self.new_present_epg_handler)
		callbacks.disk_space_alert.register(self.disk_space_alert_handler)
		callbacks.start_playing.register(self.start_playing_event_handler)
		self._new_present_epg_task = Task(self._new_present_epg_handler)
		self._speed_change_task = Task(self._speed_change_event_handler)
		self._scrambled_change_task = Task(self._scrambled_change_event_handler)
		self._record = None
		self._conflicting_rec = None
		self._foreign_rec = None
		def _build_navigator():
			self._navigator = TvNavigatorMenu(_('EPG Navigator Menu'), player=self, fill_root=False, type='tv_navigator')

		Task(_build_navigator).start(0.01)
		self._last_scrambled_status = None
		self.code_check = None
		self.shielded = False
		self.previously_muted = False
		self._favorite_list = TVRootItem().get_acl(self)
		self._TVPlayer__zap_timer = Task(self.zap)
		self._tick_can_refresh = False
		self._speed = 1
		self.program = None
		self.player_info = {}
		self._initialize_program_info()
		self._initialize_record_info()
		return None

	_get_time_info = cache_result(validity=1)()
	def tick_callback(self):
		if self._tick_can_refresh:
			program, time_info = self.program, self._get_time_info()
			utc_time = time_info.current_time
			if program:
				self.player_info['program_remaining_time'] = seconds_to_hhmm_utc(max(0, program['scheduledEndTime'] - utc_time))
				self.player_info['program_elapsed_time'] = seconds_to_hhmm_utc(utc_time - program['scheduledStartTime'])
			else:
				elapsed = utc_time - time_info.min_available_time
				timeshift_duration = user_config['tv']['timeshift_length'] * 60
				self.player_info['program_remaining_time'] = seconds_to_hhmm_utc(timeshift_duration - elapsed)
				self.player_info['program_elapsed_time'] = seconds_to_hhmm_utc(elapsed)
			if self._record:
				real_utc_time = self.real_utc_time
				self.player_info['rec_elapsed_time'] = seconds_to_hhmm_utc(real_utc_time - self._record.start_time)
				self.player_info['rec_remaining_time'] = seconds_to_hhmm_utc(max(0, self._record.stop_time + self._record.stop_padding - real_utc_time))
			else:
				self.player_info['rec_elapsed_time'], self.player_info['rec_remaining_time'] = '--:--', '--:--'
			for key in ('program_duration', 'program_elapsed_time', 'program_remaining_time', 'record_timeshift_programbar', 'rec_duration', 'rec_elapsed_time', 'rec_remaining_time', 'status_icon'):
				louie_send(key, sender=self, value=self[key])

	def on_foreground(self):
		Player.on_foreground(self)
		chan = self.selected
		try:
			items = self._favorite_list.browse()
			if not items:
				raise ValueError('Current favorite is empty')

	def get_subtitles(self):
		subtitles_list = [{'lang': _('OFF'), 'id': -1}] + self.live_controller.slist()
		sid = self.live_controller.sid

	def set_subtitle(self, sid):
		self.live_controller.wyplayer.sid = sid

	def get_audio_substreams(self):
		audiostreams_list = self.live_controller.alist()
		aid = self.live_controller.wyplayer.aid

	def set_audio_substream(self, aid):
		self.live_controller.wyplayer.aid = aid

	def _get_aspect_ratio(self):
		return self.live_controller.wyplayer.aspect_ratio

	def _set_aspect_ratio(self, aspect_ratio):
		log.info('Setting aspect ratio to %s', aspect_ratio)
		self.live_controller.wyplayer.aspect_ratio = aspect_ratio

	aspect_ratio = property(_get_aspect_ratio, _set_aspect_ratio, doc="The player's aspect ratio (4_3 or 16_9)")
	def _get_display_format(self):
		return self.live_controller.wyplayer.display_format

	def _set_display_format(self, display_format):
		log.info('Setting display format to %s', display_format)
		self.live_controller.wyplayer.display_format = display_format

	display_format = property(_get_display_format, _set_display_format, doc="The player's display format (for use when the stream's aspect ratio differs from that of the display)")
	def _shield(self):
		louie_send('hide_screen', sender=self)
		mix = Mix()
		self.previously_muted = mix.get_mute()
		mix.set_mute(True)
		self.shielded = True

	def _unshield(self):
		louie_send('show_screen', sender=self)
		Mix().set_mute(self.previously_muted)
		if self.code_check in pygui_globs['menustack'].menus_stack:
			self.code_check.hide()
		self.code_check = None
		self.shielded = False
		return None

	def prompt_for_pin(self):
		self.code_check = SecretCodeCheckMenu(name=_('Check PIN Code'), action=self._pin_ok, cancel_action=self._pin_nok)
		self.code_check.show()

	def _pin_ok(self):
		user_config['security']['parent_mode'] = True
		user_config.save()
		self._unshield()

	def _pin_nok(self):
		self.code_check.hide()

	def _update_tracks_info(self):
		if len(self.live_controller.alist()) > 1:
			pass
		self.player_info['program_nrAudioChannels'] = None
		if len(self.live_controller.slist()) > 0:
			pass
		self.player_info['program_nrSubtitleTracks'] = None
		if len(self.live_controller.vlist()) > 0:
			stream_info = self.live_controller.vlist()[0]
			if len(stream_info) > 0 and stream_info['height'] >= 720:
				pass
			self.player_info['program_videoFormatHD'] = None
		else:
			self.player_info['program_videoFormatHD'] = None
		for key in ('nrSubtitleTracks', 'nrAudioChannels', 'videoFormatHD'):
			louie_send('%s_icon' % key.lower(), sender=self, value=self.player_info['program_' + key])
		return None

	_new_present_epg_handler = selective_gui_updater('program_name', 'program_start_time', 'program_stop_time', 'program_duration', 'program_content', 'maturity_rating_icon')()
	def new_present_epg_handler(self, *args, **args):
		self._new_present_epg_task.args = args
		self._new_present_epg_task.kw = kw
		self._new_present_epg_task.start(-0.10000000000000001)

	def _disk_space_alert_handler(self, needed_space, available_space, timeshift_ratio):
		log.warn('DISK SPACE ALERT: %s %s', needed_space, available_space)
		message = _('Disk space is running low.')
		title = _('Disk space warning')
		if available_space <= 0:
			message = _('Disk space has run out. Timeshift and recordings have been disabled.')
		else:
			message_pattern = _('Maximum timeshift duration has been reduced to %(duration)s.')
			message = message_pattern % {'duration': '%i%%' % timeshift_ratio}
		MessageWindow(message, title, button=None).show(timeout=5)
		return None

	def disk_space_alert_handler(self, *args, **args):
		return Task(self._disk_space_alert_handler, *args, **kw).start(0.10000000000000001)

	_recording_event_handler = selective_gui_updater('record_timeshift_programbar')()
	def recording_event_handler(self, *args, **args):
		return Task(self._recording_event_handler, *args, **kw).start(0.20000000000000001)

	_start_playing_event_handler = info_banner_activator(selective_gui_updater('channel_name', 'channel_type', 'speed', 'status')())
	def start_playing_event_handler(self, *args, **args):
		return Task(self._start_playing_event_handler, *args, **kw).start(0.050000000000000003)

	def _device_signal_event_handler(self, device_id, signal_status):
		if device_id != self.live_controller.getCurrentlive().deviceid:
			log.info('Signal changed on other device -- ignoring...')
		if signal_status:
			log.info('Acquired signal on device %s', device_id)
			louie_send('signal_acquired', sender=self)
		else:
			log.info('Lost signal on device %s', device_id)
			louie_send('signal_lost', sender=self)

	def device_signal_event_handler(self, *args, **args):
		return Task(self._device_signal_event_handler, *args, **kw).start(0.10000000000000001)

	def _service_added(self, service_info):
		log.info('Added service %s', service_info)
		title = _('New service detected')
		text = _('%(channel_name)s added on channel #%(channel_number)i.') % service_info
		MessageWindow(text, title, button=None).show(timeout=5)
		return None

	def _service_updated(self, service_info):
		log.info('Updated service %s', service_info)

	def _service_removed(self, service_info):
		log.info('Removed service %s', service_info)
		if int(self.selected['serviceId']) == service_info['service_id']:
			self.select(1)
		title = _('Service removed')
		text = _('%(channel_name)s is not available anymore.') % service_info
		MessageWindow(text, title, button=None).show(timeout=5)
		return None

	def _service_update_event_handler(self, device, service_info_list, tp_info):
		dispatch = {UPDATE_SERVICE_ADDED: self._service_added, UPDATE_SERVICE_UPDATED: self._service_updated, UPDATE_SERVICE_REMOVED: self._service_removed}
		for service in service_info_list:
			service_info = dict(zip(('service_id', 'channel_name', 'channel_number', 'channel_type'), service[0:3]))
			dispatch[service[4]](service_info)

	def service_update_event_handler(self, *args, **args):
		return Task(self._service_update_event_handler, *args, **kw).start(0.10000000000000001)

	_speed_change_event_handler = selective_gui_updater('status_icon', 'speed')()
	def speed_change_event_handler(self, *args, **args):
		self._speed_change_task.args = args
		self._speed_change_task.kw = kw
		self._speed_change_task.start(0.10000000000000001)

	_scrambled_change_event_handler = info_banner_activator()
	def scrambled_change_event_handler(self, *args, **args):
		self._scrambled_change_task.args = args
		self._scrambled_change_task.kw = kw
		self._scrambled_change_task.start(0.10000000000000001)

	_set_livecontroller_speed = tasked(0.5)()
	_set_speed = selective_gui_updater('speed', 'status_icon')(info_banner_activator())
	def _get_speed(self):
		return self._speed

	speed = property(_get_speed, _set_speed)
	del _get_speed
	del _set_speed
	def get_channel_name(self):
		channel = self.selected
		if channel is None:
			return u''
		title = u'%02i %s' % (int(channel['logical_channel_number']), channel.name)
		return ellipsize(title, 20)

	def get_channel_type(self):
		channel = self.selected
		if channel is None:
			return None
		return '%s.png' % channel.display_type

	def get_seek_step(self):
		time_info = self._get_time_info()
		if not (time_info.max_available_time - time_info.min_available_time) / 10.0:
			pass
		return (time_info.max_available_time - time_info.min_available_time) / 10.0

	def get_record_timeshift_programbar(self, record=None):
		_lc = self.live_controller
		time_info = self._get_time_info()
		direct = time_info.max_available_time
		if self.program:
			begin = self.program['scheduledStartTime']
			end = self.program['scheduledEndTime']
		else:
			begin = time_info.min_available_time
			end = begin + user_config['tv']['timeshift_length'] * 60
		if self._record:
			pass
		if self._record:
			pass
		return dict(live=time_info.current_time, direct=direct, timeshift_begin=time_info.min_available_time, timeshift_end=direct, program_begin=begin, program_end=end, record_begin=None, record_end=None)

	def _get_status(self):
		if self.live_controller.status in ('loading', 'idle'):
			return 'loading'
		speed = self._speed
		if speed == 1:
			try:
				if self.live_controller.default_renderer.isPlayingOnlive():
					return 'live'
				else:
					return 'timeshift'
			except Exception, e:
				return 'unknown'
		if speed == 0:
			return 'pause'
		if -1 <= speed:
			pass
		else:
			speed
		if -1 <= speed:
			return 'slow_motion_rewind'
		if 0 < speed:
			pass
		else:
			speed
		if 0 < speed:
			return 'slow_motion_forward'
		if speed > 1:
			return forward_tricks_icons[self.eventhandler.forward_steps.index(speed)]
		if speed < -1:
			return backward_tricks_icons[self.eventhandler.backward_steps.index(speed)]

	def _request_channel(self, req_channel=None, req_favorite=None):
		if req_favorite:
			favorite = req_favorite
		else:
			if self._favorite_list:
				favorite = self._favorite_list
			else:
				favorite = TVRootItem().get_acl(self)
		try:
			playlist = favorite.browse()
		except BrowseError:
			log.info('Cannot browse requested favorite -- falling back to the ACL')
			favorite = TVRootItem().get_acl(self)
			playlist = favorite.browse()
		if not req_channel or req_channel.name not in favorite:
			lzs = self._last_zap_service
			if lzs is not None and lzs.parent == favorite and lzs.name in favorite:
				channel = lzs
				log.info('Falling back to previous service: %s', channel)
			else:
				channel = playlist[0]
				if channel['class'].endswith('videoCapture') and len(playlist) > 1:
					channel = playlist[1]
				log.info('Falling back to first service in playlist %s: %s', playlist, channel)
		else:
			channel = req_channel
		return (channel, favorite, playlist)

	def can_zap(self):
		return self.live_controller.canZap()

	play = info_banner_activator(selective_gui_updater('channel_name', 'channel_type')())
	def stop(self):
		self._TVPlayer__zap_timer.stop()
		info_banner_activator.force_ending()
		record_banner_activator.force_ending()
		self._initialize_record_info()
		self._initialize_program_info()
		callbacks = WyRecord().callbacks
		callbacks.device_signal.unregister(self.device_signal_event_handler)
		callbacks.service_update.unregister(self.service_update_event_handler)
		callbacks.recording_event.unregister(self.recording_event_handler)
		for i in ('speed', 'scrambled'):
			self.live_controller.watch_property(i, None)
		Player.stop(self)
		try:
			self.live_controller.close()
		except LiveIsRecordingErrors:
			pass
		if self.shielded:
			self._unshield()
		return None

	def _initialize_record_info(self):
		player_info = self.player_info
		player_info['rec_status'] = None
		player_info['rec_duration'] = '--:--'
		player_info['rec_remaining_time'] = '--:--'
		player_info['rec_elapsed_time'] = '--:--'
		player_info['foreign_rec_status'] = None
		player_info['foreign_rec_channel_name'] = ''
		return None

	def _initialize_program_info(self):
		timeshift_duration = user_config['tv']['timeshift_length'] * 60
		utc_time = time()
		player_info = self.player_info
		player_info['program_name'] = ''
		player_info['program_content'] = ''
		player_info['program_start_time'] = seconds_to_hhmm(utc_time)
		player_info['program_stop_time'] = seconds_to_hhmm(utc_time + timeshift_duration)
		player_info['program_duration'] = seconds_to_hhmm_utc(timeshift_duration)
		player_info['program_remaining_time'] = seconds_to_hhmm_utc(timeshift_duration)
		player_info['program_elapsed_time'] = '00:00'
		player_info['program_videoFormat_16_9'] = None
		player_info['program_videoFormatHD'] = None
		player_info['program_nrAudioChannels'] = None
		player_info['program_nrSubtitleTracks'] = None
		player_info['program_subtitleHardOfHearing'] = None
		player_info['program_audioHardOfHearing'] = None
		player_info['program_audioVisuallyImpaired'] = None
		player_info['program_freeCaMode'] = None
		player_info['program_maturity_rating'] = None
		return None

	clear_info_banner = selective_gui_updater('program_name', 'program_start_time', 'program_stop_time', 'maturity_rating_icon', 'program_content', 'program_duration', 'program_elapsed_time', 'program_remaining_time', 'rec_status')()
	select = selective_gui_updater('channel_name', 'channel_type')(info_banner_activator())
	def toggle_menu(self):
		self._navigator.select_program(self._favorite_list, self.selected)
		ms = pygui_globs['menustack']
		if self._navigator not in ms.menus_stack:
			self._navigator.show()
			louie_send('show_program_info', sender=self._navigator)
			louie_send('empty_preview', sender=self._navigator)
			louie_send('hide_preview_program_bar', sender=self._navigator)
			louie_send('show_program_bar', sender=self._navigator)
		else:
			ms.toggle()
			self._navigator.show_help()
		record_banner_activator.force_ending()
		info_banner_activator.force_ending()

	real_utc_time = property()
	timeshift_utc_time = property()
	def zap(self, item=None):
		if not item:
			pass
		item = item
		service_id = int(item['serviceId'])
		current_live = self.live_controller.getCurrentlive(True)
		if current_live and current_live.serviceid == service_id and self.program:
			self.new_present_epg_handler(self.program.wymedia_resource, None)
		else:
			self.program = None

	start_recording = selective_gui_updater('record_timeshift_programbar')()
	stop_recording = selective_gui_updater('rec_duration', 'rec_status', 'rec_remaining_time', 'record_timeshift_programbar')()
	_prompt_stop_record = record_banner_activator(selective_gui_updater('rec_duration', 'rec_remaining_time')())
	def _prompt_stop_foreign_rec(self):
		record = self._foreign_rec
		message_pattern = _('A recording is in progress on channel %(channel)s. %(remaining_time)s remaining. Stop it?')
		data = {'channel': record.service_name, 'remaining_time': seconds_to_hhmm_utc(max(0, record.stop_time + record.stop_padding - self.real_utc_time))}
		messbox = ConfirmWindow(text=message_pattern % data, confirm_action=self.stop_recording, confirm_args=[record])
		messbox.show()

	set_record_duration = record_banner_activator(info_banner_activator(selective_gui_updater('rec_duration', 'rec_remaining_time', 'record_timeshift_programbar')()))
	def _get_record(self):
		current_live = self.live_controller.current_live
		if current_live:
			self._record = current_live.current_rec

	update_record_info = selective_gui_updater('rec_status', 'foreign_rec_status', 'foreign_rec_channel_name', 'rec_duration', 'rec_remaining_time', 'rec_elapsed_time')()
	def resume(self):
		self.live_controller.resume()
		self._speed = 1

	def pause(self):
		self.live_controller.pause()
		self._speed = 0

	action_seek = info_banner_activator(selective_gui_updater('status_icon')())
	action_rec = selective_gui_updater('rec_duration', 'rec_remaining_time')()
	action_play_pause = info_banner_activator(selective_gui_updater('speed', 'status_icon')())
	def action_info(self, refresh=False):
		if info_banner_activator._timer and info_banner_activator._timer.running and not refresh:
			info_banner_activator.force_ending()
		else:
			info_banner_activator((lambda self: None))(self)

	def action_stop(self):
		self.update_record_info()
		if self._record:
			self._prompt_stop_record()
		else:
			if self._foreign_rec:
				self._prompt_stop_foreign_rec()

	def action_vertical(self, offset):
		inverted = HMI_TV['invert_y_axis']
		if record_banner_activator._timer.running:
			if self._record is not None:
				self.set_record_duration(offset * HMI_TV['record_duration_step'])
				self.player_info['rec_duration'] = self._record
		else:
			if self.can_zap():
				if inverted:
					pass
				self.select(offset)
			else:
				title = _('A recording is in progress.')
				message = _('Stop the recording before changing channels.')
				MessageWindow(message, title, button=None).show(timeout=5)
		return None

	def schedule_record(self):
		from pygui.menu.menu.tv.scheduled_record import ScheduledRecordMenu
		_loading = LoadingWindow()
		_loading.show()
		menu = ScheduledRecordMenu()
		menu.select_channel(self.selected, self._favorite_list)
		date = self.real_utc_time
		menu.select_date(date, date + 3600)
		menu.show()
		_loading.hide()

	def display_epg(self):
		from pygui.menu.menu.tv.epg_grid import EpgGridMenu
		menu = EpgGridMenu(player=self, channel_list=self._favorite_list, selected_chan=self.selected)
		menu.show()

	zapping_rollback = gui_updater()
	def clear_last_zap(self):
		self._last_zap_service, self._favorite_list = None, None
		user_config['tv']['last_favorite_name'] = u'all_channels_list'
		user_config['tv']['last_channel_index'] = None
		Task(user_config.save).start(1)
		return None

	def goto_schedule_record(self):
		ms = pygui_globs['menustack']
		if self._navigator not in ms.menus_stack:
			self._navigator.show(hide_previous_menu=False)
			self._navigator.select_schedule_recordings()
		else:
			ms.toggle()
			self._navigator.select_schedule_recordings()



]:
	i: 62(), 78()
	o: 

nname: 78
n 78(None)[]:
	i: 0(f)
	o: 79()

nname: 62
n 62(None)[raise ImportError('TV is disabled')
]:
	i: 0(t)
	o: 79()

nname: 0
n 0('tv' not in plugins)[from __future__ import absolute_import
from pygui.config import HMI_TV, add_tv_info_banner_idle_events, user_config, plugins
]:
	i: 
	o: 62(t), 78(f)

nname: 0
n 0(None)[from __future__ import absolute_import
from pygui.config import HMI_TV, add_tv_info_banner_idle_events, user_config, plugins
if 'tv' not in plugins:
	raise ImportError('TV is disabled')
from time import localtime, strftime, time
from wymedia.wmplus import BrowseError
from wyrecord import WyRecord
from wyrecord import RECORDING_EVENT_RECORD_STARTED, RECORDING_EVENT_RECORD_STOPPED, RECORDING_EVENT_RECORD_START_ERROR, RECORDING_EVENT_RECORD_GOING_TO_START, RECORDING_TYPE_NOT_SCHEDULED, RECORDING_EVENT_RECORD_DISK_SPACE_START_ERROR, RECORDING_EVENT_RECORD_MACROVISION_START_ERROR, RECORDING_EVENT_RECORD_MACROVISION_STOP_ERROR
from wyrecord.callbacks import UPDATE_SERVICE_ADDED, UPDATE_SERVICE_UPDATED, UPDATE_SERVICE_REMOVED
from wyrecord.exceptions import LiveIsRecordingErrors, LiveInConflictError, DefaultLiveControllerError, NoLiveAvailableError, StartingLiveErrors, StartLivePlayingErrors, NoDeviceForServiceErrors, SchedulingFailedOnConflictErrors, SchedulingDoneWithConflictErrors, SchedulingFailedOnDiskSpaceErrors
from peewee.debug import GET_LOGGER, PRINT_EXCEPTION
from peewee.cache_utils import cache_result
from peewee.formatters import ellipsize, seconds_to_hhmm, seconds_to_hhmm_utc
from peewee.messages import send as louie_send
from peewee.notifier import Task, tasked
from peewee.ranges import f_list
from pygui.eventmanager.players import TVEventHandler
from pygui.facilities.codemapping import country_dict, player_aspect_ratio_dict
from pygui.facilities.l10n import get_date_format
from pygui.facilities.mixer import Mix
from pygui.item.core import Item
from pygui.item.mediaitem.tv import TVRootItem, ProgramItem
from pygui.shared import pygui_globs
from pygui.menu import gui_updater, selective_gui_updater
from pygui.menu.menu.security import SecretCodeCheckMenu
from pygui.menu.menu.tv.navigator import TvNavigatorMenu
from pygui.menu.players.core import Player, TimerActivator
from pygui.window import ConfirmWindow, LoadingWindow, MessageWindow
from . import forward_tricks_icons, backward_tricks_icons
log = GET_LOGGER(__name__)
info_banner_activator = TimerActivator(signals=('on_user_event', 'on_user_idle'), delay=HMI_TV.get('banner_period', 2), _check=not add_tv_info_banner_idle_events)
record_banner_activator = TimerActivator(signals=('on_show_record', 'on_hide_record'), delay=HMI_TV.get('record_banner_period', 5))
INSTANT_RECORD_NAME_PATTERN = _('%(date)s %(channel)s %(start_time)s - %(end_time)s')
_EMPTY_RECORD_TIMESHIFT_PROGRAM_BAR = dict(live=0, direct=0, program_begin=0, program_end=100, timeshift_begin=0, timeshift_end=0, record_begin=None, record_end=None)
class TVPlayer(Player):
	def could_remove_banner(self):
		if 0 < abs(self._speed):
			pass
		else:
			abs(self._speed)
		if 0 < abs(self._speed):
			pass
		return 0 < abs(self._speed)

	def __init__(self, player=None, type='tvplayer'):
		Player.__init__(self, type, universe='tv')
		self.eventhandler = TVEventHandler(self)
		self._getitems_keywords.update(dict(clock=(lambda : None), channel_name=(lambda : self.player_info['channel_name']), channel_type=(lambda : self.player_info['channel_type']), program_name=(lambda : self.player_info['program_name']), program_content=(lambda : self.player_info['program_content']), program_start_time=(lambda : self.player_info['program_start_time']), program_stop_time=(lambda : self.player_info['program_stop_time']), program_duration=(lambda : self.player_info['program_duration']), program_remaining_time=(lambda : self.player_info['program_remaining_time']), program_elapsed_time=(lambda : self.player_info['program_elapsed_time']), live_time=(lambda : seconds_to_hhmm(self.real_utc_time)), rec_duration=(lambda : self.player_info['rec_duration']), rec_elapsed_time=(lambda : self.player_info['rec_elapsed_time']), rec_remaining_time=(lambda : self.player_info['rec_remaining_time']), rec_status=(lambda : self.player_info['rec_status']), foreign_rec_status=(lambda : self.player_info['foreign_rec_status']), foreign_rec_channel_name=(lambda : self.player_info['foreign_rec_channel_name']), record_timeshift_programbar=self.get_record_timeshift_programbar, speed=(lambda : ._speed not in f_list([0, 1]):
			pass
		return ''), videoformat_16_9_icon=(lambda : self.player_info['program_videoFormat_16_9']), videoformathd_icon=(lambda : self.player_info['program_videoFormatHD']), nraudiochannels_icon=(lambda : self.player_info['program_nrAudioChannels']), nrsubtitletracks_icon=(lambda : self.player_info['program_nrSubtitleTracks']), subtitlehardofhearing_icon=(lambda : self.player_info['program_subtitleHardOfHearing']), audiohardofhearing_icon=(lambda : self.player_info['program_audioHardOfHearing']), audiovisuallyimpaired_icon=(lambda : self.player_info['program_audioVisuallyImpaired']), freecamode_icon=(lambda : self.player_info['program_freeCaMode']), maturity_rating_icon=(lambda : self.player_info['program_maturity_rating'])))
		_wyrec = WyRecord()
		self.live_controller = _wyrec.getLiveController(player)
		self.record_scheduler = _wyrec.scheduler
		callbacks = _wyrec.callbacks
		callbacks.new_present_epg.register(self.new_present_epg_handler)
		callbacks.disk_space_alert.register(self.disk_space_alert_handler)
		callbacks.start_playing.register(self.start_playing_event_handler)
		self._new_present_epg_task = Task(self._new_present_epg_handler)
		self._speed_change_task = Task(self._speed_change_event_handler)
		self._scrambled_change_task = Task(self._scrambled_change_event_handler)
		self._record = None
		self._conflicting_rec = None
		self._foreign_rec = None
		def _build_navigator():
			self._navigator = TvNavigatorMenu(_('EPG Navigator Menu'), player=self, fill_root=False, type='tv_navigator')

		Task(_build_navigator).start(0.01)
		self._last_scrambled_status = None
		self.code_check = None
		self.shielded = False
		self.previously_muted = False
		self._favorite_list = TVRootItem().get_acl(self)
		self._TVPlayer__zap_timer = Task(self.zap)
		self._tick_can_refresh = False
		self._speed = 1
		self.program = None
		self.player_info = {}
		self._initialize_program_info()
		self._initialize_record_info()
		return None

	_get_time_info = cache_result(validity=1)()
	def tick_callback(self):
		if self._tick_can_refresh:
			program, time_info = self.program, self._get_time_info()
			utc_time = time_info.current_time
			if program:
				self.player_info['program_remaining_time'] = seconds_to_hhmm_utc(max(0, program['scheduledEndTime'] - utc_time))
				self.player_info['program_elapsed_time'] = seconds_to_hhmm_utc(utc_time - program['scheduledStartTime'])
			else:
				elapsed = utc_time - time_info.min_available_time
				timeshift_duration = user_config['tv']['timeshift_length'] * 60
				self.player_info['program_remaining_time'] = seconds_to_hhmm_utc(timeshift_duration - elapsed)
				self.player_info['program_elapsed_time'] = seconds_to_hhmm_utc(elapsed)
			if self._record:
				real_utc_time = self.real_utc_time
				self.player_info['rec_elapsed_time'] = seconds_to_hhmm_utc(real_utc_time - self._record.start_time)
				self.player_info['rec_remaining_time'] = seconds_to_hhmm_utc(max(0, self._record.stop_time + self._record.stop_padding - real_utc_time))
			else:
				self.player_info['rec_elapsed_time'], self.player_info['rec_remaining_time'] = '--:--', '--:--'
			for key in ('program_duration', 'program_elapsed_time', 'program_remaining_time', 'record_timeshift_programbar', 'rec_duration', 'rec_elapsed_time', 'rec_remaining_time', 'status_icon'):
				louie_send(key, sender=self, value=self[key])

	def on_foreground(self):
		Player.on_foreground(self)
		chan = self.selected
		try:
			items = self._favorite_list.browse()
			if not items:
				raise ValueError('Current favorite is empty')

	def get_subtitles(self):
		subtitles_list = [{'lang': _('OFF'), 'id': -1}] + self.live_controller.slist()
		sid = self.live_controller.sid

	def set_subtitle(self, sid):
		self.live_controller.wyplayer.sid = sid

	def get_audio_substreams(self):
		audiostreams_list = self.live_controller.alist()
		aid = self.live_controller.wyplayer.aid

	def set_audio_substream(self, aid):
		self.live_controller.wyplayer.aid = aid

	def _get_aspect_ratio(self):
		return self.live_controller.wyplayer.aspect_ratio

	def _set_aspect_ratio(self, aspect_ratio):
		log.info('Setting aspect ratio to %s', aspect_ratio)
		self.live_controller.wyplayer.aspect_ratio = aspect_ratio

	aspect_ratio = property(_get_aspect_ratio, _set_aspect_ratio, doc="The player's aspect ratio (4_3 or 16_9)")
	def _get_display_format(self):
		return self.live_controller.wyplayer.display_format

	def _set_display_format(self, display_format):
		log.info('Setting display format to %s', display_format)
		self.live_controller.wyplayer.display_format = display_format

	display_format = property(_get_display_format, _set_display_format, doc="The player's display format (for use when the stream's aspect ratio differs from that of the display)")
	def _shield(self):
		louie_send('hide_screen', sender=self)
		mix = Mix()
		self.previously_muted = mix.get_mute()
		mix.set_mute(True)
		self.shielded = True

	def _unshield(self):
		louie_send('show_screen', sender=self)
		Mix().set_mute(self.previously_muted)
		if self.code_check in pygui_globs['menustack'].menus_stack:
			self.code_check.hide()
		self.code_check = None
		self.shielded = False
		return None

	def prompt_for_pin(self):
		self.code_check = SecretCodeCheckMenu(name=_('Check PIN Code'), action=self._pin_ok, cancel_action=self._pin_nok)
		self.code_check.show()

	def _pin_ok(self):
		user_config['security']['parent_mode'] = True
		user_config.save()
		self._unshield()

	def _pin_nok(self):
		self.code_check.hide()

	def _update_tracks_info(self):
		if len(self.live_controller.alist()) > 1:
			pass
		self.player_info['program_nrAudioChannels'] = None
		if len(self.live_controller.slist()) > 0:
			pass
		self.player_info['program_nrSubtitleTracks'] = None
		if len(self.live_controller.vlist()) > 0:
			stream_info = self.live_controller.vlist()[0]
			if len(stream_info) > 0 and stream_info['height'] >= 720:
				pass
			self.player_info['program_videoFormatHD'] = None
		else:
			self.player_info['program_videoFormatHD'] = None
		for key in ('nrSubtitleTracks', 'nrAudioChannels', 'videoFormatHD'):
			louie_send('%s_icon' % key.lower(), sender=self, value=self.player_info['program_' + key])
		return None

	_new_present_epg_handler = selective_gui_updater('program_name', 'program_start_time', 'program_stop_time', 'program_duration', 'program_content', 'maturity_rating_icon')()
	def new_present_epg_handler(self, *args, **args):
		self._new_present_epg_task.args = args
		self._new_present_epg_task.kw = kw
		self._new_present_epg_task.start(-0.10000000000000001)

	def _disk_space_alert_handler(self, needed_space, available_space, timeshift_ratio):
		log.warn('DISK SPACE ALERT: %s %s', needed_space, available_space)
		message = _('Disk space is running low.')
		title = _('Disk space warning')
		if available_space <= 0:
			message = _('Disk space has run out. Timeshift and recordings have been disabled.')
		else:
			message_pattern = _('Maximum timeshift duration has been reduced to %(duration)s.')
			message = message_pattern % {'duration': '%i%%' % timeshift_ratio}
		MessageWindow(message, title, button=None).show(timeout=5)
		return None

	def disk_space_alert_handler(self, *args, **args):
		return Task(self._disk_space_alert_handler, *args, **kw).start(0.10000000000000001)

	_recording_event_handler = selective_gui_updater('record_timeshift_programbar')()
	def recording_event_handler(self, *args, **args):
		return Task(self._recording_event_handler, *args, **kw).start(0.20000000000000001)

	_start_playing_event_handler = info_banner_activator(selective_gui_updater('channel_name', 'channel_type', 'speed', 'status')())
	def start_playing_event_handler(self, *args, **args):
		return Task(self._start_playing_event_handler, *args, **kw).start(0.050000000000000003)

	def _device_signal_event_handler(self, device_id, signal_status):
		if device_id != self.live_controller.getCurrentlive().deviceid:
			log.info('Signal changed on other device -- ignoring...')
		if signal_status:
			log.info('Acquired signal on device %s', device_id)
			louie_send('signal_acquired', sender=self)
		else:
			log.info('Lost signal on device %s', device_id)
			louie_send('signal_lost', sender=self)

	def device_signal_event_handler(self, *args, **args):
		return Task(self._device_signal_event_handler, *args, **kw).start(0.10000000000000001)

	def _service_added(self, service_info):
		log.info('Added service %s', service_info)
		title = _('New service detected')
		text = _('%(channel_name)s added on channel #%(channel_number)i.') % service_info
		MessageWindow(text, title, button=None).show(timeout=5)
		return None

	def _service_updated(self, service_info):
		log.info('Updated service %s', service_info)

	def _service_removed(self, service_info):
		log.info('Removed service %s', service_info)
		if int(self.selected['serviceId']) == service_info['service_id']:
			self.select(1)
		title = _('Service removed')
		text = _('%(channel_name)s is not available anymore.') % service_info
		MessageWindow(text, title, button=None).show(timeout=5)
		return None

	def _service_update_event_handler(self, device, service_info_list, tp_info):
		dispatch = {UPDATE_SERVICE_ADDED: self._service_added, UPDATE_SERVICE_UPDATED: self._service_updated, UPDATE_SERVICE_REMOVED: self._service_removed}
		for service in service_info_list:
			service_info = dict(zip(('service_id', 'channel_name', 'channel_number', 'channel_type'), service[0:3]))
			dispatch[service[4]](service_info)

	def service_update_event_handler(self, *args, **args):
		return Task(self._service_update_event_handler, *args, **kw).start(0.10000000000000001)

	_speed_change_event_handler = selective_gui_updater('status_icon', 'speed')()
	def speed_change_event_handler(self, *args, **args):
		self._speed_change_task.args = args
		self._speed_change_task.kw = kw
		self._speed_change_task.start(0.10000000000000001)

	_scrambled_change_event_handler = info_banner_activator()
	def scrambled_change_event_handler(self, *args, **args):
		self._scrambled_change_task.args = args
		self._scrambled_change_task.kw = kw
		self._scrambled_change_task.start(0.10000000000000001)

	_set_livecontroller_speed = tasked(0.5)()
	_set_speed = selective_gui_updater('speed', 'status_icon')(info_banner_activator())
	def _get_speed(self):
		return self._speed

	speed = property(_get_speed, _set_speed)
	del _get_speed
	del _set_speed
	def get_channel_name(self):
		channel = self.selected
		if channel is None:
			return u''
		title = u'%02i %s' % (int(channel['logical_channel_number']), channel.name)
		return ellipsize(title, 20)

	def get_channel_type(self):
		channel = self.selected
		if channel is None:
			return None
		return '%s.png' % channel.display_type

	def get_seek_step(self):
		time_info = self._get_time_info()
		if not (time_info.max_available_time - time_info.min_available_time) / 10.0:
			pass
		return (time_info.max_available_time - time_info.min_available_time) / 10.0

	def get_record_timeshift_programbar(self, record=None):
		_lc = self.live_controller
		time_info = self._get_time_info()
		direct = time_info.max_available_time
		if self.program:
			begin = self.program['scheduledStartTime']
			end = self.program['scheduledEndTime']
		else:
			begin = time_info.min_available_time
			end = begin + user_config['tv']['timeshift_length'] * 60
		if self._record:
			pass
		if self._record:
			pass
		return dict(live=time_info.current_time, direct=direct, timeshift_begin=time_info.min_available_time, timeshift_end=direct, program_begin=begin, program_end=end, record_begin=None, record_end=None)

	def _get_status(self):
		if self.live_controller.status in ('loading', 'idle'):
			return 'loading'
		speed = self._speed
		if speed == 1:
			try:
				if self.live_controller.default_renderer.isPlayingOnlive():
					return 'live'
				else:
					return 'timeshift'
			except Exception, e:
				return 'unknown'
		if speed == 0:
			return 'pause'
		if -1 <= speed:
			pass
		else:
			speed
		if -1 <= speed:
			return 'slow_motion_rewind'
		if 0 < speed:
			pass
		else:
			speed
		if 0 < speed:
			return 'slow_motion_forward'
		if speed > 1:
			return forward_tricks_icons[self.eventhandler.forward_steps.index(speed)]
		if speed < -1:
			return backward_tricks_icons[self.eventhandler.backward_steps.index(speed)]

	def _request_channel(self, req_channel=None, req_favorite=None):
		if req_favorite:
			favorite = req_favorite
		else:
			if self._favorite_list:
				favorite = self._favorite_list
			else:
				favorite = TVRootItem().get_acl(self)
		try:
			playlist = favorite.browse()
		except BrowseError:
			log.info('Cannot browse requested favorite -- falling back to the ACL')
			favorite = TVRootItem().get_acl(self)
			playlist = favorite.browse()
		if not req_channel or req_channel.name not in favorite:
			lzs = self._last_zap_service
			if lzs is not None and lzs.parent == favorite and lzs.name in favorite:
				channel = lzs
				log.info('Falling back to previous service: %s', channel)
			else:
				channel = playlist[0]
				if channel['class'].endswith('videoCapture') and len(playlist) > 1:
					channel = playlist[1]
				log.info('Falling back to first service in playlist %s: %s', playlist, channel)
		else:
			channel = req_channel
		return (channel, favorite, playlist)

	def can_zap(self):
		return self.live_controller.canZap()

	play = info_banner_activator(selective_gui_updater('channel_name', 'channel_type')())
	def stop(self):
		self._TVPlayer__zap_timer.stop()
		info_banner_activator.force_ending()
		record_banner_activator.force_ending()
		self._initialize_record_info()
		self._initialize_program_info()
		callbacks = WyRecord().callbacks
		callbacks.device_signal.unregister(self.device_signal_event_handler)
		callbacks.service_update.unregister(self.service_update_event_handler)
		callbacks.recording_event.unregister(self.recording_event_handler)
		for i in ('speed', 'scrambled'):
			self.live_controller.watch_property(i, None)
		Player.stop(self)
		try:
			self.live_controller.close()
		except LiveIsRecordingErrors:
			pass
		if self.shielded:
			self._unshield()
		return None

	def _initialize_record_info(self):
		player_info = self.player_info
		player_info['rec_status'] = None
		player_info['rec_duration'] = '--:--'
		player_info['rec_remaining_time'] = '--:--'
		player_info['rec_elapsed_time'] = '--:--'
		player_info['foreign_rec_status'] = None
		player_info['foreign_rec_channel_name'] = ''
		return None

	def _initialize_program_info(self):
		timeshift_duration = user_config['tv']['timeshift_length'] * 60
		utc_time = time()
		player_info = self.player_info
		player_info['program_name'] = ''
		player_info['program_content'] = ''
		player_info['program_start_time'] = seconds_to_hhmm(utc_time)
		player_info['program_stop_time'] = seconds_to_hhmm(utc_time + timeshift_duration)
		player_info['program_duration'] = seconds_to_hhmm_utc(timeshift_duration)
		player_info['program_remaining_time'] = seconds_to_hhmm_utc(timeshift_duration)
		player_info['program_elapsed_time'] = '00:00'
		player_info['program_videoFormat_16_9'] = None
		player_info['program_videoFormatHD'] = None
		player_info['program_nrAudioChannels'] = None
		player_info['program_nrSubtitleTracks'] = None
		player_info['program_subtitleHardOfHearing'] = None
		player_info['program_audioHardOfHearing'] = None
		player_info['program_audioVisuallyImpaired'] = None
		player_info['program_freeCaMode'] = None
		player_info['program_maturity_rating'] = None
		return None

	clear_info_banner = selective_gui_updater('program_name', 'program_start_time', 'program_stop_time', 'maturity_rating_icon', 'program_content', 'program_duration', 'program_elapsed_time', 'program_remaining_time', 'rec_status')()
	select = selective_gui_updater('channel_name', 'channel_type')(info_banner_activator())
	def toggle_menu(self):
		self._navigator.select_program(self._favorite_list, self.selected)
		ms = pygui_globs['menustack']
		if self._navigator not in ms.menus_stack:
			self._navigator.show()
			louie_send('show_program_info', sender=self._navigator)
			louie_send('empty_preview', sender=self._navigator)
			louie_send('hide_preview_program_bar', sender=self._navigator)
			louie_send('show_program_bar', sender=self._navigator)
		else:
			ms.toggle()
			self._navigator.show_help()
		record_banner_activator.force_ending()
		info_banner_activator.force_ending()

	real_utc_time = property()
	timeshift_utc_time = property()
	def zap(self, item=None):
		if not item:
			pass
		item = item
		service_id = int(item['serviceId'])
		current_live = self.live_controller.getCurrentlive(True)
		if current_live and current_live.serviceid == service_id and self.program:
			self.new_present_epg_handler(self.program.wymedia_resource, None)
		else:
			self.program = None

	start_recording = selective_gui_updater('record_timeshift_programbar')()
	stop_recording = selective_gui_updater('rec_duration', 'rec_status', 'rec_remaining_time', 'record_timeshift_programbar')()
	_prompt_stop_record = record_banner_activator(selective_gui_updater('rec_duration', 'rec_remaining_time')())
	def _prompt_stop_foreign_rec(self):
		record = self._foreign_rec
		message_pattern = _('A recording is in progress on channel %(channel)s. %(remaining_time)s remaining. Stop it?')
		data = {'channel': record.service_name, 'remaining_time': seconds_to_hhmm_utc(max(0, record.stop_time + record.stop_padding - self.real_utc_time))}
		messbox = ConfirmWindow(text=message_pattern % data, confirm_action=self.stop_recording, confirm_args=[record])
		messbox.show()

	set_record_duration = record_banner_activator(info_banner_activator(selective_gui_updater('rec_duration', 'rec_remaining_time', 'record_timeshift_programbar')()))
	def _get_record(self):
		current_live = self.live_controller.current_live
		if current_live:
			self._record = current_live.current_rec

	update_record_info = selective_gui_updater('rec_status', 'foreign_rec_status', 'foreign_rec_channel_name', 'rec_duration', 'rec_remaining_time', 'rec_elapsed_time')()
	def resume(self):
		self.live_controller.resume()
		self._speed = 1

	def pause(self):
		self.live_controller.pause()
		self._speed = 0

	action_seek = info_banner_activator(selective_gui_updater('status_icon')())
	action_rec = selective_gui_updater('rec_duration', 'rec_remaining_time')()
	action_play_pause = info_banner_activator(selective_gui_updater('speed', 'status_icon')())
	def action_info(self, refresh=False):
		if info_banner_activator._timer and info_banner_activator._timer.running and not refresh:
			info_banner_activator.force_ending()
		else:
			info_banner_activator((lambda self: None))(self)

	def action_stop(self):
		self.update_record_info()
		if self._record:
			self._prompt_stop_record()
		else:
			if self._foreign_rec:
				self._prompt_stop_foreign_rec()

	def action_vertical(self, offset):
		inverted = HMI_TV['invert_y_axis']
		if record_banner_activator._timer.running:
			if self._record is not None:
				self.set_record_duration(offset * HMI_TV['record_duration_step'])
				self.player_info['rec_duration'] = self._record
		else:
			if self.can_zap():
				if inverted:
					pass
				self.select(offset)
			else:
				title = _('A recording is in progress.')
				message = _('Stop the recording before changing channels.')
				MessageWindow(message, title, button=None).show(timeout=5)
		return None

	def schedule_record(self):
		from pygui.menu.menu.tv.scheduled_record import ScheduledRecordMenu
		_loading = LoadingWindow()
		_loading.show()
		menu = ScheduledRecordMenu()
		menu.select_channel(self.selected, self._favorite_list)
		date = self.real_utc_time
		menu.select_date(date, date + 3600)
		menu.show()
		_loading.hide()

	def display_epg(self):
		from pygui.menu.menu.tv.epg_grid import EpgGridMenu
		menu = EpgGridMenu(player=self, channel_list=self._favorite_list, selected_chan=self.selected)
		menu.show()

	zapping_rollback = gui_updater()
	def clear_last_zap(self):
		self._last_zap_service, self._favorite_list = None, None
		user_config['tv']['last_favorite_name'] = u'all_channels_list'
		user_config['tv']['last_channel_index'] = None
		Task(user_config.save).start(1)
		return None

	def goto_schedule_record(self):
		ms = pygui_globs['menustack']
		if self._navigator not in ms.menus_stack:
			self._navigator.show(hide_previous_menu=False)
			self._navigator.select_schedule_recordings()
		else:
			ms.toggle()
			self._navigator.select_schedule_recordings()



]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb74745cc>}
from __future__ import absolute_import
from pygui.config import HMI_TV, add_tv_info_banner_idle_events, user_config, plugins
if 'tv' not in plugins:
	raise ImportError('TV is disabled')
from time import localtime, strftime, time
from wymedia.wmplus import BrowseError
from wyrecord import WyRecord
from wyrecord import RECORDING_EVENT_RECORD_STARTED, RECORDING_EVENT_RECORD_STOPPED, RECORDING_EVENT_RECORD_START_ERROR, RECORDING_EVENT_RECORD_GOING_TO_START, RECORDING_TYPE_NOT_SCHEDULED, RECORDING_EVENT_RECORD_DISK_SPACE_START_ERROR, RECORDING_EVENT_RECORD_MACROVISION_START_ERROR, RECORDING_EVENT_RECORD_MACROVISION_STOP_ERROR
from wyrecord.callbacks import UPDATE_SERVICE_ADDED, UPDATE_SERVICE_UPDATED, UPDATE_SERVICE_REMOVED
from wyrecord.exceptions import LiveIsRecordingErrors, LiveInConflictError, DefaultLiveControllerError, NoLiveAvailableError, StartingLiveErrors, StartLivePlayingErrors, NoDeviceForServiceErrors, SchedulingFailedOnConflictErrors, SchedulingDoneWithConflictErrors, SchedulingFailedOnDiskSpaceErrors
from peewee.debug import GET_LOGGER, PRINT_EXCEPTION
from peewee.cache_utils import cache_result
from peewee.formatters import ellipsize, seconds_to_hhmm, seconds_to_hhmm_utc
from peewee.messages import send as louie_send
from peewee.notifier import Task, tasked
from peewee.ranges import f_list
from pygui.eventmanager.players import TVEventHandler
from pygui.facilities.codemapping import country_dict, player_aspect_ratio_dict
from pygui.facilities.l10n import get_date_format
from pygui.facilities.mixer import Mix
from pygui.item.core import Item
from pygui.item.mediaitem.tv import TVRootItem, ProgramItem
from pygui.shared import pygui_globs
from pygui.menu import gui_updater, selective_gui_updater
from pygui.menu.menu.security import SecretCodeCheckMenu
from pygui.menu.menu.tv.navigator import TvNavigatorMenu
from pygui.menu.players.core import Player, TimerActivator
from pygui.window import ConfirmWindow, LoadingWindow, MessageWindow
from . import forward_tricks_icons, backward_tricks_icons
log = GET_LOGGER(__name__)
info_banner_activator = TimerActivator(signals=('on_user_event', 'on_user_idle'), delay=HMI_TV.get('banner_period', 2), _check=not add_tv_info_banner_idle_events)
record_banner_activator = TimerActivator(signals=('on_show_record', 'on_hide_record'), delay=HMI_TV.get('record_banner_period', 5))
INSTANT_RECORD_NAME_PATTERN = _('%(date)s %(channel)s %(start_time)s - %(end_time)s')
_EMPTY_RECORD_TIMESHIFT_PROGRAM_BAR = dict(live=0, direct=0, program_begin=0, program_end=100, timeshift_begin=0, timeshift_end=0, record_begin=None, record_end=None)
class TVPlayer(Player):
	def could_remove_banner(self):
		if 0 < abs(self._speed):
			pass
		else:
			abs(self._speed)
		if 0 < abs(self._speed):
			pass
		return 0 < abs(self._speed)

	def __init__(self, player=None, type='tvplayer'):
		Player.__init__(self, type, universe='tv')
		self.eventhandler = TVEventHandler(self)
		self._getitems_keywords.update(dict(clock=(lambda : None), channel_name=(lambda : self.player_info['channel_name']), channel_type=(lambda : self.player_info['channel_type']), program_name=(lambda : self.player_info['program_name']), program_content=(lambda : self.player_info['program_content']), program_start_time=(lambda : self.player_info['program_start_time']), program_stop_time=(lambda : self.player_info['program_stop_time']), program_duration=(lambda : self.player_info['program_duration']), program_remaining_time=(lambda : self.player_info['program_remaining_time']), program_elapsed_time=(lambda : self.player_info['program_elapsed_time']), live_time=(lambda : seconds_to_hhmm(self.real_utc_time)), rec_duration=(lambda : self.player_info['rec_duration']), rec_elapsed_time=(lambda : self.player_info['rec_elapsed_time']), rec_remaining_time=(lambda : self.player_info['rec_remaining_time']), rec_status=(lambda : self.player_info['rec_status']), foreign_rec_status=(lambda : self.player_info['foreign_rec_status']), foreign_rec_channel_name=(lambda : self.player_info['foreign_rec_channel_name']), record_timeshift_programbar=self.get_record_timeshift_programbar, speed=(lambda : ._speed not in f_list([0, 1]):
			pass
		return ''), videoformat_16_9_icon=(lambda : self.player_info['program_videoFormat_16_9']), videoformathd_icon=(lambda : self.player_info['program_videoFormatHD']), nraudiochannels_icon=(lambda : self.player_info['program_nrAudioChannels']), nrsubtitletracks_icon=(lambda : self.player_info['program_nrSubtitleTracks']), subtitlehardofhearing_icon=(lambda : self.player_info['program_subtitleHardOfHearing']), audiohardofhearing_icon=(lambda : self.player_info['program_audioHardOfHearing']), audiovisuallyimpaired_icon=(lambda : self.player_info['program_audioVisuallyImpaired']), freecamode_icon=(lambda : self.player_info['program_freeCaMode']), maturity_rating_icon=(lambda : self.player_info['program_maturity_rating'])))
		_wyrec = WyRecord()
		self.live_controller = _wyrec.getLiveController(player)
		self.record_scheduler = _wyrec.scheduler
		callbacks = _wyrec.callbacks
		callbacks.new_present_epg.register(self.new_present_epg_handler)
		callbacks.disk_space_alert.register(self.disk_space_alert_handler)
		callbacks.start_playing.register(self.start_playing_event_handler)
		self._new_present_epg_task = Task(self._new_present_epg_handler)
		self._speed_change_task = Task(self._speed_change_event_handler)
		self._scrambled_change_task = Task(self._scrambled_change_event_handler)
		self._record = None
		self._conflicting_rec = None
		self._foreign_rec = None
		def _build_navigator():
			self._navigator = TvNavigatorMenu(_('EPG Navigator Menu'), player=self, fill_root=False, type='tv_navigator')

		Task(_build_navigator).start(0.01)
		self._last_scrambled_status = None
		self.code_check = None
		self.shielded = False
		self.previously_muted = False
		self._favorite_list = TVRootItem().get_acl(self)
		self._TVPlayer__zap_timer = Task(self.zap)
		self._tick_can_refresh = False
		self._speed = 1
		self.program = None
		self.player_info = {}
		self._initialize_program_info()
		self._initialize_record_info()
		return None

	_get_time_info = cache_result(validity=1)()
	def tick_callback(self):
		if self._tick_can_refresh:
			program, time_info = self.program, self._get_time_info()
			utc_time = time_info.current_time
			if program:
				self.player_info['program_remaining_time'] = seconds_to_hhmm_utc(max(0, program['scheduledEndTime'] - utc_time))
				self.player_info['program_elapsed_time'] = seconds_to_hhmm_utc(utc_time - program['scheduledStartTime'])
			else:
				elapsed = utc_time - time_info.min_available_time
				timeshift_duration = user_config['tv']['timeshift_length'] * 60
				self.player_info['program_remaining_time'] = seconds_to_hhmm_utc(timeshift_duration - elapsed)
				self.player_info['program_elapsed_time'] = seconds_to_hhmm_utc(elapsed)
			if self._record:
				real_utc_time = self.real_utc_time
				self.player_info['rec_elapsed_time'] = seconds_to_hhmm_utc(real_utc_time - self._record.start_time)
				self.player_info['rec_remaining_time'] = seconds_to_hhmm_utc(max(0, self._record.stop_time + self._record.stop_padding - real_utc_time))
			else:
				self.player_info['rec_elapsed_time'], self.player_info['rec_remaining_time'] = '--:--', '--:--'
			for key in ('program_duration', 'program_elapsed_time', 'program_remaining_time', 'record_timeshift_programbar', 'rec_duration', 'rec_elapsed_time', 'rec_remaining_time', 'status_icon'):
				louie_send(key, sender=self, value=self[key])

	def on_foreground(self):
		Player.on_foreground(self)
		chan = self.selected
		try:
			items = self._favorite_list.browse()
			if not items:
				raise ValueError('Current favorite is empty')

	def get_subtitles(self):
		subtitles_list = [{'lang': _('OFF'), 'id': -1}] + self.live_controller.slist()
		sid = self.live_controller.sid

	def set_subtitle(self, sid):
		self.live_controller.wyplayer.sid = sid

	def get_audio_substreams(self):
		audiostreams_list = self.live_controller.alist()
		aid = self.live_controller.wyplayer.aid

	def set_audio_substream(self, aid):
		self.live_controller.wyplayer.aid = aid

	def _get_aspect_ratio(self):
		return self.live_controller.wyplayer.aspect_ratio

	def _set_aspect_ratio(self, aspect_ratio):
		log.info('Setting aspect ratio to %s', aspect_ratio)
		self.live_controller.wyplayer.aspect_ratio = aspect_ratio

	aspect_ratio = property(_get_aspect_ratio, _set_aspect_ratio, doc="The player's aspect ratio (4_3 or 16_9)")
	def _get_display_format(self):
		return self.live_controller.wyplayer.display_format

	def _set_display_format(self, display_format):
		log.info('Setting display format to %s', display_format)
		self.live_controller.wyplayer.display_format = display_format

	display_format = property(_get_display_format, _set_display_format, doc="The player's display format (for use when the stream's aspect ratio differs from that of the display)")
	def _shield(self):
		louie_send('hide_screen', sender=self)
		mix = Mix()
		self.previously_muted = mix.get_mute()
		mix.set_mute(True)
		self.shielded = True

	def _unshield(self):
		louie_send('show_screen', sender=self)
		Mix().set_mute(self.previously_muted)
		if self.code_check in pygui_globs['menustack'].menus_stack:
			self.code_check.hide()
		self.code_check = None
		self.shielded = False
		return None

	def prompt_for_pin(self):
		self.code_check = SecretCodeCheckMenu(name=_('Check PIN Code'), action=self._pin_ok, cancel_action=self._pin_nok)
		self.code_check.show()

	def _pin_ok(self):
		user_config['security']['parent_mode'] = True
		user_config.save()
		self._unshield()

	def _pin_nok(self):
		self.code_check.hide()

	def _update_tracks_info(self):
		if len(self.live_controller.alist()) > 1:
			pass
		self.player_info['program_nrAudioChannels'] = None
		if len(self.live_controller.slist()) > 0:
			pass
		self.player_info['program_nrSubtitleTracks'] = None
		if len(self.live_controller.vlist()) > 0:
			stream_info = self.live_controller.vlist()[0]
			if len(stream_info) > 0 and stream_info['height'] >= 720:
				pass
			self.player_info['program_videoFormatHD'] = None
		else:
			self.player_info['program_videoFormatHD'] = None
		for key in ('nrSubtitleTracks', 'nrAudioChannels', 'videoFormatHD'):
			louie_send('%s_icon' % key.lower(), sender=self, value=self.player_info['program_' + key])
		return None

	_new_present_epg_handler = selective_gui_updater('program_name', 'program_start_time', 'program_stop_time', 'program_duration', 'program_content', 'maturity_rating_icon')()
	def new_present_epg_handler(self, *args, **args):
		self._new_present_epg_task.args = args
		self._new_present_epg_task.kw = kw
		self._new_present_epg_task.start(-0.10000000000000001)

	def _disk_space_alert_handler(self, needed_space, available_space, timeshift_ratio):
		log.warn('DISK SPACE ALERT: %s %s', needed_space, available_space)
		message = _('Disk space is running low.')
		title = _('Disk space warning')
		if available_space <= 0:
			message = _('Disk space has run out. Timeshift and recordings have been disabled.')
		else:
			message_pattern = _('Maximum timeshift duration has been reduced to %(duration)s.')
			message = message_pattern % {'duration': '%i%%' % timeshift_ratio}
		MessageWindow(message, title, button=None).show(timeout=5)
		return None

	def disk_space_alert_handler(self, *args, **args):
		return Task(self._disk_space_alert_handler, *args, **kw).start(0.10000000000000001)

	_recording_event_handler = selective_gui_updater('record_timeshift_programbar')()
	def recording_event_handler(self, *args, **args):
		return Task(self._recording_event_handler, *args, **kw).start(0.20000000000000001)

	_start_playing_event_handler = info_banner_activator(selective_gui_updater('channel_name', 'channel_type', 'speed', 'status')())
	def start_playing_event_handler(self, *args, **args):
		return Task(self._start_playing_event_handler, *args, **kw).start(0.050000000000000003)

	def _device_signal_event_handler(self, device_id, signal_status):
		if device_id != self.live_controller.getCurrentlive().deviceid:
			log.info('Signal changed on other device -- ignoring...')
		if signal_status:
			log.info('Acquired signal on device %s', device_id)
			louie_send('signal_acquired', sender=self)
		else:
			log.info('Lost signal on device %s', device_id)
			louie_send('signal_lost', sender=self)

	def device_signal_event_handler(self, *args, **args):
		return Task(self._device_signal_event_handler, *args, **kw).start(0.10000000000000001)

	def _service_added(self, service_info):
		log.info('Added service %s', service_info)
		title = _('New service detected')
		text = _('%(channel_name)s added on channel #%(channel_number)i.') % service_info
		MessageWindow(text, title, button=None).show(timeout=5)
		return None

	def _service_updated(self, service_info):
		log.info('Updated service %s', service_info)

	def _service_removed(self, service_info):
		log.info('Removed service %s', service_info)
		if int(self.selected['serviceId']) == service_info['service_id']:
			self.select(1)
		title = _('Service removed')
		text = _('%(channel_name)s is not available anymore.') % service_info
		MessageWindow(text, title, button=None).show(timeout=5)
		return None

	def _service_update_event_handler(self, device, service_info_list, tp_info):
		dispatch = {UPDATE_SERVICE_ADDED: self._service_added, UPDATE_SERVICE_UPDATED: self._service_updated, UPDATE_SERVICE_REMOVED: self._service_removed}
		for service in service_info_list:
			service_info = dict(zip(('service_id', 'channel_name', 'channel_number', 'channel_type'), service[0:3]))
			dispatch[service[4]](service_info)

	def service_update_event_handler(self, *args, **args):
		return Task(self._service_update_event_handler, *args, **kw).start(0.10000000000000001)

	_speed_change_event_handler = selective_gui_updater('status_icon', 'speed')()
	def speed_change_event_handler(self, *args, **args):
		self._speed_change_task.args = args
		self._speed_change_task.kw = kw
		self._speed_change_task.start(0.10000000000000001)

	_scrambled_change_event_handler = info_banner_activator()
	def scrambled_change_event_handler(self, *args, **args):
		self._scrambled_change_task.args = args
		self._scrambled_change_task.kw = kw
		self._scrambled_change_task.start(0.10000000000000001)

	_set_livecontroller_speed = tasked(0.5)()
	_set_speed = selective_gui_updater('speed', 'status_icon')(info_banner_activator())
	def _get_speed(self):
		return self._speed

	speed = property(_get_speed, _set_speed)
	del _get_speed
	del _set_speed
	def get_channel_name(self):
		channel = self.selected
		if channel is None:
			return u''
		title = u'%02i %s' % (int(channel['logical_channel_number']), channel.name)
		return ellipsize(title, 20)

	def get_channel_type(self):
		channel = self.selected
		if channel is None:
			return None
		return '%s.png' % channel.display_type

	def get_seek_step(self):
		time_info = self._get_time_info()
		if not (time_info.max_available_time - time_info.min_available_time) / 10.0:
			pass
		return (time_info.max_available_time - time_info.min_available_time) / 10.0

	def get_record_timeshift_programbar(self, record=None):
		_lc = self.live_controller
		time_info = self._get_time_info()
		direct = time_info.max_available_time
		if self.program:
			begin = self.program['scheduledStartTime']
			end = self.program['scheduledEndTime']
		else:
			begin = time_info.min_available_time
			end = begin + user_config['tv']['timeshift_length'] * 60
		if self._record:
			pass
		if self._record:
			pass
		return dict(live=time_info.current_time, direct=direct, timeshift_begin=time_info.min_available_time, timeshift_end=direct, program_begin=begin, program_end=end, record_begin=None, record_end=None)

	def _get_status(self):
		if self.live_controller.status in ('loading', 'idle'):
			return 'loading'
		speed = self._speed
		if speed == 1:
			try:
				if self.live_controller.default_renderer.isPlayingOnlive():
					return 'live'
				else:
					return 'timeshift'
			except Exception, e:
				return 'unknown'
		if speed == 0:
			return 'pause'
		if -1 <= speed:
			pass
		else:
			speed
		if -1 <= speed:
			return 'slow_motion_rewind'
		if 0 < speed:
			pass
		else:
			speed
		if 0 < speed:
			return 'slow_motion_forward'
		if speed > 1:
			return forward_tricks_icons[self.eventhandler.forward_steps.index(speed)]
		if speed < -1:
			return backward_tricks_icons[self.eventhandler.backward_steps.index(speed)]

	def _request_channel(self, req_channel=None, req_favorite=None):
		if req_favorite:
			favorite = req_favorite
		else:
			if self._favorite_list:
				favorite = self._favorite_list
			else:
				favorite = TVRootItem().get_acl(self)
		try:
			playlist = favorite.browse()
		except BrowseError:
			log.info('Cannot browse requested favorite -- falling back to the ACL')
			favorite = TVRootItem().get_acl(self)
			playlist = favorite.browse()
		if not req_channel or req_channel.name not in favorite:
			lzs = self._last_zap_service
			if lzs is not None and lzs.parent == favorite and lzs.name in favorite:
				channel = lzs
				log.info('Falling back to previous service: %s', channel)
			else:
				channel = playlist[0]
				if channel['class'].endswith('videoCapture') and len(playlist) > 1:
					channel = playlist[1]
				log.info('Falling back to first service in playlist %s: %s', playlist, channel)
		else:
			channel = req_channel
		return (channel, favorite, playlist)

	def can_zap(self):
		return self.live_controller.canZap()

	play = info_banner_activator(selective_gui_updater('channel_name', 'channel_type')())
	def stop(self):
		self._TVPlayer__zap_timer.stop()
		info_banner_activator.force_ending()
		record_banner_activator.force_ending()
		self._initialize_record_info()
		self._initialize_program_info()
		callbacks = WyRecord().callbacks
		callbacks.device_signal.unregister(self.device_signal_event_handler)
		callbacks.service_update.unregister(self.service_update_event_handler)
		callbacks.recording_event.unregister(self.recording_event_handler)
		for i in ('speed', 'scrambled'):
			self.live_controller.watch_property(i, None)
		Player.stop(self)
		try:
			self.live_controller.close()
		except LiveIsRecordingErrors:
			pass
		if self.shielded:
			self._unshield()
		return None

	def _initialize_record_info(self):
		player_info = self.player_info
		player_info['rec_status'] = None
		player_info['rec_duration'] = '--:--'
		player_info['rec_remaining_time'] = '--:--'
		player_info['rec_elapsed_time'] = '--:--'
		player_info['foreign_rec_status'] = None
		player_info['foreign_rec_channel_name'] = ''
		return None

	def _initialize_program_info(self):
		timeshift_duration = user_config['tv']['timeshift_length'] * 60
		utc_time = time()
		player_info = self.player_info
		player_info['program_name'] = ''
		player_info['program_content'] = ''
		player_info['program_start_time'] = seconds_to_hhmm(utc_time)
		player_info['program_stop_time'] = seconds_to_hhmm(utc_time + timeshift_duration)
		player_info['program_duration'] = seconds_to_hhmm_utc(timeshift_duration)
		player_info['program_remaining_time'] = seconds_to_hhmm_utc(timeshift_duration)
		player_info['program_elapsed_time'] = '00:00'
		player_info['program_videoFormat_16_9'] = None
		player_info['program_videoFormatHD'] = None
		player_info['program_nrAudioChannels'] = None
		player_info['program_nrSubtitleTracks'] = None
		player_info['program_subtitleHardOfHearing'] = None
		player_info['program_audioHardOfHearing'] = None
		player_info['program_audioVisuallyImpaired'] = None
		player_info['program_freeCaMode'] = None
		player_info['program_maturity_rating'] = None
		return None

	clear_info_banner = selective_gui_updater('program_name', 'program_start_time', 'program_stop_time', 'maturity_rating_icon', 'program_content', 'program_duration', 'program_elapsed_time', 'program_remaining_time', 'rec_status')()
	select = selective_gui_updater('channel_name', 'channel_type')(info_banner_activator())
	def toggle_menu(self):
		self._navigator.select_program(self._favorite_list, self.selected)
		ms = pygui_globs['menustack']
		if self._navigator not in ms.menus_stack:
			self._navigator.show()
			louie_send('show_program_info', sender=self._navigator)
			louie_send('empty_preview', sender=self._navigator)
			louie_send('hide_preview_program_bar', sender=self._navigator)
			louie_send('show_program_bar', sender=self._navigator)
		else:
			ms.toggle()
			self._navigator.show_help()
		record_banner_activator.force_ending()
		info_banner_activator.force_ending()

	real_utc_time = property()
	timeshift_utc_time = property()
	def zap(self, item=None):
		if not item:
			pass
		item = item
		service_id = int(item['serviceId'])
		current_live = self.live_controller.getCurrentlive(True)
		if current_live and current_live.serviceid == service_id and self.program:
			self.new_present_epg_handler(self.program.wymedia_resource, None)
		else:
			self.program = None

	start_recording = selective_gui_updater('record_timeshift_programbar')()
	stop_recording = selective_gui_updater('rec_duration', 'rec_status', 'rec_remaining_time', 'record_timeshift_programbar')()
	_prompt_stop_record = record_banner_activator(selective_gui_updater('rec_duration', 'rec_remaining_time')())
	def _prompt_stop_foreign_rec(self):
		record = self._foreign_rec
		message_pattern = _('A recording is in progress on channel %(channel)s. %(remaining_time)s remaining. Stop it?')
		data = {'channel': record.service_name, 'remaining_time': seconds_to_hhmm_utc(max(0, record.stop_time + record.stop_padding - self.real_utc_time))}
		messbox = ConfirmWindow(text=message_pattern % data, confirm_action=self.stop_recording, confirm_args=[record])
		messbox.show()

	set_record_duration = record_banner_activator(info_banner_activator(selective_gui_updater('rec_duration', 'rec_remaining_time', 'record_timeshift_programbar')()))
	def _get_record(self):
		current_live = self.live_controller.current_live
		if current_live:
			self._record = current_live.current_rec

	update_record_info = selective_gui_updater('rec_status', 'foreign_rec_status', 'foreign_rec_channel_name', 'rec_duration', 'rec_remaining_time', 'rec_elapsed_time')()
	def resume(self):
		self.live_controller.resume()
		self._speed = 1

	def pause(self):
		self.live_controller.pause()
		self._speed = 0

	action_seek = info_banner_activator(selective_gui_updater('status_icon')())
	action_rec = selective_gui_updater('rec_duration', 'rec_remaining_time')()
	action_play_pause = info_banner_activator(selective_gui_updater('speed', 'status_icon')())
	def action_info(self, refresh=False):
		if info_banner_activator._timer and info_banner_activator._timer.running and not refresh:
			info_banner_activator.force_ending()
		else:
			info_banner_activator((lambda self: None))(self)

	def action_stop(self):
		self.update_record_info()
		if self._record:
			self._prompt_stop_record()
		else:
			if self._foreign_rec:
				self._prompt_stop_foreign_rec()

	def action_vertical(self, offset):
		inverted = HMI_TV['invert_y_axis']
		if record_banner_activator._timer.running:
			if self._record is not None:
				self.set_record_duration(offset * HMI_TV['record_duration_step'])
				self.player_info['rec_duration'] = self._record
		else:
			if self.can_zap():
				if inverted:
					pass
				self.select(offset)
			else:
				title = _('A recording is in progress.')
				message = _('Stop the recording before changing channels.')
				MessageWindow(message, title, button=None).show(timeout=5)
		return None

	def schedule_record(self):
		from pygui.menu.menu.tv.scheduled_record import ScheduledRecordMenu
		_loading = LoadingWindow()
		_loading.show()
		menu = ScheduledRecordMenu()
		menu.select_channel(self.selected, self._favorite_list)
		date = self.real_utc_time
		menu.select_date(date, date + 3600)
		menu.show()
		_loading.hide()

	def display_epg(self):
		from pygui.menu.menu.tv.epg_grid import EpgGridMenu
		menu = EpgGridMenu(player=self, channel_list=self._favorite_list, selected_chan=self.selected)
		menu.show()

	zapping_rollback = gui_updater()
	def clear_last_zap(self):
		self._last_zap_service, self._favorite_list = None, None
		user_config['tv']['last_favorite_name'] = u'all_channels_list'
		user_config['tv']['last_channel_index'] = None
		Task(user_config.save).start(1)
		return None

	def goto_schedule_record(self):
		ms = pygui_globs['menustack']
		if self._navigator not in ms.menus_stack:
			self._navigator.show(hide_previous_menu=False)
			self._navigator.select_schedule_recordings()
		else:
			ms.toggle()
			self._navigator.select_schedule_recordings()



