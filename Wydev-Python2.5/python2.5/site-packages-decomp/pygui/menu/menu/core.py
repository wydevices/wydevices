# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 0
n 0(None)[self.addr = (host, port)
self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7662fac>}
nname: 0
n 0(None)[self.sock.sendto(msg, self.addr)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7662e4c>}
nname: 0
n 0(None)[]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7662d4c>}
nname: 6
n 6(None)[def __init__(self, host='172.16.10.66', port=2345):
	self.addr = (host, port)
	self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

def write(self, msg):
	self.sock.sendto(msg, self.addr)

def flush(self):
	pass

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb76629ec>}
nname: 0
n 0(None)[return self._active_list
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75f2bcc>}
nname: 82
n 82(None)[]:
	i: 21(), 81()
	o: 

nname: 81
n 81(None)[]:
	i: 0(f)
	o: 82()

nname: 21
n 21(None)[louie_send('on_%s_blur' % dc, self)
self._active_list = val
louie_send('on_%s_focus' % val, self)
self.choices.advertise()
]:
	i: 0(t)
	o: 82()

nname: 0
n 0(dc != val)[dc = self._active_list
]:
	i: 
	o: 21(t), 81(f)

nname: 0
n 0(None)[dc = self._active_list
if dc != val:
	louie_send('on_%s_blur' % dc, self)
	self._active_list = val
	louie_send('on_%s_focus' % val, self)
	self.choices.advertise()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75f2fec>}
nname: 107
n 107(None)[return False
]:
	i: 85(JA), 102(), 106()
	o: 

nname: 106
n 106(None)[]:
	i: 0(f)
	o: 107()

nname: 102
n 102(None)[]:
	i: 28(f)
	o: 107()

nname: 85
n 85(None)[self.active_list = new_choice
return True
]:
	i: 28(t)
	o: 107(JA)

nname: 28
n 28(new_item_list)[idx = self.available_choices.index(dc)
new_choice = self.available_choices[idx + 1]
new_item_list = self.get_item_list(new_choice)
]:
	i: 0(t)
	o: 85(t), 102(f)

nname: 0
n 0(dc != self.available_choices[-1])[dc = self.active_list
]:
	i: 
	o: 28(t), 106(f)

nname: 0
n 0(None)[dc = self.active_list
if dc != self.available_choices[-1]:
	idx = self.available_choices.index(dc)
	new_choice = self.available_choices[idx + 1]
	new_item_list = self.get_item_list(new_choice)
	if new_item_list:
		self.active_list = new_choice
		return True
return False
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb766c0ac>}
nname: 107
n 107(None)[return False
]:
	i: 85(JA), 102(), 106()
	o: 

nname: 106
n 106(None)[]:
	i: 0(f)
	o: 107()

nname: 102
n 102(None)[]:
	i: 28(f)
	o: 107()

nname: 85
n 85(None)[self.active_list = new_choice
return True
]:
	i: 28(t)
	o: 107(JA)

nname: 28
n 28(new_item_list)[idx = self.available_choices.index(dc)
new_choice = self.available_choices[idx - 1]
new_item_list = self.get_item_list(new_choice)
]:
	i: 0(t)
	o: 85(t), 102(f)

nname: 0
n 0(dc != self.available_choices[0])[dc = self.active_list
]:
	i: 
	o: 28(t), 106(f)

nname: 0
n 0(None)[dc = self.active_list
if dc != self.available_choices[0]:
	idx = self.available_choices.index(dc)
	new_choice = self.available_choices[idx - 1]
	new_item_list = self.get_item_list(new_choice)
	if new_item_list:
		self.active_list = new_choice
		return True
return False
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb766c48c>}
nname: 0
n 0(None)[return self.type
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76026ac>}
nname: 0
n 0(None)[return self.get_item_list('main_list')
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb760268c>}
nname: 0
n 0(None)[return self.name
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb760202c>}
nname: 390
n 390(None)[return None
]:
	i: 334(), 380()
	o: 

nname: 380
n 380(None)[self._autohide_timeout = None
]:
	i: 304(f)
	o: 390()

nname: 334
n 334(None)[self._autohide_timeout = Task(self._autohide)
self._autohide_timeout.delay = timeout
self._autohide_timeout.ival = timeout
]:
	i: 304(t)
	o: 390()

nname: 304
n 304(timeout is not None)[self.children = []
self.parent = parent
]:
	i: 284(), 303()
	o: 334(t), 380(f)

nname: 303
n 303(None)[]:
	i: 151(t)
	o: 304()

nname: 284
n 284(None)[self.eventhandler = MenuEventHandler(self)
]:
	i: 151(f)
	o: 304()

nname: 151
n 151(hasattr(self, 'eventhandler'))[self.set_items(choices, self.active_list)
self.available_choices = [self.active_list]
self.item = None
self._getitems_keywords = dict(menu_name=(lambda : self.name), item_name=self._get_item_name, main_list=(lambda : self.get_item_list('main_list')), menu_type_name=(lambda : self.type), parent_item_name=self._get_parent_item_name)
]:
	i: 140(), 150()
	o: 284(f), 303(t)

nname: 150
n 150(None)[]:
	i: 119(f)
	o: 151()

nname: 140
n 140(None)[choices = []
]:
	i: 119(t)
	o: 151()

nname: 119
n 119(choices is None)[self.item_lists_dict = {}
]:
	i: 105(), 118()
	o: 140(t), 150(f)

nname: 118
n 118(None)[]:
	i: 0(t)
	o: 119()

nname: 105
n 105(None)[self.zone = zone
]:
	i: 0(f)
	o: 119()

nname: 0
n 0(hasattr(self, 'zone'))[self.name = name
self.type = type
self.universe = universe
self.tasks = {'show_help': Task(self._show_help), 'hide_help': Task(self._hide_help), 'error_timeout': Task(self._error_canceler)}
]:
	i: 
	o: 105(f), 118(t)

nname: 390
n 390(None)[return None
]:
	i: 151()
	o: 

nname: 151
n 151(None)[self.set_items(choices, self.active_list)
self.available_choices = [self.active_list]
self.item = None
self._getitems_keywords = dict(menu_name=(lambda : self.name), item_name=self._get_item_name, main_list=(lambda : self.get_item_list('main_list')), menu_type_name=(lambda : self.type), parent_item_name=self._get_parent_item_name)
if not hasattr(self, 'eventhandler'):
	self.eventhandler = MenuEventHandler(self)
self.children = []
self.parent = parent
if timeout is not None:
	self._autohide_timeout = Task(self._autohide)
	self._autohide_timeout.delay = timeout
	self._autohide_timeout.ival = timeout
else:
	self._autohide_timeout = None
]:
	i: 0()
	o: 390()

nname: 0
n 0(None)[self.name = name
self.type = type
self.universe = universe
self.tasks = {'show_help': Task(self._show_help), 'hide_help': Task(self._hide_help), 'error_timeout': Task(self._error_canceler)}
if not hasattr(self, 'zone'):
	self.zone = zone
self.item_lists_dict = {}
if choices is None:
	choices = []
]:
	i: 
	o: 151()

nname: 390
n 390(None)[return None
]:
	i: 0()
	o: 

nname: 0
n 0(None)[self.name = name
self.type = type
self.universe = universe
self.tasks = {'show_help': Task(self._show_help), 'hide_help': Task(self._hide_help), 'error_timeout': Task(self._error_canceler)}
if not hasattr(self, 'zone'):
	self.zone = zone
self.item_lists_dict = {}
if choices is None:
	choices = []
self.set_items(choices, self.active_list)
self.available_choices = [self.active_list]
self.item = None
self._getitems_keywords = dict(menu_name=(lambda : self.name), item_name=self._get_item_name, main_list=(lambda : self.get_item_list('main_list')), menu_type_name=(lambda : self.type), parent_item_name=self._get_parent_item_name)
if not hasattr(self, 'eventhandler'):
	self.eventhandler = MenuEventHandler(self)
self.children = []
self.parent = parent
if timeout is not None:
	self._autohide_timeout = Task(self._autohide)
	self._autohide_timeout.delay = timeout
	self._autohide_timeout.ival = timeout
else:
	self._autohide_timeout = None
]:
	i: 
	o: 390()

nname: 0
n 0(None)[self.name = name
self.type = type
self.universe = universe
self.tasks = {'show_help': Task(self._show_help), 'hide_help': Task(self._hide_help), 'error_timeout': Task(self._error_canceler)}
if not hasattr(self, 'zone'):
	self.zone = zone
self.item_lists_dict = {}
if choices is None:
	choices = []
self.set_items(choices, self.active_list)
self.available_choices = [self.active_list]
self.item = None
self._getitems_keywords = dict(menu_name=(lambda : self.name), item_name=self._get_item_name, main_list=(lambda : self.get_item_list('main_list')), menu_type_name=(lambda : self.type), parent_item_name=self._get_parent_item_name)
if not hasattr(self, 'eventhandler'):
	self.eventhandler = MenuEventHandler(self)
self.children = []
self.parent = parent
if timeout is not None:
	self._autohide_timeout = Task(self._autohide)
	self._autohide_timeout.delay = timeout
	self._autohide_timeout.ival = timeout
else:
	self._autohide_timeout = None
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb760252c>}
nname: 80
n 80(None)[error_timeout.start(HMI_BASE['error_signal_delay'])
return None
]:
	i: 60(), 79()
	o: 

nname: 79
n 79(None)[]:
	i: 0(t)
	o: 80()

nname: 60
n 60(None)[louie_send(txt, sender=self)
]:
	i: 41(), 59()
	o: 80()

nname: 59
n 59(None)[]:
	i: 22(f)
	o: 60()

nname: 41
n 41(None)[txt = prefix + '_' + txt
]:
	i: 22(t)
	o: 60()

nname: 22
n 22(prefix is not None)[txt = 'error_signal'
]:
	i: 0(f)
	o: 41(t), 59(f)

nname: 0
n 0(error_timeout.running)[error_timeout = self.tasks['error_timeout']
]:
	i: 
	o: 22(f), 79(t)

nname: 80
n 80(None)[error_timeout.start(HMI_BASE['error_signal_delay'])
return None
]:
	i: 22(), 0(t)
	o: 

nname: 22
n 22(None)[txt = 'error_signal'
if prefix is not None:
	txt = prefix + '_' + txt
louie_send(txt, sender=self)
]:
	i: 0(f)
	o: 80()

nname: 0
n 0(error_timeout.running)[error_timeout = self.tasks['error_timeout']
]:
	i: 
	o: 22(f), 80(t)

nname: 0
n 0(None)[error_timeout = self.tasks['error_timeout']
if not error_timeout.running:
	txt = 'error_signal'
	if prefix is not None:
		txt = prefix + '_' + txt
	louie_send(txt, sender=self)
error_timeout.start(HMI_BASE['error_signal_delay'])
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb766c3ec>}
nname: 0
n 0(None)[louie_send('end_error_signal', sender=self)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75f2c8c>}
nname: 0
n 0(None)[return '<%s::%s @%x>' % (self.__class__.__name__, self.type, id(self))
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75f2d8c>}
nname: 29
n 29(None)[return ''
]:
	i: 15(), 25()
	o: 

nname: 25
n 25(None)[]:
	i: 0(f)
	o: 29()

nname: 15
n 15(None)[]:
	i: 0(t)
	o: 29()

nname: 0
n 0(sel)[sel = self.selected
]:
	i: 
	o: 15(t), 25(f)

nname: 0
n 0(None)[sel = self.selected
if sel:
	pass
return ''
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75f2c4c>}
nname: 43
n 43(None)[return u''
]:
	i: 31(), 42()
	o: 

nname: 42
n 42(None)[]:
	i: 0&15(f)
	o: 43()

nname: 31
n 31(None)[return item.name
]:
	i: 0&15(t)
	o: 43()

nname: 0&15
n 0&15(item and item.type != 'main')[item = self.item
]:
	i: 
	o: 31(t), 42(f)

nname: 0&15
n 0&15(None)[item = self.item
if item and item.type != 'main':
	return item.name
return u''
]:
	i: 
	o: 

self.nodes: {'0&15': <unpyclib.structure.node instance at 0xb75f2f2c>}
nname: 0
n 0(None)[self.show_help()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75f2c4c>}
nname: 90
n 90(None)[self.set_items(choices, self.active_list)
return None
]:
	i: 62(t), 86()
	o: 

nname: 86
n 86(None)[]:
	i: 62(f)
	o: 90()

nname: 62
n 62(choices)[self.item_lists_dict = dict()
]:
	i: 48(), 61()
	o: 86(f), 90(t)

nname: 61
n 61(None)[]:
	i: 0(f)
	o: 62()

nname: 48
n 48(None)[self.type = type
]:
	i: 0(t)
	o: 62()

nname: 0
n 0(type is not None)[self.name = name
self.item = None
self.universe = universe
self._active_list = 'main_list'
]:
	i: 
	o: 48(t), 61(f)

nname: 90
n 90(None)[self.set_items(choices, self.active_list)
return None
]:
	i: 0(t)
	o: 

nname: 0
n 0(None)[self.name = name
self.item = None
self.universe = universe
self._active_list = 'main_list'
if type is not None:
	self.type = type
self.item_lists_dict = dict()
if not choices:
	pass
]:
	i: 
	o: 90()

nname: 0
n 0(None)[self.name = name
self.item = None
self.universe = universe
self._active_list = 'main_list'
if type is not None:
	self.type = type
self.item_lists_dict = dict()
if not choices:
	pass
self.set_items(choices, self.active_list)
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb766c60c>}
nname: 0
n 0(None)[return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75f2e0c>}
nname: 0
n 0(None)[return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75f2c0c>}
nname: 0
n 0(None)[return self._getitems_keywords.get(name, (lambda : None))()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75f2ccc>}
nname: 100
n 100(None)[return None
]:
	i: 16(AL), 95(), 99()
	o: 

nname: 99
n 99(None)[]:
	i: 0(f)
	o: 100()

nname: 95
n 95(None)[]:
	i: 20(AF), 36()
	o: 100()

nname: 36
n 36(None)[for k, v in self.item_lists_dict.iteritems():
self.item_lists_dict[k].set_items([])
v.selected = False
v.menu = None
v._data = None
]:
	i: 20(for)
	o: 95()

nname: 20
n 20(None)[]:
	i: 16(loop)
	o: 36(for), 95(AF)

nname: 16
n 16(None)[]:
	i: 0(t)
	o: 20(loop), 100(AL)

nname: 0
n 0(self not in pygui_globs['menustack'])[]:
	i: 
	o: 16(t), 99(f)

nname: 100
n 100(None)[return None
]:
	i: 36(), 0(f)
	o: 

nname: 36
n 36(None)[for k, v in self.item_lists_dict.iteritems():
	self.item_lists_dict[k].set_items([])
	v.selected = False
	v.menu = None
	v._data = None
]:
	i: 16(for)
	o: 100()

nname: 16
n 16(None)[]:
	i: 0(t)
	o: 36(for)

nname: 0
n 0(self not in pygui_globs['menustack'])[]:
	i: 
	o: 16(t), 100(f)

nname: 100
n 100(None)[return None
]:
	i: 16(), 0(f)
	o: 

nname: 16
n 16(None)[for k, v in self.item_lists_dict.iteritems():
	self.item_lists_dict[k].set_items([])
	v.selected = False
	v.menu = None
	v._data = None
]:
	i: 0(t)
	o: 100()

nname: 0
n 0(self not in pygui_globs['menustack'])[]:
	i: 
	o: 16(t), 100(f)

nname: 0
n 0(None)[if self not in pygui_globs['menustack']:
	for k, v in self.item_lists_dict.iteritems():
		self.item_lists_dict[k].set_items([])
		v.selected = False
		v.menu = None
		v._data = None
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb766cbec>}
nname: 19
n 19(None)[return self.item_lists_dict[list_name]
]:
	i: 0(t), 12()
	o: 

nname: 12
n 12(None)[]:
	i: 0(f)
	o: 19()

nname: 0
n 0(list_name)[]:
	i: 
	o: 12(f), 19(t)

nname: 0
n 0(None)[if not list_name:
	pass
return self.item_lists_dict[list_name]
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75f2b4c>}
nname: 33
n 33(None)[return self.get_item_list(list_name)
]:
	i: 15(), 32()
	o: 

nname: 32
n 32(None)[]:
	i: 0(f)
	o: 33()

nname: 15
n 15(None)[self.add_item_list(list_name)
]:
	i: 0(t)
	o: 33()

nname: 0
n 0(list_name not in self.item_lists_dict)[]:
	i: 
	o: 15(t), 32(f)

nname: 0
n 0(None)[if list_name not in self.item_lists_dict:
	self.add_item_list(list_name)
return self.get_item_list(list_name)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75f2bec>}
nname: 49
n 49(None)[return None
]:
	i: 29(), 48()
	o: 

nname: 48
n 48(None)[]:
	i: 0(f)
	o: 49()

nname: 29
n 29(None)[self.item_lists_dict[list_name] = ItemList(self, items, list_name)
]:
	i: 12(t), 25()
	o: 49()

nname: 25
n 25(None)[]:
	i: 12(f)
	o: 29()

nname: 12
n 12(items)[]:
	i: 0(t)
	o: 25(f), 29(t)

nname: 0
n 0(list_name is not None)[]:
	i: 
	o: 12(t), 48(f)

nname: 49
n 49(None)[return None
]:
	i: 12(), 0(f)
	o: 

nname: 12
n 12(None)[if not items:
	pass
self.item_lists_dict[list_name] = ItemList(self, items, list_name)
]:
	i: 0(t)
	o: 49()

nname: 0
n 0(list_name is not None)[]:
	i: 
	o: 12(t), 49(f)

nname: 0
n 0(None)[if list_name is not None:
	if not items:
		pass
	self.item_lists_dict[list_name] = ItemList(self, items, list_name)
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75f2dac>}
nname: 0
n 0(None)[del self.item_lists_dict[list_name]
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75f2e6c>}
nname: 61
n 61(None)[]:
	i: 46(), 60()
	o: 

nname: 60
n 60(None)[]:
	i: 0(f)
	o: 61()

nname: 46
n 46(None)[self._logselected()
]:
	i: 0(t)
	o: 61()

nname: 0
n 0(list_name == self._active_list)[item_list = self.get_create_item_list(list_name)
item_list.set_items(items, position)
]:
	i: 
	o: 46(t), 60(f)

nname: 0
n 0(None)[item_list = self.get_create_item_list(list_name)
item_list.set_items(items, position)
if list_name == self._active_list:
	self._logselected()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75f2c0c>}
nname: 0
n 0(None)[return self.get_item_list().selected
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75f2d8c>}
nname: 0
n 0(None)[self.get_item_list().select(value)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75f2d0c>}
nname: 0
n 0(None)[return self.get_item_list().selected_pos
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75f2bcc>}
nname: 90
n 90(None)[return None
]:
	i: 79(), 83(), 89(AE)
	o: 

nname: 83
n 83(None)[]:
	i: 0(except)
	o: 90()

nname: 79
n 79(None)[]:
	i: 15(), 65(), 78()
	o: 90()

nname: 78
n 78(None)[]:
	i: 52(f)
	o: 79()

nname: 65
n 65(None)[]:
	i: 52(t)
	o: 79()

nname: 52
n 52('logselected' in plugins)[]:
	i: 3(f)
	o: 65(t), 78(f)

nname: 15
n 15(None)[logselected.write('%s\n' % self.selected.name)
logselected.flush()
]:
	i: 3(t)
	o: 79()

nname: 3
n 3(logselected is not None)[]:
	i: 0(try)
	o: 15(t), 52(f)

nname: 0
n 0(None)[]:
	i: 
	o: 3(try), 83(except)

nname: 90
n 90(None)[return None
]:
	i: 83(), 0()
	o: 

nname: 83
n 83(None)[except:
	pass
]:
	i: 0()
	o: 90()

nname: 90
n 90(None)[return None
]:
	i: 83(), 0()
	o: 

nname: 0
n 0(None)[try:
	if logselected is not None:
		logselected.write('%s\n' % self.selected.name)
		logselected.flush()
	else:
		if 'logselected' in plugins:
			pass
]:
	i: 
	o: 90(), 83()

self.nodes: {0: <unpyclib.structure.node instance at 0xb766cf6c>, 83: <unpyclib.structure.node instance at 0xb766c96c>, 90: <unpyclib.structure.node instance at 0xb766c6ac>}
nname: 107
n 107(None)[return val
]:
	i: 92(), 106()
	o: 

nname: 106
n 106(None)[]:
	i: 62(f)
	o: 107()

nname: 92
n 92(None)[self._logselected()
]:
	i: 62(t)
	o: 107()

nname: 62
n 62(val is not False)[val = self.get_item_list(list_name).select(item, force_pos)
]:
	i: 43(t), 55()
	o: 92(t), 106(f)

nname: 55
n 55(None)[]:
	i: 43(f)
	o: 62()

nname: 43
n 43(list_name)[]:
	i: 9(), 42()
	o: 55(f), 62(t)

nname: 42
n 42(None)[]:
	i: 0(f)
	o: 43()

nname: 9
n 9(None)[log.debug('%s autohide postponed', self)
self._autohide_timeout.start()
]:
	i: 0(t)
	o: 43()

nname: 0
n 0(self._autohide_timeout)[]:
	i: 
	o: 9(t), 42(f)

nname: 62
n 62(None)[val = self.get_item_list(list_name).select(item, force_pos)
if val is not False:
	self._logselected()
return val
]:
	i: 0(t)
	o: 

nname: 0
n 0(None)[if self._autohide_timeout:
	log.debug('%s autohide postponed', self)
	self._autohide_timeout.start()
if not list_name:
	pass
]:
	i: 
	o: 62()

nname: 0
n 0(None)[if self._autohide_timeout:
	log.debug('%s autohide postponed', self)
	self._autohide_timeout.start()
if not list_name:
	pass
val = self.get_item_list(list_name).select(item, force_pos)
if val is not False:
	self._logselected()
return val
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb766c02c>}
nname: 19
n 19(None)[actual_list = self.get_item_list(list_name)
actual_list.remove(item)
]:
	i: 0(t), 12()
	o: 

nname: 12
n 12(None)[]:
	i: 0(f)
	o: 19()

nname: 0
n 0(list_name)[]:
	i: 
	o: 12(f), 19(t)

nname: 0
n 0(None)[if not list_name:
	pass
actual_list = self.get_item_list(list_name)
actual_list.remove(item)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75f2fac>}
nname: 80
n 80(None)[]:
	i: 0(AL), 79()
	o: 

nname: 79
n 79(None)[]:
	i: 29(AF), 75()
	o: 80()

nname: 75
n 75(None)[]:
	i: 39(f), 57()
	o: 79()

nname: 57
n 57(None)[menu.toggle_menu()
continue
]:
	i: 39(t)
	o: 75()

nname: 39
n 39(isinstance(menu, Player))[for menu in stack.menus_stack:
]:
	i: 29(for)
	o: 57(t), 75(f)

nname: 29
n 29(None)[]:
	i: 0(loop)
	o: 39(for), 79(AF)

nname: 0
n 0(None)[stack = pygui_globs['menustack']
from pygui.menu.players.core import Player
]:
	i: 
	o: 29(loop), 80(AL)

nname: 80
n 80(None)[]:
	i: 0(AL), 29(AF), 39()
	o: 

nname: 39
n 39(None)[for menu in stack.menus_stack:
if isinstance(menu, Player):
	menu.toggle_menu()
	continue
]:
	i: 29(for)
	o: 80()

nname: 29
n 29(None)[]:
	i: 0(loop)
	o: 39(for), 80(AF)

nname: 0
n 0(None)[stack = pygui_globs['menustack']
from pygui.menu.players.core import Player
]:
	i: 
	o: 29(loop), 80(AL)

nname: 39
n 39(None)[for menu in stack.menus_stack:
	if isinstance(menu, Player):
		menu.toggle_menu()
		continue
]:
	i: 0(for)
	o: 

nname: 0
n 0(None)[stack = pygui_globs['menustack']
from pygui.menu.players.core import Player
]:
	i: 
	o: 39(for)

nname: 0
n 0(None)[stack = pygui_globs['menustack']
from pygui.menu.players.core import Player
for menu in stack.menus_stack:
	if isinstance(menu, Player):
		menu.toggle_menu()
		continue
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75f2d2c>}
nname: 63
n 63(None)[]:
	i: 31(JA), 58(), 62()
	o: 

nname: 62
n 62(None)[]:
	i: 0(f)
	o: 63()

nname: 58
n 58(None)[]:
	i: 14(t)
	o: 63()

nname: 31
n 31(None)[louie_send('show_help', self)
self.hide_help()
]:
	i: 14(f)
	o: 63(JA)

nname: 14
n 14(self.tasks['hide_help'].running)[]:
	i: 0(t)
	o: 31(f), 58(t)

nname: 0
n 0(user_config['base']['help_banner'])[]:
	i: 
	o: 14(t), 62(f)

nname: 0
n 0(None)[if user_config['base']['help_banner']:
	if not self.tasks['hide_help'].running:
		louie_send('show_help', self)
		self.hide_help()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75f2bac>}
nname: 34
n 34(None)[]:
	i: 9(), 33()
	o: 

nname: 33
n 33(None)[]:
	i: 0(f)
	o: 34()

nname: 9
n 9(None)[self.tasks['show_help'].start(0.5)
]:
	i: 0(t)
	o: 34()

nname: 0
n 0(self.show_help_banner)[]:
	i: 
	o: 9(t), 33(f)

nname: 0
n 0(None)[if self.show_help_banner:
	self.tasks['show_help'].start(0.5)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75f2b4c>}
nname: 38
n 38(None)[]:
	i: 20(), 37()
	o: 

nname: 37
n 37(None)[]:
	i: 0(f)
	o: 38()

nname: 20
n 20(None)[louie_send('hide_help', self)
]:
	i: 0(t)
	o: 38()

nname: 0
n 0(user_config['base']['help_banner'] != 1)[]:
	i: 
	o: 20(t), 37(f)

nname: 0
n 0(None)[if user_config['base']['help_banner'] != 1:
	louie_send('hide_help', self)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75f2b8c>}
nname: 38
n 38(None)[]:
	i: 9(), 37()
	o: 

nname: 37
n 37(None)[]:
	i: 0(f)
	o: 38()

nname: 9
n 9(None)[self.tasks['hide_help'].start(HMI_BASE['helpbanner_duration'])
]:
	i: 0(t)
	o: 38()

nname: 0
n 0(self.show_help_banner)[]:
	i: 
	o: 9(t), 37(f)

nname: 0
n 0(None)[if self.show_help_banner:
	self.tasks['hide_help'].start(HMI_BASE['helpbanner_duration'])
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75f2cac>}
nname: 229
n 229(None)[return None
]:
	i: 211(), 228()
	o: 

nname: 228
n 228(None)[]:
	i: 202(f)
	o: 229()

nname: 211
n 211(None)[self._autohide_timeout.start()
]:
	i: 202(t)
	o: 229()

nname: 202
n 202(self._autohide_timeout)[]:
	i: 174(), 201()
	o: 211(t), 228(f)

nname: 201
n 201(None)[]:
	i: 123(f)
	o: 202()

nname: 174
n 174(None)[self._autohide_timeout.delay = timeout
self._autohide_timeout.ival = timeout
]:
	i: 151(), 173()
	o: 202()

nname: 173
n 173(None)[]:
	i: 135(f)
	o: 174()

nname: 151
n 151(None)[self._autohide_timeout = Task(self._autohide)
]:
	i: 135(t)
	o: 174()

nname: 135
n 135(self._autohide_timeout is None)[]:
	i: 123(t)
	o: 151(t), 173(f)

nname: 123
n 123(timeout is not None)[]:
	i: 43(JA), 76(JA), 119(), 122()
	o: 135(t), 201(f)

nname: 122
n 122(None)[]:
	i: 0(f)
	o: 123()

nname: 119
n 119(None)[]:
	i: 117(AE)
	o: 123()

nname: 117
n 117(None)[]:
	i: 66(f)
	o: 119(AE)

nname: 76
n 76(None)[#, e
log.error('Cannot append %s to %s.children', self, self.parent)
PRINT_EXCEPTION(e)
]:
	i: 66(t)
	o: 123(JA)

nname: 66
n 66(<dummy_ex3> EXC_MATCH Exception)[]:
	i: 39(except)
	o: 76(t), 117(f)

nname: 43
n 43(None)[self.parent.children.append(self)
]:
	i: 39(try)
	o: 123(JA)

nname: 39
n 39(None)[]:
	i: 0(t)
	o: 43(try), 66(except)

nname: 0
n 0(self.parent)[pygui_globs['menustack'].push_menu(self, hide_previous_menu)
self.show_help()
]:
	i: 
	o: 39(t), 122(f)

nname: 202
n 202(None)[if self._autohide_timeout:
	self._autohide_timeout.start()
return None
]:
	i: 135(), 123(f)
	o: 

nname: 135
n 135(None)[if self._autohide_timeout is None:
	self._autohide_timeout = Task(self._autohide)
self._autohide_timeout.delay = timeout
self._autohide_timeout.ival = timeout
]:
	i: 123(t)
	o: 202()

nname: 123
n 123(timeout is not None)[]:
	i: 43(JA), 76(JA), 66(f), 117(AE), 0(f)
	o: 135(t), 202(f)

nname: 76
n 76(None)[#, e
log.error('Cannot append %s to %s.children', self, self.parent)
PRINT_EXCEPTION(e)
]:
	i: 66(t)
	o: 123(JA)

nname: 66
n 66(<dummy_ex3> EXC_MATCH Exception)[]:
	i: 39(except)
	o: 76(t), 123(f)

nname: 43
n 43(None)[self.parent.children.append(self)
]:
	i: 39(try)
	o: 123(JA)

nname: 39
n 39(None)[]:
	i: 0(t)
	o: 43(try), 66(except)

nname: 0
n 0(self.parent)[pygui_globs['menustack'].push_menu(self, hide_previous_menu)
self.show_help()
]:
	i: 
	o: 39(t), 123(f)

nname: 123
n 123(None)[if timeout is not None:
	if self._autohide_timeout is None:
		self._autohide_timeout = Task(self._autohide)
	self._autohide_timeout.delay = timeout
	self._autohide_timeout.ival = timeout
if self._autohide_timeout:
	self._autohide_timeout.start()
return None
]:
	i: 66(f), 0(f)
	o: 

nname: 66
n 66(None)[except Exception, e:
	log.error('Cannot append %s to %s.children', self, self.parent)
	PRINT_EXCEPTION(e)
]:
	i: 39()
	o: 123(JA)

nname: 39
n 39(None)[try:
	self.parent.children.append(self)
]:
	i: 0(t)
	o: 66()

nname: 0
n 0(self.parent)[pygui_globs['menustack'].push_menu(self, hide_previous_menu)
self.show_help()
]:
	i: 
	o: 39(t), 123(f)

nname: 123
n 123(None)[if timeout is not None:
	if self._autohide_timeout is None:
		self._autohide_timeout = Task(self._autohide)
	self._autohide_timeout.delay = timeout
	self._autohide_timeout.ival = timeout
if self._autohide_timeout:
	self._autohide_timeout.start()
return None
]:
	i: 39(f), 0(f)
	o: 

nname: 39
n 39(None)[try:
	self.parent.children.append(self)
except Exception, e:
	log.error('Cannot append %s to %s.children', self, self.parent)
	PRINT_EXCEPTION(e)
]:
	i: 0(t)
	o: 123(JA)

nname: 0
n 0(self.parent)[pygui_globs['menustack'].push_menu(self, hide_previous_menu)
self.show_help()
]:
	i: 
	o: 39(t), 123(f)

nname: 0
n 0(None)[pygui_globs['menustack'].push_menu(self, hide_previous_menu)
self.show_help()
if self.parent:
	try:
		self.parent.children.append(self)
	except Exception, e:
		log.error('Cannot append %s to %s.children', self, self.parent)
		PRINT_EXCEPTION(e)
if timeout is not None:
	if self._autohide_timeout is None:
		self._autohide_timeout = Task(self._autohide)
	self._autohide_timeout.delay = timeout
	self._autohide_timeout.ival = timeout
if self._autohide_timeout:
	self._autohide_timeout.start()
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb760294c>}
nname: 210
n 210(None)[]:
	i: 199(AE)
	o: 

nname: 199
n 199(None)[self.hide_help()
]:
	i: 120(finally), 195()
	o: 210(AE)

nname: 195
n 195(None)[]:
	i: 136(), 163(), 193(AE)
	o: 199()

nname: 193
n 193(None)[]:
	i: 153(f)
	o: 195(AE)

nname: 163
n 163(None)[log.error("Can't hide %s !", self)
PRINT_EXCEPTION()
]:
	i: 153(t)
	o: 195()

nname: 153
n 153(<dummy_ex3> EXC_MATCH ValueError)[]:
	i: 133(except)
	o: 163(t), 193(f)

nname: 136
n 136(None)[stack.close_player(self)
]:
	i: 133(try)
	o: 195()

nname: 133
n 133(None)[]:
	i: 120(ASF)
	o: 136(try), 153(except)

nname: 120
n 120(None)[stack = pygui_globs['menustack']
]:
	i: 40(JA), 73(JA), 116(), 119()
	o: 133(ASF2), 199(finally)

nname: 119
n 119(None)[]:
	i: 27(f)
	o: 120()

nname: 116
n 116(None)[]:
	i: 114(AE)
	o: 120()

nname: 114
n 114(None)[]:
	i: 63(f)
	o: 116(AE)

nname: 73
n 73(None)[#, e
log.error('Error while removing %s from %s.children', self, self.parent)
PRINT_EXCEPTION(e)
]:
	i: 63(t)
	o: 120(JA)

nname: 63
n 63(<dummy_ex3> EXC_MATCH Exception)[]:
	i: 36(except)
	o: 73(t), 114(f)

nname: 40
n 40(None)[self.parent.children.remove(self)
]:
	i: 36(try)
	o: 120(JA)

nname: 36
n 36(None)[]:
	i: 27(t)
	o: 40(try), 63(except)

nname: 27
n 27(self.parent)[]:
	i: 9(), 26()
	o: 36(t), 119(f)

nname: 26
n 26(None)[]:
	i: 0(f)
	o: 27()

nname: 9
n 9(None)[self._autohide_timeout.stop()
]:
	i: 0(t)
	o: 27()

nname: 0
n 0(self._autohide_timeout)[]:
	i: 
	o: 9(t), 26(f)

nname: 210
n 210(None)[]:
	i: 199(AE)
	o: 

nname: 199
n 199(None)[self.hide_help()
]:
	i: 120(finally), 153()
	o: 210(AE)

nname: 153
n 153(None)[except ValueError:
	log.error("Can't hide %s !", self)
	PRINT_EXCEPTION()
]:
	i: 133()
	o: 199()

nname: 133
n 133(None)[try:
	stack.close_player(self)
]:
	i: 120(ASF2)
	o: 153()

nname: 120
n 120(None)[stack = pygui_globs['menustack']
]:
	i: 40(JA), 73(JA), 63(f), 114(AE), 0(f)
	o: 133(ASF2), 199(finally)

nname: 73
n 73(None)[#, e
log.error('Error while removing %s from %s.children', self, self.parent)
PRINT_EXCEPTION(e)
]:
	i: 63(t)
	o: 120(JA)

nname: 63
n 63(<dummy_ex3> EXC_MATCH Exception)[]:
	i: 36(except)
	o: 73(t), 120(f)

nname: 40
n 40(None)[self.parent.children.remove(self)
]:
	i: 36(try)
	o: 120(JA)

nname: 36
n 36(None)[]:
	i: 0(t)
	o: 40(try), 63(except)

nname: 0
n 0(self.parent)[if self._autohide_timeout:
	self._autohide_timeout.stop()
]:
	i: 
	o: 36(t), 120(f)

nname: 210
n 210(None)[]:
	i: 199(AE)
	o: 

nname: 199
n 199(None)[self.hide_help()
]:
	i: 120(finally), 133()
	o: 210(AE)

nname: 133
n 133(None)[try:
	stack.close_player(self)
except ValueError:
	log.error("Can't hide %s !", self)
	PRINT_EXCEPTION()
]:
	i: 120(ASF2)
	o: 199()

nname: 120
n 120(None)[stack = pygui_globs['menustack']
]:
	i: 63(f), 0(f)
	o: 133(ASF2), 199(finally)

nname: 63
n 63(None)[except Exception, e:
	log.error('Error while removing %s from %s.children', self, self.parent)
	PRINT_EXCEPTION(e)
]:
	i: 36()
	o: 120(JA)

nname: 36
n 36(None)[try:
	self.parent.children.remove(self)
]:
	i: 0(t)
	o: 63()

nname: 0
n 0(self.parent)[if self._autohide_timeout:
	self._autohide_timeout.stop()
]:
	i: 
	o: 36(t), 120(f)

nname: 199
n 199(None)[finally:
	self.hide_help()
]:
	i: 120()
	o: 

nname: 120
n 120(None)[stack = pygui_globs['menustack']
try:
	stack.close_player(self)
except ValueError:
	log.error("Can't hide %s !", self)
	PRINT_EXCEPTION()
]:
	i: 36(f), 0(f)
	o: 199()

nname: 36
n 36(None)[try:
	self.parent.children.remove(self)
except Exception, e:
	log.error('Error while removing %s from %s.children', self, self.parent)
	PRINT_EXCEPTION(e)
]:
	i: 0(t)
	o: 120(JA)

nname: 0
n 0(self.parent)[if self._autohide_timeout:
	self._autohide_timeout.stop()
]:
	i: 
	o: 36(t), 120(f)

nname: 199
n 199(None)[finally:
	self.hide_help()
]:
	i: 0()
	o: 

nname: 0
n 0(None)[if self._autohide_timeout:
	self._autohide_timeout.stop()
if self.parent:
	try:
		self.parent.children.remove(self)
	except Exception, e:
		log.error('Error while removing %s from %s.children', self, self.parent)
		PRINT_EXCEPTION(e)
stack = pygui_globs['menustack']
try:
	stack.close_player(self)
except ValueError:
	log.error("Can't hide %s !", self)
	PRINT_EXCEPTION()
]:
	i: 
	o: 199()

nname: 0
n 0(None)[if self._autohide_timeout:
	self._autohide_timeout.stop()
if self.parent:
	try:
		self.parent.children.remove(self)
	except Exception, e:
		log.error('Error while removing %s from %s.children', self, self.parent)
		PRINT_EXCEPTION(e)
stack = pygui_globs['menustack']
try:
	stack.close_player(self)
except ValueError:
	log.error("Can't hide %s !", self)
	PRINT_EXCEPTION()
finally:
	self.hide_help()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7602a0c>}
nname: 87
n 87(None)[]:
	i: 9(), 64()
	o: 

nname: 64
n 64(None)[log.debug('%s has children %s ! avoid autohide', self, self.children)
]:
	i: 0(t)
	o: 87()

nname: 9
n 9(None)[log.debug('%s no children: calling hide()', self)
Task(self._autohide_timeout.stop).start(0)
self.hide()
]:
	i: 0(f)
	o: 87()

nname: 0
n 0(self.children)[]:
	i: 
	o: 9(f), 64(t)

nname: 0
n 0(None)[if not self.children:
	log.debug('%s no children: calling hide()', self)
	Task(self._autohide_timeout.stop).start(0)
	self.hide()
else:
	log.debug('%s has children %s ! avoid autohide', self, self.children)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75f2acc>}
nname: 52
n 52(None)[]:
	i: 0(AL), 51()
	o: 

nname: 51
n 51(None)[]:
	i: 19(AF), 35()
	o: 52()

nname: 35
n 35(None)[for t in self.tasks.itervalues():
t.stop()
]:
	i: 19(for)
	o: 51()

nname: 19
n 19(None)[]:
	i: 0(loop)
	o: 35(for), 51(AF)

nname: 0
n 0(None)[log.debug('%s stopping. Stopping tasks...', self)
]:
	i: 
	o: 19(loop), 52(AL)

nname: 52
n 52(None)[]:
	i: 35()
	o: 

nname: 35
n 35(None)[for t in self.tasks.itervalues():
	t.stop()
]:
	i: 0(for)
	o: 52()

nname: 0
n 0(None)[log.debug('%s stopping. Stopping tasks...', self)
]:
	i: 
	o: 35(for)

nname: 52
n 52(None)[]:
	i: 0()
	o: 

nname: 0
n 0(None)[log.debug('%s stopping. Stopping tasks...', self)
for t in self.tasks.itervalues():
	t.stop()
]:
	i: 
	o: 52()

nname: 0
n 0(None)[log.debug('%s stopping. Stopping tasks...', self)
for t in self.tasks.itervalues():
	t.stop()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75f2cec>}
nname: 0
n 0(None)[self.hide_help()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75f2c6c>}
nname: 0
n 0(None)[self.show_help()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75f2fec>}
nname: 52
n 52(None)[]:
	i: 15(), 35()
	o: 

nname: 35
n 35(None)[log.debug('Menu ungrouped from %r', self)
]:
	i: 0(f)
	o: 52()

nname: 15
n 15(None)[log.debug('Menu grouped with %r', self)
]:
	i: 0(t)
	o: 52()

nname: 0
n 0(value)[self._grouped_menu = value
]:
	i: 
	o: 15(t), 35(f)

nname: 0
n 0(None)[self._grouped_menu = value
if value:
	log.debug('Menu grouped with %r', self)
else:
	log.debug('Menu ungrouped from %r', self)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75f2b8c>}
nname: 0
n 0(None)[return self._grouped_menu
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75f2fec>}
nname: 118
n 118(None)[]:
	i: 0(AL), 117()
	o: 

nname: 117
n 117(None)[]:
	i: 27(AF), 114()
	o: 118()

nname: 114
n 114(None)[]:
	i: 41(AL), 113()
	o: 117()

nname: 113
n 113(None)[]:
	i: 47(AF), 110()
	o: 114()

nname: 110
n 110(None)[]:
	i: 57(AL), 109()
	o: 113()

nname: 109
n 109(None)[]:
	i: 63(AF), 105()
	o: 110()

nname: 105
n 105(None)[]:
	i: 79(f), 97()
	o: 109()

nname: 97
n 97(None)[return list_view
continue
]:
	i: 79(t)
	o: 105()

nname: 79
n 79(list_view.menu_list is model_list)[for list_view in menu_widget.get_list_obj_by_name(al):
]:
	i: 63(for)
	o: 97(t), 105(f)

nname: 63
n 63(None)[]:
	i: 57(loop)
	o: 79(for), 109(AF)

nname: 57
n 57(None)[for menu_widget in engine.menu_stack:
]:
	i: 47(for)
	o: 63(loop), 110(AL)

nname: 47
n 47(None)[]:
	i: 41(loop)
	o: 57(for), 113(AF)

nname: 41
n 41(None)[for engine in pygui_globs['menustack'].engines:
]:
	i: 27(for)
	o: 47(loop), 114(AL)

nname: 27
n 27(None)[]:
	i: 0(loop)
	o: 41(for), 117(AF)

nname: 0
n 0(None)[al = self._active_list
model_list = self.get_item_list(al)
]:
	i: 
	o: 27(loop), 118(AL)

nname: 118
n 118(None)[]:
	i: 0(AL), 27(AF), 41(AL), 47(AF), 57(AL), 63(AF), 79()
	o: 

nname: 79
n 79(None)[for list_view in menu_widget.get_list_obj_by_name(al):
if list_view.menu_list is model_list:
	return list_view
	continue
]:
	i: 63(for)
	o: 118()

nname: 63
n 63(None)[]:
	i: 57(loop)
	o: 79(for), 118(AF)

nname: 57
n 57(None)[for menu_widget in engine.menu_stack:
]:
	i: 47(for)
	o: 63(loop), 118(AL)

nname: 47
n 47(None)[]:
	i: 41(loop)
	o: 57(for), 118(AF)

nname: 41
n 41(None)[for engine in pygui_globs['menustack'].engines:
]:
	i: 27(for)
	o: 47(loop), 118(AL)

nname: 27
n 27(None)[]:
	i: 0(loop)
	o: 41(for), 118(AF)

nname: 0
n 0(None)[al = self._active_list
model_list = self.get_item_list(al)
]:
	i: 
	o: 27(loop), 118(AL)

nname: 118
n 118(None)[]:
	i: 0(AL), 27(AF), 41(AL), 47(AF), 79()
	o: 

nname: 79
n 79(None)[for list_view in menu_widget.get_list_obj_by_name(al):
	if list_view.menu_list is model_list:
		return list_view
		continue
]:
	i: 57(for)
	o: 118()

nname: 57
n 57(None)[for menu_widget in engine.menu_stack:
]:
	i: 47(for)
	o: 79(for)

nname: 47
n 47(None)[]:
	i: 41(loop)
	o: 57(for), 118(AF)

nname: 41
n 41(None)[for engine in pygui_globs['menustack'].engines:
]:
	i: 27(for)
	o: 47(loop), 118(AL)

nname: 27
n 27(None)[]:
	i: 0(loop)
	o: 41(for), 118(AF)

nname: 0
n 0(None)[al = self._active_list
model_list = self.get_item_list(al)
]:
	i: 
	o: 27(loop), 118(AL)

nname: 118
n 118(None)[]:
	i: 0(AL), 27(AF), 41(AL), 47(AF), 57()
	o: 

nname: 57
n 57(None)[for menu_widget in engine.menu_stack:
for list_view in menu_widget.get_list_obj_by_name(al):
	if list_view.menu_list is model_list:
		return list_view
		continue
]:
	i: 47(for)
	o: 118()

nname: 47
n 47(None)[]:
	i: 41(loop)
	o: 57(for), 118(AF)

nname: 41
n 41(None)[for engine in pygui_globs['menustack'].engines:
]:
	i: 27(for)
	o: 47(loop), 118(AL)

nname: 27
n 27(None)[]:
	i: 0(loop)
	o: 41(for), 118(AF)

nname: 0
n 0(None)[al = self._active_list
model_list = self.get_item_list(al)
]:
	i: 
	o: 27(loop), 118(AL)

nname: 118
n 118(None)[]:
	i: 0(AL), 27(AF), 57()
	o: 

nname: 57
n 57(None)[for menu_widget in engine.menu_stack:
	for list_view in menu_widget.get_list_obj_by_name(al):
		if list_view.menu_list is model_list:
			return list_view
			continue
]:
	i: 41(for)
	o: 118()

nname: 41
n 41(None)[for engine in pygui_globs['menustack'].engines:
]:
	i: 27(for)
	o: 57(for)

nname: 27
n 27(None)[]:
	i: 0(loop)
	o: 41(for), 118(AF)

nname: 0
n 0(None)[al = self._active_list
model_list = self.get_item_list(al)
]:
	i: 
	o: 27(loop), 118(AL)

nname: 118
n 118(None)[]:
	i: 0(AL), 27(AF), 41()
	o: 

nname: 41
n 41(None)[for engine in pygui_globs['menustack'].engines:
for menu_widget in engine.menu_stack:
	for list_view in menu_widget.get_list_obj_by_name(al):
		if list_view.menu_list is model_list:
			return list_view
			continue
]:
	i: 27(for)
	o: 118()

nname: 27
n 27(None)[]:
	i: 0(loop)
	o: 41(for), 118(AF)

nname: 0
n 0(None)[al = self._active_list
model_list = self.get_item_list(al)
]:
	i: 
	o: 27(loop), 118(AL)

nname: 41
n 41(None)[for engine in pygui_globs['menustack'].engines:
	for menu_widget in engine.menu_stack:
		for list_view in menu_widget.get_list_obj_by_name(al):
			if list_view.menu_list is model_list:
				return list_view
				continue
]:
	i: 0(for)
	o: 

nname: 0
n 0(None)[al = self._active_list
model_list = self.get_item_list(al)
]:
	i: 
	o: 41(for)

nname: 0
n 0(None)[al = self._active_list
model_list = self.get_item_list(al)
for engine in pygui_globs['menustack'].engines:
	for menu_widget in engine.menu_stack:
		for list_view in menu_widget.get_list_obj_by_name(al):
			if list_view.menu_list is model_list:
				return list_view
				continue
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7602c2c>}
nname: 6
n 6(None)[__doc__ = "\n    Base class for Menu application\n\n    A Menu is a fullscreen application, managed in a stack of Menus.\n    Events are send to the upper menu. The interface is described with an XML file\n    and the controler is simply a class inheriting from Menu.\n    This class must have an eventhandler acting on the controler.\n    Each menu has at least one list of items ('main', the default),\n     plus an arbitrary number others (item_list)\n    Ex : item_list 'main_list' contains Item1, Item2\n         item_list 'preview_list' contains ItemList1\n    These items can be acceded via 'get_item_list(list_name)', for all available list_name.\n    Only one item_list can be active (e.g. the focus on screen can be set on a single item_list at a time)\n    Items can be selected, to call methods on it for ex.\n    To change the selected item, you must use 'select(item, item_list)'. It is not allowed to change\n    the selected item or the internal choices directly.\n    It is obviously possible to add new Items to the Menu.\n    For this, you must use set_items(items, item_list)\n    "
_active_list = 'main_list'
toggleable = False
groupeable = False
_grouped_menu = 0
hold = False
show_help_banner = True
def _get_active_list(self):
	return self._active_list

def _set_active_list(self, val):
	dc = self._active_list
	if dc != val:
		louie_send('on_%s_blur' % dc, self)
		self._active_list = val
		louie_send('on_%s_focus' % val, self)
		self.choices.advertise()

active_list = property(_get_active_list, _set_active_list)
del _get_active_list
del _set_active_list
def focus_next(self):
	dc = self.active_list
	if dc != self.available_choices[-1]:
		idx = self.available_choices.index(dc)
		new_choice = self.available_choices[idx + 1]
		new_item_list = self.get_item_list(new_choice)
		if new_item_list:
			self.active_list = new_choice
			return True
	return False

def focus_previous(self):
	dc = self.active_list
	if dc != self.available_choices[0]:
		idx = self.available_choices.index(dc)
		new_choice = self.available_choices[idx - 1]
		new_item_list = self.get_item_list(new_choice)
		if new_item_list:
			self.active_list = new_choice
			return True
	return False

def __init__(self, name, choices=None, type='undefined', universe=None, timeout=None, parent=None, zone=None):
	self.name = name
	self.type = type
	self.universe = universe
	self.tasks = {'show_help': Task(self._show_help), 'hide_help': Task(self._hide_help), 'error_timeout': Task(self._error_canceler)}
	if not hasattr(self, 'zone'):
		self.zone = zone
	self.item_lists_dict = {}
	if choices is None:
		choices = []
	self.set_items(choices, self.active_list)
	self.available_choices = [self.active_list]
	self.item = None
	self._getitems_keywords = dict(menu_name=(lambda : self.name), item_name=self._get_item_name, main_list=(lambda : self.get_item_list('main_list')), menu_type_name=(lambda : self.type), parent_item_name=self._get_parent_item_name)
	if not hasattr(self, 'eventhandler'):
		self.eventhandler = MenuEventHandler(self)
	self.children = []
	self.parent = parent
	if timeout is not None:
		self._autohide_timeout = Task(self._autohide)
		self._autohide_timeout.delay = timeout
		self._autohide_timeout.ival = timeout
	else:
		self._autohide_timeout = None
	return None

def _error_spawner(self, prefix=None):
	error_timeout = self.tasks['error_timeout']
	if not error_timeout.running:
		txt = 'error_signal'
		if prefix is not None:
			txt = prefix + '_' + txt
		louie_send(txt, sender=self)
	error_timeout.start(HMI_BASE['error_signal_delay'])
	return None

def _error_canceler(self):
	louie_send('end_error_signal', sender=self)

def __repr__(self):
	return '<%s::%s @%x>' % (self.__class__.__name__, self.type, id(self))

def _get_item_name(self):
	sel = self.selected
	if sel:
		pass
	return ''

def _get_parent_item_name(self):
	item = self.item
	if item and item.type != 'main':
		return item.name
	return u''

def reload_func(self):
	self.show_help()

def reset(self, name='', choices=None, type=None, universe=None):
	self.name = name
	self.item = None
	self.universe = universe
	self._active_list = 'main_list'
	if type is not None:
		self.type = type
	self.item_lists_dict = dict()
	if not choices:
		pass
	self.set_items(choices, self.active_list)
	return None

def __getitem__(self, name):
	return self._getitems_keywords.get(name, (lambda : None))()

def clear(self):
	if self not in pygui_globs['menustack']:
		for k, v in self.item_lists_dict.iteritems():
			self.item_lists_dict[k].set_items([])
			v.selected = False
			v.menu = None
			v._data = None
	return None

def get_item_list(self, list_name=None):
	if not list_name:
		pass
	return self.item_lists_dict[list_name]

def get_create_item_list(self, list_name):
	if list_name not in self.item_lists_dict:
		self.add_item_list(list_name)
	return self.get_item_list(list_name)

choices = property(get_item_list, doc='helper to easily get the active choices')
def add_item_list(self, list_name, items=None):
	if list_name is not None:
		if not items:
			pass
		self.item_lists_dict[list_name] = ItemList(self, items, list_name)
	return None

def del_item_list(self, list_name):
	del self.item_lists_dict[list_name]

def set_items(self, items, list_name='main_list', position=0):
	item_list = self.get_create_item_list(list_name)
	item_list.set_items(items, position)
	if list_name == self._active_list:
		self._logselected()

def _get_selected(self):
	return self.get_item_list().selected

def _set_selected(self, value):
	self.get_item_list().select(value)

selected = property(_get_selected, _set_selected)
del _get_selected
del _set_selected
def _get_selected_pos(self):
	return self.get_item_list().selected_pos

selected_pos = property(_get_selected_pos)
del _get_selected_pos
def _logselected(self):
	try:
		if logselected is not None:
			logselected.write('%s\n' % self.selected.name)
			logselected.flush()
		else:
			if 'logselected' in plugins:
				pass

def select(self, item, list_name=None, force_pos=False):
	if self._autohide_timeout:
		log.debug('%s autohide postponed', self)
		self._autohide_timeout.start()
	if not list_name:
		pass
	val = self.get_item_list(list_name).select(item, force_pos)
	if val is not False:
		self._logselected()
	return val

def delete_item(self, item, list_name=None):
	if not list_name:
		pass
	actual_list = self.get_item_list(list_name)
	actual_list.remove(item)

def toggle_menu(self):
	stack = pygui_globs['menustack']
	from pygui.menu.players.core import Player
	for menu in stack.menus_stack:
		if isinstance(menu, Player):
			menu.toggle_menu()
			continue

def _show_help(self):
	if user_config['base']['help_banner']:
		if not self.tasks['hide_help'].running:
			louie_send('show_help', self)
			self.hide_help()

def show_help(self):
	if self.show_help_banner:
		self.tasks['show_help'].start(0.5)

def _hide_help(self):
	if user_config['base']['help_banner'] != 1:
		louie_send('hide_help', self)

def hide_help(self):
	if self.show_help_banner:
		self.tasks['hide_help'].start(HMI_BASE['helpbanner_duration'])

def show(self, hide_previous_menu=True, timeout=None):
	pygui_globs['menustack'].push_menu(self, hide_previous_menu)
	self.show_help()
	if self.parent:
		try:
			self.parent.children.append(self)
		except Exception, e:
			log.error('Cannot append %s to %s.children', self, self.parent)
			PRINT_EXCEPTION(e)
	if timeout is not None:
		if self._autohide_timeout is None:
			self._autohide_timeout = Task(self._autohide)
		self._autohide_timeout.delay = timeout
		self._autohide_timeout.ival = timeout
	if self._autohide_timeout:
		self._autohide_timeout.start()
	return None

def hide(self):
	if self._autohide_timeout:
		self._autohide_timeout.stop()
	if self.parent:
		try:
			self.parent.children.remove(self)
		except Exception, e:
			log.error('Error while removing %s from %s.children', self, self.parent)
			PRINT_EXCEPTION(e)
	stack = pygui_globs['menustack']
	try:
		stack.close_player(self)
	except ValueError:
		log.error("Can't hide %s !", self)
		PRINT_EXCEPTION()
	finally:
		self.hide_help()

def _autohide(self):
	if not self.children:
		log.debug('%s no children: calling hide()', self)
		Task(self._autohide_timeout.stop).start(0)
		self.hide()
	else:
		log.debug('%s has children %s ! avoid autohide', self, self.children)

def stop(self):
	log.debug('%s stopping. Stopping tasks...', self)
	for t in self.tasks.itervalues():
		t.stop()

def on_background(self):
	self.hide_help()

def on_foreground(self):
	self.show_help()

def _Menu__set_grouped_menu(self, value):
	self._grouped_menu = value
	if value:
		log.debug('Menu grouped with %r', self)
	else:
		log.debug('Menu ungrouped from %r', self)

def _Menu__get_grouped_menu(self):
	return self._grouped_menu

grouped_menu = property(_Menu__get_grouped_menu, _Menu__set_grouped_menu)
del _Menu__set_grouped_menu
del _Menu__get_grouped_menu
def _find_list_view(self):
	al = self._active_list
	model_list = self.get_item_list(al)
	for engine in pygui_globs['menustack'].engines:
		for menu_widget in engine.menu_stack:
			for list_view in menu_widget.get_list_obj_by_name(al):
				if list_view.menu_list is model_list:
					return list_view
					continue

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb76686ac>}
nname: 0
n 0(None)[return self.get_item_list('options_list')
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7662e2c>}
nname: 0
n 0(None)[return self.get_item_list('options_list')
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7662eec>}
nname: 0
n 0(None)[Menu.__init__(self, name, choices, type, universe, *args, **kw)
self.available_choices.append('options_list')
self._getitems_keywords.update({'options_list': (lambda : self.get_item_list('options_list'))})
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7662b8c>}
nname: 165
n 165(None)[]:
	i: 128(), 148()
	o: 

nname: 148
n 148(None)[louie_send('empty_options', sender=self)
]:
	i: 97(f)
	o: 165()

nname: 128
n 128(None)[louie_send('not_empty_options', sender=self)
]:
	i: 97(t)
	o: 165()

nname: 97
n 97(browsed)[self.set_items(browsed, list_name='options_list', position=index)
]:
	i: 68(), 90()
	o: 128(t), 148(f)

nname: 90
n 90(None)[index = -1
]:
	i: 62(f)
	o: 97()

nname: 68
n 68(None)[index = self.get_item_list('options_list').selected_pos
]:
	i: 62(t)
	o: 97()

nname: 62
n 62(keep_selection)[]:
	i: 21(), 47(), 60(AE)
	o: 68(t), 90(f)

nname: 60
n 60(None)[]:
	i: 37(f)
	o: 62(AE)

nname: 47
n 47(None)[browsed = []
]:
	i: 37(t)
	o: 62()

nname: 37
n 37(<dummy_ex3> EXC_MATCH AttributeError)[]:
	i: 0(except)
	o: 47(t), 60(f)

nname: 21
n 21(None)[browsed = selection.browse()
]:
	i: 0(try)
	o: 62()

nname: 0
n 0(None)[selection = self.get_item_list('main_list').selected
]:
	i: 
	o: 21(try), 37(except)

nname: 97
n 97(None)[self.set_items(browsed, list_name='options_list', position=index)
if browsed:
	louie_send('not_empty_options', sender=self)
else:
	louie_send('empty_options', sender=self)
]:
	i: 37()
	o: 

nname: 37
n 37(None)[except AttributeError:
	browsed = []
if keep_selection:
	index = self.get_item_list('options_list').selected_pos
else:
	index = -1
]:
	i: 0()
	o: 97()

nname: 0
n 0(None)[selection = self.get_item_list('main_list').selected
try:
	browsed = selection.browse()
]:
	i: 
	o: 37()

nname: 97
n 97(None)[self.set_items(browsed, list_name='options_list', position=index)
if browsed:
	louie_send('not_empty_options', sender=self)
else:
	louie_send('empty_options', sender=self)
]:
	i: 0()
	o: 

nname: 0
n 0(None)[selection = self.get_item_list('main_list').selected
try:
	browsed = selection.browse()
except AttributeError:
	browsed = []
if keep_selection:
	index = self.get_item_list('options_list').selected_pos
else:
	index = -1
]:
	i: 
	o: 97()

nname: 0
n 0(None)[selection = self.get_item_list('main_list').selected
try:
	browsed = selection.browse()
except AttributeError:
	browsed = []
if keep_selection:
	index = self.get_item_list('options_list').selected_pos
else:
	index = -1
self.set_items(browsed, list_name='options_list', position=index)
if browsed:
	louie_send('not_empty_options', sender=self)
else:
	louie_send('empty_options', sender=self)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7662aac>}
nname: 61
n 61(None)[return ret
]:
	i: 46(), 60()
	o: 

nname: 60
n 60(None)[]:
	i: 0&30(f)
	o: 61()

nname: 46
n 46(None)[self._set_options_list()
]:
	i: 0&30(t)
	o: 61()

nname: 0&30
n 0&30(ret and self.active_list == 'main_list')[ret = Menu.select(self, item, list_name, force_pos)
]:
	i: 
	o: 46(t), 60(f)

nname: 0&30
n 0&30(None)[ret = Menu.select(self, item, list_name, force_pos)
if ret and self.active_list == 'main_list':
	self._set_options_list()
return ret
]:
	i: 
	o: 

self.nodes: {'0&30': <unpyclib.structure.node instance at 0xb7663f4c>}
nname: 69
n 69(None)[return ret
]:
	i: 52(), 68()
	o: 

nname: 68
n 68(None)[]:
	i: 0(f)
	o: 69()

nname: 52
n 52(None)[self.select(0)
]:
	i: 37(), 51()
	o: 69()

nname: 51
n 51(None)[]:
	i: 21(f)
	o: 52()

nname: 37
n 37(None)[self._set_options_list()
]:
	i: 21(t)
	o: 52()

nname: 21
n 21(self._active_list == 'main_list')[]:
	i: 0(t)
	o: 37(t), 51(f)

nname: 0
n 0(ret)[ret = Menu.focus_next(self)
]:
	i: 
	o: 21(t), 68(f)

nname: 69
n 69(None)[return ret
]:
	i: 21(), 0(f)
	o: 

nname: 21
n 21(None)[if self._active_list == 'main_list':
	self._set_options_list()
self.select(0)
]:
	i: 0(t)
	o: 69()

nname: 0
n 0(ret)[ret = Menu.focus_next(self)
]:
	i: 
	o: 21(t), 69(f)

nname: 0
n 0(None)[ret = Menu.focus_next(self)
if ret:
	if self._active_list == 'main_list':
		self._set_options_list()
	self.select(0)
return ret
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7663f6c>}
nname: 39
n 39(None)[return ret
]:
	i: 21(), 38()
	o: 

nname: 38
n 38(None)[]:
	i: 0(f)
	o: 39()

nname: 21
n 21(None)[self._set_options_list(False)
]:
	i: 0(t)
	o: 39()

nname: 0
n 0(ret)[ret = Menu.focus_previous(self)
]:
	i: 
	o: 21(t), 38(f)

nname: 0
n 0(None)[ret = Menu.focus_previous(self)
if ret:
	self._set_options_list(False)
return ret
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7663ecc>}
nname: 0
n 0(None)[return Menu.show(self, False, *args, **kw)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7663dac>}
nname: 6
n 6(None)[__doc__ = "Menu with a few extra features to handle an options_list:\n        - automatic update of the options_list when browsing the main_list (if the\n          selected item has a browse() method, it's called to populate it) or on\n          focus changes.\n    "
groupeable = True
def __init__(self, name, choices=[], type=None, universe=None, *args, **args):
	Menu.__init__(self, name, choices, type, universe, *args, **kw)
	self.available_choices.append('options_list')
	self._getitems_keywords.update({'options_list': (lambda : self.get_item_list('options_list'))})

def _set_options_list(self, keep_selection=False):
	selection = self.get_item_list('main_list').selected
	try:
		browsed = selection.browse()
	except AttributeError:
		browsed = []
	if keep_selection:
		index = self.get_item_list('options_list').selected_pos
	else:
		index = -1
	self.set_items(browsed, list_name='options_list', position=index)
	if browsed:
		louie_send('not_empty_options', sender=self)
	else:
		louie_send('empty_options', sender=self)

def select(self, item, list_name=None, force_pos=False):
	ret = Menu.select(self, item, list_name, force_pos)
	if ret and self.active_list == 'main_list':
		self._set_options_list()
	return ret

def focus_next(self):
	ret = Menu.focus_next(self)
	if ret:
		if self._active_list == 'main_list':
			self._set_options_list()
		self.select(0)
	return ret

def focus_previous(self):
	ret = Menu.focus_previous(self)
	if ret:
		self._set_options_list(False)
	return ret

def show(self, *args, **args):
	return Menu.show(self, False, *args, **kw)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb7663b4c>}
nname: 0
n 0(None)[from __future__ import absolute_import
from peewee.debug import GET_LOGGER, PRINT_EXCEPTION
from peewee.messages import send as louie_send
from peewee.notifier import Task
from pygui.config import user_config, HMI_BASE
from pygui.eventmanager.menus import MenuEventHandler
from pygui.facilities.l10n import omnicode
from pygui.item.containers import ItemList
from pygui.shared import pygui_globs
log = GET_LOGGER(__name__)
class UDPSender(object):
	def __init__(self, host='172.16.10.66', port=2345):
		self.addr = (host, port)
		self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

	def write(self, msg):
		self.sock.sendto(msg, self.addr)

	def flush(self):
		pass



class Menu(object):
	__doc__ = "\n    Base class for Menu application\n\n    A Menu is a fullscreen application, managed in a stack of Menus.\n    Events are send to the upper menu. The interface is described with an XML file\n    and the controler is simply a class inheriting from Menu.\n    This class must have an eventhandler acting on the controler.\n    Each menu has at least one list of items ('main', the default),\n     plus an arbitrary number others (item_list)\n    Ex : item_list 'main_list' contains Item1, Item2\n         item_list 'preview_list' contains ItemList1\n    These items can be acceded via 'get_item_list(list_name)', for all available list_name.\n    Only one item_list can be active (e.g. the focus on screen can be set on a single item_list at a time)\n    Items can be selected, to call methods on it for ex.\n    To change the selected item, you must use 'select(item, item_list)'. It is not allowed to change\n    the selected item or the internal choices directly.\n    It is obviously possible to add new Items to the Menu.\n    For this, you must use set_items(items, item_list)\n    "
	_active_list = 'main_list'
	toggleable = False
	groupeable = False
	_grouped_menu = 0
	hold = False
	show_help_banner = True
	def _get_active_list(self):
		return self._active_list

	def _set_active_list(self, val):
		dc = self._active_list
		if dc != val:
			louie_send('on_%s_blur' % dc, self)
			self._active_list = val
			louie_send('on_%s_focus' % val, self)
			self.choices.advertise()

	active_list = property(_get_active_list, _set_active_list)
	del _get_active_list
	del _set_active_list
	def focus_next(self):
		dc = self.active_list
		if dc != self.available_choices[-1]:
			idx = self.available_choices.index(dc)
			new_choice = self.available_choices[idx + 1]
			new_item_list = self.get_item_list(new_choice)
			if new_item_list:
				self.active_list = new_choice
				return True
		return False

	def focus_previous(self):
		dc = self.active_list
		if dc != self.available_choices[0]:
			idx = self.available_choices.index(dc)
			new_choice = self.available_choices[idx - 1]
			new_item_list = self.get_item_list(new_choice)
			if new_item_list:
				self.active_list = new_choice
				return True
		return False

	def __init__(self, name, choices=None, type='undefined', universe=None, timeout=None, parent=None, zone=None):
		self.name = name
		self.type = type
		self.universe = universe
		self.tasks = {'show_help': Task(self._show_help), 'hide_help': Task(self._hide_help), 'error_timeout': Task(self._error_canceler)}
		if not hasattr(self, 'zone'):
			self.zone = zone
		self.item_lists_dict = {}
		if choices is None:
			choices = []
		self.set_items(choices, self.active_list)
		self.available_choices = [self.active_list]
		self.item = None
		self._getitems_keywords = dict(menu_name=(lambda : self.name), item_name=self._get_item_name, main_list=(lambda : self.get_item_list('main_list')), menu_type_name=(lambda : self.type), parent_item_name=self._get_parent_item_name)
		if not hasattr(self, 'eventhandler'):
			self.eventhandler = MenuEventHandler(self)
		self.children = []
		self.parent = parent
		if timeout is not None:
			self._autohide_timeout = Task(self._autohide)
			self._autohide_timeout.delay = timeout
			self._autohide_timeout.ival = timeout
		else:
			self._autohide_timeout = None
		return None

	def _error_spawner(self, prefix=None):
		error_timeout = self.tasks['error_timeout']
		if not error_timeout.running:
			txt = 'error_signal'
			if prefix is not None:
				txt = prefix + '_' + txt
			louie_send(txt, sender=self)
		error_timeout.start(HMI_BASE['error_signal_delay'])
		return None

	def _error_canceler(self):
		louie_send('end_error_signal', sender=self)

	def __repr__(self):
		return '<%s::%s @%x>' % (self.__class__.__name__, self.type, id(self))

	def _get_item_name(self):
		sel = self.selected
		if sel:
			pass
		return ''

	def _get_parent_item_name(self):
		item = self.item
		if item and item.type != 'main':
			return item.name
		return u''

	def reload_func(self):
		self.show_help()

	def reset(self, name='', choices=None, type=None, universe=None):
		self.name = name
		self.item = None
		self.universe = universe
		self._active_list = 'main_list'
		if type is not None:
			self.type = type
		self.item_lists_dict = dict()
		if not choices:
			pass
		self.set_items(choices, self.active_list)
		return None

	def __getitem__(self, name):
		return self._getitems_keywords.get(name, (lambda : None))()

	def clear(self):
		if self not in pygui_globs['menustack']:
			for k, v in self.item_lists_dict.iteritems():
				self.item_lists_dict[k].set_items([])
				v.selected = False
				v.menu = None
				v._data = None
		return None

	def get_item_list(self, list_name=None):
		if not list_name:
			pass
		return self.item_lists_dict[list_name]

	def get_create_item_list(self, list_name):
		if list_name not in self.item_lists_dict:
			self.add_item_list(list_name)
		return self.get_item_list(list_name)

	choices = property(get_item_list, doc='helper to easily get the active choices')
	def add_item_list(self, list_name, items=None):
		if list_name is not None:
			if not items:
				pass
			self.item_lists_dict[list_name] = ItemList(self, items, list_name)
		return None

	def del_item_list(self, list_name):
		del self.item_lists_dict[list_name]

	def set_items(self, items, list_name='main_list', position=0):
		item_list = self.get_create_item_list(list_name)
		item_list.set_items(items, position)
		if list_name == self._active_list:
			self._logselected()

	def _get_selected(self):
		return self.get_item_list().selected

	def _set_selected(self, value):
		self.get_item_list().select(value)

	selected = property(_get_selected, _set_selected)
	del _get_selected
	del _set_selected
	def _get_selected_pos(self):
		return self.get_item_list().selected_pos

	selected_pos = property(_get_selected_pos)
	del _get_selected_pos
	def _logselected(self):
		try:
			if logselected is not None:
				logselected.write('%s\n' % self.selected.name)
				logselected.flush()
			else:
				if 'logselected' in plugins:
					pass

	def select(self, item, list_name=None, force_pos=False):
		if self._autohide_timeout:
			log.debug('%s autohide postponed', self)
			self._autohide_timeout.start()
		if not list_name:
			pass
		val = self.get_item_list(list_name).select(item, force_pos)
		if val is not False:
			self._logselected()
		return val

	def delete_item(self, item, list_name=None):
		if not list_name:
			pass
		actual_list = self.get_item_list(list_name)
		actual_list.remove(item)

	def toggle_menu(self):
		stack = pygui_globs['menustack']
		from pygui.menu.players.core import Player
		for menu in stack.menus_stack:
			if isinstance(menu, Player):
				menu.toggle_menu()
				continue

	def _show_help(self):
		if user_config['base']['help_banner']:
			if not self.tasks['hide_help'].running:
				louie_send('show_help', self)
				self.hide_help()

	def show_help(self):
		if self.show_help_banner:
			self.tasks['show_help'].start(0.5)

	def _hide_help(self):
		if user_config['base']['help_banner'] != 1:
			louie_send('hide_help', self)

	def hide_help(self):
		if self.show_help_banner:
			self.tasks['hide_help'].start(HMI_BASE['helpbanner_duration'])

	def show(self, hide_previous_menu=True, timeout=None):
		pygui_globs['menustack'].push_menu(self, hide_previous_menu)
		self.show_help()
		if self.parent:
			try:
				self.parent.children.append(self)
			except Exception, e:
				log.error('Cannot append %s to %s.children', self, self.parent)
				PRINT_EXCEPTION(e)
		if timeout is not None:
			if self._autohide_timeout is None:
				self._autohide_timeout = Task(self._autohide)
			self._autohide_timeout.delay = timeout
			self._autohide_timeout.ival = timeout
		if self._autohide_timeout:
			self._autohide_timeout.start()
		return None

	def hide(self):
		if self._autohide_timeout:
			self._autohide_timeout.stop()
		if self.parent:
			try:
				self.parent.children.remove(self)
			except Exception, e:
				log.error('Error while removing %s from %s.children', self, self.parent)
				PRINT_EXCEPTION(e)
		stack = pygui_globs['menustack']
		try:
			stack.close_player(self)
		except ValueError:
			log.error("Can't hide %s !", self)
			PRINT_EXCEPTION()
		finally:
			self.hide_help()

	def _autohide(self):
		if not self.children:
			log.debug('%s no children: calling hide()', self)
			Task(self._autohide_timeout.stop).start(0)
			self.hide()
		else:
			log.debug('%s has children %s ! avoid autohide', self, self.children)

	def stop(self):
		log.debug('%s stopping. Stopping tasks...', self)
		for t in self.tasks.itervalues():
			t.stop()

	def on_background(self):
		self.hide_help()

	def on_foreground(self):
		self.show_help()

	def _Menu__set_grouped_menu(self, value):
		self._grouped_menu = value
		if value:
			log.debug('Menu grouped with %r', self)
		else:
			log.debug('Menu ungrouped from %r', self)

	def _Menu__get_grouped_menu(self):
		return self._grouped_menu

	grouped_menu = property(_Menu__get_grouped_menu, _Menu__set_grouped_menu)
	del _Menu__set_grouped_menu
	del _Menu__get_grouped_menu
	def _find_list_view(self):
		al = self._active_list
		model_list = self.get_item_list(al)
		for engine in pygui_globs['menustack'].engines:
			for menu_widget in engine.menu_stack:
				for list_view in menu_widget.get_list_obj_by_name(al):
					if list_view.menu_list is model_list:
						return list_view
						continue



class ContextMenu(Menu):
	__doc__ = "Menu with a few extra features to handle an options_list:\n        - automatic update of the options_list when browsing the main_list (if the\n          selected item has a browse() method, it's called to populate it) or on\n          focus changes.\n    "
	groupeable = True
	def __init__(self, name, choices=[], type=None, universe=None, *args, **args):
		Menu.__init__(self, name, choices, type, universe, *args, **kw)
		self.available_choices.append('options_list')
		self._getitems_keywords.update({'options_list': (lambda : self.get_item_list('options_list'))})

	def _set_options_list(self, keep_selection=False):
		selection = self.get_item_list('main_list').selected
		try:
			browsed = selection.browse()
		except AttributeError:
			browsed = []
		if keep_selection:
			index = self.get_item_list('options_list').selected_pos
		else:
			index = -1
		self.set_items(browsed, list_name='options_list', position=index)
		if browsed:
			louie_send('not_empty_options', sender=self)
		else:
			louie_send('empty_options', sender=self)

	def select(self, item, list_name=None, force_pos=False):
		ret = Menu.select(self, item, list_name, force_pos)
		if ret and self.active_list == 'main_list':
			self._set_options_list()
		return ret

	def focus_next(self):
		ret = Menu.focus_next(self)
		if ret:
			if self._active_list == 'main_list':
				self._set_options_list()
			self.select(0)
		return ret

	def focus_previous(self):
		ret = Menu.focus_previous(self)
		if ret:
			self._set_options_list(False)
		return ret

	def show(self, *args, **args):
		return Menu.show(self, False, *args, **kw)



]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb765776c>}
from __future__ import absolute_import
from peewee.debug import GET_LOGGER, PRINT_EXCEPTION
from peewee.messages import send as louie_send
from peewee.notifier import Task
from pygui.config import user_config, HMI_BASE
from pygui.eventmanager.menus import MenuEventHandler
from pygui.facilities.l10n import omnicode
from pygui.item.containers import ItemList
from pygui.shared import pygui_globs
log = GET_LOGGER(__name__)
class UDPSender(object):
	def __init__(self, host='172.16.10.66', port=2345):
		self.addr = (host, port)
		self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

	def write(self, msg):
		self.sock.sendto(msg, self.addr)

	def flush(self):
		pass



class Menu(object):
	__doc__ = "\n    Base class for Menu application\n\n    A Menu is a fullscreen application, managed in a stack of Menus.\n    Events are send to the upper menu. The interface is described with an XML file\n    and the controler is simply a class inheriting from Menu.\n    This class must have an eventhandler acting on the controler.\n    Each menu has at least one list of items ('main', the default),\n     plus an arbitrary number others (item_list)\n    Ex : item_list 'main_list' contains Item1, Item2\n         item_list 'preview_list' contains ItemList1\n    These items can be acceded via 'get_item_list(list_name)', for all available list_name.\n    Only one item_list can be active (e.g. the focus on screen can be set on a single item_list at a time)\n    Items can be selected, to call methods on it for ex.\n    To change the selected item, you must use 'select(item, item_list)'. It is not allowed to change\n    the selected item or the internal choices directly.\n    It is obviously possible to add new Items to the Menu.\n    For this, you must use set_items(items, item_list)\n    "
	_active_list = 'main_list'
	toggleable = False
	groupeable = False
	_grouped_menu = 0
	hold = False
	show_help_banner = True
	def _get_active_list(self):
		return self._active_list

	def _set_active_list(self, val):
		dc = self._active_list
		if dc != val:
			louie_send('on_%s_blur' % dc, self)
			self._active_list = val
			louie_send('on_%s_focus' % val, self)
			self.choices.advertise()

	active_list = property(_get_active_list, _set_active_list)
	del _get_active_list
	del _set_active_list
	def focus_next(self):
		dc = self.active_list
		if dc != self.available_choices[-1]:
			idx = self.available_choices.index(dc)
			new_choice = self.available_choices[idx + 1]
			new_item_list = self.get_item_list(new_choice)
			if new_item_list:
				self.active_list = new_choice
				return True
		return False

	def focus_previous(self):
		dc = self.active_list
		if dc != self.available_choices[0]:
			idx = self.available_choices.index(dc)
			new_choice = self.available_choices[idx - 1]
			new_item_list = self.get_item_list(new_choice)
			if new_item_list:
				self.active_list = new_choice
				return True
		return False

	def __init__(self, name, choices=None, type='undefined', universe=None, timeout=None, parent=None, zone=None):
		self.name = name
		self.type = type
		self.universe = universe
		self.tasks = {'show_help': Task(self._show_help), 'hide_help': Task(self._hide_help), 'error_timeout': Task(self._error_canceler)}
		if not hasattr(self, 'zone'):
			self.zone = zone
		self.item_lists_dict = {}
		if choices is None:
			choices = []
		self.set_items(choices, self.active_list)
		self.available_choices = [self.active_list]
		self.item = None
		self._getitems_keywords = dict(menu_name=(lambda : self.name), item_name=self._get_item_name, main_list=(lambda : self.get_item_list('main_list')), menu_type_name=(lambda : self.type), parent_item_name=self._get_parent_item_name)
		if not hasattr(self, 'eventhandler'):
			self.eventhandler = MenuEventHandler(self)
		self.children = []
		self.parent = parent
		if timeout is not None:
			self._autohide_timeout = Task(self._autohide)
			self._autohide_timeout.delay = timeout
			self._autohide_timeout.ival = timeout
		else:
			self._autohide_timeout = None
		return None

	def _error_spawner(self, prefix=None):
		error_timeout = self.tasks['error_timeout']
		if not error_timeout.running:
			txt = 'error_signal'
			if prefix is not None:
				txt = prefix + '_' + txt
			louie_send(txt, sender=self)
		error_timeout.start(HMI_BASE['error_signal_delay'])
		return None

	def _error_canceler(self):
		louie_send('end_error_signal', sender=self)

	def __repr__(self):
		return '<%s::%s @%x>' % (self.__class__.__name__, self.type, id(self))

	def _get_item_name(self):
		sel = self.selected
		if sel:
			pass
		return ''

	def _get_parent_item_name(self):
		item = self.item
		if item and item.type != 'main':
			return item.name
		return u''

	def reload_func(self):
		self.show_help()

	def reset(self, name='', choices=None, type=None, universe=None):
		self.name = name
		self.item = None
		self.universe = universe
		self._active_list = 'main_list'
		if type is not None:
			self.type = type
		self.item_lists_dict = dict()
		if not choices:
			pass
		self.set_items(choices, self.active_list)
		return None

	def __getitem__(self, name):
		return self._getitems_keywords.get(name, (lambda : None))()

	def clear(self):
		if self not in pygui_globs['menustack']:
			for k, v in self.item_lists_dict.iteritems():
				self.item_lists_dict[k].set_items([])
				v.selected = False
				v.menu = None
				v._data = None
		return None

	def get_item_list(self, list_name=None):
		if not list_name:
			pass
		return self.item_lists_dict[list_name]

	def get_create_item_list(self, list_name):
		if list_name not in self.item_lists_dict:
			self.add_item_list(list_name)
		return self.get_item_list(list_name)

	choices = property(get_item_list, doc='helper to easily get the active choices')
	def add_item_list(self, list_name, items=None):
		if list_name is not None:
			if not items:
				pass
			self.item_lists_dict[list_name] = ItemList(self, items, list_name)
		return None

	def del_item_list(self, list_name):
		del self.item_lists_dict[list_name]

	def set_items(self, items, list_name='main_list', position=0):
		item_list = self.get_create_item_list(list_name)
		item_list.set_items(items, position)
		if list_name == self._active_list:
			self._logselected()

	def _get_selected(self):
		return self.get_item_list().selected

	def _set_selected(self, value):
		self.get_item_list().select(value)

	selected = property(_get_selected, _set_selected)
	del _get_selected
	del _set_selected
	def _get_selected_pos(self):
		return self.get_item_list().selected_pos

	selected_pos = property(_get_selected_pos)
	del _get_selected_pos
	def _logselected(self):
		try:
			if logselected is not None:
				logselected.write('%s\n' % self.selected.name)
				logselected.flush()
			else:
				if 'logselected' in plugins:
					pass

	def select(self, item, list_name=None, force_pos=False):
		if self._autohide_timeout:
			log.debug('%s autohide postponed', self)
			self._autohide_timeout.start()
		if not list_name:
			pass
		val = self.get_item_list(list_name).select(item, force_pos)
		if val is not False:
			self._logselected()
		return val

	def delete_item(self, item, list_name=None):
		if not list_name:
			pass
		actual_list = self.get_item_list(list_name)
		actual_list.remove(item)

	def toggle_menu(self):
		stack = pygui_globs['menustack']
		from pygui.menu.players.core import Player
		for menu in stack.menus_stack:
			if isinstance(menu, Player):
				menu.toggle_menu()
				continue

	def _show_help(self):
		if user_config['base']['help_banner']:
			if not self.tasks['hide_help'].running:
				louie_send('show_help', self)
				self.hide_help()

	def show_help(self):
		if self.show_help_banner:
			self.tasks['show_help'].start(0.5)

	def _hide_help(self):
		if user_config['base']['help_banner'] != 1:
			louie_send('hide_help', self)

	def hide_help(self):
		if self.show_help_banner:
			self.tasks['hide_help'].start(HMI_BASE['helpbanner_duration'])

	def show(self, hide_previous_menu=True, timeout=None):
		pygui_globs['menustack'].push_menu(self, hide_previous_menu)
		self.show_help()
		if self.parent:
			try:
				self.parent.children.append(self)
			except Exception, e:
				log.error('Cannot append %s to %s.children', self, self.parent)
				PRINT_EXCEPTION(e)
		if timeout is not None:
			if self._autohide_timeout is None:
				self._autohide_timeout = Task(self._autohide)
			self._autohide_timeout.delay = timeout
			self._autohide_timeout.ival = timeout
		if self._autohide_timeout:
			self._autohide_timeout.start()
		return None

	def hide(self):
		if self._autohide_timeout:
			self._autohide_timeout.stop()
		if self.parent:
			try:
				self.parent.children.remove(self)
			except Exception, e:
				log.error('Error while removing %s from %s.children', self, self.parent)
				PRINT_EXCEPTION(e)
		stack = pygui_globs['menustack']
		try:
			stack.close_player(self)
		except ValueError:
			log.error("Can't hide %s !", self)
			PRINT_EXCEPTION()
		finally:
			self.hide_help()

	def _autohide(self):
		if not self.children:
			log.debug('%s no children: calling hide()', self)
			Task(self._autohide_timeout.stop).start(0)
			self.hide()
		else:
			log.debug('%s has children %s ! avoid autohide', self, self.children)

	def stop(self):
		log.debug('%s stopping. Stopping tasks...', self)
		for t in self.tasks.itervalues():
			t.stop()

	def on_background(self):
		self.hide_help()

	def on_foreground(self):
		self.show_help()

	def _Menu__set_grouped_menu(self, value):
		self._grouped_menu = value
		if value:
			log.debug('Menu grouped with %r', self)
		else:
			log.debug('Menu ungrouped from %r', self)

	def _Menu__get_grouped_menu(self):
		return self._grouped_menu

	grouped_menu = property(_Menu__get_grouped_menu, _Menu__set_grouped_menu)
	del _Menu__set_grouped_menu
	del _Menu__get_grouped_menu
	def _find_list_view(self):
		al = self._active_list
		model_list = self.get_item_list(al)
		for engine in pygui_globs['menustack'].engines:
			for menu_widget in engine.menu_stack:
				for list_view in menu_widget.get_list_obj_by_name(al):
					if list_view.menu_list is model_list:
						return list_view
						continue



class ContextMenu(Menu):
	__doc__ = "Menu with a few extra features to handle an options_list:\n        - automatic update of the options_list when browsing the main_list (if the\n          selected item has a browse() method, it's called to populate it) or on\n          focus changes.\n    "
	groupeable = True
	def __init__(self, name, choices=[], type=None, universe=None, *args, **args):
		Menu.__init__(self, name, choices, type, universe, *args, **kw)
		self.available_choices.append('options_list')
		self._getitems_keywords.update({'options_list': (lambda : self.get_item_list('options_list'))})

	def _set_options_list(self, keep_selection=False):
		selection = self.get_item_list('main_list').selected
		try:
			browsed = selection.browse()
		except AttributeError:
			browsed = []
		if keep_selection:
			index = self.get_item_list('options_list').selected_pos
		else:
			index = -1
		self.set_items(browsed, list_name='options_list', position=index)
		if browsed:
			louie_send('not_empty_options', sender=self)
		else:
			louie_send('empty_options', sender=self)

	def select(self, item, list_name=None, force_pos=False):
		ret = Menu.select(self, item, list_name, force_pos)
		if ret and self.active_list == 'main_list':
			self._set_options_list()
		return ret

	def focus_next(self):
		ret = Menu.focus_next(self)
		if ret:
			if self._active_list == 'main_list':
				self._set_options_list()
			self.select(0)
		return ret

	def focus_previous(self):
		ret = Menu.focus_previous(self)
		if ret:
			self._set_options_list(False)
		return ret

	def show(self, *args, **args):
		return Menu.show(self, False, *args, **kw)



