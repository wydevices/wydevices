# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 60
n 60(None)[return ret
]:
	i: 9(), 41(), 58(AE)
	o: 

nname: 58
n 58(None)[]:
	i: 31(f)
	o: 60(AE)

nname: 41
n 41(None)[self.back_to_root()
]:
	i: 31(t)
	o: 60()

nname: 31
n 31(<dummy_ex3> EXC_MATCH BrowseError)[]:
	i: 0(except)
	o: 41(t), 58(f)

nname: 9
n 9(None)[ret = fn(self, *args, **kw)
]:
	i: 0(try)
	o: 60()

nname: 0
n 0(None)[ret = None
]:
	i: 
	o: 9(try), 31(except)

nname: 31
n 31(None)[except BrowseError:
	self.back_to_root()
return ret
]:
	i: 0()
	o: 

nname: 0
n 0(None)[ret = None
try:
	ret = fn(self, *args, **kw)
]:
	i: 
	o: 31()

nname: 0
n 0(None)[ret = None
try:
	ret = fn(self, *args, **kw)
except BrowseError:
	self.back_to_root()
return ret
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e4de4c>}
nname: 0
n 0(None)[def wrap(self, *args, **args):
	ret = None
	try:
		ret = fn(self, *args, **kw)
	except BrowseError:
		self.back_to_root()
	return ret

wrap.__name__ = fn.__name__
return wrap
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e4be6c>}
nname: 0
n 0(None)[Item.__init__(self, _('No content'), type_='empty', display_type='empty')
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e4d98c>}
nname: 0
n 0(None)[return _('No content')
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e4d32c>}
nname: 0
n 0(None)[return _('No content')
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e4d3ac>}
nname: 6
n 6(None)[__doc__ = ' A simple item to put in empty places to signal it '
__metaclass__ = MetaSingleton
def __init__(self):
	Item.__init__(self, _('No content'), type_='empty', display_type='empty')

name = property((lambda self: _('No content')))
]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0x9e4bf2c>}
nname: 0
n 0(None)[Item.__init__(self, _('No content for this universe'), type_='empty', display_type='empty')
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e4d7cc>}
nname: 0
n 0(None)[return _('No content for this universe')
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e4d36c>}
nname: 0
n 0(None)[return _('No content for this universe')
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e4d2ec>}
nname: 6
n 6(None)[__doc__ = ' A simple item to put in empty places to signal it '
__metaclass__ = MetaSingleton
def __init__(self):
	Item.__init__(self, _('No content for this universe'), type_='empty', display_type='empty')

name = property((lambda self: _('No content for this universe')))
]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0x9e4becc>}
nname: 0
n 0(None)[return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e5054c>}
nname: 68
n 68(None)[self._modification_handler = on_modify
return None
]:
	i: 55(t), 61()
	o: 

nname: 61
n 61(None)[]:
	i: 55(f)
	o: 68()

nname: 55
n 55(on_modify)[]:
	i: 39(JA), 50(), 54()
	o: 61(f), 68(t)

nname: 54
n 54(None)[]:
	i: 0(f)
	o: 55()

nname: 50
n 50(None)[]:
	i: 25(f)
	o: 55()

nname: 39
n 39(None)[on_modify()
]:
	i: 25(t)
	o: 55(JA)

nname: 25
n 25(on_modify)[self[:] = history
]:
	i: 0(t)
	o: 39(t), 50(f)

nname: 0
n 0(history is not None)[list.__init__(self)
]:
	i: 
	o: 25(t), 54(f)

nname: 68
n 68(None)[self._modification_handler = on_modify
return None
]:
	i: 0(t)
	o: 

nname: 0
n 0(None)[list.__init__(self)
if history is not None:
	self[:] = history
	if on_modify:
		on_modify()
if not on_modify:
	pass
]:
	i: 
	o: 68()

nname: 0
n 0(None)[list.__init__(self)
if history is not None:
	self[:] = history
	if on_modify:
		on_modify()
if not on_modify:
	pass
self._modification_handler = on_modify
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e4dc6c>}
nname: 0
n 0(None)[ret = list.pop(self, *args, **kw)
self._modification_handler()
return ret
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e4d90c>}
nname: 0
n 0(None)[ret = list.append(self, *args, **kw)
self._modification_handler()
return ret
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e4d9ac>}
nname: 0
n 0(None)[self[:] = list()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e4d9ac>}
nname: 6
n 6(None)[__doc__ = ' stack-like class with modification notification handler '
def __init__(self, history=None, on_modify=None):
	list.__init__(self)
	if history is not None:
		self[:] = history
		if on_modify:
			on_modify()
	if not on_modify:
		pass
	self._modification_handler = on_modify
	return None

def pop(self, *args, **args):
	ret = list.pop(self, *args, **kw)
	self._modification_handler()
	return ret

def append(self, *args, **args):
	ret = list.append(self, *args, **kw)
	self._modification_handler()
	return ret

def empty(self):
	self[:] = list()

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0x9e4bd4c>}
nname: 33
n 33(None)[return u''
]:
	i: 15(), 29()
	o: 

nname: 29
n 29(None)[]:
	i: 0(f)
	o: 33()

nname: 15
n 15(None)[]:
	i: 0(t)
	o: 33()

nname: 0
n 0(self.selected is not None)[]:
	i: 
	o: 15(t), 29(f)

nname: 0
n 0(None)[if self.selected is not None:
	pass
return u''
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e5beac>}
nname: 33
n 33(None)[return u''
]:
	i: 15(), 29()
	o: 

nname: 29
n 29(None)[]:
	i: 0(f)
	o: 33()

nname: 15
n 15(None)[]:
	i: 0(t)
	o: 33()

nname: 0
n 0(self.selected is not None)[]:
	i: 
	o: 15(t), 29(f)

nname: 0
n 0(None)[if self.selected is not None:
	pass
return u''
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e5bd6c>}
nname: 57
n 57(None)[return ''
]:
	i: 34(), 53()
	o: 

nname: 53
n 53(None)[]:
	i: 0&15(f)
	o: 57()

nname: 34
n 34(None)[]:
	i: 0&15(t)
	o: 57()

nname: 0&15
n 0&15(self.selected is not None and self.selected.type in ('image',))[]:
	i: 
	o: 34(t), 53(f)

nname: 0&15
n 0&15(None)[if self.selected is not None and self.selected.type in ('image',):
	pass
return ''
]:
	i: 
	o: 

self.nodes: {'0&15': <unpyclib.structure.node instance at 0x9e5bd4c>}
nname: 51
n 51(None)[return ''
]:
	i: 34(), 47()
	o: 

nname: 47
n 47(None)[]:
	i: 0&15(f)
	o: 51()

nname: 34
n 34(None)[]:
	i: 0&15(t)
	o: 51()

nname: 0&15
n 0&15(self.selected is not None and self.selected.type in ('audio',))[]:
	i: 
	o: 34(t), 47(f)

nname: 0&15
n 0&15(None)[if self.selected is not None and self.selected.type in ('audio',):
	pass
return ''
]:
	i: 
	o: 

self.nodes: {'0&15': <unpyclib.structure.node instance at 0x9e5bdac>}
nname: 59
n 59(None)[return ''
]:
	i: 34(t), 48(), 55()
	o: 

nname: 55
n 55(None)[]:
	i: 0&15(f)
	o: 59()

nname: 48
n 48(None)[]:
	i: 34(f)
	o: 59()

nname: 34
n 34(self.selected['track'])[]:
	i: 0&15(t)
	o: 48(f), 59(t)

nname: 0&15
n 0&15(self.selected is not None and self.selected.type in ('audio',))[]:
	i: 
	o: 34(t), 55(f)

nname: 0&15
n 0&15(None)[if self.selected is not None and self.selected.type in ('audio',):
	if not self.selected['track']:
		pass
return ''
]:
	i: 
	o: 

self.nodes: {'0&15': <unpyclib.structure.node instance at 0x9e5bd4c>}
nname: 52
n 52(None)[return ''
]:
	i: 34(), 48()
	o: 

nname: 48
n 48(None)[]:
	i: 0&15(f)
	o: 52()

nname: 34
n 34(None)[]:
	i: 0&15(t)
	o: 52()

nname: 0&15
n 0&15(self.selected is not None and self.selected.type in ('audio',))[]:
	i: 
	o: 34(t), 48(f)

nname: 0&15
n 0&15(None)[if self.selected is not None and self.selected.type in ('audio',):
	pass
return ''
]:
	i: 
	o: 

self.nodes: {'0&15': <unpyclib.structure.node instance at 0x9e5bf8c>}
nname: 52
n 52(None)[return ''
]:
	i: 34(), 48()
	o: 

nname: 48
n 48(None)[]:
	i: 0&15(f)
	o: 52()

nname: 34
n 34(None)[]:
	i: 0&15(t)
	o: 52()

nname: 0&15
n 0&15(self.selected is not None and self.selected.type in ('audio',))[]:
	i: 
	o: 34(t), 48(f)

nname: 0&15
n 0&15(None)[if self.selected is not None and self.selected.type in ('audio',):
	pass
return ''
]:
	i: 
	o: 

self.nodes: {'0&15': <unpyclib.structure.node instance at 0x9e5bccc>}
nname: 0
n 0(None)[return len(self._history)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e5b94c>}
nname: 0
n 0(None)[return UNIVERSE_NAME_DICT[self.type]
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e5b7ac>}
nname: 0
n 0(None)[return self.get_item_list('markerlist')
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e5b7cc>}
nname: 472
n 472(None)[self._update_marker()
louie_connect(receiver=self.back_to_root, signal='refresh_root', sender='navigator')
return None
]:
	i: 415(), 437()
	o: 

nname: 437
n 437(None)[self.eventhandler = NavigatorEventHandler(self)
self.markerlist = markerlists()[self.universe]
]:
	i: 0(f)
	o: 472()

nname: 415
n 415(None)[self.eventhandler = eventhandler
self.markerlist = None
]:
	i: 0(t)
	o: 472()

nname: 0
n 0(eventhandler)[self._history = HistoryStack()
self._actual_preview = None
self.force_preview = False
self.contextual_windows = []
Menu.__init__(self, name, choices, universe=universe, **kw)
self.tasks.update({'build_preview': Task(self._build_preview), 'hide_preview': Task(self._hide_preview), 'refresh_root': Task(self._refresh_root), 'reload_func': Task(self._reload_func)})
self._getitems_keywords.update(markerlist=(lambda : self.get_item_list('markerlist')), universe_name=(lambda : UNIVERSE_NAME_DICT[self.type]), parent_icon_name=self._get_parent_icon_name, parent_item_name=self._get_parent_item_name, thumbnail=self._get_thumbnail, folder_depth=(lambda : len(self._history)), parental_rating=self._get_parental_rating, title=self._get_title, date=self._get_date, artist=(lambda : .selected is not None and self.selected.type in ('audio',):
	pass
return ''), album=(lambda : .selected is not None and self.selected.type in ('audio',):
	pass
return ''), track=(lambda : .selected is not None and self.selected.type in ('audio',):
	if not self.selected['track']:
		pass
return ''), duration=(lambda : .selected is not None and self.selected.type in ('audio',):
	pass
return ''), size=(lambda : .selected is not None and self.selected.type in ('image',):
	pass
return ''), author=(lambda : .selected is not None:
	pass
return u''), description=self._get_description, link=(lambda : .selected is not None:
	pass
return u''), embedded_media=self._get_embedded_media_icon)
self.set_items([], list_name='markerlist')
]:
	i: 
	o: 415(t), 437(f)

nname: 0
n 0(None)[self._history = HistoryStack()
self._actual_preview = None
self.force_preview = False
self.contextual_windows = []
Menu.__init__(self, name, choices, universe=universe, **kw)
self.tasks.update({'build_preview': Task(self._build_preview), 'hide_preview': Task(self._hide_preview), 'refresh_root': Task(self._refresh_root), 'reload_func': Task(self._reload_func)})
self._getitems_keywords.update(markerlist=(lambda : self.get_item_list('markerlist')), universe_name=(lambda : UNIVERSE_NAME_DICT[self.type]), parent_icon_name=self._get_parent_icon_name, parent_item_name=self._get_parent_item_name, thumbnail=self._get_thumbnail, folder_depth=(lambda : len(self._history)), parental_rating=self._get_parental_rating, title=self._get_title, date=self._get_date, artist=(lambda : .selected is not None and self.selected.type in ('audio',):
	pass
return ''), album=(lambda : .selected is not None and self.selected.type in ('audio',):
	pass
return ''), track=(lambda : .selected is not None and self.selected.type in ('audio',):
	if not self.selected['track']:
		pass
return ''), duration=(lambda : .selected is not None and self.selected.type in ('audio',):
	pass
return ''), size=(lambda : .selected is not None and self.selected.type in ('image',):
	pass
return ''), author=(lambda : .selected is not None:
	pass
return u''), description=self._get_description, link=(lambda : .selected is not None:
	pass
return u''), embedded_media=self._get_embedded_media_icon)
self.set_items([], list_name='markerlist')
if eventhandler:
	self.eventhandler = eventhandler
	self.markerlist = None
else:
	self.eventhandler = NavigatorEventHandler(self)
	self.markerlist = markerlists()[self.universe]
self._update_marker()
louie_connect(receiver=self.back_to_root, signal='refresh_root', sender='navigator')
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e58fec>}
nname: 58
n 58(None)[return u''
]:
	i: 32(JA), 53(), 57()
	o: 

nname: 57
n 57(None)[]:
	i: 0(f)
	o: 58()

nname: 53
n 53(None)[]:
	i: 21(f)
	o: 58()

nname: 32
n 32(None)[return ellipsize(item['description'], 400)
]:
	i: 21(t)
	o: 58(JA)

nname: 21
n 21(item['description'])[]:
	i: 0(t)
	o: 32(t), 53(f)

nname: 0
n 0(item is not None)[item = self.selected
]:
	i: 
	o: 21(t), 57(f)

nname: 0
n 0(None)[item = self.selected
if item is not None:
	if item['description']:
		return ellipsize(item['description'], 400)
return u''
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e53bec>}
nname: 94
n 94(None)[return u''
]:
	i: 86(JA), 90(), 93()
	o: 

nname: 93
n 93(None)[]:
	i: 0(f)
	o: 94()

nname: 90
n 90(None)[]:
	i: 81(JA), 89()
	o: 94()

nname: 89
n 89(None)[]:
	i: 21(f)
	o: 90()

nname: 86
n 86(None)[]:
	i: 73(JA), 85()
	o: 94(JA)

nname: 85
n 85(None)[]:
	i: 38&45(f)
	o: 86()

nname: 81
n 81(None)[]:
	i: 56(f)
	o: 90(JA)

nname: 73
n 73(None)[return 'embedded_media'
]:
	i: 56(t)
	o: 86(JA)

nname: 56
n 56(item['uri'] != '::online::')[]:
	i: 38&45(t)
	o: 73(t), 81(f)

nname: 38&45
n 38&45(item and item['uri'])[]:
	i: 21(t)
	o: 56(t), 85(f)

nname: 21
n 21(item['backend'] == 'net_services')[]:
	i: 0(t)
	o: 38&45(t), 89(f)

nname: 0
n 0(item is not None)[item = self.selected
]:
	i: 
	o: 21(t), 93(f)

nname: 94
n 94(None)[return u''
]:
	i: 73(JA), 38&45(f), 56(f), 21(f), 0(f)
	o: 

nname: 73
n 73(None)[return 'embedded_media'
]:
	i: 56(t)
	o: 94(JA)

nname: 56
n 56(item['uri'] != '::online::')[]:
	i: 38&45(t)
	o: 73(t), 94(f)

nname: 38&45
n 38&45(item and item['uri'])[]:
	i: 21(t)
	o: 56(t), 94(f)

nname: 21
n 21(item['backend'] == 'net_services')[]:
	i: 0(t)
	o: 38&45(t), 94(f)

nname: 0
n 0(item is not None)[item = self.selected
]:
	i: 
	o: 21(t), 94(f)

nname: 0
n 0(None)[item = self.selected
if item is not None:
	if item['backend'] == 'net_services':
		if item and item['uri']:
			if item['uri'] != '::online::':
				return 'embedded_media'
return u''
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e53fac>}
nname: 31
n 31(None)[]:
	i: 18(), 30()
	o: 

nname: 30
n 30(None)[]:
	i: 0(f)
	o: 31()

nname: 18
n 18(None)[return embedded + '.png'
]:
	i: 0(t)
	o: 31()

nname: 0
n 0(embedded)[embedded = self._get_embedded_media()
]:
	i: 
	o: 18(t), 30(f)

nname: 0
n 0(None)[embedded = self._get_embedded_media()
if embedded:
	return embedded + '.png'
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e539ec>}
nname: 82
n 82(None)[return u''
]:
	i: 73(JA), 77(), 81()
	o: 

nname: 81
n 81(None)[]:
	i: 0(f)
	o: 82()

nname: 77
n 77(None)[]:
	i: 21(f)
	o: 82()

nname: 73
n 73(None)[return item['exif_date']
]:
	i: 54(), 65()
	o: 82(JA)

nname: 65
n 65(None)[]:
	i: 37(f)
	o: 73()

nname: 54
n 54(None)[]:
	i: 37(t)
	o: 73()

nname: 37
n 37(item['backend'] == 'net_services')[]:
	i: 21(t)
	o: 54(t), 65(f)

nname: 21
n 21(item.type == 'audio')[]:
	i: 0(t)
	o: 37(t), 77(f)

nname: 0
n 0(item is not None)[item = self.selected
]:
	i: 
	o: 21(t), 81(f)

nname: 82
n 82(None)[return u''
]:
	i: 37(JA), 21(f), 0(f)
	o: 

nname: 37
n 37(None)[if item['backend'] == 'net_services':
	pass
return item['exif_date']
]:
	i: 21(t)
	o: 82(JA)

nname: 21
n 21(item.type == 'audio')[]:
	i: 0(t)
	o: 37(t), 82(f)

nname: 0
n 0(item is not None)[item = self.selected
]:
	i: 
	o: 21(t), 82(f)

nname: 0
n 0(None)[item = self.selected
if item is not None:
	if item.type == 'audio':
		if item['backend'] == 'net_services':
			pass
		return item['exif_date']
return u''
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e53dac>}
nname: 82
n 82(None)[return u''
]:
	i: 73(JA), 77(), 81()
	o: 

nname: 81
n 81(None)[]:
	i: 0(f)
	o: 82()

nname: 77
n 77(None)[]:
	i: 21(f)
	o: 82()

nname: 73
n 73(None)[return item['metadata_title']
]:
	i: 54(), 65()
	o: 82(JA)

nname: 65
n 65(None)[]:
	i: 37(f)
	o: 73()

nname: 54
n 54(None)[]:
	i: 37(t)
	o: 73()

nname: 37
n 37(item['backend'] == 'net_services')[]:
	i: 21(t)
	o: 54(t), 65(f)

nname: 21
n 21(item.type == 'audio')[]:
	i: 0(t)
	o: 37(t), 77(f)

nname: 0
n 0(item is not None)[item = self.selected
]:
	i: 
	o: 21(t), 81(f)

nname: 82
n 82(None)[return u''
]:
	i: 37(JA), 21(f), 0(f)
	o: 

nname: 37
n 37(None)[if item['backend'] == 'net_services':
	pass
return item['metadata_title']
]:
	i: 21(t)
	o: 82(JA)

nname: 21
n 21(item.type == 'audio')[]:
	i: 0(t)
	o: 37(t), 82(f)

nname: 0
n 0(item is not None)[item = self.selected
]:
	i: 
	o: 21(t), 82(f)

nname: 0
n 0(None)[item = self.selected
if item is not None:
	if item.type == 'audio':
		if item['backend'] == 'net_services':
			pass
		return item['metadata_title']
return u''
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e53bcc>}
nname: 76
n 76(None)[]:
	i: 67(), 71()
	o: 

nname: 71
n 71(None)[return ''
]:
	i: 0(f)
	o: 76()

nname: 67
n 67(None)[return seconds_to_mmss_utc(seconds)
]:
	i: 44(), 57()
	o: 76()

nname: 57
n 57(None)[]:
	i: 19(f)
	o: 67()

nname: 44
n 44(None)[]:
	i: 19(t)
	o: 67()

nname: 19
n 19(seconds >= 3600)[seconds = int(duration)
]:
	i: 0(t)
	o: 44(t), 57(f)

nname: 0
n 0(duration)[duration = self.selected['duration']
]:
	i: 
	o: 19(t), 71(f)

nname: 76
n 76(None)[]:
	i: 19(), 71()
	o: 

nname: 71
n 71(None)[return ''
]:
	i: 0(f)
	o: 76()

nname: 19
n 19(None)[seconds = int(duration)
if seconds >= 3600:
	pass
return seconds_to_mmss_utc(seconds)
]:
	i: 0(t)
	o: 76()

nname: 0
n 0(duration)[duration = self.selected['duration']
]:
	i: 
	o: 19(t), 71(f)

nname: 0
n 0(None)[duration = self.selected['duration']
if duration:
	seconds = int(duration)
	if seconds >= 3600:
		pass
	return seconds_to_mmss_utc(seconds)
else:
	return ''
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e53d0c>}
nname: 71
n 71(None)[return ico
]:
	i: 41(JA), 66(), 70()
	o: 

nname: 70
n 70(None)[]:
	i: 0(f)
	o: 71()

nname: 66
n 66(None)[]:
	i: 23(t)
	o: 71()

nname: 41
n 41(None)[ico = 'maturityrating_%s.png' % config.user_config['security']['maturity_rating']
]:
	i: 23(f)
	o: 71(JA)

nname: 23
n 23(config.user_config['security']['parent_mode'])[]:
	i: 0(t)
	o: 41(f), 66(t)

nname: 0
n 0(config.user_config['security']['parental_control'])[ico = None
]:
	i: 
	o: 23(t), 70(f)

nname: 0
n 0(None)[ico = None
if config.user_config['security']['parental_control']:
	if not config.user_config['security']['parent_mode']:
		ico = 'maturityrating_%s.png' % config.user_config['security']['maturity_rating']
return ico
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e53c4c>}
nname: 218
n 218(None)[self.force_preview = False
return None
]:
	i: 205(), 217()
	o: 

nname: 217
n 217(None)[]:
	i: 48&85(f)
	o: 218()

nname: 205
n 205(None)[self._actual_preview = kind
]:
	i: 167(), 204()
	o: 218()

nname: 204
n 204(None)[]:
	i: 155(f)
	o: 205()

nname: 167
n 167(None)[log.debug('show_%s_preview', kind)
louie_send('show_%s_preview' % kind, self)
]:
	i: 155(t)
	o: 205()

nname: 155
n 155(kind is not None)[]:
	i: 111(), 154()
	o: 167(t), 204(f)

nname: 154
n 154(None)[]:
	i: 95(f)
	o: 155()

nname: 111
n 111(None)[log.debug('hide_%s_preview', self._actual_preview)
louie_send('hide_%s_preview' % self._actual_preview, self)
]:
	i: 95(t)
	o: 155()

nname: 95
n 95(self._actual_preview is not None)[]:
	i: 48&85(t)
	o: 111(t), 154(f)

nname: 48&85
n 48&85(kind != self._actual_preview or self.force_preview)[log.debug('actual_preview:%s  new_preview:%s', self._actual_preview, kind)
]:
	i: 23(), 47()
	o: 95(t), 217(f)

nname: 47
n 47(None)[]:
	i: 0(f)
	o: 48&85()

nname: 23
n 23(None)[log.debug('%s not on top of stack. avoid sending preview type', self)
return None
]:
	i: 0(t)
	o: 48&85()

nname: 0
n 0(pygui_globs['menustack'].menus_stack[-1] is not self)[]:
	i: 
	o: 23(t), 47(f)

nname: 218
n 218(None)[self.force_preview = False
return None
]:
	i: 205(), 0(f)
	o: 

nname: 205
n 205(None)[self._actual_preview = kind
]:
	i: 95()
	o: 218()

nname: 95
n 95(None)[if self._actual_preview is not None:
	log.debug('hide_%s_preview', self._actual_preview)
	louie_send('hide_%s_preview' % self._actual_preview, self)
if kind is not None:
	log.debug('show_%s_preview', kind)
	louie_send('show_%s_preview' % kind, self)
]:
	i: 0(t)
	o: 205()

nname: 0
n 0(kind != self._actual_preview or self.force_preview)[if pygui_globs['menustack'].menus_stack[-1] is not self:
	log.debug('%s not on top of stack. avoid sending preview type', self)
	return None
log.debug('actual_preview:%s  new_preview:%s', self._actual_preview, kind)
]:
	i: 
	o: 95(t), 218(f)

nname: 218
n 218(None)[self.force_preview = False
return None
]:
	i: 95(), 0(f)
	o: 

nname: 95
n 95(None)[if self._actual_preview is not None:
	log.debug('hide_%s_preview', self._actual_preview)
	louie_send('hide_%s_preview' % self._actual_preview, self)
if kind is not None:
	log.debug('show_%s_preview', kind)
	louie_send('show_%s_preview' % kind, self)
self._actual_preview = kind
]:
	i: 0(t)
	o: 218()

nname: 0
n 0(kind != self._actual_preview or self.force_preview)[if pygui_globs['menustack'].menus_stack[-1] is not self:
	log.debug('%s not on top of stack. avoid sending preview type', self)
	return None
log.debug('actual_preview:%s  new_preview:%s', self._actual_preview, kind)
]:
	i: 
	o: 95(t), 218(f)

nname: 0
n 0(None)[if pygui_globs['menustack'].menus_stack[-1] is not self:
	log.debug('%s not on top of stack. avoid sending preview type', self)
	return None
log.debug('actual_preview:%s  new_preview:%s', self._actual_preview, kind)
if kind != self._actual_preview or self.force_preview:
	if self._actual_preview is not None:
		log.debug('hide_%s_preview', self._actual_preview)
		louie_send('hide_%s_preview' % self._actual_preview, self)
	if kind is not None:
		log.debug('show_%s_preview', kind)
		louie_send('show_%s_preview' % kind, self)
	self._actual_preview = kind
self.force_preview = False
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e5bd4c>}
nname: 122
n 122(None)[return ''
]:
	i: 15(), 106(JA), 117(), 121()
	o: 

nname: 121
n 121(None)[]:
	i: 37(f)
	o: 122()

nname: 117
n 117(None)[]:
	i: 47&90(f)
	o: 122()

nname: 106
n 106(None)[return parent.name
]:
	i: 47&90(t)
	o: 122(JA)

nname: 47&90
n 47&90(parent not in (RootItem(), TVRootItem(), self.markerlist) and parent.name != TV_FAVORITES_FOLDER)[parent = self.selected.parent
]:
	i: 37(t)
	o: 106(t), 117(f)

nname: 37
n 37(self.selected)[]:
	i: 0(f)
	o: 47&90(t), 121(f)

nname: 15
n 15(None)[return self._history[-1]['selected'].name
]:
	i: 0(t)
	o: 122()

nname: 0
n 0(len(self._history))[]:
	i: 
	o: 15(t), 37(f)

nname: 0
n 0(None)[if len(self._history):
	return self._history[-1]['selected'].name
else:
	if self.selected:
		parent = self.selected.parent
		if parent not in (RootItem(), TVRootItem(), self.markerlist) and parent.name != TV_FAVORITES_FOLDER:
			return parent.name
return ''
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e53b4c>}
nname: 119
n 119(None)[return 'root-%s.png' % self.type
]:
	i: 15(), 99(JA), 114(), 118()
	o: 

nname: 118
n 118(None)[]:
	i: 30(f)
	o: 119()

nname: 114
n 114(None)[]:
	i: 40&83(f)
	o: 119()

nname: 99
n 99(None)[return 'parentfolder-%s.png' % self.type
]:
	i: 40&83(t)
	o: 119(JA)

nname: 40&83
n 40&83(parent not in (RootItem(), TVRootItem(), self.markerlist) and parent.name != TV_FAVORITES_FOLDER)[parent = self.selected.parent
]:
	i: 30(t)
	o: 99(t), 114(f)

nname: 30
n 30(self.selected)[]:
	i: 0(f)
	o: 40&83(t), 118(f)

nname: 15
n 15(None)[return 'parentfolder-%s.png' % self.type
]:
	i: 0(t)
	o: 119()

nname: 0
n 0(len(self._history))[]:
	i: 
	o: 15(t), 30(f)

nname: 0
n 0(None)[if len(self._history):
	return 'parentfolder-%s.png' % self.type
else:
	if self.selected:
		parent = self.selected.parent
		if parent not in (RootItem(), TVRootItem(), self.markerlist) and parent.name != TV_FAVORITES_FOLDER:
			return 'parentfolder-%s.png' % self.type
return 'root-%s.png' % self.type
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e53b6c>}
nname: 0
n 0(None)[Menu.show(self, hide_previous_menu)
self.get_item_list('main_list').advertise()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e5390c>}
nname: 0
n 0(None)[Menu.reset(self, name=name, universe=universe, **kw)
self._history.empty()
self.set_items([], list_name='markerlist')
self.markerlist = markerlists()[self.universe]
self.set_items(self.root_getter(), list_name='main_list')
self.build_preview()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e53a4c>}
nname: 42
n 42(None)[Menu.stop(self)
]:
	i: 18(), 41()
	o: 

nname: 41
n 41(None)[]:
	i: 0(f)
	o: 42()

nname: 18
n 18(None)[self.selected.unwatch(self._selection_changed)
]:
	i: 0(t)
	o: 42()

nname: 0
n 0(hasattr(self.selected, 'unwatch'))[]:
	i: 
	o: 18(t), 41(f)

nname: 0
n 0(None)[if hasattr(self.selected, 'unwatch'):
	self.selected.unwatch(self._selection_changed)
Menu.stop(self)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e5386c>}
nname: 0
n 0(None)[]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e53ecc>}
nname: 50
n 50(None)[return None
]:
	i: 20(), 35(), 48(AE)
	o: 

nname: 48
n 48(None)[]:
	i: 25(f)
	o: 50(AE)

nname: 35
n 35(None)[#, e
return None
]:
	i: 25(t)
	o: 50()

nname: 25
n 25(<dummy_ex3> EXC_MATCH Exception)[]:
	i: 0(except)
	o: 35(t), 48(f)

nname: 20
n 20(None)[return self.selected['thumbnail']
]:
	i: 3(t), 16()
	o: 50()

nname: 16
n 16(None)[]:
	i: 3(f)
	o: 20()

nname: 3
n 3(self.selected['thumbnail'])[]:
	i: 0(try)
	o: 16(f), 20(t)

nname: 0
n 0(None)[]:
	i: 
	o: 3(try), 25(except)

nname: 50
n 50(None)[return None
]:
	i: 20(), 25()
	o: 

nname: 25
n 25(None)[except Exception, e:
	return None
]:
	i: 0()
	o: 50()

nname: 20
n 20(None)[return self.selected['thumbnail']
]:
	i: 0(t)
	o: 50()

nname: 0
n 0(None)[try:
	if not self.selected['thumbnail']:
		pass
]:
	i: 
	o: 20(), 25()

self.nodes: {0: <unpyclib.structure.node instance at 0x9e5388c>, 50: <unpyclib.structure.node instance at 0x9e5398c>, 20: <unpyclib.structure.node instance at 0x9e53e4c>, 25: <unpyclib.structure.node instance at 0x9e53fcc>}
nname: 0
n 0(None)[louie_send('parent_item_name', sender=self, value=self['parent_item_name'])
louie_send('parent_icon_name', sender=self, value=self['parent_icon_name'])
louie_send('folder_depth', sender=self, value=len(self._history))
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e539ec>}
nname: 0
n 0(None)[self._history = HistoryStack(history=navigator._history)
last_context = self._history[-1]
self.set_items(last_context['items'], 'main_list', last_context['position'])
self.build_preview()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e53eac>}
nname: 0
n 0(None)[Menu.reload_func(self)
self.tasks['reload_func'].start(0.5)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e538ac>}
nname: 155
n 155(None)[]:
	i: 27(), 75()
	o: 

nname: 75
n 75(None)[log.debug('refreshing history')
history_dict = self._history[0]
history_dict['items'] = self.root_getter()
history_dict['position'] = min(history_dict['position'], len(history_dict['items']) - 1)
]:
	i: 0(t)
	o: 155()

nname: 27
n 27(None)[log.debug('refreshing items')
self.set_items(self.root_getter(), list_name='main_list', position=old_sel)
]:
	i: 0(f)
	o: 155()

nname: 0
n 0(self._history)[old_sel = max(0, self.selected_pos)
]:
	i: 
	o: 27(f), 75(t)

nname: 0
n 0(None)[old_sel = max(0, self.selected_pos)
if not self._history:
	log.debug('refreshing items')
	self.set_items(self.root_getter(), list_name='main_list', position=old_sel)
else:
	log.debug('refreshing history')
	history_dict = self._history[0]
	history_dict['items'] = self.root_getter()
	history_dict['position'] = min(history_dict['position'], len(history_dict['items']) - 1)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e5388c>}
nname: 0
n 0(None)[self.tasks['refresh_root'].start(1.0)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e53cec>}
nname: 291
n 291(None)[return False
]:
	i: 192(), 290()
	o: 

nname: 290
n 290(None)[]:
	i: 180(f)
	o: 291()

nname: 192
n 192(None)[louie_send('event_left', sender=self)
sleep(config.HMI_BASE['navigator_listing_delay'])
self.set_items(last_context['items'], 'main_list', last_context['position'])
self.tasks['reload_func'].start(1)
self._path_changed()
return True
]:
	i: 180(t)
	o: 291()

nname: 180
n 180(last_context is not None)[]:
	i: 60(), 171(), 178(AE)
	o: 192(t), 290(f)

nname: 178
n 178(None)[]:
	i: 64(f)
	o: 180(AE)

nname: 171
n 171(None)[return None
]:
	i: 100(), 152(), 170()
	o: 180()

nname: 170
n 170(None)[]:
	i: 142(t)
	o: 171()

nname: 152
n 152(None)[pygui_globs['menustack'].back_to_home()
]:
	i: 142(f)
	o: 171()

nname: 142
n 142(config.block_navigator)[]:
	i: 74&87(f)
	o: 152(f), 170(t)

nname: 100
n 100(None)[self.go_to_item(self.selected.parent, 'event_left')
louie_send('on_root', sender=self)
]:
	i: 74&87(t)
	o: 171()

nname: 74&87
n 74&87(self.selected and self.selected.parent)[]:
	i: 64(t)
	o: 100(t), 142(f)

nname: 64
n 64(<dummy_ex3> EXC_MATCH IndexError)[]:
	i: 0(except)
	o: 74&87(t), 178(f)

nname: 60
n 60(None)[]:
	i: 36(), 59()
	o: 180()

nname: 59
n 59(None)[]:
	i: 3(f)
	o: 60()

nname: 36
n 36(None)[self.selected.unwatch(self._selection_changed)
]:
	i: 3(t)
	o: 60()

nname: 3
n 3(hasattr(self.selected, 'unwatch'))[last_context = self._history.pop()
]:
	i: 0(try)
	o: 36(t), 59(f)

nname: 0
n 0(None)[]:
	i: 
	o: 3(try), 64(except)

nname: 180
n 180(None)[if last_context is not None:
	louie_send('event_left', sender=self)
	sleep(config.HMI_BASE['navigator_listing_delay'])
	self.set_items(last_context['items'], 'main_list', last_context['position'])
	self.tasks['reload_func'].start(1)
	self._path_changed()
	return True
return False
]:
	i: 3(), 171(), 178(AE)
	o: 

nname: 171
n 171(None)[return None
]:
	i: 74&87(), 64(f)
	o: 180()

nname: 74&87
n 74&87(None)[if self.selected and self.selected.parent:
	self.go_to_item(self.selected.parent, 'event_left')
	louie_send('on_root', sender=self)
else:
	if not config.block_navigator:
		pygui_globs['menustack'].back_to_home()
]:
	i: 64(t)
	o: 171()

nname: 64
n 64(<dummy_ex3> EXC_MATCH IndexError)[]:
	i: 0(except)
	o: 74&87(t), 171(f)

nname: 3
n 3(None)[last_context = self._history.pop()
if hasattr(self.selected, 'unwatch'):
	self.selected.unwatch(self._selection_changed)
]:
	i: 0(try)
	o: 180()

nname: 0
n 0(None)[]:
	i: 
	o: 3(try), 64(except)

nname: 180
n 180(None)[if last_context is not None:
	louie_send('event_left', sender=self)
	sleep(config.HMI_BASE['navigator_listing_delay'])
	self.set_items(last_context['items'], 'main_list', last_context['position'])
	self.tasks['reload_func'].start(1)
	self._path_changed()
	return True
return False
]:
	i: 3(), 64(), 178(AE)
	o: 

nname: 64
n 64(None)[except IndexError:
	if self.selected and self.selected.parent:
		self.go_to_item(self.selected.parent, 'event_left')
		louie_send('on_root', sender=self)
	else:
		if not config.block_navigator:
			pygui_globs['menustack'].back_to_home()
return None
]:
	i: 0(except)
	o: 180()

nname: 3
n 3(None)[last_context = self._history.pop()
if hasattr(self.selected, 'unwatch'):
	self.selected.unwatch(self._selection_changed)
]:
	i: 0(try)
	o: 180()

nname: 0
n 0(None)[]:
	i: 
	o: 3(try), 64(except)

nname: 64
n 64(None)[except IndexError:
	if self.selected and self.selected.parent:
		self.go_to_item(self.selected.parent, 'event_left')
		louie_send('on_root', sender=self)
	else:
		if not config.block_navigator:
			pygui_globs['menustack'].back_to_home()
return None
if last_context is not None:
	louie_send('event_left', sender=self)
	sleep(config.HMI_BASE['navigator_listing_delay'])
	self.set_items(last_context['items'], 'main_list', last_context['position'])
	self.tasks['reload_func'].start(1)
	self._path_changed()
	return True
return False
]:
	i: 0()
	o: 

nname: 0
n 0(None)[try:
	last_context = self._history.pop()
	if hasattr(self.selected, 'unwatch'):
		self.selected.unwatch(self._selection_changed)
]:
	i: 
	o: 64()

nname: 0
n 0(None)[try:
	last_context = self._history.pop()
	if hasattr(self.selected, 'unwatch'):
		self.selected.unwatch(self._selection_changed)
except IndexError:
	if self.selected and self.selected.parent:
		self.go_to_item(self.selected.parent, 'event_left')
		louie_send('on_root', sender=self)
	else:
		if not config.block_navigator:
			pygui_globs['menustack'].back_to_home()
return None
if last_context is not None:
	louie_send('event_left', sender=self)
	sleep(config.HMI_BASE['navigator_listing_delay'])
	self.set_items(last_context['items'], 'main_list', last_context['position'])
	self.tasks['reload_func'].start(1)
	self._path_changed()
	return True
return False
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e5b08c>}
nname: 161
n 161(None)[]:
	i: 31(), 133(), 160()
	o: 

nname: 160
n 160(None)[]:
	i: 99&109(f)
	o: 161()

nname: 133
n 133(None)[log.debug('IS PARENT')
self.reload_func()
]:
	i: 99&109(t)
	o: 161()

nname: 99&109
n 99&109(self._history and item == self._history[-1]['selected'])[]:
	i: 0(f)
	o: 133(t), 160(f)

nname: 31
n 31(None)[log.debug('IS SELECTED')
louie_send('main_list', sender=self, action='reset', value=self['main_list'], position=self.selected_pos)
self.build_preview()
]:
	i: 0(t)
	o: 161()

nname: 0
n 0(self.selected == item)[log.debug('UPDATE %s', item)
]:
	i: 
	o: 31(t), 99&109(f)

nname: 0
n 0(None)[log.debug('UPDATE %s', item)
if self.selected == item:
	log.debug('IS SELECTED')
	louie_send('main_list', sender=self, action='reset', value=self['main_list'], position=self.selected_pos)
	self.build_preview()
else:
	if self._history and item == self._history[-1]['selected']:
		log.debug('IS PARENT')
		self.reload_func()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e5bb0c>}
nname: 60
n 60(None)[self.go_to_item(None, event='event_left')
return None
]:
	i: 0(AL), 59()
	o: 

nname: 59
n 59(None)[]:
	i: 3(AF), 56()
	o: 60()

nname: 56
n 56(None)[]:
	i: 33(AE)
	o: 59()

nname: 33
n 33(None)[log.debug('Unable to close %s', win)
continue
]:
	i: 13(except), 19()
	o: 56(AE)

nname: 19
n 19(None)[win.hide()
continue
]:
	i: 13(try)
	o: 33()

nname: 13
n 13(None)[for win in self.contextual_windows:
]:
	i: 3(for)
	o: 19(try), 33(except)

nname: 3
n 3(None)[]:
	i: 0(loop)
	o: 13(for), 59(AF)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 60(AL)

nname: 60
n 60(None)[self.go_to_item(None, event='event_left')
return None
]:
	i: 0(AL), 3(AF), 33(AE)
	o: 

nname: 33
n 33(None)[except:
	log.debug('Unable to close %s', win)
	continue
]:
	i: 13()
	o: 60(AE)

nname: 13
n 13(None)[for win in self.contextual_windows:
try:
	win.hide()
	continue
]:
	i: 3(for)
	o: 33()

nname: 3
n 3(None)[]:
	i: 0(loop)
	o: 13(for), 60(AF)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 60(AL)

nname: 60
n 60(None)[self.go_to_item(None, event='event_left')
return None
]:
	i: 0(AL), 3(AF), 13(AE)
	o: 

nname: 13
n 13(None)[for win in self.contextual_windows:
try:
	win.hide()
	continue
except:
	log.debug('Unable to close %s', win)
	continue
]:
	i: 3(for)
	o: 60(AE)

nname: 3
n 3(None)[]:
	i: 0(loop)
	o: 13(for), 60(AF)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 60(AL)

nname: 60
n 60(None)[self.go_to_item(None, event='event_left')
return None
]:
	i: 13(AE)
	o: 

nname: 13
n 13(None)[for win in self.contextual_windows:
	try:
		win.hide()
		continue
	except:
		log.debug('Unable to close %s', win)
		continue
]:
	i: 0(for)
	o: 60(AE)

nname: 0
n 0(None)[]:
	i: 
	o: 13(for)

nname: 60
n 60(None)[self.go_to_item(None, event='event_left')
return None
]:
	i: 0(AE)
	o: 

nname: 0
n 0(None)[for win in self.contextual_windows:
	try:
		win.hide()
		continue
	except:
		log.debug('Unable to close %s', win)
		continue
]:
	i: 
	o: 60(AE)

self.nodes: {0: <unpyclib.structure.node instance at 0x9e53a4c>, 60: <unpyclib.structure.node instance at 0x9e53c0c>}
nname: 77
n 77(None)[main_list = self.get_item_list('main_list')
louie_send('main_list', sender=self, action='mark', value=main_list, position=main_list.selected_pos)
self.build_preview()
]:
	i: 21(), 57()
	o: 

nname: 57
n 57(None)[self.set_items([], list_name='markerlist')
]:
	i: 0(f)
	o: 77()

nname: 21
n 21(None)[markerlist._refresh()
self.set_items([markerlist], list_name='markerlist')
]:
	i: 0(t)
	o: 77()

nname: 0
n 0(bool(markerlist))[markerlist = self.markerlist
]:
	i: 
	o: 21(t), 57(f)

nname: 0
n 0(None)[markerlist = self.markerlist
if bool(markerlist):
	markerlist._refresh()
	self.set_items([markerlist], list_name='markerlist')
else:
	self.set_items([], list_name='markerlist')
main_list = self.get_item_list('main_list')
louie_send('main_list', sender=self, action='mark', value=main_list, position=main_list.selected_pos)
self.build_preview()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e53e2c>}
nname: 0
n 0(None)[Menu.on_foreground(self)
self.force_preview = True
self.build_preview()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e5376c>}
nname: 0
n 0(None)[Menu.on_background(self)
self.stop()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e539cc>}
nname: 84
n 84(None)[return None
]:
	i: 15(), 83()
	o: 

nname: 83
n 83(None)[]:
	i: 0(f)
	o: 84()

nname: 15
n 15(None)[louie_send('hide_%s_preview' % self._actual_preview, sender=self)
louie_send('preview_list_no_more_items_before', sender=self)
louie_send('preview_list_no_more_items_after', sender=self)
self._actual_preview = None
]:
	i: 0(t)
	o: 84()

nname: 0
n 0(self._actual_preview is not None)[]:
	i: 
	o: 15(t), 83(f)

nname: 0
n 0(None)[if self._actual_preview is not None:
	louie_send('hide_%s_preview' % self._actual_preview, sender=self)
	louie_send('preview_list_no_more_items_before', sender=self)
	louie_send('preview_list_no_more_items_after', sender=self)
	self._actual_preview = None
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e53b0c>}
nname: 0
n 0(None)[self.tasks['hide_preview'].start(config.HMI_BASE['preview_delay'] + 0.10000000000000001)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e53e0c>}
nname: 634
n 634(None)[log.debug('%s: preview_type is: %s', self, pt)
self._set_preview_type(pt)
return False
]:
	i: 603(), 607(), 633(AE)
	o: 

nname: 607
n 607(None)[PRINT_EXCEPTION()
log.error('Thumbnail error!')
]:
	i: 490(except)
	o: 634()

nname: 603
n 603(None)[]:
	i: 540(), 566(), 592(), 602()
	o: 634()

nname: 602
n 602(None)[]:
	i: 576(f)
	o: 603()

nname: 592
n 592(None)[pt = 'snd'
]:
	i: 576(t)
	o: 603()

nname: 576
n 576(isinstance(sel, AudioItem))[]:
	i: 550(f)
	o: 592(t), 602(f)

nname: 566
n 566(None)[pt = 'mov'
]:
	i: 550(t)
	o: 603()

nname: 550
n 550(isinstance(sel, VideoItem))[]:
	i: 499(f)
	o: 566(t), 576(f)

nname: 540
n 540(None)[pt = 'img'
]:
	i: 499(t)
	o: 603()

nname: 499
n 499(isinstance(sel, ImageItem))[louie_send('thumbnail', sender=self, value=self['thumbnail'])
]:
	i: 490(try)
	o: 540(t), 550(f)

nname: 490
n 490(None)[pt = None
]:
	i: 411(), 463(), 488(AE)
	o: 499(try), 607(except)

nname: 488
n 488(None)[]:
	i: 453(f)
	o: 490(AE)

nname: 463
n 463(None)[#, e
log.error('Item Name error: %s', e)
]:
	i: 453(t)
	o: 490()

nname: 453
n 453(<dummy_ex3> EXC_MATCH Exception)[]:
	i: 304(except)
	o: 463(t), 488(f)

nname: 411
n 411(None)[louie_send('item_name', sender=self, action='update', value=omnicode(self['item_name']))
]:
	i: 304(try)
	o: 490()

nname: 304
n 304(None)[louie_send('author', sender=self, value=self['author'])
louie_send('description', sender=self, value=self['description'])
louie_send('link', sender=self, value=self['link'])
louie_send('embedded_media', sender=self, value=self['embedded_media'])
]:
	i: 91(), 277(), 303(AE)
	o: 411(try), 453(except)

nname: 277
n 277(None)[PRINT_EXCEPTION()
log.error('Id3Tags error')
]:
	i: 88(except)
	o: 304()

nname: 91
n 91(None)[louie_send('title', sender=self, value=self['title'])
louie_send('artist', sender=self, value=self['artist'])
louie_send('album', sender=self, value=self['album'])
louie_send('track', sender=self, value=self['track'])
louie_send('duration', sender=self, value=self['duration'])
louie_send('size', sender=self, value=self['size'])
louie_send('date', sender=self, value=self['date'])
]:
	i: 88(try)
	o: 304()

nname: 88
n 88(None)[]:
	i: 49(), 79(), 86(AE)
	o: 91(try), 277(except)

nname: 86
n 86(None)[]:
	i: 69(f)
	o: 88(AE)

nname: 79
n 79(None)[]:
	i: 69(t)
	o: 88()

nname: 69
n 69(<dummy_ex3> EXC_MATCH AttributeError)[]:
	i: 37(except)
	o: 79(t), 86(f)

nname: 49
n 49(None)[sel.watch(self._selection_changed)
]:
	i: 37(try)
	o: 88()

nname: 37
n 37(None)[sel = self.selected
]:
	i: 22(), 36()
	o: 49(try), 69(except)

nname: 36
n 36(None)[]:
	i: 0(f)
	o: 37()

nname: 22
n 22(None)[hide_preview_task.stop()
]:
	i: 0(t)
	o: 37()

nname: 0
n 0(hide_preview_task.running)[hide_preview_task = self.tasks['hide_preview']
]:
	i: 
	o: 22(t), 36(f)

nname: 634
n 634(None)[log.debug('%s: preview_type is: %s', self, pt)
self._set_preview_type(pt)
return False
]:
	i: 607(), 490()
	o: 

nname: 607
n 607(None)[except:
	PRINT_EXCEPTION()
	log.error('Thumbnail error!')
]:
	i: 490()
	o: 634()

nname: 634
n 634(None)[log.debug('%s: preview_type is: %s', self, pt)
self._set_preview_type(pt)
return False
]:
	i: 607(), 490()
	o: 

nname: 490
n 490(None)[pt = None
try:
	louie_send('thumbnail', sender=self, value=self['thumbnail'])
	if isinstance(sel, ImageItem):
		pt = 'img'
	else:
		if isinstance(sel, VideoItem):
			pt = 'mov'
		else:
			if isinstance(sel, AudioItem):
				pt = 'snd'
]:
	i: 411()
	o: 634(), 607()

nname: 411
n 411(None)[try:
	louie_send('item_name', sender=self, action='update', value=omnicode(self['item_name']))
except Exception, e:
	log.error('Item Name error: %s', e)
]:
	i: 277(try)
	o: 490()

nname: 277
n 277(None)[except:
	PRINT_EXCEPTION()
	log.error('Id3Tags error')
louie_send('author', sender=self, value=self['author'])
louie_send('description', sender=self, value=self['description'])
louie_send('link', sender=self, value=self['link'])
louie_send('embedded_media', sender=self, value=self['embedded_media'])
]:
	i: 88()
	o: 411(try)

nname: 88
n 88(None)[try:
	louie_send('title', sender=self, value=self['title'])
	louie_send('artist', sender=self, value=self['artist'])
	louie_send('album', sender=self, value=self['album'])
	louie_send('track', sender=self, value=self['track'])
	louie_send('duration', sender=self, value=self['duration'])
	louie_send('size', sender=self, value=self['size'])
	louie_send('date', sender=self, value=self['date'])
]:
	i: 49()
	o: 277()

nname: 49
n 49(None)[try:
	sel.watch(self._selection_changed)
except AttributeError:
	pass
]:
	i: 0(try)
	o: 88()

nname: 0
n 0(None)[hide_preview_task = self.tasks['hide_preview']
if hide_preview_task.running:
	hide_preview_task.stop()
sel = self.selected
]:
	i: 
	o: 49(try)

nname: 634
n 634(None)[log.debug('%s: preview_type is: %s', self, pt)
self._set_preview_type(pt)
return False
]:
	i: 607(), 411()
	o: 

nname: 607
n 607(None)[except:
	PRINT_EXCEPTION()
	log.error('Thumbnail error!')
]:
	i: 411()
	o: 634()

nname: 634
n 634(None)[log.debug('%s: preview_type is: %s', self, pt)
self._set_preview_type(pt)
return False
]:
	i: 607(), 411()
	o: 

nname: 411
n 411(None)[try:
	louie_send('item_name', sender=self, action='update', value=omnicode(self['item_name']))
except Exception, e:
	log.error('Item Name error: %s', e)
pt = None
try:
	louie_send('thumbnail', sender=self, value=self['thumbnail'])
	if isinstance(sel, ImageItem):
		pt = 'img'
	else:
		if isinstance(sel, VideoItem):
			pt = 'mov'
		else:
			if isinstance(sel, AudioItem):
				pt = 'snd'
]:
	i: 88(try)
	o: 634(), 607()

nname: 88
n 88(None)[try:
	louie_send('title', sender=self, value=self['title'])
	louie_send('artist', sender=self, value=self['artist'])
	louie_send('album', sender=self, value=self['album'])
	louie_send('track', sender=self, value=self['track'])
	louie_send('duration', sender=self, value=self['duration'])
	louie_send('size', sender=self, value=self['size'])
	louie_send('date', sender=self, value=self['date'])
except:
	PRINT_EXCEPTION()
	log.error('Id3Tags error')
louie_send('author', sender=self, value=self['author'])
louie_send('description', sender=self, value=self['description'])
louie_send('link', sender=self, value=self['link'])
louie_send('embedded_media', sender=self, value=self['embedded_media'])
]:
	i: 0()
	o: 411(try)

nname: 0
n 0(None)[hide_preview_task = self.tasks['hide_preview']
if hide_preview_task.running:
	hide_preview_task.stop()
sel = self.selected
try:
	sel.watch(self._selection_changed)
except AttributeError:
	pass
]:
	i: 
	o: 88()

nname: 634
n 634(None)[log.debug('%s: preview_type is: %s', self, pt)
self._set_preview_type(pt)
return False
]:
	i: 607(), 411()
	o: 

nname: 607
n 607(None)[except:
	PRINT_EXCEPTION()
	log.error('Thumbnail error!')
]:
	i: 411()
	o: 634()

nname: 634
n 634(None)[log.debug('%s: preview_type is: %s', self, pt)
self._set_preview_type(pt)
return False
]:
	i: 607(), 411()
	o: 

nname: 411
n 411(None)[try:
	louie_send('item_name', sender=self, action='update', value=omnicode(self['item_name']))
except Exception, e:
	log.error('Item Name error: %s', e)
pt = None
try:
	louie_send('thumbnail', sender=self, value=self['thumbnail'])
	if isinstance(sel, ImageItem):
		pt = 'img'
	else:
		if isinstance(sel, VideoItem):
			pt = 'mov'
		else:
			if isinstance(sel, AudioItem):
				pt = 'snd'
]:
	i: 0(try)
	o: 634(), 607()

nname: 0
n 0(None)[hide_preview_task = self.tasks['hide_preview']
if hide_preview_task.running:
	hide_preview_task.stop()
sel = self.selected
try:
	sel.watch(self._selection_changed)
except AttributeError:
	pass
try:
	louie_send('title', sender=self, value=self['title'])
	louie_send('artist', sender=self, value=self['artist'])
	louie_send('album', sender=self, value=self['album'])
	louie_send('track', sender=self, value=self['track'])
	louie_send('duration', sender=self, value=self['duration'])
	louie_send('size', sender=self, value=self['size'])
	louie_send('date', sender=self, value=self['date'])
except:
	PRINT_EXCEPTION()
	log.error('Id3Tags error')
louie_send('author', sender=self, value=self['author'])
louie_send('description', sender=self, value=self['description'])
louie_send('link', sender=self, value=self['link'])
louie_send('embedded_media', sender=self, value=self['embedded_media'])
]:
	i: 
	o: 411(try)

nname: 634
n 634(None)[log.debug('%s: preview_type is: %s', self, pt)
self._set_preview_type(pt)
return False
]:
	i: 607(), 0()
	o: 

nname: 607
n 607(None)[except:
	PRINT_EXCEPTION()
	log.error('Thumbnail error!')
]:
	i: 0()
	o: 634()

nname: 634
n 634(None)[log.debug('%s: preview_type is: %s', self, pt)
self._set_preview_type(pt)
return False
]:
	i: 607(), 0()
	o: 

nname: 0
n 0(None)[hide_preview_task = self.tasks['hide_preview']
if hide_preview_task.running:
	hide_preview_task.stop()
sel = self.selected
try:
	sel.watch(self._selection_changed)
except AttributeError:
	pass
try:
	louie_send('title', sender=self, value=self['title'])
	louie_send('artist', sender=self, value=self['artist'])
	louie_send('album', sender=self, value=self['album'])
	louie_send('track', sender=self, value=self['track'])
	louie_send('duration', sender=self, value=self['duration'])
	louie_send('size', sender=self, value=self['size'])
	louie_send('date', sender=self, value=self['date'])
except:
	PRINT_EXCEPTION()
	log.error('Id3Tags error')
louie_send('author', sender=self, value=self['author'])
louie_send('description', sender=self, value=self['description'])
louie_send('link', sender=self, value=self['link'])
louie_send('embedded_media', sender=self, value=self['embedded_media'])
try:
	louie_send('item_name', sender=self, action='update', value=omnicode(self['item_name']))
except Exception, e:
	log.error('Item Name error: %s', e)
pt = None
try:
	louie_send('thumbnail', sender=self, value=self['thumbnail'])
	if isinstance(sel, ImageItem):
		pt = 'img'
	else:
		if isinstance(sel, VideoItem):
			pt = 'mov'
		else:
			if isinstance(sel, AudioItem):
				pt = 'snd'
]:
	i: 
	o: 634(), 607()

self.nodes: {0: <unpyclib.structure.node instance at 0x9e4d96c>, 607: <unpyclib.structure.node instance at 0x9efbacc>, 634: <unpyclib.structure.node instance at 0x9efbbcc>}
nname: 0
n 0(None)[self.tasks['build_preview'].start(config.HMI_BASE['preview_delay'])
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e53f8c>}
nname: 6
n 6(None)[__doc__ = " Defines 'browser' menus, to access filesystem contents "
toggleable = True
def __init__(self, name, universe, choices=None, eventhandler=None, **kw):
	self._history = HistoryStack()
	self._actual_preview = None
	self.force_preview = False
	self.contextual_windows = []
	Menu.__init__(self, name, choices, universe=universe, **kw)
	self.tasks.update({'build_preview': Task(self._build_preview), 'hide_preview': Task(self._hide_preview), 'refresh_root': Task(self._refresh_root), 'reload_func': Task(self._reload_func)})
	self._getitems_keywords.update(markerlist=(lambda : self.get_item_list('markerlist')), universe_name=(lambda : UNIVERSE_NAME_DICT[self.type]), parent_icon_name=self._get_parent_icon_name, parent_item_name=self._get_parent_item_name, thumbnail=self._get_thumbnail, folder_depth=(lambda : len(self._history)), parental_rating=self._get_parental_rating, title=self._get_title, date=self._get_date, artist=(lambda : .selected is not None and self.selected.type in ('audio',):
		pass
	return ''), album=(lambda : .selected is not None and self.selected.type in ('audio',):
		pass
	return ''), track=(lambda : .selected is not None and self.selected.type in ('audio',):
		if not self.selected['track']:
			pass
	return ''), duration=(lambda : .selected is not None and self.selected.type in ('audio',):
		pass
	return ''), size=(lambda : .selected is not None and self.selected.type in ('image',):
		pass
	return ''), author=(lambda : .selected is not None:
		pass
	return u''), description=self._get_description, link=(lambda : .selected is not None:
		pass
	return u''), embedded_media=self._get_embedded_media_icon)
	self.set_items([], list_name='markerlist')
	if eventhandler:
		self.eventhandler = eventhandler
		self.markerlist = None
	else:
		self.eventhandler = NavigatorEventHandler(self)
		self.markerlist = markerlists()[self.universe]
	self._update_marker()
	louie_connect(receiver=self.back_to_root, signal='refresh_root', sender='navigator')
	return None

def _get_description(self):
	item = self.selected
	if item is not None:
		if item['description']:
			return ellipsize(item['description'], 400)
	return u''

def _get_embedded_media(self):
	item = self.selected
	if item is not None:
		if item['backend'] == 'net_services':
			if item and item['uri']:
				if item['uri'] != '::online::':
					return 'embedded_media'
	return u''

def _get_embedded_media_icon(self):
	embedded = self._get_embedded_media()
	if embedded:
		return embedded + '.png'

def _get_date(self):
	item = self.selected
	if item is not None:
		if item.type == 'audio':
			if item['backend'] == 'net_services':
				pass
			return item['exif_date']
	return u''

def _get_title(self):
	item = self.selected
	if item is not None:
		if item.type == 'audio':
			if item['backend'] == 'net_services':
				pass
			return item['metadata_title']
	return u''

def _get_audio_duration(self):
	duration = self.selected['duration']
	if duration:
		seconds = int(duration)
		if seconds >= 3600:
			pass
		return seconds_to_mmss_utc(seconds)
	else:
		return ''

def _get_parental_rating(self):
	ico = None
	if config.user_config['security']['parental_control']:
		if not config.user_config['security']['parent_mode']:
			ico = 'maturityrating_%s.png' % config.user_config['security']['maturity_rating']
	return ico

def _set_preview_type(self, kind):
	if pygui_globs['menustack'].menus_stack[-1] is not self:
		log.debug('%s not on top of stack. avoid sending preview type', self)
		return None
	log.debug('actual_preview:%s  new_preview:%s', self._actual_preview, kind)
	if kind != self._actual_preview or self.force_preview:
		if self._actual_preview is not None:
			log.debug('hide_%s_preview', self._actual_preview)
			louie_send('hide_%s_preview' % self._actual_preview, self)
		if kind is not None:
			log.debug('show_%s_preview', kind)
			louie_send('show_%s_preview' % kind, self)
		self._actual_preview = kind
	self.force_preview = False
	return None

def _get_parent_item_name(self):
	if len(self._history):
		return self._history[-1]['selected'].name
	else:
		if self.selected:
			parent = self.selected.parent
			if parent not in (RootItem(), TVRootItem(), self.markerlist) and parent.name != TV_FAVORITES_FOLDER:
				return parent.name
	return ''

def _get_parent_icon_name(self):
	if len(self._history):
		return 'parentfolder-%s.png' % self.type
	else:
		if self.selected:
			parent = self.selected.parent
			if parent not in (RootItem(), TVRootItem(), self.markerlist) and parent.name != TV_FAVORITES_FOLDER:
				return 'parentfolder-%s.png' % self.type
	return 'root-%s.png' % self.type

def show(self, hide_previous_menu=True):
	Menu.show(self, hide_previous_menu)
	self.get_item_list('main_list').advertise()

def reset(self, name, universe, **kw):
	Menu.reset(self, name=name, universe=universe, **kw)
	self._history.empty()
	self.set_items([], list_name='markerlist')
	self.markerlist = markerlists()[self.universe]
	self.set_items(self.root_getter(), list_name='main_list')
	self.build_preview()

def stop(self):
	if hasattr(self.selected, 'unwatch'):
		self.selected.unwatch(self._selection_changed)
	Menu.stop(self)

def clear(self):
	pass

def _get_thumbnail(self):
	try:
		if not self.selected['thumbnail']:
			pass

def _path_changed(self):
	louie_send('parent_item_name', sender=self, value=self['parent_item_name'])
	louie_send('parent_icon_name', sender=self, value=self['parent_icon_name'])
	louie_send('folder_depth', sender=self, value=len(self._history))

def backup_navigator_history(self, navigator):
	self._history = HistoryStack(history=navigator._history)
	last_context = self._history[-1]
	self.set_items(last_context['items'], 'main_list', last_context['position'])
	self.build_preview()

execute_selected = back_root_if_error()
_reload_func = back_root_if_error()
def reload_func(self):
	Menu.reload_func(self)
	self.tasks['reload_func'].start(0.5)

def _refresh_root(self):
	old_sel = max(0, self.selected_pos)
	if not self._history:
		log.debug('refreshing items')
		self.set_items(self.root_getter(), list_name='main_list', position=old_sel)
	else:
		log.debug('refreshing history')
		history_dict = self._history[0]
		history_dict['items'] = self.root_getter()
		history_dict['position'] = min(history_dict['position'], len(history_dict['items']) - 1)

def refresh_root(self):
	self.tasks['refresh_root'].start(1.0)

browse_selected = back_root_if_error()
def browse_previous(self):
	try:
		last_context = self._history.pop()
		if hasattr(self.selected, 'unwatch'):
			self.selected.unwatch(self._selection_changed)
	except IndexError:
		if self.selected and self.selected.parent:
			self.go_to_item(self.selected.parent, 'event_left')
			louie_send('on_root', sender=self)
		else:
			if not config.block_navigator:
				pygui_globs['menustack'].back_to_home()
	return None
	if last_context is not None:
		louie_send('event_left', sender=self)
		sleep(config.HMI_BASE['navigator_listing_delay'])
		self.set_items(last_context['items'], 'main_list', last_context['position'])
		self.tasks['reload_func'].start(1)
		self._path_changed()
		return True
	return False

go_to_item = back_root_if_error()
def _selection_changed(self, item):
	log.debug('UPDATE %s', item)
	if self.selected == item:
		log.debug('IS SELECTED')
		louie_send('main_list', sender=self, action='reset', value=self['main_list'], position=self.selected_pos)
		self.build_preview()
	else:
		if self._history and item == self._history[-1]['selected']:
			log.debug('IS PARENT')
			self.reload_func()

select = back_root_if_error()
def back_to_root(self, *args, **args):
	for win in self.contextual_windows:
		try:
			win.hide()
			continue
		except:
			log.debug('Unable to close %s', win)
			continue

def _update_marker(self):
	markerlist = self.markerlist
	if bool(markerlist):
		markerlist._refresh()
		self.set_items([markerlist], list_name='markerlist')
	else:
		self.set_items([], list_name='markerlist')
	main_list = self.get_item_list('main_list')
	louie_send('main_list', sender=self, action='mark', value=main_list, position=main_list.selected_pos)
	self.build_preview()

def on_foreground(self):
	Menu.on_foreground(self)
	self.force_preview = True
	self.build_preview()

def on_background(self):
	Menu.on_background(self)
	self.stop()

def _hide_preview(self):
	if self._actual_preview is not None:
		louie_send('hide_%s_preview' % self._actual_preview, sender=self)
		louie_send('preview_list_no_more_items_before', sender=self)
		louie_send('preview_list_no_more_items_after', sender=self)
		self._actual_preview = None
	return None

def hide_preview(self):
	self.tasks['hide_preview'].start(config.HMI_BASE['preview_delay'] + 0.10000000000000001)

def _build_preview(self):
	hide_preview_task = self.tasks['hide_preview']
	if hide_preview_task.running:
		hide_preview_task.stop()
	sel = self.selected
	try:
		sel.watch(self._selection_changed)
	except AttributeError:
		pass
	try:
		louie_send('title', sender=self, value=self['title'])
		louie_send('artist', sender=self, value=self['artist'])
		louie_send('album', sender=self, value=self['album'])
		louie_send('track', sender=self, value=self['track'])
		louie_send('duration', sender=self, value=self['duration'])
		louie_send('size', sender=self, value=self['size'])
		louie_send('date', sender=self, value=self['date'])
	except:
		PRINT_EXCEPTION()
		log.error('Id3Tags error')
	louie_send('author', sender=self, value=self['author'])
	louie_send('description', sender=self, value=self['description'])
	louie_send('link', sender=self, value=self['link'])
	louie_send('embedded_media', sender=self, value=self['embedded_media'])
	try:
		louie_send('item_name', sender=self, action='update', value=omnicode(self['item_name']))
	except Exception, e:
		log.error('Item Name error: %s', e)
	pt = None
	try:
		louie_send('thumbnail', sender=self, value=self['thumbnail'])
		if isinstance(sel, ImageItem):
			pt = 'img'
		else:
			if isinstance(sel, VideoItem):
				pt = 'mov'
			else:
				if isinstance(sel, AudioItem):
					pt = 'snd'

def build_preview(self):
	self.tasks['build_preview'].start(config.HMI_BASE['preview_delay'])

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0x9e5068c>}
nname: 81
n 81(None)[]:
	i: 56(), 80()
	o: 

nname: 80
n 80(None)[]:
	i: 0(f)
	o: 81()

nname: 56
n 56(None)[self.tasks['_fill_nav'].start(-1)
]:
	i: 0(t)
	o: 81()

nname: 0
n 0(fill_root)[GenericNavigator.__init__(self, name, universe, choices, eventhandler, **kw)
self.tasks['_fill_nav'] = Task(self._fill_nav)
]:
	i: 
	o: 56(t), 80(f)

nname: 0
n 0(None)[GenericNavigator.__init__(self, name, universe, choices, eventhandler, **kw)
self.tasks['_fill_nav'] = Task(self._fill_nav)
if fill_root:
	self.tasks['_fill_nav'].start(-1)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e53e8c>}
nname: 0
n 0(None)[self.set_items(self.root_getter())
self.build_preview()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e53ecc>}
nname: 68
n 68(None)[return root_items
]:
	i: 3(), 47(), 66(AE)
	o: 

nname: 66
n 66(None)[]:
	i: 37(f)
	o: 68(AE)

nname: 47
n 47(None)[root_items = [EmptyItem()]
]:
	i: 37(t)
	o: 68()

nname: 37
n 37(<dummy_ex3> EXC_MATCH BrowseError)[]:
	i: 0(except)
	o: 47(t), 66(f)

nname: 3
n 3(None)[root_items = list(RootItem().browse(self.type, self))
]:
	i: 0(try)
	o: 68()

nname: 0
n 0(None)[]:
	i: 
	o: 3(try), 37(except)

nname: 37
n 37(None)[except BrowseError:
	root_items = [EmptyItem()]
return root_items
]:
	i: 0()
	o: 

nname: 0
n 0(None)[try:
	root_items = list(RootItem().browse(self.type, self))
]:
	i: 
	o: 37()

nname: 0
n 0(None)[try:
	root_items = list(RootItem().browse(self.type, self))
except BrowseError:
	root_items = [EmptyItem()]
return root_items
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e5398c>}
nname: 0
n 0(None)[GenericNavigator.reset(self, *args, **kw)
self._update_marker()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e537ec>}
nname: 0
n 0(None)[]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e5366c>}
nname: 122
n 122(None)[return ret
]:
	i: 95(JA), 109(JA), 118(), 121()
	o: 

nname: 121
n 121(None)[]:
	i: 0&45(f)
	o: 122()

nname: 118
n 118(None)[]:
	i: 116(AE)
	o: 122()

nname: 116
n 116(None)[]:
	i: 99(f)
	o: 118(AE)

nname: 109
n 109(None)[]:
	i: 99(t)
	o: 122(JA)

nname: 99
n 99(<dummy_ex3> EXC_MATCH AttributeError)[]:
	i: 61(except)
	o: 109(t), 116(f)

nname: 95
n 95(None)[]:
	i: 74(), 94()
	o: 122(JA)

nname: 94
n 94(None)[]:
	i: 65(f)
	o: 95()

nname: 74
n 74(None)[old_sel.unwatch(self._selection_changed)
]:
	i: 65(t)
	o: 95()

nname: 65
n 65(old_sel.watched)[]:
	i: 61(try)
	o: 74(t), 94(f)

nname: 61
n 61(None)[]:
	i: 0&45(t)
	o: 65(try), 99(except)

nname: 0&45
n 0&45(ret and old_sel != self.selected)[old_sel = self.selected
ret = GenericNavigator.select(self, item, list_name=list_name, force_pos=force_pos)
]:
	i: 
	o: 61(t), 121(f)

nname: 122
n 122(None)[return ret
]:
	i: 65(JA), 99(f), 99(t), 116(AE), 0&45(f)
	o: 

nname: 99
n 99(<dummy_ex3> EXC_MATCH AttributeError)[]:
	i: 61(except)
	o: 122(f)

nname: 65
n 65(None)[if old_sel.watched:
	old_sel.unwatch(self._selection_changed)
]:
	i: 61(try)
	o: 122(JA)

nname: 61
n 61(None)[]:
	i: 0&45(t)
	o: 65(try), 99(except)

structureSingleExcept Exception 'NoneType' object has no attribute 'toNode'
nname: 0&45
n 0&45(ret and old_sel != self.selected)[old_sel = self.selected
ret = GenericNavigator.select(self, item, list_name=list_name, force_pos=force_pos)
]:
	i: 
	o: 61(t), 122(f)

nname: 122
n 122(None)[return ret
]:
	i: 65(JA), 99(t), 116(AE), 0&45(f), 61(except)
	o: 

nname: 65
n 65(None)[if old_sel.watched:
	old_sel.unwatch(self._selection_changed)
]:
	i: 61(try)
	o: 122(JA)

nname: 61
n 61(None)[]:
	i: 0&45(t)
	o: 65(try), 122(except)

nname: 0&45
n 0&45(ret and old_sel != self.selected)[old_sel = self.selected
ret = GenericNavigator.select(self, item, list_name=list_name, force_pos=force_pos)
]:
	i: 
	o: 61(t), 122(f)

nname: 122
n 122(None)[except:
	return ret
]:
	i: 65(JA), 99(t), 116(AE), 0&45(f), 61(except)
	o: 

nname: 65
n 65(None)[if old_sel.watched:
	old_sel.unwatch(self._selection_changed)
]:
	i: 61(try)
	o: 122(JA)

nname: 61
n 61(None)[]:
	i: 0&45(t)
	o: 65(try), 122(except)

nname: 0&45
n 0&45(ret and old_sel != self.selected)[old_sel = self.selected
ret = GenericNavigator.select(self, item, list_name=list_name, force_pos=force_pos)
]:
	i: 
	o: 61(t), 122(f)

self.nodes: {65: <unpyclib.structure.node instance at 0x9e5b6ac>, '0&45': <unpyclib.structure.node instance at 0x9e5bf0c>, 116: <unpyclib.structure.node instance at 0x9e5b10c>, 122: <unpyclib.structure.node instance at 0x9e5b3cc>, 61: <unpyclib.structure.node instance at 0x9e53aac>}
nname: 123
n 123(None)[]:
	i: 68(JA), 109(), 122()
	o: 

nname: 122
n 122(None)[]:
	i: 0(f)
	o: 123()

nname: 109
n 109(None)[info_menu.show()
]:
	i: 29(), 107(AE)
	o: 123()

nname: 107
n 107(None)[]:
	i: 58(f)
	o: 109(AE)

nname: 68
n 68(None)[self._error_spawner()
log.warn('No InfowWindow defined for type %s', self.selected.type)
]:
	i: 58(t)
	o: 123(JA)

nname: 58
n 58(<dummy_ex3> EXC_MATCH KeyError)[]:
	i: 9(except)
	o: 68(t), 107(f)

nname: 29
n 29(None)[info_menu = item_info_menu_dict[self.selected.type](self.selected)
]:
	i: 9(try)
	o: 109()

nname: 9
n 9(None)[from pygui.menu.menu.info import item_info_menu_dict
]:
	i: 0(t)
	o: 29(try), 58(except)

nname: 0
n 0(self.selected)[]:
	i: 
	o: 9(t), 122(f)

nname: 123
n 123(None)[]:
	i: 68(JA), 109(), 58(f), 0(f)
	o: 

nname: 68
n 68(None)[self._error_spawner()
log.warn('No InfowWindow defined for type %s', self.selected.type)
]:
	i: 58(t)
	o: 123(JA)

nname: 58
n 58(<dummy_ex3> EXC_MATCH KeyError)[]:
	i: 9(except)
	o: 68(t), 123(f)

nname: 109
n 109(None)[info_menu.show()
]:
	i: 29(), 107(AE)
	o: 123()

nname: 29
n 29(None)[info_menu = item_info_menu_dict[self.selected.type](self.selected)
]:
	i: 9(try)
	o: 109()

nname: 9
n 9(None)[from pygui.menu.menu.info import item_info_menu_dict
]:
	i: 0(t)
	o: 29(try), 58(except)

nname: 0
n 0(self.selected)[]:
	i: 
	o: 9(t), 123(f)

nname: 123
n 123(None)[]:
	i: 58(), 0(f)
	o: 

nname: 58
n 58(None)[except KeyError:
	self._error_spawner()
	log.warn('No InfowWindow defined for type %s', self.selected.type)
else:
	info_menu.show()
]:
	i: 9()
	o: 123()

nname: 9
n 9(None)[from pygui.menu.menu.info import item_info_menu_dict
try:
	info_menu = item_info_menu_dict[self.selected.type](self.selected)
]:
	i: 0(t)
	o: 58()

nname: 0
n 0(self.selected)[]:
	i: 
	o: 9(t), 123(f)

nname: 123
n 123(None)[]:
	i: 9(), 0(f)
	o: 

nname: 9
n 9(None)[from pygui.menu.menu.info import item_info_menu_dict
try:
	info_menu = item_info_menu_dict[self.selected.type](self.selected)
except KeyError:
	self._error_spawner()
	log.warn('No InfowWindow defined for type %s', self.selected.type)
else:
	info_menu.show()
]:
	i: 0(t)
	o: 123()

nname: 0
n 0(self.selected)[]:
	i: 
	o: 9(t), 123(f)

nname: 0
n 0(None)[if self.selected:
	from pygui.menu.menu.info import item_info_menu_dict
	try:
		info_menu = item_info_menu_dict[self.selected.type](self.selected)
	except KeyError:
		self._error_spawner()
		log.warn('No InfowWindow defined for type %s', self.selected.type)
	else:
		info_menu.show()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e5b56c>}
nname: 168
n 168(None)[return None
]:
	i: 92(JA), 106(), 167()
	o: 

nname: 167
n 167(None)[]:
	i: 0&37(f)
	o: 168()

nname: 106
n 106(None)[self.select(0, force_pos=True)
louie_send('main_list', action='update', sender=self, value=self['main_list'], position=0)
]:
	i: 56&76(f)
	o: 168()

nname: 92
n 92(None)[stack.back_to_home()
]:
	i: 56&76(t)
	o: 168(JA)

nname: 56&76
n 56&76(self['main_list'].selected_pos == 0 and 'universe_switcher' not in config.plugins)[]:
	i: 0&37(t)
	o: 92(t), 106(f)

nname: 0&37
n 0&37(ret is None and stack.get_player() is None)[ret = GenericNavigator.browse_previous(self)
stack = pygui_globs['menustack']
]:
	i: 
	o: 56&76(t), 167(f)

nname: 0&37
n 0&37(None)[ret = GenericNavigator.browse_previous(self)
stack = pygui_globs['menustack']
if ret is None and stack.get_player() is None:
	if self['main_list'].selected_pos == 0 and 'universe_switcher' not in config.plugins:
		stack.back_to_home()
	else:
		self.select(0, force_pos=True)
		louie_send('main_list', action='update', sender=self, value=self['main_list'], position=0)
return None
]:
	i: 
	o: 

self.nodes: {'0&37': <unpyclib.structure.node instance at 0x9e5bb8c>}
nname: 6
n 6(None)[__doc__ = " Defines 'browser' menus, to access filesystem contents "
name = 'navigator'
def __init__(self, name, universe, choices=None, eventhandler=None, fill_root=True, **kw):
	GenericNavigator.__init__(self, name, universe, choices, eventhandler, **kw)
	self.tasks['_fill_nav'] = Task(self._fill_nav)
	if fill_root:
		self.tasks['_fill_nav'].start(-1)

def _fill_nav(self):
	self.set_items(self.root_getter())
	self.build_preview()

def root_getter(self):
	try:
		root_items = list(RootItem().browse(self.type, self))
	except BrowseError:
		root_items = [EmptyItem()]
	return root_items

def reset(self, *args, **args):
	GenericNavigator.reset(self, *args, **kw)
	self._update_marker()

def clear(self):
	pass

def select(self, item, list_name=None, force_pos=False):
	old_sel = self.selected
	ret = GenericNavigator.select(self, item, list_name=list_name, force_pos=force_pos)

execute_selected = back_root_if_error()
def action_info(self):
	if self.selected:
		from pygui.menu.menu.info import item_info_menu_dict
		try:
			info_menu = item_info_menu_dict[self.selected.type](self.selected)
		except KeyError:
			self._error_spawner()
			log.warn('No InfowWindow defined for type %s', self.selected.type)
		else:
			info_menu.show()

def browse_previous(self):
	ret = GenericNavigator.browse_previous(self)
	stack = pygui_globs['menustack']
	if ret is None and stack.get_player() is None:
		if self['main_list'].selected_pos == 0 and 'universe_switcher' not in config.plugins:
			stack.back_to_home()
		else:
			self.select(0, force_pos=True)
			louie_send('main_list', action='update', sender=self, value=self['main_list'], position=0)
	return None

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0x9e535ac>}
nname: 0
n 0(None)[return self.get_item_list('origin_list')
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e5320c>}
nname: 95
n 95(None)[self.set_items([marker], list_name='markerlist')
self.markerlist = marker
def self._getitems_keywords['origin_list']():
	return self.get_item_list('origin_list')

self.selected = None
self.select(0)
return None
]:
	i: 43(), 75()
	o: 

nname: 75
n 75(None)[self.set_items([], list_name='origin_list')
]:
	i: 0(f)
	o: 95()

nname: 43
n 43(None)[self.set_items([copy(origin)], list_name='origin_list')
]:
	i: 0(t)
	o: 95()

nname: 0
n 0(origin)[GenericNavigator.__init__(self, name, universe, choices, eventhandler=MarkerListEventHandler(self), **kw)
]:
	i: 
	o: 43(t), 75(f)

nname: 0
n 0(None)[GenericNavigator.__init__(self, name, universe, choices, eventhandler=MarkerListEventHandler(self), **kw)
if origin:
	self.set_items([copy(origin)], list_name='origin_list')
else:
	self.set_items([], list_name='origin_list')
self.set_items([marker], list_name='markerlist')
self.markerlist = marker
def self._getitems_keywords['origin_list']():
	return self.get_item_list('origin_list')

self.selected = None
self.select(0)
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e5b82c>}
nname: 40
n 40(None)[GenericNavigator.stop(self)
]:
	i: 3(), 26(), 39(AE)
	o: 

nname: 26
n 26(None)[PRINT_EXCEPTION()
]:
	i: 0(except)
	o: 40()

nname: 3
n 3(None)[pygui_globs['menustack'].get_navigator().force_preview = True
]:
	i: 0(try)
	o: 40()

nname: 0
n 0(None)[]:
	i: 
	o: 3(try), 26(except)

nname: 26
n 26(None)[except:
	PRINT_EXCEPTION()
GenericNavigator.stop(self)
]:
	i: 0()
	o: 

nname: 0
n 0(None)[try:
	pygui_globs['menustack'].get_navigator().force_preview = True
]:
	i: 
	o: 26()

nname: 0
n 0(None)[try:
	pygui_globs['menustack'].get_navigator().force_preview = True
except:
	PRINT_EXCEPTION()
GenericNavigator.stop(self)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e5b04c>}
nname: 0
n 0(None)[sel = self.selected
self.markerlist.del_item(sel)
self.delete_item(sel)
self.build_preview()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e5bc0c>}
nname: 0
n 0(None)[]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e5b4cc>}
nname: 0
n 0(None)[from pygui.menu.menu.info import MarkerListInfoMenu
info_menu = MarkerListInfoMenu(self.markerlist)
info_menu.show()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e5b48c>}
nname: 6
n 6(None)[name = 'MarkerList'
def __init__(self, name, universe, choices, origin, marker, **kw):
	GenericNavigator.__init__(self, name, universe, choices, eventhandler=MarkerListEventHandler(self), **kw)
	if origin:
		self.set_items([copy(origin)], list_name='origin_list')
	else:
		self.set_items([], list_name='origin_list')
	self.set_items([marker], list_name='markerlist')
	self.markerlist = marker
	def self._getitems_keywords['origin_list']():
		return self.get_item_list('origin_list')

	self.selected = None
	self.select(0)
	return None

def stop(self):
	try:
		pygui_globs['menustack'].get_navigator().force_preview = True
	except:
		PRINT_EXCEPTION()
	GenericNavigator.stop(self)

def unmark_selected(self):
	sel = self.selected
	self.markerlist.del_item(sel)
	self.delete_item(sel)
	self.build_preview()

def refresh_root(self):
	pass

def action_info(self):
	from pygui.menu.menu.info import MarkerListInfoMenu
	info_menu = MarkerListInfoMenu(self.markerlist)
	info_menu.show()

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0x9e4bcec>}
nname: 55
n 55(None)[return None
]:
	i: 29(), 54()
	o: 

nname: 54
n 54(None)[]:
	i: 0(f)
	o: 55()

nname: 29
n 29(None)[self.item_lists_dict[list_name] = ItemGrid(self, items, list_name, self.row_length)
]:
	i: 12(t), 25()
	o: 55()

nname: 25
n 25(None)[]:
	i: 12(f)
	o: 29()

nname: 12
n 12(items)[]:
	i: 0(t)
	o: 25(f), 29(t)

nname: 0
n 0(list_name is not None)[]:
	i: 
	o: 12(t), 54(f)

nname: 55
n 55(None)[return None
]:
	i: 12(), 0(f)
	o: 

nname: 12
n 12(None)[if not items:
	pass
self.item_lists_dict[list_name] = ItemGrid(self, items, list_name, self.row_length)
]:
	i: 0(t)
	o: 55()

nname: 0
n 0(list_name is not None)[]:
	i: 
	o: 12(t), 55(f)

nname: 0
n 0(None)[if list_name is not None:
	if not items:
		pass
	self.item_lists_dict[list_name] = ItemGrid(self, items, list_name, self.row_length)
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e5b7cc>}
nname: 19
n 19(None)[return self.get_item_list(list_name).select_horizontal(item, force_pos)
]:
	i: 0(t), 12()
	o: 

nname: 12
n 12(None)[]:
	i: 0(f)
	o: 19()

nname: 0
n 0(list_name)[]:
	i: 
	o: 12(f), 19(t)

nname: 0
n 0(None)[if not list_name:
	pass
return self.get_item_list(list_name).select_horizontal(item, force_pos)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e5b22c>}
nname: 19
n 19(None)[return self.get_item_list(list_name).select_vertical(item, force_pos)
]:
	i: 0(t), 12()
	o: 

nname: 12
n 12(None)[]:
	i: 0(f)
	o: 19()

nname: 0
n 0(list_name)[]:
	i: 
	o: 12(f), 19(t)

nname: 0
n 0(None)[if not list_name:
	pass
return self.get_item_list(list_name).select_vertical(item, force_pos)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e5b0cc>}
nname: 6
n 6(None)[__doc__ = 'Navigator that uses ItemGrids instead of ItemLists.\n\n    Perfect for thumbnails and the like.\n    Grids have their row lengths set by the row_length class attribute.\n\n    TODO Maybe allow one row length per grid, with a {name: length} dict?\n    '
row_length = 5
def add_item_list(self, list_name, items=None):
	if list_name is not None:
		if not items:
			pass
		self.item_lists_dict[list_name] = ItemGrid(self, items, list_name, self.row_length)
	return None

def select_horizontal(self, item, list_name=None, force_pos=False):
	if not list_name:
		pass
	return self.get_item_list(list_name).select_horizontal(item, force_pos)

def select_vertical(self, item, list_name=None, force_pos=False):
	if not list_name:
		pass
	return self.get_item_list(list_name).select_vertical(item, force_pos)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0x9e4bf6c>}
nname: 26
n 26(None)[return u''
]:
	i: 9(), 22()
	o: 

nname: 22
n 22(None)[]:
	i: 0(f)
	o: 26()

nname: 9
n 9(None)[]:
	i: 0(t)
	o: 26()

nname: 0
n 0(self.folder)[]:
	i: 
	o: 9(t), 22(f)

nname: 0
n 0(None)[if self.folder:
	pass
return u''
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e537ac>}
nname: 111
n 111(None)[def self._getitems_keywords['parent_item_name']():
	if self.folder:
		pass
	return u''

]:
	i: 72(), 110()
	o: 

nname: 110
n 110(None)[]:
	i: 0&62(f)
	o: 111()

nname: 72
n 72(None)[self.folder.menu = self
self.set_items(self.folder.browse())
]:
	i: 0&62(t)
	o: 111()

nname: 0&62
n 0&62(not choices and self.folder)[GridNavigator.__init__(self, name, universe, choices=choices, eventhandler=ThumbnailNavigatorEventHandler(self), type=type, **kw)
self.folder = folder
]:
	i: 
	o: 72(t), 110(f)

nname: 0&62
n 0&62(None)[GridNavigator.__init__(self, name, universe, choices=choices, eventhandler=ThumbnailNavigatorEventHandler(self), type=type, **kw)
self.folder = folder
if not choices and self.folder:
	self.folder.menu = self
	self.set_items(self.folder.browse())
def self._getitems_keywords['parent_item_name']():
	if self.folder:
		pass
	return u''

]:
	i: 
	o: 

self.nodes: {'0&62': <unpyclib.structure.node instance at 0x9e5b94c>}
nname: 0
n 0(None)[return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e5bd8c>}
nname: 40
n 40(None)[GridNavigator.stop(self)
metadata_collector_clear()
]:
	i: 3(), 26(), 39(AE)
	o: 

nname: 26
n 26(None)[PRINT_EXCEPTION()
]:
	i: 0(except)
	o: 40()

nname: 3
n 3(None)[pygui_globs['menustack'].get_navigator().force_preview = True
]:
	i: 0(try)
	o: 40()

nname: 0
n 0(None)[]:
	i: 
	o: 3(try), 26(except)

nname: 26
n 26(None)[except:
	PRINT_EXCEPTION()
GridNavigator.stop(self)
metadata_collector_clear()
]:
	i: 0()
	o: 

nname: 0
n 0(None)[try:
	pygui_globs['menustack'].get_navigator().force_preview = True
]:
	i: 
	o: 26()

nname: 0
n 0(None)[try:
	pygui_globs['menustack'].get_navigator().force_preview = True
except:
	PRINT_EXCEPTION()
GridNavigator.stop(self)
metadata_collector_clear()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e5b34c>}
nname: 0
n 0(None)[louie_send('main_list', sender=self, action='reset', value=self['main_list'])
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e5b5cc>}
nname: 0
n 0(None)[pos = self['main_list'].index(item)
louie_send('main_list', sender=self, action='reset', value=self['main_list'], position=pos)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e5b72c>}
nname: 6
n 6(None)[__doc__ = 'Thumbnail browser.'
toggleable = False
groupeable = True
row_length = config.HMI_PHOTO['thumbnail_row_length']
def __init__(self, name, universe, choices=None, eventhandler=None, folder=None, type=None, **kw):
	GridNavigator.__init__(self, name, universe, choices=choices, eventhandler=ThumbnailNavigatorEventHandler(self), type=type, **kw)
	self.folder = folder
	if not choices and self.folder:
		self.folder.menu = self
		self.set_items(self.folder.browse())
	def self._getitems_keywords['parent_item_name']():
		if self.folder:
			pass
		return u''


def build_preview(self, *args, **args):
	return None

def stop(self):
	try:
		pygui_globs['menustack'].get_navigator().force_preview = True
	except:
		PRINT_EXCEPTION()
	GridNavigator.stop(self)
	metadata_collector_clear()

execute_selected = back_root_if_error()
def _refresh_main(self):
	louie_send('main_list', sender=self, action='reset', value=self['main_list'])

def _thumbnail_updated(self, item):
	pos = self['main_list'].index(item)
	louie_send('main_list', sender=self, action='reset', value=self['main_list'], position=pos)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0x9e5b9cc>}
nname: 0
n 0(None)[from __future__ import absolute_import
__all__ = ['MarkerNavigator', 'ThumbnailNavigator', 'Navigator', 'GenericNavigator', 'EmptyItem']
from copy import copy
from time import sleep
from wymedia.wmplus import BrowseError, metadata_collector_clear
from peewee.debug import GET_LOGGER, PRINT_EXCEPTION
from peewee.formatters import seconds_to_hhmmss_utc, seconds_to_mmss_utc, ellipsize
from peewee.messages import send as louie_send
from peewee.messages import connect as louie_connect
from peewee.misc_utils import MetaSingleton
from peewee.notifier import Task
from pygui import config
from pygui.window import LoadingWindow
from pygui.eventmanager.menus import MarkerListEventHandler, NavigatorEventHandler, ThumbnailNavigatorEventHandler
from pygui.facilities.l10n import omnicode
from pygui.item.core import Item
from pygui.item.containers import ItemGrid
from pygui.item.info import get_field
from pygui.item.mediaitem import RootItem, TVRootItem, DVDItem, IsoDVDItem, VideoItem, ImageItem, AudioItem
from pygui.item.mediaitem import DirItem, Playlist
from pygui.item.mediaitem.net import NetFeedItem
from pygui.item.mediaitem.audiovideo import TVRecordItem
from pygui.item.mediaitem.core import TV_FAVORITES_FOLDER
from pygui.item.mediaitem.net import NetItem
from pygui.markerlist import markerlists
from pygui.menu import UNIVERSE_NAME_DICT
from pygui.menu.menu.core import Menu
from pygui.shared import pygui_globs
from pygui.window import Button, ConfirmWindow
from pygui.window import LoadingWindow
log = GET_LOGGER(__name__)
def back_root_if_error(fn):
	def wrap(self, *args, **args):
		ret = None
		try:
			ret = fn(self, *args, **kw)
		except BrowseError:
			self.back_to_root()
		return ret

	wrap.__name__ = fn.__name__
	return wrap

class EmptyItem(Item):
	__doc__ = ' A simple item to put in empty places to signal it '
	__metaclass__ = MetaSingleton
	def __init__(self):
		Item.__init__(self, _('No content'), type_='empty', display_type='empty')

	name = property((lambda self: _('No content')))


class NotSoEmptyItem(Item):
	__doc__ = ' A simple item to put in empty places to signal it '
	__metaclass__ = MetaSingleton
	def __init__(self):
		Item.__init__(self, _('No content for this universe'), type_='empty', display_type='empty')

	name = property((lambda self: _('No content for this universe')))


class HistoryStack(list):
	__doc__ = ' stack-like class with modification notification handler '
	def __init__(self, history=None, on_modify=None):
		list.__init__(self)
		if history is not None:
			self[:] = history
			if on_modify:
				on_modify()
		if not on_modify:
			pass
		self._modification_handler = on_modify
		return None

	def pop(self, *args, **args):
		ret = list.pop(self, *args, **kw)
		self._modification_handler()
		return ret

	def append(self, *args, **args):
		ret = list.append(self, *args, **kw)
		self._modification_handler()
		return ret

	def empty(self):
		self[:] = list()



class GenericNavigator(Menu):
	__doc__ = " Defines 'browser' menus, to access filesystem contents "
	toggleable = True
	def __init__(self, name, universe, choices=None, eventhandler=None, **kw):
		self._history = HistoryStack()
		self._actual_preview = None
		self.force_preview = False
		self.contextual_windows = []
		Menu.__init__(self, name, choices, universe=universe, **kw)
		self.tasks.update({'build_preview': Task(self._build_preview), 'hide_preview': Task(self._hide_preview), 'refresh_root': Task(self._refresh_root), 'reload_func': Task(self._reload_func)})
		self._getitems_keywords.update(markerlist=(lambda : self.get_item_list('markerlist')), universe_name=(lambda : UNIVERSE_NAME_DICT[self.type]), parent_icon_name=self._get_parent_icon_name, parent_item_name=self._get_parent_item_name, thumbnail=self._get_thumbnail, folder_depth=(lambda : len(self._history)), parental_rating=self._get_parental_rating, title=self._get_title, date=self._get_date, artist=(lambda : .selected is not None and self.selected.type in ('audio',):
			pass
		return ''), album=(lambda : .selected is not None and self.selected.type in ('audio',):
			pass
		return ''), track=(lambda : .selected is not None and self.selected.type in ('audio',):
			if not self.selected['track']:
				pass
		return ''), duration=(lambda : .selected is not None and self.selected.type in ('audio',):
			pass
		return ''), size=(lambda : .selected is not None and self.selected.type in ('image',):
			pass
		return ''), author=(lambda : .selected is not None:
			pass
		return u''), description=self._get_description, link=(lambda : .selected is not None:
			pass
		return u''), embedded_media=self._get_embedded_media_icon)
		self.set_items([], list_name='markerlist')
		if eventhandler:
			self.eventhandler = eventhandler
			self.markerlist = None
		else:
			self.eventhandler = NavigatorEventHandler(self)
			self.markerlist = markerlists()[self.universe]
		self._update_marker()
		louie_connect(receiver=self.back_to_root, signal='refresh_root', sender='navigator')
		return None

	def _get_description(self):
		item = self.selected
		if item is not None:
			if item['description']:
				return ellipsize(item['description'], 400)
		return u''

	def _get_embedded_media(self):
		item = self.selected
		if item is not None:
			if item['backend'] == 'net_services':
				if item and item['uri']:
					if item['uri'] != '::online::':
						return 'embedded_media'
		return u''

	def _get_embedded_media_icon(self):
		embedded = self._get_embedded_media()
		if embedded:
			return embedded + '.png'

	def _get_date(self):
		item = self.selected
		if item is not None:
			if item.type == 'audio':
				if item['backend'] == 'net_services':
					pass
				return item['exif_date']
		return u''

	def _get_title(self):
		item = self.selected
		if item is not None:
			if item.type == 'audio':
				if item['backend'] == 'net_services':
					pass
				return item['metadata_title']
		return u''

	def _get_audio_duration(self):
		duration = self.selected['duration']
		if duration:
			seconds = int(duration)
			if seconds >= 3600:
				pass
			return seconds_to_mmss_utc(seconds)
		else:
			return ''

	def _get_parental_rating(self):
		ico = None
		if config.user_config['security']['parental_control']:
			if not config.user_config['security']['parent_mode']:
				ico = 'maturityrating_%s.png' % config.user_config['security']['maturity_rating']
		return ico

	def _set_preview_type(self, kind):
		if pygui_globs['menustack'].menus_stack[-1] is not self:
			log.debug('%s not on top of stack. avoid sending preview type', self)
			return None
		log.debug('actual_preview:%s  new_preview:%s', self._actual_preview, kind)
		if kind != self._actual_preview or self.force_preview:
			if self._actual_preview is not None:
				log.debug('hide_%s_preview', self._actual_preview)
				louie_send('hide_%s_preview' % self._actual_preview, self)
			if kind is not None:
				log.debug('show_%s_preview', kind)
				louie_send('show_%s_preview' % kind, self)
			self._actual_preview = kind
		self.force_preview = False
		return None

	def _get_parent_item_name(self):
		if len(self._history):
			return self._history[-1]['selected'].name
		else:
			if self.selected:
				parent = self.selected.parent
				if parent not in (RootItem(), TVRootItem(), self.markerlist) and parent.name != TV_FAVORITES_FOLDER:
					return parent.name
		return ''

	def _get_parent_icon_name(self):
		if len(self._history):
			return 'parentfolder-%s.png' % self.type
		else:
			if self.selected:
				parent = self.selected.parent
				if parent not in (RootItem(), TVRootItem(), self.markerlist) and parent.name != TV_FAVORITES_FOLDER:
					return 'parentfolder-%s.png' % self.type
		return 'root-%s.png' % self.type

	def show(self, hide_previous_menu=True):
		Menu.show(self, hide_previous_menu)
		self.get_item_list('main_list').advertise()

	def reset(self, name, universe, **kw):
		Menu.reset(self, name=name, universe=universe, **kw)
		self._history.empty()
		self.set_items([], list_name='markerlist')
		self.markerlist = markerlists()[self.universe]
		self.set_items(self.root_getter(), list_name='main_list')
		self.build_preview()

	def stop(self):
		if hasattr(self.selected, 'unwatch'):
			self.selected.unwatch(self._selection_changed)
		Menu.stop(self)

	def clear(self):
		pass

	def _get_thumbnail(self):
		try:
			if not self.selected['thumbnail']:
				pass

	def _path_changed(self):
		louie_send('parent_item_name', sender=self, value=self['parent_item_name'])
		louie_send('parent_icon_name', sender=self, value=self['parent_icon_name'])
		louie_send('folder_depth', sender=self, value=len(self._history))

	def backup_navigator_history(self, navigator):
		self._history = HistoryStack(history=navigator._history)
		last_context = self._history[-1]
		self.set_items(last_context['items'], 'main_list', last_context['position'])
		self.build_preview()

	execute_selected = back_root_if_error()
	_reload_func = back_root_if_error()
	def reload_func(self):
		Menu.reload_func(self)
		self.tasks['reload_func'].start(0.5)

	def _refresh_root(self):
		old_sel = max(0, self.selected_pos)
		if not self._history:
			log.debug('refreshing items')
			self.set_items(self.root_getter(), list_name='main_list', position=old_sel)
		else:
			log.debug('refreshing history')
			history_dict = self._history[0]
			history_dict['items'] = self.root_getter()
			history_dict['position'] = min(history_dict['position'], len(history_dict['items']) - 1)

	def refresh_root(self):
		self.tasks['refresh_root'].start(1.0)

	browse_selected = back_root_if_error()
	def browse_previous(self):
		try:
			last_context = self._history.pop()
			if hasattr(self.selected, 'unwatch'):
				self.selected.unwatch(self._selection_changed)
		except IndexError:
			if self.selected and self.selected.parent:
				self.go_to_item(self.selected.parent, 'event_left')
				louie_send('on_root', sender=self)
			else:
				if not config.block_navigator:
					pygui_globs['menustack'].back_to_home()
		return None
		if last_context is not None:
			louie_send('event_left', sender=self)
			sleep(config.HMI_BASE['navigator_listing_delay'])
			self.set_items(last_context['items'], 'main_list', last_context['position'])
			self.tasks['reload_func'].start(1)
			self._path_changed()
			return True
		return False

	go_to_item = back_root_if_error()
	def _selection_changed(self, item):
		log.debug('UPDATE %s', item)
		if self.selected == item:
			log.debug('IS SELECTED')
			louie_send('main_list', sender=self, action='reset', value=self['main_list'], position=self.selected_pos)
			self.build_preview()
		else:
			if self._history and item == self._history[-1]['selected']:
				log.debug('IS PARENT')
				self.reload_func()

	select = back_root_if_error()
	def back_to_root(self, *args, **args):
		for win in self.contextual_windows:
			try:
				win.hide()
				continue
			except:
				log.debug('Unable to close %s', win)
				continue

	def _update_marker(self):
		markerlist = self.markerlist
		if bool(markerlist):
			markerlist._refresh()
			self.set_items([markerlist], list_name='markerlist')
		else:
			self.set_items([], list_name='markerlist')
		main_list = self.get_item_list('main_list')
		louie_send('main_list', sender=self, action='mark', value=main_list, position=main_list.selected_pos)
		self.build_preview()

	def on_foreground(self):
		Menu.on_foreground(self)
		self.force_preview = True
		self.build_preview()

	def on_background(self):
		Menu.on_background(self)
		self.stop()

	def _hide_preview(self):
		if self._actual_preview is not None:
			louie_send('hide_%s_preview' % self._actual_preview, sender=self)
			louie_send('preview_list_no_more_items_before', sender=self)
			louie_send('preview_list_no_more_items_after', sender=self)
			self._actual_preview = None
		return None

	def hide_preview(self):
		self.tasks['hide_preview'].start(config.HMI_BASE['preview_delay'] + 0.10000000000000001)

	def _build_preview(self):
		hide_preview_task = self.tasks['hide_preview']
		if hide_preview_task.running:
			hide_preview_task.stop()
		sel = self.selected
		try:
			sel.watch(self._selection_changed)
		except AttributeError:
			pass
		try:
			louie_send('title', sender=self, value=self['title'])
			louie_send('artist', sender=self, value=self['artist'])
			louie_send('album', sender=self, value=self['album'])
			louie_send('track', sender=self, value=self['track'])
			louie_send('duration', sender=self, value=self['duration'])
			louie_send('size', sender=self, value=self['size'])
			louie_send('date', sender=self, value=self['date'])
		except:
			PRINT_EXCEPTION()
			log.error('Id3Tags error')
		louie_send('author', sender=self, value=self['author'])
		louie_send('description', sender=self, value=self['description'])
		louie_send('link', sender=self, value=self['link'])
		louie_send('embedded_media', sender=self, value=self['embedded_media'])
		try:
			louie_send('item_name', sender=self, action='update', value=omnicode(self['item_name']))
		except Exception, e:
			log.error('Item Name error: %s', e)
		pt = None
		try:
			louie_send('thumbnail', sender=self, value=self['thumbnail'])
			if isinstance(sel, ImageItem):
				pt = 'img'
			else:
				if isinstance(sel, VideoItem):
					pt = 'mov'
				else:
					if isinstance(sel, AudioItem):
						pt = 'snd'

	def build_preview(self):
		self.tasks['build_preview'].start(config.HMI_BASE['preview_delay'])



class Navigator(GenericNavigator):
	__doc__ = " Defines 'browser' menus, to access filesystem contents "
	name = 'navigator'
	def __init__(self, name, universe, choices=None, eventhandler=None, fill_root=True, **kw):
		GenericNavigator.__init__(self, name, universe, choices, eventhandler, **kw)
		self.tasks['_fill_nav'] = Task(self._fill_nav)
		if fill_root:
			self.tasks['_fill_nav'].start(-1)

	def _fill_nav(self):
		self.set_items(self.root_getter())
		self.build_preview()

	def root_getter(self):
		try:
			root_items = list(RootItem().browse(self.type, self))
		except BrowseError:
			root_items = [EmptyItem()]
		return root_items

	def reset(self, *args, **args):
		GenericNavigator.reset(self, *args, **kw)
		self._update_marker()

	def clear(self):
		pass

	def select(self, item, list_name=None, force_pos=False):
		old_sel = self.selected
		ret = GenericNavigator.select(self, item, list_name=list_name, force_pos=force_pos)

	execute_selected = back_root_if_error()
	def action_info(self):
		if self.selected:
			from pygui.menu.menu.info import item_info_menu_dict
			try:
				info_menu = item_info_menu_dict[self.selected.type](self.selected)
			except KeyError:
				self._error_spawner()
				log.warn('No InfowWindow defined for type %s', self.selected.type)
			else:
				info_menu.show()

	def browse_previous(self):
		ret = GenericNavigator.browse_previous(self)
		stack = pygui_globs['menustack']
		if ret is None and stack.get_player() is None:
			if self['main_list'].selected_pos == 0 and 'universe_switcher' not in config.plugins:
				stack.back_to_home()
			else:
				self.select(0, force_pos=True)
				louie_send('main_list', action='update', sender=self, value=self['main_list'], position=0)
		return None



class MarkerNavigator(GenericNavigator):
	name = 'MarkerList'
	def __init__(self, name, universe, choices, origin, marker, **kw):
		GenericNavigator.__init__(self, name, universe, choices, eventhandler=MarkerListEventHandler(self), **kw)
		if origin:
			self.set_items([copy(origin)], list_name='origin_list')
		else:
			self.set_items([], list_name='origin_list')
		self.set_items([marker], list_name='markerlist')
		self.markerlist = marker
		def self._getitems_keywords['origin_list']():
			return self.get_item_list('origin_list')

		self.selected = None
		self.select(0)
		return None

	def stop(self):
		try:
			pygui_globs['menustack'].get_navigator().force_preview = True
		except:
			PRINT_EXCEPTION()
		GenericNavigator.stop(self)

	def unmark_selected(self):
		sel = self.selected
		self.markerlist.del_item(sel)
		self.delete_item(sel)
		self.build_preview()

	def refresh_root(self):
		pass

	def action_info(self):
		from pygui.menu.menu.info import MarkerListInfoMenu
		info_menu = MarkerListInfoMenu(self.markerlist)
		info_menu.show()



class GridNavigator(GenericNavigator):
	__doc__ = 'Navigator that uses ItemGrids instead of ItemLists.\n\n    Perfect for thumbnails and the like.\n    Grids have their row lengths set by the row_length class attribute.\n\n    TODO Maybe allow one row length per grid, with a {name: length} dict?\n    '
	row_length = 5
	def add_item_list(self, list_name, items=None):
		if list_name is not None:
			if not items:
				pass
			self.item_lists_dict[list_name] = ItemGrid(self, items, list_name, self.row_length)
		return None

	def select_horizontal(self, item, list_name=None, force_pos=False):
		if not list_name:
			pass
		return self.get_item_list(list_name).select_horizontal(item, force_pos)

	def select_vertical(self, item, list_name=None, force_pos=False):
		if not list_name:
			pass
		return self.get_item_list(list_name).select_vertical(item, force_pos)



class ThumbnailNavigator(GridNavigator):
	__doc__ = 'Thumbnail browser.'
	toggleable = False
	groupeable = True
	row_length = config.HMI_PHOTO['thumbnail_row_length']
	def __init__(self, name, universe, choices=None, eventhandler=None, folder=None, type=None, **kw):
		GridNavigator.__init__(self, name, universe, choices=choices, eventhandler=ThumbnailNavigatorEventHandler(self), type=type, **kw)
		self.folder = folder
		if not choices and self.folder:
			self.folder.menu = self
			self.set_items(self.folder.browse())
		def self._getitems_keywords['parent_item_name']():
			if self.folder:
				pass
			return u''


	def build_preview(self, *args, **args):
		return None

	def stop(self):
		try:
			pygui_globs['menustack'].get_navigator().force_preview = True
		except:
			PRINT_EXCEPTION()
		GridNavigator.stop(self)
		metadata_collector_clear()

	execute_selected = back_root_if_error()
	def _refresh_main(self):
		louie_send('main_list', sender=self, action='reset', value=self['main_list'])

	def _thumbnail_updated(self, item):
		pos = self['main_list'].index(item)
		louie_send('main_list', sender=self, action='reset', value=self['main_list'], position=pos)



]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9e3430c>}
from __future__ import absolute_import
__all__ = ['MarkerNavigator', 'ThumbnailNavigator', 'Navigator', 'GenericNavigator', 'EmptyItem']
from copy import copy
from time import sleep
from wymedia.wmplus import BrowseError, metadata_collector_clear
from peewee.debug import GET_LOGGER, PRINT_EXCEPTION
from peewee.formatters import seconds_to_hhmmss_utc, seconds_to_mmss_utc, ellipsize
from peewee.messages import send as louie_send
from peewee.messages import connect as louie_connect
from peewee.misc_utils import MetaSingleton
from peewee.notifier import Task
from pygui import config
from pygui.window import LoadingWindow
from pygui.eventmanager.menus import MarkerListEventHandler, NavigatorEventHandler, ThumbnailNavigatorEventHandler
from pygui.facilities.l10n import omnicode
from pygui.item.core import Item
from pygui.item.containers import ItemGrid
from pygui.item.info import get_field
from pygui.item.mediaitem import RootItem, TVRootItem, DVDItem, IsoDVDItem, VideoItem, ImageItem, AudioItem
from pygui.item.mediaitem import DirItem, Playlist
from pygui.item.mediaitem.net import NetFeedItem
from pygui.item.mediaitem.audiovideo import TVRecordItem
from pygui.item.mediaitem.core import TV_FAVORITES_FOLDER
from pygui.item.mediaitem.net import NetItem
from pygui.markerlist import markerlists
from pygui.menu import UNIVERSE_NAME_DICT
from pygui.menu.menu.core import Menu
from pygui.shared import pygui_globs
from pygui.window import Button, ConfirmWindow
from pygui.window import LoadingWindow
log = GET_LOGGER(__name__)
def back_root_if_error(fn):
	def wrap(self, *args, **args):
		ret = None
		try:
			ret = fn(self, *args, **kw)
		except BrowseError:
			self.back_to_root()
		return ret

	wrap.__name__ = fn.__name__
	return wrap

class EmptyItem(Item):
	__doc__ = ' A simple item to put in empty places to signal it '
	__metaclass__ = MetaSingleton
	def __init__(self):
		Item.__init__(self, _('No content'), type_='empty', display_type='empty')

	name = property((lambda self: _('No content')))


class NotSoEmptyItem(Item):
	__doc__ = ' A simple item to put in empty places to signal it '
	__metaclass__ = MetaSingleton
	def __init__(self):
		Item.__init__(self, _('No content for this universe'), type_='empty', display_type='empty')

	name = property((lambda self: _('No content for this universe')))


class HistoryStack(list):
	__doc__ = ' stack-like class with modification notification handler '
	def __init__(self, history=None, on_modify=None):
		list.__init__(self)
		if history is not None:
			self[:] = history
			if on_modify:
				on_modify()
		if not on_modify:
			pass
		self._modification_handler = on_modify
		return None

	def pop(self, *args, **args):
		ret = list.pop(self, *args, **kw)
		self._modification_handler()
		return ret

	def append(self, *args, **args):
		ret = list.append(self, *args, **kw)
		self._modification_handler()
		return ret

	def empty(self):
		self[:] = list()



class GenericNavigator(Menu):
	__doc__ = " Defines 'browser' menus, to access filesystem contents "
	toggleable = True
	def __init__(self, name, universe, choices=None, eventhandler=None, **kw):
		self._history = HistoryStack()
		self._actual_preview = None
		self.force_preview = False
		self.contextual_windows = []
		Menu.__init__(self, name, choices, universe=universe, **kw)
		self.tasks.update({'build_preview': Task(self._build_preview), 'hide_preview': Task(self._hide_preview), 'refresh_root': Task(self._refresh_root), 'reload_func': Task(self._reload_func)})
		self._getitems_keywords.update(markerlist=(lambda : self.get_item_list('markerlist')), universe_name=(lambda : UNIVERSE_NAME_DICT[self.type]), parent_icon_name=self._get_parent_icon_name, parent_item_name=self._get_parent_item_name, thumbnail=self._get_thumbnail, folder_depth=(lambda : len(self._history)), parental_rating=self._get_parental_rating, title=self._get_title, date=self._get_date, artist=(lambda : .selected is not None and self.selected.type in ('audio',):
			pass
		return ''), album=(lambda : .selected is not None and self.selected.type in ('audio',):
			pass
		return ''), track=(lambda : .selected is not None and self.selected.type in ('audio',):
			if not self.selected['track']:
				pass
		return ''), duration=(lambda : .selected is not None and self.selected.type in ('audio',):
			pass
		return ''), size=(lambda : .selected is not None and self.selected.type in ('image',):
			pass
		return ''), author=(lambda : .selected is not None:
			pass
		return u''), description=self._get_description, link=(lambda : .selected is not None:
			pass
		return u''), embedded_media=self._get_embedded_media_icon)
		self.set_items([], list_name='markerlist')
		if eventhandler:
			self.eventhandler = eventhandler
			self.markerlist = None
		else:
			self.eventhandler = NavigatorEventHandler(self)
			self.markerlist = markerlists()[self.universe]
		self._update_marker()
		louie_connect(receiver=self.back_to_root, signal='refresh_root', sender='navigator')
		return None

	def _get_description(self):
		item = self.selected
		if item is not None:
			if item['description']:
				return ellipsize(item['description'], 400)
		return u''

	def _get_embedded_media(self):
		item = self.selected
		if item is not None:
			if item['backend'] == 'net_services':
				if item and item['uri']:
					if item['uri'] != '::online::':
						return 'embedded_media'
		return u''

	def _get_embedded_media_icon(self):
		embedded = self._get_embedded_media()
		if embedded:
			return embedded + '.png'

	def _get_date(self):
		item = self.selected
		if item is not None:
			if item.type == 'audio':
				if item['backend'] == 'net_services':
					pass
				return item['exif_date']
		return u''

	def _get_title(self):
		item = self.selected
		if item is not None:
			if item.type == 'audio':
				if item['backend'] == 'net_services':
					pass
				return item['metadata_title']
		return u''

	def _get_audio_duration(self):
		duration = self.selected['duration']
		if duration:
			seconds = int(duration)
			if seconds >= 3600:
				pass
			return seconds_to_mmss_utc(seconds)
		else:
			return ''

	def _get_parental_rating(self):
		ico = None
		if config.user_config['security']['parental_control']:
			if not config.user_config['security']['parent_mode']:
				ico = 'maturityrating_%s.png' % config.user_config['security']['maturity_rating']
		return ico

	def _set_preview_type(self, kind):
		if pygui_globs['menustack'].menus_stack[-1] is not self:
			log.debug('%s not on top of stack. avoid sending preview type', self)
			return None
		log.debug('actual_preview:%s  new_preview:%s', self._actual_preview, kind)
		if kind != self._actual_preview or self.force_preview:
			if self._actual_preview is not None:
				log.debug('hide_%s_preview', self._actual_preview)
				louie_send('hide_%s_preview' % self._actual_preview, self)
			if kind is not None:
				log.debug('show_%s_preview', kind)
				louie_send('show_%s_preview' % kind, self)
			self._actual_preview = kind
		self.force_preview = False
		return None

	def _get_parent_item_name(self):
		if len(self._history):
			return self._history[-1]['selected'].name
		else:
			if self.selected:
				parent = self.selected.parent
				if parent not in (RootItem(), TVRootItem(), self.markerlist) and parent.name != TV_FAVORITES_FOLDER:
					return parent.name
		return ''

	def _get_parent_icon_name(self):
		if len(self._history):
			return 'parentfolder-%s.png' % self.type
		else:
			if self.selected:
				parent = self.selected.parent
				if parent not in (RootItem(), TVRootItem(), self.markerlist) and parent.name != TV_FAVORITES_FOLDER:
					return 'parentfolder-%s.png' % self.type
		return 'root-%s.png' % self.type

	def show(self, hide_previous_menu=True):
		Menu.show(self, hide_previous_menu)
		self.get_item_list('main_list').advertise()

	def reset(self, name, universe, **kw):
		Menu.reset(self, name=name, universe=universe, **kw)
		self._history.empty()
		self.set_items([], list_name='markerlist')
		self.markerlist = markerlists()[self.universe]
		self.set_items(self.root_getter(), list_name='main_list')
		self.build_preview()

	def stop(self):
		if hasattr(self.selected, 'unwatch'):
			self.selected.unwatch(self._selection_changed)
		Menu.stop(self)

	def clear(self):
		pass

	def _get_thumbnail(self):
		try:
			if not self.selected['thumbnail']:
				pass

	def _path_changed(self):
		louie_send('parent_item_name', sender=self, value=self['parent_item_name'])
		louie_send('parent_icon_name', sender=self, value=self['parent_icon_name'])
		louie_send('folder_depth', sender=self, value=len(self._history))

	def backup_navigator_history(self, navigator):
		self._history = HistoryStack(history=navigator._history)
		last_context = self._history[-1]
		self.set_items(last_context['items'], 'main_list', last_context['position'])
		self.build_preview()

	execute_selected = back_root_if_error()
	_reload_func = back_root_if_error()
	def reload_func(self):
		Menu.reload_func(self)
		self.tasks['reload_func'].start(0.5)

	def _refresh_root(self):
		old_sel = max(0, self.selected_pos)
		if not self._history:
			log.debug('refreshing items')
			self.set_items(self.root_getter(), list_name='main_list', position=old_sel)
		else:
			log.debug('refreshing history')
			history_dict = self._history[0]
			history_dict['items'] = self.root_getter()
			history_dict['position'] = min(history_dict['position'], len(history_dict['items']) - 1)

	def refresh_root(self):
		self.tasks['refresh_root'].start(1.0)

	browse_selected = back_root_if_error()
	def browse_previous(self):
		try:
			last_context = self._history.pop()
			if hasattr(self.selected, 'unwatch'):
				self.selected.unwatch(self._selection_changed)
		except IndexError:
			if self.selected and self.selected.parent:
				self.go_to_item(self.selected.parent, 'event_left')
				louie_send('on_root', sender=self)
			else:
				if not config.block_navigator:
					pygui_globs['menustack'].back_to_home()
		return None
		if last_context is not None:
			louie_send('event_left', sender=self)
			sleep(config.HMI_BASE['navigator_listing_delay'])
			self.set_items(last_context['items'], 'main_list', last_context['position'])
			self.tasks['reload_func'].start(1)
			self._path_changed()
			return True
		return False

	go_to_item = back_root_if_error()
	def _selection_changed(self, item):
		log.debug('UPDATE %s', item)
		if self.selected == item:
			log.debug('IS SELECTED')
			louie_send('main_list', sender=self, action='reset', value=self['main_list'], position=self.selected_pos)
			self.build_preview()
		else:
			if self._history and item == self._history[-1]['selected']:
				log.debug('IS PARENT')
				self.reload_func()

	select = back_root_if_error()
	def back_to_root(self, *args, **args):
		for win in self.contextual_windows:
			try:
				win.hide()
				continue
			except:
				log.debug('Unable to close %s', win)
				continue

	def _update_marker(self):
		markerlist = self.markerlist
		if bool(markerlist):
			markerlist._refresh()
			self.set_items([markerlist], list_name='markerlist')
		else:
			self.set_items([], list_name='markerlist')
		main_list = self.get_item_list('main_list')
		louie_send('main_list', sender=self, action='mark', value=main_list, position=main_list.selected_pos)
		self.build_preview()

	def on_foreground(self):
		Menu.on_foreground(self)
		self.force_preview = True
		self.build_preview()

	def on_background(self):
		Menu.on_background(self)
		self.stop()

	def _hide_preview(self):
		if self._actual_preview is not None:
			louie_send('hide_%s_preview' % self._actual_preview, sender=self)
			louie_send('preview_list_no_more_items_before', sender=self)
			louie_send('preview_list_no_more_items_after', sender=self)
			self._actual_preview = None
		return None

	def hide_preview(self):
		self.tasks['hide_preview'].start(config.HMI_BASE['preview_delay'] + 0.10000000000000001)

	def _build_preview(self):
		hide_preview_task = self.tasks['hide_preview']
		if hide_preview_task.running:
			hide_preview_task.stop()
		sel = self.selected
		try:
			sel.watch(self._selection_changed)
		except AttributeError:
			pass
		try:
			louie_send('title', sender=self, value=self['title'])
			louie_send('artist', sender=self, value=self['artist'])
			louie_send('album', sender=self, value=self['album'])
			louie_send('track', sender=self, value=self['track'])
			louie_send('duration', sender=self, value=self['duration'])
			louie_send('size', sender=self, value=self['size'])
			louie_send('date', sender=self, value=self['date'])
		except:
			PRINT_EXCEPTION()
			log.error('Id3Tags error')
		louie_send('author', sender=self, value=self['author'])
		louie_send('description', sender=self, value=self['description'])
		louie_send('link', sender=self, value=self['link'])
		louie_send('embedded_media', sender=self, value=self['embedded_media'])
		try:
			louie_send('item_name', sender=self, action='update', value=omnicode(self['item_name']))
		except Exception, e:
			log.error('Item Name error: %s', e)
		pt = None
		try:
			louie_send('thumbnail', sender=self, value=self['thumbnail'])
			if isinstance(sel, ImageItem):
				pt = 'img'
			else:
				if isinstance(sel, VideoItem):
					pt = 'mov'
				else:
					if isinstance(sel, AudioItem):
						pt = 'snd'

	def build_preview(self):
		self.tasks['build_preview'].start(config.HMI_BASE['preview_delay'])



class Navigator(GenericNavigator):
	__doc__ = " Defines 'browser' menus, to access filesystem contents "
	name = 'navigator'
	def __init__(self, name, universe, choices=None, eventhandler=None, fill_root=True, **kw):
		GenericNavigator.__init__(self, name, universe, choices, eventhandler, **kw)
		self.tasks['_fill_nav'] = Task(self._fill_nav)
		if fill_root:
			self.tasks['_fill_nav'].start(-1)

	def _fill_nav(self):
		self.set_items(self.root_getter())
		self.build_preview()

	def root_getter(self):
		try:
			root_items = list(RootItem().browse(self.type, self))
		except BrowseError:
			root_items = [EmptyItem()]
		return root_items

	def reset(self, *args, **args):
		GenericNavigator.reset(self, *args, **kw)
		self._update_marker()

	def clear(self):
		pass

	def select(self, item, list_name=None, force_pos=False):
		old_sel = self.selected
		ret = GenericNavigator.select(self, item, list_name=list_name, force_pos=force_pos)

	execute_selected = back_root_if_error()
	def action_info(self):
		if self.selected:
			from pygui.menu.menu.info import item_info_menu_dict
			try:
				info_menu = item_info_menu_dict[self.selected.type](self.selected)
			except KeyError:
				self._error_spawner()
				log.warn('No InfowWindow defined for type %s', self.selected.type)
			else:
				info_menu.show()

	def browse_previous(self):
		ret = GenericNavigator.browse_previous(self)
		stack = pygui_globs['menustack']
		if ret is None and stack.get_player() is None:
			if self['main_list'].selected_pos == 0 and 'universe_switcher' not in config.plugins:
				stack.back_to_home()
			else:
				self.select(0, force_pos=True)
				louie_send('main_list', action='update', sender=self, value=self['main_list'], position=0)
		return None



class MarkerNavigator(GenericNavigator):
	name = 'MarkerList'
	def __init__(self, name, universe, choices, origin, marker, **kw):
		GenericNavigator.__init__(self, name, universe, choices, eventhandler=MarkerListEventHandler(self), **kw)
		if origin:
			self.set_items([copy(origin)], list_name='origin_list')
		else:
			self.set_items([], list_name='origin_list')
		self.set_items([marker], list_name='markerlist')
		self.markerlist = marker
		def self._getitems_keywords['origin_list']():
			return self.get_item_list('origin_list')

		self.selected = None
		self.select(0)
		return None

	def stop(self):
		try:
			pygui_globs['menustack'].get_navigator().force_preview = True
		except:
			PRINT_EXCEPTION()
		GenericNavigator.stop(self)

	def unmark_selected(self):
		sel = self.selected
		self.markerlist.del_item(sel)
		self.delete_item(sel)
		self.build_preview()

	def refresh_root(self):
		pass

	def action_info(self):
		from pygui.menu.menu.info import MarkerListInfoMenu
		info_menu = MarkerListInfoMenu(self.markerlist)
		info_menu.show()



class GridNavigator(GenericNavigator):
	__doc__ = 'Navigator that uses ItemGrids instead of ItemLists.\n\n    Perfect for thumbnails and the like.\n    Grids have their row lengths set by the row_length class attribute.\n\n    TODO Maybe allow one row length per grid, with a {name: length} dict?\n    '
	row_length = 5
	def add_item_list(self, list_name, items=None):
		if list_name is not None:
			if not items:
				pass
			self.item_lists_dict[list_name] = ItemGrid(self, items, list_name, self.row_length)
		return None

	def select_horizontal(self, item, list_name=None, force_pos=False):
		if not list_name:
			pass
		return self.get_item_list(list_name).select_horizontal(item, force_pos)

	def select_vertical(self, item, list_name=None, force_pos=False):
		if not list_name:
			pass
		return self.get_item_list(list_name).select_vertical(item, force_pos)



class ThumbnailNavigator(GridNavigator):
	__doc__ = 'Thumbnail browser.'
	toggleable = False
	groupeable = True
	row_length = config.HMI_PHOTO['thumbnail_row_length']
	def __init__(self, name, universe, choices=None, eventhandler=None, folder=None, type=None, **kw):
		GridNavigator.__init__(self, name, universe, choices=choices, eventhandler=ThumbnailNavigatorEventHandler(self), type=type, **kw)
		self.folder = folder
		if not choices and self.folder:
			self.folder.menu = self
			self.set_items(self.folder.browse())
		def self._getitems_keywords['parent_item_name']():
			if self.folder:
				pass
			return u''


	def build_preview(self, *args, **args):
		return None

	def stop(self):
		try:
			pygui_globs['menustack'].get_navigator().force_preview = True
		except:
			PRINT_EXCEPTION()
		GridNavigator.stop(self)
		metadata_collector_clear()

	execute_selected = back_root_if_error()
	def _refresh_main(self):
		louie_send('main_list', sender=self, action='reset', value=self['main_list'])

	def _thumbnail_updated(self, item):
		pos = self['main_list'].index(item)
		louie_send('main_list', sender=self, action='reset', value=self['main_list'], position=pos)



