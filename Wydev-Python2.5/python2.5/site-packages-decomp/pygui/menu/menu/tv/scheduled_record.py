# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 53
n 53(None)[d = date(c.year + 0, max(1, (c.month + 1) % 13), 1)
return (d - c).days
]:
	i: 0&42(t), 49()
	o: 

nname: 49
n 49(None)[]:
	i: 0&42(f)
	o: 53()

nname: 0&42
n 0&42(c.month == 12 and 1)[c = date(year, month, 1)
]:
	i: 
	o: 49(f), 53(t)

nname: 0&42
n 0&42(None)[c = date(year, month, 1)
if not(c.month == 12 and 1):
	pass
d = date(c.year + 0, max(1, (c.month + 1) % 13), 1)
return (d - c).days
]:
	i: 
	o: 

self.nodes: {'0&42': <unpyclib.structure.node instance at 0xb75aa5ec>}
nname: 0
n 0(None)[Item.__init__(self, '%.2d' % val, type_, menu=None, display_type=None, parent=None)
self.val = val
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75aa8ec>}
nname: 36
n 36(None)[return False
]:
	i: 15(), 35()
	o: 

nname: 35
n 35(None)[]:
	i: 0(f)
	o: 36()

nname: 15
n 15(None)[return self.val == other.val
]:
	i: 0(t)
	o: 36()

nname: 0
n 0(isinstance(other, Item))[]:
	i: 
	o: 15(t), 35(f)

nname: 0
n 0(None)[if isinstance(other, Item):
	return self.val == other.val
return False
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75aa8ec>}
nname: 6
n 6(None)[def __init__(self, val, type_='int', menu=None, display_type=None, parent=None):
	Item.__init__(self, '%.2d' % val, type_, menu=None, display_type=None, parent=None)
	self.val = val
	return None

def __eq__(self, other):
	if isinstance(other, Item):
		return self.val == other.val
	return False

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb761f5ec>}
nname: 0
n 0(None)[it = Item(self.PERIODICITY[key][0], 'periodic', self)
it.val = self.PERIODICITY[key]
it.key = key
return it
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75ca72c>}
nname: 0
n 0(None)[return self.confirmation_list
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75cdbec>}
nname: 0
n 0(None)[return self.repetition_number_list.selected.name
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75cdbac>}
nname: 0
n 0(None)[return self.repetition_type_list.selected.name
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75cdd4c>}
nname: 0
n 0(None)[return self.stop_minute_list.selected.name
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75cddac>}
nname: 0
n 0(None)[return self.stop_hour_list.selected.name
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75cdc8c>}
nname: 0
n 0(None)[return self.start_minute_list.selected.name
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75cdaac>}
nname: 0
n 0(None)[return self.start_hour_list.selected.name
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75cdccc>}
nname: 0
n 0(None)[return self.date_3_list.selected.name
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75cdaac>}
nname: 0
n 0(None)[return self.date_2_list.selected.name
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75cdc8c>}
nname: 0
n 0(None)[return self.date_1_list.selected.name
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75cdbac>}
nname: 0
n 0(None)[return self.record_name
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75cdbac>}
nname: 38
n 38(None)[return _('Unknown')
]:
	i: 0&12(t), 28()
	o: 

nname: 28
n 28(None)[]:
	i: 0&12(f)
	o: 38()

nname: 0&12
n 0&12(self.favorite_list.selected and self.favorite_list.selected.name)[]:
	i: 
	o: 28(f), 38(t)

nname: 0&12
n 0&12(None)[if not(self.favorite_list.selected and self.favorite_list.selected.name):
	pass
return _('Unknown')
]:
	i: 
	o: 

self.nodes: {'0&12': <unpyclib.structure.node instance at 0xb75cd8cc>}
nname: 38
n 38(None)[return _('Unknown')
]:
	i: 0&12(t), 28()
	o: 

nname: 28
n 28(None)[]:
	i: 0&12(f)
	o: 38()

nname: 0&12
n 0&12(self.channel_list.selected and self.channel_list.selected.name)[]:
	i: 
	o: 28(f), 38(t)

nname: 0&12
n 0&12(None)[if not(self.channel_list.selected and self.channel_list.selected.name):
	pass
return _('Unknown')
]:
	i: 
	o: 

self.nodes: {'0&12': <unpyclib.structure.node instance at 0xb75cdb8c>}
nname: 507
n 507(None)[del _[2]
def _fun(key):
	it = Item(self.PERIODICITY[key][0], 'periodic', self)
	it.val = self.PERIODICITY[key]
	it.key = key
	return it

self.confirmation_list.select(None, True)
self.set_items([self.service_list, self.date_list, self.start_time_list, self.stop_time_list, self.repetition_list, self.repetition_num_list, self.confirmation_list])
self._getitems_keywords.update(channel_name=(lambda : self.channel_list.selected and self.channel_list.selected.name):
	pass
return _('Unknown')), favorite_name=(lambda : self.favorite_list.selected and self.favorite_list.selected.name):
	pass
return _('Unknown')), record_name=(lambda : self.record_name), date_1=(lambda : self.date_1_list.selected.name), date_2=(lambda : self.date_2_list.selected.name), date_3=(lambda : self.date_3_list.selected.name), date_weekday=self._get_weekday_from_date, start_hour=(lambda : self.start_hour_list.selected.name), start_minute=(lambda : self.start_minute_list.selected.name), stop_hour=(lambda : self.stop_hour_list.selected.name), stop_minute=(lambda : self.stop_minute_list.selected.name), repetition_type=(lambda : self.repetition_type_list.selected.name), repetition_number=(lambda : self.repetition_number_list.selected.name), confirmation_list=(lambda : self.confirmation_list))
return None
]:
	i: 431(AF), 488()
	o: 

nname: 488
n 488(None)[for i in xrange(1, days_in_month(_today.year, _today.month) + 1):
]:
	i: 431(for)
	o: 507()

nname: 431
n 431(None)[del _[1]
]:
	i: 0(AF), 412()
	o: 488(for), 507(AF)

nname: 412
n 412(None)[for i in xrange(_today.year, _today.year + 10):
]:
	i: 0(for)
	o: 431()

nname: 0
n 0(None)[Menu.__init__(self, name, type=type_, universe='tv')
self.PERIODICITY = {'none': (_('Only this time'), 0), 'daily': (_('Every day'), 1), 'weekly': (_('Every week'), 7)}
self._favorite_list = [TVRootItem().get_acl(menu=self)]
self._favorite_list.extend(TVRootItem().browse_favorites(self))
self._all_channel_list = self._favorite_list[0]
self.eventhandler = ModifyScheduledRecordMenuEventHandler(self)
self.channel_list = ItemListItem(_('Channels'), menu=self, _list=self._favorite_list, list_name='channel_name_list')
self.favorite_list = ItemListItem(_('Favorites'), menu=self, _list=self._all_channel_list.browse(), list_name='favorite_name_list')
self.service_list = ItemListItem(_('Channel'), menu=self, _list=[self.channel_list, self.favorite_list], list_name='service_list')
self.item_lists_dict['service_list'] = self.service_list
_today = date.today()
]:
	i: 
	o: 412(for), 431(AF)

self.nodes: {0: <unpyclib.structure.node instance at 0xb75ca24c>, 488: <unpyclib.structure.node instance at 0xb75ca3cc>, 507: <unpyclib.structure.node instance at 0xb75ca44c>, 412: <unpyclib.structure.node instance at 0xb75ca2cc>, 431: <unpyclib.structure.node instance at 0xb75ca34c>}
nname: 68
n 68(None)[]:
	i: 31(), 51()
	o: 

nname: 51
n 51(None)[louie_send('frequency_only_this_time_off', sender=self)
]:
	i: 0(f)
	o: 68()

nname: 31
n 31(None)[louie_send('frequency_only_this_time_on', sender=self)
]:
	i: 0(t)
	o: 68()

nname: 0
n 0(self.is_only_this_time())[Menu.show(self, *args, **kw)
]:
	i: 
	o: 31(t), 51(f)

nname: 0
n 0(None)[Menu.show(self, *args, **kw)
if self.is_only_this_time():
	louie_send('frequency_only_this_time_on', sender=self)
else:
	louie_send('frequency_only_this_time_off', sender=self)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76266ac>}
nname: 0
n 0(None)[return self.get_item_list('repetition_list')[0].selected_pos == 0
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb762628c>}
nname: 0
n 0(None)[date_list = self.date_list
return day_dict[date(int(date_list[self.year_index].selected.name), int(date_list[self.month_index].selected.name), int(date_list[self.day_index].selected.name)).weekday()]
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7626b0c>}
nname: 232
n 232(None)[]:
	i: 150(), 231()
	o: 

nname: 231
n 231(None)[]:
	i: 0(f)
	o: 232()

nname: 150
n 150(None)[del _[1]
[](xrange(1, d + 1), selected=min(d_list.selected_pos, d - 1))
louie_send('date_%d' % (self.day_index + 1), sender=self, value=self.date_list[self.day_index].selected.name)
]:
	i: 81(AF), 125()
	o: 232()

nname: 125
n 125(None)[for i in xrange(1, d + 1):
]:
	i: 81(for)
	o: 150()

nname: 81
n 81(None)[]:
	i: 0(t)
	o: 125(for), 150(AF)

nname: 0
n 0(d != len(d_list))[d_list = self.date_list[self.day_index]
d = days_in_month(self.date_list[self.year_index].selected.val, self.date_list[self.month_index].selected.val)
]:
	i: 
	o: 81(t), 231(f)

nname: 232
n 232(None)[]:
	i: 150(), 0(f)
	o: 

nname: 150
n 150(None)[del _[1]
[](xrange(1, d + 1), selected=min(d_list.selected_pos, d - 1))
louie_send('date_%d' % (self.day_index + 1), sender=self, value=self.date_list[self.day_index].selected.name)
]:
	i: 81(AF), 125()
	o: 232()

nname: 125
n 125(None)[for i in xrange(1, d + 1):
]:
	i: 81(for)
	o: 150()

nname: 81
n 81(None)[]:
	i: 0(t)
	o: 125(for), 150(AF)

nname: 0
n 0(d != len(d_list))[d_list = self.date_list[self.day_index]
d = days_in_month(self.date_list[self.year_index].selected.val, self.date_list[self.month_index].selected.val)
]:
	i: 
	o: 81(t), 232(f)

self.nodes: {0: <unpyclib.structure.node instance at 0xb75b562c>, 232: <unpyclib.structure.node instance at 0xb75b5d2c>, 81: <unpyclib.structure.node instance at 0xb75b5e4c>, 150: <unpyclib.structure.node instance at 0xb75b576c>, 125: <unpyclib.structure.node instance at 0xb75b5f2c>}
nname: 264
n 264(None)[]:
	i: 195(), 263()
	o: 

nname: 263
n 263(None)[]:
	i: 0(f)
	o: 264()

nname: 195
n 195(None)[struct_t = localtime(stop)
self.stop_hour_list.select(IntegerItem(struct_t[3]))
self.stop_minute_list.select(IntegerItem(struct_t[4]))
]:
	i: 0(t)
	o: 264()

nname: 0
n 0(stop)[struct_t = localtime(_date)
self.date_list[self.year_index].select(IntegerItem(struct_t[0]))
self.date_list[self.month_index].select(IntegerItem(struct_t[1]))
self.date_list[self.day_index].select(IntegerItem(struct_t[2]))
louie_send('date_weekday', sender=self, value=self['date_weekday'])
self.start_hour_list.select(IntegerItem(struct_t[3]))
self.start_minute_list.select(IntegerItem(struct_t[4]))
]:
	i: 
	o: 195(t), 263(f)

nname: 0
n 0(None)[struct_t = localtime(_date)
self.date_list[self.year_index].select(IntegerItem(struct_t[0]))
self.date_list[self.month_index].select(IntegerItem(struct_t[1]))
self.date_list[self.day_index].select(IntegerItem(struct_t[2]))
louie_send('date_weekday', sender=self, value=self['date_weekday'])
self.start_hour_list.select(IntegerItem(struct_t[3]))
self.start_minute_list.select(IntegerItem(struct_t[4]))
if stop:
	struct_t = localtime(stop)
	self.stop_hour_list.select(IntegerItem(struct_t[3]))
	self.stop_minute_list.select(IntegerItem(struct_t[4]))
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75b576c>}
nname: 120
n 120(None)[chans = self.favorite_list.selected.browse()
self.channel_list.set_items(chans)
self.channel_list.select(chan_info)
return None
]:
	i: 77(), 103()
	o: 

nname: 103
n 103(None)[self.favorite_list.select(current_favorite)
]:
	i: 0(f)
	o: 120()

nname: 77
n 77(None)[self.favorite_list.select(0, force_pos=True)
]:
	i: 0(t)
	o: 120()

nname: 0
n 0(current_favorite is None)[favorite_list = [TVRootItem().get_acl(menu=self)]
favorite_list.extend(TVRootItem().browse_favorites(self))
self.favorite_list.set_items(favorite_list)
]:
	i: 
	o: 77(t), 103(f)

nname: 0
n 0(None)[favorite_list = [TVRootItem().get_acl(menu=self)]
favorite_list.extend(TVRootItem().browse_favorites(self))
self.favorite_list.set_items(favorite_list)
if current_favorite is None:
	self.favorite_list.select(0, force_pos=True)
else:
	self.favorite_list.select(current_favorite)
chans = self.favorite_list.selected.browse()
self.channel_list.set_items(chans)
self.channel_list.select(chan_info)
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75b56cc>}
nname: 375
n 375(None)[return None
]:
	i: 217(), 374()
	o: 

nname: 374
n 374(None)[]:
	i: 189(f)
	o: 375()

nname: 217
n 217(None)[_rule = _wyrecord.scheduler.GetPeriodicRuleById(scheduled_record.record.periodicity_rule_id)
self.repetition_type_list.select(Item(self.PERIODICITY[_rule.extern_rule_name][0], 'periodic', self))
_num = (mktime(_rule.last_time.timetuple()) - _rule.recording_ref.start_time) / float(self.PERIODICITY[_rule.extern_rule_name][1] * 86400)
self.repetition_number_list.select(IntegerItem(int(_num)))
]:
	i: 189(t)
	o: 375()

nname: 189
n 189(isinstance(scheduled_record, PeriodicScheduledRecordItem))[self.select_channel(target_channel)
]:
	i: 0(AL), 182()
	o: 217(t), 374(f)

nname: 182
n 182(None)[]:
	i: 100(AF), 178()
	o: 189()

nname: 178
n 178(None)[]:
	i: 122(f), 160()
	o: 182()

nname: 160
n 160(None)[target_channel, target_channel = None, self.favorite_list[i]
break
continue
]:
	i: 122(t)
	o: 178()

nname: 122
n 122(self.favorite_list[i]['serviceId'] == str(scheduled_record.record.service_id))[for i in xrange(len(self.favorite_list)):
]:
	i: 100(for)
	o: 160(t), 178(f)

nname: 100
n 100(None)[]:
	i: 0(loop)
	o: 122(for), 182(AF)

nname: 0
n 0(None)[self._record_to_remove = scheduled_record
_wyrecord = WyRecord()
self.record_name = scheduled_record.name
self.select_date(scheduled_record.record.start_time, scheduled_record.record.stop_time)
target_channel = TVRootItem().get_acl(self).get_channel_from_service_id(str(scheduled_record.record.service_id))
]:
	i: 
	o: 100(loop), 189(AL)

nname: 189
n 189(None)[self.select_channel(target_channel)
if isinstance(scheduled_record, PeriodicScheduledRecordItem):
	_rule = _wyrecord.scheduler.GetPeriodicRuleById(scheduled_record.record.periodicity_rule_id)
	self.repetition_type_list.select(Item(self.PERIODICITY[_rule.extern_rule_name][0], 'periodic', self))
	_num = (mktime(_rule.last_time.timetuple()) - _rule.recording_ref.start_time) / float(self.PERIODICITY[_rule.extern_rule_name][1] * 86400)
	self.repetition_number_list.select(IntegerItem(int(_num)))
return None
]:
	i: 0(AL), 100(AF), 122()
	o: 

nname: 122
n 122(None)[for i in xrange(len(self.favorite_list)):
if self.favorite_list[i]['serviceId'] == str(scheduled_record.record.service_id):
	target_channel, target_channel = None, self.favorite_list[i]
	break
	continue
]:
	i: 100(for)
	o: 189()

nname: 100
n 100(None)[]:
	i: 0(loop)
	o: 122(for), 189(AF)

nname: 0
n 0(None)[self._record_to_remove = scheduled_record
_wyrecord = WyRecord()
self.record_name = scheduled_record.name
self.select_date(scheduled_record.record.start_time, scheduled_record.record.stop_time)
target_channel = TVRootItem().get_acl(self).get_channel_from_service_id(str(scheduled_record.record.service_id))
]:
	i: 
	o: 100(loop), 189(AL)

nname: 122
n 122(None)[for i in xrange(len(self.favorite_list)):
	if self.favorite_list[i]['serviceId'] == str(scheduled_record.record.service_id):
		target_channel, target_channel = None, self.favorite_list[i]
		break
		continue
self.select_channel(target_channel)
if isinstance(scheduled_record, PeriodicScheduledRecordItem):
	_rule = _wyrecord.scheduler.GetPeriodicRuleById(scheduled_record.record.periodicity_rule_id)
	self.repetition_type_list.select(Item(self.PERIODICITY[_rule.extern_rule_name][0], 'periodic', self))
	_num = (mktime(_rule.last_time.timetuple()) - _rule.recording_ref.start_time) / float(self.PERIODICITY[_rule.extern_rule_name][1] * 86400)
	self.repetition_number_list.select(IntegerItem(int(_num)))
return None
]:
	i: 0(for)
	o: 

nname: 0
n 0(None)[self._record_to_remove = scheduled_record
_wyrecord = WyRecord()
self.record_name = scheduled_record.name
self.select_date(scheduled_record.record.start_time, scheduled_record.record.stop_time)
target_channel = TVRootItem().get_acl(self).get_channel_from_service_id(str(scheduled_record.record.service_id))
]:
	i: 
	o: 122(for)

nname: 0
n 0(None)[self._record_to_remove = scheduled_record
_wyrecord = WyRecord()
self.record_name = scheduled_record.name
self.select_date(scheduled_record.record.start_time, scheduled_record.record.stop_time)
target_channel = TVRootItem().get_acl(self).get_channel_from_service_id(str(scheduled_record.record.service_id))
for i in xrange(len(self.favorite_list)):
	if self.favorite_list[i]['serviceId'] == str(scheduled_record.record.service_id):
		target_channel, target_channel = None, self.favorite_list[i]
		break
		continue
self.select_channel(target_channel)
if isinstance(scheduled_record, PeriodicScheduledRecordItem):
	_rule = _wyrecord.scheduler.GetPeriodicRuleById(scheduled_record.record.periodicity_rule_id)
	self.repetition_type_list.select(Item(self.PERIODICITY[_rule.extern_rule_name][0], 'periodic', self))
	_num = (mktime(_rule.last_time.timetuple()) - _rule.recording_ref.start_time) / float(self.PERIODICITY[_rule.extern_rule_name][1] * 86400)
	self.repetition_number_list.select(IntegerItem(int(_num)))
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75ca1cc>}
nname: 329
n 329(None)[return True
]:
	i: 278(), 328()
	o: 

nname: 328
n 328(None)[]:
	i: 228(f)
	o: 329()

nname: 278
n 278(None)[error_title = _('Invalid data')
MessageWindow(error_message, error_title, button=None).show(timeout=5)
return False
]:
	i: 240(AL), 277()
	o: 329()

nname: 277
n 277(None)[]:
	i: 244(AF), 251()
	o: 278()

nname: 251
n 251(None)[for field in invalid_fields:
louie_send('%s_invalid' % field, sender=self)
]:
	i: 244(for)
	o: 277()

nname: 244
n 244(None)[]:
	i: 240(loop)
	o: 251(for), 277(AF)

nname: 240
n 240(None)[]:
	i: 228(t)
	o: 244(loop), 278(AL)

nname: 228
n 228(error_message is not None)[]:
	i: 182(AL), 227()
	o: 240(t), 328(f)

nname: 227
n 227(None)[]:
	i: 185(AF), 201()
	o: 228()

nname: 201
n 201(None)[for field in all_fields.difference(invalid_fields):
louie_send('%s_valid' % field, sender=self)
]:
	i: 185(for)
	o: 227()

nname: 185
n 185(None)[]:
	i: 182(loop)
	o: 201(for), 227(AF)

nname: 182
n 182(None)[]:
	i: 160(JA), 177(), 181()
	o: 185(loop), 228(AL)

nname: 181
n 181(None)[]:
	i: 106(f)
	o: 182()

nname: 177
n 177(None)[]:
	i: 118(f)
	o: 182()

nname: 160
n 160(None)[invalid_fields.add('date')
]:
	i: 118(t)
	o: 182(JA)

nname: 118
n 118(now - end_time >= 86400)[error_message = _('You are trying to record a program already over.')
invalid_fields.add('end_time')
]:
	i: 106(t)
	o: 160(t), 177(f)

nname: 106
n 106(end_time < now)[]:
	i: 89(), 105()
	o: 118(t), 181(f)

nname: 105
n 105(None)[]:
	i: 0(f)
	o: 106()

nname: 89
n 89(None)[error_message = _('The recording cannot be longer than 6 hours.')
]:
	i: 0(t)
	o: 106()

nname: 0
n 0(abs(end_time - start_time) > 21600)[all_fields = set(['date', 'start_time', 'end_date', 'end_time'])
invalid_fields = set()
error_message = None
now = time()
start_time, end_time = self.start_time, self.end_time
]:
	i: 
	o: 89(t), 105(f)

nname: 329
n 329(None)[return True
]:
	i: 278(), 228(f)
	o: 

nname: 278
n 278(None)[error_title = _('Invalid data')
MessageWindow(error_message, error_title, button=None).show(timeout=5)
return False
]:
	i: 251()
	o: 329()

nname: 251
n 251(None)[for field in invalid_fields:
	louie_send('%s_invalid' % field, sender=self)
]:
	i: 240(for)
	o: 278()

nname: 240
n 240(None)[]:
	i: 228(t)
	o: 251(for)

nname: 228
n 228(error_message is not None)[]:
	i: 201()
	o: 240(t), 329(f)

nname: 201
n 201(None)[for field in all_fields.difference(invalid_fields):
	louie_send('%s_valid' % field, sender=self)
]:
	i: 182(for)
	o: 228()

nname: 182
n 182(None)[]:
	i: 0(JA)
	o: 201(for)

nname: 0
n 0(None)[all_fields = set(['date', 'start_time', 'end_date', 'end_time'])
invalid_fields = set()
error_message = None
now = time()
start_time, end_time = self.start_time, self.end_time
if abs(end_time - start_time) > 21600:
	error_message = _('The recording cannot be longer than 6 hours.')
if end_time < now:
	error_message = _('You are trying to record a program already over.')
	invalid_fields.add('end_time')
	if now - end_time >= 86400:
		invalid_fields.add('date')
]:
	i: 
	o: 182(JA)

nname: 329
n 329(None)[return True
]:
	i: 278(), 201(f)
	o: 

nname: 278
n 278(None)[error_title = _('Invalid data')
MessageWindow(error_message, error_title, button=None).show(timeout=5)
return False
]:
	i: 240()
	o: 329()

nname: 240
n 240(None)[for field in invalid_fields:
	louie_send('%s_invalid' % field, sender=self)
]:
	i: 201(t)
	o: 278()

nname: 201
n 201(error_message is not None)[for field in all_fields.difference(invalid_fields):
	louie_send('%s_valid' % field, sender=self)
]:
	i: 0(for)
	o: 240(t), 329(f)

nname: 0
n 0(None)[all_fields = set(['date', 'start_time', 'end_date', 'end_time'])
invalid_fields = set()
error_message = None
now = time()
start_time, end_time = self.start_time, self.end_time
if abs(end_time - start_time) > 21600:
	error_message = _('The recording cannot be longer than 6 hours.')
if end_time < now:
	error_message = _('You are trying to record a program already over.')
	invalid_fields.add('end_time')
	if now - end_time >= 86400:
		invalid_fields.add('date')
]:
	i: 
	o: 201(for)

nname: 329
n 329(None)[return True
]:
	i: 240(), 0(f)
	o: 

nname: 240
n 240(None)[for field in invalid_fields:
	louie_send('%s_invalid' % field, sender=self)
error_title = _('Invalid data')
MessageWindow(error_message, error_title, button=None).show(timeout=5)
return False
]:
	i: 0(t)
	o: 329()

nname: 0
n 0(error_message is not None)[all_fields = set(['date', 'start_time', 'end_date', 'end_time'])
invalid_fields = set()
error_message = None
now = time()
start_time, end_time = self.start_time, self.end_time
if abs(end_time - start_time) > 21600:
	error_message = _('The recording cannot be longer than 6 hours.')
if end_time < now:
	error_message = _('You are trying to record a program already over.')
	invalid_fields.add('end_time')
	if now - end_time >= 86400:
		invalid_fields.add('date')
for field in all_fields.difference(invalid_fields):
	louie_send('%s_valid' % field, sender=self)
]:
	i: 
	o: 240(t), 329(f)

nname: 0
n 0(None)[all_fields = set(['date', 'start_time', 'end_date', 'end_time'])
invalid_fields = set()
error_message = None
now = time()
start_time, end_time = self.start_time, self.end_time
if abs(end_time - start_time) > 21600:
	error_message = _('The recording cannot be longer than 6 hours.')
if end_time < now:
	error_message = _('You are trying to record a program already over.')
	invalid_fields.add('end_time')
	if now - end_time >= 86400:
		invalid_fields.add('date')
for field in all_fields.difference(invalid_fields):
	louie_send('%s_valid' % field, sender=self)
if error_message is not None:
	for field in invalid_fields:
		louie_send('%s_invalid' % field, sender=self)
	error_title = _('Invalid data')
	MessageWindow(error_message, error_title, button=None).show(timeout=5)
	return False
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb758248c>}
nname: 150
n 150(None)[self.scheduled_record = None
return None
]:
	i: 16(), 46(), 82(), 148(AE)
	o: 

nname: 148
n 148(None)[]:
	i: 72(f)
	o: 150(AE)

nname: 82
n 82(None)[error_title = _('Impossible to cancel recording')
message = _('This recording has already started.')
MessageWindow(message, error_title, button=None).show(timeout=5)
return None
]:
	i: 72(t)
	o: 150()

nname: 72
n 72(<dummy_ex3> EXC_MATCH SchedulerRecordingRunningError)[]:
	i: 42(except)
	o: 82(t), 148(f)

nname: 46
n 46(None)[_wyrecord.scheduler.DeleteRecording(self.scheduled_record.id)
]:
	i: 42(try)
	o: 150()

nname: 42
n 42(None)[]:
	i: 0(f)
	o: 46(try), 72(except)

nname: 16
n 16(None)[_wyrecord.scheduler.RemovePeriodicRecording(rule_id, delete_records=False)
]:
	i: 0(t)
	o: 150()

nname: 0
n 0(rule_id)[kbd.hide()
]:
	i: 
	o: 16(t), 42(f)

nname: 150
n 150(None)[self.scheduled_record = None
return None
]:
	i: 16(), 72()
	o: 

nname: 72
n 72(None)[except SchedulerRecordingRunningError:
	error_title = _('Impossible to cancel recording')
	message = _('This recording has already started.')
	MessageWindow(message, error_title, button=None).show(timeout=5)
	return None
]:
	i: 42()
	o: 150()

nname: 42
n 42(None)[try:
	_wyrecord.scheduler.DeleteRecording(self.scheduled_record.id)
]:
	i: 0(f)
	o: 72()

nname: 16
n 16(None)[_wyrecord.scheduler.RemovePeriodicRecording(rule_id, delete_records=False)
]:
	i: 0(t)
	o: 150()

nname: 0
n 0(rule_id)[kbd.hide()
]:
	i: 
	o: 16(t), 42(f)

nname: 150
n 150(None)[self.scheduled_record = None
return None
]:
	i: 16(), 42()
	o: 

nname: 42
n 42(None)[try:
	_wyrecord.scheduler.DeleteRecording(self.scheduled_record.id)
except SchedulerRecordingRunningError:
	error_title = _('Impossible to cancel recording')
	message = _('This recording has already started.')
	MessageWindow(message, error_title, button=None).show(timeout=5)
	return None
]:
	i: 0(f)
	o: 150()

nname: 16
n 16(None)[_wyrecord.scheduler.RemovePeriodicRecording(rule_id, delete_records=False)
]:
	i: 0(t)
	o: 150()

nname: 0
n 0(rule_id)[kbd.hide()
]:
	i: 
	o: 16(t), 42(f)

nname: 0
n 0(None)[kbd.hide()
if rule_id:
	_wyrecord.scheduler.RemovePeriodicRecording(rule_id, delete_records=False)
else:
	try:
		_wyrecord.scheduler.DeleteRecording(self.scheduled_record.id)
	except SchedulerRecordingRunningError:
		error_title = _('Impossible to cancel recording')
		message = _('This recording has already started.')
		MessageWindow(message, error_title, button=None).show(timeout=5)
		return None
self.scheduled_record = None
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75d9a4c>}
nname: 879
n 879(None)[kbd = KeyboardWindow(title=_('Scheduled recording name'), text=rec_name, confirm_action=self._rename_record)
def kbd_hide():
	kbd.hide()
	if rule_id:
		_wyrecord.scheduler.RemovePeriodicRecording(rule_id, delete_records=False)
	else:
		try:
			_wyrecord.scheduler.DeleteRecording(self.scheduled_record.id)
		except SchedulerRecordingRunningError:
			error_title = _('Impossible to cancel recording')
			message = _('This recording has already started.')
			MessageWindow(message, error_title, button=None).show(timeout=5)
			return None
	self.scheduled_record = None
	return None

kbd.action_buttons[4].connect(kbd_hide)
kbd.show()
return None
]:
	i: 474(), 488(), 649(), 799(), 877(AE)
	o: 

nname: 877
n 877(None)[]:
	i: 788(f)
	o: 879(AE)

nname: 799
n 799(None)[#, e
log.error("Can't start recording due to %s", e)
message = 'Unable to schedule your recording. Sorry.'
error_title = _('Recording scheduler error')
MessageWindow(message, error_title, button=None).show(timeout=5)
return None
]:
	i: 788(t)
	o: 879()

nname: 788
n 788(<dummy_ex3> EXC_MATCH SchedulerError)[]:
	i: 638(f)
	o: 799(t), 877(f)

nname: 649
n 649(None)[#, e
conflicting_rec = e.conflict.getAllRecInConflict()[0]
message_pattern = _('The recording you are attempting to schedule conflicts with "%(name)s", starting at %(start_time)s on %(channel)s.')
message = message_pattern % {'name': conflicting_rec.name, 'start_time': seconds_to_hhmm(conflicting_rec.start_time), 'channel': conflicting_rec.service_name}
error_title = _('Recording scheduler error')
MessageWindow(message, error_title, button=None).show(timeout=5)
return None
]:
	i: 638(t)
	o: 879()

nname: 638
n 638(<dummy_ex3> EXC_MATCH SchedulerConflictError)[]:
	i: 478(f)
	o: 649(t), 788(f)

nname: 488
n 488(None)[#, e
conflicting_rec = e.conflict.getAllRecInConflict()[0]
message_pattern = _('An instant recording on %(channel)s will be stopped when this recording starts.')
message = message_pattern % {'name': conflicting_rec.name, 'start_time': seconds_to_hhmm(conflicting_rec.start_time), 'channel': conflicting_rec.service_name}
title = _('Conflict with an instant recording')
MessageWindow(message, title, button=None).show(timeout=5)
self.scheduled_record = e.conflict.rec
]:
	i: 478(t)
	o: 879()

nname: 478
n 478(<dummy_ex3> EXC_MATCH SchedulerConflictWithInstantRecordError)[]:
	i: 243(except)
	o: 488(t), 638(f)

nname: 474
n 474(None)[]:
	i: 375(), 473()
	o: 879()

nname: 473
n 473(None)[]:
	i: 246&362(f)
	o: 474()

nname: 375
n 375(None)[rule_id = _wyrecord.scheduler.createPeriodicityRule(periodicity_type.key)
end_date = datetime.fromtimestamp(start_time) + timedelta(days=periodicity_type.val[1] * periodicity_number - 1)
res = _wyrecord.scheduler.GeneratePeriodicRecording(self.scheduled_record.id, rule_id, end_date)
]:
	i: 246&362(t)
	o: 474()

nname: 246&362
n 246&362(periodicity_type.key != 'none' and periodicity_number > 1)[self.scheduled_record = _wyrecord.scheduler.ScheduleRecording(int(self.channel_list.selected['serviceId']), int(start_time), int(stop_time), rec_name, favorite=self['favorite_name'])
periodicity_type = self.repetition_type_list.selected
periodicity_number = self.repetition_number_list.selected.val
rule_id = None
]:
	i: 243(try)
	o: 375(t), 473(f)

nname: 243
n 243(None)[]:
	i: 226(), 242()
	o: 246&362(try), 478(except)

nname: 242
n 242(None)[]:
	i: 0(f)
	o: 243()

nname: 226
n 226(None)[self._record_to_remove = None
return None
]:
	i: 60(), 118(JA), 157(JA), 221(), 224(AE)
	o: 243()

nname: 224
n 224(None)[]:
	i: 101(f)
	o: 226(AE)

nname: 221
n 221(None)[]:
	i: 219(AE)
	o: 226()

nname: 219
n 219(None)[]:
	i: 147(f)
	o: 221(AE)

nname: 157
n 157(None)[error_title = _('Impossible to cancel recording')
message = _('This recording has already started.')
MessageWindow(message, error_title, button=None).show(timeout=5)
]:
	i: 147(t)
	o: 226(JA)

nname: 147
n 147(<dummy_ex3> EXC_MATCH SchedulerRecordingRunningError)[]:
	i: 111(except)
	o: 157(t), 219(f)

nname: 118
n 118(None)[_wyrecord.scheduler.DeleteRecording(self._record_to_remove.record.id)
]:
	i: 111(try)
	o: 226(JA)

nname: 111
n 111(None)[]:
	i: 101(t)
	o: 118(try), 147(except)

nname: 101
n 101(<dummy_ex3> EXC_MATCH AttributeError)[]:
	i: 37(except)
	o: 111(t), 224(f)

nname: 60
n 60(None)[rule_id = self._record_to_remove.periodic_rule.id
_wyrecord.scheduler.RemovePeriodicRecording(rule_id, delete_records=False)
]:
	i: 37(try)
	o: 226()

nname: 37
n 37(None)[log.info('Deleting scheduled recording [%s] for replacement', self._record_to_remove)
]:
	i: 0(t)
	o: 60(try), 101(except)

nname: 0
n 0(self._record_to_remove)[_wyrecord = WyRecord()
start_time, stop_time = self.start_time, self.end_time
]:
	i: 
	o: 37(t), 242(f)

nname: 879
n 879(None)[kbd = KeyboardWindow(title=_('Scheduled recording name'), text=rec_name, confirm_action=self._rename_record)
def kbd_hide():
	kbd.hide()
	if rule_id:
		_wyrecord.scheduler.RemovePeriodicRecording(rule_id, delete_records=False)
	else:
		try:
			_wyrecord.scheduler.DeleteRecording(self.scheduled_record.id)
		except SchedulerRecordingRunningError:
			error_title = _('Impossible to cancel recording')
			message = _('This recording has already started.')
			MessageWindow(message, error_title, button=None).show(timeout=5)
			return None
	self.scheduled_record = None
	return None

kbd.action_buttons[4].connect(kbd_hide)
kbd.show()
return None
]:
	i: 478(), 243()
	o: 

nname: 478
n 478(None)[except SchedulerConflictWithInstantRecordError, e:
	conflicting_rec = e.conflict.getAllRecInConflict()[0]
	message_pattern = _('An instant recording on %(channel)s will be stopped when this recording starts.')
	message = message_pattern % {'name': conflicting_rec.name, 'start_time': seconds_to_hhmm(conflicting_rec.start_time), 'channel': conflicting_rec.service_name}
	title = _('Conflict with an instant recording')
	MessageWindow(message, title, button=None).show(timeout=5)
	self.scheduled_record = e.conflict.rec
except:
	except SchedulerConflictError, e:
		conflicting_rec = e.conflict.getAllRecInConflict()[0]
		message_pattern = _('The recording you are attempting to schedule conflicts with "%(name)s", starting at %(start_time)s on %(channel)s.')
		message = message_pattern % {'name': conflicting_rec.name, 'start_time': seconds_to_hhmm(conflicting_rec.start_time), 'channel': conflicting_rec.service_name}
		error_title = _('Recording scheduler error')
		MessageWindow(message, error_title, button=None).show(timeout=5)
		return None
	except:
		except SchedulerError, e:
			log.error("Can't start recording due to %s", e)
			message = 'Unable to schedule your recording. Sorry.'
			error_title = _('Recording scheduler error')
			MessageWindow(message, error_title, button=None).show(timeout=5)
			return None
]:
	i: 243()
	o: 879()

nname: 879
n 879(None)[kbd = KeyboardWindow(title=_('Scheduled recording name'), text=rec_name, confirm_action=self._rename_record)
def kbd_hide():
	kbd.hide()
	if rule_id:
		_wyrecord.scheduler.RemovePeriodicRecording(rule_id, delete_records=False)
	else:
		try:
			_wyrecord.scheduler.DeleteRecording(self.scheduled_record.id)
		except SchedulerRecordingRunningError:
			error_title = _('Impossible to cancel recording')
			message = _('This recording has already started.')
			MessageWindow(message, error_title, button=None).show(timeout=5)
			return None
	self.scheduled_record = None
	return None

kbd.action_buttons[4].connect(kbd_hide)
kbd.show()
return None
]:
	i: 478(), 243()
	o: 

nname: 243
n 243(None)[try:
	self.scheduled_record = _wyrecord.scheduler.ScheduleRecording(int(self.channel_list.selected['serviceId']), int(start_time), int(stop_time), rec_name, favorite=self['favorite_name'])
	periodicity_type = self.repetition_type_list.selected
	periodicity_number = self.repetition_number_list.selected.val
	rule_id = None
	if periodicity_type.key != 'none' and periodicity_number > 1:
		rule_id = _wyrecord.scheduler.createPeriodicityRule(periodicity_type.key)
		end_date = datetime.fromtimestamp(start_time) + timedelta(days=periodicity_type.val[1] * periodicity_number - 1)
		res = _wyrecord.scheduler.GeneratePeriodicRecording(self.scheduled_record.id, rule_id, end_date)
]:
	i: 226(), 0(f)
	o: 879(), 478()

nname: 226
n 226(None)[self._record_to_remove = None
return None
]:
	i: 60(), 118(JA), 157(JA), 224(AE), 147(f), 219(AE)
	o: 243()

nname: 224
n 224(None)[]:
	i: 101(f)
	o: 226(AE)

nname: 157
n 157(None)[error_title = _('Impossible to cancel recording')
message = _('This recording has already started.')
MessageWindow(message, error_title, button=None).show(timeout=5)
]:
	i: 147(t)
	o: 226(JA)

nname: 147
n 147(<dummy_ex3> EXC_MATCH SchedulerRecordingRunningError)[]:
	i: 111(except)
	o: 157(t), 226(f)

nname: 118
n 118(None)[_wyrecord.scheduler.DeleteRecording(self._record_to_remove.record.id)
]:
	i: 111(try)
	o: 226(JA)

nname: 111
n 111(None)[]:
	i: 101(t)
	o: 118(try), 147(except)

nname: 101
n 101(<dummy_ex3> EXC_MATCH AttributeError)[]:
	i: 37(except)
	o: 111(t), 224(f)

nname: 60
n 60(None)[rule_id = self._record_to_remove.periodic_rule.id
_wyrecord.scheduler.RemovePeriodicRecording(rule_id, delete_records=False)
]:
	i: 37(try)
	o: 226()

nname: 37
n 37(None)[log.info('Deleting scheduled recording [%s] for replacement', self._record_to_remove)
]:
	i: 0(t)
	o: 60(try), 101(except)

nname: 0
n 0(self._record_to_remove)[_wyrecord = WyRecord()
start_time, stop_time = self.start_time, self.end_time
]:
	i: 
	o: 37(t), 243(f)

nname: 879
n 879(None)[kbd = KeyboardWindow(title=_('Scheduled recording name'), text=rec_name, confirm_action=self._rename_record)
def kbd_hide():
	kbd.hide()
	if rule_id:
		_wyrecord.scheduler.RemovePeriodicRecording(rule_id, delete_records=False)
	else:
		try:
			_wyrecord.scheduler.DeleteRecording(self.scheduled_record.id)
		except SchedulerRecordingRunningError:
			error_title = _('Impossible to cancel recording')
			message = _('This recording has already started.')
			MessageWindow(message, error_title, button=None).show(timeout=5)
			return None
	self.scheduled_record = None
	return None

kbd.action_buttons[4].connect(kbd_hide)
kbd.show()
return None
]:
	i: 478(), 243()
	o: 

nname: 478
n 478(None)[except SchedulerConflictWithInstantRecordError, e:
	conflicting_rec = e.conflict.getAllRecInConflict()[0]
	message_pattern = _('An instant recording on %(channel)s will be stopped when this recording starts.')
	message = message_pattern % {'name': conflicting_rec.name, 'start_time': seconds_to_hhmm(conflicting_rec.start_time), 'channel': conflicting_rec.service_name}
	title = _('Conflict with an instant recording')
	MessageWindow(message, title, button=None).show(timeout=5)
	self.scheduled_record = e.conflict.rec
except:
	except SchedulerConflictError, e:
		conflicting_rec = e.conflict.getAllRecInConflict()[0]
		message_pattern = _('The recording you are attempting to schedule conflicts with "%(name)s", starting at %(start_time)s on %(channel)s.')
		message = message_pattern % {'name': conflicting_rec.name, 'start_time': seconds_to_hhmm(conflicting_rec.start_time), 'channel': conflicting_rec.service_name}
		error_title = _('Recording scheduler error')
		MessageWindow(message, error_title, button=None).show(timeout=5)
		return None
	except:
		except SchedulerError, e:
			log.error("Can't start recording due to %s", e)
			message = 'Unable to schedule your recording. Sorry.'
			error_title = _('Recording scheduler error')
			MessageWindow(message, error_title, button=None).show(timeout=5)
			return None
]:
	i: 243()
	o: 879()

nname: 879
n 879(None)[kbd = KeyboardWindow(title=_('Scheduled recording name'), text=rec_name, confirm_action=self._rename_record)
def kbd_hide():
	kbd.hide()
	if rule_id:
		_wyrecord.scheduler.RemovePeriodicRecording(rule_id, delete_records=False)
	else:
		try:
			_wyrecord.scheduler.DeleteRecording(self.scheduled_record.id)
		except SchedulerRecordingRunningError:
			error_title = _('Impossible to cancel recording')
			message = _('This recording has already started.')
			MessageWindow(message, error_title, button=None).show(timeout=5)
			return None
	self.scheduled_record = None
	return None

kbd.action_buttons[4].connect(kbd_hide)
kbd.show()
return None
]:
	i: 478(), 243()
	o: 

nname: 243
n 243(None)[try:
	self.scheduled_record = _wyrecord.scheduler.ScheduleRecording(int(self.channel_list.selected['serviceId']), int(start_time), int(stop_time), rec_name, favorite=self['favorite_name'])
	periodicity_type = self.repetition_type_list.selected
	periodicity_number = self.repetition_number_list.selected.val
	rule_id = None
	if periodicity_type.key != 'none' and periodicity_number > 1:
		rule_id = _wyrecord.scheduler.createPeriodicityRule(periodicity_type.key)
		end_date = datetime.fromtimestamp(start_time) + timedelta(days=periodicity_type.val[1] * periodicity_number - 1)
		res = _wyrecord.scheduler.GeneratePeriodicRecording(self.scheduled_record.id, rule_id, end_date)
]:
	i: 226(), 0(f)
	o: 879(), 478()

nname: 226
n 226(None)[self._record_to_remove = None
return None
]:
	i: 60(), 224(AE), 118(f)
	o: 243()

nname: 118
n 118(None)[try:
	_wyrecord.scheduler.DeleteRecording(self._record_to_remove.record.id)
except SchedulerRecordingRunningError:
	error_title = _('Impossible to cancel recording')
	message = _('This recording has already started.')
	MessageWindow(message, error_title, button=None).show(timeout=5)
]:
	i: 101(f), 101(t)
	o: 226(JA)

nname: 101
n 101(<dummy_ex3> EXC_MATCH AttributeError)[]:
	i: 37(except)
	o: 118(f)

nname: 60
n 60(None)[rule_id = self._record_to_remove.periodic_rule.id
_wyrecord.scheduler.RemovePeriodicRecording(rule_id, delete_records=False)
]:
	i: 37(try)
	o: 226()

nname: 37
n 37(None)[log.info('Deleting scheduled recording [%s] for replacement', self._record_to_remove)
]:
	i: 0(t)
	o: 60(try), 101(except)

structureSingleExcept Exception 'NoneType' object has no attribute 'toNode'
nname: 0
n 0(self._record_to_remove)[_wyrecord = WyRecord()
start_time, stop_time = self.start_time, self.end_time
]:
	i: 
	o: 37(t), 243(f)

nname: 879
n 879(None)[kbd = KeyboardWindow(title=_('Scheduled recording name'), text=rec_name, confirm_action=self._rename_record)
def kbd_hide():
	kbd.hide()
	if rule_id:
		_wyrecord.scheduler.RemovePeriodicRecording(rule_id, delete_records=False)
	else:
		try:
			_wyrecord.scheduler.DeleteRecording(self.scheduled_record.id)
		except SchedulerRecordingRunningError:
			error_title = _('Impossible to cancel recording')
			message = _('This recording has already started.')
			MessageWindow(message, error_title, button=None).show(timeout=5)
			return None
	self.scheduled_record = None
	return None

kbd.action_buttons[4].connect(kbd_hide)
kbd.show()
return None
]:
	i: 478(), 243()
	o: 

nname: 478
n 478(None)[except SchedulerConflictWithInstantRecordError, e:
	conflicting_rec = e.conflict.getAllRecInConflict()[0]
	message_pattern = _('An instant recording on %(channel)s will be stopped when this recording starts.')
	message = message_pattern % {'name': conflicting_rec.name, 'start_time': seconds_to_hhmm(conflicting_rec.start_time), 'channel': conflicting_rec.service_name}
	title = _('Conflict with an instant recording')
	MessageWindow(message, title, button=None).show(timeout=5)
	self.scheduled_record = e.conflict.rec
except:
	except SchedulerConflictError, e:
		conflicting_rec = e.conflict.getAllRecInConflict()[0]
		message_pattern = _('The recording you are attempting to schedule conflicts with "%(name)s", starting at %(start_time)s on %(channel)s.')
		message = message_pattern % {'name': conflicting_rec.name, 'start_time': seconds_to_hhmm(conflicting_rec.start_time), 'channel': conflicting_rec.service_name}
		error_title = _('Recording scheduler error')
		MessageWindow(message, error_title, button=None).show(timeout=5)
		return None
	except:
		except SchedulerError, e:
			log.error("Can't start recording due to %s", e)
			message = 'Unable to schedule your recording. Sorry.'
			error_title = _('Recording scheduler error')
			MessageWindow(message, error_title, button=None).show(timeout=5)
			return None
]:
	i: 243()
	o: 879()

nname: 879
n 879(None)[kbd = KeyboardWindow(title=_('Scheduled recording name'), text=rec_name, confirm_action=self._rename_record)
def kbd_hide():
	kbd.hide()
	if rule_id:
		_wyrecord.scheduler.RemovePeriodicRecording(rule_id, delete_records=False)
	else:
		try:
			_wyrecord.scheduler.DeleteRecording(self.scheduled_record.id)
		except SchedulerRecordingRunningError:
			error_title = _('Impossible to cancel recording')
			message = _('This recording has already started.')
			MessageWindow(message, error_title, button=None).show(timeout=5)
			return None
	self.scheduled_record = None
	return None

kbd.action_buttons[4].connect(kbd_hide)
kbd.show()
return None
]:
	i: 478(), 243()
	o: 

nname: 243
n 243(None)[try:
	self.scheduled_record = _wyrecord.scheduler.ScheduleRecording(int(self.channel_list.selected['serviceId']), int(start_time), int(stop_time), rec_name, favorite=self['favorite_name'])
	periodicity_type = self.repetition_type_list.selected
	periodicity_number = self.repetition_number_list.selected.val
	rule_id = None
	if periodicity_type.key != 'none' and periodicity_number > 1:
		rule_id = _wyrecord.scheduler.createPeriodicityRule(periodicity_type.key)
		end_date = datetime.fromtimestamp(start_time) + timedelta(days=periodicity_type.val[1] * periodicity_number - 1)
		res = _wyrecord.scheduler.GeneratePeriodicRecording(self.scheduled_record.id, rule_id, end_date)
]:
	i: 226(), 0(f)
	o: 879(), 478()

nname: 226
n 226(None)[self._record_to_remove = None
return None
]:
	i: 60(), 224(AE), 118(f)
	o: 243()

nname: 118
n 118(None)[try:
	_wyrecord.scheduler.DeleteRecording(self._record_to_remove.record.id)
except SchedulerRecordingRunningError:
	error_title = _('Impossible to cancel recording')
	message = _('This recording has already started.')
	MessageWindow(message, error_title, button=None).show(timeout=5)
]:
	i: 101(t), 37(except)
	o: 226(JA)

nname: 60
n 60(None)[rule_id = self._record_to_remove.periodic_rule.id
_wyrecord.scheduler.RemovePeriodicRecording(rule_id, delete_records=False)
]:
	i: 37(try)
	o: 226()

nname: 37
n 37(None)[log.info('Deleting scheduled recording [%s] for replacement', self._record_to_remove)
]:
	i: 0(t)
	o: 60(try), 118(except)

nname: 0
n 0(self._record_to_remove)[_wyrecord = WyRecord()
start_time, stop_time = self.start_time, self.end_time
]:
	i: 
	o: 37(t), 243(f)

nname: 879
n 879(None)[kbd = KeyboardWindow(title=_('Scheduled recording name'), text=rec_name, confirm_action=self._rename_record)
def kbd_hide():
	kbd.hide()
	if rule_id:
		_wyrecord.scheduler.RemovePeriodicRecording(rule_id, delete_records=False)
	else:
		try:
			_wyrecord.scheduler.DeleteRecording(self.scheduled_record.id)
		except SchedulerRecordingRunningError:
			error_title = _('Impossible to cancel recording')
			message = _('This recording has already started.')
			MessageWindow(message, error_title, button=None).show(timeout=5)
			return None
	self.scheduled_record = None
	return None

kbd.action_buttons[4].connect(kbd_hide)
kbd.show()
return None
]:
	i: 478(), 243()
	o: 

nname: 478
n 478(None)[except SchedulerConflictWithInstantRecordError, e:
	conflicting_rec = e.conflict.getAllRecInConflict()[0]
	message_pattern = _('An instant recording on %(channel)s will be stopped when this recording starts.')
	message = message_pattern % {'name': conflicting_rec.name, 'start_time': seconds_to_hhmm(conflicting_rec.start_time), 'channel': conflicting_rec.service_name}
	title = _('Conflict with an instant recording')
	MessageWindow(message, title, button=None).show(timeout=5)
	self.scheduled_record = e.conflict.rec
except:
	except SchedulerConflictError, e:
		conflicting_rec = e.conflict.getAllRecInConflict()[0]
		message_pattern = _('The recording you are attempting to schedule conflicts with "%(name)s", starting at %(start_time)s on %(channel)s.')
		message = message_pattern % {'name': conflicting_rec.name, 'start_time': seconds_to_hhmm(conflicting_rec.start_time), 'channel': conflicting_rec.service_name}
		error_title = _('Recording scheduler error')
		MessageWindow(message, error_title, button=None).show(timeout=5)
		return None
	except:
		except SchedulerError, e:
			log.error("Can't start recording due to %s", e)
			message = 'Unable to schedule your recording. Sorry.'
			error_title = _('Recording scheduler error')
			MessageWindow(message, error_title, button=None).show(timeout=5)
			return None
]:
	i: 243()
	o: 879()

nname: 879
n 879(None)[kbd = KeyboardWindow(title=_('Scheduled recording name'), text=rec_name, confirm_action=self._rename_record)
def kbd_hide():
	kbd.hide()
	if rule_id:
		_wyrecord.scheduler.RemovePeriodicRecording(rule_id, delete_records=False)
	else:
		try:
			_wyrecord.scheduler.DeleteRecording(self.scheduled_record.id)
		except SchedulerRecordingRunningError:
			error_title = _('Impossible to cancel recording')
			message = _('This recording has already started.')
			MessageWindow(message, error_title, button=None).show(timeout=5)
			return None
	self.scheduled_record = None
	return None

kbd.action_buttons[4].connect(kbd_hide)
kbd.show()
return None
]:
	i: 478(), 243()
	o: 

nname: 243
n 243(None)[try:
	self.scheduled_record = _wyrecord.scheduler.ScheduleRecording(int(self.channel_list.selected['serviceId']), int(start_time), int(stop_time), rec_name, favorite=self['favorite_name'])
	periodicity_type = self.repetition_type_list.selected
	periodicity_number = self.repetition_number_list.selected.val
	rule_id = None
	if periodicity_type.key != 'none' and periodicity_number > 1:
		rule_id = _wyrecord.scheduler.createPeriodicityRule(periodicity_type.key)
		end_date = datetime.fromtimestamp(start_time) + timedelta(days=periodicity_type.val[1] * periodicity_number - 1)
		res = _wyrecord.scheduler.GeneratePeriodicRecording(self.scheduled_record.id, rule_id, end_date)
]:
	i: 118(), 0(f)
	o: 879(), 478()

nname: 118
n 118(None)[except:
	try:
		_wyrecord.scheduler.DeleteRecording(self._record_to_remove.record.id)
	except SchedulerRecordingRunningError:
		error_title = _('Impossible to cancel recording')
		message = _('This recording has already started.')
		MessageWindow(message, error_title, button=None).show(timeout=5)
self._record_to_remove = None
return None
]:
	i: 101(t), 37()
	o: 243()

nname: 37
n 37(None)[log.info('Deleting scheduled recording [%s] for replacement', self._record_to_remove)
try:
	rule_id = self._record_to_remove.periodic_rule.id
	_wyrecord.scheduler.RemovePeriodicRecording(rule_id, delete_records=False)
]:
	i: 0(t)
	o: 118()

nname: 0
n 0(self._record_to_remove)[_wyrecord = WyRecord()
start_time, stop_time = self.start_time, self.end_time
]:
	i: 
	o: 37(t), 243(f)

self.nodes: {0: <unpyclib.structure.node instance at 0xb75d518c>, 879: <unpyclib.structure.node instance at 0xb75d57ec>, 37: <unpyclib.structure.node instance at 0xb75ca66c>, 118: <unpyclib.structure.node instance at 0xb75ca90c>, 478: <unpyclib.structure.node instance at 0xb75d916c>, 243: <unpyclib.structure.node instance at 0xb75d90cc>}
nname: 0
n 0(None)[WyRecord().scheduler.UpdateRecordingName(self.scheduled_record.id, kbd.text)
kbd.hide()
pygui_globs['menustack'].back_one_menu()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75b54cc>}
nname: 311
n 311(None)[self._schedule_record(scheduled_name)
loader.hide()
]:
	i: 197(), 213()
	o: 

nname: 213
n 213(None)[values = {'channel': self.channel_list.selected.name, 'date': strftime('%Y/%m/%d', localtime(self.start_time)), 'start_time': seconds_to_hhmm(self.start_time), 'end_time': seconds_to_hhmm(self.end_time)}
scheduled_name = name_pattern % values
]:
	i: 169&178(f)
	o: 311()

nname: 197
n 197(None)[scheduled_name = self._record_to_remove.name
]:
	i: 169&178(t)
	o: 311()

nname: 169&178
n 169&178(self._record_to_remove and computed_old_name != self._record_to_remove.name)[]:
	i: 61(), 168()
	o: 197(t), 213(f)

nname: 168
n 168(None)[]:
	i: 21(f)
	o: 169&178()

nname: 61
n 61(None)[old_rec = self._record_to_remove.record
old_values = {'channel': old_rec.service_name, 'date': strftime('%Y/%m/%d', localtime(old_rec.start_time)), 'start_time': seconds_to_hhmm(old_rec.start_time), 'end_time': seconds_to_hhmm(old_rec.stop_time)}
computed_old_name = name_pattern % old_values
]:
	i: 21(t)
	o: 169&178()

nname: 21
n 21(self._record_to_remove)[loader = LoadingWindow()
loader.show()
name_pattern = _('%(date)s %(channel)s %(start_time)s - %(end_time)s')
]:
	i: 12(), 20()
	o: 61(t), 168(f)

nname: 20
n 20(None)[]:
	i: 0(t)
	o: 21()

nname: 12
n 12(None)[]:
	i: 0(f)
	o: 21()

nname: 0
n 0(self._validate())[]:
	i: 
	o: 12(f), 20(t)

nname: 169&178
n 169&178(None)[if self._record_to_remove and computed_old_name != self._record_to_remove.name:
	scheduled_name = self._record_to_remove.name
else:
	values = {'channel': self.channel_list.selected.name, 'date': strftime('%Y/%m/%d', localtime(self.start_time)), 'start_time': seconds_to_hhmm(self.start_time), 'end_time': seconds_to_hhmm(self.end_time)}
	scheduled_name = name_pattern % values
self._schedule_record(scheduled_name)
loader.hide()
]:
	i: 0()
	o: 

nname: 0
n 0(None)[if not self._validate():
	pass
loader = LoadingWindow()
loader.show()
name_pattern = _('%(date)s %(channel)s %(start_time)s - %(end_time)s')
if self._record_to_remove:
	old_rec = self._record_to_remove.record
	old_values = {'channel': old_rec.service_name, 'date': strftime('%Y/%m/%d', localtime(old_rec.start_time)), 'start_time': seconds_to_hhmm(old_rec.start_time), 'end_time': seconds_to_hhmm(old_rec.stop_time)}
	computed_old_name = name_pattern % old_values
]:
	i: 
	o: 169&178()

nname: 0
n 0(None)[if not self._validate():
	pass
loader = LoadingWindow()
loader.show()
name_pattern = _('%(date)s %(channel)s %(start_time)s - %(end_time)s')
if self._record_to_remove:
	old_rec = self._record_to_remove.record
	old_values = {'channel': old_rec.service_name, 'date': strftime('%Y/%m/%d', localtime(old_rec.start_time)), 'start_time': seconds_to_hhmm(old_rec.start_time), 'end_time': seconds_to_hhmm(old_rec.stop_time)}
	computed_old_name = name_pattern % old_values
if self._record_to_remove and computed_old_name != self._record_to_remove.name:
	scheduled_name = self._record_to_remove.name
else:
	values = {'channel': self.channel_list.selected.name, 'date': strftime('%Y/%m/%d', localtime(self.start_time)), 'start_time': seconds_to_hhmm(self.start_time), 'end_time': seconds_to_hhmm(self.end_time)}
	scheduled_name = name_pattern % values
self._schedule_record(scheduled_name)
loader.hide()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb758222c>}
nname: 0
n 0(None)[pygui_globs['menustack'].back_one_menu()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75b58ec>}
nname: 345
n 345(None)[]:
	i: 304(JA), 324(), 344()
	o: 

nname: 344
n 344(None)[]:
	i: 276(f)
	o: 345()

nname: 324
n 324(None)[louie_send('frequency_only_this_time_off', sender=self)
]:
	i: 291(f)
	o: 345()

nname: 304
n 304(None)[louie_send('frequency_only_this_time_on', sender=self)
]:
	i: 291(t)
	o: 345(JA)

nname: 291
n 291(self.is_only_this_time())[]:
	i: 276(t)
	o: 304(t), 324(f)

nname: 276
n 276(_list.list_name == 'repetition_type_list')[]:
	i: 185(JA), 218(JA), 272(), 275()
	o: 291(t), 344(f)

nname: 275
n 275(None)[]:
	i: 133(f)
	o: 276()

nname: 272
n 272(None)[]:
	i: 270(AE)
	o: 276()

nname: 270
n 270(None)[]:
	i: 208(f)
	o: 272(AE)

nname: 218
n 218(None)[self.channel_list.set_items(items, 0)
louie_send('channel_name', sender=self, value=self['channel_name'])
]:
	i: 208(t)
	o: 276(JA)

nname: 208
n 208(<dummy_ex3> EXC_MATCH ValueError)[]:
	i: 154(except)
	o: 218(t), 270(f)

nname: 185
n 185(None)[self.channel_list.set_items(items, current_channel)
]:
	i: 154(try)
	o: 276(JA)

nname: 154
n 154(None)[items = _list.selected.browse()
current_channel = self.channel_list.selected
]:
	i: 133(t)
	o: 185(try), 208(except)

nname: 133
n 133(_list.name == _('Favorites'))[]:
	i: 118(), 132()
	o: 154(t), 275(f)

nname: 132
n 132(None)[]:
	i: 85(f)
	o: 133()

nname: 118
n 118(None)[self.update_day_list()
]:
	i: 85(t)
	o: 133()

nname: 85
n 85(_list.name in [_('Month'), _('Year')])[]:
	i: 54(), 84()
	o: 118(t), 132(f)

nname: 84
n 84(None)[]:
	i: 0(f)
	o: 85()

nname: 54
n 54(None)[louie_send('date_weekday', sender=self, value=self['date_weekday'])
]:
	i: 0(t)
	o: 85()

nname: 0
n 0(_list.list_name in ('date_1_list', 'date_2_list', 'date_3_list'))[up_str = _list.list_name[:-5]
louie_send(up_str, sender=self, value=self[up_str])
]:
	i: 
	o: 54(t), 84(f)

nname: 276
n 276(None)[if _list.list_name == 'repetition_type_list':
	if self.is_only_this_time():
		louie_send('frequency_only_this_time_on', sender=self)
	else:
		louie_send('frequency_only_this_time_off', sender=self)
]:
	i: 185(JA), 218(JA), 208(f), 270(AE), 133(f)
	o: 

nname: 218
n 218(None)[self.channel_list.set_items(items, 0)
louie_send('channel_name', sender=self, value=self['channel_name'])
]:
	i: 208(t)
	o: 276(JA)

nname: 208
n 208(<dummy_ex3> EXC_MATCH ValueError)[]:
	i: 154(except)
	o: 218(t), 276(f)

nname: 185
n 185(None)[self.channel_list.set_items(items, current_channel)
]:
	i: 154(try)
	o: 276(JA)

nname: 154
n 154(None)[items = _list.selected.browse()
current_channel = self.channel_list.selected
]:
	i: 133(t)
	o: 185(try), 208(except)

nname: 133
n 133(_list.name == _('Favorites'))[]:
	i: 0()
	o: 154(t), 276(f)

nname: 0
n 0(None)[up_str = _list.list_name[:-5]
louie_send(up_str, sender=self, value=self[up_str])
if _list.list_name in ('date_1_list', 'date_2_list', 'date_3_list'):
	louie_send('date_weekday', sender=self, value=self['date_weekday'])
if _list.name in [_('Month'), _('Year')]:
	self.update_day_list()
]:
	i: 
	o: 133()

nname: 276
n 276(None)[if _list.list_name == 'repetition_type_list':
	if self.is_only_this_time():
		louie_send('frequency_only_this_time_on', sender=self)
	else:
		louie_send('frequency_only_this_time_off', sender=self)
]:
	i: 208(f), 0(f)
	o: 

nname: 208
n 208(None)[except ValueError:
	self.channel_list.set_items(items, 0)
	louie_send('channel_name', sender=self, value=self['channel_name'])
]:
	i: 154()
	o: 276(JA)

nname: 154
n 154(None)[items = _list.selected.browse()
current_channel = self.channel_list.selected
try:
	self.channel_list.set_items(items, current_channel)
]:
	i: 0(t)
	o: 208()

nname: 0
n 0(_list.name == _('Favorites'))[up_str = _list.list_name[:-5]
louie_send(up_str, sender=self, value=self[up_str])
if _list.list_name in ('date_1_list', 'date_2_list', 'date_3_list'):
	louie_send('date_weekday', sender=self, value=self['date_weekday'])
if _list.name in [_('Month'), _('Year')]:
	self.update_day_list()
]:
	i: 
	o: 154(t), 276(f)

nname: 276
n 276(None)[if _list.list_name == 'repetition_type_list':
	if self.is_only_this_time():
		louie_send('frequency_only_this_time_on', sender=self)
	else:
		louie_send('frequency_only_this_time_off', sender=self)
]:
	i: 154(f), 0(f)
	o: 

nname: 154
n 154(None)[items = _list.selected.browse()
current_channel = self.channel_list.selected
try:
	self.channel_list.set_items(items, current_channel)
except ValueError:
	self.channel_list.set_items(items, 0)
	louie_send('channel_name', sender=self, value=self['channel_name'])
]:
	i: 0(t)
	o: 276(JA)

nname: 0
n 0(_list.name == _('Favorites'))[up_str = _list.list_name[:-5]
louie_send(up_str, sender=self, value=self[up_str])
if _list.list_name in ('date_1_list', 'date_2_list', 'date_3_list'):
	louie_send('date_weekday', sender=self, value=self['date_weekday'])
if _list.name in [_('Month'), _('Year')]:
	self.update_day_list()
]:
	i: 
	o: 154(t), 276(f)

nname: 0
n 0(None)[up_str = _list.list_name[:-5]
louie_send(up_str, sender=self, value=self[up_str])
if _list.list_name in ('date_1_list', 'date_2_list', 'date_3_list'):
	louie_send('date_weekday', sender=self, value=self['date_weekday'])
if _list.name in [_('Month'), _('Year')]:
	self.update_day_list()
if _list.name == _('Favorites'):
	items = _list.selected.browse()
	current_channel = self.channel_list.selected
	try:
		self.channel_list.set_items(items, current_channel)
	except ValueError:
		self.channel_list.set_items(items, 0)
		louie_send('channel_name', sender=self, value=self['channel_name'])
if _list.list_name == 'repetition_type_list':
	if self.is_only_this_time():
		louie_send('frequency_only_this_time_on', sender=self)
	else:
		louie_send('frequency_only_this_time_off', sender=self)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75cafec>}
nname: 6
n 6(None)[def __init__(self, name=_('Scheduled recordings'), type_='scheduled_records'):
	Menu.__init__(self, name, type=type_, universe='tv')
	self.PERIODICITY = {'none': (_('Only this time'), 0), 'daily': (_('Every day'), 1), 'weekly': (_('Every week'), 7)}
	self._favorite_list = [TVRootItem().get_acl(menu=self)]
	self._favorite_list.extend(TVRootItem().browse_favorites(self))
	self._all_channel_list = self._favorite_list[0]
	self.eventhandler = ModifyScheduledRecordMenuEventHandler(self)
	self.channel_list = ItemListItem(_('Channels'), menu=self, _list=self._favorite_list, list_name='channel_name_list')
	self.favorite_list = ItemListItem(_('Favorites'), menu=self, _list=self._all_channel_list.browse(), list_name='favorite_name_list')
	self.service_list = ItemListItem(_('Channel'), menu=self, _list=[self.channel_list, self.favorite_list], list_name='service_list')
	self.item_lists_dict['service_list'] = self.service_list
	_today = date.today()

def show(self, *args, **args):
	Menu.show(self, *args, **kw)
	if self.is_only_this_time():
		louie_send('frequency_only_this_time_on', sender=self)
	else:
		louie_send('frequency_only_this_time_off', sender=self)

def is_only_this_time(self):
	return self.get_item_list('repetition_list')[0].selected_pos == 0

def _get_weekday_from_date(self):
	date_list = self.date_list
	return day_dict[date(int(date_list[self.year_index].selected.name), int(date_list[self.month_index].selected.name), int(date_list[self.day_index].selected.name)).weekday()]

def update_day_list(self):
	d_list = self.date_list[self.day_index]
	d = days_in_month(self.date_list[self.year_index].selected.val, self.date_list[self.month_index].selected.val)

def select_date(self, _date, stop=None):
	struct_t = localtime(_date)
	self.date_list[self.year_index].select(IntegerItem(struct_t[0]))
	self.date_list[self.month_index].select(IntegerItem(struct_t[1]))
	self.date_list[self.day_index].select(IntegerItem(struct_t[2]))
	louie_send('date_weekday', sender=self, value=self['date_weekday'])
	self.start_hour_list.select(IntegerItem(struct_t[3]))
	self.start_minute_list.select(IntegerItem(struct_t[4]))
	if stop:
		struct_t = localtime(stop)
		self.stop_hour_list.select(IntegerItem(struct_t[3]))
		self.stop_minute_list.select(IntegerItem(struct_t[4]))

def select_channel(self, chan_info, current_favorite=None):
	favorite_list = [TVRootItem().get_acl(menu=self)]
	favorite_list.extend(TVRootItem().browse_favorites(self))
	self.favorite_list.set_items(favorite_list)
	if current_favorite is None:
		self.favorite_list.select(0, force_pos=True)
	else:
		self.favorite_list.select(current_favorite)
	chans = self.favorite_list.selected.browse()
	self.channel_list.set_items(chans)
	self.channel_list.select(chan_info)
	return None

def _set_record(self, scheduled_record):
	self._record_to_remove = scheduled_record
	_wyrecord = WyRecord()
	self.record_name = scheduled_record.name
	self.select_date(scheduled_record.record.start_time, scheduled_record.record.stop_time)
	target_channel = TVRootItem().get_acl(self).get_channel_from_service_id(str(scheduled_record.record.service_id))
	for i in xrange(len(self.favorite_list)):
		if self.favorite_list[i]['serviceId'] == str(scheduled_record.record.service_id):
			target_channel, target_channel = None, self.favorite_list[i]
			break
			continue
	self.select_channel(target_channel)
	if isinstance(scheduled_record, PeriodicScheduledRecordItem):
		_rule = _wyrecord.scheduler.GetPeriodicRuleById(scheduled_record.record.periodicity_rule_id)
		self.repetition_type_list.select(Item(self.PERIODICITY[_rule.extern_rule_name][0], 'periodic', self))
		_num = (mktime(_rule.last_time.timetuple()) - _rule.recording_ref.start_time) / float(self.PERIODICITY[_rule.extern_rule_name][1] * 86400)
		self.repetition_number_list.select(IntegerItem(int(_num)))
	return None

def _validate(self):
	all_fields = set(['date', 'start_time', 'end_date', 'end_time'])
	invalid_fields = set()
	error_message = None
	now = time()
	start_time, end_time = self.start_time, self.end_time
	if abs(end_time - start_time) > 21600:
		error_message = _('The recording cannot be longer than 6 hours.')
	if end_time < now:
		error_message = _('You are trying to record a program already over.')
		invalid_fields.add('end_time')
		if now - end_time >= 86400:
			invalid_fields.add('date')
	for field in all_fields.difference(invalid_fields):
		louie_send('%s_valid' % field, sender=self)
	if error_message is not None:
		for field in invalid_fields:
			louie_send('%s_invalid' % field, sender=self)
		error_title = _('Invalid data')
		MessageWindow(error_message, error_title, button=None).show(timeout=5)
		return False
	return True

def _schedule_record(self, rec_name):
	_wyrecord = WyRecord()
	start_time, stop_time = self.start_time, self.end_time

def _rename_record(self, kbd):
	WyRecord().scheduler.UpdateRecordingName(self.scheduled_record.id, kbd.text)
	kbd.hide()
	pygui_globs['menustack'].back_one_menu()

def _confirm(self):
	if not self._validate():
		pass
	loader = LoadingWindow()
	loader.show()
	name_pattern = _('%(date)s %(channel)s %(start_time)s - %(end_time)s')
	if self._record_to_remove:
		old_rec = self._record_to_remove.record
		old_values = {'channel': old_rec.service_name, 'date': strftime('%Y/%m/%d', localtime(old_rec.start_time)), 'start_time': seconds_to_hhmm(old_rec.start_time), 'end_time': seconds_to_hhmm(old_rec.stop_time)}
		computed_old_name = name_pattern % old_values
	if self._record_to_remove and computed_old_name != self._record_to_remove.name:
		scheduled_name = self._record_to_remove.name
	else:
		values = {'channel': self.channel_list.selected.name, 'date': strftime('%Y/%m/%d', localtime(self.start_time)), 'start_time': seconds_to_hhmm(self.start_time), 'end_time': seconds_to_hhmm(self.end_time)}
		scheduled_name = name_pattern % values
	self._schedule_record(scheduled_name)
	loader.hide()

def cancel(self):
	pygui_globs['menustack'].back_one_menu()

def update(self, _list):
	up_str = _list.list_name[:-5]
	louie_send(up_str, sender=self, value=self[up_str])
	if _list.list_name in ('date_1_list', 'date_2_list', 'date_3_list'):
		louie_send('date_weekday', sender=self, value=self['date_weekday'])
	if _list.name in [_('Month'), _('Year')]:
		self.update_day_list()
	if _list.name == _('Favorites'):
		items = _list.selected.browse()
		current_channel = self.channel_list.selected
		try:
			self.channel_list.set_items(items, current_channel)
		except ValueError:
			self.channel_list.set_items(items, 0)
			louie_send('channel_name', sender=self, value=self['channel_name'])
	if _list.list_name == 'repetition_type_list':
		if self.is_only_this_time():
			louie_send('frequency_only_this_time_on', sender=self)
		else:
			louie_send('frequency_only_this_time_off', sender=self)

start_time = property()
end_time = property()
]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75aab4c>}
nname: 607
n 607(None)[del _[3]
for MONTHS in xrange(1, 13):
class ScheduledRecordMenu(Menu):
	def __init__(self, name=_('Scheduled recordings'), type_='scheduled_records'):
		Menu.__init__(self, name, type=type_, universe='tv')
		self.PERIODICITY = {'none': (_('Only this time'), 0), 'daily': (_('Every day'), 1), 'weekly': (_('Every week'), 7)}
		self._favorite_list = [TVRootItem().get_acl(menu=self)]
		self._favorite_list.extend(TVRootItem().browse_favorites(self))
		self._all_channel_list = self._favorite_list[0]
		self.eventhandler = ModifyScheduledRecordMenuEventHandler(self)
		self.channel_list = ItemListItem(_('Channels'), menu=self, _list=self._favorite_list, list_name='channel_name_list')
		self.favorite_list = ItemListItem(_('Favorites'), menu=self, _list=self._all_channel_list.browse(), list_name='favorite_name_list')
		self.service_list = ItemListItem(_('Channel'), menu=self, _list=[self.channel_list, self.favorite_list], list_name='service_list')
		self.item_lists_dict['service_list'] = self.service_list
		_today = date.today()

	def show(self, *args, **args):
		Menu.show(self, *args, **kw)
		if self.is_only_this_time():
			louie_send('frequency_only_this_time_on', sender=self)
		else:
			louie_send('frequency_only_this_time_off', sender=self)

	def is_only_this_time(self):
		return self.get_item_list('repetition_list')[0].selected_pos == 0

	def _get_weekday_from_date(self):
		date_list = self.date_list
		return day_dict[date(int(date_list[self.year_index].selected.name), int(date_list[self.month_index].selected.name), int(date_list[self.day_index].selected.name)).weekday()]

	def update_day_list(self):
		d_list = self.date_list[self.day_index]
		d = days_in_month(self.date_list[self.year_index].selected.val, self.date_list[self.month_index].selected.val)

	def select_date(self, _date, stop=None):
		struct_t = localtime(_date)
		self.date_list[self.year_index].select(IntegerItem(struct_t[0]))
		self.date_list[self.month_index].select(IntegerItem(struct_t[1]))
		self.date_list[self.day_index].select(IntegerItem(struct_t[2]))
		louie_send('date_weekday', sender=self, value=self['date_weekday'])
		self.start_hour_list.select(IntegerItem(struct_t[3]))
		self.start_minute_list.select(IntegerItem(struct_t[4]))
		if stop:
			struct_t = localtime(stop)
			self.stop_hour_list.select(IntegerItem(struct_t[3]))
			self.stop_minute_list.select(IntegerItem(struct_t[4]))

	def select_channel(self, chan_info, current_favorite=None):
		favorite_list = [TVRootItem().get_acl(menu=self)]
		favorite_list.extend(TVRootItem().browse_favorites(self))
		self.favorite_list.set_items(favorite_list)
		if current_favorite is None:
			self.favorite_list.select(0, force_pos=True)
		else:
			self.favorite_list.select(current_favorite)
		chans = self.favorite_list.selected.browse()
		self.channel_list.set_items(chans)
		self.channel_list.select(chan_info)
		return None

	def _set_record(self, scheduled_record):
		self._record_to_remove = scheduled_record
		_wyrecord = WyRecord()
		self.record_name = scheduled_record.name
		self.select_date(scheduled_record.record.start_time, scheduled_record.record.stop_time)
		target_channel = TVRootItem().get_acl(self).get_channel_from_service_id(str(scheduled_record.record.service_id))
		for i in xrange(len(self.favorite_list)):
			if self.favorite_list[i]['serviceId'] == str(scheduled_record.record.service_id):
				target_channel, target_channel = None, self.favorite_list[i]
				break
				continue
		self.select_channel(target_channel)
		if isinstance(scheduled_record, PeriodicScheduledRecordItem):
			_rule = _wyrecord.scheduler.GetPeriodicRuleById(scheduled_record.record.periodicity_rule_id)
			self.repetition_type_list.select(Item(self.PERIODICITY[_rule.extern_rule_name][0], 'periodic', self))
			_num = (mktime(_rule.last_time.timetuple()) - _rule.recording_ref.start_time) / float(self.PERIODICITY[_rule.extern_rule_name][1] * 86400)
			self.repetition_number_list.select(IntegerItem(int(_num)))
		return None

	def _validate(self):
		all_fields = set(['date', 'start_time', 'end_date', 'end_time'])
		invalid_fields = set()
		error_message = None
		now = time()
		start_time, end_time = self.start_time, self.end_time
		if abs(end_time - start_time) > 21600:
			error_message = _('The recording cannot be longer than 6 hours.')
		if end_time < now:
			error_message = _('You are trying to record a program already over.')
			invalid_fields.add('end_time')
			if now - end_time >= 86400:
				invalid_fields.add('date')
		for field in all_fields.difference(invalid_fields):
			louie_send('%s_valid' % field, sender=self)
		if error_message is not None:
			for field in invalid_fields:
				louie_send('%s_invalid' % field, sender=self)
			error_title = _('Invalid data')
			MessageWindow(error_message, error_title, button=None).show(timeout=5)
			return False
		return True

	def _schedule_record(self, rec_name):
		_wyrecord = WyRecord()
		start_time, stop_time = self.start_time, self.end_time

	def _rename_record(self, kbd):
		WyRecord().scheduler.UpdateRecordingName(self.scheduled_record.id, kbd.text)
		kbd.hide()
		pygui_globs['menustack'].back_one_menu()

	def _confirm(self):
		if not self._validate():
			pass
		loader = LoadingWindow()
		loader.show()
		name_pattern = _('%(date)s %(channel)s %(start_time)s - %(end_time)s')
		if self._record_to_remove:
			old_rec = self._record_to_remove.record
			old_values = {'channel': old_rec.service_name, 'date': strftime('%Y/%m/%d', localtime(old_rec.start_time)), 'start_time': seconds_to_hhmm(old_rec.start_time), 'end_time': seconds_to_hhmm(old_rec.stop_time)}
			computed_old_name = name_pattern % old_values
		if self._record_to_remove and computed_old_name != self._record_to_remove.name:
			scheduled_name = self._record_to_remove.name
		else:
			values = {'channel': self.channel_list.selected.name, 'date': strftime('%Y/%m/%d', localtime(self.start_time)), 'start_time': seconds_to_hhmm(self.start_time), 'end_time': seconds_to_hhmm(self.end_time)}
			scheduled_name = name_pattern % values
		self._schedule_record(scheduled_name)
		loader.hide()

	def cancel(self):
		pygui_globs['menustack'].back_one_menu()

	def update(self, _list):
		up_str = _list.list_name[:-5]
		louie_send(up_str, sender=self, value=self[up_str])
		if _list.list_name in ('date_1_list', 'date_2_list', 'date_3_list'):
			louie_send('date_weekday', sender=self, value=self['date_weekday'])
		if _list.name in [_('Month'), _('Year')]:
			self.update_day_list()
		if _list.name == _('Favorites'):
			items = _list.selected.browse()
			current_channel = self.channel_list.selected
			try:
				self.channel_list.set_items(items, current_channel)
			except ValueError:
				self.channel_list.set_items(items, 0)
				louie_send('channel_name', sender=self, value=self['channel_name'])
		if _list.list_name == 'repetition_type_list':
			if self.is_only_this_time():
				louie_send('frequency_only_this_time_on', sender=self)
			else:
				louie_send('frequency_only_this_time_off', sender=self)

	start_time = property()
	end_time = property()


]:
	i: 559(AF), 588()
	o: 

nname: 588
n 588(None)[for i in xrange(1, 13):
]:
	i: 559(for)
	o: 607()

nname: 559
n 559(None)[del _[2]
for MINUTES in xrange(60):
]:
	i: 514(AF), 540()
	o: 588(for), 607(AF)

nname: 540
n 540(None)[for i in xrange(60):
]:
	i: 514(for)
	o: 559()

nname: 514
n 514(None)[del _[1]
for HOURS in xrange(24):
]:
	i: 0(AF), 495()
	o: 540(for), 559(AF)

nname: 495
n 495(None)[for i in xrange(24):
]:
	i: 0(for)
	o: 514()

nname: 0
n 0(None)[from __future__ import absolute_import
from datetime import date, datetime, timedelta
from time import time, mktime, localtime, strftime
from peewee.messages import send as louie_send
from peewee.debug import GET_LOGGER, PRINT_EXCEPTION
from peewee.formatters import seconds_to_hhmm
from wyrecord import WyRecord
from wyrecord.exceptions import SchedulerConflictWithInstantRecordError, SchedulerConflictError, SchedulerError, SchedulerRecordingRunningError
from .. import Menu
from pygui.eventmanager.menus import ModifyScheduledRecordMenuEventHandler
from pygui.facilities.l10n import get_date_format
from pygui.facilities.timeslices import datetime_to_timestamp
from pygui.item.core import Item, ActionItem
from pygui.item.containers import ItemListItem
from pygui.item.mediaitem.core import TVRootItem
from pygui.shared import pygui_globs
from pygui.item.scheduledrecord import PeriodicScheduledRecordItem, ScheduledRecordItem
from pygui.menu import gui_updater, selective_gui_updater
from pygui.config import user_config
from pygui.window import Button, ConfirmWindow, LoadingWindow, KeyboardWindow, MessageWindow
from pygui.facilities.codemapping import day_dict
log = GET_LOGGER(__name__)
def days_in_month(year, month):
	c = date(year, month, 1)
	if not(c.month == 12 and 1):
		pass
	d = date(c.year + 0, max(1, (c.month + 1) % 13), 1)
	return (d - c).days

class IntegerItem(Item):
	def __init__(self, val, type_='int', menu=None, display_type=None, parent=None):
		Item.__init__(self, '%.2d' % val, type_, menu=None, display_type=None, parent=None)
		self.val = val
		return None

	def __eq__(self, other):
		if isinstance(other, Item):
			return self.val == other.val
		return False



]:
	i: 
	o: 495(for), 514(AF)

self.nodes: {0: <unpyclib.structure.node instance at 0xb761ffcc>, 514: <unpyclib.structure.node instance at 0xb761f1ec>, 588: <unpyclib.structure.node instance at 0xb761f3ec>, 559: <unpyclib.structure.node instance at 0xb761f36c>, 495: <unpyclib.structure.node instance at 0xb761f12c>, 540: <unpyclib.structure.node instance at 0xb761f2cc>, 607: <unpyclib.structure.node instance at 0xb761f4ac>}
from __future__ import absolute_import
from datetime import date, datetime, timedelta
from time import time, mktime, localtime, strftime
from peewee.messages import send as louie_send
from peewee.debug import GET_LOGGER, PRINT_EXCEPTION
from peewee.formatters import seconds_to_hhmm
from wyrecord import WyRecord
from wyrecord.exceptions import SchedulerConflictWithInstantRecordError, SchedulerConflictError, SchedulerError, SchedulerRecordingRunningError
from .. import Menu
from pygui.eventmanager.menus import ModifyScheduledRecordMenuEventHandler
from pygui.facilities.l10n import get_date_format
from pygui.facilities.timeslices import datetime_to_timestamp
from pygui.item.core import Item, ActionItem
from pygui.item.containers import ItemListItem
from pygui.item.mediaitem.core import TVRootItem
from pygui.shared import pygui_globs
from pygui.item.scheduledrecord import PeriodicScheduledRecordItem, ScheduledRecordItem
from pygui.menu import gui_updater, selective_gui_updater
from pygui.config import user_config
from pygui.window import Button, ConfirmWindow, LoadingWindow, KeyboardWindow, MessageWindow
from pygui.facilities.codemapping import day_dict
log = GET_LOGGER(__name__)
def days_in_month(year, month):
	c = date(year, month, 1)
	if not(c.month == 12 and 1):
		pass
	d = date(c.year + 0, max(1, (c.month + 1) % 13), 1)
	return (d - c).days

class IntegerItem(Item):
	def __init__(self, val, type_='int', menu=None, display_type=None, parent=None):
		Item.__init__(self, '%.2d' % val, type_, menu=None, display_type=None, parent=None)
		self.val = val
		return None

	def __eq__(self, other):
		if isinstance(other, Item):
			return self.val == other.val
		return False



