# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 0
n 0(None)[Item.__init__(self, _('No scheduled recordings'), type_='empty', display_type='empty')
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb767a90c>}
nname: 6
n 6(None)[__doc__ = ' A simple item to put in empty places to signal it '
__metaclass__ = MetaSingleton
locked = False
hidden = False
def __init__(self):
	Item.__init__(self, _('No scheduled recordings'), type_='empty', display_type='empty')

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb767a32c>}
nname: 0
n 0(None)[Item.__init__(self, _('EPG not available'), type_='empty', display_type='empty')
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb767a8cc>}
nname: 6
n 6(None)[__doc__ = ' A simple item to put in empty places to signal it '
__metaclass__ = MetaSingleton
locked = False
hidden = False
def __init__(self):
	Item.__init__(self, _('EPG not available'), type_='empty', display_type='empty')

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb767a4ac>}
nname: 27
n 27(None)[return ''
]:
	i: 0&9(t), 23()
	o: 

nname: 23
n 23(None)[]:
	i: 0&9(f)
	o: 27()

nname: 0&9
n 0&9(self._player and self._player['live_time'])[]:
	i: 
	o: 23(f), 27(t)

nname: 0&9
n 0&9(None)[if not(self._player and self._player['live_time']):
	pass
return ''
]:
	i: 
	o: 

self.nodes: {'0&9': <unpyclib.structure.node instance at 0xb768f1ec>}
nname: 26
n 26(None)[return ''
]:
	i: 0&9(t), 22()
	o: 

nname: 22
n 22(None)[]:
	i: 0&9(f)
	o: 26()

nname: 0&9
n 0&9(self._program and self._program.content_type)[]:
	i: 
	o: 22(f), 26(t)

nname: 0&9
n 0&9(None)[if not(self._program and self._program.content_type):
	pass
return ''
]:
	i: 
	o: 

self.nodes: {'0&9': <unpyclib.structure.node instance at 0xb768f1ec>}
nname: 40
n 40(None)[return ''
]:
	i: 0&9(t), 36()
	o: 

nname: 36
n 36(None)[]:
	i: 0&9(f)
	o: 40()

nname: 0&9
n 0&9(self._program and self._program.short_description + '\n' + self._program.description)[]:
	i: 
	o: 36(f), 40(t)

nname: 0&9
n 0&9(None)[if not(self._program and self._program.short_description + '\n' + self._program.description):
	pass
return ''
]:
	i: 
	o: 

self.nodes: {'0&9': <unpyclib.structure.node instance at 0xb768f3cc>}
nname: 33
n 33(None)[return ''
]:
	i: 0&9(t), 29()
	o: 

nname: 29
n 29(None)[]:
	i: 0&9(f)
	o: 33()

nname: 0&9
n 0&9(self._program and seconds_to_hhmm_utc(self._program['duration']))[]:
	i: 
	o: 29(f), 33(t)

nname: 0&9
n 0&9(None)[if not(self._program and seconds_to_hhmm_utc(self._program['duration'])):
	pass
return ''
]:
	i: 
	o: 

self.nodes: {'0&9': <unpyclib.structure.node instance at 0xb768f02c>}
nname: 71
n 71(None)[return ''
]:
	i: 0&9&19(t), 67()
	o: 

nname: 67
n 67(None)[]:
	i: 0&9&19(f)
	o: 71()

nname: 0&9&19
n 0&9&19(self._program and self._player and seconds_to_hhmm_utc(max(self._player.real_utc_time - int(self._program.wymedia_resource['scheduledStartTime']), 0)))[]:
	i: 
	o: 67(f), 71(t)

nname: 0&9&19
n 0&9&19(None)[if not(self._program and self._player and seconds_to_hhmm_utc(max(self._player.real_utc_time - int(self._program.wymedia_resource['scheduledStartTime']), 0))):
	pass
return ''
]:
	i: 
	o: 

self.nodes: {'0&9&19': <unpyclib.structure.node instance at 0xb768f66c>}
nname: 78
n 78(None)[return ''
]:
	i: 0&9&19(t), 74()
	o: 

nname: 74
n 74(None)[]:
	i: 0&9&19(f)
	o: 78()

nname: 0&9&19
n 0&9&19(self._program and self._player and seconds_to_hhmm_utc(min(int(self._program.wymedia_resource['scheduledEndTime']) - self._player.real_utc_time, self._program['duration'])))[]:
	i: 
	o: 74(f), 78(t)

nname: 0&9&19
n 0&9&19(None)[if not(self._program and self._player and seconds_to_hhmm_utc(min(int(self._program.wymedia_resource['scheduledEndTime']) - self._player.real_utc_time, self._program['duration']))):
	pass
return ''
]:
	i: 
	o: 

self.nodes: {'0&9&19': <unpyclib.structure.node instance at 0xb768f4ec>}
nname: 42
n 42(None)[return ''
]:
	i: 0&9(t), 38()
	o: 

nname: 38
n 38(None)[]:
	i: 0&9(f)
	o: 42()

nname: 0&9
n 0&9(self._program and seconds_to_hhmm(int(self._program.wymedia_resource['scheduledEndTime'])))[]:
	i: 
	o: 38(f), 42(t)

nname: 0&9
n 0&9(None)[if not(self._program and seconds_to_hhmm(int(self._program.wymedia_resource['scheduledEndTime']))):
	pass
return ''
]:
	i: 
	o: 

self.nodes: {'0&9': <unpyclib.structure.node instance at 0xb768f5ec>}
nname: 42
n 42(None)[return ''
]:
	i: 0&9(t), 38()
	o: 

nname: 38
n 38(None)[]:
	i: 0&9(f)
	o: 42()

nname: 0&9
n 0&9(self._program and seconds_to_hhmm(int(self._program.wymedia_resource['scheduledStartTime'])))[]:
	i: 
	o: 38(f), 42(t)

nname: 0&9
n 0&9(None)[if not(self._program and seconds_to_hhmm(int(self._program.wymedia_resource['scheduledStartTime']))):
	pass
return ''
]:
	i: 
	o: 

self.nodes: {'0&9': <unpyclib.structure.node instance at 0xb768deec>}
nname: 0
n 0(None)[Navigator.__init__(self, name=name, choices=services, type=type, fill_root=fill_root, universe='tv')
self.eventhandler = TvNavigatorEventHandler(self)
self._all_channel_list = None
self._program = None
self._player = player
self._getitems_keywords.update(dict(program_start_time=(lambda : self._program and seconds_to_hhmm(int(self._program.wymedia_resource['scheduledStartTime']))):
	pass
return ''), program_stop_time=(lambda : self._program and seconds_to_hhmm(int(self._program.wymedia_resource['scheduledEndTime']))):
	pass
return ''), program_remaining_time=(lambda : self._program and self._player and seconds_to_hhmm_utc(min(int(self._program.wymedia_resource['scheduledEndTime']) - self._player.real_utc_time, self._program['duration']))):
	pass
return ''), program_elapsed_time=(lambda : self._program and self._player and seconds_to_hhmm_utc(max(self._player.real_utc_time - int(self._program.wymedia_resource['scheduledStartTime']), 0))):
	pass
return ''), program_duration=(lambda : self._program and seconds_to_hhmm_utc(self._program['duration'])):
	pass
return ''), program_description=(lambda : self._program and self._program.short_description + '\n' + self._program.description):
	pass
return ''), program_content_type=(lambda : self._program and self._program.content_type):
	pass
return ''), live_time=(lambda : self._player and self._player['live_time']):
	pass
return ''), record_timeshift_programbar=self._get_program_bar, recording_info=self._get_recording_info))
self.tasks.update({'show_help_left': Task(self._show_help, side=-1), 'show_help_right': Task(self._show_help, side=1)})
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7686c4c>}
nname: 169
n 169(None)[]:
	i: 155(), 168()
	o: 

nname: 168
n 168(None)[]:
	i: 0(f)
	o: 169()

nname: 155
n 155(None)[self.hide_help()
]:
	i: 68(), 101(), 134(), 154()
	o: 169()

nname: 154
n 154(None)[]:
	i: 121(f)
	o: 155()

nname: 134
n 134(None)[louie_send('show_help_left', sender=self)
]:
	i: 121(t)
	o: 155()

nname: 121
n 121(side == -1)[]:
	i: 88(f)
	o: 134(t), 154(f)

nname: 101
n 101(None)[louie_send('show_help_right', sender=self)
]:
	i: 88(t)
	o: 155()

nname: 88
n 88(side == 1)[]:
	i: 62(t)
	o: 101(t), 121(f)

nname: 68
n 68(None)[louie_send('show_help', sender=self)
]:
	i: 62(f)
	o: 155()

nname: 62
n 62(side)[]:
	i: 41(), 61()
	o: 68(f), 88(t)

nname: 61
n 61(None)[]:
	i: 17(f)
	o: 62()

nname: 41
n 41(None)[louie_send('hide_help', sender=self)
]:
	i: 17(t)
	o: 62()

nname: 17
n 17(config.user_config['base']['help_banner'] == 1)[]:
	i: 0(t)
	o: 41(t), 61(f)

nname: 0
n 0(config.user_config['base']['help_banner'])[]:
	i: 
	o: 17(t), 168(f)

nname: 169
n 169(None)[]:
	i: 155(), 0(f)
	o: 

nname: 155
n 155(None)[self.hide_help()
]:
	i: 17()
	o: 169()

nname: 17
n 17(None)[if config.user_config['base']['help_banner'] == 1:
	louie_send('hide_help', sender=self)
if not side:
	louie_send('show_help', sender=self)
else:
	if side == 1:
		louie_send('show_help_right', sender=self)
	else:
		if side == -1:
			louie_send('show_help_left', sender=self)
]:
	i: 0(t)
	o: 155()

nname: 0
n 0(config.user_config['base']['help_banner'])[]:
	i: 
	o: 17(t), 169(f)

nname: 169
n 169(None)[]:
	i: 17(), 0(f)
	o: 

nname: 17
n 17(None)[if config.user_config['base']['help_banner'] == 1:
	louie_send('hide_help', sender=self)
if not side:
	louie_send('show_help', sender=self)
else:
	if side == 1:
		louie_send('show_help_right', sender=self)
	else:
		if side == -1:
			louie_send('show_help_left', sender=self)
self.hide_help()
]:
	i: 0(t)
	o: 169()

nname: 0
n 0(config.user_config['base']['help_banner'])[]:
	i: 
	o: 17(t), 169(f)

nname: 0
n 0(None)[if config.user_config['base']['help_banner']:
	if config.user_config['base']['help_banner'] == 1:
		louie_send('hide_help', sender=self)
	if not side:
		louie_send('show_help', sender=self)
	else:
		if side == 1:
			louie_send('show_help_right', sender=self)
		else:
			if side == -1:
				louie_send('show_help_left', sender=self)
	self.hide_help()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb768db0c>}
nname: 34
n 34(None)[]:
	i: 9(), 33()
	o: 

nname: 33
n 33(None)[]:
	i: 0(f)
	o: 34()

nname: 9
n 9(None)[self.tasks['show_help_left'].start(0.5)
]:
	i: 0(t)
	o: 34()

nname: 0
n 0(self.show_help_banner)[]:
	i: 
	o: 9(t), 33(f)

nname: 0
n 0(None)[if self.show_help_banner:
	self.tasks['show_help_left'].start(0.5)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7685fec>}
nname: 34
n 34(None)[]:
	i: 9(), 33()
	o: 

nname: 33
n 33(None)[]:
	i: 0(f)
	o: 34()

nname: 9
n 9(None)[self.tasks['show_help_right'].start(0.5)
]:
	i: 0(t)
	o: 34()

nname: 0
n 0(self.show_help_banner)[]:
	i: 
	o: 9(t), 33(f)

nname: 0
n 0(None)[if self.show_help_banner:
	self.tasks['show_help_right'].start(0.5)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7685fcc>}
nname: 498
n 498(None)[return res
]:
	i: 207(), 411(JA), 453(), 477()
	o: 

nname: 477
n 477(None)[res['timeshift_begin'] = None
res['timeshift_end'] = None
]:
	i: 251(f)
	o: 498()

nname: 453
n 453(None)[res['record_begin'] = None
res['record_end'] = None
]:
	i: 371(f)
	o: 498()

nname: 411
n 411(None)[res['record_begin'] = self._player._record.start_time
res['record_end'] = self._player._record.stop_time
]:
	i: 371(t)
	o: 498(JA)

nname: 371
n 371(self._player._record)[res['timeshift_begin'] = time_info.min_available_time
res['timeshift_end'] = res['direct']
]:
	i: 251(t)
	o: 411(t), 453(f)

nname: 251
n 251(self._player.selected['serviceId'] == service['serviceId'])[_lc = self._player.live_controller
res['program_begin'] = int(program['scheduledStartTime'])
res['program_end'] = int(program['scheduledEndTime'])
time_info = _lc.default_renderer.getTimeInfo()
res['direct'] = time_info.max_available_time
res['live'] = time_info.current_time
]:
	i: 161&185(f)
	o: 371(t), 477(f)

nname: 207
n 207(None)[res['program_begin'] = 0
res['program_end'] = 100
res['direct'] = 0
res['live'] = 0
]:
	i: 161&185(t)
	o: 498()

nname: 161&185
n 161&185(self._player is None or program in (None, EmptyProgramItem()))[res = dict()
]:
	i: 85(), 107(), 150(), 160()
	o: 207(t), 251(f)

nname: 160
n 160(None)[]:
	i: 134(f)
	o: 161&185()

nname: 150
n 150(None)[program = None
]:
	i: 134(t)
	o: 161&185()

nname: 134
n 134(isinstance(sel, ScheduledRecordRootItem))[]:
	i: 91(f)
	o: 150(t), 160(f)

nname: 107
n 107(None)[service = self._history[-1]['selected']
program = sel
]:
	i: 91(t)
	o: 161&185()

nname: 91
n 91(isinstance(sel, ProgramItem))[]:
	i: 0(f)
	o: 107(t), 134(f)

nname: 85
n 85(None)[program = None
]:
	i: 30&70(t), 81()
	o: 161&185()

nname: 81
n 81(None)[]:
	i: 30&70(f)
	o: 85()

nname: 30&70
n 30&70(len(l) > 0 and l[0])[service = sel
l = self.get_item_list('preview_list')
]:
	i: 0(t)
	o: 81(f), 85(t)

nname: 0
n 0(isinstance(sel, ChannelItem))[sel = self.selected
program = None
]:
	i: 
	o: 30&70(t), 91(f)

nname: 161&185
n 161&185(None)[res = dict()
if self._player is None or program in (None, EmptyProgramItem()):
	res['program_begin'] = 0
	res['program_end'] = 100
	res['direct'] = 0
	res['live'] = 0
else:
	_lc = self._player.live_controller
	res['program_begin'] = int(program['scheduledStartTime'])
	res['program_end'] = int(program['scheduledEndTime'])
	time_info = _lc.default_renderer.getTimeInfo()
	res['direct'] = time_info.max_available_time
	res['live'] = time_info.current_time
	if self._player.selected['serviceId'] == service['serviceId']:
		res['timeshift_begin'] = time_info.min_available_time
		res['timeshift_end'] = res['direct']
		if self._player._record:
			res['record_begin'] = self._player._record.start_time
			res['record_end'] = self._player._record.stop_time
		else:
			res['record_begin'] = None
			res['record_end'] = None
	else:
		res['timeshift_begin'] = None
		res['timeshift_end'] = None
return res
]:
	i: 30&70(), 91()
	o: 

nname: 91
n 91(None)[if isinstance(sel, ProgramItem):
	service = self._history[-1]['selected']
	program = sel
else:
	if isinstance(sel, ScheduledRecordRootItem):
		program = None
]:
	i: 0(f)
	o: 161&185()

nname: 30&70
n 30&70(None)[service = sel
l = self.get_item_list('preview_list')
if not(len(l) > 0 and l[0]):
	pass
program = None
]:
	i: 0(t)
	o: 161&185()

nname: 0
n 0(isinstance(sel, ChannelItem))[sel = self.selected
program = None
]:
	i: 
	o: 30&70(t), 91(f)

nname: 0
n 0(None)[sel = self.selected
program = None
if isinstance(sel, ChannelItem):
	service = sel
	l = self.get_item_list('preview_list')
	if not(len(l) > 0 and l[0]):
		pass
	program = None
else:
	if isinstance(sel, ProgramItem):
		service = self._history[-1]['selected']
		program = sel
	else:
		if isinstance(sel, ScheduledRecordRootItem):
			program = None
res = dict()
if self._player is None or program in (None, EmptyProgramItem()):
	res['program_begin'] = 0
	res['program_end'] = 100
	res['direct'] = 0
	res['live'] = 0
else:
	_lc = self._player.live_controller
	res['program_begin'] = int(program['scheduledStartTime'])
	res['program_end'] = int(program['scheduledEndTime'])
	time_info = _lc.default_renderer.getTimeInfo()
	res['direct'] = time_info.max_available_time
	res['live'] = time_info.current_time
	if self._player.selected['serviceId'] == service['serviceId']:
		res['timeshift_begin'] = time_info.min_available_time
		res['timeshift_end'] = res['direct']
		if self._player._record:
			res['record_begin'] = self._player._record.start_time
			res['record_end'] = self._player._record.stop_time
		else:
			res['record_begin'] = None
			res['record_end'] = None
	else:
		res['timeshift_begin'] = None
		res['timeshift_end'] = None
return res
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb769ddac>}
nname: 80
n 80(None)[return u''
]:
	i: 0(AL), 79()
	o: 

nname: 79
n 79(None)[]:
	i: 3(AF), 75()
	o: 80()

nname: 75
n 75(None)[]:
	i: 22(f), 37()
	o: 79()

nname: 37
n 37(None)[service_id = live.serviceid
channel = self._all_channel_list.get_channel_from_service_id(service_id)
return channel.name
continue
]:
	i: 22(t)
	o: 75()

nname: 22
n 22(live.isRecording())[for live in WyRecord().live_controller.getRunningLiveList():
]:
	i: 3(for)
	o: 37(t), 75(f)

nname: 3
n 3(None)[]:
	i: 0(loop)
	o: 22(for), 79(AF)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 80(AL)

nname: 80
n 80(None)[return u''
]:
	i: 0(AL), 3(AF), 22()
	o: 

nname: 22
n 22(None)[for live in WyRecord().live_controller.getRunningLiveList():
if live.isRecording():
	service_id = live.serviceid
	channel = self._all_channel_list.get_channel_from_service_id(service_id)
	return channel.name
	continue
]:
	i: 3(for)
	o: 80()

nname: 3
n 3(None)[]:
	i: 0(loop)
	o: 22(for), 80(AF)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 80(AL)

nname: 22
n 22(None)[for live in WyRecord().live_controller.getRunningLiveList():
	if live.isRecording():
		service_id = live.serviceid
		channel = self._all_channel_list.get_channel_from_service_id(service_id)
		return channel.name
		continue
return u''
]:
	i: 0(for)
	o: 

nname: 0
n 0(None)[]:
	i: 
	o: 22(for)

nname: 0
n 0(None)[for live in WyRecord().live_controller.getRunningLiveList():
	if live.isRecording():
		service_id = live.serviceid
		channel = self._all_channel_list.get_channel_from_service_id(service_id)
		return channel.name
		continue
return u''
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb768d22c>}
nname: 0
n 0(None)[tv_root = TVRootItem()
_list = []
_list.append(ScheduledRecordRootItem(self, parent=tv_root))
self._all_channel_list = tv_root.get_acl(self)
_list.append(self._all_channel_list)
_list.extend(list(tv_root.browse_favorites(self)))
return _list
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb768d90c>}
nname: 102
n 102(None)[return ret
]:
	i: 88(), 101()
	o: 

nname: 101
n 101(None)[]:
	i: 0(f)
	o: 102()

nname: 88
n 88(None)[self.build_preview()
]:
	i: 62(), 78()
	o: 102()

nname: 78
n 78(None)[self._program = None
]:
	i: 27(f)
	o: 88()

nname: 62
n 62(None)[self._program = self.selected
]:
	i: 27(t)
	o: 88()

nname: 27
n 27(isinstance(self.selected, ProgramItem))[louie_send('hide_preview', sender=self)
]:
	i: 0(t)
	o: 62(t), 78(f)

nname: 0
n 0(ret)[ret = Menu.select(self, item, list_name)
]:
	i: 
	o: 27(t), 101(f)

nname: 102
n 102(None)[return ret
]:
	i: 27(), 0(f)
	o: 

nname: 27
n 27(None)[louie_send('hide_preview', sender=self)
if isinstance(self.selected, ProgramItem):
	self._program = self.selected
else:
	self._program = None
self.build_preview()
]:
	i: 0(t)
	o: 102()

nname: 0
n 0(ret)[ret = Menu.select(self, item, list_name)
]:
	i: 
	o: 27(t), 102(f)

nname: 0
n 0(None)[ret = Menu.select(self, item, list_name)
if ret:
	louie_send('hide_preview', sender=self)
	if isinstance(self.selected, ProgramItem):
		self._program = self.selected
	else:
		self._program = None
	self.build_preview()
return ret
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb768d02c>}
nname: 193
n 193(None)[return None
]:
	i: 96(JA), 120(), 137()
	o: 

nname: 137
n 137(None)[title = _("Can't change channels")
message = _('A recording is in progress. Stop it before zapping.')
MessageWindow(message, title, button=None).show(timeout=5)
]:
	i: 52&67(f)
	o: 193()

nname: 120
n 120(None)[Navigator.execute_selected(self)
]:
	i: 80(f)
	o: 193()

nname: 96
n 96(None)[item.browse()[0].execute()
]:
	i: 80(t)
	o: 193(JA)

nname: 80
n 80(isinstance(item, DirItem))[]:
	i: 52&67(t)
	o: 96(t), 120(f)

nname: 52&67
n 52&67(item == player.selected or player.can_zap())[]:
	i: 33(), 51()
	o: 80(t), 137(f)

nname: 51
n 51(None)[]:
	i: 0(f)
	o: 52&67()

nname: 33
n 33(None)[self.browse_selected()
return None
]:
	i: 0(t)
	o: 52&67()

nname: 0
n 0(isinstance(item, Playlist))[item = self.selected
player = self._player
]:
	i: 
	o: 33(t), 51(f)

nname: 193
n 193(None)[return None
]:
	i: 0(JA)
	o: 

nname: 0
n 0(None)[item = self.selected
player = self._player
if isinstance(item, Playlist):
	self.browse_selected()
	return None
if item == player.selected or player.can_zap():
	if isinstance(item, DirItem):
		item.browse()[0].execute()
	else:
		Navigator.execute_selected(self)
else:
	title = _("Can't change channels")
	message = _('A recording is in progress. Stop it before zapping.')
	MessageWindow(message, title, button=None).show(timeout=5)
]:
	i: 
	o: 193(JA)

nname: 0
n 0(None)[item = self.selected
player = self._player
if isinstance(item, Playlist):
	self.browse_selected()
	return None
if item == player.selected or player.can_zap():
	if isinstance(item, DirItem):
		item.browse()[0].execute()
	else:
		Navigator.execute_selected(self)
else:
	title = _("Can't change channels")
	message = _('A recording is in progress. Stop it before zapping.')
	MessageWindow(message, title, button=None).show(timeout=5)
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb768d9ec>}
nname: 0
n 0(None)[return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb769d22c>}
nname: 0
n 0(None)[return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb769df2c>}
nname: 412
n 412(None)[louie_send('not_empty_preview', self)
return True
]:
	i: 381(), 411()
	o: 

nname: 411
n 411(None)[]:
	i: 333(f)
	o: 412()

nname: 381
n 381(None)[louie_send('record_timeshift_programbar', sender=self, value=self['record_timeshift_programbar'])
]:
	i: 333(t)
	o: 412()

nname: 333
n 333(_refresh_program_bar)[self.set_items(item_list[:4], list_name='preview_list', position=-1)
louie_send('show_preview', self)
]:
	i: 69(), 241(), 300(JA), 316(), 332()
	o: 381(t), 411(f)

nname: 332
n 332(None)[]:
	i: 250(f)
	o: 333()

nname: 316
n 316(None)[item_list = [EmptyItem()]
]:
	i: 281(f)
	o: 333()

nname: 300
n 300(None)[item_list = [EmptyScheduledItem()]
]:
	i: 281(t)
	o: 333(JA)

nname: 281
n 281(isinstance(self.selected, ScheduledRecordRootItem))[]:
	i: 250(t)
	o: 300(t), 316(f)

nname: 250
n 250(len(item_list) == 0)[item_list = sel.browse()
]:
	i: 136(f)
	o: 281(t), 332(f)

nname: 241
n 241(None)[_refresh_program_bar = True
]:
	i: 224(), 240()
	o: 333()

nname: 240
n 240(None)[]:
	i: 206(f)
	o: 241()

nname: 224
n 224(None)[item_list = [EmptyProgramItem()]
]:
	i: 206(t)
	o: 241()

nname: 206
n 206(len(item_list) == 0)[]:
	i: 156(), 187(), 205(AE)
	o: 224(t), 240(f)

nname: 187
n 187(None)[item_list = sel.browse()
]:
	i: 152(except)
	o: 206()

nname: 156
n 156(None)[item_list = sel.browse(self._player.real_utc_time, limit=4)
]:
	i: 152(try)
	o: 206()

nname: 152
n 152(None)[]:
	i: 136(t)
	o: 156(try), 187(except)

nname: 136
n 136(isinstance(sel, ChannelItem))[]:
	i: 33(f)
	o: 152(t), 250(f)

nname: 69
n 69(None)[louie_send('empty_preview', self)
selective_gui_updater('program_start_time', 'program_stop_time', 'program_remaining_time', 'program_elapsed_time', 'program_duration', 'program_content_type', 'program_description', 'record_timeshift_programbar')((lambda self: None))(self)
return True
]:
	i: 33(t)
	o: 333()

nname: 33
n 33(isinstance(sel, ProgramItem))[sel = self.selected
item_list = None
_refresh_program_bar = False
]:
	i: 18(), 32()
	o: 69(t), 136(f)

nname: 32
n 32(None)[]:
	i: 0(t)
	o: 33()

nname: 18
n 18(None)[self._refresh_root()
]:
	i: 0(f)
	o: 33()

nname: 0
n 0(self._history)[sel = self.selected
]:
	i: 
	o: 18(f), 32(t)

nname: 333
n 333(None)[self.set_items(item_list[:4], list_name='preview_list', position=-1)
louie_send('show_preview', self)
if _refresh_program_bar:
	louie_send('record_timeshift_programbar', sender=self, value=self['record_timeshift_programbar'])
louie_send('not_empty_preview', self)
return True
]:
	i: 69(), 241(), 250(JA)
	o: 

nname: 250
n 250(None)[item_list = sel.browse()
if len(item_list) == 0:
	if isinstance(self.selected, ScheduledRecordRootItem):
		item_list = [EmptyScheduledItem()]
	else:
		item_list = [EmptyItem()]
]:
	i: 136(f)
	o: 333(JA)

nname: 241
n 241(None)[_refresh_program_bar = True
]:
	i: 187()
	o: 333()

nname: 187
n 187(None)[except:
	item_list = sel.browse()
if len(item_list) == 0:
	item_list = [EmptyProgramItem()]
]:
	i: 152()
	o: 241()

nname: 152
n 152(None)[try:
	item_list = sel.browse(self._player.real_utc_time, limit=4)
]:
	i: 136(t)
	o: 187()

nname: 136
n 136(isinstance(sel, ChannelItem))[]:
	i: 0(f)
	o: 152(t), 250(f)

nname: 69
n 69(None)[louie_send('empty_preview', self)
selective_gui_updater('program_start_time', 'program_stop_time', 'program_remaining_time', 'program_elapsed_time', 'program_duration', 'program_content_type', 'program_description', 'record_timeshift_programbar')((lambda self: None))(self)
return True
]:
	i: 0(t)
	o: 333()

nname: 0
n 0(isinstance(sel, ProgramItem))[sel = self.selected
if not self._history:
	self._refresh_root()
sel = self.selected
item_list = None
_refresh_program_bar = False
]:
	i: 
	o: 69(t), 136(f)

nname: 333
n 333(None)[self.set_items(item_list[:4], list_name='preview_list', position=-1)
louie_send('show_preview', self)
if _refresh_program_bar:
	louie_send('record_timeshift_programbar', sender=self, value=self['record_timeshift_programbar'])
louie_send('not_empty_preview', self)
return True
]:
	i: 69(), 241(), 250(JA)
	o: 

nname: 250
n 250(None)[item_list = sel.browse()
if len(item_list) == 0:
	if isinstance(self.selected, ScheduledRecordRootItem):
		item_list = [EmptyScheduledItem()]
	else:
		item_list = [EmptyItem()]
]:
	i: 136(f)
	o: 333(JA)

nname: 241
n 241(None)[_refresh_program_bar = True
]:
	i: 152()
	o: 333()

nname: 152
n 152(None)[try:
	item_list = sel.browse(self._player.real_utc_time, limit=4)
except:
	item_list = sel.browse()
if len(item_list) == 0:
	item_list = [EmptyProgramItem()]
]:
	i: 136(t)
	o: 241()

nname: 136
n 136(isinstance(sel, ChannelItem))[]:
	i: 0(f)
	o: 152(t), 250(f)

nname: 69
n 69(None)[louie_send('empty_preview', self)
selective_gui_updater('program_start_time', 'program_stop_time', 'program_remaining_time', 'program_elapsed_time', 'program_duration', 'program_content_type', 'program_description', 'record_timeshift_programbar')((lambda self: None))(self)
return True
]:
	i: 0(t)
	o: 333()

nname: 0
n 0(isinstance(sel, ProgramItem))[sel = self.selected
if not self._history:
	self._refresh_root()
sel = self.selected
item_list = None
_refresh_program_bar = False
]:
	i: 
	o: 69(t), 136(f)

nname: 333
n 333(None)[self.set_items(item_list[:4], list_name='preview_list', position=-1)
louie_send('show_preview', self)
if _refresh_program_bar:
	louie_send('record_timeshift_programbar', sender=self, value=self['record_timeshift_programbar'])
louie_send('not_empty_preview', self)
return True
]:
	i: 69(), 152(), 250(JA)
	o: 

nname: 250
n 250(None)[item_list = sel.browse()
if len(item_list) == 0:
	if isinstance(self.selected, ScheduledRecordRootItem):
		item_list = [EmptyScheduledItem()]
	else:
		item_list = [EmptyItem()]
]:
	i: 136(f)
	o: 333(JA)

nname: 152
n 152(None)[try:
	item_list = sel.browse(self._player.real_utc_time, limit=4)
except:
	item_list = sel.browse()
if len(item_list) == 0:
	item_list = [EmptyProgramItem()]
_refresh_program_bar = True
]:
	i: 136(t)
	o: 333()

nname: 136
n 136(isinstance(sel, ChannelItem))[]:
	i: 0(f)
	o: 152(t), 250(f)

nname: 69
n 69(None)[louie_send('empty_preview', self)
selective_gui_updater('program_start_time', 'program_stop_time', 'program_remaining_time', 'program_elapsed_time', 'program_duration', 'program_content_type', 'program_description', 'record_timeshift_programbar')((lambda self: None))(self)
return True
]:
	i: 0(t)
	o: 333()

nname: 0
n 0(isinstance(sel, ProgramItem))[sel = self.selected
if not self._history:
	self._refresh_root()
sel = self.selected
item_list = None
_refresh_program_bar = False
]:
	i: 
	o: 69(t), 136(f)

nname: 0
n 0(None)[sel = self.selected
if not self._history:
	self._refresh_root()
sel = self.selected
item_list = None
_refresh_program_bar = False
if isinstance(sel, ProgramItem):
	louie_send('empty_preview', self)
	selective_gui_updater('program_start_time', 'program_stop_time', 'program_remaining_time', 'program_elapsed_time', 'program_duration', 'program_content_type', 'program_description', 'record_timeshift_programbar')((lambda self: None))(self)
	return True
else:
	if isinstance(sel, ChannelItem):
		try:
			item_list = sel.browse(self._player.real_utc_time, limit=4)
		except:
			item_list = sel.browse()
		if len(item_list) == 0:
			item_list = [EmptyProgramItem()]
		_refresh_program_bar = True
	else:
		item_list = sel.browse()
		if len(item_list) == 0:
			if isinstance(self.selected, ScheduledRecordRootItem):
				item_list = [EmptyScheduledItem()]
			else:
				item_list = [EmptyItem()]
self.set_items(item_list[:4], list_name='preview_list', position=-1)
louie_send('show_preview', self)
if _refresh_program_bar:
	louie_send('record_timeshift_programbar', sender=self, value=self['record_timeshift_programbar'])
louie_send('not_empty_preview', self)
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb768f92c>}
nname: 0
n 0(None)[return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb769e1ec>}
nname: 0
n 0(None)[return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb769edac>}
nname: 0
n 0(None)[return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb768faec>}
nname: 0
n 0(None)[return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb768f90c>}
nname: 570
n 570(None)[return None
]:
	i: 556(), 569()
	o: 

nname: 569
n 569(None)[]:
	i: 550(f)
	o: 570()

nname: 556
n 556(None)[self.universe = 'tv'
]:
	i: 550(t)
	o: 570()

nname: 550
n 550(changed)[]:
	i: 524(), 540()
	o: 556(t), 569(f)

nname: 540
n 540(None)[self._program = None
]:
	i: 481(f)
	o: 550()

nname: 524
n 524(None)[self._program = self.selected
]:
	i: 481(t)
	o: 550()

nname: 481
n 481(isinstance(self.selected, ProgramItem))[Navigator.browse_selected(self, action_override=True, *args, **kw)
]:
	i: 63(), 141(), 165(), 316(), 412(), 480()
	o: 524(t), 540(f)

nname: 480
n 480(None)[]:
	i: 396(f)
	o: 481()

nname: 412
n 412(None)[_schedule_menu = ScheduledRecordNavigator(name=_sel.name)
louie_send('hide_program_bar', sender=self)
louie_send('hide_preview_program_bar', sender=self)
_schedule_menu.show()
return None
]:
	i: 396(t)
	o: 481()

nname: 396
n 396(isinstance(_sel, ScheduledRecordRootItem))[]:
	i: 294(f)
	o: 412(t), 480(f)

nname: 316
n 316(None)[self._favorites_list = _sel
louie_send('show_preview_program_bar', sender=self)
louie_send('hide_program_bar', sender=self)
self.show_help()
selective_gui_updater('record_timeshift_programbar')((lambda self: None))(self)
]:
	i: 294(t)
	o: 481()

nname: 294
n 294(isinstance(_sel, (AllChannelsList, Playlist)))[]:
	i: 149(f)
	o: 316(t), 396(f)

nname: 165
n 165(None)[louie_send('show_program_info', sender=self)
louie_send('show_program_bar', sender=self)
louie_send('hide_preview_program_bar', sender=self)
louie_send('show_program_description', sender=self)
self.show_help_left()
kw['pad'] = False
kw['start_time'] = self._player.real_utc_time
selective_gui_updater('record_timeshift_programbar')((lambda self: None))(self)
]:
	i: 149(t)
	o: 481()

nname: 149
n 149(isinstance(_sel, ChannelItem))[]:
	i: 87&106(f)
	o: 165(t), 294(f)

nname: 141
n 141(None)[return None
]:
	i: 87&106(t)
	o: 481()

nname: 87&106
n 87&106(len(preview_list) < 2 and preview_list[0] in [EmptyProgramItem(), EmptyItem(), EmptyScheduledItem()])[]:
	i: 0(f)
	o: 141(t), 149(f)

nname: 63
n 63(None)[louie_send('main_list_not_browse', sender=self)
return None
]:
	i: 0(t)
	o: 481()

nname: 0
n 0(isinstance(_sel, ProgramItem))[changed = False
args = list()
kw = dict()
preview_list = self.get_item_list('preview_list')
_sel = self.selected
]:
	i: 
	o: 63(t), 87&106(f)

nname: 550
n 550(None)[if changed:
	self.universe = 'tv'
return None
]:
	i: 0()
	o: 

nname: 0
n 0(None)[changed = False
args = list()
kw = dict()
preview_list = self.get_item_list('preview_list')
_sel = self.selected
if isinstance(_sel, ProgramItem):
	louie_send('main_list_not_browse', sender=self)
	return None
else:
	if len(preview_list) < 2 and preview_list[0] in [EmptyProgramItem(), EmptyItem(), EmptyScheduledItem()]:
		return None
	else:
		if isinstance(_sel, ChannelItem):
			louie_send('show_program_info', sender=self)
			louie_send('show_program_bar', sender=self)
			louie_send('hide_preview_program_bar', sender=self)
			louie_send('show_program_description', sender=self)
			self.show_help_left()
			kw['pad'] = False
			kw['start_time'] = self._player.real_utc_time
			selective_gui_updater('record_timeshift_programbar')((lambda self: None))(self)
		else:
			if isinstance(_sel, (AllChannelsList, Playlist)):
				self._favorites_list = _sel
				louie_send('show_preview_program_bar', sender=self)
				louie_send('hide_program_bar', sender=self)
				self.show_help()
				selective_gui_updater('record_timeshift_programbar')((lambda self: None))(self)
			else:
				if isinstance(_sel, ScheduledRecordRootItem):
					_schedule_menu = ScheduledRecordNavigator(name=_sel.name)
					louie_send('hide_program_bar', sender=self)
					louie_send('hide_preview_program_bar', sender=self)
					_schedule_menu.show()
					return None
Navigator.browse_selected(self, action_override=True, *args, **kw)
if isinstance(self.selected, ProgramItem):
	self._program = self.selected
else:
	self._program = None
]:
	i: 
	o: 550()

nname: 0
n 0(None)[changed = False
args = list()
kw = dict()
preview_list = self.get_item_list('preview_list')
_sel = self.selected
if isinstance(_sel, ProgramItem):
	louie_send('main_list_not_browse', sender=self)
	return None
else:
	if len(preview_list) < 2 and preview_list[0] in [EmptyProgramItem(), EmptyItem(), EmptyScheduledItem()]:
		return None
	else:
		if isinstance(_sel, ChannelItem):
			louie_send('show_program_info', sender=self)
			louie_send('show_program_bar', sender=self)
			louie_send('hide_preview_program_bar', sender=self)
			louie_send('show_program_description', sender=self)
			self.show_help_left()
			kw['pad'] = False
			kw['start_time'] = self._player.real_utc_time
			selective_gui_updater('record_timeshift_programbar')((lambda self: None))(self)
		else:
			if isinstance(_sel, (AllChannelsList, Playlist)):
				self._favorites_list = _sel
				louie_send('show_preview_program_bar', sender=self)
				louie_send('hide_program_bar', sender=self)
				self.show_help()
				selective_gui_updater('record_timeshift_programbar')((lambda self: None))(self)
			else:
				if isinstance(_sel, ScheduledRecordRootItem):
					_schedule_menu = ScheduledRecordNavigator(name=_sel.name)
					louie_send('hide_program_bar', sender=self)
					louie_send('hide_preview_program_bar', sender=self)
					_schedule_menu.show()
					return None
Navigator.browse_selected(self, action_override=True, *args, **kw)
if isinstance(self.selected, ProgramItem):
	self._program = self.selected
else:
	self._program = None
if changed:
	self.universe = 'tv'
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb768f72c>}
nname: 320
n 320(None)[return False
]:
	i: 272(), 319()
	o: 

nname: 319
n 319(None)[]:
	i: 152(f)
	o: 320()

nname: 272
n 272(None)[self.tasks['set_prev_content'] = Task(_set_prev_content, self, [EmptyProgramItem()])
self.tasks['set_prev_content'].start(config.HMI_BASE['navigator_listing_delay'])
return True
]:
	i: 245(), 262()
	o: 320()

nname: 262
n 262(None)[]:
	i: 164(f)
	o: 272()

nname: 245
n 245(None)[]:
	i: 164(t)
	o: 272()

nname: 164
n 164(self.choices)[louie_send('hide_program_bar', sender=self)
louie_send('event_left', sender=self)
_set_prev_content = selective_gui_updater('parent_item_name', 'parent_icon_name')()
]:
	i: 152(t)
	o: 245(t), 262(f)

nname: 152
n 152(last_context is not None)[]:
	i: 60(), 143(), 150(AE)
	o: 164(t), 319(f)

nname: 150
n 150(None)[]:
	i: 64(f)
	o: 152(AE)

nname: 143
n 143(None)[return None
]:
	i: 100(), 142()
	o: 152()

nname: 142
n 142(None)[]:
	i: 74&87(f)
	o: 143()

nname: 100
n 100(None)[self.go_to_item(self.selected.parent, 'event_left')
louie_send('on_root', sender=self)
]:
	i: 74&87(t)
	o: 143()

nname: 74&87
n 74&87(self.selected and self.selected.parent)[]:
	i: 64(t)
	o: 100(t), 142(f)

nname: 64
n 64(<dummy_ex3> EXC_MATCH IndexError)[]:
	i: 0(except)
	o: 74&87(t), 150(f)

nname: 60
n 60(None)[]:
	i: 36(), 59()
	o: 152()

nname: 59
n 59(None)[]:
	i: 3(f)
	o: 60()

nname: 36
n 36(None)[self.selected.unwatch(self._selection_changed)
]:
	i: 3(t)
	o: 60()

nname: 3
n 3(hasattr(self.selected, 'unwatch'))[last_context = self._history.pop()
]:
	i: 0(try)
	o: 36(t), 59(f)

nname: 0
n 0(None)[]:
	i: 
	o: 3(try), 64(except)

nname: 320
n 320(None)[return False
]:
	i: 164(), 152(f)
	o: 

nname: 164
n 164(None)[louie_send('hide_program_bar', sender=self)
louie_send('event_left', sender=self)
_set_prev_content = selective_gui_updater('parent_item_name', 'parent_icon_name')()
if self.choices:
	pass
self.tasks['set_prev_content'] = Task(_set_prev_content, self, [EmptyProgramItem()])
self.tasks['set_prev_content'].start(config.HMI_BASE['navigator_listing_delay'])
return True
]:
	i: 152(t)
	o: 320()

nname: 152
n 152(last_context is not None)[]:
	i: 3(), 143(), 150(AE)
	o: 164(t), 320(f)

nname: 143
n 143(None)[return None
]:
	i: 74&87(), 64(f)
	o: 152()

nname: 74&87
n 74&87(None)[if self.selected and self.selected.parent:
	self.go_to_item(self.selected.parent, 'event_left')
	louie_send('on_root', sender=self)
]:
	i: 64(t)
	o: 143()

nname: 64
n 64(<dummy_ex3> EXC_MATCH IndexError)[]:
	i: 0(except)
	o: 74&87(t), 143(f)

nname: 3
n 3(None)[last_context = self._history.pop()
if hasattr(self.selected, 'unwatch'):
	self.selected.unwatch(self._selection_changed)
]:
	i: 0(try)
	o: 152()

nname: 0
n 0(None)[]:
	i: 
	o: 3(try), 64(except)

nname: 152
n 152(None)[if last_context is not None:
	louie_send('hide_program_bar', sender=self)
	louie_send('event_left', sender=self)
	_set_prev_content = selective_gui_updater('parent_item_name', 'parent_icon_name')()
	if self.choices:
		pass
	self.tasks['set_prev_content'] = Task(_set_prev_content, self, [EmptyProgramItem()])
	self.tasks['set_prev_content'].start(config.HMI_BASE['navigator_listing_delay'])
	return True
return False
]:
	i: 3(), 64(), 150(AE)
	o: 

nname: 64
n 64(None)[except IndexError:
	if self.selected and self.selected.parent:
		self.go_to_item(self.selected.parent, 'event_left')
		louie_send('on_root', sender=self)
return None
]:
	i: 0(except)
	o: 152()

nname: 3
n 3(None)[last_context = self._history.pop()
if hasattr(self.selected, 'unwatch'):
	self.selected.unwatch(self._selection_changed)
]:
	i: 0(try)
	o: 152()

nname: 0
n 0(None)[]:
	i: 
	o: 3(try), 64(except)

nname: 64
n 64(None)[except IndexError:
	if self.selected and self.selected.parent:
		self.go_to_item(self.selected.parent, 'event_left')
		louie_send('on_root', sender=self)
return None
if last_context is not None:
	louie_send('hide_program_bar', sender=self)
	louie_send('event_left', sender=self)
	_set_prev_content = selective_gui_updater('parent_item_name', 'parent_icon_name')()
	if self.choices:
		pass
	self.tasks['set_prev_content'] = Task(_set_prev_content, self, [EmptyProgramItem()])
	self.tasks['set_prev_content'].start(config.HMI_BASE['navigator_listing_delay'])
	return True
return False
]:
	i: 0()
	o: 

nname: 0
n 0(None)[try:
	last_context = self._history.pop()
	if hasattr(self.selected, 'unwatch'):
		self.selected.unwatch(self._selection_changed)
]:
	i: 
	o: 64()

nname: 0
n 0(None)[try:
	last_context = self._history.pop()
	if hasattr(self.selected, 'unwatch'):
		self.selected.unwatch(self._selection_changed)
except IndexError:
	if self.selected and self.selected.parent:
		self.go_to_item(self.selected.parent, 'event_left')
		louie_send('on_root', sender=self)
return None
if last_context is not None:
	louie_send('hide_program_bar', sender=self)
	louie_send('event_left', sender=self)
	_set_prev_content = selective_gui_updater('parent_item_name', 'parent_icon_name')()
	if self.choices:
		pass
	self.tasks['set_prev_content'] = Task(_set_prev_content, self, [EmptyProgramItem()])
	self.tasks['set_prev_content'].start(config.HMI_BASE['navigator_listing_delay'])
	return True
return False
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb768daec>}
nname: 148
n 148(None)[self.set_items(_playlist, position=ind)
self.build_preview()
louie_send('hide_program_info', sender=self)
louie_send('show_preview_program_bar', sender=self)
louie_send('hide_program_bar', sender=self)
]:
	i: 102(), 131(), 146(AE)
	o: 

nname: 146
n 146(None)[]:
	i: 121(f)
	o: 148(AE)

nname: 131
n 131(None)[#, e
ind = 0
]:
	i: 121(t)
	o: 148()

nname: 121
n 121(<dummy_ex3> EXC_MATCH ValueError)[]:
	i: 0(except)
	o: 131(t), 146(f)

nname: 102
n 102(None)[ind = _playlist.index(service)
]:
	i: 0(try)
	o: 148()

nname: 0
n 0(None)[self._history.empty()
root = self.root_getter()
position = root.index(playlist)
playlist = root[position]
self._history.append(dict(position=position, selected=playlist, items=root))
_playlist = playlist.browse()
]:
	i: 
	o: 102(try), 121(except)

nname: 121
n 121(None)[except ValueError, e:
	ind = 0
self.set_items(_playlist, position=ind)
self.build_preview()
louie_send('hide_program_info', sender=self)
louie_send('show_preview_program_bar', sender=self)
louie_send('hide_program_bar', sender=self)
]:
	i: 0()
	o: 

nname: 0
n 0(None)[self._history.empty()
root = self.root_getter()
position = root.index(playlist)
playlist = root[position]
self._history.append(dict(position=position, selected=playlist, items=root))
_playlist = playlist.browse()
try:
	ind = _playlist.index(service)
]:
	i: 
	o: 121()

nname: 0
n 0(None)[self._history.empty()
root = self.root_getter()
position = root.index(playlist)
playlist = root[position]
self._history.append(dict(position=position, selected=playlist, items=root))
_playlist = playlist.browse()
try:
	ind = _playlist.index(service)
except ValueError, e:
	ind = 0
self.set_items(_playlist, position=ind)
self.build_preview()
louie_send('hide_program_info', sender=self)
louie_send('show_preview_program_bar', sender=self)
louie_send('hide_program_bar', sender=self)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb768d8cc>}
nname: 0
n 0(None)[self._history.empty()
root = self.root_getter()
self.set_items(root)
self._build_preview()
self.browse_selected()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb768d28c>}
nname: 0
n 0(None)[self._player.display_epg()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7685fcc>}
nname: 134
n 134(None)[menu.show()
]:
	i: 24(), 56(), 88(), 104()
	o: 

nname: 104
n 104(None)[log.error("Information window for %s (%s) isn't supported", item, type(item))
]:
	i: 72(f)
	o: 134()

nname: 88
n 88(None)[menu = ScheduledRecordRootInfoMenu(item)
]:
	i: 72(t)
	o: 134()

nname: 72
n 72(isinstance(item, ScheduledRecordRootItem))[]:
	i: 40(f)
	o: 88(t), 104(f)

nname: 56
n 56(None)[menu = TVInfoMenu(item)
]:
	i: 40(t)
	o: 134()

nname: 40
n 40(isinstance(item, AllChannelsList))[]:
	i: 0(f)
	o: 56(t), 72(f)

nname: 24
n 24(None)[menu = ChannelInfoMenu(item)
]:
	i: 0(t)
	o: 134()

nname: 0
n 0(isinstance(item, ChannelItem))[item = self.selected
]:
	i: 
	o: 24(t), 40(f)

nname: 0
n 0(None)[item = self.selected
if isinstance(item, ChannelItem):
	menu = ChannelInfoMenu(item)
else:
	if isinstance(item, AllChannelsList):
		menu = TVInfoMenu(item)
	else:
		if isinstance(item, ScheduledRecordRootItem):
			menu = ScheduledRecordRootInfoMenu(item)
		else:
			log.error("Information window for %s (%s) isn't supported", item, type(item))
menu.show()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb768d8ac>}
nname: 116
n 116(None)[]:
	i: 59(), 105()
	o: 

nname: 105
n 105(None)[self._error_spawner()
]:
	i: 0(f)
	o: 116()

nname: 59
n 59(None)[self.set_items(item.parent.browse(self._player.real_utc_time), 'main_list', position=self.selected_pos)
]:
	i: 34(), 48()
	o: 116()

nname: 48
n 48(None)[self.record_selected()
]:
	i: 24(f)
	o: 59()

nname: 34
n 34(None)[self.cancel_record_selected()
]:
	i: 24(t)
	o: 59()

nname: 24
n 24(item.recording_id)[]:
	i: 0(t)
	o: 34(t), 48(f)

nname: 0
n 0(isinstance(item, ProgramItem))[item = self.selected
]:
	i: 
	o: 24(t), 105(f)

nname: 116
n 116(None)[]:
	i: 24(), 105()
	o: 

nname: 105
n 105(None)[self._error_spawner()
]:
	i: 0(f)
	o: 116()

nname: 24
n 24(None)[if item.recording_id:
	self.cancel_record_selected()
else:
	self.record_selected()
self.set_items(item.parent.browse(self._player.real_utc_time), 'main_list', position=self.selected_pos)
]:
	i: 0(t)
	o: 116()

nname: 0
n 0(isinstance(item, ProgramItem))[item = self.selected
]:
	i: 
	o: 24(t), 105(f)

nname: 0
n 0(None)[item = self.selected
if isinstance(item, ProgramItem):
	if item.recording_id:
		self.cancel_record_selected()
	else:
		self.record_selected()
	self.set_items(item.parent.browse(self._player.real_utc_time), 'main_list', position=self.selected_pos)
else:
	self._error_spawner()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb768d4ec>}
nname: 102
n 102(None)[]:
	i: 34(), 91()
	o: 

nname: 91
n 91(None)[self._error_spawner()
]:
	i: 0&24(f)
	o: 102()

nname: 34
n 34(None)[self.cancel_record_selected()
self.set_items(item.parent.browse(self._player.real_utc_time), 'main_list', position=self.selected_pos)
]:
	i: 0&24(t)
	o: 102()

nname: 0&24
n 0&24(isinstance(item, ProgramItem) and item.recording_id)[item = self.selected
]:
	i: 
	o: 34(t), 91(f)

nname: 0&24
n 0&24(None)[item = self.selected
if isinstance(item, ProgramItem) and item.recording_id:
	self.cancel_record_selected()
	self.set_items(item.parent.browse(self._player.real_utc_time), 'main_list', position=self.selected_pos)
else:
	self._error_spawner()
]:
	i: 
	o: 

self.nodes: {'0&24': <unpyclib.structure.node instance at 0xb768d8ec>}
nname: 748
n 748(None)[return None
]:
	i: 214(JA), 281(JA), 452(JA), 607(JA), 683(), 686()
	o: 

nname: 686
n 686(None)[message = _('The program is over. You cannot record it.')
title = _('Program already over')
win = MessageWindow(message, title, button=None)
win.show(timeout=5)
]:
	i: 0(f)
	o: 748()

nname: 683
n 683(None)[]:
	i: 681(AE)
	o: 748()

nname: 681
n 681(None)[]:
	i: 596(f)
	o: 683(AE)

nname: 607
n 607(None)[#, e
log.error("Can't start recording due to %s", e)
title = _('Recording scheduler error')
message = 'Unable to schedule your recording. Sorry.'
MessageWindow(message, title, button=None).show(timeout=5)
]:
	i: 596(t)
	o: 748(JA)

nname: 596
n 596(<dummy_ex3> EXC_MATCH SchedulerError)[]:
	i: 441(f)
	o: 607(t), 681(f)

nname: 452
n 452(None)[#, e
conflicting_rec = e.conflict.getAllRecInConflict()[0]
message_pattern = _('The recording you are attempting to schedule conflicts with "%(name)s", starting at %(start_time)s on %(channel)s.')
message = message_pattern % {'name': ellipsize(conflicting_rec.name, 40), 'start_time': seconds_to_hhmm(conflicting_rec.start_time), 'channel': conflicting_rec.service_name}
title = _('Recording scheduler error')
MessageWindow(message, title, button=None).show(timeout=5)
]:
	i: 441(t)
	o: 748(JA)

nname: 441
n 441(<dummy_ex3> EXC_MATCH SchedulerConflictError)[]:
	i: 271(f)
	o: 452(t), 596(f)

nname: 281
n 281(None)[#, e
louie_send('update_record', sender=None)
conflicting_rec = e.conflict.getAllRecInConflict()[0]
message_pattern = _('An instant recording on %(channel)s will be stopped when this recording starts.')
message = message_pattern % {'name': ellipsize(conflicting_rec.name, 40), 'start_time': seconds_to_hhmm(conflicting_rec.start_time), 'channel': conflicting_rec.service_name}
title = _('Conflict with an instant recording')
MessageWindow(message, title, button=None).show(timeout=5)
]:
	i: 271(t)
	o: 748(JA)

nname: 271
n 271(<dummy_ex3> EXC_MATCH SchedulerConflictWithInstantRecordError)[]:
	i: 39(except)
	o: 281(t), 441(f)

nname: 214
n 214(None)[WyRecord().scheduler.ScheduleRecording(chan_id, start_time, end_time, record_name, program_id=program.id, favorite=favorite_name)
louie_send('update_record')
]:
	i: 39(try)
	o: 748(JA)

nname: 39
n 39(None)[start_time = max(now, program.start_time)
end_time = min(program.end_time, start_time + 21600)
channel = program.parent
chan_id = int(channel['serviceId'])
favorite_name = channel.parent.name
values = {'channel': channel.name, 'title': program.name, 'date': strftime('%Y/%m/%d', localtime(start_time)), 'start_time': seconds_to_hhmm(start_time), 'end_time': seconds_to_hhmm(end_time)}
record_name = EPG_RECORDING_NAME_PATTERN % values
]:
	i: 0(t)
	o: 214(try), 271(except)

nname: 0
n 0(program.end_time > now)[program = self.selected
now = int(time())
]:
	i: 
	o: 39(t), 686(f)

nname: 748
n 748(None)[return None
]:
	i: 214(JA), 281(JA), 452(JA), 607(JA), 686(), 596(f), 681(AE)
	o: 

nname: 686
n 686(None)[message = _('The program is over. You cannot record it.')
title = _('Program already over')
win = MessageWindow(message, title, button=None)
win.show(timeout=5)
]:
	i: 0(f)
	o: 748()

nname: 607
n 607(None)[#, e
log.error("Can't start recording due to %s", e)
title = _('Recording scheduler error')
message = 'Unable to schedule your recording. Sorry.'
MessageWindow(message, title, button=None).show(timeout=5)
]:
	i: 596(t)
	o: 748(JA)

nname: 596
n 596(<dummy_ex3> EXC_MATCH SchedulerError)[]:
	i: 441(f)
	o: 607(t), 748(f)

nname: 452
n 452(None)[#, e
conflicting_rec = e.conflict.getAllRecInConflict()[0]
message_pattern = _('The recording you are attempting to schedule conflicts with "%(name)s", starting at %(start_time)s on %(channel)s.')
message = message_pattern % {'name': ellipsize(conflicting_rec.name, 40), 'start_time': seconds_to_hhmm(conflicting_rec.start_time), 'channel': conflicting_rec.service_name}
title = _('Recording scheduler error')
MessageWindow(message, title, button=None).show(timeout=5)
]:
	i: 441(t)
	o: 748(JA)

nname: 441
n 441(<dummy_ex3> EXC_MATCH SchedulerConflictError)[]:
	i: 271(f)
	o: 452(t), 596(f)

nname: 281
n 281(None)[#, e
louie_send('update_record', sender=None)
conflicting_rec = e.conflict.getAllRecInConflict()[0]
message_pattern = _('An instant recording on %(channel)s will be stopped when this recording starts.')
message = message_pattern % {'name': ellipsize(conflicting_rec.name, 40), 'start_time': seconds_to_hhmm(conflicting_rec.start_time), 'channel': conflicting_rec.service_name}
title = _('Conflict with an instant recording')
MessageWindow(message, title, button=None).show(timeout=5)
]:
	i: 271(t)
	o: 748(JA)

nname: 271
n 271(<dummy_ex3> EXC_MATCH SchedulerConflictWithInstantRecordError)[]:
	i: 39(except)
	o: 281(t), 441(f)

nname: 214
n 214(None)[WyRecord().scheduler.ScheduleRecording(chan_id, start_time, end_time, record_name, program_id=program.id, favorite=favorite_name)
louie_send('update_record')
]:
	i: 39(try)
	o: 748(JA)

nname: 39
n 39(None)[start_time = max(now, program.start_time)
end_time = min(program.end_time, start_time + 21600)
channel = program.parent
chan_id = int(channel['serviceId'])
favorite_name = channel.parent.name
values = {'channel': channel.name, 'title': program.name, 'date': strftime('%Y/%m/%d', localtime(start_time)), 'start_time': seconds_to_hhmm(start_time), 'end_time': seconds_to_hhmm(end_time)}
record_name = EPG_RECORDING_NAME_PATTERN % values
]:
	i: 0(t)
	o: 214(try), 271(except)

nname: 0
n 0(program.end_time > now)[program = self.selected
now = int(time())
]:
	i: 
	o: 39(t), 686(f)

nname: 748
n 748(None)[return None
]:
	i: 271(JA), 686()
	o: 

nname: 686
n 686(None)[message = _('The program is over. You cannot record it.')
title = _('Program already over')
win = MessageWindow(message, title, button=None)
win.show(timeout=5)
]:
	i: 0(f)
	o: 748()

nname: 271
n 271(None)[except SchedulerConflictWithInstantRecordError, e:
	louie_send('update_record', sender=None)
	conflicting_rec = e.conflict.getAllRecInConflict()[0]
	message_pattern = _('An instant recording on %(channel)s will be stopped when this recording starts.')
	message = message_pattern % {'name': ellipsize(conflicting_rec.name, 40), 'start_time': seconds_to_hhmm(conflicting_rec.start_time), 'channel': conflicting_rec.service_name}
	title = _('Conflict with an instant recording')
	MessageWindow(message, title, button=None).show(timeout=5)
except:
	except SchedulerConflictError, e:
		conflicting_rec = e.conflict.getAllRecInConflict()[0]
		message_pattern = _('The recording you are attempting to schedule conflicts with "%(name)s", starting at %(start_time)s on %(channel)s.')
		message = message_pattern % {'name': ellipsize(conflicting_rec.name, 40), 'start_time': seconds_to_hhmm(conflicting_rec.start_time), 'channel': conflicting_rec.service_name}
		title = _('Recording scheduler error')
		MessageWindow(message, title, button=None).show(timeout=5)
	except:
		except SchedulerError, e:
			log.error("Can't start recording due to %s", e)
			title = _('Recording scheduler error')
			message = 'Unable to schedule your recording. Sorry.'
			MessageWindow(message, title, button=None).show(timeout=5)
]:
	i: 39()
	o: 748(JA)

nname: 39
n 39(None)[start_time = max(now, program.start_time)
end_time = min(program.end_time, start_time + 21600)
channel = program.parent
chan_id = int(channel['serviceId'])
favorite_name = channel.parent.name
values = {'channel': channel.name, 'title': program.name, 'date': strftime('%Y/%m/%d', localtime(start_time)), 'start_time': seconds_to_hhmm(start_time), 'end_time': seconds_to_hhmm(end_time)}
record_name = EPG_RECORDING_NAME_PATTERN % values
try:
	WyRecord().scheduler.ScheduleRecording(chan_id, start_time, end_time, record_name, program_id=program.id, favorite=favorite_name)
	louie_send('update_record')
]:
	i: 0(t)
	o: 271()

nname: 0
n 0(program.end_time > now)[program = self.selected
now = int(time())
]:
	i: 
	o: 39(t), 686(f)

nname: 748
n 748(None)[return None
]:
	i: 39(JA), 686()
	o: 

nname: 686
n 686(None)[message = _('The program is over. You cannot record it.')
title = _('Program already over')
win = MessageWindow(message, title, button=None)
win.show(timeout=5)
]:
	i: 0(f)
	o: 748()

nname: 39
n 39(None)[start_time = max(now, program.start_time)
end_time = min(program.end_time, start_time + 21600)
channel = program.parent
chan_id = int(channel['serviceId'])
favorite_name = channel.parent.name
values = {'channel': channel.name, 'title': program.name, 'date': strftime('%Y/%m/%d', localtime(start_time)), 'start_time': seconds_to_hhmm(start_time), 'end_time': seconds_to_hhmm(end_time)}
record_name = EPG_RECORDING_NAME_PATTERN % values
try:
	WyRecord().scheduler.ScheduleRecording(chan_id, start_time, end_time, record_name, program_id=program.id, favorite=favorite_name)
	louie_send('update_record')
except SchedulerConflictWithInstantRecordError, e:
	louie_send('update_record', sender=None)
	conflicting_rec = e.conflict.getAllRecInConflict()[0]
	message_pattern = _('An instant recording on %(channel)s will be stopped when this recording starts.')
	message = message_pattern % {'name': ellipsize(conflicting_rec.name, 40), 'start_time': seconds_to_hhmm(conflicting_rec.start_time), 'channel': conflicting_rec.service_name}
	title = _('Conflict with an instant recording')
	MessageWindow(message, title, button=None).show(timeout=5)
except:
	except SchedulerConflictError, e:
		conflicting_rec = e.conflict.getAllRecInConflict()[0]
		message_pattern = _('The recording you are attempting to schedule conflicts with "%(name)s", starting at %(start_time)s on %(channel)s.')
		message = message_pattern % {'name': ellipsize(conflicting_rec.name, 40), 'start_time': seconds_to_hhmm(conflicting_rec.start_time), 'channel': conflicting_rec.service_name}
		title = _('Recording scheduler error')
		MessageWindow(message, title, button=None).show(timeout=5)
	except:
		except SchedulerError, e:
			log.error("Can't start recording due to %s", e)
			title = _('Recording scheduler error')
			message = 'Unable to schedule your recording. Sorry.'
			MessageWindow(message, title, button=None).show(timeout=5)
]:
	i: 0(t)
	o: 748(JA)

nname: 0
n 0(program.end_time > now)[program = self.selected
now = int(time())
]:
	i: 
	o: 39(t), 686(f)

nname: 0
n 0(None)[program = self.selected
now = int(time())
if program.end_time > now:
	start_time = max(now, program.start_time)
	end_time = min(program.end_time, start_time + 21600)
	channel = program.parent
	chan_id = int(channel['serviceId'])
	favorite_name = channel.parent.name
	values = {'channel': channel.name, 'title': program.name, 'date': strftime('%Y/%m/%d', localtime(start_time)), 'start_time': seconds_to_hhmm(start_time), 'end_time': seconds_to_hhmm(end_time)}
	record_name = EPG_RECORDING_NAME_PATTERN % values
	try:
		WyRecord().scheduler.ScheduleRecording(chan_id, start_time, end_time, record_name, program_id=program.id, favorite=favorite_name)
		louie_send('update_record')
	except SchedulerConflictWithInstantRecordError, e:
		louie_send('update_record', sender=None)
		conflicting_rec = e.conflict.getAllRecInConflict()[0]
		message_pattern = _('An instant recording on %(channel)s will be stopped when this recording starts.')
		message = message_pattern % {'name': ellipsize(conflicting_rec.name, 40), 'start_time': seconds_to_hhmm(conflicting_rec.start_time), 'channel': conflicting_rec.service_name}
		title = _('Conflict with an instant recording')
		MessageWindow(message, title, button=None).show(timeout=5)
	except:
		except SchedulerConflictError, e:
			conflicting_rec = e.conflict.getAllRecInConflict()[0]
			message_pattern = _('The recording you are attempting to schedule conflicts with "%(name)s", starting at %(start_time)s on %(channel)s.')
			message = message_pattern % {'name': ellipsize(conflicting_rec.name, 40), 'start_time': seconds_to_hhmm(conflicting_rec.start_time), 'channel': conflicting_rec.service_name}
			title = _('Recording scheduler error')
			MessageWindow(message, title, button=None).show(timeout=5)
		except:
			except SchedulerError, e:
				log.error("Can't start recording due to %s", e)
				title = _('Recording scheduler error')
				message = 'Unable to schedule your recording. Sorry.'
				MessageWindow(message, title, button=None).show(timeout=5)
else:
	message = _('The program is over. You cannot record it.')
	title = _('Program already over')
	win = MessageWindow(message, title, button=None)
	win.show(timeout=5)
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb769d06c>}
nname: 145
n 145(None)[return None
]:
	i: 44(JA), 77(JA), 141(), 144()
	o: 

nname: 144
n 144(None)[]:
	i: 0(f)
	o: 145()

nname: 141
n 141(None)[]:
	i: 139(AE)
	o: 145()

nname: 139
n 139(None)[]:
	i: 67(f)
	o: 141(AE)

nname: 77
n 77(None)[error_title = _('Impossible to cancel recording')
message = _('This recording has already started. To stop it, close the EPG grid and press Stop.')
MessageWindow(message, error_title, button=None).show(timeout=5)
]:
	i: 67(t)
	o: 145(JA)

nname: 67
n 67(<dummy_ex3> EXC_MATCH SchedulerRecordingRunningError)[]:
	i: 24(except)
	o: 77(t), 139(f)

nname: 44
n 44(None)[WyRecord().scheduler.DeleteRecording(rec_id)
]:
	i: 24(try)
	o: 145(JA)

nname: 24
n 24(None)[log.info('Canceling recording for %s', program)
]:
	i: 0(t)
	o: 44(try), 67(except)

nname: 0
n 0(rec_id)[program = self.selected
rec_id = program.recording_id
]:
	i: 
	o: 24(t), 144(f)

nname: 145
n 145(None)[return None
]:
	i: 44(JA), 77(JA), 67(f), 139(AE), 0(f)
	o: 

nname: 77
n 77(None)[error_title = _('Impossible to cancel recording')
message = _('This recording has already started. To stop it, close the EPG grid and press Stop.')
MessageWindow(message, error_title, button=None).show(timeout=5)
]:
	i: 67(t)
	o: 145(JA)

nname: 67
n 67(<dummy_ex3> EXC_MATCH SchedulerRecordingRunningError)[]:
	i: 24(except)
	o: 77(t), 145(f)

nname: 44
n 44(None)[WyRecord().scheduler.DeleteRecording(rec_id)
]:
	i: 24(try)
	o: 145(JA)

nname: 24
n 24(None)[log.info('Canceling recording for %s', program)
]:
	i: 0(t)
	o: 44(try), 67(except)

nname: 0
n 0(rec_id)[program = self.selected
rec_id = program.recording_id
]:
	i: 
	o: 24(t), 145(f)

nname: 145
n 145(None)[return None
]:
	i: 67(f), 0(f)
	o: 

nname: 67
n 67(None)[except SchedulerRecordingRunningError:
	error_title = _('Impossible to cancel recording')
	message = _('This recording has already started. To stop it, close the EPG grid and press Stop.')
	MessageWindow(message, error_title, button=None).show(timeout=5)
]:
	i: 24()
	o: 145(JA)

nname: 24
n 24(None)[log.info('Canceling recording for %s', program)
try:
	WyRecord().scheduler.DeleteRecording(rec_id)
]:
	i: 0(t)
	o: 67()

nname: 0
n 0(rec_id)[program = self.selected
rec_id = program.recording_id
]:
	i: 
	o: 24(t), 145(f)

nname: 145
n 145(None)[return None
]:
	i: 24(f), 0(f)
	o: 

nname: 24
n 24(None)[log.info('Canceling recording for %s', program)
try:
	WyRecord().scheduler.DeleteRecording(rec_id)
except SchedulerRecordingRunningError:
	error_title = _('Impossible to cancel recording')
	message = _('This recording has already started. To stop it, close the EPG grid and press Stop.')
	MessageWindow(message, error_title, button=None).show(timeout=5)
]:
	i: 0(t)
	o: 145(JA)

nname: 0
n 0(rec_id)[program = self.selected
rec_id = program.recording_id
]:
	i: 
	o: 24(t), 145(f)

nname: 0
n 0(None)[program = self.selected
rec_id = program.recording_id
if rec_id:
	log.info('Canceling recording for %s', program)
	try:
		WyRecord().scheduler.DeleteRecording(rec_id)
	except SchedulerRecordingRunningError:
		error_title = _('Impossible to cancel recording')
		message = _('This recording has already started. To stop it, close the EPG grid and press Stop.')
		MessageWindow(message, error_title, button=None).show(timeout=5)
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb768d68c>}
nname: 6
n 6(None)[__doc__ = 'TV Navigator/zaplist. Appears when the user\n    toggles away from the TV player.\n    '
player = None
toggleable = True
def __init__(self, name=_('Channels List Menu'), services=[], type='tv_navigator', player=None, fill_root=True):
	Navigator.__init__(self, name=name, choices=services, type=type, fill_root=fill_root, universe='tv')
	self.eventhandler = TvNavigatorEventHandler(self)
	self._all_channel_list = None
	self._program = None
	self._player = player
	self._getitems_keywords.update(dict(program_start_time=(lambda : self._program and seconds_to_hhmm(int(self._program.wymedia_resource['scheduledStartTime']))):
		pass
	return ''), program_stop_time=(lambda : self._program and seconds_to_hhmm(int(self._program.wymedia_resource['scheduledEndTime']))):
		pass
	return ''), program_remaining_time=(lambda : self._program and self._player and seconds_to_hhmm_utc(min(int(self._program.wymedia_resource['scheduledEndTime']) - self._player.real_utc_time, self._program['duration']))):
		pass
	return ''), program_elapsed_time=(lambda : self._program and self._player and seconds_to_hhmm_utc(max(self._player.real_utc_time - int(self._program.wymedia_resource['scheduledStartTime']), 0))):
		pass
	return ''), program_duration=(lambda : self._program and seconds_to_hhmm_utc(self._program['duration'])):
		pass
	return ''), program_description=(lambda : self._program and self._program.short_description + '\n' + self._program.description):
		pass
	return ''), program_content_type=(lambda : self._program and self._program.content_type):
		pass
	return ''), live_time=(lambda : self._player and self._player['live_time']):
		pass
	return ''), record_timeshift_programbar=self._get_program_bar, recording_info=self._get_recording_info))
	self.tasks.update({'show_help_left': Task(self._show_help, side=-1), 'show_help_right': Task(self._show_help, side=1)})
	return None

def _show_help(self, side=0):
	if config.user_config['base']['help_banner']:
		if config.user_config['base']['help_banner'] == 1:
			louie_send('hide_help', sender=self)
		if not side:
			louie_send('show_help', sender=self)
		else:
			if side == 1:
				louie_send('show_help_right', sender=self)
			else:
				if side == -1:
					louie_send('show_help_left', sender=self)
		self.hide_help()

def show_help_left(self):
	if self.show_help_banner:
		self.tasks['show_help_left'].start(0.5)

def show_help_right(self):
	if self.show_help_banner:
		self.tasks['show_help_right'].start(0.5)

def _get_program_bar(self):
	sel = self.selected
	program = None
	if isinstance(sel, ChannelItem):
		service = sel
		l = self.get_item_list('preview_list')
		if not(len(l) > 0 and l[0]):
			pass
		program = None
	else:
		if isinstance(sel, ProgramItem):
			service = self._history[-1]['selected']
			program = sel
		else:
			if isinstance(sel, ScheduledRecordRootItem):
				program = None
	res = dict()
	if self._player is None or program in (None, EmptyProgramItem()):
		res['program_begin'] = 0
		res['program_end'] = 100
		res['direct'] = 0
		res['live'] = 0
	else:
		_lc = self._player.live_controller
		res['program_begin'] = int(program['scheduledStartTime'])
		res['program_end'] = int(program['scheduledEndTime'])
		time_info = _lc.default_renderer.getTimeInfo()
		res['direct'] = time_info.max_available_time
		res['live'] = time_info.current_time
		if self._player.selected['serviceId'] == service['serviceId']:
			res['timeshift_begin'] = time_info.min_available_time
			res['timeshift_end'] = res['direct']
			if self._player._record:
				res['record_begin'] = self._player._record.start_time
				res['record_end'] = self._player._record.stop_time
			else:
				res['record_begin'] = None
				res['record_end'] = None
		else:
			res['timeshift_begin'] = None
			res['timeshift_end'] = None
	return res

def _get_recording_info(self):
	for live in WyRecord().live_controller.getRunningLiveList():
		if live.isRecording():
			service_id = live.serviceid
			channel = self._all_channel_list.get_channel_from_service_id(service_id)
			return channel.name
			continue
	return u''

def root_getter(self):
	tv_root = TVRootItem()
	_list = []
	_list.append(ScheduledRecordRootItem(self, parent=tv_root))
	self._all_channel_list = tv_root.get_acl(self)
	_list.append(self._all_channel_list)
	_list.extend(list(tv_root.browse_favorites(self)))
	return _list

def select(self, item, list_name=None):
	ret = Menu.select(self, item, list_name)
	if ret:
		louie_send('hide_preview', sender=self)
		if isinstance(self.selected, ProgramItem):
			self._program = self.selected
		else:
			self._program = None
		self.build_preview()
	return ret

def execute_selected(self):
	item = self.selected
	player = self._player
	if isinstance(item, Playlist):
		self.browse_selected()
		return None
	if item == player.selected or player.can_zap():
		if isinstance(item, DirItem):
			item.browse()[0].execute()
		else:
			Navigator.execute_selected(self)
	else:
		title = _("Can't change channels")
		message = _('A recording is in progress. Stop it before zapping.')
		MessageWindow(message, title, button=None).show(timeout=5)
	return None

def _build_preview(self):
	sel = self.selected
	if not self._history:
		self._refresh_root()
	sel = self.selected
	item_list = None
	_refresh_program_bar = False
	if isinstance(sel, ProgramItem):
		louie_send('empty_preview', self)
		selective_gui_updater('program_start_time', 'program_stop_time', 'program_remaining_time', 'program_elapsed_time', 'program_duration', 'program_content_type', 'program_description', 'record_timeshift_programbar')((lambda self: None))(self)
		return True
	else:
		if isinstance(sel, ChannelItem):
			try:
				item_list = sel.browse(self._player.real_utc_time, limit=4)
			except:
				item_list = sel.browse()
			if len(item_list) == 0:
				item_list = [EmptyProgramItem()]
			_refresh_program_bar = True
		else:
			item_list = sel.browse()
			if len(item_list) == 0:
				if isinstance(self.selected, ScheduledRecordRootItem):
					item_list = [EmptyScheduledItem()]
				else:
					item_list = [EmptyItem()]
	self.set_items(item_list[:4], list_name='preview_list', position=-1)
	louie_send('show_preview', self)
	if _refresh_program_bar:
		louie_send('record_timeshift_programbar', sender=self, value=self['record_timeshift_programbar'])
	louie_send('not_empty_preview', self)
	return True

def browse_selected(self):
	changed = False
	args = list()
	kw = dict()
	preview_list = self.get_item_list('preview_list')
	_sel = self.selected
	if isinstance(_sel, ProgramItem):
		louie_send('main_list_not_browse', sender=self)
		return None
	else:
		if len(preview_list) < 2 and preview_list[0] in [EmptyProgramItem(), EmptyItem(), EmptyScheduledItem()]:
			return None
		else:
			if isinstance(_sel, ChannelItem):
				louie_send('show_program_info', sender=self)
				louie_send('show_program_bar', sender=self)
				louie_send('hide_preview_program_bar', sender=self)
				louie_send('show_program_description', sender=self)
				self.show_help_left()
				kw['pad'] = False
				kw['start_time'] = self._player.real_utc_time
				selective_gui_updater('record_timeshift_programbar')((lambda self: None))(self)
			else:
				if isinstance(_sel, (AllChannelsList, Playlist)):
					self._favorites_list = _sel
					louie_send('show_preview_program_bar', sender=self)
					louie_send('hide_program_bar', sender=self)
					self.show_help()
					selective_gui_updater('record_timeshift_programbar')((lambda self: None))(self)
				else:
					if isinstance(_sel, ScheduledRecordRootItem):
						_schedule_menu = ScheduledRecordNavigator(name=_sel.name)
						louie_send('hide_program_bar', sender=self)
						louie_send('hide_preview_program_bar', sender=self)
						_schedule_menu.show()
						return None
	Navigator.browse_selected(self, action_override=True, *args, **kw)
	if isinstance(self.selected, ProgramItem):
		self._program = self.selected
	else:
		self._program = None
	if changed:
		self.universe = 'tv'
	return None

def browse_previous(self):
	try:
		last_context = self._history.pop()
		if hasattr(self.selected, 'unwatch'):
			self.selected.unwatch(self._selection_changed)
	except IndexError:
		if self.selected and self.selected.parent:
			self.go_to_item(self.selected.parent, 'event_left')
			louie_send('on_root', sender=self)
	return None
	if last_context is not None:
		louie_send('hide_program_bar', sender=self)
		louie_send('event_left', sender=self)
		_set_prev_content = selective_gui_updater('parent_item_name', 'parent_icon_name')()
		if self.choices:
			pass
		self.tasks['set_prev_content'] = Task(_set_prev_content, self, [EmptyProgramItem()])
		self.tasks['set_prev_content'].start(config.HMI_BASE['navigator_listing_delay'])
		return True
	return False

def select_service(self, playlist, service):
	self._history.empty()
	root = self.root_getter()
	position = root.index(playlist)
	playlist = root[position]
	self._history.append(dict(position=position, selected=playlist, items=root))
	_playlist = playlist.browse()
	try:
		ind = _playlist.index(service)
	except ValueError, e:
		ind = 0
	self.set_items(_playlist, position=ind)
	self.build_preview()
	louie_send('hide_program_info', sender=self)
	louie_send('show_preview_program_bar', sender=self)
	louie_send('hide_program_bar', sender=self)

select_program = gui_updater()
def select_schedule_recordings(self):
	self._history.empty()
	root = self.root_getter()
	self.set_items(root)
	self._build_preview()
	self.browse_selected()

on_foreground = selective_gui_updater('parent_item_name', 'parent_icon_name', 'recording_info')()
def display_epg(self):
	self._player.display_epg()

_reload_func = back_root_if_error()
def action_info(self):
	item = self.selected
	if isinstance(item, ChannelItem):
		menu = ChannelInfoMenu(item)
	else:
		if isinstance(item, AllChannelsList):
			menu = TVInfoMenu(item)
		else:
			if isinstance(item, ScheduledRecordRootItem):
				menu = ScheduledRecordRootInfoMenu(item)
			else:
				log.error("Information window for %s (%s) isn't supported", item, type(item))
	menu.show()

def action_record(self):
	item = self.selected
	if isinstance(item, ProgramItem):
		if item.recording_id:
			self.cancel_record_selected()
		else:
			self.record_selected()
		self.set_items(item.parent.browse(self._player.real_utc_time), 'main_list', position=self.selected_pos)
	else:
		self._error_spawner()

def action_stop(self):
	item = self.selected
	if isinstance(item, ProgramItem) and item.recording_id:
		self.cancel_record_selected()
		self.set_items(item.parent.browse(self._player.real_utc_time), 'main_list', position=self.selected_pos)
	else:
		self._error_spawner()

def record_selected(self):
	program = self.selected
	now = int(time())
	if program.end_time > now:
		start_time = max(now, program.start_time)
		end_time = min(program.end_time, start_time + 21600)
		channel = program.parent
		chan_id = int(channel['serviceId'])
		favorite_name = channel.parent.name
		values = {'channel': channel.name, 'title': program.name, 'date': strftime('%Y/%m/%d', localtime(start_time)), 'start_time': seconds_to_hhmm(start_time), 'end_time': seconds_to_hhmm(end_time)}
		record_name = EPG_RECORDING_NAME_PATTERN % values
		try:
			WyRecord().scheduler.ScheduleRecording(chan_id, start_time, end_time, record_name, program_id=program.id, favorite=favorite_name)
			louie_send('update_record')
		except SchedulerConflictWithInstantRecordError, e:
			louie_send('update_record', sender=None)
			conflicting_rec = e.conflict.getAllRecInConflict()[0]
			message_pattern = _('An instant recording on %(channel)s will be stopped when this recording starts.')
			message = message_pattern % {'name': ellipsize(conflicting_rec.name, 40), 'start_time': seconds_to_hhmm(conflicting_rec.start_time), 'channel': conflicting_rec.service_name}
			title = _('Conflict with an instant recording')
			MessageWindow(message, title, button=None).show(timeout=5)
		except:
			except SchedulerConflictError, e:
				conflicting_rec = e.conflict.getAllRecInConflict()[0]
				message_pattern = _('The recording you are attempting to schedule conflicts with "%(name)s", starting at %(start_time)s on %(channel)s.')
				message = message_pattern % {'name': ellipsize(conflicting_rec.name, 40), 'start_time': seconds_to_hhmm(conflicting_rec.start_time), 'channel': conflicting_rec.service_name}
				title = _('Recording scheduler error')
				MessageWindow(message, title, button=None).show(timeout=5)
			except:
				except SchedulerError, e:
					log.error("Can't start recording due to %s", e)
					title = _('Recording scheduler error')
					message = 'Unable to schedule your recording. Sorry.'
					MessageWindow(message, title, button=None).show(timeout=5)
	else:
		message = _('The program is over. You cannot record it.')
		title = _('Program already over')
		win = MessageWindow(message, title, button=None)
		win.show(timeout=5)
	return None

def cancel_record_selected(self):
	program = self.selected
	rec_id = program.recording_id
	if rec_id:
		log.info('Canceling recording for %s', program)
		try:
			WyRecord().scheduler.DeleteRecording(rec_id)
		except SchedulerRecordingRunningError:
			error_title = _('Impossible to cancel recording')
			message = _('This recording has already started. To stop it, close the EPG grid and press Stop.')
			MessageWindow(message, error_title, button=None).show(timeout=5)
	return None

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb7685cec>}
nname: 0
n 0(None)[from __future__ import absolute_import
from time import time, strftime, localtime
from peewee.messages import send as louie_send
from peewee.debug import GET_LOGGER
from peewee.misc_utils import MetaSingleton
from peewee.notifier import Task
from peewee.formatters import ellipsize, seconds_to_hhmm, seconds_to_hhmm_utc
from wyrecord import WyRecord, SchedulerConflictError, SchedulerConflictWithInstantRecordError, SchedulerRecordingRunningError, SchedulerError
import pygui.config as config
from pygui.eventmanager.menus import TvNavigatorEventHandler
from pygui.item.scheduledrecord import ScheduledRecordRootItem, ScheduledRecordItem
from pygui.item.mediaitem.core import TVRootItem, DirItem, ChannelItem, AllChannelsList, Playlist, ProgramItem
from pygui.item.mediaitem.progressive_result import WindowedItemList
from pygui.item.core import Item
from pygui.menu import gui_updater, selective_gui_updater
from pygui.window import MessageWindow
from pygui.menu.menu.core import Menu
from pygui.menu.menu.info import ChannelInfoMenu, TVInfoMenu, ScheduledRecordRootInfoMenu
from pygui.menu.menu.navigators import Navigator, EmptyItem, back_root_if_error
from pygui.menu.menu.tv import ScheduledRecordNavigator
from pygui.menu.menu.tv.epg_grid import EPG_RECORDING_NAME_PATTERN
from pygui.shared import pygui_globs
log = GET_LOGGER(__name__)
class EmptyScheduledItem(Item):
	__doc__ = ' A simple item to put in empty places to signal it '
	__metaclass__ = MetaSingleton
	locked = False
	hidden = False
	def __init__(self):
		Item.__init__(self, _('No scheduled recordings'), type_='empty', display_type='empty')



class EmptyProgramItem(Item):
	__doc__ = ' A simple item to put in empty places to signal it '
	__metaclass__ = MetaSingleton
	locked = False
	hidden = False
	def __init__(self):
		Item.__init__(self, _('EPG not available'), type_='empty', display_type='empty')



class TvNavigatorMenu(Navigator):
	__doc__ = 'TV Navigator/zaplist. Appears when the user\n    toggles away from the TV player.\n    '
	player = None
	toggleable = True
	def __init__(self, name=_('Channels List Menu'), services=[], type='tv_navigator', player=None, fill_root=True):
		Navigator.__init__(self, name=name, choices=services, type=type, fill_root=fill_root, universe='tv')
		self.eventhandler = TvNavigatorEventHandler(self)
		self._all_channel_list = None
		self._program = None
		self._player = player
		self._getitems_keywords.update(dict(program_start_time=(lambda : self._program and seconds_to_hhmm(int(self._program.wymedia_resource['scheduledStartTime']))):
			pass
		return ''), program_stop_time=(lambda : self._program and seconds_to_hhmm(int(self._program.wymedia_resource['scheduledEndTime']))):
			pass
		return ''), program_remaining_time=(lambda : self._program and self._player and seconds_to_hhmm_utc(min(int(self._program.wymedia_resource['scheduledEndTime']) - self._player.real_utc_time, self._program['duration']))):
			pass
		return ''), program_elapsed_time=(lambda : self._program and self._player and seconds_to_hhmm_utc(max(self._player.real_utc_time - int(self._program.wymedia_resource['scheduledStartTime']), 0))):
			pass
		return ''), program_duration=(lambda : self._program and seconds_to_hhmm_utc(self._program['duration'])):
			pass
		return ''), program_description=(lambda : self._program and self._program.short_description + '\n' + self._program.description):
			pass
		return ''), program_content_type=(lambda : self._program and self._program.content_type):
			pass
		return ''), live_time=(lambda : self._player and self._player['live_time']):
			pass
		return ''), record_timeshift_programbar=self._get_program_bar, recording_info=self._get_recording_info))
		self.tasks.update({'show_help_left': Task(self._show_help, side=-1), 'show_help_right': Task(self._show_help, side=1)})
		return None

	def _show_help(self, side=0):
		if config.user_config['base']['help_banner']:
			if config.user_config['base']['help_banner'] == 1:
				louie_send('hide_help', sender=self)
			if not side:
				louie_send('show_help', sender=self)
			else:
				if side == 1:
					louie_send('show_help_right', sender=self)
				else:
					if side == -1:
						louie_send('show_help_left', sender=self)
			self.hide_help()

	def show_help_left(self):
		if self.show_help_banner:
			self.tasks['show_help_left'].start(0.5)

	def show_help_right(self):
		if self.show_help_banner:
			self.tasks['show_help_right'].start(0.5)

	def _get_program_bar(self):
		sel = self.selected
		program = None
		if isinstance(sel, ChannelItem):
			service = sel
			l = self.get_item_list('preview_list')
			if not(len(l) > 0 and l[0]):
				pass
			program = None
		else:
			if isinstance(sel, ProgramItem):
				service = self._history[-1]['selected']
				program = sel
			else:
				if isinstance(sel, ScheduledRecordRootItem):
					program = None
		res = dict()
		if self._player is None or program in (None, EmptyProgramItem()):
			res['program_begin'] = 0
			res['program_end'] = 100
			res['direct'] = 0
			res['live'] = 0
		else:
			_lc = self._player.live_controller
			res['program_begin'] = int(program['scheduledStartTime'])
			res['program_end'] = int(program['scheduledEndTime'])
			time_info = _lc.default_renderer.getTimeInfo()
			res['direct'] = time_info.max_available_time
			res['live'] = time_info.current_time
			if self._player.selected['serviceId'] == service['serviceId']:
				res['timeshift_begin'] = time_info.min_available_time
				res['timeshift_end'] = res['direct']
				if self._player._record:
					res['record_begin'] = self._player._record.start_time
					res['record_end'] = self._player._record.stop_time
				else:
					res['record_begin'] = None
					res['record_end'] = None
			else:
				res['timeshift_begin'] = None
				res['timeshift_end'] = None
		return res

	def _get_recording_info(self):
		for live in WyRecord().live_controller.getRunningLiveList():
			if live.isRecording():
				service_id = live.serviceid
				channel = self._all_channel_list.get_channel_from_service_id(service_id)
				return channel.name
				continue
		return u''

	def root_getter(self):
		tv_root = TVRootItem()
		_list = []
		_list.append(ScheduledRecordRootItem(self, parent=tv_root))
		self._all_channel_list = tv_root.get_acl(self)
		_list.append(self._all_channel_list)
		_list.extend(list(tv_root.browse_favorites(self)))
		return _list

	def select(self, item, list_name=None):
		ret = Menu.select(self, item, list_name)
		if ret:
			louie_send('hide_preview', sender=self)
			if isinstance(self.selected, ProgramItem):
				self._program = self.selected
			else:
				self._program = None
			self.build_preview()
		return ret

	def execute_selected(self):
		item = self.selected
		player = self._player
		if isinstance(item, Playlist):
			self.browse_selected()
			return None
		if item == player.selected or player.can_zap():
			if isinstance(item, DirItem):
				item.browse()[0].execute()
			else:
				Navigator.execute_selected(self)
		else:
			title = _("Can't change channels")
			message = _('A recording is in progress. Stop it before zapping.')
			MessageWindow(message, title, button=None).show(timeout=5)
		return None

	def _build_preview(self):
		sel = self.selected
		if not self._history:
			self._refresh_root()
		sel = self.selected
		item_list = None
		_refresh_program_bar = False
		if isinstance(sel, ProgramItem):
			louie_send('empty_preview', self)
			selective_gui_updater('program_start_time', 'program_stop_time', 'program_remaining_time', 'program_elapsed_time', 'program_duration', 'program_content_type', 'program_description', 'record_timeshift_programbar')((lambda self: None))(self)
			return True
		else:
			if isinstance(sel, ChannelItem):
				try:
					item_list = sel.browse(self._player.real_utc_time, limit=4)
				except:
					item_list = sel.browse()
				if len(item_list) == 0:
					item_list = [EmptyProgramItem()]
				_refresh_program_bar = True
			else:
				item_list = sel.browse()
				if len(item_list) == 0:
					if isinstance(self.selected, ScheduledRecordRootItem):
						item_list = [EmptyScheduledItem()]
					else:
						item_list = [EmptyItem()]
		self.set_items(item_list[:4], list_name='preview_list', position=-1)
		louie_send('show_preview', self)
		if _refresh_program_bar:
			louie_send('record_timeshift_programbar', sender=self, value=self['record_timeshift_programbar'])
		louie_send('not_empty_preview', self)
		return True

	def browse_selected(self):
		changed = False
		args = list()
		kw = dict()
		preview_list = self.get_item_list('preview_list')
		_sel = self.selected
		if isinstance(_sel, ProgramItem):
			louie_send('main_list_not_browse', sender=self)
			return None
		else:
			if len(preview_list) < 2 and preview_list[0] in [EmptyProgramItem(), EmptyItem(), EmptyScheduledItem()]:
				return None
			else:
				if isinstance(_sel, ChannelItem):
					louie_send('show_program_info', sender=self)
					louie_send('show_program_bar', sender=self)
					louie_send('hide_preview_program_bar', sender=self)
					louie_send('show_program_description', sender=self)
					self.show_help_left()
					kw['pad'] = False
					kw['start_time'] = self._player.real_utc_time
					selective_gui_updater('record_timeshift_programbar')((lambda self: None))(self)
				else:
					if isinstance(_sel, (AllChannelsList, Playlist)):
						self._favorites_list = _sel
						louie_send('show_preview_program_bar', sender=self)
						louie_send('hide_program_bar', sender=self)
						self.show_help()
						selective_gui_updater('record_timeshift_programbar')((lambda self: None))(self)
					else:
						if isinstance(_sel, ScheduledRecordRootItem):
							_schedule_menu = ScheduledRecordNavigator(name=_sel.name)
							louie_send('hide_program_bar', sender=self)
							louie_send('hide_preview_program_bar', sender=self)
							_schedule_menu.show()
							return None
		Navigator.browse_selected(self, action_override=True, *args, **kw)
		if isinstance(self.selected, ProgramItem):
			self._program = self.selected
		else:
			self._program = None
		if changed:
			self.universe = 'tv'
		return None

	def browse_previous(self):
		try:
			last_context = self._history.pop()
			if hasattr(self.selected, 'unwatch'):
				self.selected.unwatch(self._selection_changed)
		except IndexError:
			if self.selected and self.selected.parent:
				self.go_to_item(self.selected.parent, 'event_left')
				louie_send('on_root', sender=self)
		return None
		if last_context is not None:
			louie_send('hide_program_bar', sender=self)
			louie_send('event_left', sender=self)
			_set_prev_content = selective_gui_updater('parent_item_name', 'parent_icon_name')()
			if self.choices:
				pass
			self.tasks['set_prev_content'] = Task(_set_prev_content, self, [EmptyProgramItem()])
			self.tasks['set_prev_content'].start(config.HMI_BASE['navigator_listing_delay'])
			return True
		return False

	def select_service(self, playlist, service):
		self._history.empty()
		root = self.root_getter()
		position = root.index(playlist)
		playlist = root[position]
		self._history.append(dict(position=position, selected=playlist, items=root))
		_playlist = playlist.browse()
		try:
			ind = _playlist.index(service)
		except ValueError, e:
			ind = 0
		self.set_items(_playlist, position=ind)
		self.build_preview()
		louie_send('hide_program_info', sender=self)
		louie_send('show_preview_program_bar', sender=self)
		louie_send('hide_program_bar', sender=self)

	select_program = gui_updater()
	def select_schedule_recordings(self):
		self._history.empty()
		root = self.root_getter()
		self.set_items(root)
		self._build_preview()
		self.browse_selected()

	on_foreground = selective_gui_updater('parent_item_name', 'parent_icon_name', 'recording_info')()
	def display_epg(self):
		self._player.display_epg()

	_reload_func = back_root_if_error()
	def action_info(self):
		item = self.selected
		if isinstance(item, ChannelItem):
			menu = ChannelInfoMenu(item)
		else:
			if isinstance(item, AllChannelsList):
				menu = TVInfoMenu(item)
			else:
				if isinstance(item, ScheduledRecordRootItem):
					menu = ScheduledRecordRootInfoMenu(item)
				else:
					log.error("Information window for %s (%s) isn't supported", item, type(item))
		menu.show()

	def action_record(self):
		item = self.selected
		if isinstance(item, ProgramItem):
			if item.recording_id:
				self.cancel_record_selected()
			else:
				self.record_selected()
			self.set_items(item.parent.browse(self._player.real_utc_time), 'main_list', position=self.selected_pos)
		else:
			self._error_spawner()

	def action_stop(self):
		item = self.selected
		if isinstance(item, ProgramItem) and item.recording_id:
			self.cancel_record_selected()
			self.set_items(item.parent.browse(self._player.real_utc_time), 'main_list', position=self.selected_pos)
		else:
			self._error_spawner()

	def record_selected(self):
		program = self.selected
		now = int(time())
		if program.end_time > now:
			start_time = max(now, program.start_time)
			end_time = min(program.end_time, start_time + 21600)
			channel = program.parent
			chan_id = int(channel['serviceId'])
			favorite_name = channel.parent.name
			values = {'channel': channel.name, 'title': program.name, 'date': strftime('%Y/%m/%d', localtime(start_time)), 'start_time': seconds_to_hhmm(start_time), 'end_time': seconds_to_hhmm(end_time)}
			record_name = EPG_RECORDING_NAME_PATTERN % values
			try:
				WyRecord().scheduler.ScheduleRecording(chan_id, start_time, end_time, record_name, program_id=program.id, favorite=favorite_name)
				louie_send('update_record')
			except SchedulerConflictWithInstantRecordError, e:
				louie_send('update_record', sender=None)
				conflicting_rec = e.conflict.getAllRecInConflict()[0]
				message_pattern = _('An instant recording on %(channel)s will be stopped when this recording starts.')
				message = message_pattern % {'name': ellipsize(conflicting_rec.name, 40), 'start_time': seconds_to_hhmm(conflicting_rec.start_time), 'channel': conflicting_rec.service_name}
				title = _('Conflict with an instant recording')
				MessageWindow(message, title, button=None).show(timeout=5)
			except:
				except SchedulerConflictError, e:
					conflicting_rec = e.conflict.getAllRecInConflict()[0]
					message_pattern = _('The recording you are attempting to schedule conflicts with "%(name)s", starting at %(start_time)s on %(channel)s.')
					message = message_pattern % {'name': ellipsize(conflicting_rec.name, 40), 'start_time': seconds_to_hhmm(conflicting_rec.start_time), 'channel': conflicting_rec.service_name}
					title = _('Recording scheduler error')
					MessageWindow(message, title, button=None).show(timeout=5)
				except:
					except SchedulerError, e:
						log.error("Can't start recording due to %s", e)
						title = _('Recording scheduler error')
						message = 'Unable to schedule your recording. Sorry.'
						MessageWindow(message, title, button=None).show(timeout=5)
		else:
			message = _('The program is over. You cannot record it.')
			title = _('Program already over')
			win = MessageWindow(message, title, button=None)
			win.show(timeout=5)
		return None

	def cancel_record_selected(self):
		program = self.selected
		rec_id = program.recording_id
		if rec_id:
			log.info('Canceling recording for %s', program)
			try:
				WyRecord().scheduler.DeleteRecording(rec_id)
			except SchedulerRecordingRunningError:
				error_title = _('Impossible to cancel recording')
				message = _('This recording has already started. To stop it, close the EPG grid and press Stop.')
				MessageWindow(message, error_title, button=None).show(timeout=5)
		return None



]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76f0ccc>}
from __future__ import absolute_import
from time import time, strftime, localtime
from peewee.messages import send as louie_send
from peewee.debug import GET_LOGGER
from peewee.misc_utils import MetaSingleton
from peewee.notifier import Task
from peewee.formatters import ellipsize, seconds_to_hhmm, seconds_to_hhmm_utc
from wyrecord import WyRecord, SchedulerConflictError, SchedulerConflictWithInstantRecordError, SchedulerRecordingRunningError, SchedulerError
import pygui.config as config
from pygui.eventmanager.menus import TvNavigatorEventHandler
from pygui.item.scheduledrecord import ScheduledRecordRootItem, ScheduledRecordItem
from pygui.item.mediaitem.core import TVRootItem, DirItem, ChannelItem, AllChannelsList, Playlist, ProgramItem
from pygui.item.mediaitem.progressive_result import WindowedItemList
from pygui.item.core import Item
from pygui.menu import gui_updater, selective_gui_updater
from pygui.window import MessageWindow
from pygui.menu.menu.core import Menu
from pygui.menu.menu.info import ChannelInfoMenu, TVInfoMenu, ScheduledRecordRootInfoMenu
from pygui.menu.menu.navigators import Navigator, EmptyItem, back_root_if_error
from pygui.menu.menu.tv import ScheduledRecordNavigator
from pygui.menu.menu.tv.epg_grid import EPG_RECORDING_NAME_PATTERN
from pygui.shared import pygui_globs
log = GET_LOGGER(__name__)
class EmptyScheduledItem(Item):
	__doc__ = ' A simple item to put in empty places to signal it '
	__metaclass__ = MetaSingleton
	locked = False
	hidden = False
	def __init__(self):
		Item.__init__(self, _('No scheduled recordings'), type_='empty', display_type='empty')



class EmptyProgramItem(Item):
	__doc__ = ' A simple item to put in empty places to signal it '
	__metaclass__ = MetaSingleton
	locked = False
	hidden = False
	def __init__(self):
		Item.__init__(self, _('EPG not available'), type_='empty', display_type='empty')



class TvNavigatorMenu(Navigator):
	__doc__ = 'TV Navigator/zaplist. Appears when the user\n    toggles away from the TV player.\n    '
	player = None
	toggleable = True
	def __init__(self, name=_('Channels List Menu'), services=[], type='tv_navigator', player=None, fill_root=True):
		Navigator.__init__(self, name=name, choices=services, type=type, fill_root=fill_root, universe='tv')
		self.eventhandler = TvNavigatorEventHandler(self)
		self._all_channel_list = None
		self._program = None
		self._player = player
		self._getitems_keywords.update(dict(program_start_time=(lambda : self._program and seconds_to_hhmm(int(self._program.wymedia_resource['scheduledStartTime']))):
			pass
		return ''), program_stop_time=(lambda : self._program and seconds_to_hhmm(int(self._program.wymedia_resource['scheduledEndTime']))):
			pass
		return ''), program_remaining_time=(lambda : self._program and self._player and seconds_to_hhmm_utc(min(int(self._program.wymedia_resource['scheduledEndTime']) - self._player.real_utc_time, self._program['duration']))):
			pass
		return ''), program_elapsed_time=(lambda : self._program and self._player and seconds_to_hhmm_utc(max(self._player.real_utc_time - int(self._program.wymedia_resource['scheduledStartTime']), 0))):
			pass
		return ''), program_duration=(lambda : self._program and seconds_to_hhmm_utc(self._program['duration'])):
			pass
		return ''), program_description=(lambda : self._program and self._program.short_description + '\n' + self._program.description):
			pass
		return ''), program_content_type=(lambda : self._program and self._program.content_type):
			pass
		return ''), live_time=(lambda : self._player and self._player['live_time']):
			pass
		return ''), record_timeshift_programbar=self._get_program_bar, recording_info=self._get_recording_info))
		self.tasks.update({'show_help_left': Task(self._show_help, side=-1), 'show_help_right': Task(self._show_help, side=1)})
		return None

	def _show_help(self, side=0):
		if config.user_config['base']['help_banner']:
			if config.user_config['base']['help_banner'] == 1:
				louie_send('hide_help', sender=self)
			if not side:
				louie_send('show_help', sender=self)
			else:
				if side == 1:
					louie_send('show_help_right', sender=self)
				else:
					if side == -1:
						louie_send('show_help_left', sender=self)
			self.hide_help()

	def show_help_left(self):
		if self.show_help_banner:
			self.tasks['show_help_left'].start(0.5)

	def show_help_right(self):
		if self.show_help_banner:
			self.tasks['show_help_right'].start(0.5)

	def _get_program_bar(self):
		sel = self.selected
		program = None
		if isinstance(sel, ChannelItem):
			service = sel
			l = self.get_item_list('preview_list')
			if not(len(l) > 0 and l[0]):
				pass
			program = None
		else:
			if isinstance(sel, ProgramItem):
				service = self._history[-1]['selected']
				program = sel
			else:
				if isinstance(sel, ScheduledRecordRootItem):
					program = None
		res = dict()
		if self._player is None or program in (None, EmptyProgramItem()):
			res['program_begin'] = 0
			res['program_end'] = 100
			res['direct'] = 0
			res['live'] = 0
		else:
			_lc = self._player.live_controller
			res['program_begin'] = int(program['scheduledStartTime'])
			res['program_end'] = int(program['scheduledEndTime'])
			time_info = _lc.default_renderer.getTimeInfo()
			res['direct'] = time_info.max_available_time
			res['live'] = time_info.current_time
			if self._player.selected['serviceId'] == service['serviceId']:
				res['timeshift_begin'] = time_info.min_available_time
				res['timeshift_end'] = res['direct']
				if self._player._record:
					res['record_begin'] = self._player._record.start_time
					res['record_end'] = self._player._record.stop_time
				else:
					res['record_begin'] = None
					res['record_end'] = None
			else:
				res['timeshift_begin'] = None
				res['timeshift_end'] = None
		return res

	def _get_recording_info(self):
		for live in WyRecord().live_controller.getRunningLiveList():
			if live.isRecording():
				service_id = live.serviceid
				channel = self._all_channel_list.get_channel_from_service_id(service_id)
				return channel.name
				continue
		return u''

	def root_getter(self):
		tv_root = TVRootItem()
		_list = []
		_list.append(ScheduledRecordRootItem(self, parent=tv_root))
		self._all_channel_list = tv_root.get_acl(self)
		_list.append(self._all_channel_list)
		_list.extend(list(tv_root.browse_favorites(self)))
		return _list

	def select(self, item, list_name=None):
		ret = Menu.select(self, item, list_name)
		if ret:
			louie_send('hide_preview', sender=self)
			if isinstance(self.selected, ProgramItem):
				self._program = self.selected
			else:
				self._program = None
			self.build_preview()
		return ret

	def execute_selected(self):
		item = self.selected
		player = self._player
		if isinstance(item, Playlist):
			self.browse_selected()
			return None
		if item == player.selected or player.can_zap():
			if isinstance(item, DirItem):
				item.browse()[0].execute()
			else:
				Navigator.execute_selected(self)
		else:
			title = _("Can't change channels")
			message = _('A recording is in progress. Stop it before zapping.')
			MessageWindow(message, title, button=None).show(timeout=5)
		return None

	def _build_preview(self):
		sel = self.selected
		if not self._history:
			self._refresh_root()
		sel = self.selected
		item_list = None
		_refresh_program_bar = False
		if isinstance(sel, ProgramItem):
			louie_send('empty_preview', self)
			selective_gui_updater('program_start_time', 'program_stop_time', 'program_remaining_time', 'program_elapsed_time', 'program_duration', 'program_content_type', 'program_description', 'record_timeshift_programbar')((lambda self: None))(self)
			return True
		else:
			if isinstance(sel, ChannelItem):
				try:
					item_list = sel.browse(self._player.real_utc_time, limit=4)
				except:
					item_list = sel.browse()
				if len(item_list) == 0:
					item_list = [EmptyProgramItem()]
				_refresh_program_bar = True
			else:
				item_list = sel.browse()
				if len(item_list) == 0:
					if isinstance(self.selected, ScheduledRecordRootItem):
						item_list = [EmptyScheduledItem()]
					else:
						item_list = [EmptyItem()]
		self.set_items(item_list[:4], list_name='preview_list', position=-1)
		louie_send('show_preview', self)
		if _refresh_program_bar:
			louie_send('record_timeshift_programbar', sender=self, value=self['record_timeshift_programbar'])
		louie_send('not_empty_preview', self)
		return True

	def browse_selected(self):
		changed = False
		args = list()
		kw = dict()
		preview_list = self.get_item_list('preview_list')
		_sel = self.selected
		if isinstance(_sel, ProgramItem):
			louie_send('main_list_not_browse', sender=self)
			return None
		else:
			if len(preview_list) < 2 and preview_list[0] in [EmptyProgramItem(), EmptyItem(), EmptyScheduledItem()]:
				return None
			else:
				if isinstance(_sel, ChannelItem):
					louie_send('show_program_info', sender=self)
					louie_send('show_program_bar', sender=self)
					louie_send('hide_preview_program_bar', sender=self)
					louie_send('show_program_description', sender=self)
					self.show_help_left()
					kw['pad'] = False
					kw['start_time'] = self._player.real_utc_time
					selective_gui_updater('record_timeshift_programbar')((lambda self: None))(self)
				else:
					if isinstance(_sel, (AllChannelsList, Playlist)):
						self._favorites_list = _sel
						louie_send('show_preview_program_bar', sender=self)
						louie_send('hide_program_bar', sender=self)
						self.show_help()
						selective_gui_updater('record_timeshift_programbar')((lambda self: None))(self)
					else:
						if isinstance(_sel, ScheduledRecordRootItem):
							_schedule_menu = ScheduledRecordNavigator(name=_sel.name)
							louie_send('hide_program_bar', sender=self)
							louie_send('hide_preview_program_bar', sender=self)
							_schedule_menu.show()
							return None
		Navigator.browse_selected(self, action_override=True, *args, **kw)
		if isinstance(self.selected, ProgramItem):
			self._program = self.selected
		else:
			self._program = None
		if changed:
			self.universe = 'tv'
		return None

	def browse_previous(self):
		try:
			last_context = self._history.pop()
			if hasattr(self.selected, 'unwatch'):
				self.selected.unwatch(self._selection_changed)
		except IndexError:
			if self.selected and self.selected.parent:
				self.go_to_item(self.selected.parent, 'event_left')
				louie_send('on_root', sender=self)
		return None
		if last_context is not None:
			louie_send('hide_program_bar', sender=self)
			louie_send('event_left', sender=self)
			_set_prev_content = selective_gui_updater('parent_item_name', 'parent_icon_name')()
			if self.choices:
				pass
			self.tasks['set_prev_content'] = Task(_set_prev_content, self, [EmptyProgramItem()])
			self.tasks['set_prev_content'].start(config.HMI_BASE['navigator_listing_delay'])
			return True
		return False

	def select_service(self, playlist, service):
		self._history.empty()
		root = self.root_getter()
		position = root.index(playlist)
		playlist = root[position]
		self._history.append(dict(position=position, selected=playlist, items=root))
		_playlist = playlist.browse()
		try:
			ind = _playlist.index(service)
		except ValueError, e:
			ind = 0
		self.set_items(_playlist, position=ind)
		self.build_preview()
		louie_send('hide_program_info', sender=self)
		louie_send('show_preview_program_bar', sender=self)
		louie_send('hide_program_bar', sender=self)

	select_program = gui_updater()
	def select_schedule_recordings(self):
		self._history.empty()
		root = self.root_getter()
		self.set_items(root)
		self._build_preview()
		self.browse_selected()

	on_foreground = selective_gui_updater('parent_item_name', 'parent_icon_name', 'recording_info')()
	def display_epg(self):
		self._player.display_epg()

	_reload_func = back_root_if_error()
	def action_info(self):
		item = self.selected
		if isinstance(item, ChannelItem):
			menu = ChannelInfoMenu(item)
		else:
			if isinstance(item, AllChannelsList):
				menu = TVInfoMenu(item)
			else:
				if isinstance(item, ScheduledRecordRootItem):
					menu = ScheduledRecordRootInfoMenu(item)
				else:
					log.error("Information window for %s (%s) isn't supported", item, type(item))
		menu.show()

	def action_record(self):
		item = self.selected
		if isinstance(item, ProgramItem):
			if item.recording_id:
				self.cancel_record_selected()
			else:
				self.record_selected()
			self.set_items(item.parent.browse(self._player.real_utc_time), 'main_list', position=self.selected_pos)
		else:
			self._error_spawner()

	def action_stop(self):
		item = self.selected
		if isinstance(item, ProgramItem) and item.recording_id:
			self.cancel_record_selected()
			self.set_items(item.parent.browse(self._player.real_utc_time), 'main_list', position=self.selected_pos)
		else:
			self._error_spawner()

	def record_selected(self):
		program = self.selected
		now = int(time())
		if program.end_time > now:
			start_time = max(now, program.start_time)
			end_time = min(program.end_time, start_time + 21600)
			channel = program.parent
			chan_id = int(channel['serviceId'])
			favorite_name = channel.parent.name
			values = {'channel': channel.name, 'title': program.name, 'date': strftime('%Y/%m/%d', localtime(start_time)), 'start_time': seconds_to_hhmm(start_time), 'end_time': seconds_to_hhmm(end_time)}
			record_name = EPG_RECORDING_NAME_PATTERN % values
			try:
				WyRecord().scheduler.ScheduleRecording(chan_id, start_time, end_time, record_name, program_id=program.id, favorite=favorite_name)
				louie_send('update_record')
			except SchedulerConflictWithInstantRecordError, e:
				louie_send('update_record', sender=None)
				conflicting_rec = e.conflict.getAllRecInConflict()[0]
				message_pattern = _('An instant recording on %(channel)s will be stopped when this recording starts.')
				message = message_pattern % {'name': ellipsize(conflicting_rec.name, 40), 'start_time': seconds_to_hhmm(conflicting_rec.start_time), 'channel': conflicting_rec.service_name}
				title = _('Conflict with an instant recording')
				MessageWindow(message, title, button=None).show(timeout=5)
			except:
				except SchedulerConflictError, e:
					conflicting_rec = e.conflict.getAllRecInConflict()[0]
					message_pattern = _('The recording you are attempting to schedule conflicts with "%(name)s", starting at %(start_time)s on %(channel)s.')
					message = message_pattern % {'name': ellipsize(conflicting_rec.name, 40), 'start_time': seconds_to_hhmm(conflicting_rec.start_time), 'channel': conflicting_rec.service_name}
					title = _('Recording scheduler error')
					MessageWindow(message, title, button=None).show(timeout=5)
				except:
					except SchedulerError, e:
						log.error("Can't start recording due to %s", e)
						title = _('Recording scheduler error')
						message = 'Unable to schedule your recording. Sorry.'
						MessageWindow(message, title, button=None).show(timeout=5)
		else:
			message = _('The program is over. You cannot record it.')
			title = _('Program already over')
			win = MessageWindow(message, title, button=None)
			win.show(timeout=5)
		return None

	def cancel_record_selected(self):
		program = self.selected
		rec_id = program.recording_id
		if rec_id:
			log.info('Canceling recording for %s', program)
			try:
				WyRecord().scheduler.DeleteRecording(rec_id)
			except SchedulerRecordingRunningError:
				error_title = _('Impossible to cancel recording')
				message = _('This recording has already started. To stop it, close the EPG grid and press Stop.')
				MessageWindow(message, error_title, button=None).show(timeout=5)
		return None



