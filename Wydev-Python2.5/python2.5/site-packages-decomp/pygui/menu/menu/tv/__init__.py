# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 38
n 38(None)[return ''
]:
	i: 0&18(t), 34()
	o: 

nname: 34
n 34(None)[]:
	i: 0&18(f)
	o: 38()

nname: 0&18
n 0&18(isinstance(self.selected, PeriodicScheduledRecordItem) and self.selected.periodic_rule.limit)[]:
	i: 
	o: 34(f), 38(t)

nname: 0&18
n 0&18(None)[if not(isinstance(self.selected, PeriodicScheduledRecordItem) and self.selected.periodic_rule.limit):
	pass
return ''
]:
	i: 
	o: 

self.nodes: {'0&18': <unpyclib.structure.node instance at 0xb77231ec>}
nname: 50
n 50(None)[return ''
]:
	i: 0&18(t), 46()
	o: 

nname: 46
n 46(None)[]:
	i: 0&18(f)
	o: 50()

nname: 0&18
n 0&18(isinstance(self.selected, PeriodicScheduledRecordItem) and _(self.selected.periodic_rule.extern_rule_name.capitalize()))[]:
	i: 
	o: 46(f), 50(t)

nname: 0&18
n 0&18(None)[if not(isinstance(self.selected, PeriodicScheduledRecordItem) and _(self.selected.periodic_rule.extern_rule_name.capitalize())):
	pass
return ''
]:
	i: 
	o: 

self.nodes: {'0&18': <unpyclib.structure.node instance at 0xb77230ec>}
nname: 29
n 29(None)[return ''
]:
	i: 9(), 25()
	o: 

nname: 25
n 25(None)[]:
	i: 0(f)
	o: 29()

nname: 9
n 9(None)[]:
	i: 0(t)
	o: 29()

nname: 0
n 0(self.selected)[]:
	i: 
	o: 9(t), 25(f)

nname: 0
n 0(None)[if self.selected:
	pass
return ''
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb771cfcc>}
nname: 35
n 35(None)[return ''
]:
	i: 9(), 31()
	o: 

nname: 31
n 31(None)[]:
	i: 0(f)
	o: 35()

nname: 9
n 9(None)[]:
	i: 0(t)
	o: 35()

nname: 0
n 0(self.selected)[]:
	i: 
	o: 9(t), 31(f)

nname: 0
n 0(None)[if self.selected:
	pass
return ''
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb771cf4c>}
nname: 35
n 35(None)[return ''
]:
	i: 9(), 31()
	o: 

nname: 31
n 31(None)[]:
	i: 0(f)
	o: 35()

nname: 9
n 9(None)[]:
	i: 0(t)
	o: 35()

nname: 0
n 0(self.selected)[]:
	i: 
	o: 9(t), 31(f)

nname: 0
n 0(None)[if self.selected:
	pass
return ''
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb771ceec>}
nname: 35
n 35(None)[return ''
]:
	i: 9(), 31()
	o: 

nname: 31
n 31(None)[]:
	i: 0(f)
	o: 35()

nname: 9
n 9(None)[]:
	i: 0(t)
	o: 35()

nname: 0
n 0(self.selected)[]:
	i: 
	o: 9(t), 31(f)

nname: 0
n 0(None)[if self.selected:
	pass
return ''
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb771cf8c>}
nname: 0
n 0(None)[return self.name
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb771cc4c>}
nname: 0
n 0(None)[return 'parentfolder-%s.png' % self.type
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb771cc2c>}
nname: 0
n 0(None)[return UNIVERSE_NAME_DICT[self.type]
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb771cb6c>}
nname: 0
n 0(None)[self.eventhandler = ScheduledRecordMenuEventHandler(self)
Menu.__init__(self, name=name, choices=ScheduledRecordRootItem(self).browse(), type=type)
self._program = None
self._getitems_keywords.update(dict(universe_name=(lambda : UNIVERSE_NAME_DICT[self.type]), parent_icon_name=(lambda : 'parentfolder-%s.png' % self.type), parent_item_name=(lambda : self.name), record_description=self.get_record_description, record_date=(lambda : .selected:
	pass
return ''), record_start_time=(lambda : .selected:
	pass
return ''), record_stop_time=(lambda : .selected:
	pass
return ''), channel_name=(lambda : .selected:
	pass
return ''), repetition_type=(lambda : isinstance(self.selected, PeriodicScheduledRecordItem) and _(self.selected.periodic_rule.extern_rule_name.capitalize())):
	pass
return ''), repetition_number=(lambda : isinstance(self.selected, PeriodicScheduledRecordItem) and self.selected.periodic_rule.limit):
	pass
return '')))
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7717cac>}
nname: 0
n 0(None)[loader = LoadingWindow()
loader.show()
from .scheduled_record import ScheduledRecordMenu
menu = ScheduledRecordMenu()
menu._set_record(self.selected)
menu.show()
loader.hide()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb77179ec>}
nname: 0
n 0(None)[ScheduledRecordInfoMenu(self.selected).show()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb771740c>}
nname: 84
n 84(None)[context = dict(menu=self, selected=sel, parent=parent)
s = ActionMenu(context, universe=self.universe)
s.show()
return None
]:
	i: 53(), 74()
	o: 

nname: 74
n 74(None)[parent = sel.parent
]:
	i: 0&43(f)
	o: 84()

nname: 53
n 53(None)[parent = self._history[-1]['selected']
]:
	i: 0&43(t)
	o: 84()

nname: 0&43
n 0&43(sel is None and self._history)[sel = self.selected
from pygui.menu.menu import ActionMenu
parent = None
]:
	i: 
	o: 53(t), 74(f)

nname: 0&43
n 0&43(None)[sel = self.selected
from pygui.menu.menu import ActionMenu
parent = None
if sel is None and self._history:
	parent = self._history[-1]['selected']
else:
	parent = sel.parent
context = dict(menu=self, selected=sel, parent=parent)
s = ActionMenu(context, universe=self.universe)
s.show()
return None
]:
	i: 
	o: 

self.nodes: {'0&43': <unpyclib.structure.node instance at 0xb7717a8c>}
nname: 151
n 151(None)[return message_template % values
]:
	i: 72(), 130(), 149(AE)
	o: 

nname: 149
n 149(None)[]:
	i: 120(f)
	o: 151(AE)

nname: 130
n 130(None)[message_template = _('The %(date)s\nFrom %(start_time)s\nTo %(end_time)s')
]:
	i: 120(t)
	o: 151()

nname: 120
n 120(<dummy_ex3> EXC_MATCH AttributeError)[]:
	i: 24(except)
	o: 130(t), 149(f)

nname: 72
n 72(None)[values['name'] = self.selected.period
values['number'] = self.selected.remaining_count
message_template = _('The %(date)s\nFrom %(start_time)s\nTo %(end_time)s\nrepeated %(name)s (%(number)s more remaining)')
]:
	i: 24(try)
	o: 151()

nname: 24
n 24(None)[values = {'date': self['record_date'], 'start_time': self['record_start_time'], 'end_time': self['record_stop_time']}
]:
	i: 15(), 23()
	o: 72(try), 120(except)

nname: 23
n 23(None)[]:
	i: 0(f)
	o: 24()

nname: 15
n 15(None)[return u''
]:
	i: 0(t)
	o: 24()

nname: 0
n 0(self.selected is None)[]:
	i: 
	o: 15(t), 23(f)

nname: 151
n 151(None)[return message_template % values
]:
	i: 72()
	o: 

nname: 72
n 72(None)[try:
	values['name'] = self.selected.period
	values['number'] = self.selected.remaining_count
	message_template = _('The %(date)s\nFrom %(start_time)s\nTo %(end_time)s\nrepeated %(name)s (%(number)s more remaining)')
except AttributeError:
	message_template = _('The %(date)s\nFrom %(start_time)s\nTo %(end_time)s')
]:
	i: 0(try)
	o: 151()

nname: 0
n 0(None)[if self.selected is None:
	return u''
values = {'date': self['record_date'], 'start_time': self['record_start_time'], 'end_time': self['record_stop_time']}
]:
	i: 
	o: 72(try)

nname: 151
n 151(None)[return message_template % values
]:
	i: 0()
	o: 

nname: 0
n 0(None)[if self.selected is None:
	return u''
values = {'date': self['record_date'], 'start_time': self['record_start_time'], 'end_time': self['record_stop_time']}
try:
	values['name'] = self.selected.period
	values['number'] = self.selected.remaining_count
	message_template = _('The %(date)s\nFrom %(start_time)s\nTo %(end_time)s\nrepeated %(name)s (%(number)s more remaining)')
except AttributeError:
	message_template = _('The %(date)s\nFrom %(start_time)s\nTo %(end_time)s')
]:
	i: 
	o: 151()

nname: 0
n 0(None)[if self.selected is None:
	return u''
values = {'date': self['record_date'], 'start_time': self['record_start_time'], 'end_time': self['record_stop_time']}
try:
	values['name'] = self.selected.period
	values['number'] = self.selected.remaining_count
	message_template = _('The %(date)s\nFrom %(start_time)s\nTo %(end_time)s\nrepeated %(name)s (%(number)s more remaining)')
except AttributeError:
	message_template = _('The %(date)s\nFrom %(start_time)s\nTo %(end_time)s')
return message_template % values
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb771c0ac>}
nname: 6
n 6(None)[groupeable = True
toggleable = False
def __init__(self, name=_('Scheduled recordings'), type='scheduled_navigator'):
	self.eventhandler = ScheduledRecordMenuEventHandler(self)
	Menu.__init__(self, name=name, choices=ScheduledRecordRootItem(self).browse(), type=type)
	self._program = None
	self._getitems_keywords.update(dict(universe_name=(lambda : UNIVERSE_NAME_DICT[self.type]), parent_icon_name=(lambda : 'parentfolder-%s.png' % self.type), parent_item_name=(lambda : self.name), record_description=self.get_record_description, record_date=(lambda : .selected:
		pass
	return ''), record_start_time=(lambda : .selected:
		pass
	return ''), record_stop_time=(lambda : .selected:
		pass
	return ''), channel_name=(lambda : .selected:
		pass
	return ''), repetition_type=(lambda : isinstance(self.selected, PeriodicScheduledRecordItem) and _(self.selected.periodic_rule.extern_rule_name.capitalize())):
		pass
	return ''), repetition_number=(lambda : isinstance(self.selected, PeriodicScheduledRecordItem) and self.selected.periodic_rule.limit):
		pass
	return '')))
	return None

reload_func = gui_updater()
def modify_scheduled_record(self):
	loader = LoadingWindow()
	loader.show()
	from .scheduled_record import ScheduledRecordMenu
	menu = ScheduledRecordMenu()
	menu._set_record(self.selected)
	menu.show()
	loader.hide()

def action_info(self):
	ScheduledRecordInfoMenu(self.selected).show()

def display_action_menu(self):
	sel = self.selected
	from pygui.menu.menu import ActionMenu
	parent = None
	if sel is None and self._history:
		parent = self._history[-1]['selected']
	else:
		parent = sel.parent
	context = dict(menu=self, selected=sel, parent=parent)
	s = ActionMenu(context, universe=self.universe)
	s.show()
	return None

select = gui_updater()
def get_record_description(self):
	if self.selected is None:
		return u''
	values = {'date': self['record_date'], 'start_time': self['record_start_time'], 'end_time': self['record_stop_time']}
	try:
		values['name'] = self.selected.period
		values['number'] = self.selected.remaining_count
		message_template = _('The %(date)s\nFrom %(start_time)s\nTo %(end_time)s\nrepeated %(name)s (%(number)s more remaining)')
	except AttributeError:
		message_template = _('The %(date)s\nFrom %(start_time)s\nTo %(end_time)s')
	return message_template % values

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb7715f8c>}
nname: 0
n 0(None)[from __future__ import absolute_import
from peewee.debug import GET_LOGGER
from peewee.formatters import seconds_to_hhmm
from pygui.eventmanager.menus import ScheduledRecordMenuEventHandler
from pygui.facilities.timeslices import seconds_to_long_date
from pygui.shared import pygui_globs
from pygui.item.scheduledrecord import ScheduledRecordRootItem, PeriodicScheduledRecordItem
from pygui.menu import gui_updater, UNIVERSE_NAME_DICT
from pygui.menu.menu.core import Menu
from pygui.menu.menu.info import ScheduledRecordInfoMenu
from pygui.window import LoadingWindow
log = GET_LOGGER(__name__)
class ScheduledRecordNavigator(Menu):
	groupeable = True
	toggleable = False
	def __init__(self, name=_('Scheduled recordings'), type='scheduled_navigator'):
		self.eventhandler = ScheduledRecordMenuEventHandler(self)
		Menu.__init__(self, name=name, choices=ScheduledRecordRootItem(self).browse(), type=type)
		self._program = None
		self._getitems_keywords.update(dict(universe_name=(lambda : UNIVERSE_NAME_DICT[self.type]), parent_icon_name=(lambda : 'parentfolder-%s.png' % self.type), parent_item_name=(lambda : self.name), record_description=self.get_record_description, record_date=(lambda : .selected:
			pass
		return ''), record_start_time=(lambda : .selected:
			pass
		return ''), record_stop_time=(lambda : .selected:
			pass
		return ''), channel_name=(lambda : .selected:
			pass
		return ''), repetition_type=(lambda : isinstance(self.selected, PeriodicScheduledRecordItem) and _(self.selected.periodic_rule.extern_rule_name.capitalize())):
			pass
		return ''), repetition_number=(lambda : isinstance(self.selected, PeriodicScheduledRecordItem) and self.selected.periodic_rule.limit):
			pass
		return '')))
		return None

	reload_func = gui_updater()
	def modify_scheduled_record(self):
		loader = LoadingWindow()
		loader.show()
		from .scheduled_record import ScheduledRecordMenu
		menu = ScheduledRecordMenu()
		menu._set_record(self.selected)
		menu.show()
		loader.hide()

	def action_info(self):
		ScheduledRecordInfoMenu(self.selected).show()

	def display_action_menu(self):
		sel = self.selected
		from pygui.menu.menu import ActionMenu
		parent = None
		if sel is None and self._history:
			parent = self._history[-1]['selected']
		else:
			parent = sel.parent
		context = dict(menu=self, selected=sel, parent=parent)
		s = ActionMenu(context, universe=self.universe)
		s.show()
		return None

	select = gui_updater()
	def get_record_description(self):
		if self.selected is None:
			return u''
		values = {'date': self['record_date'], 'start_time': self['record_start_time'], 'end_time': self['record_stop_time']}
		try:
			values['name'] = self.selected.period
			values['number'] = self.selected.remaining_count
			message_template = _('The %(date)s\nFrom %(start_time)s\nTo %(end_time)s\nrepeated %(name)s (%(number)s more remaining)')
		except AttributeError:
			message_template = _('The %(date)s\nFrom %(start_time)s\nTo %(end_time)s')
		return message_template % values



]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb770accc>}
from __future__ import absolute_import
from peewee.debug import GET_LOGGER
from peewee.formatters import seconds_to_hhmm
from pygui.eventmanager.menus import ScheduledRecordMenuEventHandler
from pygui.facilities.timeslices import seconds_to_long_date
from pygui.shared import pygui_globs
from pygui.item.scheduledrecord import ScheduledRecordRootItem, PeriodicScheduledRecordItem
from pygui.menu import gui_updater, UNIVERSE_NAME_DICT
from pygui.menu.menu.core import Menu
from pygui.menu.menu.info import ScheduledRecordInfoMenu
from pygui.window import LoadingWindow
log = GET_LOGGER(__name__)
class ScheduledRecordNavigator(Menu):
	groupeable = True
	toggleable = False
	def __init__(self, name=_('Scheduled recordings'), type='scheduled_navigator'):
		self.eventhandler = ScheduledRecordMenuEventHandler(self)
		Menu.__init__(self, name=name, choices=ScheduledRecordRootItem(self).browse(), type=type)
		self._program = None
		self._getitems_keywords.update(dict(universe_name=(lambda : UNIVERSE_NAME_DICT[self.type]), parent_icon_name=(lambda : 'parentfolder-%s.png' % self.type), parent_item_name=(lambda : self.name), record_description=self.get_record_description, record_date=(lambda : .selected:
			pass
		return ''), record_start_time=(lambda : .selected:
			pass
		return ''), record_stop_time=(lambda : .selected:
			pass
		return ''), channel_name=(lambda : .selected:
			pass
		return ''), repetition_type=(lambda : isinstance(self.selected, PeriodicScheduledRecordItem) and _(self.selected.periodic_rule.extern_rule_name.capitalize())):
			pass
		return ''), repetition_number=(lambda : isinstance(self.selected, PeriodicScheduledRecordItem) and self.selected.periodic_rule.limit):
			pass
		return '')))
		return None

	reload_func = gui_updater()
	def modify_scheduled_record(self):
		loader = LoadingWindow()
		loader.show()
		from .scheduled_record import ScheduledRecordMenu
		menu = ScheduledRecordMenu()
		menu._set_record(self.selected)
		menu.show()
		loader.hide()

	def action_info(self):
		ScheduledRecordInfoMenu(self.selected).show()

	def display_action_menu(self):
		sel = self.selected
		from pygui.menu.menu import ActionMenu
		parent = None
		if sel is None and self._history:
			parent = self._history[-1]['selected']
		else:
			parent = sel.parent
		context = dict(menu=self, selected=sel, parent=parent)
		s = ActionMenu(context, universe=self.universe)
		s.show()
		return None

	select = gui_updater()
	def get_record_description(self):
		if self.selected is None:
			return u''
		values = {'date': self['record_date'], 'start_time': self['record_start_time'], 'end_time': self['record_stop_time']}
		try:
			values['name'] = self.selected.period
			values['number'] = self.selected.remaining_count
			message_template = _('The %(date)s\nFrom %(start_time)s\nTo %(end_time)s\nrepeated %(name)s (%(number)s more remaining)')
		except AttributeError:
			message_template = _('The %(date)s\nFrom %(start_time)s\nTo %(end_time)s')
		return message_template % values



