# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 0
n 0(None)[return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x93b070c>}
nname: 0
n 0(None)[return self.get_item_list('channel_list')
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x93b08cc>}
nname: 0
n 0(None)[return self.channel_list.name
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x93b088c>}
nname: 0
n 0(None)[return self._summarized_info['info_press']
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x93b094c>}
nname: 0
n 0(None)[return self._summarized_info['info_icon']
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x93b070c>}
nname: 0
n 0(None)[return self._summarized_info['program_name']
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x93b094c>}
nname: 0
n 0(None)[return self._summarized_info['program_duration']
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x93b070c>}
nname: 0
n 0(None)[return self._summarized_info['program_date']
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x93b094c>}
nname: 0
n 0(None)[return self._summarized_info['program_start']
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x93b070c>}
nname: 0
n 0(None)[return self._summarized_info['program_maturity_rating']
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x93b094c>}
nname: 0
n 0(None)[return _('Duration')
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x93b08ac>}
nname: 0
n 0(None)[return _('EPG Control Window')
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x93b084c>}
nname: 0
n 0(None)[return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x93b070c>}
nname: 0
n 0(None)[return self.get_item_list('channel_list')
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x93b09ec>}
nname: 0
n 0(None)[return self.channel_list.name
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x93b090c>}
nname: 0
n 0(None)[return self._summarized_info['info_press']
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x93b09ac>}
nname: 0
n 0(None)[return self._summarized_info['info_icon']
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x93b070c>}
nname: 0
n 0(None)[return self._summarized_info['program_name']
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x93b09ac>}
nname: 0
n 0(None)[return self._summarized_info['program_duration']
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x93b070c>}
nname: 0
n 0(None)[return self._summarized_info['program_date']
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x93b09ac>}
nname: 0
n 0(None)[return self._summarized_info['program_start']
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x93b070c>}
nname: 0
n 0(None)[return self._summarized_info['program_maturity_rating']
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x93b09ac>}
nname: 0
n 0(None)[return _('Duration')
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x93b094c>}
nname: 0
n 0(None)[return _('EPG Control Window')
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x93b064c>}
nname: 569
n 569(None)[self.tick_timer = Task(self.tick_callback)
self.tick_timer.start(5, loop=True)
self.refresh_timer.start(AUTO_REFRESH_DELAY, loop=True, consider_idle=True)
]:
	i: 0(AL), 568()
	o: 

nname: 568
n 568(None)[]:
	i: 481(AF), 564()
	o: 569()

nname: 564
n 564(None)[]:
	i: 497&521(f), 537()
	o: 568()

nname: 537
n 537(None)[self.selected_program = i
self.select_program(0)
break
continue
]:
	i: 497&521(t)
	o: 564()

nname: 497&521
n 497&521(prog.start_time <= now and prog.end_time >= now)[for i, prog in enumerate(self.displayed_programs):
]:
	i: 481(for)
	o: 537(t), 564(f)

nname: 481
n 481(None)[]:
	i: 0(loop)
	o: 497&521(for), 568(AF)

nname: 0
n 0(None)[Menu.__init__(self, name='EPG Grid', choices=[], type='epg_grid', universe=universe)
self.eventhandler = EpgGridEventHandler(self)
self.player = player
self.start_time, self.end_time = ts.current_timeslice()
self.lower_limit = ts.get_epg_day(self.start_time)
self.upper_limit = self.start_time + datetime.timedelta(days=7)
self.displayed_programs = []
self.selected_program = 0
self._summarized_info = dict()
self._getitems_keywords.update({'clock': (lambda : None), 'channel_list': (lambda : self.get_item_list('channel_list')), 'channel_list_name': (lambda : self.channel_list.name), 'info_press': (lambda : self._summarized_info['info_press']), 'info_icon': (lambda : self._summarized_info['info_icon']), 'selected_program_name': (lambda : self._summarized_info['program_name']), 'selected_program_duration': (lambda : self._summarized_info['program_duration']), 'selected_program_date': (lambda : self._summarized_info['program_date']), 'selected_program_start_time': (lambda : self._summarized_info['program_start']), 'selected_program_maturity_rating': (lambda : self._summarized_info['program_maturity_rating']), 'selected_program_duration_caption': (lambda : _('Duration')), 'epg_control_window_caption': (lambda : _('EPG Control Window'))})
self.update_channels_timer = Task(self.update_channels)
self.refresh_timer = Task(self.refresh)
self.set_channel_list(channel_list)
self.select(selected_chan, 'main_list')
self.select(selected_chan, 'channel_list')
self.update_programs()
now = time()
]:
	i: 
	o: 481(loop), 569(AL)

nname: 569
n 569(None)[self.tick_timer = Task(self.tick_callback)
self.tick_timer.start(5, loop=True)
self.refresh_timer.start(AUTO_REFRESH_DELAY, loop=True, consider_idle=True)
]:
	i: 0(AL), 481(AF), 497&521(f)
	o: 

nname: 497&521
n 497&521(None)[for i, prog in enumerate(self.displayed_programs):
if prog.start_time <= now and prog.end_time >= now:
	self.selected_program = i
	self.select_program(0)
	break
	continue
]:
	i: 481(for)
	o: 569()

nname: 481
n 481(None)[]:
	i: 0(loop)
	o: 497&521(for), 569(AF)

nname: 0
n 0(None)[Menu.__init__(self, name='EPG Grid', choices=[], type='epg_grid', universe=universe)
self.eventhandler = EpgGridEventHandler(self)
self.player = player
self.start_time, self.end_time = ts.current_timeslice()
self.lower_limit = ts.get_epg_day(self.start_time)
self.upper_limit = self.start_time + datetime.timedelta(days=7)
self.displayed_programs = []
self.selected_program = 0
self._summarized_info = dict()
self._getitems_keywords.update({'clock': (lambda : None), 'channel_list': (lambda : self.get_item_list('channel_list')), 'channel_list_name': (lambda : self.channel_list.name), 'info_press': (lambda : self._summarized_info['info_press']), 'info_icon': (lambda : self._summarized_info['info_icon']), 'selected_program_name': (lambda : self._summarized_info['program_name']), 'selected_program_duration': (lambda : self._summarized_info['program_duration']), 'selected_program_date': (lambda : self._summarized_info['program_date']), 'selected_program_start_time': (lambda : self._summarized_info['program_start']), 'selected_program_maturity_rating': (lambda : self._summarized_info['program_maturity_rating']), 'selected_program_duration_caption': (lambda : _('Duration')), 'epg_control_window_caption': (lambda : _('EPG Control Window'))})
self.update_channels_timer = Task(self.update_channels)
self.refresh_timer = Task(self.refresh)
self.set_channel_list(channel_list)
self.select(selected_chan, 'main_list')
self.select(selected_chan, 'channel_list')
self.update_programs()
now = time()
]:
	i: 
	o: 481(loop), 569(AL)

nname: 497&521
n 497&521(None)[for i, prog in enumerate(self.displayed_programs):
	if prog.start_time <= now and prog.end_time >= now:
		self.selected_program = i
		self.select_program(0)
		break
		continue
self.tick_timer = Task(self.tick_callback)
self.tick_timer.start(5, loop=True)
self.refresh_timer.start(AUTO_REFRESH_DELAY, loop=True, consider_idle=True)
]:
	i: 0(for)
	o: 

nname: 0
n 0(None)[Menu.__init__(self, name='EPG Grid', choices=[], type='epg_grid', universe=universe)
self.eventhandler = EpgGridEventHandler(self)
self.player = player
self.start_time, self.end_time = ts.current_timeslice()
self.lower_limit = ts.get_epg_day(self.start_time)
self.upper_limit = self.start_time + datetime.timedelta(days=7)
self.displayed_programs = []
self.selected_program = 0
self._summarized_info = dict()
self._getitems_keywords.update({'clock': (lambda : None), 'channel_list': (lambda : self.get_item_list('channel_list')), 'channel_list_name': (lambda : self.channel_list.name), 'info_press': (lambda : self._summarized_info['info_press']), 'info_icon': (lambda : self._summarized_info['info_icon']), 'selected_program_name': (lambda : self._summarized_info['program_name']), 'selected_program_duration': (lambda : self._summarized_info['program_duration']), 'selected_program_date': (lambda : self._summarized_info['program_date']), 'selected_program_start_time': (lambda : self._summarized_info['program_start']), 'selected_program_maturity_rating': (lambda : self._summarized_info['program_maturity_rating']), 'selected_program_duration_caption': (lambda : _('Duration')), 'epg_control_window_caption': (lambda : _('EPG Control Window'))})
self.update_channels_timer = Task(self.update_channels)
self.refresh_timer = Task(self.refresh)
self.set_channel_list(channel_list)
self.select(selected_chan, 'main_list')
self.select(selected_chan, 'channel_list')
self.update_programs()
now = time()
]:
	i: 
	o: 497&521(for)

nname: 0
n 0(None)[Menu.__init__(self, name='EPG Grid', choices=[], type='epg_grid', universe=universe)
self.eventhandler = EpgGridEventHandler(self)
self.player = player
self.start_time, self.end_time = ts.current_timeslice()
self.lower_limit = ts.get_epg_day(self.start_time)
self.upper_limit = self.start_time + datetime.timedelta(days=7)
self.displayed_programs = []
self.selected_program = 0
self._summarized_info = dict()
self._getitems_keywords.update({'clock': (lambda : None), 'channel_list': (lambda : self.get_item_list('channel_list')), 'channel_list_name': (lambda : self.channel_list.name), 'info_press': (lambda : self._summarized_info['info_press']), 'info_icon': (lambda : self._summarized_info['info_icon']), 'selected_program_name': (lambda : self._summarized_info['program_name']), 'selected_program_duration': (lambda : self._summarized_info['program_duration']), 'selected_program_date': (lambda : self._summarized_info['program_date']), 'selected_program_start_time': (lambda : self._summarized_info['program_start']), 'selected_program_maturity_rating': (lambda : self._summarized_info['program_maturity_rating']), 'selected_program_duration_caption': (lambda : _('Duration')), 'epg_control_window_caption': (lambda : _('EPG Control Window'))})
self.update_channels_timer = Task(self.update_channels)
self.refresh_timer = Task(self.refresh)
self.set_channel_list(channel_list)
self.select(selected_chan, 'main_list')
self.select(selected_chan, 'channel_list')
self.update_programs()
now = time()
for i, prog in enumerate(self.displayed_programs):
	if prog.start_time <= now and prog.end_time >= now:
		self.selected_program = i
		self.select_program(0)
		break
		continue
self.tick_timer = Task(self.tick_callback)
self.tick_timer.start(5, loop=True)
self.refresh_timer.start(AUTO_REFRESH_DELAY, loop=True, consider_idle=True)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7660a6c>}
nname: 0
n 0(None)[EpgControlWindowMenu(self).show()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7658c4c>}
nname: 53
n 53(None)[]:
	i: 32(), 52()
	o: 

nname: 52
n 52(None)[]:
	i: 0(f)
	o: 53()

nname: 32
n 32(None)[EpgInfoBanner(program).show()
]:
	i: 0(t)
	o: 53()

nname: 0
n 0('dummy' not in program['class'])[program = self.displayed_programs[self.selected_program]
]:
	i: 
	o: 32(t), 52(f)

nname: 0
n 0(None)[program = self.displayed_programs[self.selected_program]
if 'dummy' not in program['class']:
	EpgInfoBanner(program).show()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7658dcc>}
nname: 117
n 117(None)[return None
]:
	i: 15(), 61()
	o: 

nname: 61
n 61(None)[title = _("Can't change channels")
message = _('A recording is in progress. Stop it before zapping.')
MessageWindow(message, title, button=None).show(timeout=5)
]:
	i: 0(f)
	o: 117()

nname: 15
n 15(None)[channel = self.get_item_list('main_list').selected
self.hide()
channel.execute()
return True
]:
	i: 0(t)
	o: 117()

nname: 0
n 0(self.player.can_zap())[]:
	i: 
	o: 15(t), 61(f)

nname: 0
n 0(None)[if self.player.can_zap():
	channel = self.get_item_list('main_list').selected
	self.hide()
	channel.execute()
	return True
else:
	title = _("Can't change channels")
	message = _('A recording is in progress. Stop it before zapping.')
	MessageWindow(message, title, button=None).show(timeout=5)
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76601ac>}
nname: 766
n 766(None)[return None
]:
	i: 232(JA), 299(JA), 470(JA), 625(JA), 701(), 704()
	o: 

nname: 704
n 704(None)[message = _('The program is over. You cannot record it.')
title = _('Program already over')
win = MessageWindow(message, title, button=None)
win.show(timeout=5)
]:
	i: 0(f)
	o: 766()

nname: 701
n 701(None)[]:
	i: 699(AE)
	o: 766()

nname: 699
n 699(None)[]:
	i: 614(f)
	o: 701(AE)

nname: 625
n 625(None)[#, e
log.error("Can't start recording due to %s", e)
title = _('Recording scheduler error')
message = 'Unable to schedule your recording. Sorry.'
MessageWindow(message, title, button=None).show(timeout=5)
]:
	i: 614(t)
	o: 766(JA)

nname: 614
n 614(<dummy_ex3> EXC_MATCH SchedulerError)[]:
	i: 459(f)
	o: 625(t), 699(f)

nname: 470
n 470(None)[#, e
conflicting_rec = e.conflict.getAllRecInConflict()[0]
message_pattern = _('The recording you are attempting to schedule conflicts with "%(name)s", starting at %(start_time)s on %(channel)s.')
message = message_pattern % {'name': ellipsize(conflicting_rec.name, 40), 'start_time': seconds_to_hhmm(conflicting_rec.start_time), 'channel': conflicting_rec.service_name}
title = _('Recording scheduler error')
MessageWindow(message, title, button=None).show(timeout=5)
]:
	i: 459(t)
	o: 766(JA)

nname: 459
n 459(<dummy_ex3> EXC_MATCH SchedulerConflictError)[]:
	i: 289(f)
	o: 470(t), 614(f)

nname: 299
n 299(None)[#, e
louie_send('update_record', sender=None)
conflicting_rec = e.conflict.getAllRecInConflict()[0]
message_pattern = _('An instant recording on %(channel)s will be stopped when this recording starts.')
message = message_pattern % {'name': ellipsize(conflicting_rec.name, 40), 'start_time': seconds_to_hhmm(conflicting_rec.start_time), 'channel': conflicting_rec.service_name}
title = _('Conflict with an instant recording')
MessageWindow(message, title, button=None).show(timeout=5)
]:
	i: 289(t)
	o: 766(JA)

nname: 289
n 289(<dummy_ex3> EXC_MATCH SchedulerConflictWithInstantRecordError)[]:
	i: 46(except)
	o: 299(t), 459(f)

nname: 232
n 232(None)[WyRecord().scheduler.ScheduleRecording(chan_id, start_time, end_time, record_name, program_id=program.id, favorite=favorite_name)
louie_send('update_record')
]:
	i: 46(try)
	o: 766(JA)

nname: 46
n 46(None)[start_time = max(now, program.start_time)
end_time = min(program.end_time, start_time + 21600)
channel = self['channel_list'].selected
chan_id = int(channel['serviceId'])
favorite_name = self.channel_list.name
values = {'channel': self['channel_list'].selected.name, 'title': program.name, 'date': strftime('%Y/%m/%d', localtime(start_time)), 'start_time': seconds_to_hhmm(start_time), 'end_time': seconds_to_hhmm(end_time)}
record_name = EPG_RECORDING_NAME_PATTERN % values
]:
	i: 0(t)
	o: 232(try), 289(except)

nname: 0
n 0(program.end_time > now)[program = self.displayed_programs[self.selected_program]
now = int(time())
]:
	i: 
	o: 46(t), 704(f)

nname: 766
n 766(None)[return None
]:
	i: 232(JA), 299(JA), 470(JA), 625(JA), 704(), 614(f), 699(AE)
	o: 

nname: 704
n 704(None)[message = _('The program is over. You cannot record it.')
title = _('Program already over')
win = MessageWindow(message, title, button=None)
win.show(timeout=5)
]:
	i: 0(f)
	o: 766()

nname: 625
n 625(None)[#, e
log.error("Can't start recording due to %s", e)
title = _('Recording scheduler error')
message = 'Unable to schedule your recording. Sorry.'
MessageWindow(message, title, button=None).show(timeout=5)
]:
	i: 614(t)
	o: 766(JA)

nname: 614
n 614(<dummy_ex3> EXC_MATCH SchedulerError)[]:
	i: 459(f)
	o: 625(t), 766(f)

nname: 470
n 470(None)[#, e
conflicting_rec = e.conflict.getAllRecInConflict()[0]
message_pattern = _('The recording you are attempting to schedule conflicts with "%(name)s", starting at %(start_time)s on %(channel)s.')
message = message_pattern % {'name': ellipsize(conflicting_rec.name, 40), 'start_time': seconds_to_hhmm(conflicting_rec.start_time), 'channel': conflicting_rec.service_name}
title = _('Recording scheduler error')
MessageWindow(message, title, button=None).show(timeout=5)
]:
	i: 459(t)
	o: 766(JA)

nname: 459
n 459(<dummy_ex3> EXC_MATCH SchedulerConflictError)[]:
	i: 289(f)
	o: 470(t), 614(f)

nname: 299
n 299(None)[#, e
louie_send('update_record', sender=None)
conflicting_rec = e.conflict.getAllRecInConflict()[0]
message_pattern = _('An instant recording on %(channel)s will be stopped when this recording starts.')
message = message_pattern % {'name': ellipsize(conflicting_rec.name, 40), 'start_time': seconds_to_hhmm(conflicting_rec.start_time), 'channel': conflicting_rec.service_name}
title = _('Conflict with an instant recording')
MessageWindow(message, title, button=None).show(timeout=5)
]:
	i: 289(t)
	o: 766(JA)

nname: 289
n 289(<dummy_ex3> EXC_MATCH SchedulerConflictWithInstantRecordError)[]:
	i: 46(except)
	o: 299(t), 459(f)

nname: 232
n 232(None)[WyRecord().scheduler.ScheduleRecording(chan_id, start_time, end_time, record_name, program_id=program.id, favorite=favorite_name)
louie_send('update_record')
]:
	i: 46(try)
	o: 766(JA)

nname: 46
n 46(None)[start_time = max(now, program.start_time)
end_time = min(program.end_time, start_time + 21600)
channel = self['channel_list'].selected
chan_id = int(channel['serviceId'])
favorite_name = self.channel_list.name
values = {'channel': self['channel_list'].selected.name, 'title': program.name, 'date': strftime('%Y/%m/%d', localtime(start_time)), 'start_time': seconds_to_hhmm(start_time), 'end_time': seconds_to_hhmm(end_time)}
record_name = EPG_RECORDING_NAME_PATTERN % values
]:
	i: 0(t)
	o: 232(try), 289(except)

nname: 0
n 0(program.end_time > now)[program = self.displayed_programs[self.selected_program]
now = int(time())
]:
	i: 
	o: 46(t), 704(f)

nname: 766
n 766(None)[return None
]:
	i: 289(JA), 704()
	o: 

nname: 704
n 704(None)[message = _('The program is over. You cannot record it.')
title = _('Program already over')
win = MessageWindow(message, title, button=None)
win.show(timeout=5)
]:
	i: 0(f)
	o: 766()

nname: 289
n 289(None)[except SchedulerConflictWithInstantRecordError, e:
	louie_send('update_record', sender=None)
	conflicting_rec = e.conflict.getAllRecInConflict()[0]
	message_pattern = _('An instant recording on %(channel)s will be stopped when this recording starts.')
	message = message_pattern % {'name': ellipsize(conflicting_rec.name, 40), 'start_time': seconds_to_hhmm(conflicting_rec.start_time), 'channel': conflicting_rec.service_name}
	title = _('Conflict with an instant recording')
	MessageWindow(message, title, button=None).show(timeout=5)
except:
	except SchedulerConflictError, e:
		conflicting_rec = e.conflict.getAllRecInConflict()[0]
		message_pattern = _('The recording you are attempting to schedule conflicts with "%(name)s", starting at %(start_time)s on %(channel)s.')
		message = message_pattern % {'name': ellipsize(conflicting_rec.name, 40), 'start_time': seconds_to_hhmm(conflicting_rec.start_time), 'channel': conflicting_rec.service_name}
		title = _('Recording scheduler error')
		MessageWindow(message, title, button=None).show(timeout=5)
	except:
		except SchedulerError, e:
			log.error("Can't start recording due to %s", e)
			title = _('Recording scheduler error')
			message = 'Unable to schedule your recording. Sorry.'
			MessageWindow(message, title, button=None).show(timeout=5)
]:
	i: 46()
	o: 766(JA)

nname: 46
n 46(None)[start_time = max(now, program.start_time)
end_time = min(program.end_time, start_time + 21600)
channel = self['channel_list'].selected
chan_id = int(channel['serviceId'])
favorite_name = self.channel_list.name
values = {'channel': self['channel_list'].selected.name, 'title': program.name, 'date': strftime('%Y/%m/%d', localtime(start_time)), 'start_time': seconds_to_hhmm(start_time), 'end_time': seconds_to_hhmm(end_time)}
record_name = EPG_RECORDING_NAME_PATTERN % values
try:
	WyRecord().scheduler.ScheduleRecording(chan_id, start_time, end_time, record_name, program_id=program.id, favorite=favorite_name)
	louie_send('update_record')
]:
	i: 0(t)
	o: 289()

nname: 0
n 0(program.end_time > now)[program = self.displayed_programs[self.selected_program]
now = int(time())
]:
	i: 
	o: 46(t), 704(f)

nname: 766
n 766(None)[return None
]:
	i: 46(JA), 704()
	o: 

nname: 704
n 704(None)[message = _('The program is over. You cannot record it.')
title = _('Program already over')
win = MessageWindow(message, title, button=None)
win.show(timeout=5)
]:
	i: 0(f)
	o: 766()

nname: 46
n 46(None)[start_time = max(now, program.start_time)
end_time = min(program.end_time, start_time + 21600)
channel = self['channel_list'].selected
chan_id = int(channel['serviceId'])
favorite_name = self.channel_list.name
values = {'channel': self['channel_list'].selected.name, 'title': program.name, 'date': strftime('%Y/%m/%d', localtime(start_time)), 'start_time': seconds_to_hhmm(start_time), 'end_time': seconds_to_hhmm(end_time)}
record_name = EPG_RECORDING_NAME_PATTERN % values
try:
	WyRecord().scheduler.ScheduleRecording(chan_id, start_time, end_time, record_name, program_id=program.id, favorite=favorite_name)
	louie_send('update_record')
except SchedulerConflictWithInstantRecordError, e:
	louie_send('update_record', sender=None)
	conflicting_rec = e.conflict.getAllRecInConflict()[0]
	message_pattern = _('An instant recording on %(channel)s will be stopped when this recording starts.')
	message = message_pattern % {'name': ellipsize(conflicting_rec.name, 40), 'start_time': seconds_to_hhmm(conflicting_rec.start_time), 'channel': conflicting_rec.service_name}
	title = _('Conflict with an instant recording')
	MessageWindow(message, title, button=None).show(timeout=5)
except:
	except SchedulerConflictError, e:
		conflicting_rec = e.conflict.getAllRecInConflict()[0]
		message_pattern = _('The recording you are attempting to schedule conflicts with "%(name)s", starting at %(start_time)s on %(channel)s.')
		message = message_pattern % {'name': ellipsize(conflicting_rec.name, 40), 'start_time': seconds_to_hhmm(conflicting_rec.start_time), 'channel': conflicting_rec.service_name}
		title = _('Recording scheduler error')
		MessageWindow(message, title, button=None).show(timeout=5)
	except:
		except SchedulerError, e:
			log.error("Can't start recording due to %s", e)
			title = _('Recording scheduler error')
			message = 'Unable to schedule your recording. Sorry.'
			MessageWindow(message, title, button=None).show(timeout=5)
]:
	i: 0(t)
	o: 766(JA)

nname: 0
n 0(program.end_time > now)[program = self.displayed_programs[self.selected_program]
now = int(time())
]:
	i: 
	o: 46(t), 704(f)

nname: 0
n 0(None)[program = self.displayed_programs[self.selected_program]
now = int(time())
if program.end_time > now:
	start_time = max(now, program.start_time)
	end_time = min(program.end_time, start_time + 21600)
	channel = self['channel_list'].selected
	chan_id = int(channel['serviceId'])
	favorite_name = self.channel_list.name
	values = {'channel': self['channel_list'].selected.name, 'title': program.name, 'date': strftime('%Y/%m/%d', localtime(start_time)), 'start_time': seconds_to_hhmm(start_time), 'end_time': seconds_to_hhmm(end_time)}
	record_name = EPG_RECORDING_NAME_PATTERN % values
	try:
		WyRecord().scheduler.ScheduleRecording(chan_id, start_time, end_time, record_name, program_id=program.id, favorite=favorite_name)
		louie_send('update_record')
	except SchedulerConflictWithInstantRecordError, e:
		louie_send('update_record', sender=None)
		conflicting_rec = e.conflict.getAllRecInConflict()[0]
		message_pattern = _('An instant recording on %(channel)s will be stopped when this recording starts.')
		message = message_pattern % {'name': ellipsize(conflicting_rec.name, 40), 'start_time': seconds_to_hhmm(conflicting_rec.start_time), 'channel': conflicting_rec.service_name}
		title = _('Conflict with an instant recording')
		MessageWindow(message, title, button=None).show(timeout=5)
	except:
		except SchedulerConflictError, e:
			conflicting_rec = e.conflict.getAllRecInConflict()[0]
			message_pattern = _('The recording you are attempting to schedule conflicts with "%(name)s", starting at %(start_time)s on %(channel)s.')
			message = message_pattern % {'name': ellipsize(conflicting_rec.name, 40), 'start_time': seconds_to_hhmm(conflicting_rec.start_time), 'channel': conflicting_rec.service_name}
			title = _('Recording scheduler error')
			MessageWindow(message, title, button=None).show(timeout=5)
		except:
			except SchedulerError, e:
				log.error("Can't start recording due to %s", e)
				title = _('Recording scheduler error')
				message = 'Unable to schedule your recording. Sorry.'
				MessageWindow(message, title, button=None).show(timeout=5)
else:
	message = _('The program is over. You cannot record it.')
	title = _('Program already over')
	win = MessageWindow(message, title, button=None)
	win.show(timeout=5)
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x939d9ec>}
nname: 172
n 172(None)[return None
]:
	i: 51(JA), 94(JA), 158(), 161()
	o: 

nname: 161
n 161(None)[self._error_spawner()
]:
	i: 0(f)
	o: 172()

nname: 158
n 158(None)[]:
	i: 156(AE)
	o: 172()

nname: 156
n 156(None)[]:
	i: 84(f)
	o: 158(AE)

nname: 94
n 94(None)[error_title = _('Impossible to cancel recording')
message = _('This recording has already started. To stop it, close the EPG grid and press Stop.')
MessageWindow(message, error_title, button=None).show(timeout=5)
]:
	i: 84(t)
	o: 172(JA)

nname: 84
n 84(<dummy_ex3> EXC_MATCH SchedulerRecordingRunningError)[]:
	i: 31(except)
	o: 94(t), 156(f)

nname: 51
n 51(None)[WyRecord().scheduler.DeleteRecording(rec_id)
louie_send('update_record')
]:
	i: 31(try)
	o: 172(JA)

nname: 31
n 31(None)[log.info('Canceling recording for %s', program)
]:
	i: 0(t)
	o: 51(try), 84(except)

nname: 0
n 0(rec_id)[program = self.displayed_programs[self.selected_program]
rec_id = program.recording_id
]:
	i: 
	o: 31(t), 161(f)

nname: 172
n 172(None)[return None
]:
	i: 51(JA), 94(JA), 161(), 84(f), 156(AE)
	o: 

nname: 161
n 161(None)[self._error_spawner()
]:
	i: 0(f)
	o: 172()

nname: 94
n 94(None)[error_title = _('Impossible to cancel recording')
message = _('This recording has already started. To stop it, close the EPG grid and press Stop.')
MessageWindow(message, error_title, button=None).show(timeout=5)
]:
	i: 84(t)
	o: 172(JA)

nname: 84
n 84(<dummy_ex3> EXC_MATCH SchedulerRecordingRunningError)[]:
	i: 31(except)
	o: 94(t), 172(f)

nname: 51
n 51(None)[WyRecord().scheduler.DeleteRecording(rec_id)
louie_send('update_record')
]:
	i: 31(try)
	o: 172(JA)

nname: 31
n 31(None)[log.info('Canceling recording for %s', program)
]:
	i: 0(t)
	o: 51(try), 84(except)

nname: 0
n 0(rec_id)[program = self.displayed_programs[self.selected_program]
rec_id = program.recording_id
]:
	i: 
	o: 31(t), 161(f)

nname: 172
n 172(None)[return None
]:
	i: 161(), 84(f)
	o: 

nname: 161
n 161(None)[self._error_spawner()
]:
	i: 0(f)
	o: 172()

nname: 84
n 84(None)[except SchedulerRecordingRunningError:
	error_title = _('Impossible to cancel recording')
	message = _('This recording has already started. To stop it, close the EPG grid and press Stop.')
	MessageWindow(message, error_title, button=None).show(timeout=5)
]:
	i: 31()
	o: 172(JA)

nname: 31
n 31(None)[log.info('Canceling recording for %s', program)
try:
	WyRecord().scheduler.DeleteRecording(rec_id)
	louie_send('update_record')
]:
	i: 0(t)
	o: 84()

nname: 0
n 0(rec_id)[program = self.displayed_programs[self.selected_program]
rec_id = program.recording_id
]:
	i: 
	o: 31(t), 161(f)

nname: 172
n 172(None)[return None
]:
	i: 161(), 31(f)
	o: 

nname: 161
n 161(None)[self._error_spawner()
]:
	i: 0(f)
	o: 172()

nname: 31
n 31(None)[log.info('Canceling recording for %s', program)
try:
	WyRecord().scheduler.DeleteRecording(rec_id)
	louie_send('update_record')
except SchedulerRecordingRunningError:
	error_title = _('Impossible to cancel recording')
	message = _('This recording has already started. To stop it, close the EPG grid and press Stop.')
	MessageWindow(message, error_title, button=None).show(timeout=5)
]:
	i: 0(t)
	o: 172(JA)

nname: 0
n 0(rec_id)[program = self.displayed_programs[self.selected_program]
rec_id = program.recording_id
]:
	i: 
	o: 31(t), 161(f)

nname: 0
n 0(None)[program = self.displayed_programs[self.selected_program]
rec_id = program.recording_id
if rec_id:
	log.info('Canceling recording for %s', program)
	try:
		WyRecord().scheduler.DeleteRecording(rec_id)
		louie_send('update_record')
	except SchedulerRecordingRunningError:
		error_title = _('Impossible to cancel recording')
		message = _('This recording has already started. To stop it, close the EPG grid and press Stop.')
		MessageWindow(message, error_title, button=None).show(timeout=5)
else:
	self._error_spawner()
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76603ec>}
nname: 93
n 93(None)[]:
	i: 54(JA), 68(), 82()
	o: 

nname: 82
n 82(None)[self._error_spawner()
]:
	i: 0(f)
	o: 93()

nname: 68
n 68(None)[self.cancel_record_selected()
]:
	i: 32(f)
	o: 93()

nname: 54
n 54(None)[self.record_selected()
]:
	i: 32(t)
	o: 93(JA)

nname: 32
n 32(program.recording_status in (RECORDING_STATUS_UNKNOWN, RECORDING_STATUS_COMPLETED))[]:
	i: 0(t)
	o: 54(t), 68(f)

nname: 0
n 0('dummy' not in program['class'])[program = self.displayed_programs[self.selected_program]
]:
	i: 
	o: 32(t), 82(f)

nname: 0
n 0(None)[program = self.displayed_programs[self.selected_program]
if 'dummy' not in program['class']:
	if program.recording_status in (RECORDING_STATUS_UNKNOWN, RECORDING_STATUS_COMPLETED):
		self.record_selected()
	else:
		self.cancel_record_selected()
else:
	self._error_spawner()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7658cec>}
nname: 0
n 0(None)[self.select(event, 'main_list')
self.update_channels_timer.start(1)
self.refresh_timer.start(AUTO_REFRESH_DELAY, loop=True, consider_idle=True)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7658bac>}
nname: 87
n 87(None)[]:
	i: 38(), 64()
	o: 

nname: 64
n 64(None)[louie_send('info_icon', sender=self, value='none.png')
]:
	i: 0(f)
	o: 87()

nname: 38
n 38(None)[louie_send('info_icon', sender=self, value='info_icon.png')
]:
	i: 0(t)
	o: 87()

nname: 0
n 0('dummy' not in info_key)[prog = self.displayed_programs[self.selected_program]
info_key = prog['class']
]:
	i: 
	o: 38(t), 64(f)

nname: 0
n 0(None)[prog = self.displayed_programs[self.selected_program]
info_key = prog['class']
if 'dummy' not in info_key:
	louie_send('info_icon', sender=self, value='info_icon.png')
else:
	louie_send('info_icon', sender=self, value='none.png')
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7658fcc>}
nname: 0
n 0(None)[louie_send('clock', sender=self)
louie_send('clock', value=time())
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7658b4c>}
nname: 0
n 0(None)[self.tick_timer.stop()
self.refresh_timer.stop()
Menu.stop(self)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7658c8c>}
nname: 0
n 0(None)[return ts.datetime_to_timestamp(self.start_time)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7658aec>}
nname: 0
n 0(None)[self.start_time = datetime.datetime.fromtimestamp(value)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7658b0c>}
nname: 0
n 0(None)[return ts.datetime_to_timestamp(self.end_time)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7658dcc>}
nname: 0
n 0(None)[self.end_time = datetime.datetime.fromtimestamp(value)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7658aac>}
nname: 0
n 0(None)[self.start_time = start_time
self.end_time = end_time
louie_send('set_boundaries', start_ts=self.start_ts, end_ts=self.end_ts)
self.update_programs()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7658f6c>}
nname: 152
n 152(None)[self.select_program(0)
]:
	i: 99(), 138(), 151()
	o: 

nname: 151
n 151(None)[]:
	i: 125(f)
	o: 152()

nname: 138
n 138(None)[self.selected_program = 0
]:
	i: 125(t)
	o: 152()

nname: 125
n 125(value > 0)[]:
	i: 71(f)
	o: 138(t), 151(f)

nname: 99
n 99(None)[self.selected_program = len(self.displayed_programs) - 1
]:
	i: 71(t)
	o: 152()

nname: 71
n 71(value < 0)[self.set_boundaries(start_time, end_time)
]:
	i: 62(), 70()
	o: 99(t), 125(f)

nname: 70
n 70(None)[]:
	i: 59(t)
	o: 71()

nname: 62
n 62(None)[]:
	i: 59(f)
	o: 71()

nname: 59
n 59(self.lower_limit <= start_time)[]:
	i: 44(), 57()
	o: 62(f), 70(t)

nname: 57
n 57(None)[start_time
]:
	i: 0(f)
	o: 59()

nname: 44
n 44(None)[]:
	i: 0(t)
	o: 59()

nname: 0
n 0(self.lower_limit <= start_time)[start_time, end_time = ts.timeslice_boundaries(self.start_time, value)
]:
	i: 
	o: 44(t), 57(f)

nname: 71
n 71(None)[self.set_boundaries(start_time, end_time)
if value < 0:
	self.selected_program = len(self.displayed_programs) - 1
else:
	if value > 0:
		self.selected_program = 0
self.select_program(0)
]:
	i: 0()
	o: 

nname: 0
n 0(None)[start_time, end_time = ts.timeslice_boundaries(self.start_time, value)
if self.lower_limit <= start_time:
	pass
else:
	start_time
if not self.lower_limit <= start_time:
	pass
]:
	i: 
	o: 71()

nname: 0
n 0(None)[start_time, end_time = ts.timeslice_boundaries(self.start_time, value)
if self.lower_limit <= start_time:
	pass
else:
	start_time
if not self.lower_limit <= start_time:
	pass
self.set_boundaries(start_time, end_time)
if value < 0:
	self.selected_program = len(self.displayed_programs) - 1
else:
	if value > 0:
		self.selected_program = 0
self.select_program(0)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb766064c>}
nname: 0
n 0(None)[slice_count = ts.distance_to_visible_slice(self.start_time, value)
self.select_time_slice(slice_count)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7658acc>}
nname: 136
n 136(None)[self.select_current_program()
]:
	i: 71(), 109(), 135()
	o: 

nname: 135
n 135(None)[]:
	i: 84(f)
	o: 136()

nname: 109
n 109(None)[self.selected_program = len(self.displayed_programs) - 1
]:
	i: 84(t)
	o: 136()

nname: 84
n 84(self.selected_program >= len(self.displayed_programs))[]:
	i: 0(f)
	o: 109(t), 135(f)

nname: 71
n 71(None)[self.selected_program = 0
]:
	i: 0(t)
	o: 136()

nname: 0
n 0(self.selected_program < 0)[pos = self.get_item_list('main_list').selected_pos
self.get_item_list('channel_list').select(pos, force_pos=True)
self.update_programs()
]:
	i: 
	o: 71(t), 84(f)

nname: 0
n 0(None)[pos = self.get_item_list('main_list').selected_pos
self.get_item_list('channel_list').select(pos, force_pos=True)
self.update_programs()
if self.selected_program < 0:
	self.selected_program = 0
else:
	if self.selected_program >= len(self.displayed_programs):
		self.selected_program = len(self.displayed_programs) - 1
self.select_current_program()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb766064c>}
nname: 0
n 0(None)[selected_channel = self.get_item_list('channel_list').selected
self.displayed_programs[:] = selected_channel.browse(self.start_ts, self.end_ts, limit=10, pad=True, focus=time())
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7658fcc>}
nname: 0
n 0(None)[self.select_time_slice(0)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7658acc>}
nname: 91
n 91(None)[self.select_program(0)
]:
	i: 0(AL), 90()
	o: 

nname: 90
n 90(None)[]:
	i: 12(AF), 86()
	o: 91()

nname: 86
n 86(None)[]:
	i: 69(f), 72()
	o: 90()

nname: 72
n 72(None)[self.selected_program = i
break
continue
]:
	i: 69(t)
	o: 86()

nname: 69
n 69(prog.start_time <= now)[]:
	i: 54(), 67()
	o: 72(t), 86(f)

nname: 67
n 67(None)[now
]:
	i: 28(f)
	o: 69()

nname: 54
n 54(None)[]:
	i: 28(t)
	o: 69()

nname: 28
n 28(prog.start_time <= now)[for i, prog in enumerate(self.displayed_programs):
]:
	i: 12(for)
	o: 54(t), 67(f)

nname: 12
n 12(None)[]:
	i: 0(loop)
	o: 28(for), 90(AF)

nname: 0
n 0(None)[now = time()
]:
	i: 
	o: 12(loop), 91(AL)

nname: 91
n 91(None)[self.select_program(0)
]:
	i: 0(AL), 12(AF), 28(f)
	o: 

nname: 28
n 28(None)[for i, prog in enumerate(self.displayed_programs):
if prog.start_time <= now:
	pass
else:
	now
if prog.start_time <= now:
	self.selected_program = i
	break
	continue
]:
	i: 12(for)
	o: 91()

nname: 12
n 12(None)[]:
	i: 0(loop)
	o: 28(for), 91(AF)

nname: 0
n 0(None)[now = time()
]:
	i: 
	o: 12(loop), 91(AL)

nname: 28
n 28(None)[for i, prog in enumerate(self.displayed_programs):
	if prog.start_time <= now:
		pass
	else:
		now
	if prog.start_time <= now:
		self.selected_program = i
		break
		continue
self.select_program(0)
]:
	i: 0(for)
	o: 

nname: 0
n 0(None)[now = time()
]:
	i: 
	o: 28(for)

nname: 0
n 0(None)[now = time()
for i, prog in enumerate(self.displayed_programs):
	if prog.start_time <= now:
		pass
	else:
		now
	if prog.start_time <= now:
		self.selected_program = i
		break
		continue
self.select_program(0)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7658cec>}
nname: 94
n 94(None)[return ''
]:
	i: 9(), 93()
	o: 

nname: 93
n 93(None)[]:
	i: 0(f)
	o: 94()

nname: 9
n 9(None)[time_tuple = localtime(self.displayed_programs[self.selected_program].start_time)
wday = day_dict[time_tuple[6]]
month = month_dict[time_tuple[1]]
day = time_tuple[2]
return u'%s %s %s' % (wday, day, month)
]:
	i: 0(t)
	o: 94()

nname: 0
n 0(self.displayed_programs)[]:
	i: 
	o: 9(t), 93(f)

nname: 0
n 0(None)[if self.displayed_programs:
	time_tuple = localtime(self.displayed_programs[self.selected_program].start_time)
	wday = day_dict[time_tuple[6]]
	month = month_dict[time_tuple[1]]
	day = time_tuple[2]
	return u'%s %s %s' % (wday, day, month)
return ''
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7658f6c>}
nname: 6
n 6(None)[__doc__ = 'Model class for the main EPG grid.'
def __init__(self, player, channel_list, universe='tv', selected_chan=0):
	Menu.__init__(self, name='EPG Grid', choices=[], type='epg_grid', universe=universe)
	self.eventhandler = EpgGridEventHandler(self)
	self.player = player
	self.start_time, self.end_time = ts.current_timeslice()
	self.lower_limit = ts.get_epg_day(self.start_time)
	self.upper_limit = self.start_time + datetime.timedelta(days=7)
	self.displayed_programs = []
	self.selected_program = 0
	self._summarized_info = dict()
	self._getitems_keywords.update({'clock': (lambda : None), 'channel_list': (lambda : self.get_item_list('channel_list')), 'channel_list_name': (lambda : self.channel_list.name), 'info_press': (lambda : self._summarized_info['info_press']), 'info_icon': (lambda : self._summarized_info['info_icon']), 'selected_program_name': (lambda : self._summarized_info['program_name']), 'selected_program_duration': (lambda : self._summarized_info['program_duration']), 'selected_program_date': (lambda : self._summarized_info['program_date']), 'selected_program_start_time': (lambda : self._summarized_info['program_start']), 'selected_program_maturity_rating': (lambda : self._summarized_info['program_maturity_rating']), 'selected_program_duration_caption': (lambda : _('Duration')), 'epg_control_window_caption': (lambda : _('EPG Control Window'))})
	self.update_channels_timer = Task(self.update_channels)
	self.refresh_timer = Task(self.refresh)
	self.set_channel_list(channel_list)
	self.select(selected_chan, 'main_list')
	self.select(selected_chan, 'channel_list')
	self.update_programs()
	now = time()
	for i, prog in enumerate(self.displayed_programs):
		if prog.start_time <= now and prog.end_time >= now:
			self.selected_program = i
			self.select_program(0)
			break
			continue
	self.tick_timer = Task(self.tick_callback)
	self.tick_timer.start(5, loop=True)
	self.refresh_timer.start(AUTO_REFRESH_DELAY, loop=True, consider_idle=True)

def display_control_window(self):
	EpgControlWindowMenu(self).show()

def display_info_banner(self):
	program = self.displayed_programs[self.selected_program]
	if 'dummy' not in program['class']:
		EpgInfoBanner(program).show()

def zap_to_selected(self):
	if self.player.can_zap():
		channel = self.get_item_list('main_list').selected
		self.hide()
		channel.execute()
		return True
	else:
		title = _("Can't change channels")
		message = _('A recording is in progress. Stop it before zapping.')
		MessageWindow(message, title, button=None).show(timeout=5)
	return None

def record_selected(self):
	program = self.displayed_programs[self.selected_program]
	now = int(time())
	if program.end_time > now:
		start_time = max(now, program.start_time)
		end_time = min(program.end_time, start_time + 21600)
		channel = self['channel_list'].selected
		chan_id = int(channel['serviceId'])
		favorite_name = self.channel_list.name
		values = {'channel': self['channel_list'].selected.name, 'title': program.name, 'date': strftime('%Y/%m/%d', localtime(start_time)), 'start_time': seconds_to_hhmm(start_time), 'end_time': seconds_to_hhmm(end_time)}
		record_name = EPG_RECORDING_NAME_PATTERN % values
		try:
			WyRecord().scheduler.ScheduleRecording(chan_id, start_time, end_time, record_name, program_id=program.id, favorite=favorite_name)
			louie_send('update_record')
		except SchedulerConflictWithInstantRecordError, e:
			louie_send('update_record', sender=None)
			conflicting_rec = e.conflict.getAllRecInConflict()[0]
			message_pattern = _('An instant recording on %(channel)s will be stopped when this recording starts.')
			message = message_pattern % {'name': ellipsize(conflicting_rec.name, 40), 'start_time': seconds_to_hhmm(conflicting_rec.start_time), 'channel': conflicting_rec.service_name}
			title = _('Conflict with an instant recording')
			MessageWindow(message, title, button=None).show(timeout=5)
		except:
			except SchedulerConflictError, e:
				conflicting_rec = e.conflict.getAllRecInConflict()[0]
				message_pattern = _('The recording you are attempting to schedule conflicts with "%(name)s", starting at %(start_time)s on %(channel)s.')
				message = message_pattern % {'name': ellipsize(conflicting_rec.name, 40), 'start_time': seconds_to_hhmm(conflicting_rec.start_time), 'channel': conflicting_rec.service_name}
				title = _('Recording scheduler error')
				MessageWindow(message, title, button=None).show(timeout=5)
			except:
				except SchedulerError, e:
					log.error("Can't start recording due to %s", e)
					title = _('Recording scheduler error')
					message = 'Unable to schedule your recording. Sorry.'
					MessageWindow(message, title, button=None).show(timeout=5)
	else:
		message = _('The program is over. You cannot record it.')
		title = _('Program already over')
		win = MessageWindow(message, title, button=None)
		win.show(timeout=5)
	return None

def cancel_record_selected(self):
	program = self.displayed_programs[self.selected_program]
	rec_id = program.recording_id
	if rec_id:
		log.info('Canceling recording for %s', program)
		try:
			WyRecord().scheduler.DeleteRecording(rec_id)
			louie_send('update_record')
		except SchedulerRecordingRunningError:
			error_title = _('Impossible to cancel recording')
			message = _('This recording has already started. To stop it, close the EPG grid and press Stop.')
			MessageWindow(message, error_title, button=None).show(timeout=5)
	else:
		self._error_spawner()
	return None

def action_record(self):
	program = self.displayed_programs[self.selected_program]
	if 'dummy' not in program['class']:
		if program.recording_status in (RECORDING_STATUS_UNKNOWN, RECORDING_STATUS_COMPLETED):
			self.record_selected()
		else:
			self.cancel_record_selected()
	else:
		self._error_spawner()

def select_channel(self, event):
	self.select(event, 'main_list')
	self.update_channels_timer.start(1)
	self.refresh_timer.start(AUTO_REFRESH_DELAY, loop=True, consider_idle=True)

select_program = selective_gui_updater('info_press', 'selected_program_name', 'selected_program_maturity_rating', 'selected_program_duration', 'selected_program_date', 'selected_program_start_time')()
def get_info_icon(self):
	prog = self.displayed_programs[self.selected_program]
	info_key = prog['class']
	if 'dummy' not in info_key:
		louie_send('info_icon', sender=self, value='info_icon.png')
	else:
		louie_send('info_icon', sender=self, value='none.png')

def tick_callback(self):
	louie_send('clock', sender=self)
	louie_send('clock', value=time())

def stop(self):
	self.tick_timer.stop()
	self.refresh_timer.stop()
	Menu.stop(self)

def _get_start_ts(self):
	return ts.datetime_to_timestamp(self.start_time)

def _set_start_ts(self, value):
	self.start_time = datetime.datetime.fromtimestamp(value)

def _get_end_ts(self):
	return ts.datetime_to_timestamp(self.end_time)

def _set_end_ts(self, value):
	self.end_time = datetime.datetime.fromtimestamp(value)

start_ts = property(_get_start_ts, _set_start_ts)
end_ts = property(_get_end_ts, _set_end_ts)
set_channel_list = selective_gui_updater('channel_list_name')()
def set_boundaries(self, start_time, end_time):
	self.start_time = start_time
	self.end_time = end_time
	louie_send('set_boundaries', start_ts=self.start_ts, end_ts=self.end_ts)
	self.update_programs()

def select_time_slice(self, value):
	start_time, end_time = ts.timeslice_boundaries(self.start_time, value)
	if self.lower_limit <= start_time:
		pass
	else:
		start_time
	if not self.lower_limit <= start_time:
		pass
	self.set_boundaries(start_time, end_time)
	if value < 0:
		self.selected_program = len(self.displayed_programs) - 1
	else:
		if value > 0:
			self.selected_program = 0
	self.select_program(0)

def select_visible_time_slice(self, value):
	slice_count = ts.distance_to_visible_slice(self.start_time, value)
	self.select_time_slice(slice_count)

def update_channels(self):
	pos = self.get_item_list('main_list').selected_pos
	self.get_item_list('channel_list').select(pos, force_pos=True)
	self.update_programs()
	if self.selected_program < 0:
		self.selected_program = 0
	else:
		if self.selected_program >= len(self.displayed_programs):
			self.selected_program = len(self.displayed_programs) - 1
	self.select_current_program()

def update_programs(self):
	selected_channel = self.get_item_list('channel_list').selected
	self.displayed_programs[:] = selected_channel.browse(self.start_ts, self.end_ts, limit=10, pad=True, focus=time())

def refresh(self):
	self.select_time_slice(0)

def select_current_program(self):
	now = time()
	for i, prog in enumerate(self.displayed_programs):
		if prog.start_time <= now:
			pass
		else:
			now
		if prog.start_time <= now:
			self.selected_program = i
			break
			continue
	self.select_program(0)

def get_selected_program_date(self):
	if self.displayed_programs:
		time_tuple = localtime(self.displayed_programs[self.selected_program].start_time)
		wday = day_dict[time_tuple[6]]
		month = month_dict[time_tuple[1]]
		day = time_tuple[2]
		return u'%s %s %s' % (wday, day, month)
	return ''

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb764bb4c>}
nname: 0
n 0(None)[from __future__ import absolute_import
import datetime
from peewee.messages import send as louie_send
from time import time, strftime, localtime
from peewee.debug import GET_LOGGER
from peewee.formatters import ellipsize, seconds_to_hhmm, seconds_to_hhmm_utc
from peewee.notifier import Task
from pygui.eventmanager.menus import EpgGridEventHandler
from pygui.facilities import timeslices as ts
from pygui.facilities.codemapping import day_dict, month_dict
from pygui.facilities.l10n import get_date_format
from pygui.item.mediaitem import Playlist
from pygui.menu import selective_gui_updater
from pygui.window import MessageWindow
from wyrecord import WyRecord
from wyrecord.exceptions import SchedulerConflictWithInstantRecordError, SchedulerConflictError, SchedulerError, SchedulerRecordingRunningError
from wyrecord.recording import RECORDING_STATUS_UNKNOWN, RECORDING_STATUS_COMPLETED
from .epg_extras import EpgControlWindowMenu, EpgInfoBanner
from ..core import Menu
log = GET_LOGGER(__name__)
AUTO_REFRESH_DELAY = 30
EPG_RECORDING_NAME_PATTERN = _('%(date)s %(channel)s %(title)s')
class EpgGridMenu(Menu):
	__doc__ = 'Model class for the main EPG grid.'
	def __init__(self, player, channel_list, universe='tv', selected_chan=0):
		Menu.__init__(self, name='EPG Grid', choices=[], type='epg_grid', universe=universe)
		self.eventhandler = EpgGridEventHandler(self)
		self.player = player
		self.start_time, self.end_time = ts.current_timeslice()
		self.lower_limit = ts.get_epg_day(self.start_time)
		self.upper_limit = self.start_time + datetime.timedelta(days=7)
		self.displayed_programs = []
		self.selected_program = 0
		self._summarized_info = dict()
		self._getitems_keywords.update({'clock': (lambda : None), 'channel_list': (lambda : self.get_item_list('channel_list')), 'channel_list_name': (lambda : self.channel_list.name), 'info_press': (lambda : self._summarized_info['info_press']), 'info_icon': (lambda : self._summarized_info['info_icon']), 'selected_program_name': (lambda : self._summarized_info['program_name']), 'selected_program_duration': (lambda : self._summarized_info['program_duration']), 'selected_program_date': (lambda : self._summarized_info['program_date']), 'selected_program_start_time': (lambda : self._summarized_info['program_start']), 'selected_program_maturity_rating': (lambda : self._summarized_info['program_maturity_rating']), 'selected_program_duration_caption': (lambda : _('Duration')), 'epg_control_window_caption': (lambda : _('EPG Control Window'))})
		self.update_channels_timer = Task(self.update_channels)
		self.refresh_timer = Task(self.refresh)
		self.set_channel_list(channel_list)
		self.select(selected_chan, 'main_list')
		self.select(selected_chan, 'channel_list')
		self.update_programs()
		now = time()
		for i, prog in enumerate(self.displayed_programs):
			if prog.start_time <= now and prog.end_time >= now:
				self.selected_program = i
				self.select_program(0)
				break
				continue
		self.tick_timer = Task(self.tick_callback)
		self.tick_timer.start(5, loop=True)
		self.refresh_timer.start(AUTO_REFRESH_DELAY, loop=True, consider_idle=True)

	def display_control_window(self):
		EpgControlWindowMenu(self).show()

	def display_info_banner(self):
		program = self.displayed_programs[self.selected_program]
		if 'dummy' not in program['class']:
			EpgInfoBanner(program).show()

	def zap_to_selected(self):
		if self.player.can_zap():
			channel = self.get_item_list('main_list').selected
			self.hide()
			channel.execute()
			return True
		else:
			title = _("Can't change channels")
			message = _('A recording is in progress. Stop it before zapping.')
			MessageWindow(message, title, button=None).show(timeout=5)
		return None

	def record_selected(self):
		program = self.displayed_programs[self.selected_program]
		now = int(time())
		if program.end_time > now:
			start_time = max(now, program.start_time)
			end_time = min(program.end_time, start_time + 21600)
			channel = self['channel_list'].selected
			chan_id = int(channel['serviceId'])
			favorite_name = self.channel_list.name
			values = {'channel': self['channel_list'].selected.name, 'title': program.name, 'date': strftime('%Y/%m/%d', localtime(start_time)), 'start_time': seconds_to_hhmm(start_time), 'end_time': seconds_to_hhmm(end_time)}
			record_name = EPG_RECORDING_NAME_PATTERN % values
			try:
				WyRecord().scheduler.ScheduleRecording(chan_id, start_time, end_time, record_name, program_id=program.id, favorite=favorite_name)
				louie_send('update_record')
			except SchedulerConflictWithInstantRecordError, e:
				louie_send('update_record', sender=None)
				conflicting_rec = e.conflict.getAllRecInConflict()[0]
				message_pattern = _('An instant recording on %(channel)s will be stopped when this recording starts.')
				message = message_pattern % {'name': ellipsize(conflicting_rec.name, 40), 'start_time': seconds_to_hhmm(conflicting_rec.start_time), 'channel': conflicting_rec.service_name}
				title = _('Conflict with an instant recording')
				MessageWindow(message, title, button=None).show(timeout=5)
			except:
				except SchedulerConflictError, e:
					conflicting_rec = e.conflict.getAllRecInConflict()[0]
					message_pattern = _('The recording you are attempting to schedule conflicts with "%(name)s", starting at %(start_time)s on %(channel)s.')
					message = message_pattern % {'name': ellipsize(conflicting_rec.name, 40), 'start_time': seconds_to_hhmm(conflicting_rec.start_time), 'channel': conflicting_rec.service_name}
					title = _('Recording scheduler error')
					MessageWindow(message, title, button=None).show(timeout=5)
				except:
					except SchedulerError, e:
						log.error("Can't start recording due to %s", e)
						title = _('Recording scheduler error')
						message = 'Unable to schedule your recording. Sorry.'
						MessageWindow(message, title, button=None).show(timeout=5)
		else:
			message = _('The program is over. You cannot record it.')
			title = _('Program already over')
			win = MessageWindow(message, title, button=None)
			win.show(timeout=5)
		return None

	def cancel_record_selected(self):
		program = self.displayed_programs[self.selected_program]
		rec_id = program.recording_id
		if rec_id:
			log.info('Canceling recording for %s', program)
			try:
				WyRecord().scheduler.DeleteRecording(rec_id)
				louie_send('update_record')
			except SchedulerRecordingRunningError:
				error_title = _('Impossible to cancel recording')
				message = _('This recording has already started. To stop it, close the EPG grid and press Stop.')
				MessageWindow(message, error_title, button=None).show(timeout=5)
		else:
			self._error_spawner()
		return None

	def action_record(self):
		program = self.displayed_programs[self.selected_program]
		if 'dummy' not in program['class']:
			if program.recording_status in (RECORDING_STATUS_UNKNOWN, RECORDING_STATUS_COMPLETED):
				self.record_selected()
			else:
				self.cancel_record_selected()
		else:
			self._error_spawner()

	def select_channel(self, event):
		self.select(event, 'main_list')
		self.update_channels_timer.start(1)
		self.refresh_timer.start(AUTO_REFRESH_DELAY, loop=True, consider_idle=True)

	select_program = selective_gui_updater('info_press', 'selected_program_name', 'selected_program_maturity_rating', 'selected_program_duration', 'selected_program_date', 'selected_program_start_time')()
	def get_info_icon(self):
		prog = self.displayed_programs[self.selected_program]
		info_key = prog['class']
		if 'dummy' not in info_key:
			louie_send('info_icon', sender=self, value='info_icon.png')
		else:
			louie_send('info_icon', sender=self, value='none.png')

	def tick_callback(self):
		louie_send('clock', sender=self)
		louie_send('clock', value=time())

	def stop(self):
		self.tick_timer.stop()
		self.refresh_timer.stop()
		Menu.stop(self)

	def _get_start_ts(self):
		return ts.datetime_to_timestamp(self.start_time)

	def _set_start_ts(self, value):
		self.start_time = datetime.datetime.fromtimestamp(value)

	def _get_end_ts(self):
		return ts.datetime_to_timestamp(self.end_time)

	def _set_end_ts(self, value):
		self.end_time = datetime.datetime.fromtimestamp(value)

	start_ts = property(_get_start_ts, _set_start_ts)
	end_ts = property(_get_end_ts, _set_end_ts)
	set_channel_list = selective_gui_updater('channel_list_name')()
	def set_boundaries(self, start_time, end_time):
		self.start_time = start_time
		self.end_time = end_time
		louie_send('set_boundaries', start_ts=self.start_ts, end_ts=self.end_ts)
		self.update_programs()

	def select_time_slice(self, value):
		start_time, end_time = ts.timeslice_boundaries(self.start_time, value)
		if self.lower_limit <= start_time:
			pass
		else:
			start_time
		if not self.lower_limit <= start_time:
			pass
		self.set_boundaries(start_time, end_time)
		if value < 0:
			self.selected_program = len(self.displayed_programs) - 1
		else:
			if value > 0:
				self.selected_program = 0
		self.select_program(0)

	def select_visible_time_slice(self, value):
		slice_count = ts.distance_to_visible_slice(self.start_time, value)
		self.select_time_slice(slice_count)

	def update_channels(self):
		pos = self.get_item_list('main_list').selected_pos
		self.get_item_list('channel_list').select(pos, force_pos=True)
		self.update_programs()
		if self.selected_program < 0:
			self.selected_program = 0
		else:
			if self.selected_program >= len(self.displayed_programs):
				self.selected_program = len(self.displayed_programs) - 1
		self.select_current_program()

	def update_programs(self):
		selected_channel = self.get_item_list('channel_list').selected
		self.displayed_programs[:] = selected_channel.browse(self.start_ts, self.end_ts, limit=10, pad=True, focus=time())

	def refresh(self):
		self.select_time_slice(0)

	def select_current_program(self):
		now = time()
		for i, prog in enumerate(self.displayed_programs):
			if prog.start_time <= now:
				pass
			else:
				now
			if prog.start_time <= now:
				self.selected_program = i
				break
				continue
		self.select_program(0)

	def get_selected_program_date(self):
		if self.displayed_programs:
			time_tuple = localtime(self.displayed_programs[self.selected_program].start_time)
			wday = day_dict[time_tuple[6]]
			month = month_dict[time_tuple[1]]
			day = time_tuple[2]
			return u'%s %s %s' % (wday, day, month)
		return ''



]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb764456c>}
from __future__ import absolute_import
import datetime
from peewee.messages import send as louie_send
from time import time, strftime, localtime
from peewee.debug import GET_LOGGER
from peewee.formatters import ellipsize, seconds_to_hhmm, seconds_to_hhmm_utc
from peewee.notifier import Task
from pygui.eventmanager.menus import EpgGridEventHandler
from pygui.facilities import timeslices as ts
from pygui.facilities.codemapping import day_dict, month_dict
from pygui.facilities.l10n import get_date_format
from pygui.item.mediaitem import Playlist
from pygui.menu import selective_gui_updater
from pygui.window import MessageWindow
from wyrecord import WyRecord
from wyrecord.exceptions import SchedulerConflictWithInstantRecordError, SchedulerConflictError, SchedulerError, SchedulerRecordingRunningError
from wyrecord.recording import RECORDING_STATUS_UNKNOWN, RECORDING_STATUS_COMPLETED
from .epg_extras import EpgControlWindowMenu, EpgInfoBanner
from ..core import Menu
log = GET_LOGGER(__name__)
AUTO_REFRESH_DELAY = 30
EPG_RECORDING_NAME_PATTERN = _('%(date)s %(channel)s %(title)s')
class EpgGridMenu(Menu):
	__doc__ = 'Model class for the main EPG grid.'
	def __init__(self, player, channel_list, universe='tv', selected_chan=0):
		Menu.__init__(self, name='EPG Grid', choices=[], type='epg_grid', universe=universe)
		self.eventhandler = EpgGridEventHandler(self)
		self.player = player
		self.start_time, self.end_time = ts.current_timeslice()
		self.lower_limit = ts.get_epg_day(self.start_time)
		self.upper_limit = self.start_time + datetime.timedelta(days=7)
		self.displayed_programs = []
		self.selected_program = 0
		self._summarized_info = dict()
		self._getitems_keywords.update({'clock': (lambda : None), 'channel_list': (lambda : self.get_item_list('channel_list')), 'channel_list_name': (lambda : self.channel_list.name), 'info_press': (lambda : self._summarized_info['info_press']), 'info_icon': (lambda : self._summarized_info['info_icon']), 'selected_program_name': (lambda : self._summarized_info['program_name']), 'selected_program_duration': (lambda : self._summarized_info['program_duration']), 'selected_program_date': (lambda : self._summarized_info['program_date']), 'selected_program_start_time': (lambda : self._summarized_info['program_start']), 'selected_program_maturity_rating': (lambda : self._summarized_info['program_maturity_rating']), 'selected_program_duration_caption': (lambda : _('Duration')), 'epg_control_window_caption': (lambda : _('EPG Control Window'))})
		self.update_channels_timer = Task(self.update_channels)
		self.refresh_timer = Task(self.refresh)
		self.set_channel_list(channel_list)
		self.select(selected_chan, 'main_list')
		self.select(selected_chan, 'channel_list')
		self.update_programs()
		now = time()
		for i, prog in enumerate(self.displayed_programs):
			if prog.start_time <= now and prog.end_time >= now:
				self.selected_program = i
				self.select_program(0)
				break
				continue
		self.tick_timer = Task(self.tick_callback)
		self.tick_timer.start(5, loop=True)
		self.refresh_timer.start(AUTO_REFRESH_DELAY, loop=True, consider_idle=True)

	def display_control_window(self):
		EpgControlWindowMenu(self).show()

	def display_info_banner(self):
		program = self.displayed_programs[self.selected_program]
		if 'dummy' not in program['class']:
			EpgInfoBanner(program).show()

	def zap_to_selected(self):
		if self.player.can_zap():
			channel = self.get_item_list('main_list').selected
			self.hide()
			channel.execute()
			return True
		else:
			title = _("Can't change channels")
			message = _('A recording is in progress. Stop it before zapping.')
			MessageWindow(message, title, button=None).show(timeout=5)
		return None

	def record_selected(self):
		program = self.displayed_programs[self.selected_program]
		now = int(time())
		if program.end_time > now:
			start_time = max(now, program.start_time)
			end_time = min(program.end_time, start_time + 21600)
			channel = self['channel_list'].selected
			chan_id = int(channel['serviceId'])
			favorite_name = self.channel_list.name
			values = {'channel': self['channel_list'].selected.name, 'title': program.name, 'date': strftime('%Y/%m/%d', localtime(start_time)), 'start_time': seconds_to_hhmm(start_time), 'end_time': seconds_to_hhmm(end_time)}
			record_name = EPG_RECORDING_NAME_PATTERN % values
			try:
				WyRecord().scheduler.ScheduleRecording(chan_id, start_time, end_time, record_name, program_id=program.id, favorite=favorite_name)
				louie_send('update_record')
			except SchedulerConflictWithInstantRecordError, e:
				louie_send('update_record', sender=None)
				conflicting_rec = e.conflict.getAllRecInConflict()[0]
				message_pattern = _('An instant recording on %(channel)s will be stopped when this recording starts.')
				message = message_pattern % {'name': ellipsize(conflicting_rec.name, 40), 'start_time': seconds_to_hhmm(conflicting_rec.start_time), 'channel': conflicting_rec.service_name}
				title = _('Conflict with an instant recording')
				MessageWindow(message, title, button=None).show(timeout=5)
			except:
				except SchedulerConflictError, e:
					conflicting_rec = e.conflict.getAllRecInConflict()[0]
					message_pattern = _('The recording you are attempting to schedule conflicts with "%(name)s", starting at %(start_time)s on %(channel)s.')
					message = message_pattern % {'name': ellipsize(conflicting_rec.name, 40), 'start_time': seconds_to_hhmm(conflicting_rec.start_time), 'channel': conflicting_rec.service_name}
					title = _('Recording scheduler error')
					MessageWindow(message, title, button=None).show(timeout=5)
				except:
					except SchedulerError, e:
						log.error("Can't start recording due to %s", e)
						title = _('Recording scheduler error')
						message = 'Unable to schedule your recording. Sorry.'
						MessageWindow(message, title, button=None).show(timeout=5)
		else:
			message = _('The program is over. You cannot record it.')
			title = _('Program already over')
			win = MessageWindow(message, title, button=None)
			win.show(timeout=5)
		return None

	def cancel_record_selected(self):
		program = self.displayed_programs[self.selected_program]
		rec_id = program.recording_id
		if rec_id:
			log.info('Canceling recording for %s', program)
			try:
				WyRecord().scheduler.DeleteRecording(rec_id)
				louie_send('update_record')
			except SchedulerRecordingRunningError:
				error_title = _('Impossible to cancel recording')
				message = _('This recording has already started. To stop it, close the EPG grid and press Stop.')
				MessageWindow(message, error_title, button=None).show(timeout=5)
		else:
			self._error_spawner()
		return None

	def action_record(self):
		program = self.displayed_programs[self.selected_program]
		if 'dummy' not in program['class']:
			if program.recording_status in (RECORDING_STATUS_UNKNOWN, RECORDING_STATUS_COMPLETED):
				self.record_selected()
			else:
				self.cancel_record_selected()
		else:
			self._error_spawner()

	def select_channel(self, event):
		self.select(event, 'main_list')
		self.update_channels_timer.start(1)
		self.refresh_timer.start(AUTO_REFRESH_DELAY, loop=True, consider_idle=True)

	select_program = selective_gui_updater('info_press', 'selected_program_name', 'selected_program_maturity_rating', 'selected_program_duration', 'selected_program_date', 'selected_program_start_time')()
	def get_info_icon(self):
		prog = self.displayed_programs[self.selected_program]
		info_key = prog['class']
		if 'dummy' not in info_key:
			louie_send('info_icon', sender=self, value='info_icon.png')
		else:
			louie_send('info_icon', sender=self, value='none.png')

	def tick_callback(self):
		louie_send('clock', sender=self)
		louie_send('clock', value=time())

	def stop(self):
		self.tick_timer.stop()
		self.refresh_timer.stop()
		Menu.stop(self)

	def _get_start_ts(self):
		return ts.datetime_to_timestamp(self.start_time)

	def _set_start_ts(self, value):
		self.start_time = datetime.datetime.fromtimestamp(value)

	def _get_end_ts(self):
		return ts.datetime_to_timestamp(self.end_time)

	def _set_end_ts(self, value):
		self.end_time = datetime.datetime.fromtimestamp(value)

	start_ts = property(_get_start_ts, _set_start_ts)
	end_ts = property(_get_end_ts, _set_end_ts)
	set_channel_list = selective_gui_updater('channel_list_name')()
	def set_boundaries(self, start_time, end_time):
		self.start_time = start_time
		self.end_time = end_time
		louie_send('set_boundaries', start_ts=self.start_ts, end_ts=self.end_ts)
		self.update_programs()

	def select_time_slice(self, value):
		start_time, end_time = ts.timeslice_boundaries(self.start_time, value)
		if self.lower_limit <= start_time:
			pass
		else:
			start_time
		if not self.lower_limit <= start_time:
			pass
		self.set_boundaries(start_time, end_time)
		if value < 0:
			self.selected_program = len(self.displayed_programs) - 1
		else:
			if value > 0:
				self.selected_program = 0
		self.select_program(0)

	def select_visible_time_slice(self, value):
		slice_count = ts.distance_to_visible_slice(self.start_time, value)
		self.select_time_slice(slice_count)

	def update_channels(self):
		pos = self.get_item_list('main_list').selected_pos
		self.get_item_list('channel_list').select(pos, force_pos=True)
		self.update_programs()
		if self.selected_program < 0:
			self.selected_program = 0
		else:
			if self.selected_program >= len(self.displayed_programs):
				self.selected_program = len(self.displayed_programs) - 1
		self.select_current_program()

	def update_programs(self):
		selected_channel = self.get_item_list('channel_list').selected
		self.displayed_programs[:] = selected_channel.browse(self.start_ts, self.end_ts, limit=10, pad=True, focus=time())

	def refresh(self):
		self.select_time_slice(0)

	def select_current_program(self):
		now = time()
		for i, prog in enumerate(self.displayed_programs):
			if prog.start_time <= now:
				pass
			else:
				now
			if prog.start_time <= now:
				self.selected_program = i
				break
				continue
		self.select_program(0)

	def get_selected_program_date(self):
		if self.displayed_programs:
			time_tuple = localtime(self.displayed_programs[self.selected_program].start_time)
			wday = day_dict[time_tuple[6]]
			month = month_dict[time_tuple[1]]
			day = time_tuple[2]
			return u'%s %s %s' % (wday, day, month)
		return ''



