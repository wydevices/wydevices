# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 0
n 0(None)[self.data = []
sgmllib.SGMLParser.__init__(self)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76ee7ec>}
nname: 0
n 0(None)[self.data.append(' ')
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76ee88c>}
nname: 0
n 0(None)[self.data.append(' ')
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76ee8ac>}
nname: 0
n 0(None)[self.data.append(data)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76ee7ec>}
nname: 0
n 0(None)[return ''.join(self.data)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76ee88c>}
nname: 6
n 6(None)[__doc__ = ' HTML tags stripper '
def __init__(self):
	self.data = []
	sgmllib.SGMLParser.__init__(self)

def unknown_starttag(self, tag, attrib):
	self.data.append(' ')

def unknown_endtag(self, tag):
	self.data.append(' ')

def handle_data(self, data):
	self.data.append(data)

def gettext(self):
	return ''.join(self.data)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb76ee26c>}
nname: 0
n 0(None)[list.__init__(self)
self.callback = callback
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76ee4cc>}
nname: 0
n 0(None)[list.append(self, data)
self.callback(self)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76ee4ac>}
nname: 33
n 33(None)[self.callback(self)
]:
	i: 12(), 32()
	o: 

nname: 32
n 32(None)[]:
	i: 0(f)
	o: 33()

nname: 12
n 12(None)[list.remove(self, data)
]:
	i: 0(t)
	o: 33()

nname: 0
n 0(data in self)[]:
	i: 
	o: 12(t), 32(f)

nname: 0
n 0(None)[if data in self:
	list.remove(self, data)
self.callback(self)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76ee7ec>}
nname: 6
n 6(None)[__doc__ = ' Special list which call a callback function on append/remove '
def __init__(self, callback):
	list.__init__(self)
	self.callback = callback

def append(self, data):
	list.append(self, data)
	self.callback(self)

def remove(self, data):
	if data in self:
		list.remove(self, data)
	self.callback(self)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb76eaeec>}
nname: 47
n 47(None)[]:
	i: 0(AL), 46()
	o: 

nname: 46
n 46(None)[]:
	i: 3(AF), 42()
	o: 47()

nname: 42
n 42(None)[]:
	i: 10(t), 22()
	o: 46()

nname: 22
n 22(None)[list.remove(self, task)
continue
]:
	i: 10(f)
	o: 42()

nname: 10
n 10(task.running)[for task in self:
]:
	i: 3(for)
	o: 22(f), 42(t)

nname: 3
n 3(None)[]:
	i: 0(loop)
	o: 10(for), 46(AF)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 47(AL)

nname: 47
n 47(None)[]:
	i: 0(AL), 3(AF), 10()
	o: 

nname: 10
n 10(None)[for task in self:
if not task.running:
	list.remove(self, task)
	continue
]:
	i: 3(for)
	o: 47()

nname: 3
n 3(None)[]:
	i: 0(loop)
	o: 10(for), 47(AF)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 47(AL)

nname: 10
n 10(None)[for task in self:
	if not task.running:
		list.remove(self, task)
		continue
]:
	i: 0(for)
	o: 

nname: 0
n 0(None)[]:
	i: 
	o: 10(for)

nname: 0
n 0(None)[for task in self:
	if not task.running:
		list.remove(self, task)
		continue
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76eedac>}
nname: 0
n 0(None)[list.append(self, data)
self._cleanup()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76eed8c>}
nname: 33
n 33(None)[self._cleanup()
]:
	i: 12(), 32()
	o: 

nname: 32
n 32(None)[]:
	i: 0(f)
	o: 33()

nname: 12
n 12(None)[list.remove(self, data)
]:
	i: 0(t)
	o: 33()

nname: 0
n 0(data in self)[]:
	i: 
	o: 12(t), 32(f)

nname: 0
n 0(None)[if data in self:
	list.remove(self, data)
self._cleanup()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76eeaac>}
nname: 6
n 6(None)[__doc__ = ' Special list which remove old task on append/remove'
def _cleanup(self):
	for task in self:
		if not task.running:
			list.remove(self, task)
			continue

def append(self, data):
	list.append(self, data)
	self._cleanup()

def remove(self, data):
	if data in self:
		list.remove(self, data)
	self._cleanup()

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb76eaf6c>}
nname: 31
n 31(None)[self.txt_render = txt_render
self.freezed = False
self.task_list = TaskList()
self.wdb = WyDbus()
self.inst = self.wdb.instance(dbus_path)
self.inst.signal('text', 'sti', self.text, 0)
self.inst.signal('freeze', '', self.freeze, 0)
self.inst.signal('thaw', '', self.thaw, 0)
self.st = Stripper()
]:
	i: 0(t), 24()
	o: 

nname: 24
n 24(None)[]:
	i: 0(f)
	o: 31()

nname: 0
n 0(txt_render)[self.current_subs = SubList(self.sublist_callback)
]:
	i: 
	o: 24(f), 31(t)

nname: 0
n 0(None)[self.current_subs = SubList(self.sublist_callback)
if not txt_render:
	pass
self.txt_render = txt_render
self.freezed = False
self.task_list = TaskList()
self.wdb = WyDbus()
self.inst = self.wdb.instance(dbus_path)
self.inst.signal('text', 'sti', self.text, 0)
self.inst.signal('freeze', '', self.freeze, 0)
self.inst.signal('thaw', '', self.thaw, 0)
self.st = Stripper()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76f570c>}
nname: 0
n 0(None)[self.st.data = []
self.st.feed(sub)
self.st.close()
new = self.st.gettext()
return new
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76f536c>}
nname: 0
n 0(None)[self.txt_render(sublist)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76ee74c>}
nname: 0
n 0(None)[self.txt_render = f
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76eef2c>}
nname: 0
n 0(None)[self.txt_render = self.default_txt_render
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76eeacc>}
nname: 31
n 31(None)[]:
	i: 0(AL), 30()
	o: 

nname: 30
n 30(None)[]:
	i: 8(AF), 15()
	o: 31()

nname: 15
n 15(None)[for txt in sublist:
print '-> %s' % txt
]:
	i: 8(for)
	o: 30()

nname: 8
n 8(None)[]:
	i: 0(loop)
	o: 15(for), 30(AF)

nname: 0
n 0(None)[print '\n######## SUB #######'
]:
	i: 
	o: 8(loop), 31(AL)

nname: 31
n 31(None)[]:
	i: 15()
	o: 

nname: 15
n 15(None)[for txt in sublist:
	print '-> %s' % txt
]:
	i: 0(for)
	o: 31()

nname: 0
n 0(None)[print '\n######## SUB #######'
]:
	i: 
	o: 15(for)

nname: 31
n 31(None)[]:
	i: 0()
	o: 

nname: 0
n 0(None)[print '\n######## SUB #######'
for txt in sublist:
	print '-> %s' % txt
]:
	i: 
	o: 31()

nname: 0
n 0(None)[print '\n######## SUB #######'
for txt in sublist:
	print '-> %s' % txt
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76f11ac>}
nname: 38
n 38(None)[full_sub = str(sub)
full_sub = full_sub.replace('\r\n', '\n').replace('\r', '\n')
full_sub = self.strip_tag(full_sub)
self.task_list.append(Task(self.current_subs.append, full_sub).start(start_delay))
self.task_list.append(Task(self.current_subs.remove, full_sub).start(start_delay + lifetime))
]:
	i: 29(), 37()
	o: 

nname: 37
n 37(None)[]:
	i: 0(f)
	o: 38()

nname: 29
n 29(None)[return 0
]:
	i: 0(t)
	o: 38()

nname: 0
n 0(self.freezed)[start_delay = timestamp / 1000000.0
lifetime = lifetime / 1000.0
]:
	i: 
	o: 29(t), 37(f)

nname: 0
n 0(None)[start_delay = timestamp / 1000000.0
lifetime = lifetime / 1000.0
if self.freezed:
	return 0
full_sub = str(sub)
full_sub = full_sub.replace('\r\n', '\n').replace('\r', '\n')
full_sub = self.strip_tag(full_sub)
self.task_list.append(Task(self.current_subs.append, full_sub).start(start_delay))
self.task_list.append(Task(self.current_subs.remove, full_sub).start(start_delay + lifetime))
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76f170c>}
nname: 39
n 39(None)[]:
	i: 0(AL), 38()
	o: 

nname: 38
n 38(None)[]:
	i: 12(AF), 22()
	o: 39()

nname: 22
n 22(None)[for task in self.task_list:
task.pause()
]:
	i: 12(for)
	o: 38()

nname: 12
n 12(None)[]:
	i: 0(loop)
	o: 22(for), 38(AF)

nname: 0
n 0(None)[self.freezed = True
]:
	i: 
	o: 12(loop), 39(AL)

nname: 39
n 39(None)[]:
	i: 22()
	o: 

nname: 22
n 22(None)[for task in self.task_list:
	task.pause()
]:
	i: 0(for)
	o: 39()

nname: 0
n 0(None)[self.freezed = True
]:
	i: 
	o: 22(for)

nname: 39
n 39(None)[]:
	i: 0()
	o: 

nname: 0
n 0(None)[self.freezed = True
for task in self.task_list:
	task.pause()
]:
	i: 
	o: 39()

nname: 0
n 0(None)[self.freezed = True
for task in self.task_list:
	task.pause()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76f108c>}
nname: 39
n 39(None)[]:
	i: 0(AL), 38()
	o: 

nname: 38
n 38(None)[]:
	i: 12(AF), 22()
	o: 39()

nname: 22
n 22(None)[for task in self.task_list:
task.unpause()
]:
	i: 12(for)
	o: 38()

nname: 12
n 12(None)[]:
	i: 0(loop)
	o: 22(for), 38(AF)

nname: 0
n 0(None)[self.freezed = False
]:
	i: 
	o: 12(loop), 39(AL)

nname: 39
n 39(None)[]:
	i: 22()
	o: 

nname: 22
n 22(None)[for task in self.task_list:
	task.unpause()
]:
	i: 0(for)
	o: 39()

nname: 0
n 0(None)[self.freezed = False
]:
	i: 
	o: 22(for)

nname: 39
n 39(None)[]:
	i: 0()
	o: 

nname: 0
n 0(None)[self.freezed = False
for task in self.task_list:
	task.unpause()
]:
	i: 
	o: 39()

nname: 0
n 0(None)[self.freezed = False
for task in self.task_list:
	task.unpause()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76f104c>}
nname: 30
n 30(None)[self.current_subs = SubList(self.sublist_callback)
self.task_list = TaskList()
]:
	i: 0(AL), 29()
	o: 

nname: 29
n 29(None)[]:
	i: 3(AF), 13()
	o: 30()

nname: 13
n 13(None)[for task in self.task_list:
task.stop()
]:
	i: 3(for)
	o: 29()

nname: 3
n 3(None)[]:
	i: 0(loop)
	o: 13(for), 29(AF)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 30(AL)

nname: 30
n 30(None)[self.current_subs = SubList(self.sublist_callback)
self.task_list = TaskList()
]:
	i: 13()
	o: 

nname: 13
n 13(None)[for task in self.task_list:
	task.stop()
]:
	i: 0(for)
	o: 30()

nname: 0
n 0(None)[]:
	i: 
	o: 13(for)

nname: 30
n 30(None)[self.current_subs = SubList(self.sublist_callback)
self.task_list = TaskList()
]:
	i: 0()
	o: 

nname: 0
n 0(None)[for task in self.task_list:
	task.stop()
]:
	i: 
	o: 30()

nname: 0
n 0(None)[for task in self.task_list:
	task.stop()
self.current_subs = SubList(self.sublist_callback)
self.task_list = TaskList()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76f108c>}
nname: 6
n 6(None)[__metaclass__ = MetaSingleton
def __init__(self, dbus_path='/com/wyplay/SubServer', txt_render=None):
	self.current_subs = SubList(self.sublist_callback)
	if not txt_render:
		pass
	self.txt_render = txt_render
	self.freezed = False
	self.task_list = TaskList()
	self.wdb = WyDbus()
	self.inst = self.wdb.instance(dbus_path)
	self.inst.signal('text', 'sti', self.text, 0)
	self.inst.signal('freeze', '', self.freeze, 0)
	self.inst.signal('thaw', '', self.thaw, 0)
	self.st = Stripper()

def strip_tag(self, sub):
	self.st.data = []
	self.st.feed(sub)
	self.st.close()
	new = self.st.gettext()
	return new

def sublist_callback(self, sublist):
	self.txt_render(sublist)

def register_txt_render(self, f):
	self.txt_render = f

def unregister_txt_render(self):
	self.txt_render = self.default_txt_render

def default_txt_render(self, sublist):
	print '\n######## SUB #######'
	for txt in sublist:
		print '-> %s' % txt

def text(self, sub, timestamp, lifetime):
	start_delay = timestamp / 1000000.0
	lifetime = lifetime / 1000.0
	if self.freezed:
		return 0
	full_sub = str(sub)
	full_sub = full_sub.replace('\r\n', '\n').replace('\r', '\n')
	full_sub = self.strip_tag(full_sub)
	self.task_list.append(Task(self.current_subs.append, full_sub).start(start_delay))
	self.task_list.append(Task(self.current_subs.remove, full_sub).start(start_delay + lifetime))

def freeze(self):
	self.freezed = True
	for task in self.task_list:
		task.pause()

def thaw(self):
	self.freezed = False
	for task in self.task_list:
		task.unpause()

def clear(self):
	for task in self.task_list:
		task.stop()
	self.current_subs = SubList(self.sublist_callback)
	self.task_list = TaskList()

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb76ee12c>}
nname: 262
n 262(None)[]:
	i: 238(), 261()
	o: 

nname: 261
n 261(None)[]:
	i: 0(f)
	o: 262()

nname: 238
n 238(None)[s = SubServer()
notifier.loop()
]:
	i: 0(t)
	o: 262()

nname: 0
n 0(__name__ == '__main__')[from __future__ import absolute_import
import sgmllib
from time import time
from wydbus import WyDbus
from peewee.notifier import Task
from peewee.debug import GET_LOGGER
from peewee.misc_utils import MetaSingleton
import peewee.notifier as notifier
log = GET_LOGGER(__name__)
class Stripper(.):
	__doc__ = ' HTML tags stripper '
	def __init__(self):
		self.data = []
		sgmllib.SGMLParser.__init__(self)

	def unknown_starttag(self, tag, attrib):
		self.data.append(' ')

	def unknown_endtag(self, tag):
		self.data.append(' ')

	def handle_data(self, data):
		self.data.append(data)

	def gettext(self):
		return ''.join(self.data)



class SubList(list):
	__doc__ = ' Special list which call a callback function on append/remove '
	def __init__(self, callback):
		list.__init__(self)
		self.callback = callback

	def append(self, data):
		list.append(self, data)
		self.callback(self)

	def remove(self, data):
		if data in self:
			list.remove(self, data)
		self.callback(self)



class TaskList(list):
	__doc__ = ' Special list which remove old task on append/remove'
	def _cleanup(self):
		for task in self:
			if not task.running:
				list.remove(self, task)
				continue

	def append(self, data):
		list.append(self, data)
		self._cleanup()

	def remove(self, data):
		if data in self:
			list.remove(self, data)
		self._cleanup()



class SubServer(object):
	__metaclass__ = MetaSingleton
	def __init__(self, dbus_path='/com/wyplay/SubServer', txt_render=None):
		self.current_subs = SubList(self.sublist_callback)
		if not txt_render:
			pass
		self.txt_render = txt_render
		self.freezed = False
		self.task_list = TaskList()
		self.wdb = WyDbus()
		self.inst = self.wdb.instance(dbus_path)
		self.inst.signal('text', 'sti', self.text, 0)
		self.inst.signal('freeze', '', self.freeze, 0)
		self.inst.signal('thaw', '', self.thaw, 0)
		self.st = Stripper()

	def strip_tag(self, sub):
		self.st.data = []
		self.st.feed(sub)
		self.st.close()
		new = self.st.gettext()
		return new

	def sublist_callback(self, sublist):
		self.txt_render(sublist)

	def register_txt_render(self, f):
		self.txt_render = f

	def unregister_txt_render(self):
		self.txt_render = self.default_txt_render

	def default_txt_render(self, sublist):
		print '\n######## SUB #######'
		for txt in sublist:
			print '-> %s' % txt

	def text(self, sub, timestamp, lifetime):
		start_delay = timestamp / 1000000.0
		lifetime = lifetime / 1000.0
		if self.freezed:
			return 0
		full_sub = str(sub)
		full_sub = full_sub.replace('\r\n', '\n').replace('\r', '\n')
		full_sub = self.strip_tag(full_sub)
		self.task_list.append(Task(self.current_subs.append, full_sub).start(start_delay))
		self.task_list.append(Task(self.current_subs.remove, full_sub).start(start_delay + lifetime))

	def freeze(self):
		self.freezed = True
		for task in self.task_list:
			task.pause()

	def thaw(self):
		self.freezed = False
		for task in self.task_list:
			task.unpause()

	def clear(self):
		for task in self.task_list:
			task.stop()
		self.current_subs = SubList(self.sublist_callback)
		self.task_list = TaskList()



]:
	i: 
	o: 238(t), 261(f)

nname: 0
n 0(None)[from __future__ import absolute_import
import sgmllib
from time import time
from wydbus import WyDbus
from peewee.notifier import Task
from peewee.debug import GET_LOGGER
from peewee.misc_utils import MetaSingleton
import peewee.notifier as notifier
log = GET_LOGGER(__name__)
class Stripper(.):
	__doc__ = ' HTML tags stripper '
	def __init__(self):
		self.data = []
		sgmllib.SGMLParser.__init__(self)

	def unknown_starttag(self, tag, attrib):
		self.data.append(' ')

	def unknown_endtag(self, tag):
		self.data.append(' ')

	def handle_data(self, data):
		self.data.append(data)

	def gettext(self):
		return ''.join(self.data)



class SubList(list):
	__doc__ = ' Special list which call a callback function on append/remove '
	def __init__(self, callback):
		list.__init__(self)
		self.callback = callback

	def append(self, data):
		list.append(self, data)
		self.callback(self)

	def remove(self, data):
		if data in self:
			list.remove(self, data)
		self.callback(self)



class TaskList(list):
	__doc__ = ' Special list which remove old task on append/remove'
	def _cleanup(self):
		for task in self:
			if not task.running:
				list.remove(self, task)
				continue

	def append(self, data):
		list.append(self, data)
		self._cleanup()

	def remove(self, data):
		if data in self:
			list.remove(self, data)
		self._cleanup()



class SubServer(object):
	__metaclass__ = MetaSingleton
	def __init__(self, dbus_path='/com/wyplay/SubServer', txt_render=None):
		self.current_subs = SubList(self.sublist_callback)
		if not txt_render:
			pass
		self.txt_render = txt_render
		self.freezed = False
		self.task_list = TaskList()
		self.wdb = WyDbus()
		self.inst = self.wdb.instance(dbus_path)
		self.inst.signal('text', 'sti', self.text, 0)
		self.inst.signal('freeze', '', self.freeze, 0)
		self.inst.signal('thaw', '', self.thaw, 0)
		self.st = Stripper()

	def strip_tag(self, sub):
		self.st.data = []
		self.st.feed(sub)
		self.st.close()
		new = self.st.gettext()
		return new

	def sublist_callback(self, sublist):
		self.txt_render(sublist)

	def register_txt_render(self, f):
		self.txt_render = f

	def unregister_txt_render(self):
		self.txt_render = self.default_txt_render

	def default_txt_render(self, sublist):
		print '\n######## SUB #######'
		for txt in sublist:
			print '-> %s' % txt

	def text(self, sub, timestamp, lifetime):
		start_delay = timestamp / 1000000.0
		lifetime = lifetime / 1000.0
		if self.freezed:
			return 0
		full_sub = str(sub)
		full_sub = full_sub.replace('\r\n', '\n').replace('\r', '\n')
		full_sub = self.strip_tag(full_sub)
		self.task_list.append(Task(self.current_subs.append, full_sub).start(start_delay))
		self.task_list.append(Task(self.current_subs.remove, full_sub).start(start_delay + lifetime))

	def freeze(self):
		self.freezed = True
		for task in self.task_list:
			task.pause()

	def thaw(self):
		self.freezed = False
		for task in self.task_list:
			task.unpause()

	def clear(self):
		for task in self.task_list:
			task.stop()
		self.current_subs = SubList(self.sublist_callback)
		self.task_list = TaskList()



if __name__ == '__main__':
	s = SubServer()
	notifier.loop()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76e3b8c>}
from __future__ import absolute_import
import sgmllib
from time import time
from wydbus import WyDbus
from peewee.notifier import Task
from peewee.debug import GET_LOGGER
from peewee.misc_utils import MetaSingleton
import peewee.notifier as notifier
log = GET_LOGGER(__name__)
class Stripper(.):
	__doc__ = ' HTML tags stripper '
	def __init__(self):
		self.data = []
		sgmllib.SGMLParser.__init__(self)

	def unknown_starttag(self, tag, attrib):
		self.data.append(' ')

	def unknown_endtag(self, tag):
		self.data.append(' ')

	def handle_data(self, data):
		self.data.append(data)

	def gettext(self):
		return ''.join(self.data)



class SubList(list):
	__doc__ = ' Special list which call a callback function on append/remove '
	def __init__(self, callback):
		list.__init__(self)
		self.callback = callback

	def append(self, data):
		list.append(self, data)
		self.callback(self)

	def remove(self, data):
		if data in self:
			list.remove(self, data)
		self.callback(self)



class TaskList(list):
	__doc__ = ' Special list which remove old task on append/remove'
	def _cleanup(self):
		for task in self:
			if not task.running:
				list.remove(self, task)
				continue

	def append(self, data):
		list.append(self, data)
		self._cleanup()

	def remove(self, data):
		if data in self:
			list.remove(self, data)
		self._cleanup()



class SubServer(object):
	__metaclass__ = MetaSingleton
	def __init__(self, dbus_path='/com/wyplay/SubServer', txt_render=None):
		self.current_subs = SubList(self.sublist_callback)
		if not txt_render:
			pass
		self.txt_render = txt_render
		self.freezed = False
		self.task_list = TaskList()
		self.wdb = WyDbus()
		self.inst = self.wdb.instance(dbus_path)
		self.inst.signal('text', 'sti', self.text, 0)
		self.inst.signal('freeze', '', self.freeze, 0)
		self.inst.signal('thaw', '', self.thaw, 0)
		self.st = Stripper()

	def strip_tag(self, sub):
		self.st.data = []
		self.st.feed(sub)
		self.st.close()
		new = self.st.gettext()
		return new

	def sublist_callback(self, sublist):
		self.txt_render(sublist)

	def register_txt_render(self, f):
		self.txt_render = f

	def unregister_txt_render(self):
		self.txt_render = self.default_txt_render

	def default_txt_render(self, sublist):
		print '\n######## SUB #######'
		for txt in sublist:
			print '-> %s' % txt

	def text(self, sub, timestamp, lifetime):
		start_delay = timestamp / 1000000.0
		lifetime = lifetime / 1000.0
		if self.freezed:
			return 0
		full_sub = str(sub)
		full_sub = full_sub.replace('\r\n', '\n').replace('\r', '\n')
		full_sub = self.strip_tag(full_sub)
		self.task_list.append(Task(self.current_subs.append, full_sub).start(start_delay))
		self.task_list.append(Task(self.current_subs.remove, full_sub).start(start_delay + lifetime))

	def freeze(self):
		self.freezed = True
		for task in self.task_list:
			task.pause()

	def thaw(self):
		self.freezed = False
		for task in self.task_list:
			task.unpause()

	def clear(self):
		for task in self.task_list:
			task.stop()
		self.current_subs = SubList(self.sublist_callback)
		self.task_list = TaskList()



if __name__ == '__main__':
	s = SubServer()
	notifier.loop()
