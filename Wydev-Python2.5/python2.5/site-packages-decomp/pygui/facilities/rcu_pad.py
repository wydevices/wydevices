# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 216
n 216(None)[del _[1]
for self.buttons in range(self.nb_buttons):
return None
]:
	i: 0(AF), 176()
	o: 

nname: 176
n 176(None)[for i in range(self.nb_buttons):
]:
	i: 0(for)
	o: 216()

nname: 0
n 0(None)[log.debug('creating RcuPad !')
self.f = open(dev)
self.packetSize = struct.calcsize(self.format)
log.debug('packetSize = %s', self.packetSize)
self.mode = 0
self.left = 0
self.right = 0
self.x = size[0]
self.y = size[1]
self.dx = self.x / 2
self.dy = self.y / 2
]:
	i: 
	o: 176(for), 216(AF)

self.nodes: {0: <unpyclib.structure.node instance at 0xb7594a2c>, 176: <unpyclib.structure.node instance at 0xb7594aac>, 216: <unpyclib.structure.node instance at 0xb7594b2c>}
nname: 60
n 60(None)[return ret
]:
	i: 0(AL), 59()
	o: 

nname: 59
n 59(None)[]:
	i: 25(AF), 35()
	o: 60()

nname: 35
n 35(None)[for b in self.buttons:
ret += '%s ' % b['press']
]:
	i: 25(for)
	o: 59()

nname: 25
n 25(None)[]:
	i: 0(loop)
	o: 35(for), 59(AF)

nname: 0
n 0(None)[ret = 'x:%d, y:%d b: ' % (self.dx, self.dy)
]:
	i: 
	o: 25(loop), 60(AL)

nname: 60
n 60(None)[return ret
]:
	i: 35()
	o: 

nname: 35
n 35(None)[for b in self.buttons:
	ret += '%s ' % b['press']
]:
	i: 0(for)
	o: 60()

nname: 0
n 0(None)[ret = 'x:%d, y:%d b: ' % (self.dx, self.dy)
]:
	i: 
	o: 35(for)

nname: 60
n 60(None)[return ret
]:
	i: 0()
	o: 

nname: 0
n 0(None)[ret = 'x:%d, y:%d b: ' % (self.dx, self.dy)
for b in self.buttons:
	ret += '%s ' % b['press']
]:
	i: 
	o: 60()

nname: 0
n 0(None)[ret = 'x:%d, y:%d b: ' % (self.dx, self.dy)
for b in self.buttons:
	ret += '%s ' % b['press']
return ret
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb759418c>}
nname: 55
n 55(None)[return None
]:
	i: 0(AL), 54()
	o: 

nname: 54
n 54(None)[]:
	i: 3(AF), 50()
	o: 55()

nname: 50
n 50(None)[]:
	i: 13(t), 26()
	o: 54()

nname: 26
n 26(None)[but['start_x'] = None
but['start_y'] = None
continue
]:
	i: 13(f)
	o: 50()

nname: 13
n 13(but['press'])[for but in self.buttons:
]:
	i: 3(for)
	o: 26(f), 50(t)

nname: 3
n 3(None)[]:
	i: 0(loop)
	o: 13(for), 54(AF)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 55(AL)

nname: 55
n 55(None)[return None
]:
	i: 0(AL), 3(AF), 13()
	o: 

nname: 13
n 13(None)[for but in self.buttons:
if not but['press']:
	but['start_x'] = None
	but['start_y'] = None
	continue
]:
	i: 3(for)
	o: 55()

nname: 3
n 3(None)[]:
	i: 0(loop)
	o: 13(for), 55(AF)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 55(AL)

nname: 13
n 13(None)[for but in self.buttons:
	if not but['press']:
		but['start_x'] = None
		but['start_y'] = None
		continue
return None
]:
	i: 0(for)
	o: 

nname: 0
n 0(None)[]:
	i: 
	o: 13(for)

nname: 0
n 0(None)[for but in self.buttons:
	if not but['press']:
		but['start_x'] = None
		but['start_y'] = None
		continue
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb759416c>}
nname: 320
n 320(None)[]:
	i: 74(), 316()
	o: 

nname: 316
n 316(None)[return True
]:
	i: 115(AL), 315()
	o: 320()

nname: 315
n 315(None)[]:
	i: 193(AF), 312()
	o: 316()

nname: 312
n 312(None)[]:
	i: 242(JA), 311()
	o: 315()

nname: 311
n 311(None)[]:
	i: 286(f), 297()
	o: 312()

nname: 297
n 297(None)[button['press'] = False
continue
]:
	i: 286(t)
	o: 311()

nname: 286
n 286(button['press'])[]:
	i: 216(f), 282()
	o: 297(t), 311(f)

nname: 282
n 282(None)[continue
]:
	i: 231(t)
	o: 286()

nname: 242
n 242(None)[button['press'] = True
button['start_x'] = self.dx
button['start_y'] = self.dy
]:
	i: 231(f)
	o: 312(JA)

nname: 231
n 231(button['press'])[]:
	i: 216(t)
	o: 242(f), 282(t)

nname: 216
n 216(pressed)[for button, pressed in zip(self.buttons, values[5:]):
]:
	i: 193(for)
	o: 231(t), 286(f)

nname: 193
n 193(None)[]:
	i: 115(loop)
	o: 216(for), 315(AF)

nname: 115
n 115(None)[self.clean_up()
self.mode = values[0]
self.left = values[1]
self.right = values[1]
self.dx = values[3]
self.dy = values[4]
]:
	i: 39(), 113(AE)
	o: 193(loop), 316(AL)

nname: 113
n 113(None)[]:
	i: 64(f)
	o: 115(AE)

nname: 74
n 74(None)[#, e
log.warn('error while unpacking %s', buffer)
PRINT_EXCEPTION(e)
return False
]:
	i: 64(t)
	o: 320()

nname: 64
n 64(<dummy_ex3> EXC_MATCH Exception)[]:
	i: 36(except)
	o: 74(t), 113(f)

nname: 39
n 39(None)[values = struct.unpack(self.format, buffer)
]:
	i: 36(try)
	o: 115()

nname: 36
n 36(None)[]:
	i: 27(), 35()
	o: 39(try), 64(except)

nname: 35
n 35(None)[]:
	i: 0(t)
	o: 36()

nname: 27
n 27(None)[return False
]:
	i: 0(f)
	o: 36()

nname: 0
n 0(buffer)[buffer = self.f.read(self.packetSize)
]:
	i: 
	o: 27(f), 35(t)

nname: 320
n 320(None)[]:
	i: 74(), 316(), 64(f)
	o: 

nname: 74
n 74(None)[#, e
log.warn('error while unpacking %s', buffer)
PRINT_EXCEPTION(e)
return False
]:
	i: 64(t)
	o: 320()

nname: 64
n 64(<dummy_ex3> EXC_MATCH Exception)[]:
	i: 0(except)
	o: 74(t), 320(f)

nname: 316
n 316(None)[return True
]:
	i: 115(AL), 193(AF), 242(JA), 286()
	o: 320()

nname: 286
n 286(None)[if button['press']:
	button['press'] = False
	continue
]:
	i: 216(f), 282()
	o: 316()

nname: 282
n 282(None)[continue
]:
	i: 231(t)
	o: 286()

nname: 242
n 242(None)[button['press'] = True
button['start_x'] = self.dx
button['start_y'] = self.dy
]:
	i: 231(f)
	o: 316(JA)

nname: 231
n 231(button['press'])[]:
	i: 216(t)
	o: 242(f), 282(t)

nname: 216
n 216(pressed)[for button, pressed in zip(self.buttons, values[5:]):
]:
	i: 193(for)
	o: 231(t), 286(f)

nname: 193
n 193(None)[]:
	i: 115(loop)
	o: 216(for), 316(AF)

nname: 115
n 115(None)[self.clean_up()
self.mode = values[0]
self.left = values[1]
self.right = values[1]
self.dx = values[3]
self.dy = values[4]
]:
	i: 39(), 113(AE)
	o: 193(loop), 316(AL)

nname: 39
n 39(None)[values = struct.unpack(self.format, buffer)
]:
	i: 0(try)
	o: 115()

nname: 0
n 0(None)[buffer = self.f.read(self.packetSize)
if not buffer:
	return False
]:
	i: 
	o: 39(try), 64(except)

nname: 320
n 320(None)[]:
	i: 316(), 64(f)
	o: 

nname: 64
n 64(None)[except Exception, e:
	log.warn('error while unpacking %s', buffer)
	PRINT_EXCEPTION(e)
	return False
]:
	i: 0(except)
	o: 320()

nname: 316
n 316(None)[return True
]:
	i: 115(AL), 193(AF), 242(JA), 286()
	o: 320()

nname: 286
n 286(None)[if button['press']:
	button['press'] = False
	continue
]:
	i: 216(f), 282()
	o: 316()

nname: 282
n 282(None)[continue
]:
	i: 231(t)
	o: 286()

nname: 242
n 242(None)[button['press'] = True
button['start_x'] = self.dx
button['start_y'] = self.dy
]:
	i: 231(f)
	o: 316(JA)

nname: 231
n 231(button['press'])[]:
	i: 216(t)
	o: 242(f), 282(t)

nname: 216
n 216(pressed)[for button, pressed in zip(self.buttons, values[5:]):
]:
	i: 193(for)
	o: 231(t), 286(f)

nname: 193
n 193(None)[]:
	i: 115(loop)
	o: 216(for), 316(AF)

nname: 115
n 115(None)[self.clean_up()
self.mode = values[0]
self.left = values[1]
self.right = values[1]
self.dx = values[3]
self.dy = values[4]
]:
	i: 39(), 113(AE)
	o: 193(loop), 316(AL)

nname: 39
n 39(None)[values = struct.unpack(self.format, buffer)
]:
	i: 0(try)
	o: 115()

nname: 0
n 0(None)[buffer = self.f.read(self.packetSize)
if not buffer:
	return False
]:
	i: 
	o: 39(try), 64(except)

self.nodes: {0: <unpyclib.structure.node instance at 0xb759ab6c>, 64: <unpyclib.structure.node instance at 0xb759ad0c>, 193: <unpyclib.structure.node instance at 0xb759a0cc>, 39: <unpyclib.structure.node instance at 0xb759a9ec>, 231: <unpyclib.structure.node instance at 0xb759a1cc>, 320: <unpyclib.structure.node instance at 0xb759aaec>, 113: <unpyclib.structure.node instance at 0xb759a4ac>, 242: <unpyclib.structure.node instance at 0xb759a24c>, 115: <unpyclib.structure.node instance at 0xb759a04c>, 216: <unpyclib.structure.node instance at 0xb759a14c>, 282: <unpyclib.structure.node instance at 0xb759a2cc>, 316: <unpyclib.structure.node instance at 0xb759a7ec>, 286: <unpyclib.structure.node instance at 0xb759a92c>}
nname: 6
n 6(None)[__doc__ = '\n    A facility module to handle /dev/ir0 (sRCU)\n    Warn: It does not use the standard linux input event interface, but it works !\n    sRCU has 2 modes, only the first (sensitive) is used for now.\n    (The second mode need antenna to detect moves around the sRCU).\n    Run this script alone to test sRCU.\n    '
format = 'BBBBBBBBBB'
nb_buttons = 5
def __init__(self, size=(100, 100), dev='/dev/ir0'):
	log.debug('creating RcuPad !')
	self.f = open(dev)
	self.packetSize = struct.calcsize(self.format)
	log.debug('packetSize = %s', self.packetSize)
	self.mode = 0
	self.left = 0
	self.right = 0
	self.x = size[0]
	self.y = size[1]
	self.dx = self.x / 2
	self.dy = self.y / 2

def __str__(self):
	ret = 'x:%d, y:%d b: ' % (self.dx, self.dy)
	for b in self.buttons:
		ret += '%s ' % b['press']
	return ret

def clean_up(self):
	for but in self.buttons:
		if not but['press']:
			but['start_x'] = None
			but['start_y'] = None
			continue
	return None

def get_struct(self):
	buffer = self.f.read(self.packetSize)
	if not buffer:
		return False

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb758db0c>}
nname: 224
n 224(None)[]:
	i: 131(AL), 207(), 223()
	o: 

nname: 223
n 223(None)[]:
	i: 0(f)
	o: 224()

nname: 207
n 207(None)[sleep(0.02)
]:
	i: 177(), 206()
	o: 224()

nname: 206
n 206(None)[]:
	i: 165(f)
	o: 207()

nname: 177
n 177(None)[print m,
print time() - last
last = time()
]:
	i: 165(t)
	o: 207()

nname: 165
n 165(m.get_struct())[]:
	i: 131(loop)
	o: 177(t), 206(f)

nname: 131
n 131(None)[import sys
m = RcuPad()
last = time()
]:
	i: 0(t)
	o: 165(loop), 224(AL)

nname: 0
n 0(__name__ == '__main__')[from __future__ import absolute_import
import struct
from time import sleep, time
from peewee.debug import GET_LOGGER, PRINT_EXCEPTION
from peewee.notifier import descriptor_watch
log = GET_LOGGER(__name__)
class RcuPad():
	__doc__ = '\n    A facility module to handle /dev/ir0 (sRCU)\n    Warn: It does not use the standard linux input event interface, but it works !\n    sRCU has 2 modes, only the first (sensitive) is used for now.\n    (The second mode need antenna to detect moves around the sRCU).\n    Run this script alone to test sRCU.\n    '
	format = 'BBBBBBBBBB'
	nb_buttons = 5
	def __init__(self, size=(100, 100), dev='/dev/ir0'):
		log.debug('creating RcuPad !')
		self.f = open(dev)
		self.packetSize = struct.calcsize(self.format)
		log.debug('packetSize = %s', self.packetSize)
		self.mode = 0
		self.left = 0
		self.right = 0
		self.x = size[0]
		self.y = size[1]
		self.dx = self.x / 2
		self.dy = self.y / 2

	def __str__(self):
		ret = 'x:%d, y:%d b: ' % (self.dx, self.dy)
		for b in self.buttons:
			ret += '%s ' % b['press']
		return ret

	def clean_up(self):
		for but in self.buttons:
			if not but['press']:
				but['start_x'] = None
				but['start_y'] = None
				continue
		return None

	def get_struct(self):
		buffer = self.f.read(self.packetSize)
		if not buffer:
			return False



]:
	i: 
	o: 131(t), 223(f)

nname: 224
n 224(None)[]:
	i: 131(AL), 207(), 0(f)
	o: 

nname: 207
n 207(None)[sleep(0.02)
]:
	i: 177(), 165(f)
	o: 224()

nname: 177
n 177(None)[print m,
print time() - last
last = time()
]:
	i: 165(t)
	o: 207()

nname: 165
n 165(m.get_struct())[]:
	i: 131(loop)
	o: 177(t), 207(f)

nname: 131
n 131(None)[import sys
m = RcuPad()
last = time()
]:
	i: 0(t)
	o: 165(loop), 224(AL)

nname: 0
n 0(__name__ == '__main__')[from __future__ import absolute_import
import struct
from time import sleep, time
from peewee.debug import GET_LOGGER, PRINT_EXCEPTION
from peewee.notifier import descriptor_watch
log = GET_LOGGER(__name__)
class RcuPad():
	__doc__ = '\n    A facility module to handle /dev/ir0 (sRCU)\n    Warn: It does not use the standard linux input event interface, but it works !\n    sRCU has 2 modes, only the first (sensitive) is used for now.\n    (The second mode need antenna to detect moves around the sRCU).\n    Run this script alone to test sRCU.\n    '
	format = 'BBBBBBBBBB'
	nb_buttons = 5
	def __init__(self, size=(100, 100), dev='/dev/ir0'):
		log.debug('creating RcuPad !')
		self.f = open(dev)
		self.packetSize = struct.calcsize(self.format)
		log.debug('packetSize = %s', self.packetSize)
		self.mode = 0
		self.left = 0
		self.right = 0
		self.x = size[0]
		self.y = size[1]
		self.dx = self.x / 2
		self.dy = self.y / 2

	def __str__(self):
		ret = 'x:%d, y:%d b: ' % (self.dx, self.dy)
		for b in self.buttons:
			ret += '%s ' % b['press']
		return ret

	def clean_up(self):
		for but in self.buttons:
			if not but['press']:
				but['start_x'] = None
				but['start_y'] = None
				continue
		return None

	def get_struct(self):
		buffer = self.f.read(self.packetSize)
		if not buffer:
			return False



]:
	i: 
	o: 131(t), 224(f)

nname: 224
n 224(None)[]:
	i: 177(), 0(f)
	o: 

nname: 177
n 177(None)[	print m,
	print time() - last
	last = time()
else:
	sleep(0.02)
]:
	i: 131(t)
	o: 224()

nname: 131
n 131(m.get_struct())[import sys
m = RcuPad()
last = time()
while m.get_struct():
]:
	i: 0(t)
	o: 177(t)

nname: 0
n 0(__name__ == '__main__')[from __future__ import absolute_import
import struct
from time import sleep, time
from peewee.debug import GET_LOGGER, PRINT_EXCEPTION
from peewee.notifier import descriptor_watch
log = GET_LOGGER(__name__)
class RcuPad():
	__doc__ = '\n    A facility module to handle /dev/ir0 (sRCU)\n    Warn: It does not use the standard linux input event interface, but it works !\n    sRCU has 2 modes, only the first (sensitive) is used for now.\n    (The second mode need antenna to detect moves around the sRCU).\n    Run this script alone to test sRCU.\n    '
	format = 'BBBBBBBBBB'
	nb_buttons = 5
	def __init__(self, size=(100, 100), dev='/dev/ir0'):
		log.debug('creating RcuPad !')
		self.f = open(dev)
		self.packetSize = struct.calcsize(self.format)
		log.debug('packetSize = %s', self.packetSize)
		self.mode = 0
		self.left = 0
		self.right = 0
		self.x = size[0]
		self.y = size[1]
		self.dx = self.x / 2
		self.dy = self.y / 2

	def __str__(self):
		ret = 'x:%d, y:%d b: ' % (self.dx, self.dy)
		for b in self.buttons:
			ret += '%s ' % b['press']
		return ret

	def clean_up(self):
		for but in self.buttons:
			if not but['press']:
				but['start_x'] = None
				but['start_y'] = None
				continue
		return None

	def get_struct(self):
		buffer = self.f.read(self.packetSize)
		if not buffer:
			return False



]:
	i: 
	o: 131(t), 224(f)

nname: 224
n 224(None)[]:
	i: 131(), 0(f)
	o: 

nname: 131
n 131(None)[import sys
m = RcuPad()
last = time()
while m.get_struct():
	print m,
	print time() - last
	last = time()
else:
	sleep(0.02)
]:
	i: 0(t)
	o: 224()

nname: 0
n 0(__name__ == '__main__')[from __future__ import absolute_import
import struct
from time import sleep, time
from peewee.debug import GET_LOGGER, PRINT_EXCEPTION
from peewee.notifier import descriptor_watch
log = GET_LOGGER(__name__)
class RcuPad():
	__doc__ = '\n    A facility module to handle /dev/ir0 (sRCU)\n    Warn: It does not use the standard linux input event interface, but it works !\n    sRCU has 2 modes, only the first (sensitive) is used for now.\n    (The second mode need antenna to detect moves around the sRCU).\n    Run this script alone to test sRCU.\n    '
	format = 'BBBBBBBBBB'
	nb_buttons = 5
	def __init__(self, size=(100, 100), dev='/dev/ir0'):
		log.debug('creating RcuPad !')
		self.f = open(dev)
		self.packetSize = struct.calcsize(self.format)
		log.debug('packetSize = %s', self.packetSize)
		self.mode = 0
		self.left = 0
		self.right = 0
		self.x = size[0]
		self.y = size[1]
		self.dx = self.x / 2
		self.dy = self.y / 2

	def __str__(self):
		ret = 'x:%d, y:%d b: ' % (self.dx, self.dy)
		for b in self.buttons:
			ret += '%s ' % b['press']
		return ret

	def clean_up(self):
		for but in self.buttons:
			if not but['press']:
				but['start_x'] = None
				but['start_y'] = None
				continue
		return None

	def get_struct(self):
		buffer = self.f.read(self.packetSize)
		if not buffer:
			return False



]:
	i: 
	o: 131(t), 224(f)

nname: 0
n 0(None)[from __future__ import absolute_import
import struct
from time import sleep, time
from peewee.debug import GET_LOGGER, PRINT_EXCEPTION
from peewee.notifier import descriptor_watch
log = GET_LOGGER(__name__)
class RcuPad():
	__doc__ = '\n    A facility module to handle /dev/ir0 (sRCU)\n    Warn: It does not use the standard linux input event interface, but it works !\n    sRCU has 2 modes, only the first (sensitive) is used for now.\n    (The second mode need antenna to detect moves around the sRCU).\n    Run this script alone to test sRCU.\n    '
	format = 'BBBBBBBBBB'
	nb_buttons = 5
	def __init__(self, size=(100, 100), dev='/dev/ir0'):
		log.debug('creating RcuPad !')
		self.f = open(dev)
		self.packetSize = struct.calcsize(self.format)
		log.debug('packetSize = %s', self.packetSize)
		self.mode = 0
		self.left = 0
		self.right = 0
		self.x = size[0]
		self.y = size[1]
		self.dx = self.x / 2
		self.dy = self.y / 2

	def __str__(self):
		ret = 'x:%d, y:%d b: ' % (self.dx, self.dy)
		for b in self.buttons:
			ret += '%s ' % b['press']
		return ret

	def clean_up(self):
		for but in self.buttons:
			if not but['press']:
				but['start_x'] = None
				but['start_y'] = None
				continue
		return None

	def get_struct(self):
		buffer = self.f.read(self.packetSize)
		if not buffer:
			return False



if __name__ == '__main__':
	import sys
	m = RcuPad()
	last = time()
	while m.get_struct():
		print m,
		print time() - last
		last = time()
	else:
		sleep(0.02)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb758884c>}
from __future__ import absolute_import
import struct
from time import sleep, time
from peewee.debug import GET_LOGGER, PRINT_EXCEPTION
from peewee.notifier import descriptor_watch
log = GET_LOGGER(__name__)
class RcuPad():
	__doc__ = '\n    A facility module to handle /dev/ir0 (sRCU)\n    Warn: It does not use the standard linux input event interface, but it works !\n    sRCU has 2 modes, only the first (sensitive) is used for now.\n    (The second mode need antenna to detect moves around the sRCU).\n    Run this script alone to test sRCU.\n    '
	format = 'BBBBBBBBBB'
	nb_buttons = 5
	def __init__(self, size=(100, 100), dev='/dev/ir0'):
		log.debug('creating RcuPad !')
		self.f = open(dev)
		self.packetSize = struct.calcsize(self.format)
		log.debug('packetSize = %s', self.packetSize)
		self.mode = 0
		self.left = 0
		self.right = 0
		self.x = size[0]
		self.y = size[1]
		self.dx = self.x / 2
		self.dy = self.y / 2

	def __str__(self):
		ret = 'x:%d, y:%d b: ' % (self.dx, self.dy)
		for b in self.buttons:
			ret += '%s ' % b['press']
		return ret

	def clean_up(self):
		for but in self.buttons:
			if not but['press']:
				but['start_x'] = None
				but['start_y'] = None
				continue
		return None

	def get_struct(self):
		buffer = self.f.read(self.packetSize)
		if not buffer:
			return False



if __name__ == '__main__':
	import sys
	m = RcuPad()
	last = time()
	while m.get_struct():
		print m,
		print time() - last
		last = time()
	else:
		sleep(0.02)
