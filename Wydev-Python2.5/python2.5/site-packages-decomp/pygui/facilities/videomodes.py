# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 0
n 0(None)[self.display = display
self.syspath = None
self.id = 0
self.modes = self.get_modes()
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7752d8c>}
nname: 57
n 57(None)[del _[1]
for modes in sys_list:
return modes
]:
	i: 0(AF), 38()
	o: 

nname: 38
n 38(None)[for m in sys_list:
]:
	i: 0(for)
	o: 57()

nname: 0
n 0(None)[sys_list = ['S:1280x720p-60', 'S:1280x720p-59', 'S:1280x720p-50', 'S:720x480p-60', 'S:720x480p-59', 'S:720x576p-50']
]:
	i: 
	o: 38(for), 57(AF)

self.nodes: {0: <unpyclib.structure.node instance at 0xb7752f0c>, 57: <unpyclib.structure.node instance at 0xb7752e2c>, 38: <unpyclib.structure.node instance at 0xb7752f4c>}
nname: 0
n 0(None)[return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7752a0c>}
nname: 6
n 6(None)[def __init__(self, display=0):
	self.display = display
	self.syspath = None
	self.id = 0
	self.modes = self.get_modes()
	return None

def get_modes(self):
	sys_list = ['S:1280x720p-60', 'S:1280x720p-59', 'S:1280x720p-50', 'S:720x480p-60', 'S:720x480p-59', 'S:720x576p-50']

def get_hpd(self):
	return True

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb775268c>}
nname: 335
n 335(None)[return None
]:
	i: 256(), 334()
	o: 

nname: 334
n 334(None)[]:
	i: 230(f)
	o: 335()

nname: 256
n 256(None)[self.inst = wdb.instance('/com/wyplay/wycrs/wyhpd')
self.inst.signal('plug', '', self.plug_hdmi, 0)
self.inst.signal('unplug', '', self.unplug_hdmi, 0)
]:
	i: 230(t)
	o: 335()

nname: 230
n 230(wdb)[self._initial_switch()
wdb = pygui_globs['wydbus']
]:
	i: 229(AE)
	o: 256(t), 334(f)

nname: 229
n 229(None)[]:
	i: 200(), 213()
	o: 230(AE)

nname: 213
n 213(None)[self.hdmi_sink = self._get_hdmi_sink()
]:
	i: 188(f)
	o: 229()

nname: 200
n 200(None)[self.hdmi_sink = None
]:
	i: 188(t)
	o: 229()

nname: 188
n 188(hdmi_plugged != 'y')[]:
	i: 0(finally), 184()
	o: 200(t), 213(f)

nname: 184
n 184(None)[]:
	i: 114(), 163(JA), 173(), 183(AE)
	o: 188()

nname: 173
n 173(None)[hdmi_plugged = 'y'
]:
	i: 145(f)
	o: 184()

nname: 163
n 163(None)[hdmi_plugged = 'n'
]:
	i: 145(t)
	o: 184(JA)

nname: 145
n 145(config.architecture != 'pc')[]:
	i: 111(except)
	o: 163(t), 173(f)

nname: 114
n 114(None)[hdmi_plugged = open('/sys/class/stmcoredisplay/display0/hdmi0.0/hotplug', 'r').read().strip()
]:
	i: 111(try)
	o: 184()

nname: 111
n 111(None)[]:
	i: 0(ASF)
	o: 114(try), 145(except)

nname: 0
n 0(None)[self.switch_to_task = Task(self._switch_to)
self.switch_to_task.delay = 3.0
self.switch_to = self.switch_to_task.start
self.close_player_task = Task(self._close_player)
self.close_player_task.delay = 1.0
self.close_player = self.close_player_task.start
self.previous_resolution = None
self.handle_events = True
]:
	i: 
	o: 111(ASF2), 188(finally)

nname: 230
n 230(None)[self._initial_switch()
wdb = pygui_globs['wydbus']
if wdb:
	self.inst = wdb.instance('/com/wyplay/wycrs/wyhpd')
	self.inst.signal('plug', '', self.plug_hdmi, 0)
	self.inst.signal('unplug', '', self.unplug_hdmi, 0)
return None
]:
	i: 188(AE)
	o: 

nname: 188
n 188(None)[if hdmi_plugged != 'y':
	self.hdmi_sink = None
else:
	self.hdmi_sink = self._get_hdmi_sink()
]:
	i: 0(finally), 145()
	o: 230(AE)

nname: 145
n 145(None)[except:
	if config.architecture != 'pc':
		hdmi_plugged = 'n'
	else:
		hdmi_plugged = 'y'
]:
	i: 111()
	o: 188()

nname: 111
n 111(None)[try:
	hdmi_plugged = open('/sys/class/stmcoredisplay/display0/hdmi0.0/hotplug', 'r').read().strip()
]:
	i: 0(ASF2)
	o: 145()

nname: 0
n 0(None)[self.switch_to_task = Task(self._switch_to)
self.switch_to_task.delay = 3.0
self.switch_to = self.switch_to_task.start
self.close_player_task = Task(self._close_player)
self.close_player_task.delay = 1.0
self.close_player = self.close_player_task.start
self.previous_resolution = None
self.handle_events = True
]:
	i: 
	o: 111(ASF2), 188(finally)

nname: 230
n 230(None)[self._initial_switch()
wdb = pygui_globs['wydbus']
if wdb:
	self.inst = wdb.instance('/com/wyplay/wycrs/wyhpd')
	self.inst.signal('plug', '', self.plug_hdmi, 0)
	self.inst.signal('unplug', '', self.unplug_hdmi, 0)
return None
]:
	i: 188(AE)
	o: 

nname: 188
n 188(None)[if hdmi_plugged != 'y':
	self.hdmi_sink = None
else:
	self.hdmi_sink = self._get_hdmi_sink()
]:
	i: 0(finally), 111()
	o: 230(AE)

nname: 111
n 111(None)[try:
	hdmi_plugged = open('/sys/class/stmcoredisplay/display0/hdmi0.0/hotplug', 'r').read().strip()
except:
	if config.architecture != 'pc':
		hdmi_plugged = 'n'
	else:
		hdmi_plugged = 'y'
]:
	i: 0(ASF2)
	o: 188()

nname: 0
n 0(None)[self.switch_to_task = Task(self._switch_to)
self.switch_to_task.delay = 3.0
self.switch_to = self.switch_to_task.start
self.close_player_task = Task(self._close_player)
self.close_player_task.delay = 1.0
self.close_player = self.close_player_task.start
self.previous_resolution = None
self.handle_events = True
]:
	i: 
	o: 111(ASF2), 188(finally)

nname: 188
n 188(None)[finally:
	if hdmi_plugged != 'y':
		self.hdmi_sink = None
	else:
		self.hdmi_sink = self._get_hdmi_sink()
self._initial_switch()
wdb = pygui_globs['wydbus']
if wdb:
	self.inst = wdb.instance('/com/wyplay/wycrs/wyhpd')
	self.inst.signal('plug', '', self.plug_hdmi, 0)
	self.inst.signal('unplug', '', self.unplug_hdmi, 0)
return None
]:
	i: 0()
	o: 

nname: 0
n 0(None)[self.switch_to_task = Task(self._switch_to)
self.switch_to_task.delay = 3.0
self.switch_to = self.switch_to_task.start
self.close_player_task = Task(self._close_player)
self.close_player_task.delay = 1.0
self.close_player = self.close_player_task.start
self.previous_resolution = None
self.handle_events = True
try:
	hdmi_plugged = open('/sys/class/stmcoredisplay/display0/hdmi0.0/hotplug', 'r').read().strip()
except:
	if config.architecture != 'pc':
		hdmi_plugged = 'n'
	else:
		hdmi_plugged = 'y'
]:
	i: 
	o: 188()

nname: 0
n 0(None)[self.switch_to_task = Task(self._switch_to)
self.switch_to_task.delay = 3.0
self.switch_to = self.switch_to_task.start
self.close_player_task = Task(self._close_player)
self.close_player_task.delay = 1.0
self.close_player = self.close_player_task.start
self.previous_resolution = None
self.handle_events = True
try:
	hdmi_plugged = open('/sys/class/stmcoredisplay/display0/hdmi0.0/hotplug', 'r').read().strip()
except:
	if config.architecture != 'pc':
		hdmi_plugged = 'n'
	else:
		hdmi_plugged = 'y'
finally:
	if hdmi_plugged != 'y':
		self.hdmi_sink = None
	else:
		self.hdmi_sink = self._get_hdmi_sink()
self._initial_switch()
wdb = pygui_globs['wydbus']
if wdb:
	self.inst = wdb.instance('/com/wyplay/wycrs/wyhpd')
	self.inst.signal('plug', '', self.plug_hdmi, 0)
	self.inst.signal('unplug', '', self.unplug_hdmi, 0)
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76e374c>}
nname: 489
n 489(None)[log.warn('best mode supported by HDMI sink: %s', fallback)
return fallback
]:
	i: 105(AL), 205(AL), 307(AL), 388(AL), 451()
	o: 

nname: 451
n 451(None)[log.debug('fallback step 4 failed -> use CVBS resolution (PAL/NTSC)')
]:
	i: 405(AF), 447()
	o: 489()

nname: 447
n 447(None)[]:
	i: 412(f), 436()
	o: 451()

nname: 436
n 436(None)[break
continue
]:
	i: 412(t)
	o: 447()

nname: 412
n 412(mode in hdmiresolution_dict)[for m in modes:
]:
	i: 405(for)
	o: 436(t), 447(f)

nname: 405
n 405(None)[]:
	i: 388(loop)
	o: 412(for), 451(AF)

nname: 388
n 388(None)[log.debug('fallback step 3 failed')
]:
	i: 324(AF), 384()
	o: 405(loop), 489(AL)

nname: 384
n 384(None)[]:
	i: 331(f), 373()
	o: 388()

nname: 373
n 373(None)[break
continue
]:
	i: 331(t)
	o: 384()

nname: 331
n 331(abs(mode[3] - current[3]) <= 1)[for m in modes:
]:
	i: 324(for)
	o: 373(t), 384(f)

nname: 324
n 324(None)[]:
	i: 307(loop)
	o: 331(for), 388(AF)

nname: 307
n 307(None)[log.debug('fallback step 2 failed')
]:
	i: 222(AF), 303()
	o: 324(loop), 489(AL)

nname: 303
n 303(None)[]:
	i: 229&261(f), 292()
	o: 307()

nname: 292
n 292(None)[break
continue
]:
	i: 229&261(t)
	o: 303()

nname: 229&261
n 229&261(mode[2] == current[2] and abs(mode[3] - current[3]) <= 1)[for m in modes:
]:
	i: 222(for)
	o: 292(t), 303(f)

nname: 222
n 222(None)[]:
	i: 205(loop)
	o: 229&261(for), 307(AF)

nname: 205
n 205(None)[log.debug('fallback step 1 failed')
]:
	i: 130(AF), 201()
	o: 222(loop), 489(AL)

nname: 201
n 201(None)[]:
	i: 137&169(f), 190()
	o: 205()

nname: 190
n 190(None)[fallback = mode
break
continue
]:
	i: 137&169(t)
	o: 201()

nname: 137&169
n 137&169(mode[2] == current[2] and mode[3] == current[3])[for m in modes:
fallback, mode, fallback, mode, fallback, mode, fallback, mode = config.cvbs_resolution[config.user_config['connections']['composite_output']], m.tuple_repr, mode, m.tuple_repr, mode, m.tuple_repr, mode, m.tuple_repr
]:
	i: 130(for)
	o: 190(t), 201(f)

nname: 130
n 130(None)[]:
	i: 105(loop)
	o: 137&169(for), 205(AF)

nname: 105
n 105(None)[log.warn('%s not supported by HDMI sink, fallback starting...', current)
fallback = None
]:
	i: 80(), 104()
	o: 130(loop), 489(AL)

nname: 104
n 104(None)[]:
	i: 0(f)
	o: 105()

nname: 80
n 80(None)[log.debug('current HD mode (%s) supported by HDMI sink', current)
return current
]:
	i: 0(t)
	o: 105()

nname: 0
n 0(current in modes)[modes = self.hdmi_sink.get_modes()
modes.sort()
modes.reverse()
log.debug('HDMI supported modes: %s', modes)
current = config.user_config['connections']['resolution']
]:
	i: 
	o: 80(t), 104(f)

nname: 489
n 489(None)[log.warn('best mode supported by HDMI sink: %s', fallback)
return fallback
]:
	i: 0(AL), 205(AL), 307(AL), 388(AL), 451()
	o: 

nname: 451
n 451(None)[log.debug('fallback step 4 failed -> use CVBS resolution (PAL/NTSC)')
]:
	i: 405(AF), 412()
	o: 489()

nname: 412
n 412(None)[for m in modes:
if mode in hdmiresolution_dict:
	break
	continue
]:
	i: 405(for)
	o: 451()

nname: 405
n 405(None)[]:
	i: 388(loop)
	o: 412(for), 451(AF)

nname: 388
n 388(None)[log.debug('fallback step 3 failed')
]:
	i: 324(AF), 331()
	o: 405(loop), 489(AL)

nname: 331
n 331(None)[for m in modes:
if abs(mode[3] - current[3]) <= 1:
	break
	continue
]:
	i: 324(for)
	o: 388()

nname: 324
n 324(None)[]:
	i: 307(loop)
	o: 331(for), 388(AF)

nname: 307
n 307(None)[log.debug('fallback step 2 failed')
]:
	i: 222(AF), 229&261(f)
	o: 324(loop), 489(AL)

nname: 229&261
n 229&261(None)[for m in modes:
if mode[2] == current[2] and abs(mode[3] - current[3]) <= 1:
	break
	continue
]:
	i: 222(for)
	o: 307()

nname: 222
n 222(None)[]:
	i: 205(loop)
	o: 229&261(for), 307(AF)

nname: 205
n 205(None)[log.debug('fallback step 1 failed')
]:
	i: 130(AF), 137&169(f)
	o: 222(loop), 489(AL)

nname: 137&169
n 137&169(None)[for m in modes:
fallback, mode, fallback, mode, fallback, mode, fallback, mode = config.cvbs_resolution[config.user_config['connections']['composite_output']], m.tuple_repr, mode, m.tuple_repr, mode, m.tuple_repr, mode, m.tuple_repr
if mode[2] == current[2] and mode[3] == current[3]:
	fallback = mode
	break
	continue
]:
	i: 130(for)
	o: 205()

nname: 130
n 130(None)[]:
	i: 0(loop)
	o: 137&169(for), 205(AF)

nname: 0
n 0(None)[modes = self.hdmi_sink.get_modes()
modes.sort()
modes.reverse()
log.debug('HDMI supported modes: %s', modes)
current = config.user_config['connections']['resolution']
if current in modes:
	log.debug('current HD mode (%s) supported by HDMI sink', current)
	return current
log.warn('%s not supported by HDMI sink, fallback starting...', current)
fallback = None
]:
	i: 
	o: 130(loop), 489(AL)

nname: 489
n 489(None)[log.warn('best mode supported by HDMI sink: %s', fallback)
return fallback
]:
	i: 0(AL), 205(AL), 307(AL), 412()
	o: 

nname: 412
n 412(None)[for m in modes:
	if mode in hdmiresolution_dict:
		break
		continue
else:
	log.debug('fallback step 4 failed -> use CVBS resolution (PAL/NTSC)')
]:
	i: 388(for)
	o: 489()

nname: 388
n 388(None)[log.debug('fallback step 3 failed')
]:
	i: 324(AF), 331()
	o: 412(for)

nname: 331
n 331(None)[for m in modes:
if abs(mode[3] - current[3]) <= 1:
	break
	continue
]:
	i: 324(for)
	o: 388()

nname: 324
n 324(None)[]:
	i: 307(loop)
	o: 331(for), 388(AF)

nname: 307
n 307(None)[log.debug('fallback step 2 failed')
]:
	i: 222(AF), 229&261(f)
	o: 324(loop), 489(AL)

nname: 229&261
n 229&261(None)[for m in modes:
if mode[2] == current[2] and abs(mode[3] - current[3]) <= 1:
	break
	continue
]:
	i: 222(for)
	o: 307()

nname: 222
n 222(None)[]:
	i: 205(loop)
	o: 229&261(for), 307(AF)

nname: 205
n 205(None)[log.debug('fallback step 1 failed')
]:
	i: 130(AF), 137&169(f)
	o: 222(loop), 489(AL)

nname: 137&169
n 137&169(None)[for m in modes:
fallback, mode, fallback, mode, fallback, mode, fallback, mode = config.cvbs_resolution[config.user_config['connections']['composite_output']], m.tuple_repr, mode, m.tuple_repr, mode, m.tuple_repr, mode, m.tuple_repr
if mode[2] == current[2] and mode[3] == current[3]:
	fallback = mode
	break
	continue
]:
	i: 130(for)
	o: 205()

nname: 130
n 130(None)[]:
	i: 0(loop)
	o: 137&169(for), 205(AF)

nname: 0
n 0(None)[modes = self.hdmi_sink.get_modes()
modes.sort()
modes.reverse()
log.debug('HDMI supported modes: %s', modes)
current = config.user_config['connections']['resolution']
if current in modes:
	log.debug('current HD mode (%s) supported by HDMI sink', current)
	return current
log.warn('%s not supported by HDMI sink, fallback starting...', current)
fallback = None
]:
	i: 
	o: 130(loop), 489(AL)

nname: 489
n 489(None)[log.warn('best mode supported by HDMI sink: %s', fallback)
return fallback
]:
	i: 0(AL), 205(AL), 307(AL), 388()
	o: 

nname: 388
n 388(None)[log.debug('fallback step 3 failed')
for m in modes:
	if mode in hdmiresolution_dict:
		break
		continue
else:
	log.debug('fallback step 4 failed -> use CVBS resolution (PAL/NTSC)')
]:
	i: 324(AF), 331()
	o: 489()

nname: 331
n 331(None)[for m in modes:
if abs(mode[3] - current[3]) <= 1:
	break
	continue
]:
	i: 324(for)
	o: 388()

nname: 324
n 324(None)[]:
	i: 307(loop)
	o: 331(for), 388(AF)

nname: 307
n 307(None)[log.debug('fallback step 2 failed')
]:
	i: 222(AF), 229&261(f)
	o: 324(loop), 489(AL)

nname: 229&261
n 229&261(None)[for m in modes:
if mode[2] == current[2] and abs(mode[3] - current[3]) <= 1:
	break
	continue
]:
	i: 222(for)
	o: 307()

nname: 222
n 222(None)[]:
	i: 205(loop)
	o: 229&261(for), 307(AF)

nname: 205
n 205(None)[log.debug('fallback step 1 failed')
]:
	i: 130(AF), 137&169(f)
	o: 222(loop), 489(AL)

nname: 137&169
n 137&169(None)[for m in modes:
fallback, mode, fallback, mode, fallback, mode, fallback, mode = config.cvbs_resolution[config.user_config['connections']['composite_output']], m.tuple_repr, mode, m.tuple_repr, mode, m.tuple_repr, mode, m.tuple_repr
if mode[2] == current[2] and mode[3] == current[3]:
	fallback = mode
	break
	continue
]:
	i: 130(for)
	o: 205()

nname: 130
n 130(None)[]:
	i: 0(loop)
	o: 137&169(for), 205(AF)

nname: 0
n 0(None)[modes = self.hdmi_sink.get_modes()
modes.sort()
modes.reverse()
log.debug('HDMI supported modes: %s', modes)
current = config.user_config['connections']['resolution']
if current in modes:
	log.debug('current HD mode (%s) supported by HDMI sink', current)
	return current
log.warn('%s not supported by HDMI sink, fallback starting...', current)
fallback = None
]:
	i: 
	o: 130(loop), 489(AL)

nname: 489
n 489(None)[log.warn('best mode supported by HDMI sink: %s', fallback)
return fallback
]:
	i: 0(AL), 205(AL), 331()
	o: 

nname: 331
n 331(None)[for m in modes:
	if abs(mode[3] - current[3]) <= 1:
		break
		continue
else:
	log.debug('fallback step 3 failed')
	for m in modes:
		if mode in hdmiresolution_dict:
			break
			continue
	else:
		log.debug('fallback step 4 failed -> use CVBS resolution (PAL/NTSC)')
]:
	i: 307(for)
	o: 489()

nname: 307
n 307(None)[log.debug('fallback step 2 failed')
]:
	i: 222(AF), 229&261(f)
	o: 331(for)

nname: 229&261
n 229&261(None)[for m in modes:
if mode[2] == current[2] and abs(mode[3] - current[3]) <= 1:
	break
	continue
]:
	i: 222(for)
	o: 307()

nname: 222
n 222(None)[]:
	i: 205(loop)
	o: 229&261(for), 307(AF)

nname: 205
n 205(None)[log.debug('fallback step 1 failed')
]:
	i: 130(AF), 137&169(f)
	o: 222(loop), 489(AL)

nname: 137&169
n 137&169(None)[for m in modes:
fallback, mode, fallback, mode, fallback, mode, fallback, mode = config.cvbs_resolution[config.user_config['connections']['composite_output']], m.tuple_repr, mode, m.tuple_repr, mode, m.tuple_repr, mode, m.tuple_repr
if mode[2] == current[2] and mode[3] == current[3]:
	fallback = mode
	break
	continue
]:
	i: 130(for)
	o: 205()

nname: 130
n 130(None)[]:
	i: 0(loop)
	o: 137&169(for), 205(AF)

nname: 0
n 0(None)[modes = self.hdmi_sink.get_modes()
modes.sort()
modes.reverse()
log.debug('HDMI supported modes: %s', modes)
current = config.user_config['connections']['resolution']
if current in modes:
	log.debug('current HD mode (%s) supported by HDMI sink', current)
	return current
log.warn('%s not supported by HDMI sink, fallback starting...', current)
fallback = None
]:
	i: 
	o: 130(loop), 489(AL)

nname: 489
n 489(None)[log.warn('best mode supported by HDMI sink: %s', fallback)
return fallback
]:
	i: 0(AL), 205(AL), 307()
	o: 

nname: 307
n 307(None)[log.debug('fallback step 2 failed')
for m in modes:
	if abs(mode[3] - current[3]) <= 1:
		break
		continue
else:
	log.debug('fallback step 3 failed')
	for m in modes:
		if mode in hdmiresolution_dict:
			break
			continue
	else:
		log.debug('fallback step 4 failed -> use CVBS resolution (PAL/NTSC)')
]:
	i: 222(AF), 229&261(f)
	o: 489()

nname: 229&261
n 229&261(None)[for m in modes:
if mode[2] == current[2] and abs(mode[3] - current[3]) <= 1:
	break
	continue
]:
	i: 222(for)
	o: 307()

nname: 222
n 222(None)[]:
	i: 205(loop)
	o: 229&261(for), 307(AF)

nname: 205
n 205(None)[log.debug('fallback step 1 failed')
]:
	i: 130(AF), 137&169(f)
	o: 222(loop), 489(AL)

nname: 137&169
n 137&169(None)[for m in modes:
fallback, mode, fallback, mode, fallback, mode, fallback, mode = config.cvbs_resolution[config.user_config['connections']['composite_output']], m.tuple_repr, mode, m.tuple_repr, mode, m.tuple_repr, mode, m.tuple_repr
if mode[2] == current[2] and mode[3] == current[3]:
	fallback = mode
	break
	continue
]:
	i: 130(for)
	o: 205()

nname: 130
n 130(None)[]:
	i: 0(loop)
	o: 137&169(for), 205(AF)

nname: 0
n 0(None)[modes = self.hdmi_sink.get_modes()
modes.sort()
modes.reverse()
log.debug('HDMI supported modes: %s', modes)
current = config.user_config['connections']['resolution']
if current in modes:
	log.debug('current HD mode (%s) supported by HDMI sink', current)
	return current
log.warn('%s not supported by HDMI sink, fallback starting...', current)
fallback = None
]:
	i: 
	o: 130(loop), 489(AL)

nname: 489
n 489(None)[log.warn('best mode supported by HDMI sink: %s', fallback)
return fallback
]:
	i: 0(AL), 229&261()
	o: 

nname: 229&261
n 229&261(None)[for m in modes:
	if mode[2] == current[2] and abs(mode[3] - current[3]) <= 1:
		break
		continue
else:
	log.debug('fallback step 2 failed')
	for m in modes:
		if abs(mode[3] - current[3]) <= 1:
			break
			continue
	else:
		log.debug('fallback step 3 failed')
		for m in modes:
			if mode in hdmiresolution_dict:
				break
				continue
		else:
			log.debug('fallback step 4 failed -> use CVBS resolution (PAL/NTSC)')
]:
	i: 205(for)
	o: 489()

nname: 205
n 205(None)[log.debug('fallback step 1 failed')
]:
	i: 130(AF), 137&169(f)
	o: 229&261(for)

nname: 137&169
n 137&169(None)[for m in modes:
fallback, mode, fallback, mode, fallback, mode, fallback, mode = config.cvbs_resolution[config.user_config['connections']['composite_output']], m.tuple_repr, mode, m.tuple_repr, mode, m.tuple_repr, mode, m.tuple_repr
if mode[2] == current[2] and mode[3] == current[3]:
	fallback = mode
	break
	continue
]:
	i: 130(for)
	o: 205()

nname: 130
n 130(None)[]:
	i: 0(loop)
	o: 137&169(for), 205(AF)

nname: 0
n 0(None)[modes = self.hdmi_sink.get_modes()
modes.sort()
modes.reverse()
log.debug('HDMI supported modes: %s', modes)
current = config.user_config['connections']['resolution']
if current in modes:
	log.debug('current HD mode (%s) supported by HDMI sink', current)
	return current
log.warn('%s not supported by HDMI sink, fallback starting...', current)
fallback = None
]:
	i: 
	o: 130(loop), 489(AL)

nname: 489
n 489(None)[log.warn('best mode supported by HDMI sink: %s', fallback)
return fallback
]:
	i: 0(AL), 205()
	o: 

nname: 205
n 205(None)[log.debug('fallback step 1 failed')
for m in modes:
	if mode[2] == current[2] and abs(mode[3] - current[3]) <= 1:
		break
		continue
else:
	log.debug('fallback step 2 failed')
	for m in modes:
		if abs(mode[3] - current[3]) <= 1:
			break
			continue
	else:
		log.debug('fallback step 3 failed')
		for m in modes:
			if mode in hdmiresolution_dict:
				break
				continue
		else:
			log.debug('fallback step 4 failed -> use CVBS resolution (PAL/NTSC)')
]:
	i: 130(AF), 137&169(f)
	o: 489()

nname: 137&169
n 137&169(None)[for m in modes:
fallback, mode, fallback, mode, fallback, mode, fallback, mode = config.cvbs_resolution[config.user_config['connections']['composite_output']], m.tuple_repr, mode, m.tuple_repr, mode, m.tuple_repr, mode, m.tuple_repr
if mode[2] == current[2] and mode[3] == current[3]:
	fallback = mode
	break
	continue
]:
	i: 130(for)
	o: 205()

nname: 130
n 130(None)[]:
	i: 0(loop)
	o: 137&169(for), 205(AF)

nname: 0
n 0(None)[modes = self.hdmi_sink.get_modes()
modes.sort()
modes.reverse()
log.debug('HDMI supported modes: %s', modes)
current = config.user_config['connections']['resolution']
if current in modes:
	log.debug('current HD mode (%s) supported by HDMI sink', current)
	return current
log.warn('%s not supported by HDMI sink, fallback starting...', current)
fallback = None
]:
	i: 
	o: 130(loop), 489(AL)

self.nodes: {0: <unpyclib.structure.node instance at 0xb7756f0c>, 130: <unpyclib.structure.node instance at 0xb775c10c>, '137&169': <unpyclib.structure.node instance at 0xb77565ac>, 205: <unpyclib.structure.node instance at 0xb77563ac>, 489: <unpyclib.structure.node instance at 0xb775c8cc>}
nname: 258
n 258(None)[self.switch_to()
return None
]:
	i: 193(), 227()
	o: 

nname: 227
n 227(None)[config.user_config['connections']['active_device'] = 'hdmi'
config.user_config.save()
]:
	i: 178(f)
	o: 258()

nname: 193
n 193(None)[config.user_config['connections']['active_device'] = 'cvbs'
config.user_config.save()
]:
	i: 178(t)
	o: 258()

nname: 178
n 178(self.hdmi_sink is None)[]:
	i: 141(JA), 145(JA), 165(), 168()
	o: 193(t), 227(f)

nname: 168
n 168(None)[self.previous_resolution = None
]:
	i: 0(f)
	o: 178()

nname: 145
n 145(None)[log.debug('get_resolution failed')
]:
	i: 42(except)
	o: 178(JA)

nname: 141
n 141(None)[]:
	i: 127(), 140()
	o: 178(JA)

nname: 140
n 140(None)[]:
	i: 66(f)
	o: 141()

nname: 127
n 127(None)[self.previous_resolution = None
]:
	i: 66(t)
	o: 141()

nname: 66
n 66(display.get_resolution() != ((w, h), interlaced))[w, h, interlaced, freq = self.previous_resolution
display = pygui_globs['display']
]:
	i: 42(try)
	o: 127(t), 140(f)

nname: 42
n 42(None)[self.previous_resolution = config.user_config['connections']['resolution']
]:
	i: 0(t)
	o: 66(try), 145(except)

nname: 0
n 0(active_device == 'hdmi')[active_device = config.user_config['connections']['active_device']
log.debug('initial switch...')
]:
	i: 
	o: 42(t), 168(f)

nname: 178
n 178(None)[if self.hdmi_sink is None:
	config.user_config['connections']['active_device'] = 'cvbs'
	config.user_config.save()
else:
	config.user_config['connections']['active_device'] = 'hdmi'
	config.user_config.save()
self.switch_to()
return None
]:
	i: 145(JA), 165(), 168(), 42()
	o: 

nname: 168
n 168(None)[self.previous_resolution = None
]:
	i: 0(f)
	o: 178()

nname: 145
n 145(None)[except:
	log.debug('get_resolution failed')
]:
	i: 42()
	o: 178(JA)

nname: 42
n 42(None)[self.previous_resolution = config.user_config['connections']['resolution']
try:
	w, h, interlaced, freq = self.previous_resolution
	display = pygui_globs['display']
	if display.get_resolution() != ((w, h), interlaced):
		self.previous_resolution = None
]:
	i: 0(t)
	o: 178(), 145()

nname: 0
n 0(active_device == 'hdmi')[active_device = config.user_config['connections']['active_device']
log.debug('initial switch...')
]:
	i: 
	o: 42(t), 168(f)

self.nodes: {0: <unpyclib.structure.node instance at 0xb775542c>, 164: <unpyclib.structure.node instance at 0xb775516c>, 165: <unpyclib.structure.node instance at 0xb775534c>, 168: <unpyclib.structure.node instance at 0xb775566c>, 42: <unpyclib.structure.node instance at 0xb7752c0c>, 145: <unpyclib.structure.node instance at 0xb77555ac>, 178: <unpyclib.structure.node instance at 0xb7752c6c>}
nname: 48
n 48(None)[]:
	i: 23(), 37()
	o: 

nname: 37
n 37(None)[self._go_cvbs()
]:
	i: 0(f)
	o: 48()

nname: 23
n 23(None)[self._go_hdmi()
]:
	i: 0(t)
	o: 48()

nname: 0
n 0(config.user_config['connections']['active_device'] == 'hdmi')[]:
	i: 
	o: 23(t), 37(f)

nname: 0
n 0(None)[if config.user_config['connections']['active_device'] == 'hdmi':
	self._go_hdmi()
else:
	self._go_cvbs()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76e306c>}
nname: 212
n 212(None)[]:
	i: 178(JA), 191(), 211()
	o: 

nname: 211
n 211(None)[]:
	i: 0(f)
	o: 212()

nname: 191
n 191(None)[log.debug('current_mode = wanted_mode = %s: nothing to do', resolution)
]:
	i: 9(f)
	o: 212()

nname: 178
n 178(None)[louie_send('connection_switched')
]:
	i: 160(), 177()
	o: 212(JA)

nname: 177
n 177(None)[]:
	i: 37(t)
	o: 178()

nname: 160
n 160(None)[config.user_config.save()
]:
	i: 37(f)
	o: 178()

nname: 37
n 37(PowerManager().sleeping)[w, h, interlaced, freq = resolution
log.debug('Setting resolution to %s', resolution)
display = pygui_globs['display']
display.set_resolution((w, h), interlaced, freq)
display.set_aspect_ratio(config.user_config['video']['aspect_ratio'])
config.user_config['connections']['resolution'] = resolution
]:
	i: 9(t)
	o: 160(f), 177(t)

nname: 9
n 9(self.previous_resolution != resolution)[resolution = self._choose_hd_resolution()
]:
	i: 0(t)
	o: 37(t), 191(f)

nname: 0
n 0(self.hdmi_sink)[]:
	i: 
	o: 9(t), 211(f)

nname: 212
n 212(None)[]:
	i: 37(JA), 191(), 0(f)
	o: 

nname: 191
n 191(None)[log.debug('current_mode = wanted_mode = %s: nothing to do', resolution)
]:
	i: 9(f)
	o: 212()

nname: 37
n 37(None)[w, h, interlaced, freq = resolution
log.debug('Setting resolution to %s', resolution)
display = pygui_globs['display']
display.set_resolution((w, h), interlaced, freq)
display.set_aspect_ratio(config.user_config['video']['aspect_ratio'])
config.user_config['connections']['resolution'] = resolution
if not PowerManager().sleeping:
	config.user_config.save()
louie_send('connection_switched')
]:
	i: 9(t)
	o: 212(JA)

nname: 9
n 9(self.previous_resolution != resolution)[resolution = self._choose_hd_resolution()
]:
	i: 0(t)
	o: 37(t), 191(f)

nname: 0
n 0(self.hdmi_sink)[]:
	i: 
	o: 9(t), 212(f)

nname: 0
n 0(None)[if self.hdmi_sink:
	resolution = self._choose_hd_resolution()
	if self.previous_resolution != resolution:
		w, h, interlaced, freq = resolution
		log.debug('Setting resolution to %s', resolution)
		display = pygui_globs['display']
		display.set_resolution((w, h), interlaced, freq)
		display.set_aspect_ratio(config.user_config['video']['aspect_ratio'])
		config.user_config['connections']['resolution'] = resolution
		if not PowerManager().sleeping:
			config.user_config.save()
		louie_send('connection_switched')
	else:
		log.debug('current_mode = wanted_mode = %s: nothing to do', resolution)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76e3d4c>}
nname: 139
n 139(None)[]:
	i: 39(), 122()
	o: 

nname: 122
n 122(None)[log.debug('current_mode = wanted_mode = %s: nothing to do', resolution)
]:
	i: 0(f)
	o: 139()

nname: 39
n 39(None)[w, h, interlaced, freq = resolution
log.debug('Setting resolution to %s', resolution)
display = pygui_globs['display']
display.set_resolution((w, h), interlaced, freq)
louie_send('connection_switched')
]:
	i: 0(t)
	o: 139()

nname: 0
n 0(self.previous_resolution != resolution)[resolution = config.cvbs_resolution[config.user_config['connections']['composite_output']]
]:
	i: 
	o: 39(t), 122(f)

nname: 0
n 0(None)[resolution = config.cvbs_resolution[config.user_config['connections']['composite_output']]
if self.previous_resolution != resolution:
	w, h, interlaced, freq = resolution
	log.debug('Setting resolution to %s', resolution)
	display = pygui_globs['display']
	display.set_resolution((w, h), interlaced, freq)
	louie_send('connection_switched')
else:
	log.debug('current_mode = wanted_mode = %s: nothing to do', resolution)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76e326c>}
nname: 0
n 0(None)[log.debug('try to close video player')
pygui_globs['menustack'].close_player(type='video')
self.switch_to()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76e364c>}
DFADecompile Exception need more than 0 values to unpack
nname: 70
n 70(None)[70]:
	i: 65(AE)
	o: 

nname: 65
n 65(None)[return sink
]:
	i: 0(finally), 61()
	o: 70(AE)

nname: 61
n 61(None)[]:
	i: 44(), 48(), 60(AE)
	o: 65()

nname: 48
n 48(None)[sink = None
]:
	i: 3(except)
	o: 61()

nname: 44
n 44(None)[]:
	i: 21(), 34()
	o: 61()

nname: 34
n 34(None)[sink = DummyHDMISink()
]:
	i: 6(f)
	o: 44()

nname: 21
n 21(None)[sink = HDMISink()
]:
	i: 6(t)
	o: 44()

nname: 6
n 6(config.architecture != 'pc')[]:
	i: 3(try)
	o: 21(t), 34(f)

nname: 3
n 3(None)[]:
	i: 0(ASF)
	o: 6(try), 48(except)

nname: 0
n 0(None)[]:
	i: 
	o: 3(ASF2), 65(finally)

nname: 70
n 70(None)[70]:
	i: 65(AE)
	o: 

nname: 65
n 65(None)[return sink
]:
	i: 0(finally), 48(), 3()
	o: 70(AE)

nname: 48
n 48(None)[except:
	sink = None
]:
	i: 3()
	o: 65()

nname: 3
n 3(None)[try:
	if config.architecture != 'pc':
		sink = HDMISink()
	else:
		sink = DummyHDMISink()
]:
	i: 0(ASF2)
	o: 65(), 48()

nname: 0
n 0(None)[]:
	i: 
	o: 3(ASF2), 65(finally)

self.nodes: {0: <unpyclib.structure.node instance at 0xb76e396c>, 65: <unpyclib.structure.node instance at 0xb76e30cc>, 3: <unpyclib.structure.node instance at 0xb7752cec>, 70: <unpyclib.structure.node instance at 0xb76e37ac>, 48: <unpyclib.structure.node instance at 0xb76e3f2c>}
nname: 53
n 53(None)[return []
]:
	i: 9(), 52()
	o: 

nname: 52
n 52(None)[]:
	i: 0(f)
	o: 53()

nname: 9
n 9(None)[modes = self.hdmi_sink.get_modes()
modes.sort()
modes.reverse()
return modes
]:
	i: 0(t)
	o: 53()

nname: 0
n 0(self.hdmi_sink)[]:
	i: 
	o: 9(t), 52(f)

nname: 0
n 0(None)[if self.hdmi_sink:
	modes = self.hdmi_sink.get_modes()
	modes.sort()
	modes.reverse()
	return modes
return []
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76e35ec>}
nname: 112
n 112(None)[return False
]:
	i: 34(), 111()
	o: 

nname: 111
n 111(None)[]:
	i: 0&15(f)
	o: 112()

nname: 34
n 34(None)[log.debug('SET_RESOLUTION: %s', new_mode)
w, h, interlaced, freq = new_mode
display = pygui_globs['display']
display.set_resolution((w, h), interlaced, freq)
return True
]:
	i: 0&15(t)
	o: 112()

nname: 0&15
n 0&15(self.hdmi_sink is None or new_mode in self.get_hdmi_modes())[]:
	i: 
	o: 34(t), 111(f)

nname: 0&15
n 0&15(None)[if self.hdmi_sink is None or new_mode in self.get_hdmi_modes():
	log.debug('SET_RESOLUTION: %s', new_mode)
	w, h, interlaced, freq = new_mode
	display = pygui_globs['display']
	display.set_resolution((w, h), interlaced, freq)
	return True
return False
]:
	i: 
	o: 

self.nodes: {'0&15': <unpyclib.structure.node instance at 0xb76e3dcc>}
nname: 126
n 126(None)[]:
	i: 112(), 125()
	o: 

nname: 125
n 125(None)[]:
	i: 0(f)
	o: 126()

nname: 112
n 112(None)[self.close_player()
]:
	i: 94(), 111()
	o: 126()

nname: 111
n 111(None)[]:
	i: 22(t)
	o: 112()

nname: 94
n 94(None)[config.user_config.save()
]:
	i: 22(f)
	o: 112()

nname: 22
n 22(PowerManager().sleeping)[self.hdmi_sink = self._get_hdmi_sink()
self.previous_resolution = config.cvbs_resolution[config.user_config['connections']['composite_output']]
config.user_config['connections']['active_device'] = 'hdmi'
]:
	i: 0(t)
	o: 94(f), 111(t)

nname: 0
n 0(self.handle_events)[log.debug('hdmi plugged')
]:
	i: 
	o: 22(t), 125(f)

nname: 126
n 126(None)[]:
	i: 22(), 0(f)
	o: 

nname: 22
n 22(None)[self.hdmi_sink = self._get_hdmi_sink()
self.previous_resolution = config.cvbs_resolution[config.user_config['connections']['composite_output']]
config.user_config['connections']['active_device'] = 'hdmi'
if not PowerManager().sleeping:
	config.user_config.save()
self.close_player()
]:
	i: 0(t)
	o: 126()

nname: 0
n 0(self.handle_events)[log.debug('hdmi plugged')
]:
	i: 
	o: 22(t), 126(f)

nname: 0
n 0(None)[log.debug('hdmi plugged')
if self.handle_events:
	self.hdmi_sink = self._get_hdmi_sink()
	self.previous_resolution = config.cvbs_resolution[config.user_config['connections']['composite_output']]
	config.user_config['connections']['active_device'] = 'hdmi'
	if not PowerManager().sleeping:
		config.user_config.save()
	self.close_player()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76e3f4c>}
nname: 113
n 113(None)[return None
]:
	i: 99(), 112()
	o: 

nname: 112
n 112(None)[]:
	i: 0(f)
	o: 113()

nname: 99
n 99(None)[self.close_player()
]:
	i: 81(), 98()
	o: 113()

nname: 98
n 98(None)[]:
	i: 22(t)
	o: 99()

nname: 81
n 81(None)[config.user_config.save()
]:
	i: 22(f)
	o: 99()

nname: 22
n 22(PowerManager().sleeping)[self.hdmi_sink = None
self.previous_resolution = config.user_config['connections']['resolution']
config.user_config['connections']['active_device'] = 'cvbs'
]:
	i: 0(t)
	o: 81(f), 98(t)

nname: 0
n 0(self.handle_events)[log.debug('hdmi unplugged')
]:
	i: 
	o: 22(t), 112(f)

nname: 113
n 113(None)[return None
]:
	i: 22(), 0(f)
	o: 

nname: 22
n 22(None)[self.hdmi_sink = None
self.previous_resolution = config.user_config['connections']['resolution']
config.user_config['connections']['active_device'] = 'cvbs'
if not PowerManager().sleeping:
	config.user_config.save()
self.close_player()
]:
	i: 0(t)
	o: 113()

nname: 0
n 0(self.handle_events)[log.debug('hdmi unplugged')
]:
	i: 
	o: 22(t), 113(f)

nname: 0
n 0(None)[log.debug('hdmi unplugged')
if self.handle_events:
	self.hdmi_sink = None
	self.previous_resolution = config.user_config['connections']['resolution']
	config.user_config['connections']['active_device'] = 'cvbs'
	if not PowerManager().sleeping:
		config.user_config.save()
	self.close_player()
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76e3c4c>}
nname: 6
n 6(None)[__doc__ = ' Class to handle connected video output '
def __init__(self):
	self.switch_to_task = Task(self._switch_to)
	self.switch_to_task.delay = 3.0
	self.switch_to = self.switch_to_task.start
	self.close_player_task = Task(self._close_player)
	self.close_player_task.delay = 1.0
	self.close_player = self.close_player_task.start
	self.previous_resolution = None
	self.handle_events = True
	try:
		hdmi_plugged = open('/sys/class/stmcoredisplay/display0/hdmi0.0/hotplug', 'r').read().strip()
	except:
		if config.architecture != 'pc':
			hdmi_plugged = 'n'
		else:
			hdmi_plugged = 'y'
	finally:
		if hdmi_plugged != 'y':
			self.hdmi_sink = None
		else:
			self.hdmi_sink = self._get_hdmi_sink()
	self._initial_switch()
	wdb = pygui_globs['wydbus']
	if wdb:
		self.inst = wdb.instance('/com/wyplay/wycrs/wyhpd')
		self.inst.signal('plug', '', self.plug_hdmi, 0)
		self.inst.signal('unplug', '', self.unplug_hdmi, 0)
	return None

def _choose_hd_resolution(self):
	modes = self.hdmi_sink.get_modes()
	modes.sort()
	modes.reverse()
	log.debug('HDMI supported modes: %s', modes)
	current = config.user_config['connections']['resolution']
	if current in modes:
		log.debug('current HD mode (%s) supported by HDMI sink', current)
		return current
	log.warn('%s not supported by HDMI sink, fallback starting...', current)
	fallback = None

def _initial_switch(self):
	active_device = config.user_config['connections']['active_device']
	log.debug('initial switch...')

def _switch_to(self):
	if config.user_config['connections']['active_device'] == 'hdmi':
		self._go_hdmi()
	else:
		self._go_cvbs()

def _go_hdmi(self):
	if self.hdmi_sink:
		resolution = self._choose_hd_resolution()
		if self.previous_resolution != resolution:
			w, h, interlaced, freq = resolution
			log.debug('Setting resolution to %s', resolution)
			display = pygui_globs['display']
			display.set_resolution((w, h), interlaced, freq)
			display.set_aspect_ratio(config.user_config['video']['aspect_ratio'])
			config.user_config['connections']['resolution'] = resolution
			if not PowerManager().sleeping:
				config.user_config.save()
			louie_send('connection_switched')
		else:
			log.debug('current_mode = wanted_mode = %s: nothing to do', resolution)

def _go_cvbs(self):
	resolution = config.cvbs_resolution[config.user_config['connections']['composite_output']]
	if self.previous_resolution != resolution:
		w, h, interlaced, freq = resolution
		log.debug('Setting resolution to %s', resolution)
		display = pygui_globs['display']
		display.set_resolution((w, h), interlaced, freq)
		louie_send('connection_switched')
	else:
		log.debug('current_mode = wanted_mode = %s: nothing to do', resolution)

def _close_player(self):
	log.debug('try to close video player')
	pygui_globs['menustack'].close_player(type='video')
	self.switch_to()

def _get_hdmi_sink(self):
	pass

def get_hdmi_modes(self):
	if self.hdmi_sink:
		modes = self.hdmi_sink.get_modes()
		modes.sort()
		modes.reverse()
		return modes
	return []

def secure_set_resolution(self, new_mode):
	if self.hdmi_sink is None or new_mode in self.get_hdmi_modes():
		log.debug('SET_RESOLUTION: %s', new_mode)
		w, h, interlaced, freq = new_mode
		display = pygui_globs['display']
		display.set_resolution((w, h), interlaced, freq)
		return True
	return False

def plug_hdmi(self):
	log.debug('hdmi plugged')
	if self.handle_events:
		self.hdmi_sink = self._get_hdmi_sink()
		self.previous_resolution = config.cvbs_resolution[config.user_config['connections']['composite_output']]
		config.user_config['connections']['active_device'] = 'hdmi'
		if not PowerManager().sleeping:
			config.user_config.save()
		self.close_player()

def unplug_hdmi(self):
	log.debug('hdmi unplugged')
	if self.handle_events:
		self.hdmi_sink = None
		self.previous_resolution = config.user_config['connections']['resolution']
		config.user_config['connections']['active_device'] = 'cvbs'
		if not PowerManager().sleeping:
			config.user_config.save()
		self.close_player()
	return None

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb7752aec>}
nname: 0
n 0(None)[from __future__ import absolute_import
from wydbus import WyDbus
import pygui.config as config
from pygui.facilities.codemapping import hdmiresolution_dict
from pygui.facilities.power import PowerManager
from pygui.shared import pygui_globs
from peewee.hdmi import HDMISink, VideoMode
from peewee.notifier import Task
from peewee.debug import GET_LOGGER
from peewee.messages import send as louie_send
log = GET_LOGGER(__name__)
class DummyHDMISink(HDMISink):
	def __init__(self, display=0):
		self.display = display
		self.syspath = None
		self.id = 0
		self.modes = self.get_modes()
		return None

	def get_modes(self):
		sys_list = ['S:1280x720p-60', 'S:1280x720p-59', 'S:1280x720p-50', 'S:720x480p-60', 'S:720x480p-59', 'S:720x576p-50']

	def get_hpd(self):
		return True



class VideoModes(object):
	__doc__ = ' Class to handle connected video output '
	def __init__(self):
		self.switch_to_task = Task(self._switch_to)
		self.switch_to_task.delay = 3.0
		self.switch_to = self.switch_to_task.start
		self.close_player_task = Task(self._close_player)
		self.close_player_task.delay = 1.0
		self.close_player = self.close_player_task.start
		self.previous_resolution = None
		self.handle_events = True
		try:
			hdmi_plugged = open('/sys/class/stmcoredisplay/display0/hdmi0.0/hotplug', 'r').read().strip()
		except:
			if config.architecture != 'pc':
				hdmi_plugged = 'n'
			else:
				hdmi_plugged = 'y'
		finally:
			if hdmi_plugged != 'y':
				self.hdmi_sink = None
			else:
				self.hdmi_sink = self._get_hdmi_sink()
		self._initial_switch()
		wdb = pygui_globs['wydbus']
		if wdb:
			self.inst = wdb.instance('/com/wyplay/wycrs/wyhpd')
			self.inst.signal('plug', '', self.plug_hdmi, 0)
			self.inst.signal('unplug', '', self.unplug_hdmi, 0)
		return None

	def _choose_hd_resolution(self):
		modes = self.hdmi_sink.get_modes()
		modes.sort()
		modes.reverse()
		log.debug('HDMI supported modes: %s', modes)
		current = config.user_config['connections']['resolution']
		if current in modes:
			log.debug('current HD mode (%s) supported by HDMI sink', current)
			return current
		log.warn('%s not supported by HDMI sink, fallback starting...', current)
		fallback = None

	def _initial_switch(self):
		active_device = config.user_config['connections']['active_device']
		log.debug('initial switch...')

	def _switch_to(self):
		if config.user_config['connections']['active_device'] == 'hdmi':
			self._go_hdmi()
		else:
			self._go_cvbs()

	def _go_hdmi(self):
		if self.hdmi_sink:
			resolution = self._choose_hd_resolution()
			if self.previous_resolution != resolution:
				w, h, interlaced, freq = resolution
				log.debug('Setting resolution to %s', resolution)
				display = pygui_globs['display']
				display.set_resolution((w, h), interlaced, freq)
				display.set_aspect_ratio(config.user_config['video']['aspect_ratio'])
				config.user_config['connections']['resolution'] = resolution
				if not PowerManager().sleeping:
					config.user_config.save()
				louie_send('connection_switched')
			else:
				log.debug('current_mode = wanted_mode = %s: nothing to do', resolution)

	def _go_cvbs(self):
		resolution = config.cvbs_resolution[config.user_config['connections']['composite_output']]
		if self.previous_resolution != resolution:
			w, h, interlaced, freq = resolution
			log.debug('Setting resolution to %s', resolution)
			display = pygui_globs['display']
			display.set_resolution((w, h), interlaced, freq)
			louie_send('connection_switched')
		else:
			log.debug('current_mode = wanted_mode = %s: nothing to do', resolution)

	def _close_player(self):
		log.debug('try to close video player')
		pygui_globs['menustack'].close_player(type='video')
		self.switch_to()

	def _get_hdmi_sink(self):
		pass

	def get_hdmi_modes(self):
		if self.hdmi_sink:
			modes = self.hdmi_sink.get_modes()
			modes.sort()
			modes.reverse()
			return modes
		return []

	def secure_set_resolution(self, new_mode):
		if self.hdmi_sink is None or new_mode in self.get_hdmi_modes():
			log.debug('SET_RESOLUTION: %s', new_mode)
			w, h, interlaced, freq = new_mode
			display = pygui_globs['display']
			display.set_resolution((w, h), interlaced, freq)
			return True
		return False

	def plug_hdmi(self):
		log.debug('hdmi plugged')
		if self.handle_events:
			self.hdmi_sink = self._get_hdmi_sink()
			self.previous_resolution = config.cvbs_resolution[config.user_config['connections']['composite_output']]
			config.user_config['connections']['active_device'] = 'hdmi'
			if not PowerManager().sleeping:
				config.user_config.save()
			self.close_player()

	def unplug_hdmi(self):
		log.debug('hdmi unplugged')
		if self.handle_events:
			self.hdmi_sink = None
			self.previous_resolution = config.user_config['connections']['resolution']
			config.user_config['connections']['active_device'] = 'cvbs'
			if not PowerManager().sleeping:
				config.user_config.save()
			self.close_player()
		return None



]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7747e0c>}
from __future__ import absolute_import
from wydbus import WyDbus
import pygui.config as config
from pygui.facilities.codemapping import hdmiresolution_dict
from pygui.facilities.power import PowerManager
from pygui.shared import pygui_globs
from peewee.hdmi import HDMISink, VideoMode
from peewee.notifier import Task
from peewee.debug import GET_LOGGER
from peewee.messages import send as louie_send
log = GET_LOGGER(__name__)
class DummyHDMISink(HDMISink):
	def __init__(self, display=0):
		self.display = display
		self.syspath = None
		self.id = 0
		self.modes = self.get_modes()
		return None

	def get_modes(self):
		sys_list = ['S:1280x720p-60', 'S:1280x720p-59', 'S:1280x720p-50', 'S:720x480p-60', 'S:720x480p-59', 'S:720x576p-50']

	def get_hpd(self):
		return True



class VideoModes(object):
	__doc__ = ' Class to handle connected video output '
	def __init__(self):
		self.switch_to_task = Task(self._switch_to)
		self.switch_to_task.delay = 3.0
		self.switch_to = self.switch_to_task.start
		self.close_player_task = Task(self._close_player)
		self.close_player_task.delay = 1.0
		self.close_player = self.close_player_task.start
		self.previous_resolution = None
		self.handle_events = True
		try:
			hdmi_plugged = open('/sys/class/stmcoredisplay/display0/hdmi0.0/hotplug', 'r').read().strip()
		except:
			if config.architecture != 'pc':
				hdmi_plugged = 'n'
			else:
				hdmi_plugged = 'y'
		finally:
			if hdmi_plugged != 'y':
				self.hdmi_sink = None
			else:
				self.hdmi_sink = self._get_hdmi_sink()
		self._initial_switch()
		wdb = pygui_globs['wydbus']
		if wdb:
			self.inst = wdb.instance('/com/wyplay/wycrs/wyhpd')
			self.inst.signal('plug', '', self.plug_hdmi, 0)
			self.inst.signal('unplug', '', self.unplug_hdmi, 0)
		return None

	def _choose_hd_resolution(self):
		modes = self.hdmi_sink.get_modes()
		modes.sort()
		modes.reverse()
		log.debug('HDMI supported modes: %s', modes)
		current = config.user_config['connections']['resolution']
		if current in modes:
			log.debug('current HD mode (%s) supported by HDMI sink', current)
			return current
		log.warn('%s not supported by HDMI sink, fallback starting...', current)
		fallback = None

	def _initial_switch(self):
		active_device = config.user_config['connections']['active_device']
		log.debug('initial switch...')

	def _switch_to(self):
		if config.user_config['connections']['active_device'] == 'hdmi':
			self._go_hdmi()
		else:
			self._go_cvbs()

	def _go_hdmi(self):
		if self.hdmi_sink:
			resolution = self._choose_hd_resolution()
			if self.previous_resolution != resolution:
				w, h, interlaced, freq = resolution
				log.debug('Setting resolution to %s', resolution)
				display = pygui_globs['display']
				display.set_resolution((w, h), interlaced, freq)
				display.set_aspect_ratio(config.user_config['video']['aspect_ratio'])
				config.user_config['connections']['resolution'] = resolution
				if not PowerManager().sleeping:
					config.user_config.save()
				louie_send('connection_switched')
			else:
				log.debug('current_mode = wanted_mode = %s: nothing to do', resolution)

	def _go_cvbs(self):
		resolution = config.cvbs_resolution[config.user_config['connections']['composite_output']]
		if self.previous_resolution != resolution:
			w, h, interlaced, freq = resolution
			log.debug('Setting resolution to %s', resolution)
			display = pygui_globs['display']
			display.set_resolution((w, h), interlaced, freq)
			louie_send('connection_switched')
		else:
			log.debug('current_mode = wanted_mode = %s: nothing to do', resolution)

	def _close_player(self):
		log.debug('try to close video player')
		pygui_globs['menustack'].close_player(type='video')
		self.switch_to()

	def _get_hdmi_sink(self):
		pass

	def get_hdmi_modes(self):
		if self.hdmi_sink:
			modes = self.hdmi_sink.get_modes()
			modes.sort()
			modes.reverse()
			return modes
		return []

	def secure_set_resolution(self, new_mode):
		if self.hdmi_sink is None or new_mode in self.get_hdmi_modes():
			log.debug('SET_RESOLUTION: %s', new_mode)
			w, h, interlaced, freq = new_mode
			display = pygui_globs['display']
			display.set_resolution((w, h), interlaced, freq)
			return True
		return False

	def plug_hdmi(self):
		log.debug('hdmi plugged')
		if self.handle_events:
			self.hdmi_sink = self._get_hdmi_sink()
			self.previous_resolution = config.cvbs_resolution[config.user_config['connections']['composite_output']]
			config.user_config['connections']['active_device'] = 'hdmi'
			if not PowerManager().sleeping:
				config.user_config.save()
			self.close_player()

	def unplug_hdmi(self):
		log.debug('hdmi unplugged')
		if self.handle_events:
			self.hdmi_sink = None
			self.previous_resolution = config.user_config['connections']['resolution']
			config.user_config['connections']['active_device'] = 'cvbs'
			if not PowerManager().sleeping:
				config.user_config.save()
			self.close_player()
		return None



