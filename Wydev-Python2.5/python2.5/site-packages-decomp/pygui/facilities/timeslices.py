# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 112
n 112(None)[return (day - timedelta(days=1), slice)
]:
	i: 0(AL), 111()
	o: 

nname: 111
n 111(None)[]:
	i: 30(AF), 107()
	o: 112()

nname: 107
n 107(None)[]:
	i: 90(f), 93()
	o: 111()

nname: 93
n 93(None)[return (day, slice)
continue
]:
	i: 90(t)
	o: 107()

nname: 90
n 90(day + start <= dt)[]:
	i: 74(), 88()
	o: 93(t), 107(f)

nname: 88
n 88(None)[dt
]:
	i: 37(f)
	o: 90()

nname: 74
n 74(None)[]:
	i: 37(t)
	o: 90()

nname: 37
n 37(day + start <= dt)[for slice in SLICES:
start, end = BOUNDARIES[slice]
]:
	i: 30(for)
	o: 74(t), 88(f)

nname: 30
n 30(None)[]:
	i: 0(loop)
	o: 37(for), 111(AF)

nname: 0
n 0(None)[day = datetime(dt.year, dt.month, dt.day)
]:
	i: 
	o: 30(loop), 112(AL)

nname: 112
n 112(None)[return (day - timedelta(days=1), slice)
]:
	i: 0(AL), 30(AF), 37(f)
	o: 

nname: 37
n 37(None)[for slice in SLICES:
start, end = BOUNDARIES[slice]
if day + start <= dt:
	pass
else:
	dt
if day + start <= dt:
	return (day, slice)
	continue
]:
	i: 30(for)
	o: 112()

nname: 30
n 30(None)[]:
	i: 0(loop)
	o: 37(for), 112(AF)

nname: 0
n 0(None)[day = datetime(dt.year, dt.month, dt.day)
]:
	i: 
	o: 30(loop), 112(AL)

nname: 37
n 37(None)[for slice in SLICES:
	start, end = BOUNDARIES[slice]
	if day + start <= dt:
		pass
	else:
		dt
	if day + start <= dt:
		return (day, slice)
		continue
return (day - timedelta(days=1), slice)
]:
	i: 0(for)
	o: 

nname: 0
n 0(None)[day = datetime(dt.year, dt.month, dt.day)
]:
	i: 
	o: 37(for)

nname: 0
n 0(None)[day = datetime(dt.year, dt.month, dt.day)
for slice in SLICES:
	start, end = BOUNDARIES[slice]
	if day + start <= dt:
		pass
	else:
		dt
	if day + start <= dt:
		return (day, slice)
		continue
return (day - timedelta(days=1), slice)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb770f4cc>}
nname: 0
n 0(None)[return get_slice_info(dt)[0]
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7708b6c>}
nname: 0
n 0(None)[return get_slice_info(dt)[1]
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7708bac>}
nname: 72
n 72(None)[]:
	i: 0(AL), 71()
	o: 

nname: 71
n 71(None)[]:
	i: 24(AF), 67()
	o: 72()

nname: 67
n 67(None)[]:
	i: 44(f), 59()
	o: 71()

nname: 59
n 59(None)[return slice_id
continue
]:
	i: 44(t)
	o: 67()

nname: 44
n 44(slice_id in NAMES)[for slice_id in SLICES[slice_index::-1]:
]:
	i: 24(for)
	o: 59(t), 67(f)

nname: 24
n 24(None)[]:
	i: 0(loop)
	o: 44(for), 71(AF)

nname: 0
n 0(None)[slice_index = SLICES.index(get_slice_id(dt))
]:
	i: 
	o: 24(loop), 72(AL)

nname: 72
n 72(None)[]:
	i: 0(AL), 24(AF), 44()
	o: 

nname: 44
n 44(None)[for slice_id in SLICES[slice_index::-1]:
if slice_id in NAMES:
	return slice_id
	continue
]:
	i: 24(for)
	o: 72()

nname: 24
n 24(None)[]:
	i: 0(loop)
	o: 44(for), 72(AF)

nname: 0
n 0(None)[slice_index = SLICES.index(get_slice_id(dt))
]:
	i: 
	o: 24(loop), 72(AL)

nname: 44
n 44(None)[for slice_id in SLICES[slice_index::-1]:
	if slice_id in NAMES:
		return slice_id
		continue
]:
	i: 0(for)
	o: 

nname: 0
n 0(None)[slice_index = SLICES.index(get_slice_id(dt))
]:
	i: 
	o: 44(for)

nname: 0
n 0(None)[slice_index = SLICES.index(get_slice_id(dt))
for slice_id in SLICES[slice_index::-1]:
	if slice_id in NAMES:
		return slice_id
		continue
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7708f8c>}
nname: 195
n 195(None)[return slice_count
]:
	i: 119(AL), 193()
	o: 

nname: 193
n 193(None)[]:
	i: 122(f), 189()
	o: 195()

nname: 189
n 189(None)[]:
	i: 128(f), 175()
	o: 193()

nname: 175
n 175(None)[value -= sign
continue
]:
	i: 128(t)
	o: 189()

nname: 128
n 128(SLICES[current_slice_index] in NAMES)[slice_count += sign
current_slice_index = (current_slice_index + sign) % len(SLICES)
]:
	i: 122(t)
	o: 175(t), 189(f)

nname: 122
n 122(value)[]:
	i: 119(loop)
	o: 128(t), 193(f)

nname: 119
n 119(None)[]:
	i: 71(), 118()
	o: 122(loop), 195(AL)

nname: 118
n 118(None)[]:
	i: 50(f)
	o: 119()

nname: 71
n 71(None)[visible_slice_id = get_visible_slice_id(dt)
visible_slice_index = SLICES.index(visible_slice_id)
slice_count = visible_slice_index - current_slice_index
current_slice_index = visible_slice_index
]:
	i: 50(t)
	o: 119()

nname: 50
n 50(sign == -1)[sign = -1
slice_count = 0
]:
	i: 39(), 46()
	o: 71(t), 118(f)

nname: 46
n 46(None)[]:
	i: 0(f)
	o: 50()

nname: 39
n 39(None)[]:
	i: 0(t)
	o: 50()

nname: 0
n 0(value >= 0)[slice_id = get_slice_id(dt)
current_slice_index = SLICES.index(slice_id)
]:
	i: 
	o: 39(t), 46(f)

nname: 195
n 195(None)[return slice_count
]:
	i: 119(AL), 122(f), 128()
	o: 

nname: 128
n 128(None)[slice_count += sign
current_slice_index = (current_slice_index + sign) % len(SLICES)
if SLICES[current_slice_index] in NAMES:
	value -= sign
	continue
]:
	i: 122(t)
	o: 195()

nname: 122
n 122(value)[]:
	i: 119(loop)
	o: 128(t), 195(f)

nname: 119
n 119(None)[]:
	i: 0()
	o: 122(loop), 195(AL)

nname: 0
n 0(None)[slice_id = get_slice_id(dt)
current_slice_index = SLICES.index(slice_id)
if value >= 0:
	pass
sign = -1
slice_count = 0
if sign == -1:
	visible_slice_id = get_visible_slice_id(dt)
	visible_slice_index = SLICES.index(visible_slice_id)
	slice_count = visible_slice_index - current_slice_index
	current_slice_index = visible_slice_index
]:
	i: 
	o: 119()

nname: 195
n 195(None)[return slice_count
]:
	i: 122()
	o: 

nname: 122
n 122(None)[while value:
	slice_count += sign
	current_slice_index = (current_slice_index + sign) % len(SLICES)
	if SLICES[current_slice_index] in NAMES:
		value -= sign
		continue
]:
	i: 0(loop)
	o: 195()

nname: 0
n 0(None)[slice_id = get_slice_id(dt)
current_slice_index = SLICES.index(slice_id)
if value >= 0:
	pass
sign = -1
slice_count = 0
if sign == -1:
	visible_slice_id = get_visible_slice_id(dt)
	visible_slice_index = SLICES.index(visible_slice_id)
	slice_count = visible_slice_index - current_slice_index
	current_slice_index = visible_slice_index
]:
	i: 
	o: 122(loop)

nname: 195
n 195(None)[return slice_count
]:
	i: 0()
	o: 

nname: 0
n 0(None)[slice_id = get_slice_id(dt)
current_slice_index = SLICES.index(slice_id)
if value >= 0:
	pass
sign = -1
slice_count = 0
if sign == -1:
	visible_slice_id = get_visible_slice_id(dt)
	visible_slice_index = SLICES.index(visible_slice_id)
	slice_count = visible_slice_index - current_slice_index
	current_slice_index = visible_slice_index
while value:
	slice_count += sign
	current_slice_index = (current_slice_index + sign) % len(SLICES)
	if SLICES[current_slice_index] in NAMES:
		value -= sign
		continue
]:
	i: 
	o: 195()

nname: 0
n 0(None)[slice_id = get_slice_id(dt)
current_slice_index = SLICES.index(slice_id)
if value >= 0:
	pass
sign = -1
slice_count = 0
if sign == -1:
	visible_slice_id = get_visible_slice_id(dt)
	visible_slice_index = SLICES.index(visible_slice_id)
	slice_count = visible_slice_index - current_slice_index
	current_slice_index = visible_slice_index
while value:
	slice_count += sign
	current_slice_index = (current_slice_index + sign) % len(SLICES)
	if SLICES[current_slice_index] in NAMES:
		value -= sign
		continue
return slice_count
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb770f6ec>}
nname: 155
n 155(None)[new_slice_id = SLICES[new_slice_index]
start_offset, end_offset = BOUNDARIES[new_slice_id]
return (day + start_offset, day + end_offset)
]:
	i: 93(AL), 153()
	o: 

nname: 153
n 153(None)[]:
	i: 96(f), 114()
	o: 155()

nname: 114
n 114(None)[new_slice_index -= len(SLICES)
day += timedelta(days=1)
]:
	i: 96(t)
	o: 153()

nname: 96
n 96(new_slice_index >= len(SLICES))[]:
	i: 93(loop)
	o: 114(t), 153(f)

nname: 93
n 93(None)[]:
	i: 0(AL), 91()
	o: 96(loop), 155(AL)

nname: 91
n 91(None)[]:
	i: 40(f), 52()
	o: 93()

nname: 52
n 52(None)[new_slice_index += len(SLICES)
day -= timedelta(days=1)
]:
	i: 40(t)
	o: 91()

nname: 40
n 40(new_slice_index < 0)[]:
	i: 0(loop)
	o: 52(t), 91(f)

nname: 0
n 0(None)[day, slice_id = get_slice_info(dt)
new_slice_index = SLICES.index(slice_id) + value
]:
	i: 
	o: 40(loop), 93(AL)

nname: 155
n 155(None)[new_slice_id = SLICES[new_slice_index]
start_offset, end_offset = BOUNDARIES[new_slice_id]
return (day + start_offset, day + end_offset)
]:
	i: 114()
	o: 

nname: 114
n 114(None)[	new_slice_index -= len(SLICES)
	day += timedelta(days=1)
]:
	i: 93(t)
	o: 155()

nname: 93
n 93(new_slice_index >= len(SLICES))[while new_slice_index >= len(SLICES):
]:
	i: 52()
	o: 114(t)

nname: 52
n 52(None)[	new_slice_index += len(SLICES)
	day -= timedelta(days=1)
]:
	i: 0(t)
	o: 93()

nname: 0
n 0(new_slice_index < 0)[day, slice_id = get_slice_info(dt)
new_slice_index = SLICES.index(slice_id) + value
while new_slice_index < 0:
]:
	i: 
	o: 52(t)

nname: 155
n 155(None)[new_slice_id = SLICES[new_slice_index]
start_offset, end_offset = BOUNDARIES[new_slice_id]
return (day + start_offset, day + end_offset)
]:
	i: 93()
	o: 

nname: 93
n 93(None)[while new_slice_index >= len(SLICES):
	new_slice_index -= len(SLICES)
	day += timedelta(days=1)
]:
	i: 0()
	o: 155()

nname: 0
n 0(None)[day, slice_id = get_slice_info(dt)
new_slice_index = SLICES.index(slice_id) + value
while new_slice_index < 0:
	new_slice_index += len(SLICES)
	day -= timedelta(days=1)
]:
	i: 
	o: 93()

nname: 155
n 155(None)[new_slice_id = SLICES[new_slice_index]
start_offset, end_offset = BOUNDARIES[new_slice_id]
return (day + start_offset, day + end_offset)
]:
	i: 0()
	o: 

nname: 0
n 0(None)[day, slice_id = get_slice_info(dt)
new_slice_index = SLICES.index(slice_id) + value
while new_slice_index < 0:
	new_slice_index += len(SLICES)
	day -= timedelta(days=1)
while new_slice_index >= len(SLICES):
	new_slice_index -= len(SLICES)
	day += timedelta(days=1)
]:
	i: 
	o: 155()

nname: 0
n 0(None)[day, slice_id = get_slice_info(dt)
new_slice_index = SLICES.index(slice_id) + value
while new_slice_index < 0:
	new_slice_index += len(SLICES)
	day -= timedelta(days=1)
while new_slice_index >= len(SLICES):
	new_slice_index -= len(SLICES)
	day += timedelta(days=1)
new_slice_id = SLICES[new_slice_index]
start_offset, end_offset = BOUNDARIES[new_slice_id]
return (day + start_offset, day + end_offset)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb770f60c>}
nname: 0
n 0(None)[return timeslice_boundaries(datetime.now())
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb770892c>}
nname: 0
n 0(None)[return td.seconds + td.days * 86400
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb770898c>}
nname: 0
n 0(None)[return mktime(dt.timetuple())
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7708c8c>}
nname: 0
n 0(None)[time_tuple = localtime(ts)
year = time_tuple[0]
month = month_dict[time_tuple[1]]
day = time_tuple[2]
wday = day_dict[time_tuple[6]]
return u'%s, %s %s %s' % (wday, day, month, year)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7708f2c>}
nname: 0
n 0(None)[from __future__ import absolute_import
from datetime import datetime, timedelta
from time import mktime, localtime
from pygui.facilities.codemapping import day_dict, month_dict
from pygui.facilities.l10n import UnicodeDict
SLICES = ['morning', 'morning2', 'afternoon', 'afternoon2', 'evening', 'evening2', 'night']
NAMES = UnicodeDict({'morning': 'Morning', 'afternoon': 'Afternoon', 'evening': 'Evening', 'night': 'Night'})
BOUNDARIES = {'morning': (timedelta(hours=6), timedelta(hours=9)), 'morning2': (timedelta(hours=9), timedelta(hours=12)), 'afternoon': (timedelta(hours=12), timedelta(hours=15)), 'afternoon2': (timedelta(hours=15), timedelta(hours=18)), 'evening': (timedelta(hours=18), timedelta(hours=21)), 'evening2': (timedelta(hours=21), timedelta(hours=24)), 'night': (timedelta(hours=24), timedelta(hours=30))}
def get_slice_info(dt):
	day = datetime(dt.year, dt.month, dt.day)
	for slice in SLICES:
		start, end = BOUNDARIES[slice]
		if day + start <= dt:
			pass
		else:
			dt
		if day + start <= dt:
			return (day, slice)
			continue
	return (day - timedelta(days=1), slice)

def get_epg_day(dt):
	return get_slice_info(dt)[0]

def get_slice_id(dt):
	return get_slice_info(dt)[1]

def get_visible_slice_id(dt):
	slice_index = SLICES.index(get_slice_id(dt))
	for slice_id in SLICES[slice_index::-1]:
		if slice_id in NAMES:
			return slice_id
			continue

def distance_to_visible_slice(dt, value):
	slice_id = get_slice_id(dt)
	current_slice_index = SLICES.index(slice_id)
	if value >= 0:
		pass
	sign = -1
	slice_count = 0
	if sign == -1:
		visible_slice_id = get_visible_slice_id(dt)
		visible_slice_index = SLICES.index(visible_slice_id)
		slice_count = visible_slice_index - current_slice_index
		current_slice_index = visible_slice_index
	while value:
		slice_count += sign
		current_slice_index = (current_slice_index + sign) % len(SLICES)
		if SLICES[current_slice_index] in NAMES:
			value -= sign
			continue
	return slice_count

def timeslice_boundaries(dt, value=0):
	day, slice_id = get_slice_info(dt)
	new_slice_index = SLICES.index(slice_id) + value
	while new_slice_index < 0:
		new_slice_index += len(SLICES)
		day -= timedelta(days=1)
	while new_slice_index >= len(SLICES):
		new_slice_index -= len(SLICES)
		day += timedelta(days=1)
	new_slice_id = SLICES[new_slice_index]
	start_offset, end_offset = BOUNDARIES[new_slice_id]
	return (day + start_offset, day + end_offset)

def current_timeslice():
	return timeslice_boundaries(datetime.now())

def timedelta_to_seconds(td):
	return td.seconds + td.days * 86400

def datetime_to_timestamp(dt):
	return mktime(dt.timetuple())

def seconds_to_long_date(ts):
	time_tuple = localtime(ts)
	year = time_tuple[0]
	month = month_dict[time_tuple[1]]
	day = time_tuple[2]
	wday = day_dict[time_tuple[6]]
	return u'%s, %s %s %s' % (wday, day, month, year)

]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76fcd0c>}
from __future__ import absolute_import
from datetime import datetime, timedelta
from time import mktime, localtime
from pygui.facilities.codemapping import day_dict, month_dict
from pygui.facilities.l10n import UnicodeDict
SLICES = ['morning', 'morning2', 'afternoon', 'afternoon2', 'evening', 'evening2', 'night']
NAMES = UnicodeDict({'morning': 'Morning', 'afternoon': 'Afternoon', 'evening': 'Evening', 'night': 'Night'})
BOUNDARIES = {'morning': (timedelta(hours=6), timedelta(hours=9)), 'morning2': (timedelta(hours=9), timedelta(hours=12)), 'afternoon': (timedelta(hours=12), timedelta(hours=15)), 'afternoon2': (timedelta(hours=15), timedelta(hours=18)), 'evening': (timedelta(hours=18), timedelta(hours=21)), 'evening2': (timedelta(hours=21), timedelta(hours=24)), 'night': (timedelta(hours=24), timedelta(hours=30))}
def get_slice_info(dt):
	day = datetime(dt.year, dt.month, dt.day)
	for slice in SLICES:
		start, end = BOUNDARIES[slice]
		if day + start <= dt:
			pass
		else:
			dt
		if day + start <= dt:
			return (day, slice)
			continue
	return (day - timedelta(days=1), slice)

def get_epg_day(dt):
	return get_slice_info(dt)[0]

def get_slice_id(dt):
	return get_slice_info(dt)[1]

def get_visible_slice_id(dt):
	slice_index = SLICES.index(get_slice_id(dt))
	for slice_id in SLICES[slice_index::-1]:
		if slice_id in NAMES:
			return slice_id
			continue

def distance_to_visible_slice(dt, value):
	slice_id = get_slice_id(dt)
	current_slice_index = SLICES.index(slice_id)
	if value >= 0:
		pass
	sign = -1
	slice_count = 0
	if sign == -1:
		visible_slice_id = get_visible_slice_id(dt)
		visible_slice_index = SLICES.index(visible_slice_id)
		slice_count = visible_slice_index - current_slice_index
		current_slice_index = visible_slice_index
	while value:
		slice_count += sign
		current_slice_index = (current_slice_index + sign) % len(SLICES)
		if SLICES[current_slice_index] in NAMES:
			value -= sign
			continue
	return slice_count

def timeslice_boundaries(dt, value=0):
	day, slice_id = get_slice_info(dt)
	new_slice_index = SLICES.index(slice_id) + value
	while new_slice_index < 0:
		new_slice_index += len(SLICES)
		day -= timedelta(days=1)
	while new_slice_index >= len(SLICES):
		new_slice_index -= len(SLICES)
		day += timedelta(days=1)
	new_slice_id = SLICES[new_slice_index]
	start_offset, end_offset = BOUNDARIES[new_slice_id]
	return (day + start_offset, day + end_offset)

def current_timeslice():
	return timeslice_boundaries(datetime.now())

def timedelta_to_seconds(td):
	return td.seconds + td.days * 86400

def datetime_to_timestamp(dt):
	return mktime(dt.timetuple())

def seconds_to_long_date(ts):
	time_tuple = localtime(ts)
	year = time_tuple[0]
	month = month_dict[time_tuple[1]]
	day = time_tuple[2]
	wday = day_dict[time_tuple[6]]
	return u'%s, %s %s %s' % (wday, day, month, year)

