# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 167
n 167(None)[return None
]:
	i: 81(), 107()
	o: 

nname: 81
n 81(None)[log.error('Cannot open mouse')
del self.mouse
]:
	i: 0(except)
	o: 167()

nname: 107
n 107(None)[self.kbmap_get = DIRECTFB_MAP.get
self.setDaemon(True)
self.setName('MousePlugin')
Task(self.start).start(1.0)
]:
	i: 19(), 106(AE)
	o: 167()

nname: 19
n 19(None)[self.mouse = Mouse(dev='/dev/input/mice')
self._last_event = None
self._last_ts = 0
self._last_pos = None
log.info('Mouse created')
]:
	i: 0(try)
	o: 107()

nname: 0
n 0(None)[threading.Thread.__init__(self)
]:
	i: 
	o: 19(try), 81(except)

nname: 167
n 167(None)[return None
]:
	i: 81()
	o: 

nname: 81
n 81(None)[except:
	log.error('Cannot open mouse')
	del self.mouse
else:
	self.kbmap_get = DIRECTFB_MAP.get
	self.setDaemon(True)
	self.setName('MousePlugin')
	Task(self.start).start(1.0)
]:
	i: 0()
	o: 167()

nname: 0
n 0(None)[threading.Thread.__init__(self)
try:
	self.mouse = Mouse(dev='/dev/input/mice')
	self._last_event = None
	self._last_ts = 0
	self._last_pos = None
	log.info('Mouse created')
]:
	i: 
	o: 81()

nname: 167
n 167(None)[return None
]:
	i: 0()
	o: 

nname: 0
n 0(None)[threading.Thread.__init__(self)
try:
	self.mouse = Mouse(dev='/dev/input/mice')
	self._last_event = None
	self._last_ts = 0
	self._last_pos = None
	log.info('Mouse created')
except:
	log.error('Cannot open mouse')
	del self.mouse
else:
	self.kbmap_get = DIRECTFB_MAP.get
	self.setDaemon(True)
	self.setName('MousePlugin')
	Task(self.start).start(1.0)
]:
	i: 
	o: 167()

nname: 0
n 0(None)[threading.Thread.__init__(self)
try:
	self.mouse = Mouse(dev='/dev/input/mice')
	self._last_event = None
	self._last_ts = 0
	self._last_pos = None
	log.info('Mouse created')
except:
	log.error('Cannot open mouse')
	del self.mouse
else:
	self.kbmap_get = DIRECTFB_MAP.get
	self.setDaemon(True)
	self.setName('MousePlugin')
	Task(self.start).start(1.0)
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7582fcc>}
nname: 231
n 231(None)[log.debug('%s %s %s', vec, event, count)
return (event, count)
]:
	i: 144(JA), 210(), 230()
	o: 

nname: 230
n 230(None)[]:
	i: 0&60(f)
	o: 231()

nname: 210
n 210(None)[event = self.kbmap_get('CURSOR_UP')
count = abs_vec[1] / move_threshold
]:
	i: 181(), 197()
	o: 231()

nname: 197
n 197(None)[]:
	i: 164(f)
	o: 210()

nname: 181
n 181(None)[]:
	i: 164(t)
	o: 210()

nname: 164
n 164(vec[1] > 0)[]:
	i: 77(f)
	o: 181(t), 197(f)

nname: 144
n 144(None)[event = self.kbmap_get('CURSOR_LEFT')
count = abs_vec[0] / move_threshold
]:
	i: 115(), 131()
	o: 231(JA)

nname: 131
n 131(None)[]:
	i: 98(f)
	o: 144()

nname: 115
n 115(None)[]:
	i: 98(t)
	o: 144()

nname: 98
n 98(vec[0] > 0)[]:
	i: 77(t)
	o: 115(t), 131(f)

nname: 77
n 77(abs_vec[0] > abs_vec[1])[]:
	i: 0&60(t)
	o: 98(t), 164(f)

nname: 0&60
n 0&60(abs_vec[0] > move_threshold or abs_vec[1] > move_threshold)[event = None
count = 1
abs_vec = (abs(vec[0]), abs(vec[1]))
]:
	i: 
	o: 77(t), 230(f)

nname: 231
n 231(None)[log.debug('%s %s %s', vec, event, count)
return (event, count)
]:
	i: 98(JA), 164(), 0&60(f)
	o: 

nname: 164
n 164(None)[if vec[1] > 0:
	pass
event = self.kbmap_get('CURSOR_UP')
count = abs_vec[1] / move_threshold
]:
	i: 77(f)
	o: 231()

nname: 98
n 98(None)[if vec[0] > 0:
	pass
event = self.kbmap_get('CURSOR_LEFT')
count = abs_vec[0] / move_threshold
]:
	i: 77(t)
	o: 231(JA)

nname: 77
n 77(abs_vec[0] > abs_vec[1])[]:
	i: 0&60(t)
	o: 98(t), 164(f)

nname: 0&60
n 0&60(abs_vec[0] > move_threshold or abs_vec[1] > move_threshold)[event = None
count = 1
abs_vec = (abs(vec[0]), abs(vec[1]))
]:
	i: 
	o: 77(t), 231(f)

nname: 0&60
n 0&60(None)[event = None
count = 1
abs_vec = (abs(vec[0]), abs(vec[1]))
if abs_vec[0] > move_threshold or abs_vec[1] > move_threshold:
	if abs_vec[0] > abs_vec[1]:
		if vec[0] > 0:
			pass
		event = self.kbmap_get('CURSOR_LEFT')
		count = abs_vec[0] / move_threshold
	else:
		if vec[1] > 0:
			pass
		event = self.kbmap_get('CURSOR_UP')
		count = abs_vec[1] / move_threshold
log.debug('%s %s %s', vec, event, count)
return (event, count)
]:
	i: 
	o: 

self.nodes: {'0&60': <unpyclib.structure.node instance at 0xb75883ac>}
nname: 371
n 371(None)[return (event, count)
]:
	i: 347(JA), 366(), 370()
	o: 

nname: 370
n 370(None)[]:
	i: 320(t)
	o: 371()

nname: 366
n 366(None)[]:
	i: 326(f)
	o: 371()

nname: 347
n 347(None)[event = self.kbmap_get('ENTER')
]:
	i: 326(t)
	o: 371(JA)

nname: 326
n 326(self.mouse.buttons['middle']['press'])[]:
	i: 320(f)
	o: 347(t), 366(f)

nname: 320
n 320(event)[]:
	i: 46(), 302(JA), 316(), 319()
	o: 326(f), 370(t)

nname: 319
n 319(None)[]:
	i: 123&130(f)
	o: 320()

nname: 316
n 316(None)[]:
	i: 271(JA), 306()
	o: 320()

nname: 306
n 306(None)[self._last_pos = None
]:
	i: 141(t)
	o: 316()

nname: 302
n 302(None)[]:
	i: 198(f)
	o: 320(JA)

nname: 271
n 271(None)[self._last_pos = [self.mouse.dx, self.mouse.dy]
]:
	i: 198(t)
	o: 316(JA)

nname: 198
n 198(event)[vec = [self.mouse.dx - self._last_pos[0], self.mouse.dy - self._last_pos[1]]
event, count = self._get_move_event(vec)
]:
	i: 162(), 197()
	o: 271(t), 302(f)

nname: 197
n 197(None)[]:
	i: 152(t)
	o: 198()

nname: 162
n 162(None)[self._last_pos = [but['start'][0], but['start'][1]]
]:
	i: 152(f)
	o: 198()

nname: 152
n 152(self._last_pos)[]:
	i: 141(f)
	o: 162(f), 197(t)

nname: 141
n 141(but['stop'])[]:
	i: 123&130(t)
	o: 152(f), 306(t)

nname: 123&130
n 123&130(move_on_start and but['start'])[]:
	i: 0&35(f)
	o: 141(t), 319(f)

nname: 46
n 46(None)[vec = [but['stop'][0] - but['start'][0], but['stop'][1] - but['start'][1]]
event, count = self._get_move_event(vec)
]:
	i: 0&35(t)
	o: 320()

nname: 0&35
n 0&35(not move_on_start and but['stop'])[event = None
count = 1
but = self.mouse.buttons['left']
]:
	i: 
	o: 46(t), 123&130(f)

nname: 320
n 320(None)[if not event:
	if self.mouse.buttons['middle']['press']:
		event = self.kbmap_get('ENTER')
return (event, count)
]:
	i: 46(), 152(f), 271(JA), 306(), 123&130(f)
	o: 

nname: 306
n 306(None)[self._last_pos = None
]:
	i: 141(t)
	o: 320()

nname: 271
n 271(None)[self._last_pos = [self.mouse.dx, self.mouse.dy]
]:
	i: 152(t)
	o: 320(JA)

nname: 152
n 152(event)[if not self._last_pos:
	self._last_pos = [but['start'][0], but['start'][1]]
vec = [self.mouse.dx - self._last_pos[0], self.mouse.dy - self._last_pos[1]]
event, count = self._get_move_event(vec)
]:
	i: 141(f)
	o: 271(t), 320(f)

nname: 141
n 141(but['stop'])[]:
	i: 123&130(t)
	o: 152(f), 306(t)

nname: 123&130
n 123&130(move_on_start and but['start'])[]:
	i: 0&35(f)
	o: 141(t), 320(f)

nname: 46
n 46(None)[vec = [but['stop'][0] - but['start'][0], but['stop'][1] - but['start'][1]]
event, count = self._get_move_event(vec)
]:
	i: 0&35(t)
	o: 320()

nname: 0&35
n 0&35(not move_on_start and but['stop'])[event = None
count = 1
but = self.mouse.buttons['left']
]:
	i: 
	o: 46(t), 123&130(f)

nname: 0&35
n 0&35(None)[event = None
count = 1
but = self.mouse.buttons['left']
if not move_on_start and but['stop']:
	vec = [but['stop'][0] - but['start'][0], but['stop'][1] - but['start'][1]]
	event, count = self._get_move_event(vec)
else:
	if move_on_start and but['start']:
		if not but['stop']:
			if not self._last_pos:
				self._last_pos = [but['start'][0], but['start'][1]]
			vec = [self.mouse.dx - self._last_pos[0], self.mouse.dy - self._last_pos[1]]
			event, count = self._get_move_event(vec)
			if event:
				self._last_pos = [self.mouse.dx, self.mouse.dy]
		else:
			self._last_pos = None
if not event:
	if self.mouse.buttons['middle']['press']:
		event = self.kbmap_get('ENTER')
return (event, count)
]:
	i: 
	o: 

self.nodes: {'0&35': <unpyclib.structure.node instance at 0xb7588ccc>}
nname: 253
n 253(None)[return None
]:
	i: 0(AL), 251()
	o: 

nname: 251
n 251(None)[]:
	i: 16(f), 248()
	o: 253()

nname: 248
n 248(None)[]:
	i: 246(AE)
	o: 251()

nname: 246
n 246(None)[]:
	i: 211(f), 221()
	o: 248(AE)

nname: 221
n 221(None)[#, e
log.error('Error while calling Mouse.get(): %s', e)
continue
]:
	i: 211(t)
	o: 246()

nname: 211
n 211(<dummy_ex3> EXC_MATCH Exception)[]:
	i: 22(except), 207()
	o: 221(t), 246(f)

nname: 207
n 207(None)[continue
]:
	i: 182(JA), 203(), 206()
	o: 211()

nname: 206
n 206(None)[]:
	i: 26(f)
	o: 207()

nname: 203
n 203(None)[]:
	i: 128(JA), 202()
	o: 207()

nname: 202
n 202(None)[]:
	i: 71(f)
	o: 203()

nname: 182
n 182(None)[log.debug('DROP %s', event)
]:
	i: 77&93&109(f)
	o: 207(JA)

nname: 128
n 128(None)[ts = time() + 0.20000000000000001
event.post(dict(count=count, timeout=ts))
self._last_ts = ts
]:
	i: 77&93&109(t)
	o: 203(JA)

nname: 77&93&109
n 77&93&109(self._last_event is None or event != self._last_event or time() > self._last_ts)[]:
	i: 71(t)
	o: 128(t), 182(f)

nname: 71
n 71(event)[]:
	i: 66(), 70()
	o: 77&93&109(t), 202(f)

nname: 70
n 70(None)[]:
	i: 41(t)
	o: 71()

nname: 66
n 66(None)[]:
	i: 41(f)
	o: 71()

nname: 41
n 41(event)[event, count = self._get_event()
]:
	i: 26(t)
	o: 66(f), 70(t)

nname: 26
n 26(self.mouse.get())[]:
	i: 22(try)
	o: 41(t), 206(f)

nname: 22
n 22(None)[]:
	i: 16(t)
	o: 26(try), 211(except)

nname: 16
n 16(True)[]:
	i: 0(loop)
	o: 22(t), 251(f)

nname: 0
n 0(None)[log.debug('start')
]:
	i: 
	o: 16(loop), 253(AL)

nname: 253
n 253(None)[return None
]:
	i: 0(AL), 16(f), 211(AE)
	o: 

nname: 211
n 211(None)[except Exception, e:
	log.error('Error while calling Mouse.get(): %s', e)
	continue
]:
	i: 207(), 22()
	o: 253(AE)

nname: 207
n 207(None)[continue
]:
	i: 182(JA), 128(JA), 41(f), 22(f)
	o: 211()

nname: 182
n 182(None)[log.debug('DROP %s', event)
]:
	i: 77&93&109(f)
	o: 207(JA)

nname: 128
n 128(None)[ts = time() + 0.20000000000000001
event.post(dict(count=count, timeout=ts))
self._last_ts = ts
]:
	i: 77&93&109(t)
	o: 207(JA)

nname: 77&93&109
n 77&93&109(self._last_event is None or event != self._last_event or time() > self._last_ts)[]:
	i: 41(t)
	o: 128(t), 182(f)

nname: 41
n 41(event)[event, count = self._get_event()
if not event:
	pass
]:
	i: 22(t)
	o: 77&93&109(t), 207(f)

nname: 22
n 22(self.mouse.get())[try:
	pass
]:
	i: 16(t)
	o: 41(t), 207(f), 211()

nname: 16
n 16(True)[]:
	i: 0(loop)
	o: 22(t), 253(f)

nname: 0
n 0(None)[log.debug('start')
]:
	i: 
	o: 16(loop), 253(AL)

nname: 253
n 253(None)[return None
]:
	i: 0(AL), 16(f), 211(AE)
	o: 

nname: 211
n 211(None)[except Exception, e:
	log.error('Error while calling Mouse.get(): %s', e)
	continue
]:
	i: 22()
	o: 253(AE)

nname: 22
n 22(None)[try:
	pass
if self.mouse.get():
	event, count = self._get_event()
	if not event:
		pass
	if event:
		if self._last_event is None or event != self._last_event or time() > self._last_ts:
			ts = time() + 0.20000000000000001
			event.post(dict(count=count, timeout=ts))
			self._last_ts = ts
		else:
			log.debug('DROP %s', event)
continue
]:
	i: 16(t)
	o: 211()

nname: 16
n 16(True)[]:
	i: 0(loop)
	o: 22(t), 253(f)

nname: 0
n 0(None)[log.debug('start')
]:
	i: 
	o: 16(loop), 253(AL)

nname: 253
n 253(None)[return None
]:
	i: 0(AL), 16(f), 22(AE)
	o: 

nname: 22
n 22(None)[try:
	pass
if self.mouse.get():
	event, count = self._get_event()
	if not event:
		pass
	if event:
		if self._last_event is None or event != self._last_event or time() > self._last_ts:
			ts = time() + 0.20000000000000001
			event.post(dict(count=count, timeout=ts))
			self._last_ts = ts
		else:
			log.debug('DROP %s', event)
continue
except Exception, e:
	log.error('Error while calling Mouse.get(): %s', e)
	continue
]:
	i: 16(t)
	o: 253(AE)

nname: 16
n 16(True)[]:
	i: 0(loop)
	o: 22(t), 253(f)

nname: 0
n 0(None)[log.debug('start')
]:
	i: 
	o: 16(loop), 253(AL)

nname: 253
n 253(None)[return None
]:
	i: 22(AE)
	o: 

nname: 22
n 22(None)[	try:
		pass
	if self.mouse.get():
		event, count = self._get_event()
		if not event:
			pass
		if event:
			if self._last_event is None or event != self._last_event or time() > self._last_ts:
				ts = time() + 0.20000000000000001
				event.post(dict(count=count, timeout=ts))
				self._last_ts = ts
			else:
				log.debug('DROP %s', event)
	continue
	except Exception, e:
		log.error('Error while calling Mouse.get(): %s', e)
		continue
]:
	i: 0(t)
	o: 253(AE)

nname: 0
n 0(True)[log.debug('start')
while True:
]:
	i: 
	o: 22(t)

nname: 253
n 253(None)[return None
]:
	i: 0(AE)
	o: 

nname: 0
n 0(None)[log.debug('start')
while True:
	try:
		pass
	if self.mouse.get():
		event, count = self._get_event()
		if not event:
			pass
		if event:
			if self._last_event is None or event != self._last_event or time() > self._last_ts:
				ts = time() + 0.20000000000000001
				event.post(dict(count=count, timeout=ts))
				self._last_ts = ts
			else:
				log.debug('DROP %s', event)
	continue
	except Exception, e:
		log.error('Error while calling Mouse.get(): %s', e)
		continue
]:
	i: 
	o: 253(AE)

self.nodes: {0: <unpyclib.structure.node instance at 0xb7591cec>, 253: <unpyclib.structure.node instance at 0xb75887ac>}
nname: 6
n 6(None)[__doc__ = '\n    Plugin for tablet control.\n    '
def __init__(self, *args):
	threading.Thread.__init__(self)
	try:
		self.mouse = Mouse(dev='/dev/input/mice')
		self._last_event = None
		self._last_ts = 0
		self._last_pos = None
		log.info('Mouse created')
	except:
		log.error('Cannot open mouse')
		del self.mouse
	else:
		self.kbmap_get = DIRECTFB_MAP.get
		self.setDaemon(True)
		self.setName('MousePlugin')
		Task(self.start).start(1.0)
	return None

def _get_move_event(self, vec):
	event = None
	count = 1
	abs_vec = (abs(vec[0]), abs(vec[1]))
	if abs_vec[0] > move_threshold or abs_vec[1] > move_threshold:
		if abs_vec[0] > abs_vec[1]:
			if vec[0] > 0:
				pass
			event = self.kbmap_get('CURSOR_LEFT')
			count = abs_vec[0] / move_threshold
		else:
			if vec[1] > 0:
				pass
			event = self.kbmap_get('CURSOR_UP')
			count = abs_vec[1] / move_threshold
	log.debug('%s %s %s', vec, event, count)
	return (event, count)

def _get_event(self):
	event = None
	count = 1
	but = self.mouse.buttons['left']
	if not move_on_start and but['stop']:
		vec = [but['stop'][0] - but['start'][0], but['stop'][1] - but['start'][1]]
		event, count = self._get_move_event(vec)
	else:
		if move_on_start and but['start']:
			if not but['stop']:
				if not self._last_pos:
					self._last_pos = [but['start'][0], but['start'][1]]
				vec = [self.mouse.dx - self._last_pos[0], self.mouse.dy - self._last_pos[1]]
				event, count = self._get_move_event(vec)
				if event:
					self._last_pos = [self.mouse.dx, self.mouse.dy]
			else:
				self._last_pos = None
	if not event:
		if self.mouse.buttons['middle']['press']:
			event = self.kbmap_get('ENTER')
	return (event, count)

def run(self):
	log.debug('start')
	while True:
		try:
			pass
		if self.mouse.get():
			event, count = self._get_event()
			if not event:
				pass
			if event:
				if self._last_event is None or event != self._last_event or time() > self._last_ts:
					ts = time() + 0.20000000000000001
					event.post(dict(count=count, timeout=ts))
					self._last_ts = ts
				else:
					log.debug('DROP %s', event)
		continue
		except Exception, e:
			log.error('Error while calling Mouse.get(): %s', e)
			continue

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75821ac>}
nname: 0
n 0(None)[from __future__ import absolute_import
from peewee.notifier import Task
from peewee.gettime import time
from peewee.debug import GET_LOGGER
from Queue import Full
from pygui.input import DIRECTFB_MAP
from pygui.facilities.mouse import Mouse
from time import sleep
import threading
log = GET_LOGGER(__name__)
move_threshold = 20
move_on_start = True
class PluginInterface(.):
	__doc__ = '\n    Plugin for tablet control.\n    '
	def __init__(self, *args):
		threading.Thread.__init__(self)
		try:
			self.mouse = Mouse(dev='/dev/input/mice')
			self._last_event = None
			self._last_ts = 0
			self._last_pos = None
			log.info('Mouse created')
		except:
			log.error('Cannot open mouse')
			del self.mouse
		else:
			self.kbmap_get = DIRECTFB_MAP.get
			self.setDaemon(True)
			self.setName('MousePlugin')
			Task(self.start).start(1.0)
		return None

	def _get_move_event(self, vec):
		event = None
		count = 1
		abs_vec = (abs(vec[0]), abs(vec[1]))
		if abs_vec[0] > move_threshold or abs_vec[1] > move_threshold:
			if abs_vec[0] > abs_vec[1]:
				if vec[0] > 0:
					pass
				event = self.kbmap_get('CURSOR_LEFT')
				count = abs_vec[0] / move_threshold
			else:
				if vec[1] > 0:
					pass
				event = self.kbmap_get('CURSOR_UP')
				count = abs_vec[1] / move_threshold
		log.debug('%s %s %s', vec, event, count)
		return (event, count)

	def _get_event(self):
		event = None
		count = 1
		but = self.mouse.buttons['left']
		if not move_on_start and but['stop']:
			vec = [but['stop'][0] - but['start'][0], but['stop'][1] - but['start'][1]]
			event, count = self._get_move_event(vec)
		else:
			if move_on_start and but['start']:
				if not but['stop']:
					if not self._last_pos:
						self._last_pos = [but['start'][0], but['start'][1]]
					vec = [self.mouse.dx - self._last_pos[0], self.mouse.dy - self._last_pos[1]]
					event, count = self._get_move_event(vec)
					if event:
						self._last_pos = [self.mouse.dx, self.mouse.dy]
				else:
					self._last_pos = None
		if not event:
			if self.mouse.buttons['middle']['press']:
				event = self.kbmap_get('ENTER')
		return (event, count)

	def run(self):
		log.debug('start')
		while True:
			try:
				pass
			if self.mouse.get():
				event, count = self._get_event()
				if not event:
					pass
				if event:
					if self._last_event is None or event != self._last_event or time() > self._last_ts:
						ts = time() + 0.20000000000000001
						event.post(dict(count=count, timeout=ts))
						self._last_ts = ts
					else:
						log.debug('DROP %s', event)
			continue
			except Exception, e:
				log.error('Error while calling Mouse.get(): %s', e)
				continue



]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7576fec>}
from __future__ import absolute_import
from peewee.notifier import Task
from peewee.gettime import time
from peewee.debug import GET_LOGGER
from Queue import Full
from pygui.input import DIRECTFB_MAP
from pygui.facilities.mouse import Mouse
from time import sleep
import threading
log = GET_LOGGER(__name__)
move_threshold = 20
move_on_start = True
class PluginInterface(.):
	__doc__ = '\n    Plugin for tablet control.\n    '
	def __init__(self, *args):
		threading.Thread.__init__(self)
		try:
			self.mouse = Mouse(dev='/dev/input/mice')
			self._last_event = None
			self._last_ts = 0
			self._last_pos = None
			log.info('Mouse created')
		except:
			log.error('Cannot open mouse')
			del self.mouse
		else:
			self.kbmap_get = DIRECTFB_MAP.get
			self.setDaemon(True)
			self.setName('MousePlugin')
			Task(self.start).start(1.0)
		return None

	def _get_move_event(self, vec):
		event = None
		count = 1
		abs_vec = (abs(vec[0]), abs(vec[1]))
		if abs_vec[0] > move_threshold or abs_vec[1] > move_threshold:
			if abs_vec[0] > abs_vec[1]:
				if vec[0] > 0:
					pass
				event = self.kbmap_get('CURSOR_LEFT')
				count = abs_vec[0] / move_threshold
			else:
				if vec[1] > 0:
					pass
				event = self.kbmap_get('CURSOR_UP')
				count = abs_vec[1] / move_threshold
		log.debug('%s %s %s', vec, event, count)
		return (event, count)

	def _get_event(self):
		event = None
		count = 1
		but = self.mouse.buttons['left']
		if not move_on_start and but['stop']:
			vec = [but['stop'][0] - but['start'][0], but['stop'][1] - but['start'][1]]
			event, count = self._get_move_event(vec)
		else:
			if move_on_start and but['start']:
				if not but['stop']:
					if not self._last_pos:
						self._last_pos = [but['start'][0], but['start'][1]]
					vec = [self.mouse.dx - self._last_pos[0], self.mouse.dy - self._last_pos[1]]
					event, count = self._get_move_event(vec)
					if event:
						self._last_pos = [self.mouse.dx, self.mouse.dy]
				else:
					self._last_pos = None
		if not event:
			if self.mouse.buttons['middle']['press']:
				event = self.kbmap_get('ENTER')
		return (event, count)

	def run(self):
		log.debug('start')
		while True:
			try:
				pass
			if self.mouse.get():
				event, count = self._get_event()
				if not event:
					pass
				if event:
					if self._last_event is None or event != self._last_event or time() > self._last_ts:
						ts = time() + 0.20000000000000001
						event.post(dict(count=count, timeout=ts))
						self._last_ts = ts
					else:
						log.debug('DROP %s', event)
			continue
			except Exception, e:
				log.error('Error while calling Mouse.get(): %s', e)
				continue



