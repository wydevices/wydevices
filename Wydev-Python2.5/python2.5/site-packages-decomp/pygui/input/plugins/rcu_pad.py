# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 220
n 220(None)[return None
]:
	i: 132(), 172()
	o: 

nname: 172
n 172(None)[self.setDaemon(True)
self.setName('RcuPadPlugin')
Task(self.start).start(1.0)
]:
	i: 32(), 170(AE)
	o: 220()

nname: 170
n 170(None)[]:
	i: 122(f)
	o: 172(AE)

nname: 132
n 132(None)[#, e
log.error('Cannot open RcuPad')
PRINT_EXCEPTION(e)
del self.rcu
]:
	i: 122(t)
	o: 220()

nname: 122
n 122(<dummy_ex3> EXC_MATCH Exception)[]:
	i: 0(except)
	o: 132(t), 170(f)

nname: 32
n 32(None)[self.rcu = RcuPad(dev='/dev/ir0')
log.info('rcu = %s', self.rcu)
self._last_event = None
self._last_ts = 0
self._last_pos = None
self._poll_interval = 0.02
log.info('RcuPad created')
]:
	i: 0(try)
	o: 172()

nname: 0
n 0(None)[log.debug('init')
threading.Thread.__init__(self)
]:
	i: 
	o: 32(try), 122(except)

nname: 220
n 220(None)[return None
]:
	i: 132(), 172(), 122(f)
	o: 

nname: 132
n 132(None)[#, e
log.error('Cannot open RcuPad')
PRINT_EXCEPTION(e)
del self.rcu
]:
	i: 122(t)
	o: 220()

nname: 122
n 122(<dummy_ex3> EXC_MATCH Exception)[]:
	i: 0(except)
	o: 132(t), 220(f)

nname: 172
n 172(None)[self.setDaemon(True)
self.setName('RcuPadPlugin')
Task(self.start).start(1.0)
]:
	i: 32(), 170(AE)
	o: 220()

nname: 32
n 32(None)[self.rcu = RcuPad(dev='/dev/ir0')
log.info('rcu = %s', self.rcu)
self._last_event = None
self._last_ts = 0
self._last_pos = None
self._poll_interval = 0.02
log.info('RcuPad created')
]:
	i: 0(try)
	o: 172()

nname: 0
n 0(None)[log.debug('init')
threading.Thread.__init__(self)
]:
	i: 
	o: 32(try), 122(except)

nname: 220
n 220(None)[return None
]:
	i: 122()
	o: 

nname: 122
n 122(None)[except Exception, e:
	log.error('Cannot open RcuPad')
	PRINT_EXCEPTION(e)
	del self.rcu
else:
	self.setDaemon(True)
	self.setName('RcuPadPlugin')
	Task(self.start).start(1.0)
]:
	i: 0()
	o: 220()

nname: 0
n 0(None)[log.debug('init')
threading.Thread.__init__(self)
try:
	self.rcu = RcuPad(dev='/dev/ir0')
	log.info('rcu = %s', self.rcu)
	self._last_event = None
	self._last_ts = 0
	self._last_pos = None
	self._poll_interval = 0.02
	log.info('RcuPad created')
]:
	i: 
	o: 122()

nname: 220
n 220(None)[return None
]:
	i: 0()
	o: 

nname: 0
n 0(None)[log.debug('init')
threading.Thread.__init__(self)
try:
	self.rcu = RcuPad(dev='/dev/ir0')
	log.info('rcu = %s', self.rcu)
	self._last_event = None
	self._last_ts = 0
	self._last_pos = None
	self._poll_interval = 0.02
	log.info('RcuPad created')
except Exception, e:
	log.error('Cannot open RcuPad')
	PRINT_EXCEPTION(e)
	del self.rcu
else:
	self.setDaemon(True)
	self.setName('RcuPadPlugin')
	Task(self.start).start(1.0)
]:
	i: 
	o: 220()

nname: 0
n 0(None)[log.debug('init')
threading.Thread.__init__(self)
try:
	self.rcu = RcuPad(dev='/dev/ir0')
	log.info('rcu = %s', self.rcu)
	self._last_event = None
	self._last_ts = 0
	self._last_pos = None
	self._poll_interval = 0.02
	log.info('RcuPad created')
except Exception, e:
	log.error('Cannot open RcuPad')
	PRINT_EXCEPTION(e)
	del self.rcu
else:
	self.setDaemon(True)
	self.setName('RcuPadPlugin')
	Task(self.start).start(1.0)
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb758bfcc>}
nname: 41
n 41(None)[]:
	i: 28(), 40()
	o: 

nname: 40
n 40(None)[]:
	i: 0(f)
	o: 41()

nname: 28
n 28(None)[print self.rcu
]:
	i: 0(t)
	o: 41()

nname: 0
n 0(self.rcu.get_struct())[log.info('get_infos !!')
]:
	i: 
	o: 28(t), 40(f)

nname: 0
n 0(None)[log.info('get_infos !!')
if self.rcu.get_struct():
	print self.rcu
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb758b46c>}
nname: 365
n 365(None)[return None
]:
	i: 240(JA), 312(), 315()
	o: 

nname: 315
n 315(None)[event.MOUSE.post(dict(x=rcu.dx, y=rcu.dy, timeout=None, clicked=None))
]:
	i: 0(f)
	o: 365()

nname: 312
n 312(None)[]:
	i: 79(JA), 123(JA), 167(JA), 211(JA), 244()
	o: 365()

nname: 244
n 244(None)[but = buttons[0]
event.BUTTON0.post(dict(x=rcu.dx, y=rcu.dy, start_x=but['start_x'], start_y=but['start_y']))
]:
	i: 32&48(f)
	o: 312()

nname: 240
n 240(None)[]:
	i: 196(f)
	o: 365(JA)

nname: 211
n 211(None)[event.BUTTON4.post(dict(timeout=None))
]:
	i: 196(t)
	o: 312(JA)

nname: 196
n 196(buttons[4]['press'])[]:
	i: 152(f)
	o: 211(t), 240(f)

nname: 167
n 167(None)[event.BUTTON3.post(dict(timeout=None))
]:
	i: 152(t)
	o: 312(JA)

nname: 152
n 152(buttons[3]['press'])[]:
	i: 108(f)
	o: 167(t), 196(f)

nname: 123
n 123(None)[event.BUTTON2.post(dict(timeout=None))
]:
	i: 108(t)
	o: 312(JA)

nname: 108
n 108(buttons[2]['press'])[]:
	i: 64(f)
	o: 123(t), 152(f)

nname: 79
n 79(None)[event.BUTTON1.post(dict(timeout=None))
]:
	i: 64(t)
	o: 312(JA)

nname: 64
n 64(buttons[1]['press'])[]:
	i: 32&48(t)
	o: 79(t), 108(f)

nname: 32&48
n 32&48(rcu.dx == 127 or rcu.dy == 127)[]:
	i: 0(t)
	o: 64(t), 244(f)

nname: 0
n 0(buttons[0]['press'])[rcu = self.rcu
buttons = rcu.buttons
]:
	i: 
	o: 32&48(t), 315(f)

nname: 365
n 365(None)[return None
]:
	i: 315(), 196(f), 79(JA), 123(JA), 167(JA), 211(JA), 244()
	o: 

nname: 315
n 315(None)[event.MOUSE.post(dict(x=rcu.dx, y=rcu.dy, timeout=None, clicked=None))
]:
	i: 0(f)
	o: 365()

nname: 244
n 244(None)[but = buttons[0]
event.BUTTON0.post(dict(x=rcu.dx, y=rcu.dy, start_x=but['start_x'], start_y=but['start_y']))
]:
	i: 32&48(f)
	o: 365()

nname: 211
n 211(None)[event.BUTTON4.post(dict(timeout=None))
]:
	i: 196(t)
	o: 365(JA)

nname: 196
n 196(buttons[4]['press'])[]:
	i: 152(f)
	o: 211(t), 365(f)

nname: 167
n 167(None)[event.BUTTON3.post(dict(timeout=None))
]:
	i: 152(t)
	o: 365(JA)

nname: 152
n 152(buttons[3]['press'])[]:
	i: 108(f)
	o: 167(t), 196(f)

nname: 123
n 123(None)[event.BUTTON2.post(dict(timeout=None))
]:
	i: 108(t)
	o: 365(JA)

nname: 108
n 108(buttons[2]['press'])[]:
	i: 64(f)
	o: 123(t), 152(f)

nname: 79
n 79(None)[event.BUTTON1.post(dict(timeout=None))
]:
	i: 64(t)
	o: 365(JA)

nname: 64
n 64(buttons[1]['press'])[]:
	i: 32&48(t)
	o: 79(t), 108(f)

nname: 32&48
n 32&48(rcu.dx == 127 or rcu.dy == 127)[]:
	i: 0(t)
	o: 64(t), 244(f)

nname: 0
n 0(buttons[0]['press'])[rcu = self.rcu
buttons = rcu.buttons
]:
	i: 
	o: 32&48(t), 315(f)

nname: 0
n 0(None)[rcu = self.rcu
buttons = rcu.buttons
if buttons[0]['press']:
	if rcu.dx == 127 or rcu.dy == 127:
		if buttons[1]['press']:
			event.BUTTON1.post(dict(timeout=None))
		else:
			if buttons[2]['press']:
				event.BUTTON2.post(dict(timeout=None))
			else:
				if buttons[3]['press']:
					event.BUTTON3.post(dict(timeout=None))
				else:
					if buttons[4]['press']:
						event.BUTTON4.post(dict(timeout=None))
	else:
		but = buttons[0]
		event.BUTTON0.post(dict(x=rcu.dx, y=rcu.dy, start_x=but['start_x'], start_y=but['start_y']))
else:
	event.MOUSE.post(dict(x=rcu.dx, y=rcu.dy, timeout=None, clicked=None))
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75a4e6c>}
nname: 123
n 123(None)[]:
	i: 0(AL), 121()
	o: 

nname: 121
n 121(None)[]:
	i: 16(f), 118()
	o: 123()

nname: 118
n 118(None)[]:
	i: 104(AE)
	o: 121()

nname: 104
n 104(None)[sleep(self._poll_interval)
]:
	i: 22(finally), 100()
	o: 118(AE)

nname: 100
n 100(None)[]:
	i: 59(), 73(), 98(AE)
	o: 104()

nname: 98
n 98(None)[]:
	i: 63(f)
	o: 100(AE)

nname: 73
n 73(None)[#, e
log.error('Error while calling RcuPad.get_struct(): %s', e)
]:
	i: 63(t)
	o: 100()

nname: 63
n 63(<dummy_ex3> EXC_MATCH Exception)[]:
	i: 26(except)
	o: 73(t), 98(f)

nname: 59
n 59(None)[]:
	i: 44(), 58()
	o: 100()

nname: 58
n 58(None)[]:
	i: 29(f)
	o: 59()

nname: 44
n 44(None)[self.post()
]:
	i: 29(t)
	o: 59()

nname: 29
n 29(self.rcu.get_struct())[]:
	i: 26(try)
	o: 44(t), 58(f)

nname: 26
n 26(None)[]:
	i: 22(ASF)
	o: 29(try), 63(except)

nname: 22
n 22(None)[]:
	i: 16(t)
	o: 26(ASF2), 104(finally)

nname: 16
n 16(True)[]:
	i: 0(loop)
	o: 22(t), 121(f)

nname: 0
n 0(None)[log.debug('start')
]:
	i: 
	o: 16(loop), 123(AL)

nname: 123
n 123(None)[]:
	i: 0(AL), 16(f), 104(AE)
	o: 

nname: 104
n 104(None)[sleep(self._poll_interval)
]:
	i: 22(finally), 63(), 26()
	o: 123(AE)

nname: 63
n 63(None)[except Exception, e:
	log.error('Error while calling RcuPad.get_struct(): %s', e)
]:
	i: 26()
	o: 104()

nname: 26
n 26(None)[try:
	if self.rcu.get_struct():
		self.post()
]:
	i: 22(ASF2)
	o: 104(), 63()

nname: 22
n 22(None)[]:
	i: 16(t)
	o: 26(ASF2), 104(finally)

nname: 16
n 16(True)[]:
	i: 0(loop)
	o: 22(t), 123(f)

nname: 0
n 0(None)[log.debug('start')
]:
	i: 
	o: 16(loop), 123(AL)

self.nodes: {0: <unpyclib.structure.node instance at 0xb758b74c>, 123: <unpyclib.structure.node instance at 0xb758bfcc>, 104: <unpyclib.structure.node instance at 0xb758bacc>, 16: <unpyclib.structure.node instance at 0xb758b76c>, 22: <unpyclib.structure.node instance at 0xb758b54c>, 26: <unpyclib.structure.node instance at 0xb758b08c>, 63: <unpyclib.structure.node instance at 0xb758b9ac>}
nname: 6
n 6(None)[__doc__ = '\n    Input plugin for sRCU on /dev/ir0\n    Warn: It does not use the standard linux input event interface, but it works !\n    '
def __init__(self, *args):
	log.debug('init')
	threading.Thread.__init__(self)
	try:
		self.rcu = RcuPad(dev='/dev/ir0')
		log.info('rcu = %s', self.rcu)
		self._last_event = None
		self._last_ts = 0
		self._last_pos = None
		self._poll_interval = 0.02
		log.info('RcuPad created')
	except Exception, e:
		log.error('Cannot open RcuPad')
		PRINT_EXCEPTION(e)
		del self.rcu
	else:
		self.setDaemon(True)
		self.setName('RcuPadPlugin')
		Task(self.start).start(1.0)
	return None

def descriptor_watch_callback(self):
	log.info('get_infos !!')
	if self.rcu.get_struct():
		print self.rcu

def post(self):
	rcu = self.rcu
	buttons = rcu.buttons
	if buttons[0]['press']:
		if rcu.dx == 127 or rcu.dy == 127:
			if buttons[1]['press']:
				event.BUTTON1.post(dict(timeout=None))
			else:
				if buttons[2]['press']:
					event.BUTTON2.post(dict(timeout=None))
				else:
					if buttons[3]['press']:
						event.BUTTON3.post(dict(timeout=None))
					else:
						if buttons[4]['press']:
							event.BUTTON4.post(dict(timeout=None))
		else:
			but = buttons[0]
			event.BUTTON0.post(dict(x=rcu.dx, y=rcu.dy, start_x=but['start_x'], start_y=but['start_y']))
	else:
		event.MOUSE.post(dict(x=rcu.dx, y=rcu.dy, timeout=None, clicked=None))
	return None

def run(self):
	log.debug('start')

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb7584e4c>}
nname: 0
n 0(None)[from __future__ import absolute_import
from peewee.notifier import Task, descriptor_watch
from peewee.gettime import time
from peewee.debug import GET_LOGGER, PRINT_EXCEPTION
from pygui.facilities.rcu_pad import RcuPad
import pygui.config as config
import pygui.eventmanager.events as event
from time import sleep
import threading
log = GET_LOGGER(__name__)
class PluginInterface(.):
	__doc__ = '\n    Input plugin for sRCU on /dev/ir0\n    Warn: It does not use the standard linux input event interface, but it works !\n    '
	def __init__(self, *args):
		log.debug('init')
		threading.Thread.__init__(self)
		try:
			self.rcu = RcuPad(dev='/dev/ir0')
			log.info('rcu = %s', self.rcu)
			self._last_event = None
			self._last_ts = 0
			self._last_pos = None
			self._poll_interval = 0.02
			log.info('RcuPad created')
		except Exception, e:
			log.error('Cannot open RcuPad')
			PRINT_EXCEPTION(e)
			del self.rcu
		else:
			self.setDaemon(True)
			self.setName('RcuPadPlugin')
			Task(self.start).start(1.0)
		return None

	def descriptor_watch_callback(self):
		log.info('get_infos !!')
		if self.rcu.get_struct():
			print self.rcu

	def post(self):
		rcu = self.rcu
		buttons = rcu.buttons
		if buttons[0]['press']:
			if rcu.dx == 127 or rcu.dy == 127:
				if buttons[1]['press']:
					event.BUTTON1.post(dict(timeout=None))
				else:
					if buttons[2]['press']:
						event.BUTTON2.post(dict(timeout=None))
					else:
						if buttons[3]['press']:
							event.BUTTON3.post(dict(timeout=None))
						else:
							if buttons[4]['press']:
								event.BUTTON4.post(dict(timeout=None))
			else:
				but = buttons[0]
				event.BUTTON0.post(dict(x=rcu.dx, y=rcu.dy, start_x=but['start_x'], start_y=but['start_y']))
		else:
			event.MOUSE.post(dict(x=rcu.dx, y=rcu.dy, timeout=None, clicked=None))
		return None

	def run(self):
		log.debug('start')



]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb757ed0c>}
from __future__ import absolute_import
from peewee.notifier import Task, descriptor_watch
from peewee.gettime import time
from peewee.debug import GET_LOGGER, PRINT_EXCEPTION
from pygui.facilities.rcu_pad import RcuPad
import pygui.config as config
import pygui.eventmanager.events as event
from time import sleep
import threading
log = GET_LOGGER(__name__)
class PluginInterface(.):
	__doc__ = '\n    Input plugin for sRCU on /dev/ir0\n    Warn: It does not use the standard linux input event interface, but it works !\n    '
	def __init__(self, *args):
		log.debug('init')
		threading.Thread.__init__(self)
		try:
			self.rcu = RcuPad(dev='/dev/ir0')
			log.info('rcu = %s', self.rcu)
			self._last_event = None
			self._last_ts = 0
			self._last_pos = None
			self._poll_interval = 0.02
			log.info('RcuPad created')
		except Exception, e:
			log.error('Cannot open RcuPad')
			PRINT_EXCEPTION(e)
			del self.rcu
		else:
			self.setDaemon(True)
			self.setName('RcuPadPlugin')
			Task(self.start).start(1.0)
		return None

	def descriptor_watch_callback(self):
		log.info('get_infos !!')
		if self.rcu.get_struct():
			print self.rcu

	def post(self):
		rcu = self.rcu
		buttons = rcu.buttons
		if buttons[0]['press']:
			if rcu.dx == 127 or rcu.dy == 127:
				if buttons[1]['press']:
					event.BUTTON1.post(dict(timeout=None))
				else:
					if buttons[2]['press']:
						event.BUTTON2.post(dict(timeout=None))
					else:
						if buttons[3]['press']:
							event.BUTTON3.post(dict(timeout=None))
						else:
							if buttons[4]['press']:
								event.BUTTON4.post(dict(timeout=None))
			else:
				but = buttons[0]
				event.BUTTON0.post(dict(x=rcu.dx, y=rcu.dy, start_x=but['start_x'], start_y=but['start_y']))
		else:
			event.MOUSE.post(dict(x=rcu.dx, y=rcu.dy, timeout=None, clicked=None))
		return None

	def run(self):
		log.debug('start')



