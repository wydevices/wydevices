# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 0
n 0(None)[Thread.__init__(self)
self.post_key = post_key
self.running = False
self.setDaemon(True)
self.setName('Network Remote')
Task(self.start).start(0.10000000000000001)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb770bc8c>}
nname: 386
n 386(None)[sock.close()
return None
]:
	i: 0(AL), 384()
	o: 

nname: 384
n 384(None)[]:
	i: 75(f), 355()
	o: 386()

nname: 355
n 355(None)[conn.close()
log.info('%s disconnected', addr)
]:
	i: 84(AL), 353()
	o: 384()

nname: 353
n 353(None)[]:
	i: 122(f), 350()
	o: 355()

nname: 350
n 350(None)[]:
	i: 348(AE)
	o: 353()

nname: 348
n 348(None)[]:
	i: 295(f), 305()
	o: 350(AE)

nname: 305
n 305(None)[conn.send('NOK' + '\r\n\r\n')
log.error('%s sent unknown command %r', addr, data)
continue
]:
	i: 295(t)
	o: 348()

nname: 295
n 295(<dummy_ex3> EXC_MATCH KeyError)[]:
	i: 239(except), 242()
	o: 305(t), 348(f)

nname: 242
n 242(None)[self.post_key(data)
conn.send('OK' + '\r\n\r\n')
log.debug('%s sent command %r', addr, data)
continue
]:
	i: 239(try)
	o: 295()

nname: 239
n 239(None)[]:
	i: 233(), 238()
	o: 242(try), 295(except)

nname: 238
n 238(None)[]:
	i: 221(f)
	o: 239()

nname: 233
n 233(None)[break
]:
	i: 221(t)
	o: 239()

nname: 221
n 221(data in ('DISCONNECT', '\x04'))[]:
	i: 213(), 220()
	o: 233(t), 238(f)

nname: 220
n 220(None)[]:
	i: 207(t)
	o: 221()

nname: 213
n 213(None)[continue
]:
	i: 207(f)
	o: 221()

nname: 207
n 207(data)[]:
	i: 132(), 176(), 205(AE)
	o: 213(f), 220(t)

nname: 205
n 205(None)[]:
	i: 163(f)
	o: 207(AE)

nname: 176
n 176(None)[#, e
log.error('Connection error %s to %s', e, addr)
break
]:
	i: 163(t)
	o: 207()

nname: 163
n 163(<dummy_ex3> EXC_MATCH socket.error)[]:
	i: 128(except)
	o: 176(t), 205(f)

nname: 132
n 132(None)[data = conn.recv(1024).strip().upper()
]:
	i: 128(try)
	o: 207()

nname: 128
n 128(None)[]:
	i: 122(t)
	o: 132(try), 163(except)

nname: 122
n 122(True)[]:
	i: 84(loop)
	o: 128(t), 353(f)

nname: 84
n 84(None)[conn, addr = sock.accept()
log.info('Network remote connected from %s', addr)
]:
	i: 75(t)
	o: 122(loop), 355(AL)

nname: 75
n 75(self.running)[]:
	i: 0(loop)
	o: 84(t), 384(f)

nname: 0
n 0(None)[self.running = True
sock = socket.socket()
sock.bind((self.HOST, self.PORT))
sock.listen(1)
sock.settimeout(None)
]:
	i: 
	o: 75(loop), 386(AL)

nname: 386
n 386(None)[sock.close()
return None
]:
	i: 0(AL), 75(f), 355()
	o: 

nname: 355
n 355(None)[conn.close()
log.info('%s disconnected', addr)
]:
	i: 84(AL), 122(f), 348(AE)
	o: 386()

nname: 348
n 348(None)[]:
	i: 242(f)
	o: 355(AE)

nname: 242
n 242(None)[try:
	self.post_key(data)
	conn.send('OK' + '\r\n\r\n')
	log.debug('%s sent command %r', addr, data)
	continue
except KeyError:
	conn.send('NOK' + '\r\n\r\n')
	log.error('%s sent unknown command %r', addr, data)
	continue
]:
	i: 221(try)
	o: 348()

nname: 221
n 221(None)[if data in ('DISCONNECT', '\x04'):
	break
]:
	i: 163()
	o: 242(try)

nname: 163
n 163(None)[except socket.error, e:
	log.error('Connection error %s to %s', e, addr)
	break
if not data:
	continue
]:
	i: 128()
	o: 221()

nname: 128
n 128(None)[try:
	data = conn.recv(1024).strip().upper()
]:
	i: 122(t)
	o: 163()

nname: 122
n 122(True)[]:
	i: 84(loop)
	o: 128(t), 355(f)

nname: 84
n 84(None)[conn, addr = sock.accept()
log.info('Network remote connected from %s', addr)
]:
	i: 75(t)
	o: 122(loop), 355(AL)

nname: 75
n 75(self.running)[]:
	i: 0(loop)
	o: 84(t), 386(f)

nname: 0
n 0(None)[self.running = True
sock = socket.socket()
sock.bind((self.HOST, self.PORT))
sock.listen(1)
sock.settimeout(None)
]:
	i: 
	o: 75(loop), 386(AL)

nname: 386
n 386(None)[sock.close()
return None
]:
	i: 0(AL), 75(f), 355()
	o: 

nname: 355
n 355(None)[conn.close()
log.info('%s disconnected', addr)
]:
	i: 84(AL), 122(f), 348(AE)
	o: 386()

nname: 348
n 348(None)[]:
	i: 221(f)
	o: 355(AE)

nname: 221
n 221(None)[if data in ('DISCONNECT', '\x04'):
	break
try:
	self.post_key(data)
	conn.send('OK' + '\r\n\r\n')
	log.debug('%s sent command %r', addr, data)
	continue
except KeyError:
	conn.send('NOK' + '\r\n\r\n')
	log.error('%s sent unknown command %r', addr, data)
	continue
]:
	i: 128()
	o: 348()

nname: 128
n 128(None)[try:
	data = conn.recv(1024).strip().upper()
except socket.error, e:
	log.error('Connection error %s to %s', e, addr)
	break
if not data:
	continue
]:
	i: 122(t)
	o: 221()

nname: 122
n 122(True)[]:
	i: 84(loop)
	o: 128(t), 355(f)

nname: 84
n 84(None)[conn, addr = sock.accept()
log.info('Network remote connected from %s', addr)
]:
	i: 75(t)
	o: 122(loop), 355(AL)

nname: 75
n 75(self.running)[]:
	i: 0(loop)
	o: 84(t), 386(f)

nname: 0
n 0(None)[self.running = True
sock = socket.socket()
sock.bind((self.HOST, self.PORT))
sock.listen(1)
sock.settimeout(None)
]:
	i: 
	o: 75(loop), 386(AL)

nname: 386
n 386(None)[sock.close()
return None
]:
	i: 0(AL), 75(f), 355()
	o: 

nname: 355
n 355(None)[conn.close()
log.info('%s disconnected', addr)
]:
	i: 84(AL), 122(f), 348(AE)
	o: 386()

nname: 348
n 348(None)[]:
	i: 128(f)
	o: 355(AE)

nname: 128
n 128(None)[try:
	data = conn.recv(1024).strip().upper()
except socket.error, e:
	log.error('Connection error %s to %s', e, addr)
	break
if not data:
	continue
if data in ('DISCONNECT', '\x04'):
	break
try:
	self.post_key(data)
	conn.send('OK' + '\r\n\r\n')
	log.debug('%s sent command %r', addr, data)
	continue
except KeyError:
	conn.send('NOK' + '\r\n\r\n')
	log.error('%s sent unknown command %r', addr, data)
	continue
]:
	i: 122(t)
	o: 348()

nname: 122
n 122(True)[]:
	i: 84(loop)
	o: 128(t), 355(f)

nname: 84
n 84(None)[conn, addr = sock.accept()
log.info('Network remote connected from %s', addr)
]:
	i: 75(t)
	o: 122(loop), 355(AL)

nname: 75
n 75(self.running)[]:
	i: 0(loop)
	o: 84(t), 386(f)

nname: 0
n 0(None)[self.running = True
sock = socket.socket()
sock.bind((self.HOST, self.PORT))
sock.listen(1)
sock.settimeout(None)
]:
	i: 
	o: 75(loop), 386(AL)

nname: 386
n 386(None)[sock.close()
return None
]:
	i: 0(AL), 75(f), 355()
	o: 

nname: 355
n 355(None)[conn.close()
log.info('%s disconnected', addr)
]:
	i: 84(AL), 122(f), 128(AE)
	o: 386()

nname: 128
n 128(None)[try:
	data = conn.recv(1024).strip().upper()
except socket.error, e:
	log.error('Connection error %s to %s', e, addr)
	break
if not data:
	continue
if data in ('DISCONNECT', '\x04'):
	break
try:
	self.post_key(data)
	conn.send('OK' + '\r\n\r\n')
	log.debug('%s sent command %r', addr, data)
	continue
except KeyError:
	conn.send('NOK' + '\r\n\r\n')
	log.error('%s sent unknown command %r', addr, data)
	continue
]:
	i: 122(t)
	o: 355(AE)

nname: 122
n 122(True)[]:
	i: 84(loop)
	o: 128(t), 355(f)

nname: 84
n 84(None)[conn, addr = sock.accept()
log.info('Network remote connected from %s', addr)
]:
	i: 75(t)
	o: 122(loop), 355(AL)

nname: 75
n 75(self.running)[]:
	i: 0(loop)
	o: 84(t), 386(f)

nname: 0
n 0(None)[self.running = True
sock = socket.socket()
sock.bind((self.HOST, self.PORT))
sock.listen(1)
sock.settimeout(None)
]:
	i: 
	o: 75(loop), 386(AL)

nname: 386
n 386(None)[sock.close()
return None
]:
	i: 0(AL), 75(f), 355()
	o: 

nname: 355
n 355(None)[conn.close()
log.info('%s disconnected', addr)
]:
	i: 128(AE)
	o: 386()

nname: 128
n 128(None)[	try:
		data = conn.recv(1024).strip().upper()
	except socket.error, e:
		log.error('Connection error %s to %s', e, addr)
		break
	if not data:
		continue
	if data in ('DISCONNECT', '\x04'):
		break
	try:
		self.post_key(data)
		conn.send('OK' + '\r\n\r\n')
		log.debug('%s sent command %r', addr, data)
		continue
	except KeyError:
		conn.send('NOK' + '\r\n\r\n')
		log.error('%s sent unknown command %r', addr, data)
		continue
]:
	i: 84(t)
	o: 355(AE)

nname: 84
n 84(True)[conn, addr = sock.accept()
log.info('Network remote connected from %s', addr)
while True:
]:
	i: 75(t)
	o: 128(t)

nname: 75
n 75(self.running)[]:
	i: 0(loop)
	o: 84(t), 386(f)

nname: 0
n 0(None)[self.running = True
sock = socket.socket()
sock.bind((self.HOST, self.PORT))
sock.listen(1)
sock.settimeout(None)
]:
	i: 
	o: 75(loop), 386(AL)

nname: 386
n 386(None)[sock.close()
return None
]:
	i: 0(AL), 75(f), 355()
	o: 

nname: 355
n 355(None)[conn.close()
log.info('%s disconnected', addr)
]:
	i: 84(AE)
	o: 386()

nname: 84
n 84(None)[conn, addr = sock.accept()
log.info('Network remote connected from %s', addr)
while True:
	try:
		data = conn.recv(1024).strip().upper()
	except socket.error, e:
		log.error('Connection error %s to %s', e, addr)
		break
	if not data:
		continue
	if data in ('DISCONNECT', '\x04'):
		break
	try:
		self.post_key(data)
		conn.send('OK' + '\r\n\r\n')
		log.debug('%s sent command %r', addr, data)
		continue
	except KeyError:
		conn.send('NOK' + '\r\n\r\n')
		log.error('%s sent unknown command %r', addr, data)
		continue
]:
	i: 75(t)
	o: 355(AE)

nname: 75
n 75(self.running)[]:
	i: 0(loop)
	o: 84(t), 386(f)

nname: 0
n 0(None)[self.running = True
sock = socket.socket()
sock.bind((self.HOST, self.PORT))
sock.listen(1)
sock.settimeout(None)
]:
	i: 
	o: 75(loop), 386(AL)

self.nodes: {0: <unpyclib.structure.node instance at 0xb7712bec>, 386: <unpyclib.structure.node instance at 0xb7724cac>, 75: <unpyclib.structure.node instance at 0xb7712c4c>, 84: <unpyclib.structure.node instance at 0xb7712e4c>, 355: <unpyclib.structure.node instance at 0xb7724bac>}
nname: 6
n 6(None)[__doc__ = 'Network remote control input plugin.\n\n    When this plugin is active, you may control pygui by telnetting to\n    your board on port 31337, and sending line-separated keycodes,\n    e.g. home, wheel_fwd, up, down...\n\n    Blank lines and whitespace in general are ignored, and sending EOF\n    (^D) or "disconnect" terminates the connection.\n\n    The wybox sends limited feedback in the form of "OK" or "NOK", followed\n    by 2 CRLF sequences, after each command. So far, NOK only means you\n    tried to send an unrecognized command.\n\n    Only one remote user may be connected at a time, because really,\n    this is a debugging feature for a media center, not an industrial-strength\n    server.\n    '
HOST = ''
PORT = 31337
def __init__(self, post_key):
	Thread.__init__(self)
	self.post_key = post_key
	self.running = False
	self.setDaemon(True)
	self.setName('Network Remote')
	Task(self.start).start(0.10000000000000001)

def run(self):
	self.running = True
	sock = socket.socket()
	sock.bind((self.HOST, self.PORT))
	sock.listen(1)
	sock.settimeout(None)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb770b16c>}
nname: 0
n 0(None)[from __future__ import absolute_import
import socket
from threading import Thread
from peewee.debug import GET_LOGGER
from peewee.notifier import Task
log = GET_LOGGER(__name__)
class PluginInterface(Thread):
	__doc__ = 'Network remote control input plugin.\n\n    When this plugin is active, you may control pygui by telnetting to\n    your board on port 31337, and sending line-separated keycodes,\n    e.g. home, wheel_fwd, up, down...\n\n    Blank lines and whitespace in general are ignored, and sending EOF\n    (^D) or "disconnect" terminates the connection.\n\n    The wybox sends limited feedback in the form of "OK" or "NOK", followed\n    by 2 CRLF sequences, after each command. So far, NOK only means you\n    tried to send an unrecognized command.\n\n    Only one remote user may be connected at a time, because really,\n    this is a debugging feature for a media center, not an industrial-strength\n    server.\n    '
	HOST = ''
	PORT = 31337
	def __init__(self, post_key):
		Thread.__init__(self)
		self.post_key = post_key
		self.running = False
		self.setDaemon(True)
		self.setName('Network Remote')
		Task(self.start).start(0.10000000000000001)

	def run(self):
		self.running = True
		sock = socket.socket()
		sock.bind((self.HOST, self.PORT))
		sock.listen(1)
		sock.settimeout(None)



]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7705a6c>}
from __future__ import absolute_import
import socket
from threading import Thread
from peewee.debug import GET_LOGGER
from peewee.notifier import Task
log = GET_LOGGER(__name__)
class PluginInterface(Thread):
	__doc__ = 'Network remote control input plugin.\n\n    When this plugin is active, you may control pygui by telnetting to\n    your board on port 31337, and sending line-separated keycodes,\n    e.g. home, wheel_fwd, up, down...\n\n    Blank lines and whitespace in general are ignored, and sending EOF\n    (^D) or "disconnect" terminates the connection.\n\n    The wybox sends limited feedback in the form of "OK" or "NOK", followed\n    by 2 CRLF sequences, after each command. So far, NOK only means you\n    tried to send an unrecognized command.\n\n    Only one remote user may be connected at a time, because really,\n    this is a debugging feature for a media center, not an industrial-strength\n    server.\n    '
	HOST = ''
	PORT = 31337
	def __init__(self, post_key):
		Thread.__init__(self)
		self.post_key = post_key
		self.running = False
		self.setDaemon(True)
		self.setName('Network Remote')
		Task(self.start).start(0.10000000000000001)

	def run(self):
		self.running = True
		sock = socket.socket()
		sock.bind((self.HOST, self.PORT))
		sock.listen(1)
		sock.settimeout(None)



