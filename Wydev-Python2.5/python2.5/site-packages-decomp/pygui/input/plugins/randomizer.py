# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 0
n 0(None)[self.events_list = events_list
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb771628c>}
nname: 6
n 6(None)[def __init__(self, events_list):
	self.events_list = events_list

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb770eecc>}
nname: 0
n 0(None)[event_to_play = choice(self.events_list)
when_to_play = random() * 2
log.info('Event %r -- Next event will occured in %.3f', event_to_play, when_to_play)
yield event_to_play
sleep(when_to_play)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb771694c>}
nname: 6
n 6(None)[def __iter__(self):
	event_to_play = choice(self.events_list)
	when_to_play = random() * 2
	log.info('Event %r -- Next event will occured in %.3f', event_to_play, when_to_play)
	yield event_to_play
	sleep(when_to_play)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb770efec>}
nname: 109
n 109(None)[]:
	i: 0(AL), 108()
	o: 

nname: 108
n 108(None)[]:
	i: 52(AF), 65()
	o: 109()

nname: 65
n 65(None)[for i in xrange(burst_len):
log.info('Event %r num. %d in current burst', event_to_play, i)
yield event_to_play
sleep(self._timer)
]:
	i: 52(for)
	o: 108()

nname: 52
n 52(None)[]:
	i: 0(loop)
	o: 65(for), 108(AF)

nname: 0
n 0(None)[burst_len = randint(2, 30)
event_to_play = choice(self.events_list)
log.info('Burst events --- %r will occured %d times', event_to_play, burst_len)
]:
	i: 
	o: 52(loop), 109(AL)

nname: 109
n 109(None)[]:
	i: 65()
	o: 

nname: 65
n 65(None)[for i in xrange(burst_len):
	log.info('Event %r num. %d in current burst', event_to_play, i)
	yield event_to_play
	sleep(self._timer)
]:
	i: 0(for)
	o: 109()

nname: 0
n 0(None)[burst_len = randint(2, 30)
event_to_play = choice(self.events_list)
log.info('Burst events --- %r will occured %d times', event_to_play, burst_len)
]:
	i: 
	o: 65(for)

nname: 109
n 109(None)[]:
	i: 0()
	o: 

nname: 0
n 0(None)[burst_len = randint(2, 30)
event_to_play = choice(self.events_list)
log.info('Burst events --- %r will occured %d times', event_to_play, burst_len)
for i in xrange(burst_len):
	log.info('Event %r num. %d in current burst', event_to_play, i)
	yield event_to_play
	sleep(self._timer)
]:
	i: 
	o: 109()

nname: 0
n 0(None)[burst_len = randint(2, 30)
event_to_play = choice(self.events_list)
log.info('Burst events --- %r will occured %d times', event_to_play, burst_len)
for i in xrange(burst_len):
	log.info('Event %r num. %d in current burst', event_to_play, i)
	yield event_to_play
	sleep(self._timer)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7716a8c>}
nname: 6
n 6(None)[_timer = 0.10000000000000001
def __iter__(self):
	burst_len = randint(2, 30)
	event_to_play = choice(self.events_list)
	log.info('Burst events --- %r will occured %d times', event_to_play, burst_len)
	for i in xrange(burst_len):
		log.info('Event %r num. %d in current burst', event_to_play, i)
		yield event_to_play
		sleep(self._timer)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb770efcc>}
nname: 0
n 0(None)[EventGenerator.__init__(self, events_list=None)
self.events_list = random_events_duo
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb771678c>}
nname: 150
n 150(None)[]:
	i: 0(AL), 149()
	o: 

nname: 149
n 149(None)[]:
	i: 83(AF), 96()
	o: 150()

nname: 96
n 96(None)[for i in xrange(burst_len):
log.info('Event %r num. %d in flip-flap', event_to_play, i)
yield event_to_play
event_to_play = commute_dict[event_to_play]
sleep(self._timer)
]:
	i: 83(for)
	o: 149()

nname: 83
n 83(None)[]:
	i: 0(loop)
	o: 96(for), 149(AF)

nname: 0
n 0(None)[burst_len = randint(2, 30)
duo_event_to_play = choice(self.events_list)
commute_dict = {duo_event_to_play[0]: duo_event_to_play[1], duo_event_to_play[1]: duo_event_to_play[0]}
event_to_play = duo_event_to_play[0]
]:
	i: 
	o: 83(loop), 150(AL)

nname: 150
n 150(None)[]:
	i: 96()
	o: 

nname: 96
n 96(None)[for i in xrange(burst_len):
	log.info('Event %r num. %d in flip-flap', event_to_play, i)
	yield event_to_play
	event_to_play = commute_dict[event_to_play]
	sleep(self._timer)
]:
	i: 0(for)
	o: 150()

nname: 0
n 0(None)[burst_len = randint(2, 30)
duo_event_to_play = choice(self.events_list)
commute_dict = {duo_event_to_play[0]: duo_event_to_play[1], duo_event_to_play[1]: duo_event_to_play[0]}
event_to_play = duo_event_to_play[0]
]:
	i: 
	o: 96(for)

nname: 150
n 150(None)[]:
	i: 0()
	o: 

nname: 0
n 0(None)[burst_len = randint(2, 30)
duo_event_to_play = choice(self.events_list)
commute_dict = {duo_event_to_play[0]: duo_event_to_play[1], duo_event_to_play[1]: duo_event_to_play[0]}
event_to_play = duo_event_to_play[0]
for i in xrange(burst_len):
	log.info('Event %r num. %d in flip-flap', event_to_play, i)
	yield event_to_play
	event_to_play = commute_dict[event_to_play]
	sleep(self._timer)
]:
	i: 
	o: 150()

nname: 0
n 0(None)[burst_len = randint(2, 30)
duo_event_to_play = choice(self.events_list)
commute_dict = {duo_event_to_play[0]: duo_event_to_play[1], duo_event_to_play[1]: duo_event_to_play[0]}
event_to_play = duo_event_to_play[0]
for i in xrange(burst_len):
	log.info('Event %r num. %d in flip-flap', event_to_play, i)
	yield event_to_play
	event_to_play = commute_dict[event_to_play]
	sleep(self._timer)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7716d8c>}
nname: 6
n 6(None)[_timer = 0.10000000000000001
def __init__(self, events_list):
	EventGenerator.__init__(self, events_list=None)
	self.events_list = random_events_duo
	return None

def __iter__(self):
	burst_len = randint(2, 30)
	duo_event_to_play = choice(self.events_list)
	commute_dict = {duo_event_to_play[0]: duo_event_to_play[1], duo_event_to_play[1]: duo_event_to_play[0]}
	event_to_play = duo_event_to_play[0]
	for i in xrange(burst_len):
		log.info('Event %r num. %d in flip-flap', event_to_play, i)
		yield event_to_play
		event_to_play = commute_dict[event_to_play]
		sleep(self._timer)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb770ef8c>}
nname: 73
n 73(None)[]:
	i: 28(), 63()
	o: 

nname: 63
n 63(None)[self._events = random_events_sample
]:
	i: 0(f)
	o: 73()

nname: 28
n 28(None)[self._events = event_map.keys()
self._events.remove('POWER')
]:
	i: 0(t)
	o: 73()

nname: 0
n 0(all_events)[Thread.__init__(self)
self.handler = handler
]:
	i: 
	o: 28(t), 63(f)

nname: 0
n 0(None)[Thread.__init__(self)
self.handler = handler
if all_events:
	self._events = event_map.keys()
	self._events.remove('POWER')
else:
	self._events = random_events_sample
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7716f4c>}
nname: 69
n 69(None)[]:
	i: 0(AL), 67()
	o: 

nname: 67
n 67(None)[]:
	i: 3(f), 64()
	o: 69()

nname: 64
n 64(None)[]:
	i: 9(AL), 63()
	o: 67()

nname: 63
n 63(None)[]:
	i: 37(AF), 44()
	o: 64()

nname: 44
n 44(None)[for event in generator:
self.handler(event)
]:
	i: 37(for)
	o: 63()

nname: 37
n 37(None)[]:
	i: 9(loop)
	o: 44(for), 63(AF)

nname: 9
n 9(None)[generator = choice(self._event_generators)(self._events)
]:
	i: 3(t)
	o: 37(loop), 64(AL)

nname: 3
n 3(True)[]:
	i: 0(loop)
	o: 9(t), 67(f)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 69(AL)

nname: 69
n 69(None)[]:
	i: 0(AL), 3(f), 44()
	o: 

nname: 44
n 44(None)[for event in generator:
	self.handler(event)
]:
	i: 9(for)
	o: 69()

nname: 9
n 9(None)[generator = choice(self._event_generators)(self._events)
]:
	i: 3(t)
	o: 44(for)

nname: 3
n 3(True)[]:
	i: 0(loop)
	o: 9(t), 69(f)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 69(AL)

nname: 69
n 69(None)[]:
	i: 0(AL), 3(f), 9()
	o: 

nname: 9
n 9(None)[generator = choice(self._event_generators)(self._events)
for event in generator:
	self.handler(event)
]:
	i: 3(t)
	o: 69()

nname: 3
n 3(True)[]:
	i: 0(loop)
	o: 9(t), 69(f)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 69(AL)

nname: 9
n 9(None)[	generator = choice(self._event_generators)(self._events)
	for event in generator:
		self.handler(event)
]:
	i: 0(t)
	o: 

nname: 0
n 0(True)[while True:
]:
	i: 
	o: 9(t)

nname: 0
n 0(None)[while True:
	generator = choice(self._event_generators)(self._events)
	for event in generator:
		self.handler(event)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7716a8c>}
nname: 6
n 6(None)[_event_generators = (NormalEventGenerator, BurstEventGenerator, FlipFlapEventGenerator)
def __init__(self, handler, all_events=False):
	Thread.__init__(self)
	self.handler = handler
	if all_events:
		self._events = event_map.keys()
		self._events.remove('POWER')
	else:
		self._events = random_events_sample

def run(self):
	while True:
		generator = choice(self._event_generators)(self._events)
		for event in generator:
			self.handler(event)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb77160ac>}
nname: 0
n 0(None)[self.post_key = post_key
self.generator = EventRandomizer(self.handle)
self.generator.setDaemon(True)
self.generator.start()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7716d8c>}
nname: 64
n 64(None)[]:
	i: 3(), 39(), 62(AE)
	o: 

nname: 62
n 62(None)[]:
	i: 29(f)
	o: 64(AE)

nname: 39
n 39(None)[log.error('***Randomizer*** Event queue full ==> event %r not passed', event)
]:
	i: 29(t)
	o: 64()

nname: 29
n 29(<dummy_ex3> EXC_MATCH Full)[]:
	i: 0(except)
	o: 39(t), 62(f)

nname: 3
n 3(None)[self.post_key(key=event, timeout=timeout)
]:
	i: 0(try)
	o: 64()

nname: 0
n 0(None)[]:
	i: 
	o: 3(try), 29(except)

nname: 29
n 29(None)[except Full:
	log.error('***Randomizer*** Event queue full ==> event %r not passed', event)
]:
	i: 0()
	o: 

nname: 0
n 0(None)[try:
	self.post_key(key=event, timeout=timeout)
]:
	i: 
	o: 29()

nname: 0
n 0(None)[try:
	self.post_key(key=event, timeout=timeout)
except Full:
	log.error('***Randomizer*** Event queue full ==> event %r not passed', event)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb771684c>}
nname: 6
n 6(None)[__doc__ = '\n    Plugin for generate random events\n    '
def __init__(self, post_key):
	self.post_key = post_key
	self.generator = EventRandomizer(self.handle)
	self.generator.setDaemon(True)
	self.generator.start()

def handle(self, event, timeout=None):
	try:
		self.post_key(key=event, timeout=timeout)
	except Full:
		log.error('***Randomizer*** Event queue full ==> event %r not passed', event)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb770ef8c>}
nname: 0
n 0(None)[from __future__ import absolute_import
from pygui.eventmanager import event_map
from pygui.config import random_events_sample, random_events_duo
from peewee.debug import log
from random import choice, random, randint
from time import sleep
from threading import Thread
from Queue import Full
class EventGenerator(object):
	def __init__(self, events_list):
		self.events_list = events_list



class NormalEventGenerator(EventGenerator):
	def __iter__(self):
		event_to_play = choice(self.events_list)
		when_to_play = random() * 2
		log.info('Event %r -- Next event will occured in %.3f', event_to_play, when_to_play)
		yield event_to_play
		sleep(when_to_play)



class BurstEventGenerator(EventGenerator):
	_timer = 0.10000000000000001
	def __iter__(self):
		burst_len = randint(2, 30)
		event_to_play = choice(self.events_list)
		log.info('Burst events --- %r will occured %d times', event_to_play, burst_len)
		for i in xrange(burst_len):
			log.info('Event %r num. %d in current burst', event_to_play, i)
			yield event_to_play
			sleep(self._timer)



class FlipFlapEventGenerator(EventGenerator):
	_timer = 0.10000000000000001
	def __init__(self, events_list):
		EventGenerator.__init__(self, events_list=None)
		self.events_list = random_events_duo
		return None

	def __iter__(self):
		burst_len = randint(2, 30)
		duo_event_to_play = choice(self.events_list)
		commute_dict = {duo_event_to_play[0]: duo_event_to_play[1], duo_event_to_play[1]: duo_event_to_play[0]}
		event_to_play = duo_event_to_play[0]
		for i in xrange(burst_len):
			log.info('Event %r num. %d in flip-flap', event_to_play, i)
			yield event_to_play
			event_to_play = commute_dict[event_to_play]
			sleep(self._timer)



class EventRandomizer(Thread):
	_event_generators = (NormalEventGenerator, BurstEventGenerator, FlipFlapEventGenerator)
	def __init__(self, handler, all_events=False):
		Thread.__init__(self)
		self.handler = handler
		if all_events:
			self._events = event_map.keys()
			self._events.remove('POWER')
		else:
			self._events = random_events_sample

	def run(self):
		while True:
			generator = choice(self._event_generators)(self._events)
			for event in generator:
				self.handler(event)



class PluginInterface(object):
	__doc__ = '\n    Plugin for generate random events\n    '
	def __init__(self, post_key):
		self.post_key = post_key
		self.generator = EventRandomizer(self.handle)
		self.generator.setDaemon(True)
		self.generator.start()

	def handle(self, event, timeout=None):
		try:
			self.post_key(key=event, timeout=timeout)
		except Full:
			log.error('***Randomizer*** Event queue full ==> event %r not passed', event)



]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7707bac>}
from __future__ import absolute_import
from pygui.eventmanager import event_map
from pygui.config import random_events_sample, random_events_duo
from peewee.debug import log
from random import choice, random, randint
from time import sleep
from threading import Thread
from Queue import Full
class EventGenerator(object):
	def __init__(self, events_list):
		self.events_list = events_list



class NormalEventGenerator(EventGenerator):
	def __iter__(self):
		event_to_play = choice(self.events_list)
		when_to_play = random() * 2
		log.info('Event %r -- Next event will occured in %.3f', event_to_play, when_to_play)
		yield event_to_play
		sleep(when_to_play)



class BurstEventGenerator(EventGenerator):
	_timer = 0.10000000000000001
	def __iter__(self):
		burst_len = randint(2, 30)
		event_to_play = choice(self.events_list)
		log.info('Burst events --- %r will occured %d times', event_to_play, burst_len)
		for i in xrange(burst_len):
			log.info('Event %r num. %d in current burst', event_to_play, i)
			yield event_to_play
			sleep(self._timer)



class FlipFlapEventGenerator(EventGenerator):
	_timer = 0.10000000000000001
	def __init__(self, events_list):
		EventGenerator.__init__(self, events_list=None)
		self.events_list = random_events_duo
		return None

	def __iter__(self):
		burst_len = randint(2, 30)
		duo_event_to_play = choice(self.events_list)
		commute_dict = {duo_event_to_play[0]: duo_event_to_play[1], duo_event_to_play[1]: duo_event_to_play[0]}
		event_to_play = duo_event_to_play[0]
		for i in xrange(burst_len):
			log.info('Event %r num. %d in flip-flap', event_to_play, i)
			yield event_to_play
			event_to_play = commute_dict[event_to_play]
			sleep(self._timer)



class EventRandomizer(Thread):
	_event_generators = (NormalEventGenerator, BurstEventGenerator, FlipFlapEventGenerator)
	def __init__(self, handler, all_events=False):
		Thread.__init__(self)
		self.handler = handler
		if all_events:
			self._events = event_map.keys()
			self._events.remove('POWER')
		else:
			self._events = random_events_sample

	def run(self):
		while True:
			generator = choice(self._event_generators)(self._events)
			for event in generator:
				self.handler(event)



class PluginInterface(object):
	__doc__ = '\n    Plugin for generate random events\n    '
	def __init__(self, post_key):
		self.post_key = post_key
		self.generator = EventRandomizer(self.handle)
		self.generator.setDaemon(True)
		self.generator.start()

	def handle(self, event, timeout=None):
		try:
			self.post_key(key=event, timeout=timeout)
		except Full:
			log.error('***Randomizer*** Event queue full ==> event %r not passed', event)



