# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 0
n 0(None)[return stdin_read(1)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb772b1ac>}
nname: 0
n 0(None)[self._PluginInterface__pdb_mode = True
self.cleanup()
orig_pdb_set_trace(*args, **kw)
self.init_term()
self._PluginInterface__pdb_mode = False
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb772b72c>}
nname: 0
n 0(None)[self._PluginInterface__pdb_mode = False
self.kbmap_get = KEYBOARD_MAP.get
notifier.descriptor_watch(sys.stdin.fileno(), self.handle)
atexit.register(self.cleanup)
stdin_read = sys.stdin.read
def self.read():
	return stdin_read(1)

self.init_term()
def pdb_set_trace(*args, **args):
	self._PluginInterface__pdb_mode = True
	self.cleanup()
	orig_pdb_set_trace(*args, **kw)
	self.init_term()
	self._PluginInterface__pdb_mode = False

pdb.set_trace = pdb_set_trace
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb772c82c>}
nname: 47
n 47(None)[tc = termios.tcgetattr(sys.stdin.fileno())
tc[3] = tc[3] & ~termios.ICANON
tc[6][termios.VMIN] = 1
tc[6][termios.VTIME] = 0
termios.tcsetattr(sys.stdin.fileno(), termios.TCSANOW, tc)
]:
	i: 15(), 46()
	o: 

nname: 46
n 46(None)[]:
	i: 0(t)
	o: 47()

nname: 15
n 15(None)[self._tc_orig_settings = termios.tcgetattr(sys.stdin.fileno())
]:
	i: 0(f)
	o: 47()

nname: 0
n 0(hasattr(self, '_tc_orig_settings'))[]:
	i: 
	o: 15(f), 46(t)

nname: 0
n 0(None)[if not hasattr(self, '_tc_orig_settings'):
	self._tc_orig_settings = termios.tcgetattr(sys.stdin.fileno())
tc = termios.tcgetattr(sys.stdin.fileno())
tc[3] = tc[3] & ~termios.ICANON
tc[6][termios.VMIN] = 1
tc[6][termios.VTIME] = 0
termios.tcsetattr(sys.stdin.fileno(), termios.TCSANOW, tc)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb772caec>}
nname: 0
n 0(None)[termios.tcsetattr(sys.stdin.fileno(), termios.TCSANOW, self._tc_orig_settings)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb772c34c>}
nname: 117
n 117(None)[return code
]:
	i: 108(), 116()
	o: 

nname: 116
n 116(None)[]:
	i: 78(f)
	o: 117()

nname: 108
n 108(None)[return buf
]:
	i: 78(t)
	o: 117()

nname: 78
n 78(code is None)[code = self.known_keycodes.get(buf)
]:
	i: 0(AL), 76()
	o: 108(t), 116(f)

nname: 76
n 76(None)[]:
	i: 15(f), 72()
	o: 78()

nname: 72
n 72(None)[]:
	i: 34(f), 67()
	o: 76()

nname: 67
n 67(None)[break
continue
]:
	i: 34(t)
	o: 72()

nname: 34
n 34(buf[-1] == '~')[buf += self.read()
]:
	i: 15(t)
	o: 67(t), 72(f)

nname: 15
n 15(buf[:3] in self.known_prefixes)[]:
	i: 0(loop)
	o: 34(t), 76(f)

nname: 0
n 0(None)[buf = self.read()
]:
	i: 
	o: 15(loop), 78(AL)

nname: 78
n 78(None)[code = self.known_keycodes.get(buf)
if code is None:
	return buf
return code
]:
	i: 0(AL), 15(f), 34()
	o: 

nname: 34
n 34(None)[buf += self.read()
if buf[-1] == '~':
	break
	continue
]:
	i: 15(t)
	o: 78()

nname: 15
n 15(buf[:3] in self.known_prefixes)[]:
	i: 0(loop)
	o: 34(t), 78(f)

nname: 0
n 0(None)[buf = self.read()
]:
	i: 
	o: 15(loop), 78(AL)

nname: 34
n 34(None)[	buf += self.read()
	if buf[-1] == '~':
		break
		continue
code = self.known_keycodes.get(buf)
if code is None:
	return buf
return code
]:
	i: 0(t)
	o: 

nname: 0
n 0(buf[:3] in self.known_prefixes)[buf = self.read()
while buf[:3] in self.known_prefixes:
]:
	i: 
	o: 34(t)

nname: 0
n 0(None)[buf = self.read()
while buf[:3] in self.known_prefixes:
	buf += self.read()
	if buf[-1] == '~':
		break
		continue
code = self.known_keycodes.get(buf)
if code is None:
	return buf
return code
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb772c8ac>}
nname: 231
n 231(None)[return True
]:
	i: 146(JA), 191(JA), 209(JA), 227(), 230()
	o: 

nname: 230
n 230(None)[]:
	i: 85&118&131(f)
	o: 231()

nname: 227
n 227(None)[]:
	i: 225(AE)
	o: 231()

nname: 225
n 225(None)[]:
	i: 198(f)
	o: 227(AE)

nname: 209
n 209(None)[print 'Unmapped key: %s.' % keycode
]:
	i: 198(t)
	o: 231(JA)

nname: 198
n 198(<dummy_ex3> EXC_MATCH KeyError)[]:
	i: 181(f)
	o: 209(t), 225(f)

nname: 191
n 191(None)[]:
	i: 181(t)
	o: 231(JA)

nname: 181
n 181(<dummy_ex3> EXC_MATCH Full)[]:
	i: 142(except)
	o: 191(t), 198(f)

nname: 146
n 146(None)[mapped.post({'count': 1, 'timeout': None})
]:
	i: 142(try)
	o: 231(JA)

nname: 142
n 142(None)[]:
	i: 85&118&131(t)
	o: 146(try), 181(except)

nname: 85&118&131
n 85&118&131(keycode is not None and mapped is not None and not self._PluginInterface__pdb_mode)[mapped = self.kbmap_get(keycode.upper())
]:
	i: 27(), 53(), 83(AE)
	o: 142(t), 230(f)

nname: 83
n 83(None)[]:
	i: 43(f)
	o: 85&118&131(AE)

nname: 53
n 53(None)[#, e
print 'Invalid keycode',
print str(e)
keycode = None
]:
	i: 43(t)
	o: 85&118&131()

nname: 43
n 43(<dummy_ex3> EXC_MATCH Exception)[]:
	i: 24(except)
	o: 53(t), 83(f)

nname: 27
n 27(None)[keycode = self.getch()
]:
	i: 24(try)
	o: 85&118&131()

nname: 24
n 24(None)[]:
	i: 15(), 23()
	o: 27(try), 43(except)

nname: 23
n 23(None)[]:
	i: 0(f)
	o: 24()

nname: 15
n 15(None)[return True
]:
	i: 0(t)
	o: 24()

nname: 0
n 0(self._PluginInterface__pdb_mode == True)[]:
	i: 
	o: 15(t), 23(f)

nname: 231
n 231(None)[return True
]:
	i: 146(JA), 209(JA), 198(f), 181(t), 225(AE), 85&118&131(f)
	o: 

nname: 209
n 209(None)[print 'Unmapped key: %s.' % keycode
]:
	i: 198(t)
	o: 231(JA)

nname: 198
n 198(<dummy_ex3> EXC_MATCH KeyError)[]:
	i: 181(f)
	o: 209(t), 231(f)

nname: 181
n 181(<dummy_ex3> EXC_MATCH Full)[]:
	i: 142(except)
	o: 231(t), 198(f)

nname: 146
n 146(None)[mapped.post({'count': 1, 'timeout': None})
]:
	i: 142(try)
	o: 231(JA)

nname: 142
n 142(None)[]:
	i: 85&118&131(t)
	o: 146(try), 181(except)

nname: 85&118&131
n 85&118&131(keycode is not None and mapped is not None and not self._PluginInterface__pdb_mode)[mapped = self.kbmap_get(keycode.upper())
]:
	i: 27()
	o: 142(t), 231(f)

nname: 27
n 27(None)[try:
	keycode = self.getch()
except Exception, e:
	print 'Invalid keycode',
	print str(e)
	keycode = None
]:
	i: 0(try)
	o: 85&118&131()

nname: 0
n 0(None)[if self._PluginInterface__pdb_mode == True:
	return True
]:
	i: 
	o: 27(try)

nname: 231
n 231(None)[return True
]:
	i: 181(t), 85&118&131(f)
	o: 

nname: 181
n 181(None)[except:
	if not <dummy_ex3> EXC_MATCH Full:
		except KeyError:
			print 'Unmapped key: %s.' % keycode
]:
	i: 142()
	o: 231(JA)

nname: 142
n 142(None)[try:
	mapped.post({'count': 1, 'timeout': None})
]:
	i: 85&118&131(t)
	o: 181()

nname: 85&118&131
n 85&118&131(keycode is not None and mapped is not None and not self._PluginInterface__pdb_mode)[mapped = self.kbmap_get(keycode.upper())
]:
	i: 0()
	o: 142(t), 231(f)

nname: 0
n 0(None)[if self._PluginInterface__pdb_mode == True:
	return True
try:
	keycode = self.getch()
except Exception, e:
	print 'Invalid keycode',
	print str(e)
	keycode = None
]:
	i: 
	o: 85&118&131()

nname: 231
n 231(None)[return True
]:
	i: 142(t), 0(f)
	o: 

nname: 142
n 142(None)[try:
	mapped.post({'count': 1, 'timeout': None})
except:
	if not <dummy_ex3> EXC_MATCH Full:
		except KeyError:
			print 'Unmapped key: %s.' % keycode
]:
	i: 0(t)
	o: 231(JA)

nname: 0
n 0(keycode is not None and mapped is not None and not self._PluginInterface__pdb_mode)[if self._PluginInterface__pdb_mode == True:
	return True
try:
	keycode = self.getch()
except Exception, e:
	print 'Invalid keycode',
	print str(e)
	keycode = None
mapped = self.kbmap_get(keycode.upper())
]:
	i: 
	o: 142(t), 231(f)

nname: 0
n 0(None)[if self._PluginInterface__pdb_mode == True:
	return True
try:
	keycode = self.getch()
except Exception, e:
	print 'Invalid keycode',
	print str(e)
	keycode = None
mapped = self.kbmap_get(keycode.upper())
if keycode is not None and mapped is not None and not self._PluginInterface__pdb_mode:
	try:
		mapped.post({'count': 1, 'timeout': None})
	except:
		if not <dummy_ex3> EXC_MATCH Full:
			except KeyError:
				print 'Unmapped key: %s.' % keycode
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb77342ac>}
nname: 6
n 6(None)[__doc__ = '\n    Plugin for stdin control.\n    '
def __init__(self, *args):
	self._PluginInterface__pdb_mode = False
	self.kbmap_get = KEYBOARD_MAP.get
	notifier.descriptor_watch(sys.stdin.fileno(), self.handle)
	atexit.register(self.cleanup)
	stdin_read = sys.stdin.read
	def self.read():
		return stdin_read(1)

	self.init_term()
	def pdb_set_trace(*args, **args):
		self._PluginInterface__pdb_mode = True
		self.cleanup()
		orig_pdb_set_trace(*args, **kw)
		self.init_term()
		self._PluginInterface__pdb_mode = False

	pdb.set_trace = pdb_set_trace

known_prefixes = ('\x1b', '\x1bO', '\x1b[', '\x1b[1', '\x1b[2', '\x1b[3', '\x1b[4', '\x1b[5', '\x1b[ 6')
known_keycodes = {'\x1b[A': 'up', '\x1b[B': 'down', '\x1b[C': 'right', '\x1b[D': 'left', '\x1b[1~': 'home', '\x1b[4~': 'end', '\x1b[5~': 'page_up', '\x1b[6~': 'page_down', '\x1bOP': 'F1', '\x1bOQ': 'F2', '\x1bOR': 'F3', '\x1bOS': 'F4', '\x1b[15~': 'F5', '\x1b[17~': 'F6', '\x1b[18~': 'F7', '\x1b[19~': 'F8', '\x1b[20~': 'F9', '\x1b[21~': 'F10', '\x1b[23~': 'F11', '\x1b[24~': 'F12', '\x1b[2~': 'ins', '\x1b[3~': 'del', '\x1bOF': 'end', '\x1bOH': 'home', '\x1b\x1b': 'esc', '\n': 'enter', ' ': 'space', '\x7f': 'backspace'}
def init_term(self):
	if not hasattr(self, '_tc_orig_settings'):
		self._tc_orig_settings = termios.tcgetattr(sys.stdin.fileno())
	tc = termios.tcgetattr(sys.stdin.fileno())
	tc[3] = tc[3] & ~termios.ICANON
	tc[6][termios.VMIN] = 1
	tc[6][termios.VTIME] = 0
	termios.tcsetattr(sys.stdin.fileno(), termios.TCSANOW, tc)

def cleanup(self):
	termios.tcsetattr(sys.stdin.fileno(), termios.TCSANOW, self._tc_orig_settings)

def getch(self):
	buf = self.read()
	while buf[:3] in self.known_prefixes:
		buf += self.read()
		if buf[-1] == '~':
			break
			continue
	code = self.known_keycodes.get(buf)
	if code is None:
		return buf
	return code

def handle(self):
	if self._PluginInterface__pdb_mode == True:
		return True
	try:
		keycode = self.getch()
	except Exception, e:
		print 'Invalid keycode',
		print str(e)
		keycode = None
	mapped = self.kbmap_get(keycode.upper())
	if keycode is not None and mapped is not None and not self._PluginInterface__pdb_mode:
		try:
			mapped.post({'count': 1, 'timeout': None})
		except:
			if not <dummy_ex3> EXC_MATCH Full:
				except KeyError:
					print 'Unmapped key: %s.' % keycode
	return True

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb7719acc>}
nname: 0
n 0(None)[from __future__ import absolute_import
import atexit
import peewee.notifier as notifier
import sys
import termios
from Queue import Full
from pygui.input import KEYBOARD_MAP
import pdb
orig_pdb_set_trace = pdb.set_trace
class PluginInterface(object):
	__doc__ = '\n    Plugin for stdin control.\n    '
	def __init__(self, *args):
		self._PluginInterface__pdb_mode = False
		self.kbmap_get = KEYBOARD_MAP.get
		notifier.descriptor_watch(sys.stdin.fileno(), self.handle)
		atexit.register(self.cleanup)
		stdin_read = sys.stdin.read
		def self.read():
			return stdin_read(1)

		self.init_term()
		def pdb_set_trace(*args, **args):
			self._PluginInterface__pdb_mode = True
			self.cleanup()
			orig_pdb_set_trace(*args, **kw)
			self.init_term()
			self._PluginInterface__pdb_mode = False

		pdb.set_trace = pdb_set_trace

	known_prefixes = ('\x1b', '\x1bO', '\x1b[', '\x1b[1', '\x1b[2', '\x1b[3', '\x1b[4', '\x1b[5', '\x1b[ 6')
	known_keycodes = {'\x1b[A': 'up', '\x1b[B': 'down', '\x1b[C': 'right', '\x1b[D': 'left', '\x1b[1~': 'home', '\x1b[4~': 'end', '\x1b[5~': 'page_up', '\x1b[6~': 'page_down', '\x1bOP': 'F1', '\x1bOQ': 'F2', '\x1bOR': 'F3', '\x1bOS': 'F4', '\x1b[15~': 'F5', '\x1b[17~': 'F6', '\x1b[18~': 'F7', '\x1b[19~': 'F8', '\x1b[20~': 'F9', '\x1b[21~': 'F10', '\x1b[23~': 'F11', '\x1b[24~': 'F12', '\x1b[2~': 'ins', '\x1b[3~': 'del', '\x1bOF': 'end', '\x1bOH': 'home', '\x1b\x1b': 'esc', '\n': 'enter', ' ': 'space', '\x7f': 'backspace'}
	def init_term(self):
		if not hasattr(self, '_tc_orig_settings'):
			self._tc_orig_settings = termios.tcgetattr(sys.stdin.fileno())
		tc = termios.tcgetattr(sys.stdin.fileno())
		tc[3] = tc[3] & ~termios.ICANON
		tc[6][termios.VMIN] = 1
		tc[6][termios.VTIME] = 0
		termios.tcsetattr(sys.stdin.fileno(), termios.TCSANOW, tc)

	def cleanup(self):
		termios.tcsetattr(sys.stdin.fileno(), termios.TCSANOW, self._tc_orig_settings)

	def getch(self):
		buf = self.read()
		while buf[:3] in self.known_prefixes:
			buf += self.read()
			if buf[-1] == '~':
				break
				continue
		code = self.known_keycodes.get(buf)
		if code is None:
			return buf
		return code

	def handle(self):
		if self._PluginInterface__pdb_mode == True:
			return True
		try:
			keycode = self.getch()
		except Exception, e:
			print 'Invalid keycode',
			print str(e)
			keycode = None
		mapped = self.kbmap_get(keycode.upper())
		if keycode is not None and mapped is not None and not self._PluginInterface__pdb_mode:
			try:
				mapped.post({'count': 1, 'timeout': None})
			except:
				if not <dummy_ex3> EXC_MATCH Full:
					except KeyError:
						print 'Unmapped key: %s.' % keycode
		return True



]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb770ed2c>}
from __future__ import absolute_import
import atexit
import peewee.notifier as notifier
import sys
import termios
from Queue import Full
from pygui.input import KEYBOARD_MAP
import pdb
orig_pdb_set_trace = pdb.set_trace
class PluginInterface(object):
	__doc__ = '\n    Plugin for stdin control.\n    '
	def __init__(self, *args):
		self._PluginInterface__pdb_mode = False
		self.kbmap_get = KEYBOARD_MAP.get
		notifier.descriptor_watch(sys.stdin.fileno(), self.handle)
		atexit.register(self.cleanup)
		stdin_read = sys.stdin.read
		def self.read():
			return stdin_read(1)

		self.init_term()
		def pdb_set_trace(*args, **args):
			self._PluginInterface__pdb_mode = True
			self.cleanup()
			orig_pdb_set_trace(*args, **kw)
			self.init_term()
			self._PluginInterface__pdb_mode = False

		pdb.set_trace = pdb_set_trace

	known_prefixes = ('\x1b', '\x1bO', '\x1b[', '\x1b[1', '\x1b[2', '\x1b[3', '\x1b[4', '\x1b[5', '\x1b[ 6')
	known_keycodes = {'\x1b[A': 'up', '\x1b[B': 'down', '\x1b[C': 'right', '\x1b[D': 'left', '\x1b[1~': 'home', '\x1b[4~': 'end', '\x1b[5~': 'page_up', '\x1b[6~': 'page_down', '\x1bOP': 'F1', '\x1bOQ': 'F2', '\x1bOR': 'F3', '\x1bOS': 'F4', '\x1b[15~': 'F5', '\x1b[17~': 'F6', '\x1b[18~': 'F7', '\x1b[19~': 'F8', '\x1b[20~': 'F9', '\x1b[21~': 'F10', '\x1b[23~': 'F11', '\x1b[24~': 'F12', '\x1b[2~': 'ins', '\x1b[3~': 'del', '\x1bOF': 'end', '\x1bOH': 'home', '\x1b\x1b': 'esc', '\n': 'enter', ' ': 'space', '\x7f': 'backspace'}
	def init_term(self):
		if not hasattr(self, '_tc_orig_settings'):
			self._tc_orig_settings = termios.tcgetattr(sys.stdin.fileno())
		tc = termios.tcgetattr(sys.stdin.fileno())
		tc[3] = tc[3] & ~termios.ICANON
		tc[6][termios.VMIN] = 1
		tc[6][termios.VTIME] = 0
		termios.tcsetattr(sys.stdin.fileno(), termios.TCSANOW, tc)

	def cleanup(self):
		termios.tcsetattr(sys.stdin.fileno(), termios.TCSANOW, self._tc_orig_settings)

	def getch(self):
		buf = self.read()
		while buf[:3] in self.known_prefixes:
			buf += self.read()
			if buf[-1] == '~':
				break
				continue
		code = self.known_keycodes.get(buf)
		if code is None:
			return buf
		return code

	def handle(self):
		if self._PluginInterface__pdb_mode == True:
			return True
		try:
			keycode = self.getch()
		except Exception, e:
			print 'Invalid keycode',
			print str(e)
			keycode = None
		mapped = self.kbmap_get(keycode.upper())
		if keycode is not None and mapped is not None and not self._PluginInterface__pdb_mode:
			try:
				mapped.post({'count': 1, 'timeout': None})
			except:
				if not <dummy_ex3> EXC_MATCH Full:
					except KeyError:
						print 'Unmapped key: %s.' % keycode
		return True



