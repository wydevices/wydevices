# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 0
n 0(None)[self.rotate()
self.fd = file(LOGFILE % 'record-%d' % int(sched.ts), 'w')
self._last_ts = sched.ts
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75b8c0c>}
nname: 196
n 196(None)[]:
	i: 150(AL), 195()
	o: 

nname: 195
n 195(None)[]:
	i: 166(AF), 173()
	o: 196()

nname: 173
n 173(None)[for fname in flist:
log.debug(' * %s', fname)
]:
	i: 166(for)
	o: 195()

nname: 166
n 166(None)[]:
	i: 150(loop)
	o: 173(for), 195(AF)

nname: 150
n 150(None)[log.debug('Available records:')
]:
	i: 0(AL), 149()
	o: 166(loop), 196(AL)

nname: 149
n 149(None)[]:
	i: 61(AF), 146()
	o: 150()

nname: 146
n 146(None)[]:
	i: 144(AE)
	o: 149()

nname: 144
n 144(None)[]:
	i: 105(f), 121()
	o: 146(AE)

nname: 121
n 121(None)[log.error("*WARN* can't remove %s", fname)
continue
]:
	i: 105(t)
	o: 144()

nname: 105
n 105(<dummy_ex3> EXC_MATCH (IOError, OSError))[]:
	i: 72(except), 78()
	o: 121(t), 144(f)

nname: 78
n 78(None)[unlink(fname)
flist.remove(fname)
continue
]:
	i: 72(try)
	o: 105()

nname: 72
n 72(None)[for fname in flist[:-10]:
]:
	i: 61(for)
	o: 78(try), 105(except)

nname: 61
n 61(None)[]:
	i: 0(loop)
	o: 72(for), 149(AF)

nname: 0
n 0(None)[from glob import glob
from os import unlink
flist = glob(LOGFILE % 'record-*')
flist.sort()
]:
	i: 
	o: 61(loop), 150(AL)

nname: 196
n 196(None)[]:
	i: 173()
	o: 

nname: 173
n 173(None)[for fname in flist:
	log.debug(' * %s', fname)
]:
	i: 150(for)
	o: 196()

nname: 150
n 150(None)[log.debug('Available records:')
]:
	i: 0(AL), 61(AF), 105(AE)
	o: 173(for)

nname: 105
n 105(None)[except (IOError, OSError):
	log.error("*WARN* can't remove %s", fname)
	continue
]:
	i: 72()
	o: 150(AE)

nname: 72
n 72(None)[for fname in flist[:-10]:
try:
	unlink(fname)
	flist.remove(fname)
	continue
]:
	i: 61(for)
	o: 105()

nname: 61
n 61(None)[]:
	i: 0(loop)
	o: 72(for), 150(AF)

nname: 0
n 0(None)[from glob import glob
from os import unlink
flist = glob(LOGFILE % 'record-*')
flist.sort()
]:
	i: 
	o: 61(loop), 150(AL)

nname: 196
n 196(None)[]:
	i: 150()
	o: 

nname: 150
n 150(None)[log.debug('Available records:')
for fname in flist:
	log.debug(' * %s', fname)
]:
	i: 0(AL), 61(AF), 72(AE)
	o: 196()

nname: 72
n 72(None)[for fname in flist[:-10]:
try:
	unlink(fname)
	flist.remove(fname)
	continue
except (IOError, OSError):
	log.error("*WARN* can't remove %s", fname)
	continue
]:
	i: 61(for)
	o: 150(AE)

nname: 61
n 61(None)[]:
	i: 0(loop)
	o: 72(for), 150(AF)

nname: 0
n 0(None)[from glob import glob
from os import unlink
flist = glob(LOGFILE % 'record-*')
flist.sort()
]:
	i: 
	o: 61(loop), 150(AL)

nname: 150
n 150(None)[log.debug('Available records:')
for fname in flist:
	log.debug(' * %s', fname)
]:
	i: 72(AE)
	o: 

nname: 72
n 72(None)[for fname in flist[:-10]:
	try:
		unlink(fname)
		flist.remove(fname)
		continue
	except (IOError, OSError):
		log.error("*WARN* can't remove %s", fname)
		continue
]:
	i: 0(for)
	o: 150(AE)

nname: 0
n 0(None)[from glob import glob
from os import unlink
flist = glob(LOGFILE % 'record-*')
flist.sort()
]:
	i: 
	o: 72(for)

nname: 150
n 150(None)[log.debug('Available records:')
for fname in flist:
	log.debug(' * %s', fname)
]:
	i: 0(AE)
	o: 

nname: 0
n 0(None)[from glob import glob
from os import unlink
flist = glob(LOGFILE % 'record-*')
flist.sort()
for fname in flist[:-10]:
	try:
		unlink(fname)
		flist.remove(fname)
		continue
	except (IOError, OSError):
		log.error("*WARN* can't remove %s", fname)
		continue
]:
	i: 
	o: 150(AE)

self.nodes: {0: <unpyclib.structure.node instance at 0xb75bd8cc>, 150: <unpyclib.structure.node instance at 0xb75bd38c>}
nname: 0
n 0(None)[ts = sched.ts - self._last_ts
self._last_ts = sched.ts
self.fd.write('%f:%s\n' % (ts, event))
self.fd.flush()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75b8e4c>}
nname: 6
n 6(None)[def __init__(self):
	self.rotate()
	self.fd = file(LOGFILE % 'record-%d' % int(sched.ts), 'w')
	self._last_ts = sched.ts

def rotate(self):
	from glob import glob
	from os import unlink
	flist = glob(LOGFILE % 'record-*')
	flist.sort()
	for fname in flist[:-10]:
		try:
			unlink(fname)
			flist.remove(fname)
			continue
		except (IOError, OSError):
			log.error("*WARN* can't remove %s", fname)
			continue

def add(self, event, args={}):
	ts = sched.ts - self._last_ts
	self._last_ts = sched.ts
	self.fd.write('%f:%s\n' % (ts, event))
	self.fd.flush()

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75b82ac>}
nname: 0
n 0(None)[return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75bd64c>}
nname: 173
n 173(None)[return None
]:
	i: 134(), 164(), 171(AE)
	o: 

nname: 171
n 171(None)[]:
	i: 154(f)
	o: 173(AE)

nname: 164
n 164(None)[]:
	i: 154(t)
	o: 173()

nname: 154
n 154(<dummy_ex3> EXC_MATCH OSError)[]:
	i: 118(except)
	o: 164(t), 171(f)

nname: 134
n 134(None)[os.unlink(self._flag_name)
]:
	i: 118(try)
	o: 173()

nname: 118
n 118(None)[self.setDaemon(True)
]:
	i: 37(), 86()
	o: 134(try), 154(except)

nname: 86
n 86(None)[self._oom_fd = file(LOGFILE % 'oom', 'w')
self.fd = None
]:
	i: 0(f)
	o: 118()

nname: 37
n 37(None)[def self._check_oom(*args, **args):
	return None

self.fd = file(logfile, 'r')
self.loop_mode = bool(loop)
]:
	i: 0(t)
	o: 118()

nname: 0
n 0(logfile)[Thread.__init__(self)
self.handler = handler
self._flag_name = '/tmp/oom.flag'
]:
	i: 
	o: 37(t), 86(f)

nname: 173
n 173(None)[return None
]:
	i: 134()
	o: 

nname: 134
n 134(None)[try:
	os.unlink(self._flag_name)
except OSError:
	pass
]:
	i: 0(try)
	o: 173()

nname: 0
n 0(None)[Thread.__init__(self)
self.handler = handler
self._flag_name = '/tmp/oom.flag'
if logfile:
	def self._check_oom(*args, **args):
		return None

	self.fd = file(logfile, 'r')
	self.loop_mode = bool(loop)
else:
	self._oom_fd = file(LOGFILE % 'oom', 'w')
	self.fd = None
self.setDaemon(True)
]:
	i: 
	o: 134(try)

nname: 173
n 173(None)[return None
]:
	i: 0()
	o: 

nname: 0
n 0(None)[Thread.__init__(self)
self.handler = handler
self._flag_name = '/tmp/oom.flag'
if logfile:
	def self._check_oom(*args, **args):
		return None

	self.fd = file(logfile, 'r')
	self.loop_mode = bool(loop)
else:
	self._oom_fd = file(LOGFILE % 'oom', 'w')
	self.fd = None
self.setDaemon(True)
try:
	os.unlink(self._flag_name)
except OSError:
	pass
]:
	i: 
	o: 173()

nname: 0
n 0(None)[Thread.__init__(self)
self.handler = handler
self._flag_name = '/tmp/oom.flag'
if logfile:
	def self._check_oom(*args, **args):
		return None

	self.fd = file(logfile, 'r')
	self.loop_mode = bool(loop)
else:
	self._oom_fd = file(LOGFILE % 'oom', 'w')
	self.fd = None
self.setDaemon(True)
try:
	os.unlink(self._flag_name)
except OSError:
	pass
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75bd7ec>}
nname: 124
n 124(None)[return None
]:
	i: 19(JA), 64(JA), 104(), 107()
	o: 

nname: 107
n 107(None)[self.fd.seek(0)
]:
	i: 0(f)
	o: 124()

nname: 104
n 104(None)[]:
	i: 102(AE)
	o: 124()

nname: 102
n 102(None)[]:
	i: 54(f)
	o: 104(AE)

nname: 64
n 64(None)[self.fd = file(LOGFILE % 'replay', 'r')
self.loop_mode = False
]:
	i: 54(t)
	o: 124(JA)

nname: 54
n 54(<dummy_ex3> EXC_MATCH IOError)[]:
	i: 15(except)
	o: 64(t), 102(f)

nname: 19
n 19(None)[self.fd = file(LOGFILE % 'replayloop', 'r')
self.loop_mode = True
]:
	i: 15(try)
	o: 124(JA)

nname: 15
n 15(None)[]:
	i: 0(t)
	o: 19(try), 54(except)

nname: 0
n 0(self.fd is None)[]:
	i: 
	o: 15(t), 107(f)

nname: 124
n 124(None)[return None
]:
	i: 19(JA), 64(JA), 107(), 54(f), 102(AE)
	o: 

nname: 107
n 107(None)[self.fd.seek(0)
]:
	i: 0(f)
	o: 124()

nname: 64
n 64(None)[self.fd = file(LOGFILE % 'replay', 'r')
self.loop_mode = False
]:
	i: 54(t)
	o: 124(JA)

nname: 54
n 54(<dummy_ex3> EXC_MATCH IOError)[]:
	i: 15(except)
	o: 64(t), 124(f)

nname: 19
n 19(None)[self.fd = file(LOGFILE % 'replayloop', 'r')
self.loop_mode = True
]:
	i: 15(try)
	o: 124(JA)

nname: 15
n 15(None)[]:
	i: 0(t)
	o: 19(try), 54(except)

nname: 0
n 0(self.fd is None)[]:
	i: 
	o: 15(t), 107(f)

nname: 124
n 124(None)[return None
]:
	i: 107(), 54(f)
	o: 

nname: 107
n 107(None)[self.fd.seek(0)
]:
	i: 0(f)
	o: 124()

nname: 54
n 54(None)[except IOError:
	self.fd = file(LOGFILE % 'replay', 'r')
	self.loop_mode = False
]:
	i: 15()
	o: 124(JA)

nname: 15
n 15(None)[try:
	self.fd = file(LOGFILE % 'replayloop', 'r')
	self.loop_mode = True
]:
	i: 0(t)
	o: 54()

nname: 0
n 0(self.fd is None)[]:
	i: 
	o: 15(t), 107(f)

nname: 124
n 124(None)[return None
]:
	i: 107(), 15(f)
	o: 

nname: 107
n 107(None)[self.fd.seek(0)
]:
	i: 0(f)
	o: 124()

nname: 15
n 15(None)[try:
	self.fd = file(LOGFILE % 'replayloop', 'r')
	self.loop_mode = True
except IOError:
	self.fd = file(LOGFILE % 'replay', 'r')
	self.loop_mode = False
]:
	i: 0(t)
	o: 124(JA)

nname: 0
n 0(self.fd is None)[]:
	i: 
	o: 15(t), 107(f)

nname: 0
n 0(None)[if self.fd is None:
	try:
		self.fd = file(LOGFILE % 'replayloop', 'r')
		self.loop_mode = True
	except IOError:
		self.fd = file(LOGFILE % 'replay', 'r')
		self.loop_mode = False
else:
	self.fd.seek(0)
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75bd26c>}
nname: 110
n 110(None)[]:
	i: 21(), 109()
	o: 

nname: 109
n 109(None)[]:
	i: 0(f)
	o: 110()

nname: 21
n 21(None)[from pygui.shared import pygui_globs
ms = pygui_globs['menustack']
self._oom_fd.write('Memory problem at %s\n%s\nEOP\n' % (sched.ts, ms))
self._oom_fd.flush()
os.unlink(self._flag_name)
]:
	i: 0(t)
	o: 110()

nname: 0
n 0(os.path.exists(self._flag_name))[]:
	i: 
	o: 21(t), 109(f)

nname: 0
n 0(None)[if os.path.exists(self._flag_name):
	from pygui.shared import pygui_globs
	ms = pygui_globs['menustack']
	self._oom_fd.write('Memory problem at %s\n%s\nEOP\n' % (sched.ts, ms))
	self._oom_fd.flush()
	os.unlink(self._flag_name)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75b8fec>}
nname: 0
n 0(None)[self._running = False
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75b892c>}
nname: 356
n 356(None)[]:
	i: 73(AL), 354()
	o: 

nname: 354
n 354(None)[]:
	i: 76(f), 351()
	o: 356()

nname: 351
n 351(None)[]:
	i: 349(AE)
	o: 354()

nname: 349
n 349(None)[]:
	i: 304(f), 315()
	o: 351(AE)

nname: 315
n 315(None)[#, e
log.error('Error injecting keystroke %s: %s', event, str(e))
continue
]:
	i: 304(t)
	o: 349()

nname: 304
n 304(<dummy_ex3> EXC_MATCH Exception)[]:
	i: 271(f), 281()
	o: 315(t), 349(f)

nname: 281
n 281(None)[log.error('Event %s dropped because of a slowdown (queue is full)', event)
continue
]:
	i: 271(t)
	o: 304()

nname: 271
n 271(<dummy_ex3> EXC_MATCH Full)[]:
	i: 183(except), 254()
	o: 281(t), 304(f)

nname: 254
n 254(None)[self.handler(event)
continue
]:
	i: 183(try)
	o: 271()

nname: 183
n 183(None)[ts, event = line.split(':', 1)
ts = float(ts)
event = event.strip()
sleep(ts)
self._check_oom()
]:
	i: 175(), 182()
	o: 254(try), 271(except)

nname: 182
n 182(None)[]:
	i: 140&159(f)
	o: 183()

nname: 175
n 175(None)[continue
]:
	i: 140&159(t)
	o: 183()

nname: 140&159
n 140&159(not line or line.startswith('#'))[line = raw_line.strip()
]:
	i: 117(JA), 134(), 139()
	o: 175(t), 182(f)

nname: 139
n 139(None)[]:
	i: 85(t)
	o: 140&159()

nname: 134
n 134(None)[break
]:
	i: 107(f)
	o: 140&159()

nname: 117
n 117(None)[self.init()
continue
]:
	i: 107(t)
	o: 140&159(JA)

nname: 107
n 107(self.loop_mode)[]:
	i: 85(f)
	o: 117(t), 134(f)

nname: 85
n 85(raw_line)[raw_line = self.fd.readline()
]:
	i: 76(t)
	o: 107(f), 139(t)

nname: 76
n 76(self._running)[]:
	i: 73(loop)
	o: 85(t), 354(f)

nname: 73
n 73(None)[]:
	i: 12(), 36(), 71(AE)
	o: 76(loop), 356(AL)

nname: 71
n 71(None)[]:
	i: 26(f)
	o: 73(AE)

nname: 36
n 36(None)[#, e
log.error("Can't replay: %s", str(e))
]:
	i: 26(t)
	o: 73()

nname: 26
n 26(<dummy_ex3> EXC_MATCH Exception)[]:
	i: 0(except)
	o: 36(t), 71(f)

nname: 12
n 12(None)[self.init()
]:
	i: 0(try)
	o: 73()

nname: 0
n 0(None)[self._running = True
]:
	i: 
	o: 12(try), 26(except)

nname: 356
n 356(None)[]:
	i: 26(AL), 76(f), 349(AE)
	o: 

nname: 349
n 349(None)[]:
	i: 271(f)
	o: 356(AE)

nname: 271
n 271(None)[except Full:
	log.error('Event %s dropped because of a slowdown (queue is full)', event)
	continue
except Exception, e:
	log.error('Error injecting keystroke %s: %s', event, str(e))
	continue
]:
	i: 183()
	o: 349()

nname: 183
n 183(None)[ts, event = line.split(':', 1)
ts = float(ts)
event = event.strip()
sleep(ts)
self._check_oom()
try:
	self.handler(event)
	continue
]:
	i: 85()
	o: 271()

nname: 85
n 85(None)[raw_line = self.fd.readline()
if not raw_line:
	if self.loop_mode:
		self.init()
		continue
	else:
		break
line = raw_line.strip()
if not line or line.startswith('#'):
	continue
]:
	i: 76(t)
	o: 183()

nname: 76
n 76(self._running)[]:
	i: 26(loop)
	o: 85(t), 356(f)

nname: 26
n 26(None)[except Exception, e:
	log.error("Can't replay: %s", str(e))
]:
	i: 0()
	o: 76(loop), 356(AL)

nname: 0
n 0(None)[self._running = True
try:
	self.init()
]:
	i: 
	o: 26()

nname: 356
n 356(None)[]:
	i: 0(AL), 76(f), 271(AE)
	o: 

nname: 271
n 271(None)[except Full:
	log.error('Event %s dropped because of a slowdown (queue is full)', event)
	continue
except Exception, e:
	log.error('Error injecting keystroke %s: %s', event, str(e))
	continue
]:
	i: 85()
	o: 356(AE)

nname: 85
n 85(None)[raw_line = self.fd.readline()
if not raw_line:
	if self.loop_mode:
		self.init()
		continue
	else:
		break
line = raw_line.strip()
if not line or line.startswith('#'):
	continue
ts, event = line.split(':', 1)
ts = float(ts)
event = event.strip()
sleep(ts)
self._check_oom()
try:
	self.handler(event)
	continue
]:
	i: 76(t)
	o: 271()

nname: 76
n 76(self._running)[]:
	i: 0(loop)
	o: 85(t), 356(f)

nname: 0
n 0(None)[self._running = True
try:
	self.init()
except Exception, e:
	log.error("Can't replay: %s", str(e))
]:
	i: 
	o: 76(loop), 356(AL)

nname: 356
n 356(None)[]:
	i: 0(AL), 76(f), 85(AE)
	o: 

nname: 85
n 85(None)[raw_line = self.fd.readline()
if not raw_line:
	if self.loop_mode:
		self.init()
		continue
	else:
		break
line = raw_line.strip()
if not line or line.startswith('#'):
	continue
ts, event = line.split(':', 1)
ts = float(ts)
event = event.strip()
sleep(ts)
self._check_oom()
try:
	self.handler(event)
	continue
except Full:
	log.error('Event %s dropped because of a slowdown (queue is full)', event)
	continue
except Exception, e:
	log.error('Error injecting keystroke %s: %s', event, str(e))
	continue
]:
	i: 76(t)
	o: 356(AE)

nname: 76
n 76(self._running)[]:
	i: 0(loop)
	o: 85(t), 356(f)

nname: 0
n 0(None)[self._running = True
try:
	self.init()
except Exception, e:
	log.error("Can't replay: %s", str(e))
]:
	i: 
	o: 76(loop), 356(AL)

self.nodes: {0: <unpyclib.structure.node instance at 0xb75cc4ec>, 76: <unpyclib.structure.node instance at 0xb75c15ac>, 85: <unpyclib.structure.node instance at 0xb75cc14c>, 356: <unpyclib.structure.node instance at 0xb75c1a8c>}
nname: 6
n 6(None)[def __init__(self, handler, logfile=None, loop=False):
	Thread.__init__(self)
	self.handler = handler
	self._flag_name = '/tmp/oom.flag'
	if logfile:
		def self._check_oom(*args, **args):
			return None

		self.fd = file(logfile, 'r')
		self.loop_mode = bool(loop)
	else:
		self._oom_fd = file(LOGFILE % 'oom', 'w')
		self.fd = None
	self.setDaemon(True)
	try:
		os.unlink(self._flag_name)
	except OSError:
		pass
	return None

def init(self):
	if self.fd is None:
		try:
			self.fd = file(LOGFILE % 'replayloop', 'r')
			self.loop_mode = True
		except IOError:
			self.fd = file(LOGFILE % 'replay', 'r')
			self.loop_mode = False
	else:
		self.fd.seek(0)
	return None

def _check_oom(self):
	if os.path.exists(self._flag_name):
		from pygui.shared import pygui_globs
		ms = pygui_globs['menustack']
		self._oom_fd.write('Memory problem at %s\n%s\nEOP\n' % (sched.ts, ms))
		self._oom_fd.flush()
		os.unlink(self._flag_name)

def stop(self):
	self._running = False

def run(self):
	self._running = True
	try:
		self.init()
	except Exception, e:
		log.error("Can't replay: %s", str(e))

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75b866c>}
nname: 0
n 0(None)[from __future__ import absolute_import
from Queue import Full
from threading import Thread
from time import sleep
from pygui.config import TMP_DIR
from peewee.debug import log
from peewee.notifier import sched
from pygui.window import MessageWindow
import os
LOGFILE = TMP_DIR + '/hmi_events.%s'
class EventLogger(object):
	def __init__(self):
		self.rotate()
		self.fd = file(LOGFILE % 'record-%d' % int(sched.ts), 'w')
		self._last_ts = sched.ts

	def rotate(self):
		from glob import glob
		from os import unlink
		flist = glob(LOGFILE % 'record-*')
		flist.sort()
		for fname in flist[:-10]:
			try:
				unlink(fname)
				flist.remove(fname)
				continue
			except (IOError, OSError):
				log.error("*WARN* can't remove %s", fname)
				continue

	def add(self, event, args={}):
		ts = sched.ts - self._last_ts
		self._last_ts = sched.ts
		self.fd.write('%f:%s\n' % (ts, event))
		self.fd.flush()



class EventPlayer(Thread):
	def __init__(self, handler, logfile=None, loop=False):
		Thread.__init__(self)
		self.handler = handler
		self._flag_name = '/tmp/oom.flag'
		if logfile:
			def self._check_oom(*args, **args):
				return None

			self.fd = file(logfile, 'r')
			self.loop_mode = bool(loop)
		else:
			self._oom_fd = file(LOGFILE % 'oom', 'w')
			self.fd = None
		self.setDaemon(True)
		try:
			os.unlink(self._flag_name)
		except OSError:
			pass
		return None

	def init(self):
		if self.fd is None:
			try:
				self.fd = file(LOGFILE % 'replayloop', 'r')
				self.loop_mode = True
			except IOError:
				self.fd = file(LOGFILE % 'replay', 'r')
				self.loop_mode = False
		else:
			self.fd.seek(0)
		return None

	def _check_oom(self):
		if os.path.exists(self._flag_name):
			from pygui.shared import pygui_globs
			ms = pygui_globs['menustack']
			self._oom_fd.write('Memory problem at %s\n%s\nEOP\n' % (sched.ts, ms))
			self._oom_fd.flush()
			os.unlink(self._flag_name)

	def stop(self):
		self._running = False

	def run(self):
		self._running = True
		try:
			self.init()
		except Exception, e:
			log.error("Can't replay: %s", str(e))



]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75b082c>}
from __future__ import absolute_import
from Queue import Full
from threading import Thread
from time import sleep
from pygui.config import TMP_DIR
from peewee.debug import log
from peewee.notifier import sched
from pygui.window import MessageWindow
import os
LOGFILE = TMP_DIR + '/hmi_events.%s'
class EventLogger(object):
	def __init__(self):
		self.rotate()
		self.fd = file(LOGFILE % 'record-%d' % int(sched.ts), 'w')
		self._last_ts = sched.ts

	def rotate(self):
		from glob import glob
		from os import unlink
		flist = glob(LOGFILE % 'record-*')
		flist.sort()
		for fname in flist[:-10]:
			try:
				unlink(fname)
				flist.remove(fname)
				continue
			except (IOError, OSError):
				log.error("*WARN* can't remove %s", fname)
				continue

	def add(self, event, args={}):
		ts = sched.ts - self._last_ts
		self._last_ts = sched.ts
		self.fd.write('%f:%s\n' % (ts, event))
		self.fd.flush()



class EventPlayer(Thread):
	def __init__(self, handler, logfile=None, loop=False):
		Thread.__init__(self)
		self.handler = handler
		self._flag_name = '/tmp/oom.flag'
		if logfile:
			def self._check_oom(*args, **args):
				return None

			self.fd = file(logfile, 'r')
			self.loop_mode = bool(loop)
		else:
			self._oom_fd = file(LOGFILE % 'oom', 'w')
			self.fd = None
		self.setDaemon(True)
		try:
			os.unlink(self._flag_name)
		except OSError:
			pass
		return None

	def init(self):
		if self.fd is None:
			try:
				self.fd = file(LOGFILE % 'replayloop', 'r')
				self.loop_mode = True
			except IOError:
				self.fd = file(LOGFILE % 'replay', 'r')
				self.loop_mode = False
		else:
			self.fd.seek(0)
		return None

	def _check_oom(self):
		if os.path.exists(self._flag_name):
			from pygui.shared import pygui_globs
			ms = pygui_globs['menustack']
			self._oom_fd.write('Memory problem at %s\n%s\nEOP\n' % (sched.ts, ms))
			self._oom_fd.flush()
			os.unlink(self._flag_name)

	def stop(self):
		self._running = False

	def run(self):
		self._running = True
		try:
			self.init()
		except Exception, e:
			log.error("Can't replay: %s", str(e))



