# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 0
n 0(None)[self._UIButton__ui_real_object = contained
self._is_selected = selected
self._caption = caption
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75976ac>}
nname: 0
n 0(None)[return getattr(self._UIButton__ui_real_object, attr)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb759754c>}
nname: 55
n 55(None)[]:
	i: 12(), 35()
	o: 

nname: 35
n 35(None)[setattr(self._UIButton__ui_real_object, attr, value)
]:
	i: 0(f)
	o: 55()

nname: 12
n 12(None)[object.__setattr__(self, attr, value)
]:
	i: 0(t)
	o: 55()

nname: 0
n 0(attr != 'parent')[]:
	i: 
	o: 12(t), 35(f)

nname: 0
n 0(None)[if attr != 'parent':
	object.__setattr__(self, attr, value)
else:
	setattr(self._UIButton__ui_real_object, attr, value)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb759790c>}
nname: 0
n 0(None)[return cmp(self._UIButton__ui_real_object, o)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75973cc>}
nname: 0
n 0(None)[return self._UIButton__ui_real_object == o
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75973ac>}
nname: 0
n 0(None)[return hash(self._UIButton__ui_real_object)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb759754c>}
nname: 0
n 0(None)[self._caption = caption
self.get_obj_by_name('text').set_text(caption)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75976ac>}
nname: 46
n 46(None)[return None
]:
	i: 21(), 29()
	o: 

nname: 29
n 29(None)[return wid.unparent(*args, **kw)
]:
	i: 0(f)
	o: 46()

nname: 21
n 21(None)[return None
]:
	i: 0(t)
	o: 46()

nname: 0
n 0(wid is None)[wid = self._UIButton__ui_real_object
]:
	i: 
	o: 21(t), 29(f)

nname: 0
n 0(None)[wid = self._UIButton__ui_real_object
if wid is None:
	return None
else:
	return wid.unparent(*args, **kw)
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb759764c>}
nname: 6
n 6(None)[def __init__(self, contained=None, selected=False, caption=''):
	self._UIButton__ui_real_object = contained
	self._is_selected = selected
	self._caption = caption

def __getattr__(self, attr):
	return getattr(self._UIButton__ui_real_object, attr)

def __setattr__(self, attr, value):
	if attr != 'parent':
		object.__setattr__(self, attr, value)
	else:
		setattr(self._UIButton__ui_real_object, attr, value)

def __cmp__(self, o):
	return cmp(self._UIButton__ui_real_object, o)

def __eq__(self, o):
	return self._UIButton__ui_real_object == o

def __hash__(self, o):
	return hash(self._UIButton__ui_real_object)

def _set_caption(self, caption):
	self._caption = caption
	self.get_obj_by_name('text').set_text(caption)

def unparent(self, *args, **args):
	wid = self._UIButton__ui_real_object
	if wid is None:
		return None
	else:
		return wid.unparent(*args, **kw)
	return None

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb758dd6c>}
nname: 57
n 57(None)[]:
	i: 3(), 48(), 55(AE)
	o: 

nname: 55
n 55(None)[]:
	i: 38(f)
	o: 57(AE)

nname: 48
n 48(None)[]:
	i: 38(t)
	o: 57()

nname: 38
n 38(<dummy_ex3> EXC_MATCH AttributeError)[]:
	i: 0(except)
	o: 48(t), 55(f)

nname: 3
n 3(None)[self._window.get_obj_by_name('text').set_text(self.win.text)
]:
	i: 0(try)
	o: 57()

nname: 0
n 0(None)[]:
	i: 
	o: 3(try), 38(except)

nname: 38
n 38(None)[except AttributeError:
	pass
]:
	i: 0()
	o: 

nname: 0
n 0(None)[try:
	self._window.get_obj_by_name('text').set_text(self.win.text)
]:
	i: 
	o: 38()

nname: 0
n 0(None)[try:
	self._window.get_obj_by_name('text').set_text(self.win.text)
except AttributeError:
	pass
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75970ec>}
nname: 6
n 6(None)[def update(self, *args, **args):
	try:
		self._window.get_obj_by_name('text').set_text(self.win.text)
	except AttributeError:
		pass

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb758da4c>}
nname: 0
n 0(None)[self._window.get_obj_by_name('text').set_text(self.win.text)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb758decc>}
nname: 6
n 6(None)[def update(self, *args, **args):
	self._window.get_obj_by_name('text').set_text(self.win.text)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb758d9ac>}
nname: 0
n 0(None)[wid = self._window
wid.get_obj_by_name('text').set_text(self.win.text)
wid.get_obj_by_name('title').set_text(self.win.title)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb758df2c>}
nname: 6
n 6(None)[def update(self, *args, **args):
	wid = self._window
	wid.get_obj_by_name('text').set_text(self.win.text)
	wid.get_obj_by_name('title').set_text(self.win.title)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb758daac>}
nname: 0
n 0(None)[TextWindow.__init__(self, *args, **kw)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb758dc8c>}
nname: 62
n 62(None)[but = UIButton(self._widget_library.get_container(self.type, prefix + state), selected=button.selected, caption=button.name)
but.get_obj_by_name('text').set_text(button.name)
return but
]:
	i: 38(), 61()
	o: 

nname: 61
n 61(None)[]:
	i: 20(f)
	o: 62()

nname: 38
n 38(None)[prefix = '%s_%s' % (button.type, prefix)
]:
	i: 20(t)
	o: 62()

nname: 20
n 20(button.type)[state = 'not_selected'
prefix = 'button_'
]:
	i: 0&9(t), 16()
	o: 38(t), 61(f)

nname: 16
n 16(None)[]:
	i: 0&9(f)
	o: 20()

nname: 0&9
n 0&9(button.selected and 'selected')[]:
	i: 
	o: 16(f), 20(t)

nname: 0&9
n 0&9(None)[if not(button.selected and 'selected'):
	pass
state = 'not_selected'
prefix = 'button_'
if button.type:
	prefix = '%s_%s' % (button.type, prefix)
but = UIButton(self._widget_library.get_container(self.type, prefix + state), selected=button.selected, caption=button.name)
but.get_obj_by_name('text').set_text(button.name)
return but
]:
	i: 
	o: 

self.nodes: {'0&9': <unpyclib.structure.node instance at 0xb759748c>}
nname: 81
n 81(None)[return wid
]:
	i: 33(), 80()
	o: 

nname: 80
n 80(None)[]:
	i: 0(f)
	o: 81()

nname: 33
n 33(None)[but = self.button2widget(win.button)
wid.add_child(but, hcenter='50%', top='80%')
]:
	i: 0(t)
	o: 81()

nname: 0
n 0(win.button is not None)[wid = TextWindow.create_content(self, win)
]:
	i: 
	o: 33(t), 80(f)

nname: 0
n 0(None)[wid = TextWindow.create_content(self, win)
if win.button is not None:
	but = self.button2widget(win.button)
	wid.add_child(but, hcenter='50%', top='80%')
return wid
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb759718c>}
nname: 6
n 6(None)[def __init__(self, *args, **args):
	TextWindow.__init__(self, *args, **kw)

def button2widget(self, button):
	if not(button.selected and 'selected'):
		pass
	state = 'not_selected'
	prefix = 'button_'
	if button.type:
		prefix = '%s_%s' % (button.type, prefix)
	but = UIButton(self._widget_library.get_container(self.type, prefix + state), selected=button.selected, caption=button.name)
	but.get_obj_by_name('text').set_text(button.name)
	return but

def create_content(self, win):
	wid = TextWindow.create_content(self, win)
	if win.button is not None:
		but = self.button2widget(win.button)
		wid.add_child(but, hcenter='50%', top='80%')
	return wid

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb758ddcc>}
nname: 0
n 0(None)[wid = Window.create_content(self, win)
self._wid_title = wid.get_obj_by_name('title')
self._wid_description = wid.get_obj_by_name('description')
self._wid_progress = wid.get_obj_by_name('progressbar')
self._wid_total = wid.get_obj_by_name('total')
self._wid_elapsed = wid.get_obj_by_name('elapsed')
self._wid_remaining = wid.get_obj_by_name('remaining')
return wid
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7597fec>}
nname: 0
n 0(None)[win = self.win
self._wid_progress.set(pos=win.progress)
self._wid_title.set_text(win.title)
self._wid_description.set_text(win.description)
self._wid_total.set_text(win.total)
self._wid_elapsed.set_text(win.elapsed)
self._wid_remaining.set_text(win.remaining)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb759734c>}
nname: 6
n 6(None)[def create_content(self, win):
	wid = Window.create_content(self, win)
	self._wid_title = wid.get_obj_by_name('title')
	self._wid_description = wid.get_obj_by_name('description')
	self._wid_progress = wid.get_obj_by_name('progressbar')
	self._wid_total = wid.get_obj_by_name('total')
	self._wid_elapsed = wid.get_obj_by_name('elapsed')
	self._wid_remaining = wid.get_obj_by_name('remaining')
	return wid

def update(self, *args, **args):
	win = self.win
	self._wid_progress.set(pos=win.progress)
	self._wid_title.set_text(win.title)
	self._wid_description.set_text(win.description)
	self._wid_total.set_text(win.total)
	self._wid_elapsed.set_text(win.elapsed)
	self._wid_remaining.set_text(win.remaining)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb758da8c>}
nname: 0
n 0(None)[wid = Window.create_content(self, win)
self._wid_progress = wid.get_obj_by_name('progressbar')
self._wid_icon = wid.get_obj_by_name('volume_icon')
return wid
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb758df0c>}
nname: 0
n 0(None)[win = self.win
self._wid_progress.set(pos=win.progress)
self._wid_icon.load(win.icon)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb758df0c>}
nname: 6
n 6(None)[def create_content(self, win):
	wid = Window.create_content(self, win)
	self._wid_progress = wid.get_obj_by_name('progressbar')
	self._wid_icon = wid.get_obj_by_name('volume_icon')
	return wid

def update(self, *args, **args):
	win = self.win
	self._wid_progress.set(pos=win.progress)
	self._wid_icon.load(win.icon)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb758dfec>}
nname: 0
n 0(None)[wid = Window.create_content(self, win)
self._wid_icon = wid.get_obj_by_name('volume_icon')
return wid
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb758de8c>}
nname: 0
n 0(None)[win = self.win
self._wid_icon.load(win.icon)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb758de8c>}
nname: 6
n 6(None)[def create_content(self, win):
	wid = Window.create_content(self, win)
	self._wid_icon = wid.get_obj_by_name('volume_icon')
	return wid

def update(self, *args, **args):
	win = self.win
	self._wid_icon.load(win.icon)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb758dc0c>}
nname: 102
n 102(None)[return wid
]:
	i: 84(), 101()
	o: 

nname: 101
n 101(None)[]:
	i: 78(f)
	o: 102()

nname: 84
n 84(None)[self._sync_ui(wid)
]:
	i: 78(t)
	o: 102()

nname: 78
n 78(sync_ui)[]:
	i: 0(AL), 77()
	o: 84(t), 101(f)

nname: 77
n 77(None)[]:
	i: 30(AF), 40()
	o: 78()

nname: 40
n 40(None)[for button in win.buttons:
but = self.button2widget(button)
self.buttons.append(but)
]:
	i: 30(for)
	o: 77()

nname: 30
n 30(None)[]:
	i: 0(loop)
	o: 40(for), 77(AF)

nname: 0
n 0(None)[wid = TextWindow.create_content(self, win)
self.buttons = []
]:
	i: 
	o: 30(loop), 78(AL)

nname: 78
n 78(None)[if sync_ui:
	self._sync_ui(wid)
return wid
]:
	i: 40()
	o: 

nname: 40
n 40(None)[for button in win.buttons:
	but = self.button2widget(button)
	self.buttons.append(but)
]:
	i: 0(for)
	o: 78()

nname: 0
n 0(None)[wid = TextWindow.create_content(self, win)
self.buttons = []
]:
	i: 
	o: 40(for)

nname: 78
n 78(None)[if sync_ui:
	self._sync_ui(wid)
return wid
]:
	i: 0()
	o: 

nname: 0
n 0(None)[wid = TextWindow.create_content(self, win)
self.buttons = []
for button in win.buttons:
	but = self.button2widget(button)
	self.buttons.append(but)
]:
	i: 
	o: 78()

nname: 0
n 0(None)[wid = TextWindow.create_content(self, win)
self.buttons = []
for button in win.buttons:
	but = self.button2widget(button)
	self.buttons.append(but)
if sync_ui:
	self._sync_ui(wid)
return wid
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7597b6c>}
nname: 122
n 122(None)[]:
	i: 22(AL), 121()
	o: 

nname: 121
n 121(None)[]:
	i: 54(AF), 61()
	o: 122()

nname: 61
n 61(None)[for but in new_buttons:
but_idx = my_buts.index(but)
wid.add_child(but, width=width, left='%d%%' % but_idx * but_space, top='90%')
]:
	i: 54(for)
	o: 121()

nname: 54
n 54(None)[]:
	i: 22(loop)
	o: 61(for), 121(AF)

nname: 22
n 22(None)[wid = wid
but_space = 100 / len(my_buts)
width = '%d%%' % but_space
]:
	i: 0(t), 15()
	o: 54(loop), 122(AL)

nname: 15
n 15(None)[]:
	i: 0(f)
	o: 22()

nname: 0
n 0(wid)[my_buts = self.buttons
]:
	i: 
	o: 15(f), 22(t)

nname: 121
n 121(None)[]:
	i: 54()
	o: 

nname: 54
n 54(None)[for but in new_buttons:
	but_idx = my_buts.index(but)
	wid.add_child(but, width=width, left='%d%%' % but_idx * but_space, top='90%')
]:
	i: 0(loop)
	o: 121()

nname: 0
n 0(None)[my_buts = self.buttons
if not wid:
	pass
wid = wid
but_space = 100 / len(my_buts)
width = '%d%%' % but_space
]:
	i: 
	o: 54(loop)

nname: 121
n 121(None)[]:
	i: 0()
	o: 

nname: 0
n 0(None)[my_buts = self.buttons
if not wid:
	pass
wid = wid
but_space = 100 / len(my_buts)
width = '%d%%' % but_space
for but in new_buttons:
	but_idx = my_buts.index(but)
	wid.add_child(but, width=width, left='%d%%' % but_idx * but_space, top='90%')
]:
	i: 
	o: 121()

nname: 0
n 0(None)[my_buts = self.buttons
if not wid:
	pass
wid = wid
but_space = 100 / len(my_buts)
width = '%d%%' % but_space
for but in new_buttons:
	but_idx = my_buts.index(but)
	wid.add_child(but, width=width, left='%d%%' % but_idx * but_space, top='90%')
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7597e6c>}
nname: 576
n 576(None)[wid.get_obj_by_name('text').set_text(text)
]:
	i: 553(JA), 571(), 575()
	o: 

nname: 575
n 575(None)[]:
	i: 388(f)
	o: 576()

nname: 571
n 571(None)[]:
	i: 513(f)
	o: 576()

nname: 553
n 553(None)[text = HMI_BASE['keyboard_truncate_prefix'] + text
]:
	i: 513(t)
	o: 576(JA)

nname: 513
n 513(start != 0)[text = text[start:cursor_pos] + '//CURSOR//' + text[cursor_pos:end]
]:
	i: 483(), 506()
	o: 553(t), 571(f)

nname: 506
n 506(None)[end = lt
]:
	i: 421(f)
	o: 513()

nname: 483
n 483(None)[end = min(lt, start + WIDTH)
]:
	i: 421(t)
	o: 513()

nname: 421
n 421(lt > WIDTH)[WIDTH = 25
lt = len(text)
cursor_pos = self.win._text_cursor_pos
start = max(0, cursor_pos - WIDTH)
]:
	i: 388(t)
	o: 483(t), 506(f)

nname: 388
n 388(hasattr(self.win, '_text_cursor_pos'))[wid = wid
text = self.win.text
]:
	i: 359(t), 381()
	o: 421(t), 575(f)

nname: 381
n 381(None)[]:
	i: 359(f)
	o: 388()

nname: 359
n 359(wid)[self._draw_buttons(new_buttons, wid)
]:
	i: 21(), 206(AL), 358()
	o: 381(f), 388(t)

nname: 358
n 358(None)[]:
	i: 209(AF), 354()
	o: 359()

nname: 354
n 354(None)[]:
	i: 315(f), 334()
	o: 358()

nname: 334
n 334(None)[view_but._set_caption(model_but.name)
continue
]:
	i: 315(t)
	o: 354()

nname: 315
n 315(model_but.name != view_but._caption)[]:
	i: 222(f), 263()
	o: 334(t), 354(f)

nname: 263
n 263(None)[view_but.unparent()
but = self.button2widget(model_but)
my_buts[but_idx] = but
new_buttons.append(but)
continue
]:
	i: 222(t)
	o: 315()

nname: 222
n 222(model_but.selected != view_but._is_selected)[for but_idx in range(nb_items):
model_but = win_buts[but_idx]
view_but = my_buts[but_idx]
]:
	i: 209(for)
	o: 263(t), 315(f)

nname: 209
n 209(None)[]:
	i: 206(loop)
	o: 222(for), 358(AF)

nname: 206
n 206(None)[]:
	i: 86(AL), 135(), 158(AL), 201(), 205()
	o: 209(loop), 359(AL)

nname: 205
n 205(None)[]:
	i: 139(f)
	o: 206()

nname: 201
n 201(None)[]:
	i: 162(AF), 185()
	o: 206()

nname: 185
n 185(None)[for n in range(len(my_buts) - nb_items):
my_buts.pop()
]:
	i: 162(for)
	o: 201()

nname: 162
n 162(None)[]:
	i: 158(loop)
	o: 185(for), 201(AF)

nname: 158
n 158(None)[]:
	i: 139(t)
	o: 162(loop), 206(AL)

nname: 139
n 139(len(my_buts) > nb_items)[]:
	i: 31(f)
	o: 158(t), 205(f)

nname: 135
n 135(None)[]:
	i: 90(AF), 113()
	o: 206()

nname: 113
n 113(None)[for n in range(nb_items - len(my_buts)):
my_buts.append(UIButton())
]:
	i: 90(for)
	o: 135()

nname: 90
n 90(None)[]:
	i: 86(loop)
	o: 113(for), 135(AF)

nname: 86
n 86(None)[]:
	i: 31(t)
	o: 90(loop), 206(AL)

nname: 31
n 31(len(my_buts) < nb_items)[win_buts = self.win.buttons
but_idx = 0
nb_items = len(self.win.buttons)
]:
	i: 0(f)
	o: 86(t), 139(f)

nname: 21
n 21(None)[new_buttons = my_buts
]:
	i: 0(t)
	o: 359()

nname: 0
n 0(wid)[new_buttons = []
my_buts = self.buttons
]:
	i: 
	o: 21(t), 31(f)

nname: 576
n 576(None)[wid.get_obj_by_name('text').set_text(text)
]:
	i: 421(JA), 359(f)
	o: 

nname: 421
n 421(None)[WIDTH = 25
lt = len(text)
cursor_pos = self.win._text_cursor_pos
start = max(0, cursor_pos - WIDTH)
if lt > WIDTH:
	end = min(lt, start + WIDTH)
else:
	end = lt
text = text[start:cursor_pos] + '//CURSOR//' + text[cursor_pos:end]
if start != 0:
	text = HMI_BASE['keyboard_truncate_prefix'] + text
]:
	i: 359(t)
	o: 576(JA)

nname: 359
n 359(hasattr(self.win, '_text_cursor_pos'))[self._draw_buttons(new_buttons, wid)
if not wid:
	pass
wid = wid
text = self.win.text
]:
	i: 21(), 206(AL), 209(AF), 222(f)
	o: 421(t), 576(f)

nname: 222
n 222(None)[for but_idx in range(nb_items):
model_but = win_buts[but_idx]
view_but = my_buts[but_idx]
if model_but.selected != view_but._is_selected:
	view_but.unparent()
	but = self.button2widget(model_but)
	my_buts[but_idx] = but
	new_buttons.append(but)
	continue
if model_but.name != view_but._caption:
	view_but._set_caption(model_but.name)
	continue
]:
	i: 209(for)
	o: 359()

nname: 209
n 209(None)[]:
	i: 206(loop)
	o: 222(for), 359(AF)

nname: 206
n 206(None)[]:
	i: 113(), 185(), 139(f)
	o: 209(loop), 359(AL)

nname: 185
n 185(None)[for n in range(len(my_buts) - nb_items):
	my_buts.pop()
]:
	i: 158(for)
	o: 206()

nname: 158
n 158(None)[]:
	i: 139(t)
	o: 185(for)

nname: 139
n 139(len(my_buts) > nb_items)[]:
	i: 31(f)
	o: 158(t), 206(f)

nname: 113
n 113(None)[for n in range(nb_items - len(my_buts)):
	my_buts.append(UIButton())
]:
	i: 86(for)
	o: 206()

nname: 86
n 86(None)[]:
	i: 31(t)
	o: 113(for)

nname: 31
n 31(len(my_buts) < nb_items)[win_buts = self.win.buttons
but_idx = 0
nb_items = len(self.win.buttons)
]:
	i: 0(f)
	o: 86(t), 139(f)

nname: 21
n 21(None)[new_buttons = my_buts
]:
	i: 0(t)
	o: 359()

nname: 0
n 0(wid)[new_buttons = []
my_buts = self.buttons
]:
	i: 
	o: 21(t), 31(f)

nname: 359
n 359(None)[self._draw_buttons(new_buttons, wid)
if not wid:
	pass
wid = wid
text = self.win.text
if hasattr(self.win, '_text_cursor_pos'):
	WIDTH = 25
	lt = len(text)
	cursor_pos = self.win._text_cursor_pos
	start = max(0, cursor_pos - WIDTH)
	if lt > WIDTH:
		end = min(lt, start + WIDTH)
	else:
		end = lt
	text = text[start:cursor_pos] + '//CURSOR//' + text[cursor_pos:end]
	if start != 0:
		text = HMI_BASE['keyboard_truncate_prefix'] + text
wid.get_obj_by_name('text').set_text(text)
]:
	i: 21(), 222(f)
	o: 

nname: 222
n 222(None)[for but_idx in range(nb_items):
	model_but = win_buts[but_idx]
	view_but = my_buts[but_idx]
	if model_but.selected != view_but._is_selected:
		view_but.unparent()
		but = self.button2widget(model_but)
		my_buts[but_idx] = but
		new_buttons.append(but)
		continue
	if model_but.name != view_but._caption:
		view_but._set_caption(model_but.name)
		continue
]:
	i: 206(for)
	o: 359()

nname: 206
n 206(None)[]:
	i: 86(), 158(), 139(f)
	o: 222(for)

nname: 158
n 158(None)[for n in range(len(my_buts) - nb_items):
	my_buts.pop()
]:
	i: 139(t)
	o: 206()

nname: 139
n 139(len(my_buts) > nb_items)[]:
	i: 31(f)
	o: 158(t), 206(f)

nname: 86
n 86(None)[for n in range(nb_items - len(my_buts)):
	my_buts.append(UIButton())
]:
	i: 31(t)
	o: 206()

nname: 31
n 31(len(my_buts) < nb_items)[win_buts = self.win.buttons
but_idx = 0
nb_items = len(self.win.buttons)
]:
	i: 0(f)
	o: 86(t), 139(f)

nname: 21
n 21(None)[new_buttons = my_buts
]:
	i: 0(t)
	o: 359()

nname: 0
n 0(wid)[new_buttons = []
my_buts = self.buttons
]:
	i: 
	o: 21(t), 31(f)

nname: 359
n 359(None)[self._draw_buttons(new_buttons, wid)
if not wid:
	pass
wid = wid
text = self.win.text
if hasattr(self.win, '_text_cursor_pos'):
	WIDTH = 25
	lt = len(text)
	cursor_pos = self.win._text_cursor_pos
	start = max(0, cursor_pos - WIDTH)
	if lt > WIDTH:
		end = min(lt, start + WIDTH)
	else:
		end = lt
	text = text[start:cursor_pos] + '//CURSOR//' + text[cursor_pos:end]
	if start != 0:
		text = HMI_BASE['keyboard_truncate_prefix'] + text
wid.get_obj_by_name('text').set_text(text)
]:
	i: 21(), 222(f)
	o: 

nname: 222
n 222(None)[for but_idx in range(nb_items):
	model_but = win_buts[but_idx]
	view_but = my_buts[but_idx]
	if model_but.selected != view_but._is_selected:
		view_but.unparent()
		but = self.button2widget(model_but)
		my_buts[but_idx] = but
		new_buttons.append(but)
		continue
	if model_but.name != view_but._caption:
		view_but._set_caption(model_but.name)
		continue
]:
	i: 31(for)
	o: 359()

nname: 31
n 31(None)[win_buts = self.win.buttons
but_idx = 0
nb_items = len(self.win.buttons)
if len(my_buts) < nb_items:
	for n in range(nb_items - len(my_buts)):
		my_buts.append(UIButton())
else:
	if len(my_buts) > nb_items:
		for n in range(len(my_buts) - nb_items):
			my_buts.pop()
]:
	i: 0(f)
	o: 222(for)

nname: 21
n 21(None)[new_buttons = my_buts
]:
	i: 0(t)
	o: 359()

nname: 0
n 0(wid)[new_buttons = []
my_buts = self.buttons
]:
	i: 
	o: 21(t), 31(f)

nname: 359
n 359(None)[self._draw_buttons(new_buttons, wid)
if not wid:
	pass
wid = wid
text = self.win.text
if hasattr(self.win, '_text_cursor_pos'):
	WIDTH = 25
	lt = len(text)
	cursor_pos = self.win._text_cursor_pos
	start = max(0, cursor_pos - WIDTH)
	if lt > WIDTH:
		end = min(lt, start + WIDTH)
	else:
		end = lt
	text = text[start:cursor_pos] + '//CURSOR//' + text[cursor_pos:end]
	if start != 0:
		text = HMI_BASE['keyboard_truncate_prefix'] + text
wid.get_obj_by_name('text').set_text(text)
]:
	i: 21(), 31(f)
	o: 

nname: 31
n 31(None)[win_buts = self.win.buttons
but_idx = 0
nb_items = len(self.win.buttons)
if len(my_buts) < nb_items:
	for n in range(nb_items - len(my_buts)):
		my_buts.append(UIButton())
else:
	if len(my_buts) > nb_items:
		for n in range(len(my_buts) - nb_items):
			my_buts.pop()
for but_idx in range(nb_items):
	model_but = win_buts[but_idx]
	view_but = my_buts[but_idx]
	if model_but.selected != view_but._is_selected:
		view_but.unparent()
		but = self.button2widget(model_but)
		my_buts[but_idx] = but
		new_buttons.append(but)
		continue
	if model_but.name != view_but._caption:
		view_but._set_caption(model_but.name)
		continue
]:
	i: 0(f)
	o: 359()

nname: 21
n 21(None)[new_buttons = my_buts
]:
	i: 0(t)
	o: 359()

nname: 0
n 0(wid)[new_buttons = []
my_buts = self.buttons
]:
	i: 
	o: 21(t), 31(f)

nname: 0
n 0(None)[new_buttons = []
my_buts = self.buttons
if wid:
	new_buttons = my_buts
else:
	win_buts = self.win.buttons
	but_idx = 0
	nb_items = len(self.win.buttons)
	if len(my_buts) < nb_items:
		for n in range(nb_items - len(my_buts)):
			my_buts.append(UIButton())
	else:
		if len(my_buts) > nb_items:
			for n in range(len(my_buts) - nb_items):
				my_buts.pop()
	for but_idx in range(nb_items):
		model_but = win_buts[but_idx]
		view_but = my_buts[but_idx]
		if model_but.selected != view_but._is_selected:
			view_but.unparent()
			but = self.button2widget(model_but)
			my_buts[but_idx] = but
			new_buttons.append(but)
			continue
		if model_but.name != view_but._caption:
			view_but._set_caption(model_but.name)
			continue
self._draw_buttons(new_buttons, wid)
if not wid:
	pass
wid = wid
text = self.win.text
if hasattr(self.win, '_text_cursor_pos'):
	WIDTH = 25
	lt = len(text)
	cursor_pos = self.win._text_cursor_pos
	start = max(0, cursor_pos - WIDTH)
	if lt > WIDTH:
		end = min(lt, start + WIDTH)
	else:
		end = lt
	text = text[start:cursor_pos] + '//CURSOR//' + text[cursor_pos:end]
	if start != 0:
		text = HMI_BASE['keyboard_truncate_prefix'] + text
wid.get_obj_by_name('text').set_text(text)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7597aac>}
nname: 45
n 45(None)[]:
	i: 37(AE)
	o: 

nname: 37
n 37(None)[del _[1]
]:
	i: 0(finally), 20()
	o: 45(AE)

nname: 20
n 20(None)[self._sync_ui(wid)
]:
	i: 0(ASF)
	o: 37()

nname: 0
n 0(None)[render_lock.__enter__()
]:
	i: 
	o: 20(ASF), 37(finally)

nname: 37
n 37(None)[finally:
	del _[1]
]:
	i: 0()
	o: 

nname: 0
n 0(None)[render_lock.__enter__()
try:
	self._sync_ui(wid)
]:
	i: 
	o: 37()

nname: 0
n 0(None)[render_lock.__enter__()
try:
	self._sync_ui(wid)
finally:
	del _[1]
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb759e14c>}
nname: 45
n 45(None)[return MessageWindow.hide(self)
]:
	i: 3(), 38(), 44(AE)
	o: 

nname: 38
n 38(None)[]:
	i: 0(except)
	o: 45()

nname: 3
n 3(None)[self._window.get_obj_by_name('text').set_text(self.win.text)
]:
	i: 0(try)
	o: 45()

nname: 0
n 0(None)[]:
	i: 
	o: 3(try), 38(except)

nname: 38
n 38(None)[except:
	pass
return MessageWindow.hide(self)
]:
	i: 0()
	o: 

nname: 0
n 0(None)[try:
	self._window.get_obj_by_name('text').set_text(self.win.text)
]:
	i: 
	o: 38()

nname: 0
n 0(None)[try:
	self._window.get_obj_by_name('text').set_text(self.win.text)
except:
	pass
return MessageWindow.hide(self)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb759e3cc>}
nname: 6
n 6(None)[def create_content(self, win, sync_ui=True):
	wid = TextWindow.create_content(self, win)
	self.buttons = []
	for button in win.buttons:
		but = self.button2widget(button)
		self.buttons.append(but)
	if sync_ui:
		self._sync_ui(wid)
	return wid

def _draw_buttons(self, new_buttons, wid=None):
	my_buts = self.buttons
	if not wid:
		pass
	wid = wid
	but_space = 100 / len(my_buts)
	width = '%d%%' % but_space
	for but in new_buttons:
		but_idx = my_buts.index(but)
		wid.add_child(but, width=width, left='%d%%' % but_idx * but_space, top='90%')

def _sync_ui(self, wid=None):
	new_buttons = []
	my_buts = self.buttons
	if wid:
		new_buttons = my_buts
	else:
		win_buts = self.win.buttons
		but_idx = 0
		nb_items = len(self.win.buttons)
		if len(my_buts) < nb_items:
			for n in range(nb_items - len(my_buts)):
				my_buts.append(UIButton())
		else:
			if len(my_buts) > nb_items:
				for n in range(len(my_buts) - nb_items):
					my_buts.pop()
		for but_idx in range(nb_items):
			model_but = win_buts[but_idx]
			view_but = my_buts[but_idx]
			if model_but.selected != view_but._is_selected:
				view_but.unparent()
				but = self.button2widget(model_but)
				my_buts[but_idx] = but
				new_buttons.append(but)
				continue
			if model_but.name != view_but._caption:
				view_but._set_caption(model_but.name)
				continue
	self._draw_buttons(new_buttons, wid)
	if not wid:
		pass
	wid = wid
	text = self.win.text
	if hasattr(self.win, '_text_cursor_pos'):
		WIDTH = 25
		lt = len(text)
		cursor_pos = self.win._text_cursor_pos
		start = max(0, cursor_pos - WIDTH)
		if lt > WIDTH:
			end = min(lt, start + WIDTH)
		else:
			end = lt
		text = text[start:cursor_pos] + '//CURSOR//' + text[cursor_pos:end]
		if start != 0:
			text = HMI_BASE['keyboard_truncate_prefix'] + text
	wid.get_obj_by_name('text').set_text(text)

def update(self, wid=None):
	render_lock.__enter__()
	try:
		self._sync_ui(wid)
	finally:
		del _[1]

def hide(self):
	try:
		self._window.get_obj_by_name('text').set_text(self.win.text)
	except:
		pass
	return MessageWindow.hide(self)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb758dfac>}
nname: 0
n 0(None)[wid = ConfirmWindow.create_content(self, win, sync_ui=False)
wid.get_obj_by_name('title').set_text(win.title)
self._key_container = wid.get_obj_by_name('standard_keys')
self._but_container = wid.get_obj_by_name('action_keys')
self._max_displayed_keys = win.get_max_keys_number()
Task(self._sync_ui, wid).start(0.10000000000000001)
return wid
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb759e50c>}
nname: 381
n 381(None)[]:
	i: 22(AL), 380()
	o: 

nname: 380
n 380(None)[]:
	i: 168(AF), 314()
	o: 381()

nname: 314
n 314(None)[self._but_container.add_child(but, width=but_width, left='%d%%' % (but_idx - alphabet_len) * 100 / buttons_len, top='0%', height='100%', layer=layer)
]:
	i: 175(f), 244()
	o: 380()

nname: 244
n 244(None)[self._key_container.add_child(but, width=char_width, left='%d%%' % col * char_space, height='%d%%' % height, top='%d%%' % row * height, layer=layer)
continue
]:
	i: 175(t)
	o: 314()

nname: 175
n 175(but_idx < alphabet_len)[for but in new_buttons:
layer = but.get_layer()
but_idx = my_buts.index(but)
row, col = divmod(but_idx, self.win.columns)
]:
	i: 168(for)
	o: 244(t), 314(f)

nname: 168
n 168(None)[]:
	i: 22(loop)
	o: 175(for), 380(AF)

nname: 22
n 22(None)[wid = wid
lines = math.ceil(float(self._max_displayed_keys) / self.win.columns)
char_space = 100 / self.win.columns
char_width = '%d%%' % char_space
height = 100 / lines
alphabet_len = len(self.win.alphabet) + len(self.win.special_chars)
buttons_len = len(self.win.buttons) - alphabet_len
but_width = '%d%%' % 100 / buttons_len
]:
	i: 0(t), 15()
	o: 168(loop), 381(AL)

nname: 15
n 15(None)[]:
	i: 0(f)
	o: 22()

nname: 0
n 0(wid)[my_buts = self.buttons
]:
	i: 
	o: 15(f), 22(t)

nname: 381
n 381(None)[]:
	i: 0(AL), 168(AF), 175()
	o: 

nname: 175
n 175(None)[for but in new_buttons:
layer = but.get_layer()
but_idx = my_buts.index(but)
row, col = divmod(but_idx, self.win.columns)
if but_idx < alphabet_len:
	self._key_container.add_child(but, width=char_width, left='%d%%' % col * char_space, height='%d%%' % height, top='%d%%' % row * height, layer=layer)
	continue
self._but_container.add_child(but, width=but_width, left='%d%%' % (but_idx - alphabet_len) * 100 / buttons_len, top='0%', height='100%', layer=layer)
]:
	i: 168(for)
	o: 381()

nname: 168
n 168(None)[]:
	i: 0(loop)
	o: 175(for), 381(AF)

nname: 0
n 0(None)[my_buts = self.buttons
if not wid:
	pass
wid = wid
lines = math.ceil(float(self._max_displayed_keys) / self.win.columns)
char_space = 100 / self.win.columns
char_width = '%d%%' % char_space
height = 100 / lines
alphabet_len = len(self.win.alphabet) + len(self.win.special_chars)
buttons_len = len(self.win.buttons) - alphabet_len
but_width = '%d%%' % 100 / buttons_len
]:
	i: 
	o: 168(loop), 381(AL)

self.nodes: {0: <unpyclib.structure.node instance at 0xb759e58c>, 168: <unpyclib.structure.node instance at 0xb7597acc>, 175: <unpyclib.structure.node instance at 0xb759e38c>, 381: <unpyclib.structure.node instance at 0xb75978ac>}
nname: 6
n 6(None)[def create_content(self, win):
	wid = ConfirmWindow.create_content(self, win, sync_ui=False)
	wid.get_obj_by_name('title').set_text(win.title)
	self._key_container = wid.get_obj_by_name('standard_keys')
	self._but_container = wid.get_obj_by_name('action_keys')
	self._max_displayed_keys = win.get_max_keys_number()
	Task(self._sync_ui, wid).start(0.10000000000000001)
	return wid

def _draw_buttons(self, new_buttons, wid=None):
	my_buts = self.buttons
	if not wid:
		pass
	wid = wid
	lines = math.ceil(float(self._max_displayed_keys) / self.win.columns)
	char_space = 100 / self.win.columns
	char_width = '%d%%' % char_space
	height = 100 / lines
	alphabet_len = len(self.win.alphabet) + len(self.win.special_chars)
	buttons_len = len(self.win.buttons) - alphabet_len
	but_width = '%d%%' % 100 / buttons_len

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb758db6c>}
nname: 0
n 0(None)[wid = ConfirmWindow.create_content(self, win, sync_ui=False)
wid.get_obj_by_name('title').set_text(win.title)
self._key_container = wid.get_obj_by_name('standard_keys')
self._but_container = wid.get_obj_by_name('action_keys')
self._sync_ui(wid)
return wid
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb759e5ac>}
nname: 284
n 284(None)[]:
	i: 22(AL), 283()
	o: 

nname: 283
n 283(None)[]:
	i: 102(AF), 213()
	o: 284()

nname: 213
n 213(None)[self._but_container.add_child(but, width=but_width, left='%d%%' % (i - alphabet_len + 1) * 100 / buttons_len, top='0%', height='100%', layer=layer)
]:
	i: 109(f), 151()
	o: 283()

nname: 151
n 151(None)[self._key_container.add_child(but, width=char_width, left='%d%%' % (i + 1) * char_space, height='100%', top='100%', layer=layer)
continue
]:
	i: 109(t)
	o: 213()

nname: 109
n 109(i < alphabet_len)[for but in new_buttons:
layer = but.get_layer()
i = my_buts.index(but)
]:
	i: 102(for)
	o: 151(t), 213(f)

nname: 102
n 102(None)[]:
	i: 22(loop)
	o: 109(for), 283(AF)

nname: 22
n 22(None)[wid = wid
alphabet_len = len(self.win.modifiable_buttons)
char_space = 100 / alphabet_len
char_width = '%d%%' % char_space
buttons_len = len(self.win.buttons) - alphabet_len
but_width = '%d%%' % 100 / buttons_len
]:
	i: 0(t), 15()
	o: 102(loop), 284(AL)

nname: 15
n 15(None)[]:
	i: 0(f)
	o: 22()

nname: 0
n 0(wid)[my_buts = self.buttons
]:
	i: 
	o: 15(f), 22(t)

nname: 284
n 284(None)[]:
	i: 0(AL), 102(AF), 109()
	o: 

nname: 109
n 109(None)[for but in new_buttons:
layer = but.get_layer()
i = my_buts.index(but)
if i < alphabet_len:
	self._key_container.add_child(but, width=char_width, left='%d%%' % (i + 1) * char_space, height='100%', top='100%', layer=layer)
	continue
self._but_container.add_child(but, width=but_width, left='%d%%' % (i - alphabet_len + 1) * 100 / buttons_len, top='0%', height='100%', layer=layer)
]:
	i: 102(for)
	o: 284()

nname: 102
n 102(None)[]:
	i: 0(loop)
	o: 109(for), 284(AF)

nname: 0
n 0(None)[my_buts = self.buttons
if not wid:
	pass
wid = wid
alphabet_len = len(self.win.modifiable_buttons)
char_space = 100 / alphabet_len
char_width = '%d%%' % char_space
buttons_len = len(self.win.buttons) - alphabet_len
but_width = '%d%%' % 100 / buttons_len
]:
	i: 
	o: 102(loop), 284(AL)

self.nodes: {0: <unpyclib.structure.node instance at 0xb759ebac>, 102: <unpyclib.structure.node instance at 0xb759ec2c>, 109: <unpyclib.structure.node instance at 0xb759ebec>, 284: <unpyclib.structure.node instance at 0xb759ed6c>}
nname: 6
n 6(None)[__doc__ = 'IP address editor.'
def create_content(self, win):
	wid = ConfirmWindow.create_content(self, win, sync_ui=False)
	wid.get_obj_by_name('title').set_text(win.title)
	self._key_container = wid.get_obj_by_name('standard_keys')
	self._but_container = wid.get_obj_by_name('action_keys')
	self._sync_ui(wid)
	return wid

def _draw_buttons(self, new_buttons, wid=None):
	my_buts = self.buttons
	if not wid:
		pass
	wid = wid
	alphabet_len = len(self.win.modifiable_buttons)
	char_space = 100 / alphabet_len
	char_width = '%d%%' % char_space
	buttons_len = len(self.win.buttons) - alphabet_len
	but_width = '%d%%' % 100 / buttons_len

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb758d86c>}
nname: 0
n 0(None)[from __future__ import absolute_import, with_statement
import math
from copy import copy
from wyvas import render_lock
import pygui.gui.widget as widget
from .widget import Window
from peewee.notifier import Task
from pygui.config import HMI_BASE
class UIButton(object):
	def __init__(self, contained=None, selected=False, caption=''):
		self._UIButton__ui_real_object = contained
		self._is_selected = selected
		self._caption = caption

	def __getattr__(self, attr):
		return getattr(self._UIButton__ui_real_object, attr)

	def __setattr__(self, attr, value):
		if attr != 'parent':
			object.__setattr__(self, attr, value)
		else:
			setattr(self._UIButton__ui_real_object, attr, value)

	def __cmp__(self, o):
		return cmp(self._UIButton__ui_real_object, o)

	def __eq__(self, o):
		return self._UIButton__ui_real_object == o

	def __hash__(self, o):
		return hash(self._UIButton__ui_real_object)

	def _set_caption(self, caption):
		self._caption = caption
		self.get_obj_by_name('text').set_text(caption)

	def unparent(self, *args, **args):
		wid = self._UIButton__ui_real_object
		if wid is None:
			return None
		else:
			return wid.unparent(*args, **kw)
		return None



class LoadingWindow(Window):
	def update(self, *args, **args):
		try:
			self._window.get_obj_by_name('text').set_text(self.win.text)
		except AttributeError:
			pass



class KeystrokeWindow(Window):
	def update(self, *args, **args):
		self._window.get_obj_by_name('text').set_text(self.win.text)



class TextWindow(Window):
	def update(self, *args, **args):
		wid = self._window
		wid.get_obj_by_name('text').set_text(self.win.text)
		wid.get_obj_by_name('title').set_text(self.win.title)



class MessageWindow(TextWindow):
	def __init__(self, *args, **args):
		TextWindow.__init__(self, *args, **kw)

	def button2widget(self, button):
		if not(button.selected and 'selected'):
			pass
		state = 'not_selected'
		prefix = 'button_'
		if button.type:
			prefix = '%s_%s' % (button.type, prefix)
		but = UIButton(self._widget_library.get_container(self.type, prefix + state), selected=button.selected, caption=button.name)
		but.get_obj_by_name('text').set_text(button.name)
		return but

	def create_content(self, win):
		wid = TextWindow.create_content(self, win)
		if win.button is not None:
			but = self.button2widget(win.button)
			wid.add_child(but, hcenter='50%', top='80%')
		return wid



class ProgressWindow(Window):
	def create_content(self, win):
		wid = Window.create_content(self, win)
		self._wid_title = wid.get_obj_by_name('title')
		self._wid_description = wid.get_obj_by_name('description')
		self._wid_progress = wid.get_obj_by_name('progressbar')
		self._wid_total = wid.get_obj_by_name('total')
		self._wid_elapsed = wid.get_obj_by_name('elapsed')
		self._wid_remaining = wid.get_obj_by_name('remaining')
		return wid

	def update(self, *args, **args):
		win = self.win
		self._wid_progress.set(pos=win.progress)
		self._wid_title.set_text(win.title)
		self._wid_description.set_text(win.description)
		self._wid_total.set_text(win.total)
		self._wid_elapsed.set_text(win.elapsed)
		self._wid_remaining.set_text(win.remaining)



class SoundLevelWindow(Window):
	def create_content(self, win):
		wid = Window.create_content(self, win)
		self._wid_progress = wid.get_obj_by_name('progressbar')
		self._wid_icon = wid.get_obj_by_name('volume_icon')
		return wid

	def update(self, *args, **args):
		win = self.win
		self._wid_progress.set(pos=win.progress)
		self._wid_icon.load(win.icon)



class MuteWindow(Window):
	def create_content(self, win):
		wid = Window.create_content(self, win)
		self._wid_icon = wid.get_obj_by_name('volume_icon')
		return wid

	def update(self, *args, **args):
		win = self.win
		self._wid_icon.load(win.icon)



class ConfirmWindow(MessageWindow):
	def create_content(self, win, sync_ui=True):
		wid = TextWindow.create_content(self, win)
		self.buttons = []
		for button in win.buttons:
			but = self.button2widget(button)
			self.buttons.append(but)
		if sync_ui:
			self._sync_ui(wid)
		return wid

	def _draw_buttons(self, new_buttons, wid=None):
		my_buts = self.buttons
		if not wid:
			pass
		wid = wid
		but_space = 100 / len(my_buts)
		width = '%d%%' % but_space
		for but in new_buttons:
			but_idx = my_buts.index(but)
			wid.add_child(but, width=width, left='%d%%' % but_idx * but_space, top='90%')

	def _sync_ui(self, wid=None):
		new_buttons = []
		my_buts = self.buttons
		if wid:
			new_buttons = my_buts
		else:
			win_buts = self.win.buttons
			but_idx = 0
			nb_items = len(self.win.buttons)
			if len(my_buts) < nb_items:
				for n in range(nb_items - len(my_buts)):
					my_buts.append(UIButton())
			else:
				if len(my_buts) > nb_items:
					for n in range(len(my_buts) - nb_items):
						my_buts.pop()
			for but_idx in range(nb_items):
				model_but = win_buts[but_idx]
				view_but = my_buts[but_idx]
				if model_but.selected != view_but._is_selected:
					view_but.unparent()
					but = self.button2widget(model_but)
					my_buts[but_idx] = but
					new_buttons.append(but)
					continue
				if model_but.name != view_but._caption:
					view_but._set_caption(model_but.name)
					continue
		self._draw_buttons(new_buttons, wid)
		if not wid:
			pass
		wid = wid
		text = self.win.text
		if hasattr(self.win, '_text_cursor_pos'):
			WIDTH = 25
			lt = len(text)
			cursor_pos = self.win._text_cursor_pos
			start = max(0, cursor_pos - WIDTH)
			if lt > WIDTH:
				end = min(lt, start + WIDTH)
			else:
				end = lt
			text = text[start:cursor_pos] + '//CURSOR//' + text[cursor_pos:end]
			if start != 0:
				text = HMI_BASE['keyboard_truncate_prefix'] + text
		wid.get_obj_by_name('text').set_text(text)

	def update(self, wid=None):
		render_lock.__enter__()
		try:
			self._sync_ui(wid)
		finally:
			del _[1]

	def hide(self):
		try:
			self._window.get_obj_by_name('text').set_text(self.win.text)
		except:
			pass
		return MessageWindow.hide(self)



class KeyboardWindow(ConfirmWindow):
	def create_content(self, win):
		wid = ConfirmWindow.create_content(self, win, sync_ui=False)
		wid.get_obj_by_name('title').set_text(win.title)
		self._key_container = wid.get_obj_by_name('standard_keys')
		self._but_container = wid.get_obj_by_name('action_keys')
		self._max_displayed_keys = win.get_max_keys_number()
		Task(self._sync_ui, wid).start(0.10000000000000001)
		return wid

	def _draw_buttons(self, new_buttons, wid=None):
		my_buts = self.buttons
		if not wid:
			pass
		wid = wid
		lines = math.ceil(float(self._max_displayed_keys) / self.win.columns)
		char_space = 100 / self.win.columns
		char_width = '%d%%' % char_space
		height = 100 / lines
		alphabet_len = len(self.win.alphabet) + len(self.win.special_chars)
		buttons_len = len(self.win.buttons) - alphabet_len
		but_width = '%d%%' % 100 / buttons_len



class IpWindow(ConfirmWindow):
	__doc__ = 'IP address editor.'
	def create_content(self, win):
		wid = ConfirmWindow.create_content(self, win, sync_ui=False)
		wid.get_obj_by_name('title').set_text(win.title)
		self._key_container = wid.get_obj_by_name('standard_keys')
		self._but_container = wid.get_obj_by_name('action_keys')
		self._sync_ui(wid)
		return wid

	def _draw_buttons(self, new_buttons, wid=None):
		my_buts = self.buttons
		if not wid:
			pass
		wid = wid
		alphabet_len = len(self.win.modifiable_buttons)
		char_space = 100 / alphabet_len
		char_width = '%d%%' % char_space
		buttons_len = len(self.win.buttons) - alphabet_len
		but_width = '%d%%' % 100 / buttons_len



__engine__ = {'window_default': Window, 'window_text': TextWindow, 'window_keystroke': KeystrokeWindow, 'window_loading': LoadingWindow, 'window_message': MessageWindow, 'window_bigmessage': MessageWindow, 'window_confirm': ConfirmWindow, 'window_bigconfirm': ConfirmWindow, 'window_keyboard': KeyboardWindow, 'window_numeric_keyboard': KeyboardWindow, 'window_hexa_keyboard': KeyboardWindow, 'window_bigtitle_keyboard': KeyboardWindow, 'window_progress': ProgressWindow, 'window_progress_update': ProgressWindow, 'window_soundlevel': SoundLevelWindow, 'window_mute': MuteWindow, 'window_ip': IpWindow, 'window_silent_keyboard': KeyboardWindow}
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7582b4c>}
from __future__ import absolute_import, with_statement
import math
from copy import copy
from wyvas import render_lock
import pygui.gui.widget as widget
from .widget import Window
from peewee.notifier import Task
from pygui.config import HMI_BASE
class UIButton(object):
	def __init__(self, contained=None, selected=False, caption=''):
		self._UIButton__ui_real_object = contained
		self._is_selected = selected
		self._caption = caption

	def __getattr__(self, attr):
		return getattr(self._UIButton__ui_real_object, attr)

	def __setattr__(self, attr, value):
		if attr != 'parent':
			object.__setattr__(self, attr, value)
		else:
			setattr(self._UIButton__ui_real_object, attr, value)

	def __cmp__(self, o):
		return cmp(self._UIButton__ui_real_object, o)

	def __eq__(self, o):
		return self._UIButton__ui_real_object == o

	def __hash__(self, o):
		return hash(self._UIButton__ui_real_object)

	def _set_caption(self, caption):
		self._caption = caption
		self.get_obj_by_name('text').set_text(caption)

	def unparent(self, *args, **args):
		wid = self._UIButton__ui_real_object
		if wid is None:
			return None
		else:
			return wid.unparent(*args, **kw)
		return None



class LoadingWindow(Window):
	def update(self, *args, **args):
		try:
			self._window.get_obj_by_name('text').set_text(self.win.text)
		except AttributeError:
			pass



class KeystrokeWindow(Window):
	def update(self, *args, **args):
		self._window.get_obj_by_name('text').set_text(self.win.text)



class TextWindow(Window):
	def update(self, *args, **args):
		wid = self._window
		wid.get_obj_by_name('text').set_text(self.win.text)
		wid.get_obj_by_name('title').set_text(self.win.title)



class MessageWindow(TextWindow):
	def __init__(self, *args, **args):
		TextWindow.__init__(self, *args, **kw)

	def button2widget(self, button):
		if not(button.selected and 'selected'):
			pass
		state = 'not_selected'
		prefix = 'button_'
		if button.type:
			prefix = '%s_%s' % (button.type, prefix)
		but = UIButton(self._widget_library.get_container(self.type, prefix + state), selected=button.selected, caption=button.name)
		but.get_obj_by_name('text').set_text(button.name)
		return but

	def create_content(self, win):
		wid = TextWindow.create_content(self, win)
		if win.button is not None:
			but = self.button2widget(win.button)
			wid.add_child(but, hcenter='50%', top='80%')
		return wid



class ProgressWindow(Window):
	def create_content(self, win):
		wid = Window.create_content(self, win)
		self._wid_title = wid.get_obj_by_name('title')
		self._wid_description = wid.get_obj_by_name('description')
		self._wid_progress = wid.get_obj_by_name('progressbar')
		self._wid_total = wid.get_obj_by_name('total')
		self._wid_elapsed = wid.get_obj_by_name('elapsed')
		self._wid_remaining = wid.get_obj_by_name('remaining')
		return wid

	def update(self, *args, **args):
		win = self.win
		self._wid_progress.set(pos=win.progress)
		self._wid_title.set_text(win.title)
		self._wid_description.set_text(win.description)
		self._wid_total.set_text(win.total)
		self._wid_elapsed.set_text(win.elapsed)
		self._wid_remaining.set_text(win.remaining)



class SoundLevelWindow(Window):
	def create_content(self, win):
		wid = Window.create_content(self, win)
		self._wid_progress = wid.get_obj_by_name('progressbar')
		self._wid_icon = wid.get_obj_by_name('volume_icon')
		return wid

	def update(self, *args, **args):
		win = self.win
		self._wid_progress.set(pos=win.progress)
		self._wid_icon.load(win.icon)



class MuteWindow(Window):
	def create_content(self, win):
		wid = Window.create_content(self, win)
		self._wid_icon = wid.get_obj_by_name('volume_icon')
		return wid

	def update(self, *args, **args):
		win = self.win
		self._wid_icon.load(win.icon)



class ConfirmWindow(MessageWindow):
	def create_content(self, win, sync_ui=True):
		wid = TextWindow.create_content(self, win)
		self.buttons = []
		for button in win.buttons:
			but = self.button2widget(button)
			self.buttons.append(but)
		if sync_ui:
			self._sync_ui(wid)
		return wid

	def _draw_buttons(self, new_buttons, wid=None):
		my_buts = self.buttons
		if not wid:
			pass
		wid = wid
		but_space = 100 / len(my_buts)
		width = '%d%%' % but_space
		for but in new_buttons:
			but_idx = my_buts.index(but)
			wid.add_child(but, width=width, left='%d%%' % but_idx * but_space, top='90%')

	def _sync_ui(self, wid=None):
		new_buttons = []
		my_buts = self.buttons
		if wid:
			new_buttons = my_buts
		else:
			win_buts = self.win.buttons
			but_idx = 0
			nb_items = len(self.win.buttons)
			if len(my_buts) < nb_items:
				for n in range(nb_items - len(my_buts)):
					my_buts.append(UIButton())
			else:
				if len(my_buts) > nb_items:
					for n in range(len(my_buts) - nb_items):
						my_buts.pop()
			for but_idx in range(nb_items):
				model_but = win_buts[but_idx]
				view_but = my_buts[but_idx]
				if model_but.selected != view_but._is_selected:
					view_but.unparent()
					but = self.button2widget(model_but)
					my_buts[but_idx] = but
					new_buttons.append(but)
					continue
				if model_but.name != view_but._caption:
					view_but._set_caption(model_but.name)
					continue
		self._draw_buttons(new_buttons, wid)
		if not wid:
			pass
		wid = wid
		text = self.win.text
		if hasattr(self.win, '_text_cursor_pos'):
			WIDTH = 25
			lt = len(text)
			cursor_pos = self.win._text_cursor_pos
			start = max(0, cursor_pos - WIDTH)
			if lt > WIDTH:
				end = min(lt, start + WIDTH)
			else:
				end = lt
			text = text[start:cursor_pos] + '//CURSOR//' + text[cursor_pos:end]
			if start != 0:
				text = HMI_BASE['keyboard_truncate_prefix'] + text
		wid.get_obj_by_name('text').set_text(text)

	def update(self, wid=None):
		render_lock.__enter__()
		try:
			self._sync_ui(wid)
		finally:
			del _[1]

	def hide(self):
		try:
			self._window.get_obj_by_name('text').set_text(self.win.text)
		except:
			pass
		return MessageWindow.hide(self)



class KeyboardWindow(ConfirmWindow):
	def create_content(self, win):
		wid = ConfirmWindow.create_content(self, win, sync_ui=False)
		wid.get_obj_by_name('title').set_text(win.title)
		self._key_container = wid.get_obj_by_name('standard_keys')
		self._but_container = wid.get_obj_by_name('action_keys')
		self._max_displayed_keys = win.get_max_keys_number()
		Task(self._sync_ui, wid).start(0.10000000000000001)
		return wid

	def _draw_buttons(self, new_buttons, wid=None):
		my_buts = self.buttons
		if not wid:
			pass
		wid = wid
		lines = math.ceil(float(self._max_displayed_keys) / self.win.columns)
		char_space = 100 / self.win.columns
		char_width = '%d%%' % char_space
		height = 100 / lines
		alphabet_len = len(self.win.alphabet) + len(self.win.special_chars)
		buttons_len = len(self.win.buttons) - alphabet_len
		but_width = '%d%%' % 100 / buttons_len



class IpWindow(ConfirmWindow):
	__doc__ = 'IP address editor.'
	def create_content(self, win):
		wid = ConfirmWindow.create_content(self, win, sync_ui=False)
		wid.get_obj_by_name('title').set_text(win.title)
		self._key_container = wid.get_obj_by_name('standard_keys')
		self._but_container = wid.get_obj_by_name('action_keys')
		self._sync_ui(wid)
		return wid

	def _draw_buttons(self, new_buttons, wid=None):
		my_buts = self.buttons
		if not wid:
			pass
		wid = wid
		alphabet_len = len(self.win.modifiable_buttons)
		char_space = 100 / alphabet_len
		char_width = '%d%%' % char_space
		buttons_len = len(self.win.buttons) - alphabet_len
		but_width = '%d%%' % 100 / buttons_len



__engine__ = {'window_default': Window, 'window_text': TextWindow, 'window_keystroke': KeystrokeWindow, 'window_loading': LoadingWindow, 'window_message': MessageWindow, 'window_bigmessage': MessageWindow, 'window_confirm': ConfirmWindow, 'window_bigconfirm': ConfirmWindow, 'window_keyboard': KeyboardWindow, 'window_numeric_keyboard': KeyboardWindow, 'window_hexa_keyboard': KeyboardWindow, 'window_bigtitle_keyboard': KeyboardWindow, 'window_progress': ProgressWindow, 'window_progress_update': ProgressWindow, 'window_soundlevel': SoundLevelWindow, 'window_mute': MuteWindow, 'window_ip': IpWindow, 'window_silent_keyboard': KeyboardWindow}
