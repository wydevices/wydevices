# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 0
n 0(None)[self._visible = False
self._content = None
self.wl = WidgetLibrary()
self.theme = theme
self.display = display
self.menu_stack = list()
self.window_dict = dict()
self.menu_cache = weakref.WeakValueDictionary()
self.on_idle = False
self.up_window_layer = partial(self.update_window_layer, up_layer=True)
self.down_window_layer = partial(self.update_window_layer, up_layer=False)
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7780c2c>}
nname: 0
n 0(None)[return getattr(self._content, attr)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb778052c>}
nname: 0
n 0(None)[return '<gui.Application @%s, %s skin>' % (self.display, self.theme)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb77805ac>}
nname: 104
n 104(None)[]:
	i: 15(), 57(), 103()
	o: 

nname: 103
n 103(None)[]:
	i: 41(f)
	o: 104()

nname: 57
n 57(None)[from .window import __engine__
return __engine__[name](name, self.display, self.wl)
]:
	i: 41(t)
	o: 104()

nname: 41
n 41(name.startswith('window'))[]:
	i: 0(f)
	o: 57(t), 103(f)

nname: 15
n 15(None)[return MenuWidget(name, self.display, self.wl)
]:
	i: 0(t)
	o: 104()

nname: 0
n 0(name.startswith('menu'))[]:
	i: 
	o: 15(t), 41(f)

nname: 0
n 0(None)[if name.startswith('menu'):
	return MenuWidget(name, self.display, self.wl)
else:
	if name.startswith('window'):
		from .window import __engine__
		return __engine__[name](name, self.display, self.wl)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb77809ec>}
nname: 172
n 172(None)[]:
	i: 9(AL), 122(), 126()
	o: 

nname: 126
n 126(None)[self.wl.load_xml(os.path.join(config.themes_dir, self.theme, 'xml'))
yield None
]:
	i: 0(f)
	o: 172()

nname: 122
n 122(None)[]:
	i: 13(AF), 112()
	o: 172()

nname: 112
n 112(None)[raise StopIteration
]:
	i: 29(f), 87()
	o: 122()

nname: 87
n 87(None)[self.wl.load_pickle(datapack)
yield None
continue
]:
	i: 29(t)
	o: 112()

nname: 29
n 29(os.path.exists(datapack))[for step in xrange(1, 4):
datapack = os.path.join(config.themes_dir, self.theme, 'xml', 'data.pk%d' % step)
]:
	i: 13(for)
	o: 87(t), 112(f)

nname: 13
n 13(None)[]:
	i: 9(loop)
	o: 29(for), 122(AF)

nname: 9
n 9(None)[]:
	i: 0(t)
	o: 13(loop), 172(AL)

nname: 0
n 0(config.use_serialized_theme)[]:
	i: 
	o: 9(t), 126(f)

nname: 172
n 172(None)[]:
	i: 9(AL), 126(), 13(AF), 29()
	o: 

nname: 126
n 126(None)[self.wl.load_xml(os.path.join(config.themes_dir, self.theme, 'xml'))
yield None
]:
	i: 0(f)
	o: 172()

nname: 29
n 29(None)[for step in xrange(1, 4):
datapack = os.path.join(config.themes_dir, self.theme, 'xml', 'data.pk%d' % step)
if os.path.exists(datapack):
	self.wl.load_pickle(datapack)
	yield None
	continue
raise StopIteration
]:
	i: 13(for)
	o: 172()

nname: 13
n 13(None)[]:
	i: 9(loop)
	o: 29(for), 172(AF)

nname: 9
n 9(None)[]:
	i: 0(t)
	o: 13(loop), 172(AL)

nname: 0
n 0(config.use_serialized_theme)[]:
	i: 
	o: 9(t), 126(f)

nname: 172
n 172(None)[]:
	i: 126(), 29()
	o: 

nname: 126
n 126(None)[self.wl.load_xml(os.path.join(config.themes_dir, self.theme, 'xml'))
yield None
]:
	i: 0(f)
	o: 172()

nname: 29
n 29(None)[for step in xrange(1, 4):
	datapack = os.path.join(config.themes_dir, self.theme, 'xml', 'data.pk%d' % step)
	if os.path.exists(datapack):
		self.wl.load_pickle(datapack)
		yield None
		continue
	raise StopIteration
]:
	i: 9(for)
	o: 172()

nname: 9
n 9(None)[]:
	i: 0(t)
	o: 29(for)

nname: 0
n 0(config.use_serialized_theme)[]:
	i: 
	o: 9(t), 126(f)

nname: 172
n 172(None)[]:
	i: 126(), 9()
	o: 

nname: 126
n 126(None)[self.wl.load_xml(os.path.join(config.themes_dir, self.theme, 'xml'))
yield None
]:
	i: 0(f)
	o: 172()

nname: 9
n 9(None)[for step in xrange(1, 4):
	datapack = os.path.join(config.themes_dir, self.theme, 'xml', 'data.pk%d' % step)
	if os.path.exists(datapack):
		self.wl.load_pickle(datapack)
		yield None
		continue
	raise StopIteration
]:
	i: 0(t)
	o: 172()

nname: 0
n 0(config.use_serialized_theme)[]:
	i: 
	o: 9(t), 126(f)

nname: 0
n 0(None)[if config.use_serialized_theme:
	for step in xrange(1, 4):
		datapack = os.path.join(config.themes_dir, self.theme, 'xml', 'data.pk%d' % step)
		if os.path.exists(datapack):
			self.wl.load_pickle(datapack)
			yield None
			continue
		raise StopIteration
else:
	self.wl.load_xml(os.path.join(config.themes_dir, self.theme, 'xml'))
	yield None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb770372c>}
nname: 85
n 85(None)[]:
	i: 23(), 84()
	o: 

nname: 84
n 84(None)[]:
	i: 0(f)
	o: 85()

nname: 23
n 23(None)[window_content.display = self.display
self.window_dict[win] = window_content
window_content.show(win)
louie_send(signal='on_create', sender=win)
]:
	i: 0(t)
	o: 85()

nname: 0
n 0(window_content)[window_content = self['window_%s' % win.type]
]:
	i: 
	o: 23(t), 84(f)

nname: 0
n 0(None)[window_content = self['window_%s' % win.type]
if window_content:
	window_content.display = self.display
	self.window_dict[win] = window_content
	window_content.show(win)
	louie_send(signal='on_create', sender=win)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb77808cc>}
nname: 0
n 0(None)[louie_send(signal='on_remove', sender=win)
self.window_dict[win].hide()
del self.window_dict[win]
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7780f8c>}
nname: 61
n 61(None)[return None
]:
	i: 30(), 44()
	o: 

nname: 44
n 44(None)[log.warn('%s is not on screen anymore...', win)
]:
	i: 0(f)
	o: 61()

nname: 30
n 30(None)[wid.update()
]:
	i: 0(t)
	o: 61()

nname: 0
n 0(wid is not None)[wid = self.window_dict.get(win)
]:
	i: 
	o: 30(t), 44(f)

nname: 0
n 0(None)[wid = self.window_dict.get(win)
if wid is not None:
	wid.update()
else:
	log.warn('%s is not on screen anymore...', win)
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb778074c>}
nname: 114
n 114(None)[]:
	i: 9(AL), 109(), 113()
	o: 

nname: 113
n 113(None)[]:
	i: 0(t)
	o: 114()

nname: 109
n 109(None)[]:
	i: 13(AF), 90()
	o: 114()

nname: 90
n 90(None)[win.set_layer(win._layer)
]:
	i: 38(), 74()
	o: 109()

nname: 74
n 74(None)[win._layer -= menu_layer
]:
	i: 29(f)
	o: 90()

nname: 38
n 38(None)[win._layer = max(<genexpr>(self.menu_stack)) + menu_layer
]:
	i: 29(t)
	o: 90()

nname: 29
n 29(up_layer)[for win in self.window_dict.values():
]:
	i: 13(for)
	o: 38(t), 74(f)

nname: 13
n 13(None)[]:
	i: 9(loop)
	o: 29(for), 109(AF)

nname: 9
n 9(None)[]:
	i: 0(f)
	o: 13(loop), 114(AL)

nname: 0
n 0(self.on_idle)[]:
	i: 
	o: 9(f), 113(t)

nname: 114
n 114(None)[]:
	i: 9(AL), 13(AF), 29(), 0(t)
	o: 

nname: 29
n 29(None)[for win in self.window_dict.values():
if up_layer:
	win._layer = max(<genexpr>(self.menu_stack)) + menu_layer
else:
	win._layer -= menu_layer
win.set_layer(win._layer)
]:
	i: 13(for)
	o: 114()

nname: 13
n 13(None)[]:
	i: 9(loop)
	o: 29(for), 114(AF)

nname: 9
n 9(None)[]:
	i: 0(f)
	o: 13(loop), 114(AL)

nname: 0
n 0(self.on_idle)[]:
	i: 
	o: 9(f), 114(t)

nname: 114
n 114(None)[]:
	i: 29(), 0(t)
	o: 

nname: 29
n 29(None)[for win in self.window_dict.values():
	if up_layer:
		win._layer = max(<genexpr>(self.menu_stack)) + menu_layer
	else:
		win._layer -= menu_layer
	win.set_layer(win._layer)
]:
	i: 9(for)
	o: 114()

nname: 9
n 9(None)[]:
	i: 0(f)
	o: 29(for)

nname: 0
n 0(self.on_idle)[]:
	i: 
	o: 9(f), 114(t)

nname: 114
n 114(None)[]:
	i: 9(), 0(t)
	o: 

nname: 9
n 9(None)[for win in self.window_dict.values():
	if up_layer:
		win._layer = max(<genexpr>(self.menu_stack)) + menu_layer
	else:
		win._layer -= menu_layer
	win.set_layer(win._layer)
]:
	i: 0(f)
	o: 114()

nname: 0
n 0(self.on_idle)[]:
	i: 
	o: 9(f), 114(t)

nname: 0
n 0(None)[if not self.on_idle:
	for win in self.window_dict.values():
		if up_layer:
			win._layer = max(<genexpr>(self.menu_stack)) + menu_layer
		else:
			win._layer -= menu_layer
		win.set_layer(win._layer)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7780dec>}
nname: 156
n 156(None)[return None
]:
	i: 101(), 119(), 154(AE)
	o: 

nname: 154
n 154(None)[]:
	i: 109(f)
	o: 156(AE)

nname: 119
n 119(None)[#, e
PRINT_EXCEPTION(e)
raise NameError('no special menu engine for %s' % showing)
]:
	i: 109(t)
	o: 156()

nname: 109
n 109(<dummy_ex3> EXC_MATCH KeyError)[]:
	i: 24(except)
	o: 119(t), 154(f)

nname: 101
n 101(None)[return menu_content
]:
	i: 83(), 100()
	o: 156()

nname: 100
n 100(None)[]:
	i: 27(f)
	o: 101()

nname: 83
n 83(None)[menu_content.set_layer(layer)
]:
	i: 27(t)
	o: 101()

nname: 27
n 27(layer is not None)[menu_content = self[showing]
menu_content.create(menu, self.wl.get_container(showing, menu=menu))
]:
	i: 24(try)
	o: 83(t), 100(f)

nname: 24
n 24(None)[]:
	i: 6(), 23()
	o: 27(try), 109(except)

nname: 23
n 23(None)[]:
	i: 0(t)
	o: 24()

nname: 6
n 6(None)[showing = 'menu_%s' % menu.type
]:
	i: 0(f)
	o: 24()

nname: 0
n 0(showing)[]:
	i: 
	o: 6(f), 23(t)

nname: 156
n 156(None)[return None
]:
	i: 101(), 109()
	o: 

nname: 109
n 109(None)[except KeyError, e:
	PRINT_EXCEPTION(e)
	raise NameError('no special menu engine for %s' % showing)
]:
	i: 27()
	o: 156()

nname: 101
n 101(None)[return menu_content
]:
	i: 27()
	o: 156()

nname: 27
n 27(None)[try:
	menu_content = self[showing]
	menu_content.create(menu, self.wl.get_container(showing, menu=menu))
	if layer is not None:
		menu_content.set_layer(layer)
]:
	i: 0(try)
	o: 101(), 109()

nname: 0
n 0(None)[if not showing:
	showing = 'menu_%s' % menu.type
]:
	i: 
	o: 27(try)

nname: 156
n 156(None)[return None
]:
	i: 101(), 109()
	o: 

nname: 109
n 109(None)[except KeyError, e:
	PRINT_EXCEPTION(e)
	raise NameError('no special menu engine for %s' % showing)
]:
	i: 0()
	o: 156()

nname: 101
n 101(None)[return menu_content
]:
	i: 0()
	o: 156()

nname: 0
n 0(None)[if not showing:
	showing = 'menu_%s' % menu.type
try:
	menu_content = self[showing]
	menu_content.create(menu, self.wl.get_container(showing, menu=menu))
	if layer is not None:
		menu_content.set_layer(layer)
]:
	i: 
	o: 101(), 109()

self.nodes: {0: <unpyclib.structure.node instance at 0xb77037cc>, 101: <unpyclib.structure.node instance at 0xb770362c>, 109: <unpyclib.structure.node instance at 0xb77032ec>, 156: <unpyclib.structure.node instance at 0xb770326c>}
nname: 391
n 391(None)[]:
	i: 323(), 377()
	o: 

nname: 377
n 377(None)[log.warning('Unable to create a widget for this menu')
]:
	i: 194(f)
	o: 391()

nname: 323
n 323(None)[self.menu_stack.append(menu_content)
self.up_window_layer(menu_content._layer_depth)
louie_send(signal='on_create', sender=menu)
]:
	i: 242(JA), 287(), 322()
	o: 391()

nname: 322
n 322(None)[]:
	i: 200(f)
	o: 323()

nname: 287
n 287(None)[prev_menu._is_hidden = False
louie_send(signal='on_background', sender=prev_menu.menu)
]:
	i: 222(f)
	o: 323()

nname: 242
n 242(None)[prev_menu.pause_perpetual_anim()
prev_menu._is_hidden = True
louie_send(signal='on_hide', sender=prev_menu.menu)
]:
	i: 222(t)
	o: 323(JA)

nname: 222
n 222(hide_previous_menu)[prev_menu = self.menu_stack[-1]
]:
	i: 200(t)
	o: 242(t), 287(f)

nname: 200
n 200(len(self.menu_stack) > 0)[]:
	i: 194(t)
	o: 222(t), 322(f)

nname: 194
n 194(menu_content)[]:
	i: 130(JA), 175(), 178()
	o: 200(t), 377(f)

nname: 178
n 178(None)[menu_content = self.create_content(menu)
]:
	i: 0&9(f)
	o: 194()

nname: 175
n 175(None)[]:
	i: 44(AL), 134()
	o: 194()

nname: 134
n 134(None)[menu_content = self.create_content(menu)
menu_content.cached = True
self.menu_cache[menu.type] = menu_content
]:
	i: 25(f)
	o: 175()

nname: 130
n 130(None)[]:
	i: 83(AF), 93()
	o: 194(JA)

nname: 93
n 93(None)[for animation in menu_content._animations:
louie_connect(receiver=animation.play, signal=animation.event, sender=menu)
]:
	i: 83(for)
	o: 130()

nname: 83
n 83(None)[]:
	i: 44(loop)
	o: 93(for), 130(AF)

nname: 44
n 44(None)[menu_content = self.menu_cache[menu.type]
menu_content.menu = menu
menu_content.sync_model_view()
]:
	i: 25(t)
	o: 83(loop), 175(AL)

nname: 25
n 25(menu.type in self.menu_cache)[]:
	i: 0&9(t)
	o: 44(t), 134(f)

nname: 0&9
n 0&9(config.navigator_cache and menu.type in ('audio', 'video', 'image', 'video_image'))[]:
	i: 
	o: 25(t), 178(f)

nname: 391
n 391(None)[]:
	i: 200(), 377()
	o: 

nname: 377
n 377(None)[log.warning('Unable to create a widget for this menu')
]:
	i: 194(f)
	o: 391()

nname: 200
n 200(None)[if len(self.menu_stack) > 0:
	prev_menu = self.menu_stack[-1]
	if hide_previous_menu:
		prev_menu.pause_perpetual_anim()
		prev_menu._is_hidden = True
		louie_send(signal='on_hide', sender=prev_menu.menu)
	else:
		prev_menu._is_hidden = False
		louie_send(signal='on_background', sender=prev_menu.menu)
self.menu_stack.append(menu_content)
self.up_window_layer(menu_content._layer_depth)
louie_send(signal='on_create', sender=menu)
]:
	i: 194(t)
	o: 391()

nname: 194
n 194(menu_content)[]:
	i: 178(), 83(AF), 93(), 44(AL), 134()
	o: 200(t), 377(f)

nname: 178
n 178(None)[menu_content = self.create_content(menu)
]:
	i: 0&9(f)
	o: 194()

nname: 134
n 134(None)[menu_content = self.create_content(menu)
menu_content.cached = True
self.menu_cache[menu.type] = menu_content
]:
	i: 25(f)
	o: 194()

nname: 93
n 93(None)[for animation in menu_content._animations:
louie_connect(receiver=animation.play, signal=animation.event, sender=menu)
]:
	i: 83(for)
	o: 194()

nname: 83
n 83(None)[]:
	i: 44(loop)
	o: 93(for), 194(AF)

nname: 44
n 44(None)[menu_content = self.menu_cache[menu.type]
menu_content.menu = menu
menu_content.sync_model_view()
]:
	i: 25(t)
	o: 83(loop), 194(AL)

nname: 25
n 25(menu.type in self.menu_cache)[]:
	i: 0&9(t)
	o: 44(t), 134(f)

nname: 0&9
n 0&9(config.navigator_cache and menu.type in ('audio', 'video', 'image', 'video_image'))[]:
	i: 
	o: 25(t), 178(f)

nname: 194
n 194(None)[if menu_content:
	if len(self.menu_stack) > 0:
		prev_menu = self.menu_stack[-1]
		if hide_previous_menu:
			prev_menu.pause_perpetual_anim()
			prev_menu._is_hidden = True
			louie_send(signal='on_hide', sender=prev_menu.menu)
		else:
			prev_menu._is_hidden = False
			louie_send(signal='on_background', sender=prev_menu.menu)
	self.menu_stack.append(menu_content)
	self.up_window_layer(menu_content._layer_depth)
	louie_send(signal='on_create', sender=menu)
else:
	log.warning('Unable to create a widget for this menu')
]:
	i: 178(), 93(), 134()
	o: 

nname: 178
n 178(None)[menu_content = self.create_content(menu)
]:
	i: 0&9(f)
	o: 194()

nname: 134
n 134(None)[menu_content = self.create_content(menu)
menu_content.cached = True
self.menu_cache[menu.type] = menu_content
]:
	i: 25(f)
	o: 194()

nname: 93
n 93(None)[for animation in menu_content._animations:
	louie_connect(receiver=animation.play, signal=animation.event, sender=menu)
]:
	i: 44(for)
	o: 194()

nname: 44
n 44(None)[menu_content = self.menu_cache[menu.type]
menu_content.menu = menu
menu_content.sync_model_view()
]:
	i: 25(t)
	o: 93(for)

nname: 25
n 25(menu.type in self.menu_cache)[]:
	i: 0&9(t)
	o: 44(t), 134(f)

nname: 0&9
n 0&9(config.navigator_cache and menu.type in ('audio', 'video', 'image', 'video_image'))[]:
	i: 
	o: 25(t), 178(f)

nname: 194
n 194(None)[if menu_content:
	if len(self.menu_stack) > 0:
		prev_menu = self.menu_stack[-1]
		if hide_previous_menu:
			prev_menu.pause_perpetual_anim()
			prev_menu._is_hidden = True
			louie_send(signal='on_hide', sender=prev_menu.menu)
		else:
			prev_menu._is_hidden = False
			louie_send(signal='on_background', sender=prev_menu.menu)
	self.menu_stack.append(menu_content)
	self.up_window_layer(menu_content._layer_depth)
	louie_send(signal='on_create', sender=menu)
else:
	log.warning('Unable to create a widget for this menu')
]:
	i: 178(), 44(), 134()
	o: 

nname: 178
n 178(None)[menu_content = self.create_content(menu)
]:
	i: 0&9(f)
	o: 194()

nname: 134
n 134(None)[menu_content = self.create_content(menu)
menu_content.cached = True
self.menu_cache[menu.type] = menu_content
]:
	i: 25(f)
	o: 194()

nname: 44
n 44(None)[menu_content = self.menu_cache[menu.type]
menu_content.menu = menu
menu_content.sync_model_view()
for animation in menu_content._animations:
	louie_connect(receiver=animation.play, signal=animation.event, sender=menu)
]:
	i: 25(t)
	o: 194()

nname: 25
n 25(menu.type in self.menu_cache)[]:
	i: 0&9(t)
	o: 44(t), 134(f)

nname: 0&9
n 0&9(config.navigator_cache and menu.type in ('audio', 'video', 'image', 'video_image'))[]:
	i: 
	o: 25(t), 178(f)

nname: 0&9
n 0&9(None)[if config.navigator_cache and menu.type in ('audio', 'video', 'image', 'video_image'):
	if menu.type in self.menu_cache:
		menu_content = self.menu_cache[menu.type]
		menu_content.menu = menu
		menu_content.sync_model_view()
		for animation in menu_content._animations:
			louie_connect(receiver=animation.play, signal=animation.event, sender=menu)
	else:
		menu_content = self.create_content(menu)
		menu_content.cached = True
		self.menu_cache[menu.type] = menu_content
else:
	menu_content = self.create_content(menu)
if menu_content:
	if len(self.menu_stack) > 0:
		prev_menu = self.menu_stack[-1]
		if hide_previous_menu:
			prev_menu.pause_perpetual_anim()
			prev_menu._is_hidden = True
			louie_send(signal='on_hide', sender=prev_menu.menu)
		else:
			prev_menu._is_hidden = False
			louie_send(signal='on_background', sender=prev_menu.menu)
	self.menu_stack.append(menu_content)
	self.up_window_layer(menu_content._layer_depth)
	louie_send(signal='on_create', sender=menu)
else:
	log.warning('Unable to create a widget for this menu')
]:
	i: 
	o: 

self.nodes: {'0&9': <unpyclib.structure.node instance at 0xb7703c6c>}
nname: 152
n 152(None)[]:
	i: 93(), 129()
	o: 

nname: 129
n 129(None)[louie_send(signal='on_foreground', sender=last_menu.menu)
]:
	i: 30(f)
	o: 152()

nname: 93
n 93(None)[last_menu.unpause_perpetual_anim()
louie_send(signal='on_show', sender=last_menu.menu)
]:
	i: 30(t)
	o: 152()

nname: 30
n 30(last_menu._is_hidden)[removed_menu = self.menu_stack.pop()
removed_menu.remove()
last_menu = self.menu_stack[-1]
self.down_window_layer(removed_menu._layer_depth)
]:
	i: 21(), 29()
	o: 93(t), 129(f)

nname: 29
n 29(None)[]:
	i: 0(f)
	o: 30()

nname: 21
n 21(None)[]:
	i: 0(t)
	o: 30()

nname: 0
n 0(len(self.menu_stack) <= 1)[]:
	i: 
	o: 21(t), 29(f)

nname: 152
n 152(None)[]:
	i: 0()
	o: 

nname: 0
n 0(None)[if len(self.menu_stack) <= 1:
	pass
removed_menu = self.menu_stack.pop()
removed_menu.remove()
last_menu = self.menu_stack[-1]
self.down_window_layer(removed_menu._layer_depth)
if last_menu._is_hidden:
	last_menu.unpause_perpetual_anim()
	louie_send(signal='on_show', sender=last_menu.menu)
else:
	louie_send(signal='on_foreground', sender=last_menu.menu)
]:
	i: 
	o: 152()

nname: 0
n 0(None)[if len(self.menu_stack) <= 1:
	pass
removed_menu = self.menu_stack.pop()
removed_menu.remove()
last_menu = self.menu_stack[-1]
self.down_window_layer(removed_menu._layer_depth)
if last_menu._is_hidden:
	last_menu.unpause_perpetual_anim()
	louie_send(signal='on_show', sender=last_menu.menu)
else:
	louie_send(signal='on_foreground', sender=last_menu.menu)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7780e8c>}
nname: 175
n 175(None)[]:
	i: 116(), 152()
	o: 

nname: 152
n 152(None)[louie_send(signal='on_foreground', sender=last_menu.menu)
]:
	i: 94(f)
	o: 175()

nname: 116
n 116(None)[last_menu.unpause_perpetual_anim()
louie_send(signal='on_show', sender=last_menu.menu)
]:
	i: 94(t)
	o: 175()

nname: 94
n 94(last_menu._is_hidden)[last_menu = self.menu_stack[-1]
]:
	i: 0(AL), 92()
	o: 116(t), 152(f)

nname: 92
n 92(None)[]:
	i: 3&24(f), 47()
	o: 94()

nname: 47
n 47(None)[removed_menu = self.menu_stack.pop()
removed_menu.remove()
self.down_window_layer(removed_menu._layer_depth)
]:
	i: 3&24(t)
	o: 92()

nname: 3&24
n 3&24(len(self.menu_stack) > 1 and self.menu_stack[-1].menu != menu)[]:
	i: 0(loop)
	o: 47(t), 92(f)

nname: 0
n 0(None)[]:
	i: 
	o: 3&24(loop), 94(AL)

nname: 94
n 94(None)[last_menu = self.menu_stack[-1]
if last_menu._is_hidden:
	last_menu.unpause_perpetual_anim()
	louie_send(signal='on_show', sender=last_menu.menu)
else:
	louie_send(signal='on_foreground', sender=last_menu.menu)
]:
	i: 47()
	o: 

nname: 47
n 47(None)[	removed_menu = self.menu_stack.pop()
	removed_menu.remove()
	self.down_window_layer(removed_menu._layer_depth)
]:
	i: 0(t)
	o: 94()

nname: 0
n 0(len(self.menu_stack) > 1 and self.menu_stack[-1].menu != menu)[while len(self.menu_stack) > 1 and self.menu_stack[-1].menu != menu:
]:
	i: 
	o: 47(t)

nname: 94
n 94(None)[last_menu = self.menu_stack[-1]
if last_menu._is_hidden:
	last_menu.unpause_perpetual_anim()
	louie_send(signal='on_show', sender=last_menu.menu)
else:
	louie_send(signal='on_foreground', sender=last_menu.menu)
]:
	i: 0()
	o: 

nname: 0
n 0(None)[while len(self.menu_stack) > 1 and self.menu_stack[-1].menu != menu:
	removed_menu = self.menu_stack.pop()
	removed_menu.remove()
	self.down_window_layer(removed_menu._layer_depth)
]:
	i: 
	o: 94()

nname: 0
n 0(None)[while len(self.menu_stack) > 1 and self.menu_stack[-1].menu != menu:
	removed_menu = self.menu_stack.pop()
	removed_menu.remove()
	self.down_window_layer(removed_menu._layer_depth)
last_menu = self.menu_stack[-1]
if last_menu._is_hidden:
	last_menu.unpause_perpetual_anim()
	louie_send(signal='on_show', sender=last_menu.menu)
else:
	louie_send(signal='on_foreground', sender=last_menu.menu)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb778084c>}
nname: 191
n 191(None)[]:
	i: 141(), 190()
	o: 

nname: 190
n 190(None)[]:
	i: 122(f)
	o: 191()

nname: 141
n 141(None)[top_menu = self.menu_stack[-1]
louie_send(signal='on_show', sender=top_menu.menu)
top_menu.unpause_perpetual_anim()
]:
	i: 122(t)
	o: 191()

nname: 122
n 122(group_on_top)[layer = self.menu_stack[-1]
]:
	i: 0(AL), 121()
	o: 141(t), 190(f)

nname: 121
n 121(None)[]:
	i: 32(AF), 49()
	o: 122()

nname: 49
n 49(None)[for i in xrange(_range + 1):
removed = self.menu_stack.pop(rank)
removed.remove()
self.down_window_layer(removed._layer_depth)
louie_send(signal='on_remove', sender=removed.menu)
]:
	i: 32(for)
	o: 121()

nname: 32
n 32(None)[]:
	i: 0(loop)
	o: 49(for), 121(AF)

nname: 0
n 0(None)[group_on_top = _range + rank == len(self.menu_stack) - 1
]:
	i: 
	o: 32(loop), 122(AL)

nname: 122
n 122(None)[layer = self.menu_stack[-1]
if group_on_top:
	top_menu = self.menu_stack[-1]
	louie_send(signal='on_show', sender=top_menu.menu)
	top_menu.unpause_perpetual_anim()
]:
	i: 49()
	o: 

nname: 49
n 49(None)[for i in xrange(_range + 1):
	removed = self.menu_stack.pop(rank)
	removed.remove()
	self.down_window_layer(removed._layer_depth)
	louie_send(signal='on_remove', sender=removed.menu)
]:
	i: 0(for)
	o: 122()

nname: 0
n 0(None)[group_on_top = _range + rank == len(self.menu_stack) - 1
]:
	i: 
	o: 49(for)

nname: 122
n 122(None)[layer = self.menu_stack[-1]
if group_on_top:
	top_menu = self.menu_stack[-1]
	louie_send(signal='on_show', sender=top_menu.menu)
	top_menu.unpause_perpetual_anim()
]:
	i: 0()
	o: 

nname: 0
n 0(None)[group_on_top = _range + rank == len(self.menu_stack) - 1
for i in xrange(_range + 1):
	removed = self.menu_stack.pop(rank)
	removed.remove()
	self.down_window_layer(removed._layer_depth)
	louie_send(signal='on_remove', sender=removed.menu)
]:
	i: 
	o: 122()

nname: 0
n 0(None)[group_on_top = _range + rank == len(self.menu_stack) - 1
for i in xrange(_range + 1):
	removed = self.menu_stack.pop(rank)
	removed.remove()
	self.down_window_layer(removed._layer_depth)
	louie_send(signal='on_remove', sender=removed.menu)
layer = self.menu_stack[-1]
if group_on_top:
	top_menu = self.menu_stack[-1]
	louie_send(signal='on_show', sender=top_menu.menu)
	top_menu.unpause_perpetual_anim()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb77038ec>}
nname: 461
n 461(None)[ms[-1].unpause_perpetual_anim()
]:
	i: 391(AL), 460()
	o: 

nname: 460
n 460(None)[]:
	i: 394(AF), 413()
	o: 461()

nname: 413
n 413(None)[for elt in chain((last,), groups_menu_last):
elt._is_hidden = True
louie_send(signal='on_hide', sender=elt.menu)
elt.pause_perpetual_anim()
]:
	i: 394(for)
	o: 460()

nname: 394
n 394(None)[]:
	i: 391(loop)
	o: 413(for), 460(AF)

nname: 391
n 391(None)[]:
	i: 331(AL), 390()
	o: 394(loop), 461(AL)

nname: 390
n 390(None)[]:
	i: 334(AF), 353()
	o: 391()

nname: 353
n 353(None)[for elt in chain((first,), groups_menu_first):
elt._is_hidden = False
louie_send(signal='on_show', sender=elt.menu)
]:
	i: 334(for)
	o: 390()

nname: 334
n 334(None)[]:
	i: 331(loop)
	o: 353(for), 390(AF)

nname: 331
n 331(None)[]:
	i: 272(AL), 330()
	o: 334(loop), 391(AL)

nname: 330
n 330(None)[]:
	i: 275(AF), 286()
	o: 331()

nname: 286
n 286(None)[for m in ms[i1:]:
m.set_layer(base_layer, 1)
m._layer = base_layer
base_layer += m._layer_depth
]:
	i: 275(for)
	o: 330()

nname: 275
n 275(None)[]:
	i: 272(loop)
	o: 286(for), 330(AF)

nname: 272
n 272(None)[]:
	i: 183(AL), 271()
	o: 275(loop), 331(AL)

nname: 271
n 271(None)[]:
	i: 211(AF), 224()
	o: 272()

nname: 224
n 224(None)[for indice in xrange(len_group_last):
ms.insert(i1 + 1 + indice, ms.pop(i2 + 1 + indice))
]:
	i: 211(for)
	o: 271()

nname: 211
n 211(None)[]:
	i: 183(loop)
	o: 224(for), 271(AF)

nname: 183
n 183(None)[ms.insert(i1, ms.pop(i2))
]:
	i: 135(AL), 182()
	o: 211(loop), 272(AL)

nname: 182
n 182(None)[]:
	i: 138(AF), 151()
	o: 183()

nname: 151
n 151(None)[for indice in xrange(len_group_last):
groups_menu_last.append(ms[i2 + indice + 1])
]:
	i: 138(for)
	o: 182()

nname: 138
n 138(None)[]:
	i: 135(loop)
	o: 151(for), 182(AF)

nname: 135
n 135(None)[]:
	i: 39(AL), 134()
	o: 138(loop), 183(AL)

nname: 134
n 134(None)[]:
	i: 90(AF), 103()
	o: 135()

nname: 103
n 103(None)[for indice in xrange(len_group_first):
groups_menu_first.append(ms[i1 + indice + 1])
]:
	i: 90(for)
	o: 134()

nname: 90
n 90(None)[]:
	i: 39(loop)
	o: 103(for), 134(AF)

nname: 39
n 39(None)[first = ms[i1]
last = ms[i2]
base_layer = first._layer
groups_menu_first, groups_menu_last = list(), list()
]:
	i: 21(), 38()
	o: 90(loop), 135(AL)

nname: 38
n 38(None)[]:
	i: 0(f)
	o: 39()

nname: 21
n 21(None)[i2, i1 = i1, i2
]:
	i: 0(t)
	o: 39()

nname: 0
n 0(i1 > i2)[ms = self.menu_stack
]:
	i: 
	o: 21(t), 38(f)

nname: 460
n 460(None)[ms[-1].unpause_perpetual_anim()
]:
	i: 394()
	o: 

nname: 394
n 394(None)[for elt in chain((last,), groups_menu_last):
	elt._is_hidden = True
	louie_send(signal='on_hide', sender=elt.menu)
	elt.pause_perpetual_anim()
]:
	i: 390(loop)
	o: 460()

nname: 390
n 390(None)[]:
	i: 334()
	o: 394(loop)

nname: 334
n 334(None)[for elt in chain((first,), groups_menu_first):
	elt._is_hidden = False
	louie_send(signal='on_show', sender=elt.menu)
]:
	i: 330(loop)
	o: 390()

nname: 330
n 330(None)[]:
	i: 275()
	o: 334(loop)

nname: 275
n 275(None)[for m in ms[i1:]:
	m.set_layer(base_layer, 1)
	m._layer = base_layer
	base_layer += m._layer_depth
]:
	i: 271(loop)
	o: 330()

nname: 271
n 271(None)[]:
	i: 211()
	o: 275(loop)

nname: 211
n 211(None)[for indice in xrange(len_group_last):
	ms.insert(i1 + 1 + indice, ms.pop(i2 + 1 + indice))
]:
	i: 182(loop)
	o: 271()

nname: 182
n 182(None)[ms.insert(i1, ms.pop(i2))
]:
	i: 138()
	o: 211(loop)

nname: 138
n 138(None)[for indice in xrange(len_group_last):
	groups_menu_last.append(ms[i2 + indice + 1])
]:
	i: 134(loop)
	o: 182()

nname: 134
n 134(None)[]:
	i: 90()
	o: 138(loop)

nname: 90
n 90(None)[for indice in xrange(len_group_first):
	groups_menu_first.append(ms[i1 + indice + 1])
]:
	i: 0(loop)
	o: 134()

nname: 0
n 0(None)[ms = self.menu_stack
if i1 > i2:
	i2, i1 = i1, i2
first = ms[i1]
last = ms[i2]
base_layer = first._layer
groups_menu_first, groups_menu_last = list(), list()
]:
	i: 
	o: 90(loop)

nname: 460
n 460(None)[ms[-1].unpause_perpetual_anim()
]:
	i: 390()
	o: 

nname: 390
n 390(None)[for elt in chain((last,), groups_menu_last):
	elt._is_hidden = True
	louie_send(signal='on_hide', sender=elt.menu)
	elt.pause_perpetual_anim()
]:
	i: 330()
	o: 460()

nname: 330
n 330(None)[for elt in chain((first,), groups_menu_first):
	elt._is_hidden = False
	louie_send(signal='on_show', sender=elt.menu)
]:
	i: 271()
	o: 390()

nname: 271
n 271(None)[for m in ms[i1:]:
	m.set_layer(base_layer, 1)
	m._layer = base_layer
	base_layer += m._layer_depth
]:
	i: 182()
	o: 330()

nname: 182
n 182(None)[ms.insert(i1, ms.pop(i2))
for indice in xrange(len_group_last):
	ms.insert(i1 + 1 + indice, ms.pop(i2 + 1 + indice))
]:
	i: 134()
	o: 271()

nname: 134
n 134(None)[for indice in xrange(len_group_last):
	groups_menu_last.append(ms[i2 + indice + 1])
]:
	i: 0()
	o: 182()

nname: 0
n 0(None)[ms = self.menu_stack
if i1 > i2:
	i2, i1 = i1, i2
first = ms[i1]
last = ms[i2]
base_layer = first._layer
groups_menu_first, groups_menu_last = list(), list()
for indice in xrange(len_group_first):
	groups_menu_first.append(ms[i1 + indice + 1])
]:
	i: 
	o: 134()

nname: 460
n 460(None)[ms[-1].unpause_perpetual_anim()
]:
	i: 330()
	o: 

nname: 330
n 330(None)[for elt in chain((first,), groups_menu_first):
	elt._is_hidden = False
	louie_send(signal='on_show', sender=elt.menu)
for elt in chain((last,), groups_menu_last):
	elt._is_hidden = True
	louie_send(signal='on_hide', sender=elt.menu)
	elt.pause_perpetual_anim()
]:
	i: 182()
	o: 460()

nname: 182
n 182(None)[ms.insert(i1, ms.pop(i2))
for indice in xrange(len_group_last):
	ms.insert(i1 + 1 + indice, ms.pop(i2 + 1 + indice))
for m in ms[i1:]:
	m.set_layer(base_layer, 1)
	m._layer = base_layer
	base_layer += m._layer_depth
]:
	i: 0()
	o: 330()

nname: 0
n 0(None)[ms = self.menu_stack
if i1 > i2:
	i2, i1 = i1, i2
first = ms[i1]
last = ms[i2]
base_layer = first._layer
groups_menu_first, groups_menu_last = list(), list()
for indice in xrange(len_group_first):
	groups_menu_first.append(ms[i1 + indice + 1])
for indice in xrange(len_group_last):
	groups_menu_last.append(ms[i2 + indice + 1])
]:
	i: 
	o: 182()

nname: 330
n 330(None)[for elt in chain((first,), groups_menu_first):
	elt._is_hidden = False
	louie_send(signal='on_show', sender=elt.menu)
for elt in chain((last,), groups_menu_last):
	elt._is_hidden = True
	louie_send(signal='on_hide', sender=elt.menu)
	elt.pause_perpetual_anim()
ms[-1].unpause_perpetual_anim()
]:
	i: 0()
	o: 

nname: 0
n 0(None)[ms = self.menu_stack
if i1 > i2:
	i2, i1 = i1, i2
first = ms[i1]
last = ms[i2]
base_layer = first._layer
groups_menu_first, groups_menu_last = list(), list()
for indice in xrange(len_group_first):
	groups_menu_first.append(ms[i1 + indice + 1])
for indice in xrange(len_group_last):
	groups_menu_last.append(ms[i2 + indice + 1])
ms.insert(i1, ms.pop(i2))
for indice in xrange(len_group_last):
	ms.insert(i1 + 1 + indice, ms.pop(i2 + 1 + indice))
for m in ms[i1:]:
	m.set_layer(base_layer, 1)
	m._layer = base_layer
	base_layer += m._layer_depth
]:
	i: 
	o: 330()

nname: 0
n 0(None)[ms = self.menu_stack
if i1 > i2:
	i2, i1 = i1, i2
first = ms[i1]
last = ms[i2]
base_layer = first._layer
groups_menu_first, groups_menu_last = list(), list()
for indice in xrange(len_group_first):
	groups_menu_first.append(ms[i1 + indice + 1])
for indice in xrange(len_group_last):
	groups_menu_last.append(ms[i2 + indice + 1])
ms.insert(i1, ms.pop(i2))
for indice in xrange(len_group_last):
	ms.insert(i1 + 1 + indice, ms.pop(i2 + 1 + indice))
for m in ms[i1:]:
	m.set_layer(base_layer, 1)
	m._layer = base_layer
	base_layer += m._layer_depth
for elt in chain((first,), groups_menu_first):
	elt._is_hidden = False
	louie_send(signal='on_show', sender=elt.menu)
for elt in chain((last,), groups_menu_last):
	elt._is_hidden = True
	louie_send(signal='on_hide', sender=elt.menu)
	elt.pause_perpetual_anim()
ms[-1].unpause_perpetual_anim()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb770008c>}
nname: 177
n 177(None)[louie_send(signal='on_create', sender=menu)
]:
	i: 0(AL), 176()
	o: 

nname: 176
n 176(None)[]:
	i: 121(AF), 132()
	o: 177()

nname: 132
n 132(None)[for m in ms[pos:]:
m.set_layer(base_layer, 1)
m._layer = base_layer
base_layer += m._layer_depth
]:
	i: 121(for)
	o: 176()

nname: 121
n 121(None)[]:
	i: 0(loop)
	o: 132(for), 176(AF)

nname: 0
n 0(None)[log.debug('ms=%s menu=%s pos=%s', self.menu_stack, menu, pos)
ms = self.menu_stack
base_layer = ms[pos]._layer
menu_content = self.create_content(menu, layer=base_layer)
ms[pos].remove()
louie_send(signal='on_remove', sender=ms[pos].menu)
ms[pos] = menu_content
]:
	i: 
	o: 121(loop), 177(AL)

nname: 177
n 177(None)[louie_send(signal='on_create', sender=menu)
]:
	i: 132()
	o: 

nname: 132
n 132(None)[for m in ms[pos:]:
	m.set_layer(base_layer, 1)
	m._layer = base_layer
	base_layer += m._layer_depth
]:
	i: 0(for)
	o: 177()

nname: 0
n 0(None)[log.debug('ms=%s menu=%s pos=%s', self.menu_stack, menu, pos)
ms = self.menu_stack
base_layer = ms[pos]._layer
menu_content = self.create_content(menu, layer=base_layer)
ms[pos].remove()
louie_send(signal='on_remove', sender=ms[pos].menu)
ms[pos] = menu_content
]:
	i: 
	o: 132(for)

nname: 177
n 177(None)[louie_send(signal='on_create', sender=menu)
]:
	i: 0()
	o: 

nname: 0
n 0(None)[log.debug('ms=%s menu=%s pos=%s', self.menu_stack, menu, pos)
ms = self.menu_stack
base_layer = ms[pos]._layer
menu_content = self.create_content(menu, layer=base_layer)
ms[pos].remove()
louie_send(signal='on_remove', sender=ms[pos].menu)
ms[pos] = menu_content
for m in ms[pos:]:
	m.set_layer(base_layer, 1)
	m._layer = base_layer
	base_layer += m._layer_depth
]:
	i: 
	o: 177()

nname: 0
n 0(None)[log.debug('ms=%s menu=%s pos=%s', self.menu_stack, menu, pos)
ms = self.menu_stack
base_layer = ms[pos]._layer
menu_content = self.create_content(menu, layer=base_layer)
ms[pos].remove()
louie_send(signal='on_remove', sender=ms[pos].menu)
ms[pos] = menu_content
for m in ms[pos:]:
	m.set_layer(base_layer, 1)
	m._layer = base_layer
	base_layer += m._layer_depth
louie_send(signal='on_create', sender=menu)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7703ecc>}
nname: 6
n 6(None)[__doc__ = ' This class manages ONE view\n    (associated with one theme handler, associated with a display)\n    You must add some ViewManager to the engines of MenuManager (menu/menu/stack.py)\n    '
def __init__(self, display, theme):
	self._visible = False
	self._content = None
	self.wl = WidgetLibrary()
	self.theme = theme
	self.display = display
	self.menu_stack = list()
	self.window_dict = dict()
	self.menu_cache = weakref.WeakValueDictionary()
	self.on_idle = False
	self.up_window_layer = partial(self.update_window_layer, up_layer=True)
	self.down_window_layer = partial(self.update_window_layer, up_layer=False)
	return None

def __getattr__(self, attr):
	return getattr(self._content, attr)

def __repr__(self):
	return '<gui.Application @%s, %s skin>' % (self.display, self.theme)

def __getitem__(self, name):
	if name.startswith('menu'):
		return MenuWidget(name, self.display, self.wl)
	else:
		if name.startswith('window'):
			from .window import __engine__
			return __engine__[name](name, self.display, self.wl)

def loader_iterator(self):
	if config.use_serialized_theme:
		for step in xrange(1, 4):
			datapack = os.path.join(config.themes_dir, self.theme, 'xml', 'data.pk%d' % step)
			if os.path.exists(datapack):
				self.wl.load_pickle(datapack)
				yield None
				continue
			raise StopIteration
	else:
		self.wl.load_xml(os.path.join(config.themes_dir, self.theme, 'xml'))
		yield None

def add_window(self, win):
	window_content = self['window_%s' % win.type]
	if window_content:
		window_content.display = self.display
		self.window_dict[win] = window_content
		window_content.show(win)
		louie_send(signal='on_create', sender=win)

def remove_window(self, win):
	louie_send(signal='on_remove', sender=win)
	self.window_dict[win].hide()
	del self.window_dict[win]

def update_window(self, win):
	wid = self.window_dict.get(win)
	if wid is not None:
		wid.update()
	else:
		log.warn('%s is not on screen anymore...', win)
	return None

def update_window_layer(self, menu_layer, up_layer=True):
	if not self.on_idle:
		for win in self.window_dict.values():
			if up_layer:
				win._layer = max(<genexpr>(self.menu_stack)) + menu_layer
			else:
				win._layer -= menu_layer
			win.set_layer(win._layer)

def create_content(self, menu, showing=None, layer=None):
	if not showing:
		showing = 'menu_%s' % menu.type
	try:
		menu_content = self[showing]
		menu_content.create(menu, self.wl.get_container(showing, menu=menu))
		if layer is not None:
			menu_content.set_layer(layer)

def push_menu(self, menu, hide_previous_menu=True):
	if config.navigator_cache and menu.type in ('audio', 'video', 'image', 'video_image'):
		if menu.type in self.menu_cache:
			menu_content = self.menu_cache[menu.type]
			menu_content.menu = menu
			menu_content.sync_model_view()
			for animation in menu_content._animations:
				louie_connect(receiver=animation.play, signal=animation.event, sender=menu)
		else:
			menu_content = self.create_content(menu)
			menu_content.cached = True
			self.menu_cache[menu.type] = menu_content
	else:
		menu_content = self.create_content(menu)
	if menu_content:
		if len(self.menu_stack) > 0:
			prev_menu = self.menu_stack[-1]
			if hide_previous_menu:
				prev_menu.pause_perpetual_anim()
				prev_menu._is_hidden = True
				louie_send(signal='on_hide', sender=prev_menu.menu)
			else:
				prev_menu._is_hidden = False
				louie_send(signal='on_background', sender=prev_menu.menu)
		self.menu_stack.append(menu_content)
		self.up_window_layer(menu_content._layer_depth)
		louie_send(signal='on_create', sender=menu)
	else:
		log.warning('Unable to create a widget for this menu')

def back_one_menu(self):
	if len(self.menu_stack) <= 1:
		pass
	removed_menu = self.menu_stack.pop()
	removed_menu.remove()
	last_menu = self.menu_stack[-1]
	self.down_window_layer(removed_menu._layer_depth)
	if last_menu._is_hidden:
		last_menu.unpause_perpetual_anim()
		louie_send(signal='on_show', sender=last_menu.menu)
	else:
		louie_send(signal='on_foreground', sender=last_menu.menu)

def back_to_menu(self, menu):
	while len(self.menu_stack) > 1 and self.menu_stack[-1].menu != menu:
		removed_menu = self.menu_stack.pop()
		removed_menu.remove()
		self.down_window_layer(removed_menu._layer_depth)
	last_menu = self.menu_stack[-1]
	if last_menu._is_hidden:
		last_menu.unpause_perpetual_anim()
		louie_send(signal='on_show', sender=last_menu.menu)
	else:
		louie_send(signal='on_foreground', sender=last_menu.menu)

def pop_group(self, rank, _range):
	group_on_top = _range + rank == len(self.menu_stack) - 1
	for i in xrange(_range + 1):
		removed = self.menu_stack.pop(rank)
		removed.remove()
		self.down_window_layer(removed._layer_depth)
		louie_send(signal='on_remove', sender=removed.menu)
	layer = self.menu_stack[-1]
	if group_on_top:
		top_menu = self.menu_stack[-1]
		louie_send(signal='on_show', sender=top_menu.menu)
		top_menu.unpause_perpetual_anim()

def swap(self, i1, i2, len_group_first=0, len_group_last=0):
	ms = self.menu_stack
	if i1 > i2:
		i2, i1 = i1, i2
	first = ms[i1]
	last = ms[i2]
	base_layer = first._layer
	groups_menu_first, groups_menu_last = list(), list()
	for indice in xrange(len_group_first):
		groups_menu_first.append(ms[i1 + indice + 1])
	for indice in xrange(len_group_last):
		groups_menu_last.append(ms[i2 + indice + 1])
	ms.insert(i1, ms.pop(i2))
	for indice in xrange(len_group_last):
		ms.insert(i1 + 1 + indice, ms.pop(i2 + 1 + indice))
	for m in ms[i1:]:
		m.set_layer(base_layer, 1)
		m._layer = base_layer
		base_layer += m._layer_depth
	for elt in chain((first,), groups_menu_first):
		elt._is_hidden = False
		louie_send(signal='on_show', sender=elt.menu)
	for elt in chain((last,), groups_menu_last):
		elt._is_hidden = True
		louie_send(signal='on_hide', sender=elt.menu)
		elt.pause_perpetual_anim()
	ms[-1].unpause_perpetual_anim()

def switch_sub_menu(self, menu, pos):
	log.debug('ms=%s menu=%s pos=%s', self.menu_stack, menu, pos)
	ms = self.menu_stack
	base_layer = ms[pos]._layer
	menu_content = self.create_content(menu, layer=base_layer)
	ms[pos].remove()
	louie_send(signal='on_remove', sender=ms[pos].menu)
	ms[pos] = menu_content
	for m in ms[pos:]:
		m.set_layer(base_layer, 1)
		m._layer = base_layer
		base_layer += m._layer_depth
	louie_send(signal='on_create', sender=menu)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb7778e2c>}
nname: 0
n 0(None)[from __future__ import absolute_import
import pygui.config as config
import weakref
from itertools import chain
from peewee.debug import GET_LOGGER, PRINT_EXCEPTION
from peewee.messages import connect as louie_connect, send as louie_send
from .widget import MenuWidget
from pygui.gui.widget.core.widgetfactory import WidgetLibrary
import os
log = GET_LOGGER(__name__)
from functools import partial
class ViewManager(object):
	__doc__ = ' This class manages ONE view\n    (associated with one theme handler, associated with a display)\n    You must add some ViewManager to the engines of MenuManager (menu/menu/stack.py)\n    '
	def __init__(self, display, theme):
		self._visible = False
		self._content = None
		self.wl = WidgetLibrary()
		self.theme = theme
		self.display = display
		self.menu_stack = list()
		self.window_dict = dict()
		self.menu_cache = weakref.WeakValueDictionary()
		self.on_idle = False
		self.up_window_layer = partial(self.update_window_layer, up_layer=True)
		self.down_window_layer = partial(self.update_window_layer, up_layer=False)
		return None

	def __getattr__(self, attr):
		return getattr(self._content, attr)

	def __repr__(self):
		return '<gui.Application @%s, %s skin>' % (self.display, self.theme)

	def __getitem__(self, name):
		if name.startswith('menu'):
			return MenuWidget(name, self.display, self.wl)
		else:
			if name.startswith('window'):
				from .window import __engine__
				return __engine__[name](name, self.display, self.wl)

	def loader_iterator(self):
		if config.use_serialized_theme:
			for step in xrange(1, 4):
				datapack = os.path.join(config.themes_dir, self.theme, 'xml', 'data.pk%d' % step)
				if os.path.exists(datapack):
					self.wl.load_pickle(datapack)
					yield None
					continue
				raise StopIteration
		else:
			self.wl.load_xml(os.path.join(config.themes_dir, self.theme, 'xml'))
			yield None

	def add_window(self, win):
		window_content = self['window_%s' % win.type]
		if window_content:
			window_content.display = self.display
			self.window_dict[win] = window_content
			window_content.show(win)
			louie_send(signal='on_create', sender=win)

	def remove_window(self, win):
		louie_send(signal='on_remove', sender=win)
		self.window_dict[win].hide()
		del self.window_dict[win]

	def update_window(self, win):
		wid = self.window_dict.get(win)
		if wid is not None:
			wid.update()
		else:
			log.warn('%s is not on screen anymore...', win)
		return None

	def update_window_layer(self, menu_layer, up_layer=True):
		if not self.on_idle:
			for win in self.window_dict.values():
				if up_layer:
					win._layer = max(<genexpr>(self.menu_stack)) + menu_layer
				else:
					win._layer -= menu_layer
				win.set_layer(win._layer)

	def create_content(self, menu, showing=None, layer=None):
		if not showing:
			showing = 'menu_%s' % menu.type
		try:
			menu_content = self[showing]
			menu_content.create(menu, self.wl.get_container(showing, menu=menu))
			if layer is not None:
				menu_content.set_layer(layer)

	def push_menu(self, menu, hide_previous_menu=True):
		if config.navigator_cache and menu.type in ('audio', 'video', 'image', 'video_image'):
			if menu.type in self.menu_cache:
				menu_content = self.menu_cache[menu.type]
				menu_content.menu = menu
				menu_content.sync_model_view()
				for animation in menu_content._animations:
					louie_connect(receiver=animation.play, signal=animation.event, sender=menu)
			else:
				menu_content = self.create_content(menu)
				menu_content.cached = True
				self.menu_cache[menu.type] = menu_content
		else:
			menu_content = self.create_content(menu)
		if menu_content:
			if len(self.menu_stack) > 0:
				prev_menu = self.menu_stack[-1]
				if hide_previous_menu:
					prev_menu.pause_perpetual_anim()
					prev_menu._is_hidden = True
					louie_send(signal='on_hide', sender=prev_menu.menu)
				else:
					prev_menu._is_hidden = False
					louie_send(signal='on_background', sender=prev_menu.menu)
			self.menu_stack.append(menu_content)
			self.up_window_layer(menu_content._layer_depth)
			louie_send(signal='on_create', sender=menu)
		else:
			log.warning('Unable to create a widget for this menu')

	def back_one_menu(self):
		if len(self.menu_stack) <= 1:
			pass
		removed_menu = self.menu_stack.pop()
		removed_menu.remove()
		last_menu = self.menu_stack[-1]
		self.down_window_layer(removed_menu._layer_depth)
		if last_menu._is_hidden:
			last_menu.unpause_perpetual_anim()
			louie_send(signal='on_show', sender=last_menu.menu)
		else:
			louie_send(signal='on_foreground', sender=last_menu.menu)

	def back_to_menu(self, menu):
		while len(self.menu_stack) > 1 and self.menu_stack[-1].menu != menu:
			removed_menu = self.menu_stack.pop()
			removed_menu.remove()
			self.down_window_layer(removed_menu._layer_depth)
		last_menu = self.menu_stack[-1]
		if last_menu._is_hidden:
			last_menu.unpause_perpetual_anim()
			louie_send(signal='on_show', sender=last_menu.menu)
		else:
			louie_send(signal='on_foreground', sender=last_menu.menu)

	def pop_group(self, rank, _range):
		group_on_top = _range + rank == len(self.menu_stack) - 1
		for i in xrange(_range + 1):
			removed = self.menu_stack.pop(rank)
			removed.remove()
			self.down_window_layer(removed._layer_depth)
			louie_send(signal='on_remove', sender=removed.menu)
		layer = self.menu_stack[-1]
		if group_on_top:
			top_menu = self.menu_stack[-1]
			louie_send(signal='on_show', sender=top_menu.menu)
			top_menu.unpause_perpetual_anim()

	def swap(self, i1, i2, len_group_first=0, len_group_last=0):
		ms = self.menu_stack
		if i1 > i2:
			i2, i1 = i1, i2
		first = ms[i1]
		last = ms[i2]
		base_layer = first._layer
		groups_menu_first, groups_menu_last = list(), list()
		for indice in xrange(len_group_first):
			groups_menu_first.append(ms[i1 + indice + 1])
		for indice in xrange(len_group_last):
			groups_menu_last.append(ms[i2 + indice + 1])
		ms.insert(i1, ms.pop(i2))
		for indice in xrange(len_group_last):
			ms.insert(i1 + 1 + indice, ms.pop(i2 + 1 + indice))
		for m in ms[i1:]:
			m.set_layer(base_layer, 1)
			m._layer = base_layer
			base_layer += m._layer_depth
		for elt in chain((first,), groups_menu_first):
			elt._is_hidden = False
			louie_send(signal='on_show', sender=elt.menu)
		for elt in chain((last,), groups_menu_last):
			elt._is_hidden = True
			louie_send(signal='on_hide', sender=elt.menu)
			elt.pause_perpetual_anim()
		ms[-1].unpause_perpetual_anim()

	def switch_sub_menu(self, menu, pos):
		log.debug('ms=%s menu=%s pos=%s', self.menu_stack, menu, pos)
		ms = self.menu_stack
		base_layer = ms[pos]._layer
		menu_content = self.create_content(menu, layer=base_layer)
		ms[pos].remove()
		louie_send(signal='on_remove', sender=ms[pos].menu)
		ms[pos] = menu_content
		for m in ms[pos:]:
			m.set_layer(base_layer, 1)
			m._layer = base_layer
			base_layer += m._layer_depth
		louie_send(signal='on_create', sender=menu)



]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7770acc>}
from __future__ import absolute_import
import pygui.config as config
import weakref
from itertools import chain
from peewee.debug import GET_LOGGER, PRINT_EXCEPTION
from peewee.messages import connect as louie_connect, send as louie_send
from .widget import MenuWidget
from pygui.gui.widget.core.widgetfactory import WidgetLibrary
import os
log = GET_LOGGER(__name__)
from functools import partial
class ViewManager(object):
	__doc__ = ' This class manages ONE view\n    (associated with one theme handler, associated with a display)\n    You must add some ViewManager to the engines of MenuManager (menu/menu/stack.py)\n    '
	def __init__(self, display, theme):
		self._visible = False
		self._content = None
		self.wl = WidgetLibrary()
		self.theme = theme
		self.display = display
		self.menu_stack = list()
		self.window_dict = dict()
		self.menu_cache = weakref.WeakValueDictionary()
		self.on_idle = False
		self.up_window_layer = partial(self.update_window_layer, up_layer=True)
		self.down_window_layer = partial(self.update_window_layer, up_layer=False)
		return None

	def __getattr__(self, attr):
		return getattr(self._content, attr)

	def __repr__(self):
		return '<gui.Application @%s, %s skin>' % (self.display, self.theme)

	def __getitem__(self, name):
		if name.startswith('menu'):
			return MenuWidget(name, self.display, self.wl)
		else:
			if name.startswith('window'):
				from .window import __engine__
				return __engine__[name](name, self.display, self.wl)

	def loader_iterator(self):
		if config.use_serialized_theme:
			for step in xrange(1, 4):
				datapack = os.path.join(config.themes_dir, self.theme, 'xml', 'data.pk%d' % step)
				if os.path.exists(datapack):
					self.wl.load_pickle(datapack)
					yield None
					continue
				raise StopIteration
		else:
			self.wl.load_xml(os.path.join(config.themes_dir, self.theme, 'xml'))
			yield None

	def add_window(self, win):
		window_content = self['window_%s' % win.type]
		if window_content:
			window_content.display = self.display
			self.window_dict[win] = window_content
			window_content.show(win)
			louie_send(signal='on_create', sender=win)

	def remove_window(self, win):
		louie_send(signal='on_remove', sender=win)
		self.window_dict[win].hide()
		del self.window_dict[win]

	def update_window(self, win):
		wid = self.window_dict.get(win)
		if wid is not None:
			wid.update()
		else:
			log.warn('%s is not on screen anymore...', win)
		return None

	def update_window_layer(self, menu_layer, up_layer=True):
		if not self.on_idle:
			for win in self.window_dict.values():
				if up_layer:
					win._layer = max(<genexpr>(self.menu_stack)) + menu_layer
				else:
					win._layer -= menu_layer
				win.set_layer(win._layer)

	def create_content(self, menu, showing=None, layer=None):
		if not showing:
			showing = 'menu_%s' % menu.type
		try:
			menu_content = self[showing]
			menu_content.create(menu, self.wl.get_container(showing, menu=menu))
			if layer is not None:
				menu_content.set_layer(layer)

	def push_menu(self, menu, hide_previous_menu=True):
		if config.navigator_cache and menu.type in ('audio', 'video', 'image', 'video_image'):
			if menu.type in self.menu_cache:
				menu_content = self.menu_cache[menu.type]
				menu_content.menu = menu
				menu_content.sync_model_view()
				for animation in menu_content._animations:
					louie_connect(receiver=animation.play, signal=animation.event, sender=menu)
			else:
				menu_content = self.create_content(menu)
				menu_content.cached = True
				self.menu_cache[menu.type] = menu_content
		else:
			menu_content = self.create_content(menu)
		if menu_content:
			if len(self.menu_stack) > 0:
				prev_menu = self.menu_stack[-1]
				if hide_previous_menu:
					prev_menu.pause_perpetual_anim()
					prev_menu._is_hidden = True
					louie_send(signal='on_hide', sender=prev_menu.menu)
				else:
					prev_menu._is_hidden = False
					louie_send(signal='on_background', sender=prev_menu.menu)
			self.menu_stack.append(menu_content)
			self.up_window_layer(menu_content._layer_depth)
			louie_send(signal='on_create', sender=menu)
		else:
			log.warning('Unable to create a widget for this menu')

	def back_one_menu(self):
		if len(self.menu_stack) <= 1:
			pass
		removed_menu = self.menu_stack.pop()
		removed_menu.remove()
		last_menu = self.menu_stack[-1]
		self.down_window_layer(removed_menu._layer_depth)
		if last_menu._is_hidden:
			last_menu.unpause_perpetual_anim()
			louie_send(signal='on_show', sender=last_menu.menu)
		else:
			louie_send(signal='on_foreground', sender=last_menu.menu)

	def back_to_menu(self, menu):
		while len(self.menu_stack) > 1 and self.menu_stack[-1].menu != menu:
			removed_menu = self.menu_stack.pop()
			removed_menu.remove()
			self.down_window_layer(removed_menu._layer_depth)
		last_menu = self.menu_stack[-1]
		if last_menu._is_hidden:
			last_menu.unpause_perpetual_anim()
			louie_send(signal='on_show', sender=last_menu.menu)
		else:
			louie_send(signal='on_foreground', sender=last_menu.menu)

	def pop_group(self, rank, _range):
		group_on_top = _range + rank == len(self.menu_stack) - 1
		for i in xrange(_range + 1):
			removed = self.menu_stack.pop(rank)
			removed.remove()
			self.down_window_layer(removed._layer_depth)
			louie_send(signal='on_remove', sender=removed.menu)
		layer = self.menu_stack[-1]
		if group_on_top:
			top_menu = self.menu_stack[-1]
			louie_send(signal='on_show', sender=top_menu.menu)
			top_menu.unpause_perpetual_anim()

	def swap(self, i1, i2, len_group_first=0, len_group_last=0):
		ms = self.menu_stack
		if i1 > i2:
			i2, i1 = i1, i2
		first = ms[i1]
		last = ms[i2]
		base_layer = first._layer
		groups_menu_first, groups_menu_last = list(), list()
		for indice in xrange(len_group_first):
			groups_menu_first.append(ms[i1 + indice + 1])
		for indice in xrange(len_group_last):
			groups_menu_last.append(ms[i2 + indice + 1])
		ms.insert(i1, ms.pop(i2))
		for indice in xrange(len_group_last):
			ms.insert(i1 + 1 + indice, ms.pop(i2 + 1 + indice))
		for m in ms[i1:]:
			m.set_layer(base_layer, 1)
			m._layer = base_layer
			base_layer += m._layer_depth
		for elt in chain((first,), groups_menu_first):
			elt._is_hidden = False
			louie_send(signal='on_show', sender=elt.menu)
		for elt in chain((last,), groups_menu_last):
			elt._is_hidden = True
			louie_send(signal='on_hide', sender=elt.menu)
			elt.pause_perpetual_anim()
		ms[-1].unpause_perpetual_anim()

	def switch_sub_menu(self, menu, pos):
		log.debug('ms=%s menu=%s pos=%s', self.menu_stack, menu, pos)
		ms = self.menu_stack
		base_layer = ms[pos]._layer
		menu_content = self.create_content(menu, layer=base_layer)
		ms[pos].remove()
		louie_send(signal='on_remove', sender=ms[pos].menu)
		ms[pos] = menu_content
		for m in ms[pos:]:
			m.set_layer(base_layer, 1)
			m._layer = base_layer
			base_layer += m._layer_depth
		louie_send(signal='on_create', sender=menu)



