# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 134
n 134(None)[]:
	i: 119(), 133()
	o: 

nname: 133
n 133(None)[]:
	i: 19(f)
	o: 134()

nname: 119
n 119(None)[self.set_scroll()
]:
	i: 19(t)
	o: 134()

nname: 19
n 19(autoscroll)[self._max_width = max_width
self._pause = 1.0
self.text = ''
self._text = ''
self.total_size = 0
self._style = ''
self.i18n = i18n
wyvas.TextBlock.__init__(self)
self.scroll_timer = Task(self.next)
]:
	i: 0(t), 15()
	o: 119(t), 133(f)

nname: 15
n 15(None)[]:
	i: 0(f)
	o: 19()

nname: 0
n 0(max_width)[self._lastmove = 0
]:
	i: 
	o: 15(f), 19(t)

nname: 134
n 134(None)[]:
	i: 0()
	o: 

nname: 0
n 0(None)[self._lastmove = 0
if not max_width:
	pass
self._max_width = max_width
self._pause = 1.0
self.text = ''
self._text = ''
self.total_size = 0
self._style = ''
self.i18n = i18n
wyvas.TextBlock.__init__(self)
self.scroll_timer = Task(self.next)
if autoscroll:
	self.set_scroll()
]:
	i: 
	o: 134()

nname: 0
n 0(None)[self._lastmove = 0
if not max_width:
	pass
self._max_width = max_width
self._pause = 1.0
self.text = ''
self._text = ''
self.total_size = 0
self._style = ''
self.i18n = i18n
wyvas.TextBlock.__init__(self)
self.scroll_timer = Task(self.next)
if autoscroll:
	self.set_scroll()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb768450c>}
nname: 103
n 103(None)[return None
]:
	i: 22(JA), 54(), 102()
	o: 

nname: 102
n 102(None)[]:
	i: 0(f)
	o: 103()

nname: 54
n 54(None)[self.scroll_timer.stop()
self._offset = -1
self.next()
self._lastmove = sched.ts
]:
	i: 15(f)
	o: 103()

nname: 22
n 22(None)[self.scroll_timer.start(0.29999999999999999, consider_idle=True, loop=True)
]:
	i: 15(t)
	o: 103(JA)

nname: 15
n 15(activated)[]:
	i: 0(t)
	o: 22(t), 54(f)

nname: 0
n 0(self.scroll_timer is not None)[]:
	i: 
	o: 15(t), 102(f)

nname: 0
n 0(None)[if self.scroll_timer is not None:
	if activated:
		self.scroll_timer.start(0.29999999999999999, consider_idle=True, loop=True)
	else:
		self.scroll_timer.stop()
		self._offset = -1
		self.next()
		self._lastmove = sched.ts
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb768408c>}
nname: 33
n 33(None)[return None
]:
	i: 15(), 32()
	o: 

nname: 32
n 32(None)[]:
	i: 0(f)
	o: 33()

nname: 15
n 15(None)[self.scroll_timer.stop()
]:
	i: 0(t)
	o: 33()

nname: 0
n 0(self.scroll_timer is not None)[]:
	i: 
	o: 15(t), 32(f)

nname: 0
n 0(None)[if self.scroll_timer is not None:
	self.scroll_timer.stop()
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb767fd0c>}
nname: 0
n 0(None)[self.stop()
self.scroll_timer = None
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb767fe2c>}
nname: 0
n 0(None)[self._style = kwargs['style']
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb767fc2c>}
nname: 44
n 44(None)[txt = xml_tag(self._style, html_format(self.text))
return txt.replace('//CURSOR//', '<color=#000000>_</>')
]:
	i: 21(), 37()
	o: 

nname: 37
n 37(None)[]:
	i: 0(f)
	o: 44()

nname: 21
n 21(None)[]:
	i: 0(t)
	o: 44()

nname: 0
n 0(self.i18n)[]:
	i: 
	o: 21(t), 37(f)

nname: 0
n 0(None)[if self.i18n:
	pass
txt = xml_tag(self._style, html_format(self.text))
return txt.replace('//CURSOR//', '<color=#000000>_</>')
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb767fcec>}
nname: 76
n 76(None)[]:
	i: 3(), 38(), 75(AE)
	o: 

nname: 38
n 38(None)[wyvas.TextBlock.set_text(self, rendered_text.encode('ascii', 'ignore'))
]:
	i: 0(except)
	o: 76()

nname: 3
n 3(None)[rendered_text = self.render_text()
wyvas.TextBlock.set_text(self, rendered_text)
]:
	i: 0(try)
	o: 76()

nname: 0
n 0(None)[]:
	i: 
	o: 3(try), 38(except)

nname: 38
n 38(None)[except:
	wyvas.TextBlock.set_text(self, rendered_text.encode('ascii', 'ignore'))
]:
	i: 0()
	o: 

nname: 0
n 0(None)[try:
	rendered_text = self.render_text()
	wyvas.TextBlock.set_text(self, rendered_text)
]:
	i: 
	o: 38()

nname: 0
n 0(None)[try:
	rendered_text = self.render_text()
	wyvas.TextBlock.set_text(self, rendered_text)
except:
	wyvas.TextBlock.set_text(self, rendered_text.encode('ascii', 'ignore'))
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb767fccc>}
nname: 270
n 270(None)[return None
]:
	i: 209(), 232(), 269(AE)
	o: 

nname: 232
n 232(None)[wyvas.TextBlock.set_text(self, rendered_text.encode('ascii', 'ignore'))
]:
	i: 203(except)
	o: 270()

nname: 209
n 209(None)[wyvas.TextBlock.set_text(self, rendered_text)
]:
	i: 203(try)
	o: 270()

nname: 203
n 203(None)[rendered_text = ''
]:
	i: 186(), 199()
	o: 209(try), 232(except)

nname: 199
n 199(None)[]:
	i: 174(f)
	o: 203()

nname: 186
n 186(None)[]:
	i: 174(t)
	o: 203()

nname: 174
n 174(text is not None)[]:
	i: 144(), 164()
	o: 186(t), 199(f)

nname: 164
n 164(None)[self.text = text
]:
	i: 102(f)
	o: 174()

nname: 144
n 144(None)[self.text = text[:self._max_width]
]:
	i: 102(t)
	o: 174()

nname: 102
n 102(self.total_size > self._max_width)[self.total_size = 0
self._text = text
self._offset = 0
]:
	i: 85(), 98()
	o: 144(t), 164(f)

nname: 98
n 98(None)[]:
	i: 79(f)
	o: 102()

nname: 85
n 85(None)[]:
	i: 79(t)
	o: 102()

nname: 79
n 79(text)[]:
	i: 64(), 78()
	o: 85(t), 98(f)

nname: 78
n 78(None)[]:
	i: 24&42(f)
	o: 79()

nname: 64
n 64(None)[text = text + '  ~  '
]:
	i: 24&42(t)
	o: 79()

nname: 24&42
n 24&42(text and len(text) > self._max_width)[self._lastmove = sched.ts
]:
	i: 15(), 23()
	o: 64(t), 78(f)

nname: 23
n 23(None)[]:
	i: 0(f)
	o: 24&42()

nname: 15
n 15(None)[return None
]:
	i: 0(t)
	o: 24&42()

nname: 0
n 0(self._text == text)[]:
	i: 
	o: 15(t), 23(f)

nname: 270
n 270(None)[return None
]:
	i: 209()
	o: 

nname: 209
n 209(None)[try:
	wyvas.TextBlock.set_text(self, rendered_text)
except:
	wyvas.TextBlock.set_text(self, rendered_text.encode('ascii', 'ignore'))
]:
	i: 174(try)
	o: 270()

nname: 174
n 174(None)[if text is not None:
	pass
rendered_text = ''
]:
	i: 79()
	o: 209(try)

nname: 79
n 79(None)[if text:
	pass
self.total_size = 0
self._text = text
self._offset = 0
if self.total_size > self._max_width:
	self.text = text[:self._max_width]
else:
	self.text = text
]:
	i: 0()
	o: 174()

nname: 0
n 0(None)[if self._text == text:
	return None
self._lastmove = sched.ts
if text and len(text) > self._max_width:
	text = text + '  ~  '
]:
	i: 
	o: 79()

nname: 270
n 270(None)[return None
]:
	i: 174()
	o: 

nname: 174
n 174(None)[if text is not None:
	pass
rendered_text = ''
try:
	wyvas.TextBlock.set_text(self, rendered_text)
except:
	wyvas.TextBlock.set_text(self, rendered_text.encode('ascii', 'ignore'))
]:
	i: 0()
	o: 270()

nname: 0
n 0(None)[if self._text == text:
	return None
self._lastmove = sched.ts
if text and len(text) > self._max_width:
	text = text + '  ~  '
if text:
	pass
self.total_size = 0
self._text = text
self._offset = 0
if self.total_size > self._max_width:
	self.text = text[:self._max_width]
else:
	self.text = text
]:
	i: 
	o: 174()

nname: 270
n 270(None)[return None
]:
	i: 0()
	o: 

nname: 0
n 0(None)[if self._text == text:
	return None
self._lastmove = sched.ts
if text and len(text) > self._max_width:
	text = text + '  ~  '
if text:
	pass
self.total_size = 0
self._text = text
self._offset = 0
if self.total_size > self._max_width:
	self.text = text[:self._max_width]
else:
	self.text = text
if text is not None:
	pass
rendered_text = ''
try:
	wyvas.TextBlock.set_text(self, rendered_text)
except:
	wyvas.TextBlock.set_text(self, rendered_text.encode('ascii', 'ignore'))
]:
	i: 
	o: 270()

nname: 0
n 0(None)[if self._text == text:
	return None
self._lastmove = sched.ts
if text and len(text) > self._max_width:
	text = text + '  ~  '
if text:
	pass
self.total_size = 0
self._text = text
self._offset = 0
if self.total_size > self._max_width:
	self.text = text[:self._max_width]
else:
	self.text = text
if text is not None:
	pass
rendered_text = ''
try:
	wyvas.TextBlock.set_text(self, rendered_text)
except:
	wyvas.TextBlock.set_text(self, rendered_text.encode('ascii', 'ignore'))
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb768498c>}
nname: 52
n 52(None)[return None
]:
	i: 38(), 51()
	o: 

nname: 51
n 51(None)[]:
	i: 26(f)
	o: 52()

nname: 38
n 38(None)[self._pause = pause
]:
	i: 26(t)
	o: 52()

nname: 26
n 26(pause is not None)[]:
	i: 12(), 25()
	o: 38(t), 51(f)

nname: 25
n 25(None)[]:
	i: 0(f)
	o: 26()

nname: 12
n 12(None)[self._max_width = maxlen
]:
	i: 0(t)
	o: 26()

nname: 0
n 0(maxlen is not None)[]:
	i: 
	o: 12(t), 25(f)

nname: 52
n 52(None)[return None
]:
	i: 0()
	o: 

nname: 0
n 0(None)[if maxlen is not None:
	self._max_width = maxlen
if pause is not None:
	self._pause = pause
]:
	i: 
	o: 52()

nname: 0
n 0(None)[if maxlen is not None:
	self._max_width = maxlen
if pause is not None:
	self._pause = pause
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb767feec>}
nname: 264
n 264(None)[return None
]:
	i: 231(), 263()
	o: 

nname: 263
n 263(None)[]:
	i: 195(f)
	o: 264()

nname: 231
n 231(None)[wyvas.TextBlock.set_text(self, r_txt)
self._rendered_text = r_txt
]:
	i: 195(t)
	o: 264()

nname: 195
n 195(r_txt != getattr(self, '_rendered_text', None))[r_txt = self.render_text()
]:
	i: 182(), 194()
	o: 231(t), 263(f)

nname: 194
n 194(None)[]:
	i: 0(f)
	o: 195()

nname: 182
n 182(None)[self.text = txt
]:
	i: 168(), 181()
	o: 195()

nname: 181
n 181(None)[]:
	i: 85(f)
	o: 182()

nname: 168
n 168(None)[self._offset = -1
]:
	i: 85(t)
	o: 182()

nname: 85
n 85(self._offset == self.total_size)[self._offset += 1
txt = (self._text[self._offset:self._offset + self._max_width] + self._text[:self._offset])[:self._max_width]
]:
	i: 68(), 84()
	o: 168(t), 181(f)

nname: 84
n 84(None)[]:
	i: 53(f)
	o: 85()

nname: 68
n 68(None)[self._lastmove = sched.ts
]:
	i: 53(t)
	o: 85()

nname: 53
n 53(self._offset == -1)[]:
	i: 44(), 52()
	o: 68(t), 84(f)

nname: 52
n 52(None)[]:
	i: 18(f)
	o: 53()

nname: 44
n 44(None)[return None
]:
	i: 18(t)
	o: 53()

nname: 18
n 18(self._lastmove + self._pause > sched.ts)[]:
	i: 0(t)
	o: 44(t), 52(f)

nname: 0
n 0(self.total_size > self._max_width)[]:
	i: 
	o: 18(t), 194(f)

nname: 195
n 195(None)[r_txt = self.render_text()
if r_txt != getattr(self, '_rendered_text', None):
	wyvas.TextBlock.set_text(self, r_txt)
	self._rendered_text = r_txt
return None
]:
	i: 85(), 0(f)
	o: 

nname: 85
n 85(None)[self._offset += 1
txt = (self._text[self._offset:self._offset + self._max_width] + self._text[:self._offset])[:self._max_width]
if self._offset == self.total_size:
	self._offset = -1
self.text = txt
]:
	i: 18()
	o: 195()

nname: 18
n 18(None)[if self._lastmove + self._pause > sched.ts:
	return None
if self._offset == -1:
	self._lastmove = sched.ts
]:
	i: 0(t)
	o: 85()

nname: 0
n 0(self.total_size > self._max_width)[]:
	i: 
	o: 18(t), 195(f)

nname: 195
n 195(None)[r_txt = self.render_text()
if r_txt != getattr(self, '_rendered_text', None):
	wyvas.TextBlock.set_text(self, r_txt)
	self._rendered_text = r_txt
return None
]:
	i: 18(), 0(f)
	o: 

nname: 18
n 18(None)[if self._lastmove + self._pause > sched.ts:
	return None
if self._offset == -1:
	self._lastmove = sched.ts
self._offset += 1
txt = (self._text[self._offset:self._offset + self._max_width] + self._text[:self._offset])[:self._max_width]
if self._offset == self.total_size:
	self._offset = -1
self.text = txt
]:
	i: 0(t)
	o: 195()

nname: 0
n 0(self.total_size > self._max_width)[]:
	i: 
	o: 18(t), 195(f)

nname: 0
n 0(None)[if self.total_size > self._max_width:
	if self._lastmove + self._pause > sched.ts:
		return None
	if self._offset == -1:
		self._lastmove = sched.ts
	self._offset += 1
	txt = (self._text[self._offset:self._offset + self._max_width] + self._text[:self._offset])[:self._max_width]
	if self._offset == self.total_size:
		self._offset = -1
	self.text = txt
r_txt = self.render_text()
if r_txt != getattr(self, '_rendered_text', None):
	wyvas.TextBlock.set_text(self, r_txt)
	self._rendered_text = r_txt
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7686c0c>}
nname: 6
n 6(None)[def __init__(self, autoscroll=False, max_width=None, i18n=False):
	self._lastmove = 0
	if not max_width:
		pass
	self._max_width = max_width
	self._pause = 1.0
	self.text = ''
	self._text = ''
	self.total_size = 0
	self._style = ''
	self.i18n = i18n
	wyvas.TextBlock.__init__(self)
	self.scroll_timer = Task(self.next)
	if autoscroll:
		self.set_scroll()

def set_scroll(self, activated=True):
	if self.scroll_timer is not None:
		if activated:
			self.scroll_timer.start(0.29999999999999999, consider_idle=True, loop=True)
		else:
			self.scroll_timer.stop()
			self._offset = -1
			self.next()
			self._lastmove = sched.ts
	return None

def stop(self):
	if self.scroll_timer is not None:
		self.scroll_timer.stop()
	return None

def clear(self):
	self.stop()
	self.scroll_timer = None
	return None

def set_style(self, **kwargs):
	self._style = kwargs['style']

def render_text(self):
	if self.i18n:
		pass
	txt = xml_tag(self._style, html_format(self.text))
	return txt.replace('//CURSOR//', '<color=#000000>_</>')

def refresh_text(self):
	try:
		rendered_text = self.render_text()
		wyvas.TextBlock.set_text(self, rendered_text)
	except:
		wyvas.TextBlock.set_text(self, rendered_text.encode('ascii', 'ignore'))

def set_text(self, text):
	if self._text == text:
		return None
	self._lastmove = sched.ts
	if text and len(text) > self._max_width:
		text = text + '  ~  '
	if text:
		pass
	self.total_size = 0
	self._text = text
	self._offset = 0
	if self.total_size > self._max_width:
		self.text = text[:self._max_width]
	else:
		self.text = text
	if text is not None:
		pass
	rendered_text = ''
	try:
		wyvas.TextBlock.set_text(self, rendered_text)
	except:
		wyvas.TextBlock.set_text(self, rendered_text.encode('ascii', 'ignore'))
	return None

def set_length(self, maxlen=None, pause=None):
	if maxlen is not None:
		self._max_width = maxlen
	if pause is not None:
		self._pause = pause
	return None

def next(self):
	if self.total_size > self._max_width:
		if self._lastmove + self._pause > sched.ts:
			return None
		if self._offset == -1:
			self._lastmove = sched.ts
		self._offset += 1
		txt = (self._text[self._offset:self._offset + self._max_width] + self._text[:self._offset])[:self._max_width]
		if self._offset == self.total_size:
			self._offset = -1
		self.text = txt
	r_txt = self.render_text()
	if r_txt != getattr(self, '_rendered_text', None):
		wyvas.TextBlock.set_text(self, r_txt)
		self._rendered_text = r_txt
	return None

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb767f84c>}
nname: 165
n 165(None)[return result
]:
	i: 0(AL), 164()
	o: 

nname: 164
n 164(None)[]:
	i: 9(AF), 161()
	o: 165()

nname: 161
n 161(None)[]:
	i: 43(AL), 160()
	o: 164()

nname: 160
n 160(None)[]:
	i: 28(f), 155()
	o: 161()

nname: 155
n 155(None)[continue
]:
	i: 98(f), 110()
	o: 160()

nname: 110
n 110(None)[_a, _b = divmod(color, 16)
result += str(hexa_to_rgb_dict[_b])
]:
	i: 98(t)
	o: 155()

nname: 98
n 98(_a > 0)[]:
	i: 43(loop)
	o: 110(t), 155(f)

nname: 43
n 43(None)[result += '0'
_a, _b = divmod(color, 16)
result += str(hexa_to_rgb_dict[_b])
]:
	i: 28(t)
	o: 98(loop), 161(AL)

nname: 28
n 28(color < 159)[for color in [r, g, b, a]:
]:
	i: 9(for)
	o: 43(t), 160(f)

nname: 9
n 9(None)[]:
	i: 0(loop)
	o: 28(for), 164(AF)

nname: 0
n 0(None)[result = ''
]:
	i: 
	o: 9(loop), 165(AL)

nname: 165
n 165(None)[return result
]:
	i: 0(AL), 9(AF), 43(AL), 28(f), 155()
	o: 

nname: 155
n 155(None)[continue
]:
	i: 98(f), 110()
	o: 165()

nname: 110
n 110(None)[_a, _b = divmod(color, 16)
result += str(hexa_to_rgb_dict[_b])
]:
	i: 98(t)
	o: 155()

nname: 98
n 98(_a > 0)[]:
	i: 43(loop)
	o: 110(t), 155(f)

nname: 43
n 43(None)[result += '0'
_a, _b = divmod(color, 16)
result += str(hexa_to_rgb_dict[_b])
]:
	i: 28(t)
	o: 98(loop), 165(AL)

nname: 28
n 28(color < 159)[for color in [r, g, b, a]:
]:
	i: 9(for)
	o: 43(t), 165(f)

nname: 9
n 9(None)[]:
	i: 0(loop)
	o: 28(for), 165(AF)

nname: 0
n 0(None)[result = ''
]:
	i: 
	o: 9(loop), 165(AL)

nname: 165
n 165(None)[return result
]:
	i: 0(AL), 9(AF), 28(f), 110()
	o: 

nname: 110
n 110(None)[	_a, _b = divmod(color, 16)
	result += str(hexa_to_rgb_dict[_b])
else:
	continue
]:
	i: 43(t)
	o: 165()

nname: 43
n 43(_a > 0)[result += '0'
_a, _b = divmod(color, 16)
result += str(hexa_to_rgb_dict[_b])
while _a > 0:
]:
	i: 28(t)
	o: 110(t)

nname: 28
n 28(color < 159)[for color in [r, g, b, a]:
]:
	i: 9(for)
	o: 43(t), 165(f)

nname: 9
n 9(None)[]:
	i: 0(loop)
	o: 28(for), 165(AF)

nname: 0
n 0(None)[result = ''
]:
	i: 
	o: 9(loop), 165(AL)

nname: 165
n 165(None)[return result
]:
	i: 0(AL), 9(AF), 28(f), 43()
	o: 

nname: 43
n 43(None)[result += '0'
_a, _b = divmod(color, 16)
result += str(hexa_to_rgb_dict[_b])
while _a > 0:
	_a, _b = divmod(color, 16)
	result += str(hexa_to_rgb_dict[_b])
else:
	continue
]:
	i: 28(t)
	o: 165()

nname: 28
n 28(color < 159)[for color in [r, g, b, a]:
]:
	i: 9(for)
	o: 43(t), 165(f)

nname: 9
n 9(None)[]:
	i: 0(loop)
	o: 28(for), 165(AF)

nname: 0
n 0(None)[result = ''
]:
	i: 
	o: 9(loop), 165(AL)

nname: 28
n 28(None)[for color in [r, g, b, a]:
	if color < 159:
		result += '0'
		_a, _b = divmod(color, 16)
		result += str(hexa_to_rgb_dict[_b])
		while _a > 0:
			_a, _b = divmod(color, 16)
			result += str(hexa_to_rgb_dict[_b])
		else:
			continue
return result
]:
	i: 0(for)
	o: 

nname: 0
n 0(None)[result = ''
]:
	i: 
	o: 28(for)

nname: 0
n 0(None)[result = ''
for color in [r, g, b, a]:
	if color < 159:
		result += '0'
		_a, _b = divmod(color, 16)
		result += str(hexa_to_rgb_dict[_b])
		while _a > 0:
			_a, _b = divmod(color, 16)
			result += str(hexa_to_rgb_dict[_b])
		else:
			continue
return result
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb767f7ac>}
nname: 0
n 0(None)[return []
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7678d0c>}
nname: 0
n 0(None)[from __future__ import absolute_import
import wyvas
from peewee.formatters import html_format, xml_tag
from peewee.notifier import Task, sched
class TextBlock(.):
	def __init__(self, autoscroll=False, max_width=None, i18n=False):
		self._lastmove = 0
		if not max_width:
			pass
		self._max_width = max_width
		self._pause = 1.0
		self.text = ''
		self._text = ''
		self.total_size = 0
		self._style = ''
		self.i18n = i18n
		wyvas.TextBlock.__init__(self)
		self.scroll_timer = Task(self.next)
		if autoscroll:
			self.set_scroll()

	def set_scroll(self, activated=True):
		if self.scroll_timer is not None:
			if activated:
				self.scroll_timer.start(0.29999999999999999, consider_idle=True, loop=True)
			else:
				self.scroll_timer.stop()
				self._offset = -1
				self.next()
				self._lastmove = sched.ts
		return None

	def stop(self):
		if self.scroll_timer is not None:
			self.scroll_timer.stop()
		return None

	def clear(self):
		self.stop()
		self.scroll_timer = None
		return None

	def set_style(self, **kwargs):
		self._style = kwargs['style']

	def render_text(self):
		if self.i18n:
			pass
		txt = xml_tag(self._style, html_format(self.text))
		return txt.replace('//CURSOR//', '<color=#000000>_</>')

	def refresh_text(self):
		try:
			rendered_text = self.render_text()
			wyvas.TextBlock.set_text(self, rendered_text)
		except:
			wyvas.TextBlock.set_text(self, rendered_text.encode('ascii', 'ignore'))

	def set_text(self, text):
		if self._text == text:
			return None
		self._lastmove = sched.ts
		if text and len(text) > self._max_width:
			text = text + '  ~  '
		if text:
			pass
		self.total_size = 0
		self._text = text
		self._offset = 0
		if self.total_size > self._max_width:
			self.text = text[:self._max_width]
		else:
			self.text = text
		if text is not None:
			pass
		rendered_text = ''
		try:
			wyvas.TextBlock.set_text(self, rendered_text)
		except:
			wyvas.TextBlock.set_text(self, rendered_text.encode('ascii', 'ignore'))
		return None

	def set_length(self, maxlen=None, pause=None):
		if maxlen is not None:
			self._max_width = maxlen
		if pause is not None:
			self._pause = pause
		return None

	def next(self):
		if self.total_size > self._max_width:
			if self._lastmove + self._pause > sched.ts:
				return None
			if self._offset == -1:
				self._lastmove = sched.ts
			self._offset += 1
			txt = (self._text[self._offset:self._offset + self._max_width] + self._text[:self._offset])[:self._max_width]
			if self._offset == self.total_size:
				self._offset = -1
			self.text = txt
		r_txt = self.render_text()
		if r_txt != getattr(self, '_rendered_text', None):
			wyvas.TextBlock.set_text(self, r_txt)
			self._rendered_text = r_txt
		return None



hexa_to_rgb_dict = map(None, range(16), range(10) + list('abcdef'))
def convert_color(r=0, g=0, b=0, a=0):
	result = ''
	for color in [r, g, b, a]:
		if color < 159:
			result += '0'
			_a, _b = divmod(color, 16)
			result += str(hexa_to_rgb_dict[_b])
			while _a > 0:
				_a, _b = divmod(color, 16)
				result += str(hexa_to_rgb_dict[_b])
			else:
				continue
	return result

def convert_hexa(self, hexa='00000000'):
	return []

]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76785ac>}
from __future__ import absolute_import
import wyvas
from peewee.formatters import html_format, xml_tag
from peewee.notifier import Task, sched
class TextBlock(.):
	def __init__(self, autoscroll=False, max_width=None, i18n=False):
		self._lastmove = 0
		if not max_width:
			pass
		self._max_width = max_width
		self._pause = 1.0
		self.text = ''
		self._text = ''
		self.total_size = 0
		self._style = ''
		self.i18n = i18n
		wyvas.TextBlock.__init__(self)
		self.scroll_timer = Task(self.next)
		if autoscroll:
			self.set_scroll()

	def set_scroll(self, activated=True):
		if self.scroll_timer is not None:
			if activated:
				self.scroll_timer.start(0.29999999999999999, consider_idle=True, loop=True)
			else:
				self.scroll_timer.stop()
				self._offset = -1
				self.next()
				self._lastmove = sched.ts
		return None

	def stop(self):
		if self.scroll_timer is not None:
			self.scroll_timer.stop()
		return None

	def clear(self):
		self.stop()
		self.scroll_timer = None
		return None

	def set_style(self, **kwargs):
		self._style = kwargs['style']

	def render_text(self):
		if self.i18n:
			pass
		txt = xml_tag(self._style, html_format(self.text))
		return txt.replace('//CURSOR//', '<color=#000000>_</>')

	def refresh_text(self):
		try:
			rendered_text = self.render_text()
			wyvas.TextBlock.set_text(self, rendered_text)
		except:
			wyvas.TextBlock.set_text(self, rendered_text.encode('ascii', 'ignore'))

	def set_text(self, text):
		if self._text == text:
			return None
		self._lastmove = sched.ts
		if text and len(text) > self._max_width:
			text = text + '  ~  '
		if text:
			pass
		self.total_size = 0
		self._text = text
		self._offset = 0
		if self.total_size > self._max_width:
			self.text = text[:self._max_width]
		else:
			self.text = text
		if text is not None:
			pass
		rendered_text = ''
		try:
			wyvas.TextBlock.set_text(self, rendered_text)
		except:
			wyvas.TextBlock.set_text(self, rendered_text.encode('ascii', 'ignore'))
		return None

	def set_length(self, maxlen=None, pause=None):
		if maxlen is not None:
			self._max_width = maxlen
		if pause is not None:
			self._pause = pause
		return None

	def next(self):
		if self.total_size > self._max_width:
			if self._lastmove + self._pause > sched.ts:
				return None
			if self._offset == -1:
				self._lastmove = sched.ts
			self._offset += 1
			txt = (self._text[self._offset:self._offset + self._max_width] + self._text[:self._offset])[:self._max_width]
			if self._offset == self.total_size:
				self._offset = -1
			self.text = txt
		r_txt = self.render_text()
		if r_txt != getattr(self, '_rendered_text', None):
			wyvas.TextBlock.set_text(self, r_txt)
			self._rendered_text = r_txt
		return None



hexa_to_rgb_dict = map(None, range(16), range(10) + list('abcdef'))
def convert_color(r=0, g=0, b=0, a=0):
	result = ''
	for color in [r, g, b, a]:
		if color < 159:
			result += '0'
			_a, _b = divmod(color, 16)
			result += str(hexa_to_rgb_dict[_b])
			while _a > 0:
				_a, _b = divmod(color, 16)
				result += str(hexa_to_rgb_dict[_b])
			else:
				continue
	return result

def convert_hexa(self, hexa='00000000'):
	return []

