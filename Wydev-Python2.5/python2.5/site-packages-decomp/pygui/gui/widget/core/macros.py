# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 0
n 0(None)[return eval('%s' % m[3:], MACRO_GLOBS, {})
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76129cc>}
nname: 29
n 29(None)[# from __future__ import division
# CAUTION! future division detected!
step = (stop - start) / (num_values - 1)
return <genexpr>(xrange(num_values))
]:
	i: 12(), 28()
	o: 

nname: 28
n 28(None)[]:
	i: 0(f)
	o: 29()

nname: 12
n 12(None)[raise ValueError('linear() must return at least 2 values')
]:
	i: 0(t)
	o: 29()

nname: 0
n 0(num_values <= 1)[]:
	i: 
	o: 12(t), 28(f)

nname: 0
n 0(None)[if num_values <= 1:
	raise ValueError('linear() must return at least 2 values')
# from __future__ import division
# CAUTION! future division detected!
step = (stop - start) / (num_values - 1)
return <genexpr>(xrange(num_values))
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7612e0c>}
nname: 0
n 0(None)[list.__init__(self, <genexpr>(_linear(start, stop, num_values)))
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76135cc>}
nname: 0
n 0(None)[return ' '.join(self)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7612dcc>}
nname: 6
n 6(None)[__doc__ = 'LinearInts(start, stop, num_values)\n\n    Linear sequence of num_values integers,\n    ranging from start to stop inclusive.\n\n    Its string representation is space-separated.\n\n    >>> str(LinearInts(0, 100, 3))\n    "0 50 100"\n    '
def __init__(self, start, stop, num_values):
	list.__init__(self, <genexpr>(_linear(start, stop, num_values)))

def __str__(self):
	return ' '.join(self)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb7612f6c>}
nname: 0
n 0(None)[list.__init__(self, <genexpr>(_linear(start, stop, num_values)))
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76134cc>}
nname: 0
n 0(None)[return ' '.join(self)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7612d4c>}
nname: 6
n 6(None)[__doc__ = 'LinearFloats(start, stop, num_values)\n\n    Linear sequence of num_values floats (2 decimal places),\n    ranging from start to stop inclusive.\n\n    Its string representation is space-separated.\n\n    >>> str(LinearFloats(0, 100, 3))\n    "0.00 50.00 100.00"\n    '
def __init__(self, start, stop, num_values):
	list.__init__(self, <genexpr>(_linear(start, stop, num_values)))

def __str__(self):
	return ' '.join(self)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb7612b4c>}
nname: 0
n 0(None)[list.__init__(self, <genexpr>(_linear(start, stop, num_values)))
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb761346c>}
nname: 0
n 0(None)[return ' '.join(self)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7612dac>}
nname: 6
n 6(None)[__doc__ = 'LinearPercentages(start, stop, num_values)\n\n    Linear sequence of num_values percentages,\n    ranging from start% to stop% inclusive.\n\n    Its string representation is space-separated.\n\n    >>> str(LinearPercentages(0, 100, 3))\n    "0% 50% 100%"\n    '
def __init__(self, start, stop, num_values):
	list.__init__(self, <genexpr>(_linear(start, stop, num_values)))

def __str__(self):
	return ' '.join(self)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb7612bcc>}
nname: 42
n 42(None)[return NotImplemented
]:
	i: 15(), 41()
	o: 

nname: 41
n 41(None)[]:
	i: 0(f)
	o: 42()

nname: 15
n 15(None)[return TupleSequence(list.__add__(self, other))
]:
	i: 0(t)
	o: 42()

nname: 0
n 0(isinstance(other, TupleSequence))[]:
	i: 
	o: 15(t), 41(f)

nname: 0
n 0(None)[if isinstance(other, TupleSequence):
	return TupleSequence(list.__add__(self, other))
return NotImplemented
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb761316c>}
nname: 0
n 0(None)[return ' '.join(<genexpr>(self))
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7612eac>}
nname: 6
n 6(None)[__doc__ = 'A sequence of n-tuples of strings. Supports standard list\n    operations, as well as addition.\n\n    Its string representation uses space-separated groups of\n    comma-separated values.\n\n    >>> str(TupleSequence([("1", "2", "3"), ("4", "5", "6")]))\n    "1,2,3 4,5,6"\n    '
def __add__(self, other):
	if isinstance(other, TupleSequence):
		return TupleSequence(list.__add__(self, other))
	return NotImplemented

def __str__(self):
	return ' '.join(<genexpr>(self))

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb7612d6c>}
nname: 317
n 317(None)[TupleSequence.__init__(self, data)
return None
]:
	i: 193(), 299()
	o: 

nname: 299
n 299(None)[data = zip(x_data, y_data, z_data)
]:
	i: 282(), 298()
	o: 317()

nname: 298
n 298(None)[]:
	i: 258(f)
	o: 299()

nname: 282
n 282(None)[raise ValueError('Z argument mismatch -- must have the same length as X and Y')
]:
	i: 258(t)
	o: 299()

nname: 258
n 258(len(z_data) != len(x_data))[]:
	i: 228(), 251()
	o: 282(t), 298(f)

nname: 251
n 251(None)[z_data = z
]:
	i: 212(f)
	o: 258()

nname: 228
n 228(None)[z_data = [z] * len(x_data)
]:
	i: 212(t)
	o: 258()

nname: 212
n 212(isinstance(z, basestring))[]:
	i: 181(f)
	o: 228(t), 251(f)

nname: 193
n 193(None)[data = zip(x_data, y_data)
]:
	i: 181(t)
	o: 317()

nname: 181
n 181(z is None)[]:
	i: 164(), 180()
	o: 193(t), 212(f)

nname: 180
n 180(None)[]:
	i: 140(f)
	o: 181()

nname: 164
n 164(None)[raise ValueError('X/Y argument mismatch -- both must have the same length')
]:
	i: 140(t)
	o: 181()

nname: 140
n 140(len(x_data) != len(y_data))[]:
	i: 31(JA), 53(), 98(), 127()
	o: 164(t), 180(f)

nname: 127
n 127(None)[x_data = x
y_data = y
]:
	i: 82(f)
	o: 140()

nname: 98
n 98(None)[x_data = x
y_data = [y] * len(x)
]:
	i: 82(t)
	o: 140()

nname: 82
n 82(isinstance(y, basestring))[]:
	i: 0(f)
	o: 98(t), 127(f)

nname: 53
n 53(None)[x_data = [x] * len(y)
y_data = y
]:
	i: 15(f)
	o: 140()

nname: 31
n 31(None)[x_data = [x]
y_data = [y]
]:
	i: 15(t)
	o: 140(JA)

nname: 15
n 15(isinstance(y, basestring))[]:
	i: 0(t)
	o: 31(t), 53(f)

nname: 0
n 0(isinstance(x, basestring))[]:
	i: 
	o: 15(t), 82(f)

nname: 317
n 317(None)[TupleSequence.__init__(self, data)
return None
]:
	i: 193(), 299()
	o: 

nname: 299
n 299(None)[data = zip(x_data, y_data, z_data)
]:
	i: 212()
	o: 317()

nname: 212
n 212(None)[if isinstance(z, basestring):
	z_data = [z] * len(x_data)
else:
	z_data = z
if len(z_data) != len(x_data):
	raise ValueError('Z argument mismatch -- must have the same length as X and Y')
]:
	i: 181(f)
	o: 299()

nname: 193
n 193(None)[data = zip(x_data, y_data)
]:
	i: 181(t)
	o: 317()

nname: 181
n 181(z is None)[]:
	i: 0()
	o: 193(t), 212(f)

nname: 0
n 0(None)[if isinstance(x, basestring):
	if isinstance(y, basestring):
		x_data = [x]
		y_data = [y]
	else:
		x_data = [x] * len(y)
		y_data = y
else:
	if isinstance(y, basestring):
		x_data = x
		y_data = [y] * len(x)
	else:
		x_data = x
		y_data = y
if len(x_data) != len(y_data):
	raise ValueError('X/Y argument mismatch -- both must have the same length')
]:
	i: 
	o: 181()

nname: 317
n 317(None)[TupleSequence.__init__(self, data)
return None
]:
	i: 193(), 212()
	o: 

nname: 212
n 212(None)[if isinstance(z, basestring):
	z_data = [z] * len(x_data)
else:
	z_data = z
if len(z_data) != len(x_data):
	raise ValueError('Z argument mismatch -- must have the same length as X and Y')
data = zip(x_data, y_data, z_data)
]:
	i: 0(f)
	o: 317()

nname: 193
n 193(None)[data = zip(x_data, y_data)
]:
	i: 0(t)
	o: 317()

nname: 0
n 0(z is None)[if isinstance(x, basestring):
	if isinstance(y, basestring):
		x_data = [x]
		y_data = [y]
	else:
		x_data = [x] * len(y)
		y_data = y
else:
	if isinstance(y, basestring):
		x_data = x
		y_data = [y] * len(x)
	else:
		x_data = x
		y_data = y
if len(x_data) != len(y_data):
	raise ValueError('X/Y argument mismatch -- both must have the same length')
]:
	i: 
	o: 193(t), 212(f)

nname: 0
n 0(None)[if isinstance(x, basestring):
	if isinstance(y, basestring):
		x_data = [x]
		y_data = [y]
	else:
		x_data = [x] * len(y)
		y_data = y
else:
	if isinstance(y, basestring):
		x_data = x
		y_data = [y] * len(x)
	else:
		x_data = x
		y_data = y
if len(x_data) != len(y_data):
	raise ValueError('X/Y argument mismatch -- both must have the same length')
if z is None:
	data = zip(x_data, y_data)
else:
	if isinstance(z, basestring):
		z_data = [z] * len(x_data)
	else:
		z_data = z
	if len(z_data) != len(x_data):
		raise ValueError('Z argument mismatch -- must have the same length as X and Y')
	data = zip(x_data, y_data, z_data)
TupleSequence.__init__(self, data)
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75a094c>}
nname: 6
n 6(None)[__doc__ = 'ListCoordinates(x_data, y_data[, z_data])\n\n    A sequence of 2D or 3D (usually x, y[, z]) coordinates,\n    used to represent a list.\n\n    It has the following use cases:\n      - Single X, single Y (not really useful, but knock yourself out):\n        >>> ListCoordinates("1", "1")\n        [("1", "1")]\n\n      - Single X, multiple Y:\n        >>> ListCoordinates("1", LinearInts(1, 3, 3))\n        [("1", "1"), ("1", "2"), ("1", "3")]\n\n      - Single Y, multiple X:\n        >>> ListCoordinates(LinearInts(1, 3, 3), 1)\n        [("1", "1"), ("2", "1"), ("3", "1")]\n\n      - Multiple X, multiple Y: This last mode requires both sequences\n        to have the same length. The result is a sequence of that same\n        length -- *not* a grid of len(x) * len(y)!\n\n        >>> ListCoordinates(LinearInts(1, 3, 3), LinearInts(0, 2, 3))\n        [("1", "0"), ("2", "1"), ("3", "2")]\n\n    The string representation returns space-separated pairs, e.g.\n    >>> str(ListCoordinates(LinearInts(1, 3, 3), LinearInts(0, 2, 3)))\n    "1,0 2,1 3,2"\n\n    Likewise, the single and multiple Z cases are properly handled.\n    >>> str(ListCoordinates(LinearPercentages(0, 100, 3), LinearPercentages(100, 200, 3), "0"))\n    "0%,100%,0 50%,150%,0 100%,200%,0"\n\n    >>> str(ListCoordinates(LinearPercentages(0, 100, 3),\n    ... LinearPercentages(100, 200, 3), LinearIntegers(-2, 0, 3)))\n    "0%,100%,-2 50%,150%,-1 100%,200%,0"\n    '
def __init__(self, x, y, z=None):
	if isinstance(x, basestring):
		if isinstance(y, basestring):
			x_data = [x]
			y_data = [y]
		else:
			x_data = [x] * len(y)
			y_data = y
	else:
		if isinstance(y, basestring):
			x_data = x
			y_data = [y] * len(x)
		else:
			x_data = x
			y_data = y
	if len(x_data) != len(y_data):
		raise ValueError('X/Y argument mismatch -- both must have the same length')
	if z is None:
		data = zip(x_data, y_data)
	else:
		if isinstance(z, basestring):
			z_data = [z] * len(x_data)
		else:
			z_data = z
		if len(z_data) != len(x_data):
			raise ValueError('Z argument mismatch -- must have the same length as X and Y')
		data = zip(x_data, y_data, z_data)
	TupleSequence.__init__(self, data)
	return None

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb7612bcc>}
nname: 70
n 70(None)[TupleSequence.__init__(self, <genexpr>(y_list))
]:
	i: 53(), 69()
	o: 

nname: 69
n 69(None)[]:
	i: 35(f)
	o: 70()

nname: 53
n 53(None)[raise ValueError('At least 1 Y position is required')
]:
	i: 35(t)
	o: 70()

nname: 35
n 35(len(y_list) < 1)[]:
	i: 18(), 34()
	o: 53(t), 69(f)

nname: 34
n 34(None)[]:
	i: 0(f)
	o: 35()

nname: 18
n 18(None)[raise ValueError('At least 1 X position is required')
]:
	i: 0(t)
	o: 35()

nname: 0
n 0(len(x_list) < 1)[]:
	i: 
	o: 18(t), 34(f)

nname: 70
n 70(None)[TupleSequence.__init__(self, <genexpr>(y_list))
]:
	i: 0()
	o: 

nname: 0
n 0(None)[if len(x_list) < 1:
	raise ValueError('At least 1 X position is required')
if len(y_list) < 1:
	raise ValueError('At least 1 Y position is required')
]:
	i: 
	o: 70()

nname: 0
n 0(None)[if len(x_list) < 1:
	raise ValueError('At least 1 X position is required')
if len(y_list) < 1:
	raise ValueError('At least 1 Y position is required')
TupleSequence.__init__(self, <genexpr>(y_list))
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7613b4c>}
nname: 6
n 6(None)[__doc__ = 'GridCoordinates(x_data, y_data)\n\n    A sequence of 2D (usually x, y) coordinates, used to represent a grid.\n\n    Unlike L{ListCoordinates}, it requires both its arguments to be\n    lists of length >= 1, and creates len(x_list) * len(y_list)\n    coordinates out of them.\n\n    Example:\n    >>> GridCoordinates(LinearPercentages(0, 100, 3),\n    ... LinearPercentages(10, 20, 2))\n    [("0%", "10%"), ("50%", "10%"), ("100%", "10%"),\n    ("0%", "20%"), ("50%", "20%"), ("100%", "20%")]\n\n    The string representation returns space-separated pairs.\n    '
def __init__(self, x_list, y_list):
	if len(x_list) < 1:
		raise ValueError('At least 1 X position is required')
	if len(y_list) < 1:
		raise ValueError('At least 1 Y position is required')
	TupleSequence.__init__(self, <genexpr>(y_list))

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb761272c>}
nname: 0
n 0(None)[from __future__ import absolute_import
from __future__ import division
import random
def py_macro(m):
	return eval('%s' % m[3:], MACRO_GLOBS, {})

def _linear(start, stop, num_values):
	if num_values <= 1:
		raise ValueError('linear() must return at least 2 values')
	# from __future__ import division
	# CAUTION! future division detected!
	step = (stop - start) / (num_values - 1)
	return <genexpr>(xrange(num_values))

class LinearInts(list):
	__doc__ = 'LinearInts(start, stop, num_values)\n\n    Linear sequence of num_values integers,\n    ranging from start to stop inclusive.\n\n    Its string representation is space-separated.\n\n    >>> str(LinearInts(0, 100, 3))\n    "0 50 100"\n    '
	def __init__(self, start, stop, num_values):
		list.__init__(self, <genexpr>(_linear(start, stop, num_values)))

	def __str__(self):
		return ' '.join(self)



class LinearFloats(list):
	__doc__ = 'LinearFloats(start, stop, num_values)\n\n    Linear sequence of num_values floats (2 decimal places),\n    ranging from start to stop inclusive.\n\n    Its string representation is space-separated.\n\n    >>> str(LinearFloats(0, 100, 3))\n    "0.00 50.00 100.00"\n    '
	def __init__(self, start, stop, num_values):
		list.__init__(self, <genexpr>(_linear(start, stop, num_values)))

	def __str__(self):
		return ' '.join(self)



class LinearPercentages(list):
	__doc__ = 'LinearPercentages(start, stop, num_values)\n\n    Linear sequence of num_values percentages,\n    ranging from start% to stop% inclusive.\n\n    Its string representation is space-separated.\n\n    >>> str(LinearPercentages(0, 100, 3))\n    "0% 50% 100%"\n    '
	def __init__(self, start, stop, num_values):
		list.__init__(self, <genexpr>(_linear(start, stop, num_values)))

	def __str__(self):
		return ' '.join(self)



class TupleSequence(list):
	__doc__ = 'A sequence of n-tuples of strings. Supports standard list\n    operations, as well as addition.\n\n    Its string representation uses space-separated groups of\n    comma-separated values.\n\n    >>> str(TupleSequence([("1", "2", "3"), ("4", "5", "6")]))\n    "1,2,3 4,5,6"\n    '
	def __add__(self, other):
		if isinstance(other, TupleSequence):
			return TupleSequence(list.__add__(self, other))
		return NotImplemented

	def __str__(self):
		return ' '.join(<genexpr>(self))



class ListCoordinates(TupleSequence):
	__doc__ = 'ListCoordinates(x_data, y_data[, z_data])\n\n    A sequence of 2D or 3D (usually x, y[, z]) coordinates,\n    used to represent a list.\n\n    It has the following use cases:\n      - Single X, single Y (not really useful, but knock yourself out):\n        >>> ListCoordinates("1", "1")\n        [("1", "1")]\n\n      - Single X, multiple Y:\n        >>> ListCoordinates("1", LinearInts(1, 3, 3))\n        [("1", "1"), ("1", "2"), ("1", "3")]\n\n      - Single Y, multiple X:\n        >>> ListCoordinates(LinearInts(1, 3, 3), 1)\n        [("1", "1"), ("2", "1"), ("3", "1")]\n\n      - Multiple X, multiple Y: This last mode requires both sequences\n        to have the same length. The result is a sequence of that same\n        length -- *not* a grid of len(x) * len(y)!\n\n        >>> ListCoordinates(LinearInts(1, 3, 3), LinearInts(0, 2, 3))\n        [("1", "0"), ("2", "1"), ("3", "2")]\n\n    The string representation returns space-separated pairs, e.g.\n    >>> str(ListCoordinates(LinearInts(1, 3, 3), LinearInts(0, 2, 3)))\n    "1,0 2,1 3,2"\n\n    Likewise, the single and multiple Z cases are properly handled.\n    >>> str(ListCoordinates(LinearPercentages(0, 100, 3), LinearPercentages(100, 200, 3), "0"))\n    "0%,100%,0 50%,150%,0 100%,200%,0"\n\n    >>> str(ListCoordinates(LinearPercentages(0, 100, 3),\n    ... LinearPercentages(100, 200, 3), LinearIntegers(-2, 0, 3)))\n    "0%,100%,-2 50%,150%,-1 100%,200%,0"\n    '
	def __init__(self, x, y, z=None):
		if isinstance(x, basestring):
			if isinstance(y, basestring):
				x_data = [x]
				y_data = [y]
			else:
				x_data = [x] * len(y)
				y_data = y
		else:
			if isinstance(y, basestring):
				x_data = x
				y_data = [y] * len(x)
			else:
				x_data = x
				y_data = y
		if len(x_data) != len(y_data):
			raise ValueError('X/Y argument mismatch -- both must have the same length')
		if z is None:
			data = zip(x_data, y_data)
		else:
			if isinstance(z, basestring):
				z_data = [z] * len(x_data)
			else:
				z_data = z
			if len(z_data) != len(x_data):
				raise ValueError('Z argument mismatch -- must have the same length as X and Y')
			data = zip(x_data, y_data, z_data)
		TupleSequence.__init__(self, data)
		return None



class GridCoordinates(TupleSequence):
	__doc__ = 'GridCoordinates(x_data, y_data)\n\n    A sequence of 2D (usually x, y) coordinates, used to represent a grid.\n\n    Unlike L{ListCoordinates}, it requires both its arguments to be\n    lists of length >= 1, and creates len(x_list) * len(y_list)\n    coordinates out of them.\n\n    Example:\n    >>> GridCoordinates(LinearPercentages(0, 100, 3),\n    ... LinearPercentages(10, 20, 2))\n    [("0%", "10%"), ("50%", "10%"), ("100%", "10%"),\n    ("0%", "20%"), ("50%", "20%"), ("100%", "20%")]\n\n    The string representation returns space-separated pairs.\n    '
	def __init__(self, x_list, y_list):
		if len(x_list) < 1:
			raise ValueError('At least 1 X position is required')
		if len(y_list) < 1:
			raise ValueError('At least 1 Y position is required')
		TupleSequence.__init__(self, <genexpr>(y_list))



MACRO_GLOBS = {'__builtins__': None, 'randint': random.randint, 'LinearInts': LinearInts, 'LinearFloats': LinearFloats, 'LinearPercentages': LinearPercentages, 'ListCoordinates': ListCoordinates, 'GridCoordinates': GridCoordinates}
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76066ac>}
from __future__ import absolute_import
from __future__ import division
import random
def py_macro(m):
	return eval('%s' % m[3:], MACRO_GLOBS, {})

def _linear(start, stop, num_values):
	if num_values <= 1:
		raise ValueError('linear() must return at least 2 values')
	# from __future__ import division
	# CAUTION! future division detected!
	step = (stop - start) / (num_values - 1)
	return <genexpr>(xrange(num_values))

class LinearInts(list):
	__doc__ = 'LinearInts(start, stop, num_values)\n\n    Linear sequence of num_values integers,\n    ranging from start to stop inclusive.\n\n    Its string representation is space-separated.\n\n    >>> str(LinearInts(0, 100, 3))\n    "0 50 100"\n    '
	def __init__(self, start, stop, num_values):
		list.__init__(self, <genexpr>(_linear(start, stop, num_values)))

	def __str__(self):
		return ' '.join(self)



class LinearFloats(list):
	__doc__ = 'LinearFloats(start, stop, num_values)\n\n    Linear sequence of num_values floats (2 decimal places),\n    ranging from start to stop inclusive.\n\n    Its string representation is space-separated.\n\n    >>> str(LinearFloats(0, 100, 3))\n    "0.00 50.00 100.00"\n    '
	def __init__(self, start, stop, num_values):
		list.__init__(self, <genexpr>(_linear(start, stop, num_values)))

	def __str__(self):
		return ' '.join(self)



class LinearPercentages(list):
	__doc__ = 'LinearPercentages(start, stop, num_values)\n\n    Linear sequence of num_values percentages,\n    ranging from start% to stop% inclusive.\n\n    Its string representation is space-separated.\n\n    >>> str(LinearPercentages(0, 100, 3))\n    "0% 50% 100%"\n    '
	def __init__(self, start, stop, num_values):
		list.__init__(self, <genexpr>(_linear(start, stop, num_values)))

	def __str__(self):
		return ' '.join(self)



class TupleSequence(list):
	__doc__ = 'A sequence of n-tuples of strings. Supports standard list\n    operations, as well as addition.\n\n    Its string representation uses space-separated groups of\n    comma-separated values.\n\n    >>> str(TupleSequence([("1", "2", "3"), ("4", "5", "6")]))\n    "1,2,3 4,5,6"\n    '
	def __add__(self, other):
		if isinstance(other, TupleSequence):
			return TupleSequence(list.__add__(self, other))
		return NotImplemented

	def __str__(self):
		return ' '.join(<genexpr>(self))



class ListCoordinates(TupleSequence):
	__doc__ = 'ListCoordinates(x_data, y_data[, z_data])\n\n    A sequence of 2D or 3D (usually x, y[, z]) coordinates,\n    used to represent a list.\n\n    It has the following use cases:\n      - Single X, single Y (not really useful, but knock yourself out):\n        >>> ListCoordinates("1", "1")\n        [("1", "1")]\n\n      - Single X, multiple Y:\n        >>> ListCoordinates("1", LinearInts(1, 3, 3))\n        [("1", "1"), ("1", "2"), ("1", "3")]\n\n      - Single Y, multiple X:\n        >>> ListCoordinates(LinearInts(1, 3, 3), 1)\n        [("1", "1"), ("2", "1"), ("3", "1")]\n\n      - Multiple X, multiple Y: This last mode requires both sequences\n        to have the same length. The result is a sequence of that same\n        length -- *not* a grid of len(x) * len(y)!\n\n        >>> ListCoordinates(LinearInts(1, 3, 3), LinearInts(0, 2, 3))\n        [("1", "0"), ("2", "1"), ("3", "2")]\n\n    The string representation returns space-separated pairs, e.g.\n    >>> str(ListCoordinates(LinearInts(1, 3, 3), LinearInts(0, 2, 3)))\n    "1,0 2,1 3,2"\n\n    Likewise, the single and multiple Z cases are properly handled.\n    >>> str(ListCoordinates(LinearPercentages(0, 100, 3), LinearPercentages(100, 200, 3), "0"))\n    "0%,100%,0 50%,150%,0 100%,200%,0"\n\n    >>> str(ListCoordinates(LinearPercentages(0, 100, 3),\n    ... LinearPercentages(100, 200, 3), LinearIntegers(-2, 0, 3)))\n    "0%,100%,-2 50%,150%,-1 100%,200%,0"\n    '
	def __init__(self, x, y, z=None):
		if isinstance(x, basestring):
			if isinstance(y, basestring):
				x_data = [x]
				y_data = [y]
			else:
				x_data = [x] * len(y)
				y_data = y
		else:
			if isinstance(y, basestring):
				x_data = x
				y_data = [y] * len(x)
			else:
				x_data = x
				y_data = y
		if len(x_data) != len(y_data):
			raise ValueError('X/Y argument mismatch -- both must have the same length')
		if z is None:
			data = zip(x_data, y_data)
		else:
			if isinstance(z, basestring):
				z_data = [z] * len(x_data)
			else:
				z_data = z
			if len(z_data) != len(x_data):
				raise ValueError('Z argument mismatch -- must have the same length as X and Y')
			data = zip(x_data, y_data, z_data)
		TupleSequence.__init__(self, data)
		return None



class GridCoordinates(TupleSequence):
	__doc__ = 'GridCoordinates(x_data, y_data)\n\n    A sequence of 2D (usually x, y) coordinates, used to represent a grid.\n\n    Unlike L{ListCoordinates}, it requires both its arguments to be\n    lists of length >= 1, and creates len(x_list) * len(y_list)\n    coordinates out of them.\n\n    Example:\n    >>> GridCoordinates(LinearPercentages(0, 100, 3),\n    ... LinearPercentages(10, 20, 2))\n    [("0%", "10%"), ("50%", "10%"), ("100%", "10%"),\n    ("0%", "20%"), ("50%", "20%"), ("100%", "20%")]\n\n    The string representation returns space-separated pairs.\n    '
	def __init__(self, x_list, y_list):
		if len(x_list) < 1:
			raise ValueError('At least 1 X position is required')
		if len(y_list) < 1:
			raise ValueError('At least 1 Y position is required')
		TupleSequence.__init__(self, <genexpr>(y_list))



MACRO_GLOBS = {'__builtins__': None, 'randint': random.randint, 'LinearInts': LinearInts, 'LinearFloats': LinearFloats, 'LinearPercentages': LinearPercentages, 'ListCoordinates': ListCoordinates, 'GridCoordinates': GridCoordinates}
