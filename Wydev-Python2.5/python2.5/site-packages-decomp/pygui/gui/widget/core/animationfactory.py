# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 21
n 21(None)[log.error('Invalid value %s : not in %s', value, args)
return args[0]
]:
	i: 12(), 20()
	o: 

nname: 20
n 20(None)[]:
	i: 0(f)
	o: 21()

nname: 12
n 12(None)[return value
]:
	i: 0(t)
	o: 21()

nname: 0
n 0(value in values_set)[]:
	i: 
	o: 12(t), 20(f)

nname: 0
n 0(None)[if value in values_set:
	return value
log.error('Invalid value %s : not in %s', value, args)
return args[0]
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75e1d0c>}
nname: 0
n 0(None)[values_set = set(args)
def _aux(value):
	if value in values_set:
		return value
	log.error('Invalid value %s : not in %s', value, args)
	return args[0]

return _aux
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75e14cc>}
nname: 0
n 0(None)[return cast(eval('%s' % m[3:], MACRO_GLOBS))
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75e19ec>}
nname: 0
n 0(None)[return (lambda : cast(eval('%s' % m[3:], MACRO_GLOBS)))
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75e148c>}
nname: 80
n 80(None)[return dict
]:
	i: 0(AL), 79()
	o: 

nname: 79
n 79(None)[]:
	i: 3(AF), 75()
	o: 80()

nname: 75
n 75(None)[]:
	i: 16(f), 55()
	o: 79()

nname: 55
n 55(None)[dict[key] = castor(val)
continue
]:
	i: 16(t)
	o: 75()

nname: 16
n 16(castor is not None)[for key, val in dict.iteritems():
castor = _att_cast_list.get(key, None)
]:
	i: 3(for)
	o: 55(t), 75(f)

nname: 3
n 3(None)[]:
	i: 0(loop)
	o: 16(for), 79(AF)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 80(AL)

nname: 80
n 80(None)[return dict
]:
	i: 0(AL), 3(AF), 16()
	o: 

nname: 16
n 16(None)[for key, val in dict.iteritems():
castor = _att_cast_list.get(key, None)
if castor is not None:
	dict[key] = castor(val)
	continue
]:
	i: 3(for)
	o: 80()

nname: 3
n 3(None)[]:
	i: 0(loop)
	o: 16(for), 80(AF)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 80(AL)

nname: 16
n 16(None)[for key, val in dict.iteritems():
	castor = _att_cast_list.get(key, None)
	if castor is not None:
		dict[key] = castor(val)
		continue
return dict
]:
	i: 0(for)
	o: 

nname: 0
n 0(None)[]:
	i: 
	o: 16(for)

nname: 0
n 0(None)[for key, val in dict.iteritems():
	castor = _att_cast_list.get(key, None)
	if castor is not None:
		dict[key] = castor(val)
		continue
return dict
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75e2b6c>}
nname: 105
n 105(None)[return None
]:
	i: 0(AL), 104()
	o: 

nname: 104
n 104(None)[]:
	i: 69(AF), 76()
	o: 105()

nname: 76
n 76(None)[for subnode in node:
self._callbacks.append(Anim(subnode))
]:
	i: 69(for)
	o: 104()

nname: 69
n 69(None)[]:
	i: 0(loop)
	o: 76(for), 104(AF)

nname: 0
n 0(None)[self.object = None
kwargs = node.attrib
self.type = node.tag
self._callbacks = []
self._stopped = False
self._kwargs = self._cast_att(kwargs)
]:
	i: 
	o: 69(loop), 105(AL)

nname: 105
n 105(None)[return None
]:
	i: 76()
	o: 

nname: 76
n 76(None)[for subnode in node:
	self._callbacks.append(Anim(subnode))
]:
	i: 0(for)
	o: 105()

nname: 0
n 0(None)[self.object = None
kwargs = node.attrib
self.type = node.tag
self._callbacks = []
self._stopped = False
self._kwargs = self._cast_att(kwargs)
]:
	i: 
	o: 76(for)

nname: 105
n 105(None)[return None
]:
	i: 0()
	o: 

nname: 0
n 0(None)[self.object = None
kwargs = node.attrib
self.type = node.tag
self._callbacks = []
self._stopped = False
self._kwargs = self._cast_att(kwargs)
for subnode in node:
	self._callbacks.append(Anim(subnode))
]:
	i: 
	o: 105()

nname: 0
n 0(None)[self.object = None
kwargs = node.attrib
self.type = node.tag
self._callbacks = []
self._stopped = False
self._kwargs = self._cast_att(kwargs)
for subnode in node:
	self._callbacks.append(Anim(subnode))
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75e250c>}
nname: 0
n 0(None)[return '<%s:%s::%s(%s)>' % (self.__class__.__name__, self.object, self.type, self._kwargs)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75e232c>}
nname: 48
n 48(None)[log.debug('ANIM %s %d : %s --> %s', object.name, id(object), self.type, self._kwargs)
getattr(object, 'animate')(self.type, **self._kwargs)
]:
	i: 27(), 47()
	o: 

nname: 47
n 47(None)[]:
	i: 0(f)
	o: 48()

nname: 27
n 27(None)[self._kwargs['end_callback'] = self.end_callback
]:
	i: 0(t)
	o: 48()

nname: 0
n 0(self._callbacks)[self._stopped = False
self.object = object
]:
	i: 
	o: 27(t), 47(f)

nname: 0
n 0(None)[self._stopped = False
self.object = object
if self._callbacks:
	self._kwargs['end_callback'] = self.end_callback
log.debug('ANIM %s %d : %s --> %s', object.name, id(object), self.type, self._kwargs)
getattr(object, 'animate')(self.type, **self._kwargs)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75e27ec>}
nname: 63
n 63(None)[]:
	i: 22(AL), 58(), 62()
	o: 

nname: 62
n 62(None)[]:
	i: 0(t)
	o: 63()

nname: 58
n 58(None)[]:
	i: 26(AF), 36()
	o: 63()

nname: 36
n 36(None)[for anim in self._callbacks:
anim.play(self.object)
]:
	i: 26(for)
	o: 58()

nname: 26
n 26(None)[]:
	i: 22(loop)
	o: 36(for), 58(AF)

nname: 22
n 22(None)[]:
	i: 0(f)
	o: 26(loop), 63(AL)

nname: 0
n 0(self._stopped)[log.info('running end callback (should be thread-safe, I hope :P)')
]:
	i: 
	o: 22(f), 62(t)

nname: 63
n 63(None)[]:
	i: 36(), 0(t)
	o: 

nname: 36
n 36(None)[for anim in self._callbacks:
	anim.play(self.object)
]:
	i: 22(for)
	o: 63()

nname: 22
n 22(None)[]:
	i: 0(f)
	o: 36(for)

nname: 0
n 0(self._stopped)[log.info('running end callback (should be thread-safe, I hope :P)')
]:
	i: 
	o: 22(f), 63(t)

nname: 63
n 63(None)[]:
	i: 22(), 0(t)
	o: 

nname: 22
n 22(None)[for anim in self._callbacks:
	anim.play(self.object)
]:
	i: 0(f)
	o: 63()

nname: 0
n 0(self._stopped)[log.info('running end callback (should be thread-safe, I hope :P)')
]:
	i: 
	o: 22(f), 63(t)

nname: 0
n 0(None)[log.info('running end callback (should be thread-safe, I hope :P)')
if not self._stopped:
	for anim in self._callbacks:
		anim.play(self.object)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75e22cc>}
nname: 0
n 0(None)[self._stopped = True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75e1dcc>}
nname: 6
n 6(None)[__doc__ = '\n    class used to stock informations about a certain animation.\n    '
def _cast_att(self, dict):
	for key, val in dict.iteritems():
		castor = _att_cast_list.get(key, None)
		if castor is not None:
			dict[key] = castor(val)
			continue
	return dict

def __init__(self, node):
	self.object = None
	kwargs = node.attrib
	self.type = node.tag
	self._callbacks = []
	self._stopped = False
	self._kwargs = self._cast_att(kwargs)
	for subnode in node:
		self._callbacks.append(Anim(subnode))
	return None

def __repr__(self):
	return '<%s:%s::%s(%s)>' % (self.__class__.__name__, self.object, self.type, self._kwargs)

def play(self, object=None):
	self._stopped = False
	self.object = object
	if self._callbacks:
		self._kwargs['end_callback'] = self.end_callback
	log.debug('ANIM %s %d : %s --> %s', object.name, id(object), self.type, self._kwargs)
	getattr(object, 'animate')(self.type, **self._kwargs)

def end_callback(self):
	log.info('running end callback (should be thread-safe, I hope :P)')
	if not self._stopped:
		for anim in self._callbacks:
			anim.play(self.object)

def stop(self):
	self._stopped = True

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75e1c2c>}
nname: 456
n 456(None)[self._properties = dict(maxi=maximums, mini=minimums, duration=duration, value=value, step_type=step_type)
return None
]:
	i: 0(AL), 455()
	o: 

nname: 455
n 455(None)[]:
	i: 78(AF), 452()
	o: 456()

nname: 452
n 452(None)[]:
	i: 150(JA), 259(JA), 355(JA), 451()
	o: 455()

nname: 451
n 451(None)[]:
	i: 422(f), 435()
	o: 452()

nname: 435
n 435(None)[step_type = _step_type_cast(v)
continue
]:
	i: 422(t)
	o: 451()

nname: 422
n 422(k == 'step_type')[]:
	i: 399(f), 412()
	o: 435(t), 451(f)

nname: 412
n 412(None)[value = v
continue
]:
	i: 399(t)
	o: 422()

nname: 399
n 399(k == 'type')[]:
	i: 320(f), 383()
	o: 412(t), 422(f)

nname: 383
n 383(None)[duration = float(v)
continue
]:
	i: 333(f)
	o: 399()

nname: 355
n 355(None)[duration = _py_macro_call(v, _att_cast_list.get(k))
]:
	i: 333(t)
	o: 452(JA)

nname: 333
n 333(str(v).startswith('py:'))[]:
	i: 320(t)
	o: 355(t), 383(f)

nname: 320
n 320(k == 'duration')[]:
	i: 211(f), 291()
	o: 333(t), 399(f)

nname: 291
n 291(None)[maximums[name] = _att_cast_list.get(name)(v)
continue
]:
	i: 227(f)
	o: 320()

nname: 259
n 259(None)[maximums[name] = _py_macro_call(v, _att_cast_list.get(name))
]:
	i: 227(t)
	o: 452(JA)

nname: 227
n 227(str(v).startswith('py:'))[name = k[:-4]
]:
	i: 211(t)
	o: 259(t), 291(f)

nname: 211
n 211(k.endswith('_max'))[]:
	i: 94(f), 182()
	o: 227(t), 320(f)

nname: 182
n 182(None)[minimums[name] = _att_cast_list.get(name)(v)
continue
]:
	i: 118(f)
	o: 211()

nname: 150
n 150(None)[minimums[name] = _py_macro_call(v, _att_cast_list.get(name))
]:
	i: 118(t)
	o: 452(JA)

nname: 118
n 118(str(v).startswith('py:'))[name = k[:-4]
]:
	i: 94(t)
	o: 150(t), 182(f)

nname: 94
n 94(k.endswith('_min'))[for k, v in node.attrib.iteritems():
]:
	i: 78(for)
	o: 118(t), 211(f)

nname: 78
n 78(None)[]:
	i: 0(loop)
	o: 94(for), 455(AF)

nname: 0
n 0(None)[self.type = node.tag
self.object = None
self._task = None
self._in_pause = False
maximums = dict()
minimums = dict()
duration = 1
value = 'opacity'
step_type = 'linear'
]:
	i: 
	o: 78(loop), 456(AL)

nname: 456
n 456(None)[self._properties = dict(maxi=maximums, mini=minimums, duration=duration, value=value, step_type=step_type)
return None
]:
	i: 0(AL), 78(AF), 150(JA), 259(JA), 355(JA), 399(f)
	o: 

nname: 399
n 399(None)[if k == 'type':
	value = v
	continue
if k == 'step_type':
	step_type = _step_type_cast(v)
	continue
]:
	i: 320(f), 383()
	o: 456()

nname: 383
n 383(None)[duration = float(v)
continue
]:
	i: 333(f)
	o: 399()

nname: 355
n 355(None)[duration = _py_macro_call(v, _att_cast_list.get(k))
]:
	i: 333(t)
	o: 456(JA)

nname: 333
n 333(str(v).startswith('py:'))[]:
	i: 320(t)
	o: 355(t), 383(f)

nname: 320
n 320(k == 'duration')[]:
	i: 211(f), 291()
	o: 333(t), 399(f)

nname: 291
n 291(None)[maximums[name] = _att_cast_list.get(name)(v)
continue
]:
	i: 227(f)
	o: 320()

nname: 259
n 259(None)[maximums[name] = _py_macro_call(v, _att_cast_list.get(name))
]:
	i: 227(t)
	o: 456(JA)

nname: 227
n 227(str(v).startswith('py:'))[name = k[:-4]
]:
	i: 211(t)
	o: 259(t), 291(f)

nname: 211
n 211(k.endswith('_max'))[]:
	i: 94(f), 182()
	o: 227(t), 320(f)

nname: 182
n 182(None)[minimums[name] = _att_cast_list.get(name)(v)
continue
]:
	i: 118(f)
	o: 211()

nname: 150
n 150(None)[minimums[name] = _py_macro_call(v, _att_cast_list.get(name))
]:
	i: 118(t)
	o: 456(JA)

nname: 118
n 118(str(v).startswith('py:'))[name = k[:-4]
]:
	i: 94(t)
	o: 150(t), 182(f)

nname: 94
n 94(k.endswith('_min'))[for k, v in node.attrib.iteritems():
]:
	i: 78(for)
	o: 118(t), 211(f)

nname: 78
n 78(None)[]:
	i: 0(loop)
	o: 94(for), 456(AF)

nname: 0
n 0(None)[self.type = node.tag
self.object = None
self._task = None
self._in_pause = False
maximums = dict()
minimums = dict()
duration = 1
value = 'opacity'
step_type = 'linear'
]:
	i: 
	o: 78(loop), 456(AL)

self.nodes: {0: <unpyclib.structure.node instance at 0xb75e49ac>, 259: <unpyclib.structure.node instance at 0xb75e4c4c>, 399: <unpyclib.structure.node instance at 0xb75f698c>, 150: <unpyclib.structure.node instance at 0xb75e4aac>, 291: <unpyclib.structure.node instance at 0xb75e4ccc>, 182: <unpyclib.structure.node instance at 0xb75e4aec>, 320: <unpyclib.structure.node instance at 0xb75e4d4c>, 456: <unpyclib.structure.node instance at 0xb75f658c>, 333: <unpyclib.structure.node instance at 0xb75e4dcc>, 78: <unpyclib.structure.node instance at 0xb75e49ec>, 355: <unpyclib.structure.node instance at 0xb75e4e4c>, 94: <unpyclib.structure.node instance at 0xb75e4a2c>, 227: <unpyclib.structure.node instance at 0xb75e4bcc>, 211: <unpyclib.structure.node instance at 0xb75e4b4c>, 118: <unpyclib.structure.node instance at 0xb75e4a6c>, 383: <unpyclib.structure.node instance at 0xb75e4ecc>}
nname: 0
n 0(None)[return '<%s:%s::%s(%s)>' % (self.__class__.__name__, self.object, self.type, self._properties)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75e216c>}
nname: 162
n 162(None)[log.debug('PERPETANIM %s %d : %s --> maxi:%s value:%s duration:%s step_type:%s', object.name, id(object), self.type, p['maxi'], p['value'], duration, p['step_type'])
object.animate(p['value'], duration=duration, loop_type='boom', end_callback=self.set_min, step_type=p['step_type'], **p['maxi'])
]:
	i: 153(), 161()
	o: 

nname: 161
n 161(None)[]:
	i: 60(f)
	o: 162()

nname: 153
n 153(None)[]:
	i: 60(t)
	o: 162()

nname: 60
n 60('noglow' in plugins)[duration = float(d)
log.debug('PERPETANIM %s %d : %s --> mini:%s value:%s duration:0', object.name, id(object), self.type, p['mini'], p['value'])
object.animate(p['value'], duration=0, **p['mini'])
]:
	i: 40(), 50()
	o: 153(t), 161(f)

nname: 50
n 50(None)[]:
	i: 0(f)
	o: 60()

nname: 40
n 40(None)[]:
	i: 0(t)
	o: 60()

nname: 0
n 0(callable(d))[self.object = object
p = self._properties
d = p['duration']
]:
	i: 
	o: 40(t), 50(f)

nname: 162
n 162(None)[log.debug('PERPETANIM %s %d : %s --> maxi:%s value:%s duration:%s step_type:%s', object.name, id(object), self.type, p['maxi'], p['value'], duration, p['step_type'])
object.animate(p['value'], duration=duration, loop_type='boom', end_callback=self.set_min, step_type=p['step_type'], **p['maxi'])
]:
	i: 0()
	o: 

nname: 0
n 0(None)[self.object = object
p = self._properties
d = p['duration']
if callable(d):
	pass
duration = float(d)
log.debug('PERPETANIM %s %d : %s --> mini:%s value:%s duration:0', object.name, id(object), self.type, p['mini'], p['value'])
object.animate(p['value'], duration=0, **p['mini'])
if 'noglow' in plugins:
	pass
]:
	i: 
	o: 162()

nname: 0
n 0(None)[self.object = object
p = self._properties
d = p['duration']
if callable(d):
	pass
duration = float(d)
log.debug('PERPETANIM %s %d : %s --> mini:%s value:%s duration:0', object.name, id(object), self.type, p['mini'], p['value'])
object.animate(p['value'], duration=0, **p['mini'])
if 'noglow' in plugins:
	pass
log.debug('PERPETANIM %s %d : %s --> maxi:%s value:%s duration:%s step_type:%s', object.name, id(object), self.type, p['maxi'], p['value'], duration, p['step_type'])
object.animate(p['value'], duration=duration, loop_type='boom', end_callback=self.set_min, step_type=p['step_type'], **p['maxi'])
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75e2d2c>}
nname: 0
n 0(None)[self.object.animate(p['value'], duration=0, **self._properties['mini'])
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75e212c>}
nname: 0
n 0(None)[self.object.animate_stop(self._properties['value'])
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75e1b6c>}
nname: 0
n 0(None)[self.object.animate_stop(self._properties['value'])
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75e1bec>}
nname: 0
n 0(None)[p = self._properties
self.object.animate(p['value'], duration=p['duration'], loop_type='boom', step_type=p['step_type'], end_callback=self.set_min, **p['maxi'])
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75e280c>}
nname: 6
n 6(None)[def __init__(self, node):
	self.type = node.tag
	self.object = None
	self._task = None
	self._in_pause = False
	maximums = dict()
	minimums = dict()
	duration = 1
	value = 'opacity'
	step_type = 'linear'

def __repr__(self):
	return '<%s:%s::%s(%s)>' % (self.__class__.__name__, self.object, self.type, self._properties)

def play(self, object=None):
	self.object = object
	p = self._properties
	d = p['duration']
	if callable(d):
		pass
	duration = float(d)
	log.debug('PERPETANIM %s %d : %s --> mini:%s value:%s duration:0', object.name, id(object), self.type, p['mini'], p['value'])
	object.animate(p['value'], duration=0, **p['mini'])
	if 'noglow' in plugins:
		pass
	log.debug('PERPETANIM %s %d : %s --> maxi:%s value:%s duration:%s step_type:%s', object.name, id(object), self.type, p['maxi'], p['value'], duration, p['step_type'])
	object.animate(p['value'], duration=duration, loop_type='boom', end_callback=self.set_min, step_type=p['step_type'], **p['maxi'])

def set_min(self):
	self.object.animate(p['value'], duration=0, **self._properties['mini'])

def stop(self):
	self.object.animate_stop(self._properties['value'])

def pause(self):
	self.object.animate_stop(self._properties['value'])

def unpause(self):
	p = self._properties
	self.object.animate(p['value'], duration=p['duration'], loop_type='boom', step_type=p['step_type'], end_callback=self.set_min, **p['maxi'])

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75e1bac>}
nname: 0
n 0(None)[self._animations = []
self.event = node.get('event')
self.name = node.get('id')
self.add_animations(node)
self.obj = obj
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75e238c>}
nname: 0
n 0(None)[return '%s({"event": %s, "name": %s}, %s)' % (self.__class__.__name__, self.event, self.name, self._animations)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75e1cac>}
nname: 101
n 101(None)[]:
	i: 0(AL), 100()
	o: 

nname: 100
n 100(None)[]:
	i: 3(AF), 96()
	o: 101()

nname: 96
n 96(None)[]:
	i: 54(f), 70()
	o: 100()

nname: 70
n 70(None)[self._animations.append(PerpetualAnim(anim_node))
continue
]:
	i: 54(t)
	o: 96()

nname: 54
n 54(anim_node.tag == 'glow')[]:
	i: 10(f), 28()
	o: 70(t), 96(f)

nname: 28
n 28(None)[self._animations.append(Anim(anim_node))
continue
]:
	i: 10(t)
	o: 54()

nname: 10
n 10(anim_node.tag in _animation_list)[for anim_node in node:
]:
	i: 3(for)
	o: 28(t), 54(f)

nname: 3
n 3(None)[]:
	i: 0(loop)
	o: 10(for), 100(AF)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 101(AL)

nname: 101
n 101(None)[]:
	i: 0(AL), 3(AF), 10(f)
	o: 

nname: 10
n 10(None)[for anim_node in node:
if anim_node.tag in _animation_list:
	self._animations.append(Anim(anim_node))
	continue
if anim_node.tag == 'glow':
	self._animations.append(PerpetualAnim(anim_node))
	continue
]:
	i: 3(for)
	o: 101()

nname: 3
n 3(None)[]:
	i: 0(loop)
	o: 10(for), 101(AF)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 101(AL)

nname: 10
n 10(None)[for anim_node in node:
	if anim_node.tag in _animation_list:
		self._animations.append(Anim(anim_node))
		continue
	if anim_node.tag == 'glow':
		self._animations.append(PerpetualAnim(anim_node))
		continue
]:
	i: 0(for)
	o: 

nname: 0
n 0(None)[]:
	i: 
	o: 10(for)

nname: 0
n 0(None)[for anim_node in node:
	if anim_node.tag in _animation_list:
		self._animations.append(Anim(anim_node))
		continue
	if anim_node.tag == 'glow':
		self._animations.append(PerpetualAnim(anim_node))
		continue
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75e266c>}
nname: 55
n 55(None)[]:
	i: 0(AL), 54()
	o: 

nname: 54
n 54(None)[]:
	i: 22(AF), 32()
	o: 55()

nname: 32
n 32(None)[for anim in self._animations:
anim.play(self.obj)
]:
	i: 22(for)
	o: 54()

nname: 22
n 22(None)[]:
	i: 0(loop)
	o: 32(for), 54(AF)

nname: 0
n 0(None)[log.info('play %s %s', args, kw)
]:
	i: 
	o: 22(loop), 55(AL)

nname: 55
n 55(None)[]:
	i: 32()
	o: 

nname: 32
n 32(None)[for anim in self._animations:
	anim.play(self.obj)
]:
	i: 0(for)
	o: 55()

nname: 0
n 0(None)[log.info('play %s %s', args, kw)
]:
	i: 
	o: 32(for)

nname: 55
n 55(None)[]:
	i: 0()
	o: 

nname: 0
n 0(None)[log.info('play %s %s', args, kw)
for anim in self._animations:
	anim.play(self.obj)
]:
	i: 
	o: 55()

nname: 0
n 0(None)[log.info('play %s %s', args, kw)
for anim in self._animations:
	anim.play(self.obj)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75e2ecc>}
nname: 30
n 30(None)[]:
	i: 0(AL), 29()
	o: 

nname: 29
n 29(None)[]:
	i: 3(AF), 13()
	o: 30()

nname: 13
n 13(None)[for anim in self._animations:
anim.stop()
]:
	i: 3(for)
	o: 29()

nname: 3
n 3(None)[]:
	i: 0(loop)
	o: 13(for), 29(AF)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 30(AL)

nname: 30
n 30(None)[]:
	i: 13()
	o: 

nname: 13
n 13(None)[for anim in self._animations:
	anim.stop()
]:
	i: 0(for)
	o: 30()

nname: 0
n 0(None)[]:
	i: 
	o: 13(for)

nname: 30
n 30(None)[]:
	i: 0()
	o: 

nname: 0
n 0(None)[for anim in self._animations:
	anim.stop()
]:
	i: 
	o: 30()

nname: 0
n 0(None)[for anim in self._animations:
	anim.stop()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75e1dcc>}
nname: 65
n 65(None)[]:
	i: 0(AL), 64()
	o: 

nname: 64
n 64(None)[]:
	i: 3(AF), 61()
	o: 65()

nname: 61
n 61(None)[]:
	i: 59(AE)
	o: 64()

nname: 59
n 59(None)[]:
	i: 42(f), 52()
	o: 61(AE)

nname: 52
n 52(None)[continue
]:
	i: 42(t)
	o: 59()

nname: 42
n 42(<dummy_ex3> EXC_MATCH AttributeError)[]:
	i: 13(except), 28()
	o: 52(t), 59(f)

nname: 28
n 28(None)[anim.pause()
continue
]:
	i: 13(try)
	o: 42()

nname: 13
n 13(None)[for anim in self._animations:
anim._in_pause = True
]:
	i: 3(for)
	o: 28(try), 42(except)

nname: 3
n 3(None)[]:
	i: 0(loop)
	o: 13(for), 64(AF)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 65(AL)

nname: 65
n 65(None)[]:
	i: 0(AL), 3(AF), 42(AE)
	o: 

nname: 42
n 42(None)[except AttributeError:
	continue
]:
	i: 13()
	o: 65(AE)

nname: 13
n 13(None)[for anim in self._animations:
anim._in_pause = True
try:
	anim.pause()
	continue
]:
	i: 3(for)
	o: 42()

nname: 3
n 3(None)[]:
	i: 0(loop)
	o: 13(for), 65(AF)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 65(AL)

nname: 65
n 65(None)[]:
	i: 0(AL), 3(AF), 13(AE)
	o: 

nname: 13
n 13(None)[for anim in self._animations:
anim._in_pause = True
try:
	anim.pause()
	continue
except AttributeError:
	continue
]:
	i: 3(for)
	o: 65(AE)

nname: 3
n 3(None)[]:
	i: 0(loop)
	o: 13(for), 65(AF)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 65(AL)

nname: 65
n 65(None)[]:
	i: 13(AE)
	o: 

nname: 13
n 13(None)[for anim in self._animations:
	anim._in_pause = True
	try:
		anim.pause()
		continue
	except AttributeError:
		continue
]:
	i: 0(for)
	o: 65(AE)

nname: 0
n 0(None)[]:
	i: 
	o: 13(for)

nname: 65
n 65(None)[]:
	i: 0(AE)
	o: 

nname: 0
n 0(None)[for anim in self._animations:
	anim._in_pause = True
	try:
		anim.pause()
		continue
	except AttributeError:
		continue
]:
	i: 
	o: 65(AE)

self.nodes: {0: <unpyclib.structure.node instance at 0xb75e29ec>, 65: <unpyclib.structure.node instance at 0xb75e2a4c>}
nname: 65
n 65(None)[]:
	i: 0(AL), 64()
	o: 

nname: 64
n 64(None)[]:
	i: 3(AF), 61()
	o: 65()

nname: 61
n 61(None)[]:
	i: 59(AE)
	o: 64()

nname: 59
n 59(None)[]:
	i: 42(f), 52()
	o: 61(AE)

nname: 52
n 52(None)[continue
]:
	i: 42(t)
	o: 59()

nname: 42
n 42(<dummy_ex3> EXC_MATCH AttributeError)[]:
	i: 13(except), 28()
	o: 52(t), 59(f)

nname: 28
n 28(None)[anim.unpause()
continue
]:
	i: 13(try)
	o: 42()

nname: 13
n 13(None)[for anim in self._animations:
anim._in_pause = False
]:
	i: 3(for)
	o: 28(try), 42(except)

nname: 3
n 3(None)[]:
	i: 0(loop)
	o: 13(for), 64(AF)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 65(AL)

nname: 65
n 65(None)[]:
	i: 0(AL), 3(AF), 42(AE)
	o: 

nname: 42
n 42(None)[except AttributeError:
	continue
]:
	i: 13()
	o: 65(AE)

nname: 13
n 13(None)[for anim in self._animations:
anim._in_pause = False
try:
	anim.unpause()
	continue
]:
	i: 3(for)
	o: 42()

nname: 3
n 3(None)[]:
	i: 0(loop)
	o: 13(for), 65(AF)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 65(AL)

nname: 65
n 65(None)[]:
	i: 0(AL), 3(AF), 13(AE)
	o: 

nname: 13
n 13(None)[for anim in self._animations:
anim._in_pause = False
try:
	anim.unpause()
	continue
except AttributeError:
	continue
]:
	i: 3(for)
	o: 65(AE)

nname: 3
n 3(None)[]:
	i: 0(loop)
	o: 13(for), 65(AF)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 65(AL)

nname: 65
n 65(None)[]:
	i: 13(AE)
	o: 

nname: 13
n 13(None)[for anim in self._animations:
	anim._in_pause = False
	try:
		anim.unpause()
		continue
	except AttributeError:
		continue
]:
	i: 0(for)
	o: 65(AE)

nname: 0
n 0(None)[]:
	i: 
	o: 13(for)

nname: 65
n 65(None)[]:
	i: 0(AE)
	o: 

nname: 0
n 0(None)[for anim in self._animations:
	anim._in_pause = False
	try:
		anim.unpause()
		continue
	except AttributeError:
		continue
]:
	i: 
	o: 65(AE)

self.nodes: {0: <unpyclib.structure.node instance at 0xb75e2cec>, 65: <unpyclib.structure.node instance at 0xb75e2a8c>}
nname: 6
n 6(None)[__doc__ = "\n    This class is a sort of contanier for multiple animations.\n    It's used when more than one animation are being played\n    on the same object at the same time (event).\n    "
def __init__(self, node, obj=None):
	self._animations = []
	self.event = node.get('event')
	self.name = node.get('id')
	self.add_animations(node)
	self.obj = obj

def __repr__(self):
	return '%s({"event": %s, "name": %s}, %s)' % (self.__class__.__name__, self.event, self.name, self._animations)

def add_animations(self, node):
	for anim_node in node:
		if anim_node.tag in _animation_list:
			self._animations.append(Anim(anim_node))
			continue
		if anim_node.tag == 'glow':
			self._animations.append(PerpetualAnim(anim_node))
			continue

def play(self, *args, **args):
	log.info('play %s %s', args, kw)
	for anim in self._animations:
		anim.play(self.obj)

def stop(self):
	for anim in self._animations:
		anim.stop()

def pause(self):
	for anim in self._animations:
		anim._in_pause = True
		try:
			anim.pause()
			continue
		except AttributeError:
			continue

def unpause(self):
	for anim in self._animations:
		anim._in_pause = False
		try:
			anim.unpause()
			continue
		except AttributeError:
			continue

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75e174c>}
nname: 21
n 21(None)[]:
	i: 12(), 20()
	o: 

nname: 20
n 20(None)[]:
	i: 0(f)
	o: 21()

nname: 12
n 12(None)[return _animation_list
]:
	i: 0(t)
	o: 21()

nname: 0
n 0(att == 'list')[]:
	i: 
	o: 12(t), 20(f)

nname: 0
n 0(None)[if att == 'list':
	return _animation_list
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75e188c>}
nname: 0
n 0(None)[return Animation(node, obj)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75e1c6c>}
nname: 6
n 6(None)[def __getitem__(self, att):
	if att == 'list':
		return _animation_list

def create(self, node, obj):
	return Animation(node, obj)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75e138c>}
nname: 0
n 0(None)[from __future__ import absolute_import
from pygui.config import plugins
from .macros import MACRO_GLOBS
from peewee.debug import GET_LOGGER
from peewee.formatters import string_or_float
log = GET_LOGGER(__name__)
def in_set(*args):
	values_set = set(args)
	def _aux(value):
		if value in values_set:
			return value
		log.error('Invalid value %s : not in %s', value, args)
		return args[0]

	return _aux

_step_type_cast = in_set('linear', 'log', 'exp', 'samples', 'easein', 'easeout', 'easeinout', 'bounce')
_animation_list = ['size', 'opacity', 'move', 'color']
_att_cast_list = {'name': None, 'opacity': float, 'opacity_min': float, 'opacity_max': float, 'width': string_or_float, 'height': string_or_float, 'left': string_or_float, 'right': string_or_float, 'top': string_or_float, 'bottom': string_or_float, 'hcenter': string_or_float, 'vcenter': string_or_float, 'a': int, 'r': int, 'g': int, 'b': int, 'starting_offset': float, 'duration': float, 'step_type': _step_type_cast}
def _py_macro_call(m, cast):
	return (lambda : cast(eval('%s' % m[3:], MACRO_GLOBS)))

class Anim(object):
	__doc__ = '\n    class used to stock informations about a certain animation.\n    '
	def _cast_att(self, dict):
		for key, val in dict.iteritems():
			castor = _att_cast_list.get(key, None)
			if castor is not None:
				dict[key] = castor(val)
				continue
		return dict

	def __init__(self, node):
		self.object = None
		kwargs = node.attrib
		self.type = node.tag
		self._callbacks = []
		self._stopped = False
		self._kwargs = self._cast_att(kwargs)
		for subnode in node:
			self._callbacks.append(Anim(subnode))
		return None

	def __repr__(self):
		return '<%s:%s::%s(%s)>' % (self.__class__.__name__, self.object, self.type, self._kwargs)

	def play(self, object=None):
		self._stopped = False
		self.object = object
		if self._callbacks:
			self._kwargs['end_callback'] = self.end_callback
		log.debug('ANIM %s %d : %s --> %s', object.name, id(object), self.type, self._kwargs)
		getattr(object, 'animate')(self.type, **self._kwargs)

	def end_callback(self):
		log.info('running end callback (should be thread-safe, I hope :P)')
		if not self._stopped:
			for anim in self._callbacks:
				anim.play(self.object)

	def stop(self):
		self._stopped = True



class PerpetualAnim(Anim):
	def __init__(self, node):
		self.type = node.tag
		self.object = None
		self._task = None
		self._in_pause = False
		maximums = dict()
		minimums = dict()
		duration = 1
		value = 'opacity'
		step_type = 'linear'

	def __repr__(self):
		return '<%s:%s::%s(%s)>' % (self.__class__.__name__, self.object, self.type, self._properties)

	def play(self, object=None):
		self.object = object
		p = self._properties
		d = p['duration']
		if callable(d):
			pass
		duration = float(d)
		log.debug('PERPETANIM %s %d : %s --> mini:%s value:%s duration:0', object.name, id(object), self.type, p['mini'], p['value'])
		object.animate(p['value'], duration=0, **p['mini'])
		if 'noglow' in plugins:
			pass
		log.debug('PERPETANIM %s %d : %s --> maxi:%s value:%s duration:%s step_type:%s', object.name, id(object), self.type, p['maxi'], p['value'], duration, p['step_type'])
		object.animate(p['value'], duration=duration, loop_type='boom', end_callback=self.set_min, step_type=p['step_type'], **p['maxi'])

	def set_min(self):
		self.object.animate(p['value'], duration=0, **self._properties['mini'])

	def stop(self):
		self.object.animate_stop(self._properties['value'])

	def pause(self):
		self.object.animate_stop(self._properties['value'])

	def unpause(self):
		p = self._properties
		self.object.animate(p['value'], duration=p['duration'], loop_type='boom', step_type=p['step_type'], end_callback=self.set_min, **p['maxi'])



class Animation(object):
	__doc__ = "\n    This class is a sort of contanier for multiple animations.\n    It's used when more than one animation are being played\n    on the same object at the same time (event).\n    "
	def __init__(self, node, obj=None):
		self._animations = []
		self.event = node.get('event')
		self.name = node.get('id')
		self.add_animations(node)
		self.obj = obj

	def __repr__(self):
		return '%s({"event": %s, "name": %s}, %s)' % (self.__class__.__name__, self.event, self.name, self._animations)

	def add_animations(self, node):
		for anim_node in node:
			if anim_node.tag in _animation_list:
				self._animations.append(Anim(anim_node))
				continue
			if anim_node.tag == 'glow':
				self._animations.append(PerpetualAnim(anim_node))
				continue

	def play(self, *args, **args):
		log.info('play %s %s', args, kw)
		for anim in self._animations:
			anim.play(self.obj)

	def stop(self):
		for anim in self._animations:
			anim.stop()

	def pause(self):
		for anim in self._animations:
			anim._in_pause = True
			try:
				anim.pause()
				continue
			except AttributeError:
				continue

	def unpause(self):
		for anim in self._animations:
			anim._in_pause = False
			try:
				anim.unpause()
				continue
			except AttributeError:
				continue



class AnimationCreator(object):
	def __getitem__(self, att):
		if att == 'list':
			return _animation_list

	def create(self, node, obj):
		return Animation(node, obj)



]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75cd7ec>}
from __future__ import absolute_import
from pygui.config import plugins
from .macros import MACRO_GLOBS
from peewee.debug import GET_LOGGER
from peewee.formatters import string_or_float
log = GET_LOGGER(__name__)
def in_set(*args):
	values_set = set(args)
	def _aux(value):
		if value in values_set:
			return value
		log.error('Invalid value %s : not in %s', value, args)
		return args[0]

	return _aux

_step_type_cast = in_set('linear', 'log', 'exp', 'samples', 'easein', 'easeout', 'easeinout', 'bounce')
_animation_list = ['size', 'opacity', 'move', 'color']
_att_cast_list = {'name': None, 'opacity': float, 'opacity_min': float, 'opacity_max': float, 'width': string_or_float, 'height': string_or_float, 'left': string_or_float, 'right': string_or_float, 'top': string_or_float, 'bottom': string_or_float, 'hcenter': string_or_float, 'vcenter': string_or_float, 'a': int, 'r': int, 'g': int, 'b': int, 'starting_offset': float, 'duration': float, 'step_type': _step_type_cast}
def _py_macro_call(m, cast):
	return (lambda : cast(eval('%s' % m[3:], MACRO_GLOBS)))

class Anim(object):
	__doc__ = '\n    class used to stock informations about a certain animation.\n    '
	def _cast_att(self, dict):
		for key, val in dict.iteritems():
			castor = _att_cast_list.get(key, None)
			if castor is not None:
				dict[key] = castor(val)
				continue
		return dict

	def __init__(self, node):
		self.object = None
		kwargs = node.attrib
		self.type = node.tag
		self._callbacks = []
		self._stopped = False
		self._kwargs = self._cast_att(kwargs)
		for subnode in node:
			self._callbacks.append(Anim(subnode))
		return None

	def __repr__(self):
		return '<%s:%s::%s(%s)>' % (self.__class__.__name__, self.object, self.type, self._kwargs)

	def play(self, object=None):
		self._stopped = False
		self.object = object
		if self._callbacks:
			self._kwargs['end_callback'] = self.end_callback
		log.debug('ANIM %s %d : %s --> %s', object.name, id(object), self.type, self._kwargs)
		getattr(object, 'animate')(self.type, **self._kwargs)

	def end_callback(self):
		log.info('running end callback (should be thread-safe, I hope :P)')
		if not self._stopped:
			for anim in self._callbacks:
				anim.play(self.object)

	def stop(self):
		self._stopped = True



class PerpetualAnim(Anim):
	def __init__(self, node):
		self.type = node.tag
		self.object = None
		self._task = None
		self._in_pause = False
		maximums = dict()
		minimums = dict()
		duration = 1
		value = 'opacity'
		step_type = 'linear'

	def __repr__(self):
		return '<%s:%s::%s(%s)>' % (self.__class__.__name__, self.object, self.type, self._properties)

	def play(self, object=None):
		self.object = object
		p = self._properties
		d = p['duration']
		if callable(d):
			pass
		duration = float(d)
		log.debug('PERPETANIM %s %d : %s --> mini:%s value:%s duration:0', object.name, id(object), self.type, p['mini'], p['value'])
		object.animate(p['value'], duration=0, **p['mini'])
		if 'noglow' in plugins:
			pass
		log.debug('PERPETANIM %s %d : %s --> maxi:%s value:%s duration:%s step_type:%s', object.name, id(object), self.type, p['maxi'], p['value'], duration, p['step_type'])
		object.animate(p['value'], duration=duration, loop_type='boom', end_callback=self.set_min, step_type=p['step_type'], **p['maxi'])

	def set_min(self):
		self.object.animate(p['value'], duration=0, **self._properties['mini'])

	def stop(self):
		self.object.animate_stop(self._properties['value'])

	def pause(self):
		self.object.animate_stop(self._properties['value'])

	def unpause(self):
		p = self._properties
		self.object.animate(p['value'], duration=p['duration'], loop_type='boom', step_type=p['step_type'], end_callback=self.set_min, **p['maxi'])



class Animation(object):
	__doc__ = "\n    This class is a sort of contanier for multiple animations.\n    It's used when more than one animation are being played\n    on the same object at the same time (event).\n    "
	def __init__(self, node, obj=None):
		self._animations = []
		self.event = node.get('event')
		self.name = node.get('id')
		self.add_animations(node)
		self.obj = obj

	def __repr__(self):
		return '%s({"event": %s, "name": %s}, %s)' % (self.__class__.__name__, self.event, self.name, self._animations)

	def add_animations(self, node):
		for anim_node in node:
			if anim_node.tag in _animation_list:
				self._animations.append(Anim(anim_node))
				continue
			if anim_node.tag == 'glow':
				self._animations.append(PerpetualAnim(anim_node))
				continue

	def play(self, *args, **args):
		log.info('play %s %s', args, kw)
		for anim in self._animations:
			anim.play(self.obj)

	def stop(self):
		for anim in self._animations:
			anim.stop()

	def pause(self):
		for anim in self._animations:
			anim._in_pause = True
			try:
				anim.pause()
				continue
			except AttributeError:
				continue

	def unpause(self):
		for anim in self._animations:
			anim._in_pause = False
			try:
				anim.unpause()
				continue
			except AttributeError:
				continue



class AnimationCreator(object):
	def __getitem__(self, att):
		if att == 'list':
			return _animation_list

	def create(self, node, obj):
		return Animation(node, obj)



