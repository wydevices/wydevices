# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 0
n 0(None)[self._item_list = item_list
self.offset = offset
self.step = step
self.cyclic = False
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb760bbec>}
nname: 254
n 254(None)[return None
]:
	i: 173(), 212(), 241()
	o: 

nname: 241
n 241(None)[raise TypeError('_ILView object only supports indexing with ints or slices.')
]:
	i: 196(f)
	o: 254()

nname: 212
n 212(None)[return self._item_list[k * self.step + self.offset]
]:
	i: 196(t)
	o: 254()

nname: 196
n 196(isinstance(k, int))[]:
	i: 0(f)
	o: 212(t), 241(f)

nname: 173
n 173(None)[return self._item_list[start:stop:step]
]:
	i: 143(), 156()
	o: 254()

nname: 156
n 156(None)[step = k.step * self.step
]:
	i: 128(f)
	o: 173()

nname: 143
n 143(None)[step = self.step
]:
	i: 128(t)
	o: 173()

nname: 128
n 128(k.step is None)[]:
	i: 83(), 116()
	o: 143(t), 156(f)

nname: 116
n 116(None)[stop = start + (k.stop - k.start) * self.step
]:
	i: 93(t), 112()
	o: 128()

nname: 112
n 112(None)[]:
	i: 93(f)
	o: 116()

nname: 93
n 93(k.start)[]:
	i: 68(f)
	o: 112(f), 116(t)

nname: 83
n 83(None)[stop = None
]:
	i: 68(t)
	o: 128()

nname: 68
n 68(k.stop is None)[]:
	i: 31(), 44()
	o: 83(t), 93(f)

nname: 44
n 44(None)[start = k.start * self.step + self.offset
]:
	i: 15(f)
	o: 68()

nname: 31
n 31(None)[start = self.offset
]:
	i: 15(t)
	o: 68()

nname: 15
n 15(k.start is None)[]:
	i: 0(t)
	o: 31(t), 44(f)

nname: 0
n 0(isinstance(k, slice))[]:
	i: 
	o: 15(t), 196(f)

nname: 254
n 254(None)[return None
]:
	i: 128(), 196()
	o: 

nname: 196
n 196(None)[if isinstance(k, int):
	return self._item_list[k * self.step + self.offset]
else:
	raise TypeError('_ILView object only supports indexing with ints or slices.')
]:
	i: 0(f)
	o: 254()

nname: 128
n 128(None)[if k.step is None:
	step = self.step
else:
	step = k.step * self.step
return self._item_list[start:stop:step]
]:
	i: 83(), 93()
	o: 254()

nname: 93
n 93(None)[if not k.start:
	pass
stop = start + (k.stop - k.start) * self.step
]:
	i: 15(f)
	o: 128()

nname: 83
n 83(None)[stop = None
]:
	i: 15(t)
	o: 128()

nname: 15
n 15(k.stop is None)[if k.start is None:
	start = self.offset
else:
	start = k.start * self.step + self.offset
]:
	i: 0(t)
	o: 83(t), 93(f)

nname: 0
n 0(isinstance(k, slice))[]:
	i: 
	o: 15(t), 196(f)

nname: 254
n 254(None)[return None
]:
	i: 15(), 196()
	o: 

nname: 196
n 196(None)[if isinstance(k, int):
	return self._item_list[k * self.step + self.offset]
else:
	raise TypeError('_ILView object only supports indexing with ints or slices.')
]:
	i: 0(f)
	o: 254()

nname: 15
n 15(None)[if k.start is None:
	start = self.offset
else:
	start = k.start * self.step + self.offset
if k.stop is None:
	stop = None
else:
	if not k.start:
		pass
	stop = start + (k.stop - k.start) * self.step
if k.step is None:
	step = self.step
else:
	step = k.step * self.step
return self._item_list[start:stop:step]
]:
	i: 0(t)
	o: 254()

nname: 0
n 0(isinstance(k, slice))[]:
	i: 
	o: 15(t), 196(f)

nname: 0
n 0(None)[if isinstance(k, slice):
	if k.start is None:
		start = self.offset
	else:
		start = k.start * self.step + self.offset
	if k.stop is None:
		stop = None
	else:
		if not k.start:
			pass
		stop = start + (k.stop - k.start) * self.step
	if k.step is None:
		step = self.step
	else:
		step = k.step * self.step
	return self._item_list[start:stop:step]
else:
	if isinstance(k, int):
		return self._item_list[k * self.step + self.offset]
	else:
		raise TypeError('_ILView object only supports indexing with ints or slices.')
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7599d2c>}
nname: 0
n 0(None)[raise TypeError('_ILView object does not support item assignment.')
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb760b9ec>}
nname: 0
n 0(None)[raise TypeError('_ILView object does not support item deletion.')
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb760ba0c>}
nname: 0
n 0(None)[return iter(self._item_list[self.offset::self.step])
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb760bd6c>}
nname: 0
n 0(None)[source_len = len(self._item_list)
return int(ceil((source_len - self.offset) / float(self.step)))
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb760bc8c>}
nname: 6
n 6(None)[__doc__ = "View over a part of an pygui.item.containers.ItemList.\n\n    Used to fool Listing widgets into believing an ItemList is\n    actually a slice of another, beginning at [offset]\n    with a step of [step].\n\n    So an _ILView over [1, 2, 3, 4, 5, 6] with an offset of 1\n    and a step of 2 will give [2, 4, 6].\n\n    Other than that, it mimics most of a read-only,\n    inert ItemList's behavior.\n\n    XXX Maybe this should be moved to pygui.item.containers?\n    "
def __init__(self, item_list, offset=0, step=1):
	self._item_list = item_list
	self.offset = offset
	self.step = step
	self.cyclic = False

menu = property()
selected_pos = property()
selected = property()
def __getitem__(self, k):
	if isinstance(k, slice):
		if k.start is None:
			start = self.offset
		else:
			start = k.start * self.step + self.offset
		if k.stop is None:
			stop = None
		else:
			if not k.start:
				pass
			stop = start + (k.stop - k.start) * self.step
		if k.step is None:
			step = self.step
		else:
			step = k.step * self.step
		return self._item_list[start:stop:step]
	else:
		if isinstance(k, int):
			return self._item_list[k * self.step + self.offset]
		else:
			raise TypeError('_ILView object only supports indexing with ints or slices.')
	return None

def __setitem__(self, k, value):
	raise TypeError('_ILView object does not support item assignment.')

def __delitem__(self, k):
	raise TypeError('_ILView object does not support item deletion.')

def __iter__(self):
	return iter(self._item_list[self.offset::self.step])

def __len__(self):
	source_len = len(self._item_list)
	return int(ceil((source_len - self.offset) / float(self.step)))

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb760b6ac>}
nname: 0
n 0(None)[self._all_positions = positions
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb760b76c>}
nname: 40
n 40(None)[]:
	i: 26(), 39()
	o: 

nname: 39
n 39(None)[]:
	i: 20(f)
	o: 40()

nname: 26
n 26(None)[self.post_positions = post_positions
]:
	i: 20(t)
	o: 40()

nname: 20
n 20(post_positions)[]:
	i: 6(), 19()
	o: 26(t), 39(f)

nname: 19
n 19(None)[]:
	i: 0(f)
	o: 20()

nname: 6
n 6(None)[self.pre_positions = pre_positions
]:
	i: 0(t)
	o: 20()

nname: 0
n 0(pre_positions)[]:
	i: 
	o: 6(t), 19(f)

nname: 40
n 40(None)[]:
	i: 0()
	o: 

nname: 0
n 0(None)[if pre_positions:
	self.pre_positions = pre_positions
if post_positions:
	self.post_positions = post_positions
]:
	i: 
	o: 40()

nname: 0
n 0(None)[if pre_positions:
	self.pre_positions = pre_positions
if post_positions:
	self.post_positions = post_positions
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb760b9ac>}
nname: 442
n 442(None)[return None
]:
	i: 434(AE)
	o: 

nname: 434
n 434(None)[del _[1]
]:
	i: 18(finally), 430()
	o: 442(AE)

nname: 430
n 430(None)[]:
	i: 103(AL), 429()
	o: 434()

nname: 429
n 429(None)[]:
	i: 106(AF), 329()
	o: 430()

nname: 329
n 329(None)[item.initialize(None, None, _ILView(self.menu_list, i, row_length))
items.append(item)
self.add_child(item, left='0%', top='0%', height='100%', width='100%')
positions.append(('0%', '0%'))
]:
	i: 301(), 328()
	o: 429()

nname: 328
n 328(None)[]:
	i: 292(f)
	o: 329()

nname: 301
n 301(None)[item.set_extra_positions(post_position=self.post_positions[i])
]:
	i: 292(t)
	o: 329()

nname: 292
n 292(self.post_positions)[]:
	i: 264(), 291()
	o: 301(t), 328(f)

nname: 291
n 291(None)[]:
	i: 183(f)
	o: 292()

nname: 264
n 264(None)[item.set_extra_positions(pre_position=self.pre_positions[i])
]:
	i: 183(t)
	o: 292()

nname: 183
n 183(self.pre_positions)[item.name = '%s_column%i' % (self.name, i)
item.style_name = self.style_name
item.style_dict = self.style_dict
item.set_positions(pl[i::row_length])
]:
	i: 160(), 173()
	o: 264(t), 291(f)

nname: 173
n 173(None)[item = DefaultListing()
]:
	i: 119(f)
	o: 183()

nname: 160
n 160(None)[item = FixedListing()
]:
	i: 119(t)
	o: 183()

nname: 119
n 119(self.style_name.endswith('_fixed'))[for i in xrange(row_length):
_[1], self.item_list, self.positions_list, start = render_lock.__exit__, ItemList(items, 0, col_length, 0), positions, row_length * i
end = start + col_length
]:
	i: 106(for)
	o: 160(t), 173(f)

nname: 106
n 106(None)[]:
	i: 103(loop)
	o: 119(for), 429(AF)

nname: 103
n 103(None)[]:
	i: 18(ASF)
	o: 106(loop), 430(AL)

nname: 18
n 18(None)[self._initialized = True
pl = self._all_positions
row_length, self.row_length = self.menu_list.row_length, self.menu_list.row_length
col_length = len(pl) / row_length
items = []
positions = []
render_lock.__enter__()
]:
	i: 9(), 17()
	o: 103(ASF), 434(finally)

nname: 17
n 17(None)[]:
	i: 0(f)
	o: 18()

nname: 9
n 9(None)[return None
]:
	i: 0(t)
	o: 18()

nname: 0
n 0(self._initialized)[]:
	i: 
	o: 9(t), 17(f)

nname: 442
n 442(None)[return None
]:
	i: 434(AE)
	o: 

nname: 434
n 434(None)[del _[1]
]:
	i: 0(finally), 103(AL), 106(AF), 292()
	o: 442(AE)

nname: 292
n 292(None)[if self.post_positions:
	item.set_extra_positions(post_position=self.post_positions[i])
item.initialize(None, None, _ILView(self.menu_list, i, row_length))
items.append(item)
self.add_child(item, left='0%', top='0%', height='100%', width='100%')
positions.append(('0%', '0%'))
]:
	i: 119()
	o: 434()

nname: 119
n 119(None)[for i in xrange(row_length):
_[1], self.item_list, self.positions_list, start = render_lock.__exit__, ItemList(items, 0, col_length, 0), positions, row_length * i
end = start + col_length
if self.style_name.endswith('_fixed'):
	item = FixedListing()
else:
	item = DefaultListing()
item.name = '%s_column%i' % (self.name, i)
item.style_name = self.style_name
item.style_dict = self.style_dict
item.set_positions(pl[i::row_length])
if self.pre_positions:
	item.set_extra_positions(pre_position=self.pre_positions[i])
]:
	i: 106(for)
	o: 292()

nname: 106
n 106(None)[]:
	i: 103(loop)
	o: 119(for), 434(AF)

nname: 103
n 103(None)[]:
	i: 0(ASF)
	o: 106(loop), 434(AL)

nname: 0
n 0(None)[if self._initialized:
	return None
self._initialized = True
pl = self._all_positions
row_length, self.row_length = self.menu_list.row_length, self.menu_list.row_length
col_length = len(pl) / row_length
items = []
positions = []
render_lock.__enter__()
]:
	i: 
	o: 103(ASF), 434(finally)

nname: 442
n 442(None)[return None
]:
	i: 434(AE)
	o: 

nname: 434
n 434(None)[del _[1]
]:
	i: 0(finally), 103(AL), 106(AF), 119()
	o: 442(AE)

nname: 119
n 119(None)[for i in xrange(row_length):
_[1], self.item_list, self.positions_list, start = render_lock.__exit__, ItemList(items, 0, col_length, 0), positions, row_length * i
end = start + col_length
if self.style_name.endswith('_fixed'):
	item = FixedListing()
else:
	item = DefaultListing()
item.name = '%s_column%i' % (self.name, i)
item.style_name = self.style_name
item.style_dict = self.style_dict
item.set_positions(pl[i::row_length])
if self.pre_positions:
	item.set_extra_positions(pre_position=self.pre_positions[i])
if self.post_positions:
	item.set_extra_positions(post_position=self.post_positions[i])
item.initialize(None, None, _ILView(self.menu_list, i, row_length))
items.append(item)
self.add_child(item, left='0%', top='0%', height='100%', width='100%')
positions.append(('0%', '0%'))
]:
	i: 106(for)
	o: 434()

nname: 106
n 106(None)[]:
	i: 103(loop)
	o: 119(for), 434(AF)

nname: 103
n 103(None)[]:
	i: 0(ASF)
	o: 106(loop), 434(AL)

nname: 0
n 0(None)[if self._initialized:
	return None
self._initialized = True
pl = self._all_positions
row_length, self.row_length = self.menu_list.row_length, self.menu_list.row_length
col_length = len(pl) / row_length
items = []
positions = []
render_lock.__enter__()
]:
	i: 
	o: 103(ASF), 434(finally)

nname: 442
n 442(None)[return None
]:
	i: 434(AE)
	o: 

nname: 434
n 434(None)[del _[1]
]:
	i: 0(finally), 119()
	o: 442(AE)

nname: 119
n 119(None)[for i in xrange(row_length):
	_[1], self.item_list, self.positions_list, start = render_lock.__exit__, ItemList(items, 0, col_length, 0), positions, row_length * i
	end = start + col_length
	if self.style_name.endswith('_fixed'):
		item = FixedListing()
	else:
		item = DefaultListing()
	item.name = '%s_column%i' % (self.name, i)
	item.style_name = self.style_name
	item.style_dict = self.style_dict
	item.set_positions(pl[i::row_length])
	if self.pre_positions:
		item.set_extra_positions(pre_position=self.pre_positions[i])
	if self.post_positions:
		item.set_extra_positions(post_position=self.post_positions[i])
	item.initialize(None, None, _ILView(self.menu_list, i, row_length))
	items.append(item)
	self.add_child(item, left='0%', top='0%', height='100%', width='100%')
	positions.append(('0%', '0%'))
]:
	i: 103(for)
	o: 434()

nname: 103
n 103(None)[]:
	i: 0(ASF)
	o: 119(for)

nname: 0
n 0(None)[if self._initialized:
	return None
self._initialized = True
pl = self._all_positions
row_length, self.row_length = self.menu_list.row_length, self.menu_list.row_length
col_length = len(pl) / row_length
items = []
positions = []
render_lock.__enter__()
]:
	i: 
	o: 103(ASF), 434(finally)

nname: 442
n 442(None)[return None
]:
	i: 434(AE)
	o: 

nname: 434
n 434(None)[del _[1]
]:
	i: 0(finally), 103()
	o: 442(AE)

nname: 103
n 103(None)[for i in xrange(row_length):
	_[1], self.item_list, self.positions_list, start = render_lock.__exit__, ItemList(items, 0, col_length, 0), positions, row_length * i
	end = start + col_length
	if self.style_name.endswith('_fixed'):
		item = FixedListing()
	else:
		item = DefaultListing()
	item.name = '%s_column%i' % (self.name, i)
	item.style_name = self.style_name
	item.style_dict = self.style_dict
	item.set_positions(pl[i::row_length])
	if self.pre_positions:
		item.set_extra_positions(pre_position=self.pre_positions[i])
	if self.post_positions:
		item.set_extra_positions(post_position=self.post_positions[i])
	item.initialize(None, None, _ILView(self.menu_list, i, row_length))
	items.append(item)
	self.add_child(item, left='0%', top='0%', height='100%', width='100%')
	positions.append(('0%', '0%'))
]:
	i: 0(ASF)
	o: 434()

nname: 0
n 0(None)[if self._initialized:
	return None
self._initialized = True
pl = self._all_positions
row_length, self.row_length = self.menu_list.row_length, self.menu_list.row_length
col_length = len(pl) / row_length
items = []
positions = []
render_lock.__enter__()
]:
	i: 
	o: 103(ASF), 434(finally)

self.nodes: {0: <unpyclib.structure.node instance at 0xb76126ac>, 103: <unpyclib.structure.node instance at 0xb76123cc>, 434: <unpyclib.structure.node instance at 0xb759806c>, 442: <unpyclib.structure.node instance at 0xb75980ac>}
nname: 186
n 186(None)[]:
	i: 178(AE)
	o: 

nname: 178
n 178(None)[del _[1]
]:
	i: 0(finally), 174()
	o: 186(AE)

nname: 174
n 174(None)[]:
	i: 96(AL), 173()
	o: 178()

nname: 173
n 173(None)[]:
	i: 99(AF), 153()
	o: 174()

nname: 153
n 153(None)[item.do_update(-1, updated_row)
]:
	i: 115(f), 136()
	o: 173()

nname: 136
n 136(None)[item.do_update(updated_row)
continue
]:
	i: 115(t)
	o: 153()

nname: 115
n 115(column == updated_column)[_[1], self.item_list.selected, column, item = render_lock.__exit__, updated_column, enumerate(self.item_list), enumerate(self.item_list)
]:
	i: 99(for)
	o: 136(t), 153(f)

nname: 99
n 99(None)[]:
	i: 96(loop)
	o: 115(for), 173(AF)

nname: 96
n 96(None)[]:
	i: 0(ASF)
	o: 99(loop), 174(AL)

nname: 0
n 0(None)[current_column = self.item_list.selected
current_row = self.item_list[current_column].item_list.selected
updated_row = position // self.row_length
updated_column = position - updated_row * self.row_length
col_length = len(self.positions_list)
render_lock.__enter__()
]:
	i: 
	o: 96(ASF), 178(finally)

nname: 186
n 186(None)[]:
	i: 178(AE)
	o: 

nname: 178
n 178(None)[del _[1]
]:
	i: 0(finally), 96(AL), 99(AF), 115()
	o: 186(AE)

nname: 115
n 115(None)[_[1], self.item_list.selected, column, item = render_lock.__exit__, updated_column, enumerate(self.item_list), enumerate(self.item_list)
if column == updated_column:
	item.do_update(updated_row)
	continue
item.do_update(-1, updated_row)
]:
	i: 99(for)
	o: 178()

nname: 99
n 99(None)[]:
	i: 96(loop)
	o: 115(for), 178(AF)

nname: 96
n 96(None)[]:
	i: 0(ASF)
	o: 99(loop), 178(AL)

nname: 0
n 0(None)[current_column = self.item_list.selected
current_row = self.item_list[current_column].item_list.selected
updated_row = position // self.row_length
updated_column = position - updated_row * self.row_length
col_length = len(self.positions_list)
render_lock.__enter__()
]:
	i: 
	o: 96(ASF), 178(finally)

nname: 186
n 186(None)[]:
	i: 178(AE)
	o: 

nname: 178
n 178(None)[del _[1]
]:
	i: 0(finally), 115()
	o: 186(AE)

nname: 115
n 115(None)[_[1], self.item_list.selected, column, item = render_lock.__exit__, updated_column, enumerate(self.item_list), enumerate(self.item_list)
	if column == updated_column:
		item.do_update(updated_row)
		continue
	item.do_update(-1, updated_row)
]:
	i: 96(for)
	o: 178()

nname: 96
n 96(None)[]:
	i: 0(ASF)
	o: 115(for)

nname: 0
n 0(None)[current_column = self.item_list.selected
current_row = self.item_list[current_column].item_list.selected
updated_row = position // self.row_length
updated_column = position - updated_row * self.row_length
col_length = len(self.positions_list)
render_lock.__enter__()
]:
	i: 
	o: 96(ASF), 178(finally)

nname: 186
n 186(None)[]:
	i: 178(AE)
	o: 

nname: 178
n 178(None)[del _[1]
]:
	i: 0(finally), 96()
	o: 186(AE)

nname: 96
n 96(None)[_[1], self.item_list.selected, column, item = render_lock.__exit__, updated_column, enumerate(self.item_list), enumerate(self.item_list)
	if column == updated_column:
		item.do_update(updated_row)
		continue
	item.do_update(-1, updated_row)
]:
	i: 0(ASF)
	o: 178()

nname: 0
n 0(None)[current_column = self.item_list.selected
current_row = self.item_list[current_column].item_list.selected
updated_row = position // self.row_length
updated_column = position - updated_row * self.row_length
col_length = len(self.positions_list)
render_lock.__enter__()
]:
	i: 
	o: 96(ASF), 178(finally)

nname: 178
n 178(None)[finally:
	del _[1]
]:
	i: 0()
	o: 

nname: 0
n 0(None)[current_column = self.item_list.selected
current_row = self.item_list[current_column].item_list.selected
updated_row = position // self.row_length
updated_column = position - updated_row * self.row_length
col_length = len(self.positions_list)
render_lock.__enter__()
try:
	_[1], self.item_list.selected, column, item = render_lock.__exit__, updated_column, enumerate(self.item_list), enumerate(self.item_list)
		if column == updated_column:
			item.do_update(updated_row)
			continue
		item.do_update(-1, updated_row)
]:
	i: 
	o: 178()

nname: 0
n 0(None)[current_column = self.item_list.selected
current_row = self.item_list[current_column].item_list.selected
updated_row = position // self.row_length
updated_column = position - updated_row * self.row_length
col_length = len(self.positions_list)
render_lock.__enter__()
try:
	_[1], self.item_list.selected, column, item = render_lock.__exit__, updated_column, enumerate(self.item_list), enumerate(self.item_list)
		if column == updated_column:
			item.do_update(updated_row)
			continue
		item.do_update(-1, updated_row)
finally:
	del _[1]
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75990ac>}
nname: 162
n 162(None)[]:
	i: 154(AE)
	o: 

nname: 154
n 154(None)[del _[1]
]:
	i: 0(finally), 150()
	o: 162(AE)

nname: 150
n 150(None)[]:
	i: 62(AL), 149()
	o: 154()

nname: 149
n 149(None)[]:
	i: 65(AF), 119()
	o: 150()

nname: 119
n 119(None)[item.do_reset()
item.do_update(-1, selected_row)
]:
	i: 81(f), 102()
	o: 149()

nname: 102
n 102(None)[item.do_remove(row)
continue
]:
	i: 81(t)
	o: 119()

nname: 81
n 81(index == column)[_[1], index, item = render_lock.__exit__, enumerate(self.item_list), enumerate(self.item_list)
]:
	i: 65(for)
	o: 102(t), 119(f)

nname: 65
n 65(None)[]:
	i: 62(loop)
	o: 81(for), 149(AF)

nname: 62
n 62(None)[]:
	i: 0(ASF)
	o: 65(loop), 150(AL)

nname: 0
n 0(None)[row = position // self.row_length
column = position - row * self.row_length
selected_row = self.menu_list.selected_row
render_lock.__enter__()
]:
	i: 
	o: 62(ASF), 154(finally)

nname: 162
n 162(None)[]:
	i: 154(AE)
	o: 

nname: 154
n 154(None)[del _[1]
]:
	i: 0(finally), 62(AL), 65(AF), 81()
	o: 162(AE)

nname: 81
n 81(None)[_[1], index, item = render_lock.__exit__, enumerate(self.item_list), enumerate(self.item_list)
if index == column:
	item.do_remove(row)
	continue
item.do_reset()
item.do_update(-1, selected_row)
]:
	i: 65(for)
	o: 154()

nname: 65
n 65(None)[]:
	i: 62(loop)
	o: 81(for), 154(AF)

nname: 62
n 62(None)[]:
	i: 0(ASF)
	o: 65(loop), 154(AL)

nname: 0
n 0(None)[row = position // self.row_length
column = position - row * self.row_length
selected_row = self.menu_list.selected_row
render_lock.__enter__()
]:
	i: 
	o: 62(ASF), 154(finally)

nname: 162
n 162(None)[]:
	i: 154(AE)
	o: 

nname: 154
n 154(None)[del _[1]
]:
	i: 0(finally), 81()
	o: 162(AE)

nname: 81
n 81(None)[_[1], index, item = render_lock.__exit__, enumerate(self.item_list), enumerate(self.item_list)
	if index == column:
		item.do_remove(row)
		continue
	item.do_reset()
	item.do_update(-1, selected_row)
]:
	i: 62(for)
	o: 154()

nname: 62
n 62(None)[]:
	i: 0(ASF)
	o: 81(for)

nname: 0
n 0(None)[row = position // self.row_length
column = position - row * self.row_length
selected_row = self.menu_list.selected_row
render_lock.__enter__()
]:
	i: 
	o: 62(ASF), 154(finally)

nname: 162
n 162(None)[]:
	i: 154(AE)
	o: 

nname: 154
n 154(None)[del _[1]
]:
	i: 0(finally), 62()
	o: 162(AE)

nname: 62
n 62(None)[_[1], index, item = render_lock.__exit__, enumerate(self.item_list), enumerate(self.item_list)
	if index == column:
		item.do_remove(row)
		continue
	item.do_reset()
	item.do_update(-1, selected_row)
]:
	i: 0(ASF)
	o: 154()

nname: 0
n 0(None)[row = position // self.row_length
column = position - row * self.row_length
selected_row = self.menu_list.selected_row
render_lock.__enter__()
]:
	i: 
	o: 62(ASF), 154(finally)

nname: 154
n 154(None)[finally:
	del _[1]
]:
	i: 0()
	o: 

nname: 0
n 0(None)[row = position // self.row_length
column = position - row * self.row_length
selected_row = self.menu_list.selected_row
render_lock.__enter__()
try:
	_[1], index, item = render_lock.__exit__, enumerate(self.item_list), enumerate(self.item_list)
		if index == column:
			item.do_remove(row)
			continue
		item.do_reset()
		item.do_update(-1, selected_row)
]:
	i: 
	o: 154()

nname: 0
n 0(None)[row = position // self.row_length
column = position - row * self.row_length
selected_row = self.menu_list.selected_row
render_lock.__enter__()
try:
	_[1], index, item = render_lock.__exit__, enumerate(self.item_list), enumerate(self.item_list)
		if index == column:
			item.do_remove(row)
			continue
		item.do_reset()
		item.do_update(-1, selected_row)
finally:
	del _[1]
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb760bb0c>}
nname: 247
n 247(None)[return None
]:
	i: 144(), 196(), 220()
	o: 

nname: 220
n 220(None)[self.item_list[column].do_reset(row, focus=row)
]:
	i: 147(f)
	o: 247()

nname: 196
n 196(None)[self.item_list[column].do_reset(row)
]:
	i: 147(t)
	o: 247()

nname: 147
n 147(column == self.menu_list.selected_column)[row = position // self.row_length
column = position - row * self.row_length
]:
	i: 0(f)
	o: 196(t), 220(f)

nname: 144
n 144(None)[]:
	i: 136(AE)
	o: 247()

nname: 136
n 136(None)[del _[1]
]:
	i: 12(finally), 132()
	o: 144(AE)

nname: 132
n 132(None)[]:
	i: 33(AL), 131()
	o: 136()

nname: 131
n 131(None)[]:
	i: 60(AF), 127()
	o: 132()

nname: 127
n 127(None)[]:
	i: 76(f), 107()
	o: 131()

nname: 107
n 107(None)[item.do_update(-1, selected_row)
continue
]:
	i: 76(t)
	o: 127()

nname: 76
n 76(column != selected_column)[for column, item in enumerate(self.item_list):
item.do_reset()
]:
	i: 60(for)
	o: 107(t), 127(f)

nname: 60
n 60(None)[]:
	i: 33(loop)
	o: 76(for), 131(AF)

nname: 33
n 33(None)[_[1], selected_row = render_lock.__exit__, self.menu_list.selected_row
selected_column = self.menu_list.selected_column
]:
	i: 12(ASF)
	o: 60(loop), 132(AL)

nname: 12
n 12(None)[render_lock.__enter__()
]:
	i: 0(t)
	o: 33(ASF), 136(finally)

nname: 0
n 0(position is None)[]:
	i: 
	o: 12(t), 147(f)

nname: 247
n 247(None)[return None
]:
	i: 147(), 136(AE)
	o: 

nname: 147
n 147(None)[row = position // self.row_length
column = position - row * self.row_length
if column == self.menu_list.selected_column:
	self.item_list[column].do_reset(row)
else:
	self.item_list[column].do_reset(row, focus=row)
]:
	i: 0(f)
	o: 247()

nname: 136
n 136(None)[del _[1]
]:
	i: 12(finally), 33(AL), 60(AF), 76()
	o: 247(AE)

nname: 76
n 76(None)[for column, item in enumerate(self.item_list):
item.do_reset()
if column != selected_column:
	item.do_update(-1, selected_row)
	continue
]:
	i: 60(for)
	o: 136()

nname: 60
n 60(None)[]:
	i: 33(loop)
	o: 76(for), 136(AF)

nname: 33
n 33(None)[_[1], selected_row = render_lock.__exit__, self.menu_list.selected_row
selected_column = self.menu_list.selected_column
]:
	i: 12(ASF)
	o: 60(loop), 136(AL)

nname: 12
n 12(None)[render_lock.__enter__()
]:
	i: 0(t)
	o: 33(ASF), 136(finally)

nname: 0
n 0(position is None)[]:
	i: 
	o: 12(t), 147(f)

nname: 247
n 247(None)[return None
]:
	i: 147(), 136(AE)
	o: 

nname: 147
n 147(None)[row = position // self.row_length
column = position - row * self.row_length
if column == self.menu_list.selected_column:
	self.item_list[column].do_reset(row)
else:
	self.item_list[column].do_reset(row, focus=row)
]:
	i: 0(f)
	o: 247()

nname: 136
n 136(None)[del _[1]
]:
	i: 12(finally), 76()
	o: 247(AE)

nname: 76
n 76(None)[for column, item in enumerate(self.item_list):
	item.do_reset()
	if column != selected_column:
		item.do_update(-1, selected_row)
		continue
]:
	i: 33(for)
	o: 136()

nname: 33
n 33(None)[_[1], selected_row = render_lock.__exit__, self.menu_list.selected_row
selected_column = self.menu_list.selected_column
]:
	i: 12(ASF)
	o: 76(for)

nname: 12
n 12(None)[render_lock.__enter__()
]:
	i: 0(t)
	o: 33(ASF), 136(finally)

nname: 0
n 0(position is None)[]:
	i: 
	o: 12(t), 147(f)

nname: 247
n 247(None)[return None
]:
	i: 147(), 136(AE)
	o: 

nname: 147
n 147(None)[row = position // self.row_length
column = position - row * self.row_length
if column == self.menu_list.selected_column:
	self.item_list[column].do_reset(row)
else:
	self.item_list[column].do_reset(row, focus=row)
]:
	i: 0(f)
	o: 247()

nname: 136
n 136(None)[del _[1]
]:
	i: 12(finally), 33()
	o: 247(AE)

nname: 33
n 33(None)[_[1], selected_row = render_lock.__exit__, self.menu_list.selected_row
selected_column = self.menu_list.selected_column
for column, item in enumerate(self.item_list):
	item.do_reset()
	if column != selected_column:
		item.do_update(-1, selected_row)
		continue
]:
	i: 12(ASF)
	o: 136()

nname: 12
n 12(None)[render_lock.__enter__()
]:
	i: 0(t)
	o: 33(ASF), 136(finally)

nname: 0
n 0(position is None)[]:
	i: 
	o: 12(t), 147(f)

nname: 247
n 247(None)[return None
]:
	i: 147(), 136()
	o: 

nname: 147
n 147(None)[row = position // self.row_length
column = position - row * self.row_length
if column == self.menu_list.selected_column:
	self.item_list[column].do_reset(row)
else:
	self.item_list[column].do_reset(row, focus=row)
]:
	i: 0(f)
	o: 247()

nname: 136
n 136(None)[finally:
	del _[1]
]:
	i: 12()
	o: 247()

nname: 12
n 12(None)[render_lock.__enter__()
try:
	_[1], selected_row = render_lock.__exit__, self.menu_list.selected_row
	selected_column = self.menu_list.selected_column
	for column, item in enumerate(self.item_list):
		item.do_reset()
		if column != selected_column:
			item.do_update(-1, selected_row)
			continue
]:
	i: 0(t)
	o: 136()

nname: 0
n 0(position is None)[]:
	i: 
	o: 12(t), 147(f)

nname: 247
n 247(None)[return None
]:
	i: 147(), 12()
	o: 

nname: 147
n 147(None)[row = position // self.row_length
column = position - row * self.row_length
if column == self.menu_list.selected_column:
	self.item_list[column].do_reset(row)
else:
	self.item_list[column].do_reset(row, focus=row)
]:
	i: 0(f)
	o: 247()

nname: 12
n 12(None)[render_lock.__enter__()
try:
	_[1], selected_row = render_lock.__exit__, self.menu_list.selected_row
	selected_column = self.menu_list.selected_column
	for column, item in enumerate(self.item_list):
		item.do_reset()
		if column != selected_column:
			item.do_update(-1, selected_row)
			continue
finally:
	del _[1]
]:
	i: 0(t)
	o: 247()

nname: 0
n 0(position is None)[]:
	i: 
	o: 12(t), 147(f)

nname: 0
n 0(None)[if position is None:
	render_lock.__enter__()
	try:
		_[1], selected_row = render_lock.__exit__, self.menu_list.selected_row
		selected_column = self.menu_list.selected_column
		for column, item in enumerate(self.item_list):
			item.do_reset()
			if column != selected_column:
				item.do_update(-1, selected_row)
				continue
	finally:
		del _[1]
else:
	row = position // self.row_length
	column = position - row * self.row_length
	if column == self.menu_list.selected_column:
		self.item_list[column].do_reset(row)
	else:
		self.item_list[column].do_reset(row, focus=row)
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb759936c>}
nname: 0
n 0(None)[col_index = DefaultListing.pick(self, x)
row_index = self.item_list[col_index].pick(y)
return row_index * self.row_length + col_index
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb760b8ec>}
nname: 156
n 156(None)[]:
	i: 67(), 128()
	o: 

nname: 128
n 128(None)[new_pos = pos - row_length * col_length
return max(0, new_pos)
]:
	i: 0(f)
	o: 156()

nname: 67
n 67(None)[ml = self.menu_list
new_pos = pos + row_length * col_length
ml[pos:new_pos]
return min(new_pos, len(ml) - 1)
]:
	i: 0(t)
	o: 156()

nname: 0
n 0(forward)[il = self.item_list
ml = self.menu_list
pl = self._all_positions
row_length = self.row_length
col_length = len(pl) / row_length
pos = ml.selected_pos
]:
	i: 
	o: 67(t), 128(f)

nname: 0
n 0(None)[il = self.item_list
ml = self.menu_list
pl = self._all_positions
row_length = self.row_length
col_length = len(pl) / row_length
pos = ml.selected_pos
if forward:
	ml = self.menu_list
	new_pos = pos + row_length * col_length
	ml[pos:new_pos]
	return min(new_pos, len(ml) - 1)
else:
	new_pos = pos - row_length * col_length
	return max(0, new_pos)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb760bfac>}
nname: 136
n 136(None)[]:
	i: 40(AL), 73(), 77(AL), 135()
	o: 

nname: 135
n 135(None)[]:
	i: 110(AF), 120()
	o: 136()

nname: 120
n 120(None)[for sublist in self.item_list:
sublist._no_selection = False
]:
	i: 110(for)
	o: 135()

nname: 110
n 110(None)[]:
	i: 77(loop)
	o: 120(for), 135(AF)

nname: 77
n 77(None)[sublists = self.item_list
sublists[sublists.selected].do_enable_selection(True)
]:
	i: 24(t)
	o: 110(loop), 136(AL)

nname: 73
n 73(None)[]:
	i: 44(AF), 54()
	o: 136()

nname: 54
n 54(None)[for sublist in self.item_list:
sublist.do_enable_selection(False)
]:
	i: 44(for)
	o: 73()

nname: 44
n 44(None)[]:
	i: 40(loop)
	o: 54(for), 73(AF)

nname: 40
n 40(None)[]:
	i: 24(f)
	o: 44(loop), 136(AL)

nname: 24
n 24(select)[self._no_selection = not select
]:
	i: 15(), 23()
	o: 40(f), 77(t)

nname: 23
n 23(None)[]:
	i: 0(f)
	o: 24()

nname: 15
n 15(None)[]:
	i: 0(t)
	o: 24()

nname: 0
n 0(self._no_selection != select)[]:
	i: 
	o: 15(t), 23(f)

nname: 136
n 136(None)[]:
	i: 54(), 120()
	o: 

nname: 120
n 120(None)[for sublist in self.item_list:
	sublist._no_selection = False
]:
	i: 77(for)
	o: 136()

nname: 77
n 77(None)[sublists = self.item_list
sublists[sublists.selected].do_enable_selection(True)
]:
	i: 0(t)
	o: 120(for)

nname: 54
n 54(None)[for sublist in self.item_list:
	sublist.do_enable_selection(False)
]:
	i: 40(for)
	o: 136()

nname: 40
n 40(None)[]:
	i: 0(f)
	o: 54(for)

nname: 0
n 0(select)[if self._no_selection != select:
	pass
self._no_selection = not select
]:
	i: 
	o: 40(f), 77(t)

nname: 136
n 136(None)[]:
	i: 40(), 77()
	o: 

nname: 77
n 77(None)[sublists = self.item_list
sublists[sublists.selected].do_enable_selection(True)
for sublist in self.item_list:
	sublist._no_selection = False
]:
	i: 0(t)
	o: 136()

nname: 40
n 40(None)[for sublist in self.item_list:
	sublist.do_enable_selection(False)
]:
	i: 0(f)
	o: 136()

nname: 0
n 0(select)[if self._no_selection != select:
	pass
self._no_selection = not select
]:
	i: 
	o: 40(f), 77(t)

nname: 0
n 0(None)[if self._no_selection != select:
	pass
self._no_selection = not select
if not select:
	for sublist in self.item_list:
		sublist.do_enable_selection(False)
else:
	sublists = self.item_list
	sublists[sublists.selected].do_enable_selection(True)
	for sublist in self.item_list:
		sublist._no_selection = False
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb760bf4c>}
nname: 6
n 6(None)[__doc__ = 'Grid widget.\n\n    Implemented as a DefaultListing containing [user-set style] listings.\n    Each column is made to scroll by the Grid when necessary.\n\n    Requires a L{pygui.item.containers.ItemGrid} as its underlying model.\n    '
pre_positions = None
post_positions = None
def set_positions(self, positions):
	self._all_positions = positions

def set_extra_positions(self, pre_positions=None, post_positions=None):
	if pre_positions:
		self.pre_positions = pre_positions
	if post_positions:
		self.post_positions = post_positions

def create_content(self):
	if self._initialized:
		return None
	self._initialized = True
	pl = self._all_positions
	row_length, self.row_length = self.menu_list.row_length, self.menu_list.row_length
	col_length = len(pl) / row_length
	items = []
	positions = []
	render_lock.__enter__()

def do_update(self, position):
	current_column = self.item_list.selected
	current_row = self.item_list[current_column].item_list.selected
	updated_row = position // self.row_length
	updated_column = position - updated_row * self.row_length
	col_length = len(self.positions_list)
	render_lock.__enter__()
	try:
		_[1], self.item_list.selected, column, item = render_lock.__exit__, updated_column, enumerate(self.item_list), enumerate(self.item_list)
			if column == updated_column:
				item.do_update(updated_row)
				continue
			item.do_update(-1, updated_row)
	finally:
		del _[1]

def do_remove(self, position):
	row = position // self.row_length
	column = position - row * self.row_length
	selected_row = self.menu_list.selected_row
	render_lock.__enter__()
	try:
		_[1], index, item = render_lock.__exit__, enumerate(self.item_list), enumerate(self.item_list)
			if index == column:
				item.do_remove(row)
				continue
			item.do_reset()
			item.do_update(-1, selected_row)
	finally:
		del _[1]

def do_reset(self, position=None):
	if position is None:
		render_lock.__enter__()
		try:
			_[1], selected_row = render_lock.__exit__, self.menu_list.selected_row
			selected_column = self.menu_list.selected_column
			for column, item in enumerate(self.item_list):
				item.do_reset()
				if column != selected_column:
					item.do_update(-1, selected_row)
					continue
		finally:
			del _[1]
	else:
		row = position // self.row_length
		column = position - row * self.row_length
		if column == self.menu_list.selected_column:
			self.item_list[column].do_reset(row)
		else:
			self.item_list[column].do_reset(row, focus=row)
	return None

def pick(self, x, y):
	col_index = DefaultListing.pick(self, x)
	row_index = self.item_list[col_index].pick(y)
	return row_index * self.row_length + col_index

def page_jump(self, forward):
	il = self.item_list
	ml = self.menu_list
	pl = self._all_positions
	row_length = self.row_length
	col_length = len(pl) / row_length
	pos = ml.selected_pos
	if forward:
		ml = self.menu_list
		new_pos = pos + row_length * col_length
		ml[pos:new_pos]
		return min(new_pos, len(ml) - 1)
	else:
		new_pos = pos - row_length * col_length
		return max(0, new_pos)

def do_enable_selection(self, select):
	if self._no_selection != select:
		pass
	self._no_selection = not select
	if not select:
		for sublist in self.item_list:
			sublist.do_enable_selection(False)
	else:
		sublists = self.item_list
		sublists[sublists.selected].do_enable_selection(True)
		for sublist in self.item_list:
			sublist._no_selection = False

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb760b58c>}
nname: 0
n 0(None)[from __future__ import absolute_import, with_statement
from math import ceil
from wyvas import render_lock
from pygui.gui.widget.listing.items import ItemList
from pygui.gui.widget.listing.style_default import DefaultListing
from pygui.gui.widget.listing.style_fixed import FixedListing
class _ILView(object):
	__doc__ = "View over a part of an pygui.item.containers.ItemList.\n\n    Used to fool Listing widgets into believing an ItemList is\n    actually a slice of another, beginning at [offset]\n    with a step of [step].\n\n    So an _ILView over [1, 2, 3, 4, 5, 6] with an offset of 1\n    and a step of 2 will give [2, 4, 6].\n\n    Other than that, it mimics most of a read-only,\n    inert ItemList's behavior.\n\n    XXX Maybe this should be moved to pygui.item.containers?\n    "
	def __init__(self, item_list, offset=0, step=1):
		self._item_list = item_list
		self.offset = offset
		self.step = step
		self.cyclic = False

	menu = property()
	selected_pos = property()
	selected = property()
	def __getitem__(self, k):
		if isinstance(k, slice):
			if k.start is None:
				start = self.offset
			else:
				start = k.start * self.step + self.offset
			if k.stop is None:
				stop = None
			else:
				if not k.start:
					pass
				stop = start + (k.stop - k.start) * self.step
			if k.step is None:
				step = self.step
			else:
				step = k.step * self.step
			return self._item_list[start:stop:step]
		else:
			if isinstance(k, int):
				return self._item_list[k * self.step + self.offset]
			else:
				raise TypeError('_ILView object only supports indexing with ints or slices.')
		return None

	def __setitem__(self, k, value):
		raise TypeError('_ILView object does not support item assignment.')

	def __delitem__(self, k):
		raise TypeError('_ILView object does not support item deletion.')

	def __iter__(self):
		return iter(self._item_list[self.offset::self.step])

	def __len__(self):
		source_len = len(self._item_list)
		return int(ceil((source_len - self.offset) / float(self.step)))



class Grid(DefaultListing):
	__doc__ = 'Grid widget.\n\n    Implemented as a DefaultListing containing [user-set style] listings.\n    Each column is made to scroll by the Grid when necessary.\n\n    Requires a L{pygui.item.containers.ItemGrid} as its underlying model.\n    '
	pre_positions = None
	post_positions = None
	def set_positions(self, positions):
		self._all_positions = positions

	def set_extra_positions(self, pre_positions=None, post_positions=None):
		if pre_positions:
			self.pre_positions = pre_positions
		if post_positions:
			self.post_positions = post_positions

	def create_content(self):
		if self._initialized:
			return None
		self._initialized = True
		pl = self._all_positions
		row_length, self.row_length = self.menu_list.row_length, self.menu_list.row_length
		col_length = len(pl) / row_length
		items = []
		positions = []
		render_lock.__enter__()

	def do_update(self, position):
		current_column = self.item_list.selected
		current_row = self.item_list[current_column].item_list.selected
		updated_row = position // self.row_length
		updated_column = position - updated_row * self.row_length
		col_length = len(self.positions_list)
		render_lock.__enter__()
		try:
			_[1], self.item_list.selected, column, item = render_lock.__exit__, updated_column, enumerate(self.item_list), enumerate(self.item_list)
				if column == updated_column:
					item.do_update(updated_row)
					continue
				item.do_update(-1, updated_row)
		finally:
			del _[1]

	def do_remove(self, position):
		row = position // self.row_length
		column = position - row * self.row_length
		selected_row = self.menu_list.selected_row
		render_lock.__enter__()
		try:
			_[1], index, item = render_lock.__exit__, enumerate(self.item_list), enumerate(self.item_list)
				if index == column:
					item.do_remove(row)
					continue
				item.do_reset()
				item.do_update(-1, selected_row)
		finally:
			del _[1]

	def do_reset(self, position=None):
		if position is None:
			render_lock.__enter__()
			try:
				_[1], selected_row = render_lock.__exit__, self.menu_list.selected_row
				selected_column = self.menu_list.selected_column
				for column, item in enumerate(self.item_list):
					item.do_reset()
					if column != selected_column:
						item.do_update(-1, selected_row)
						continue
			finally:
				del _[1]
		else:
			row = position // self.row_length
			column = position - row * self.row_length
			if column == self.menu_list.selected_column:
				self.item_list[column].do_reset(row)
			else:
				self.item_list[column].do_reset(row, focus=row)
		return None

	def pick(self, x, y):
		col_index = DefaultListing.pick(self, x)
		row_index = self.item_list[col_index].pick(y)
		return row_index * self.row_length + col_index

	def page_jump(self, forward):
		il = self.item_list
		ml = self.menu_list
		pl = self._all_positions
		row_length = self.row_length
		col_length = len(pl) / row_length
		pos = ml.selected_pos
		if forward:
			ml = self.menu_list
			new_pos = pos + row_length * col_length
			ml[pos:new_pos]
			return min(new_pos, len(ml) - 1)
		else:
			new_pos = pos - row_length * col_length
			return max(0, new_pos)

	def do_enable_selection(self, select):
		if self._no_selection != select:
			pass
		self._no_selection = not select
		if not select:
			for sublist in self.item_list:
				sublist.do_enable_selection(False)
		else:
			sublists = self.item_list
			sublists[sublists.selected].do_enable_selection(True)
			for sublist in self.item_list:
				sublist._no_selection = False



]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb760518c>}
from __future__ import absolute_import, with_statement
from math import ceil
from wyvas import render_lock
from pygui.gui.widget.listing.items import ItemList
from pygui.gui.widget.listing.style_default import DefaultListing
from pygui.gui.widget.listing.style_fixed import FixedListing
class _ILView(object):
	__doc__ = "View over a part of an pygui.item.containers.ItemList.\n\n    Used to fool Listing widgets into believing an ItemList is\n    actually a slice of another, beginning at [offset]\n    with a step of [step].\n\n    So an _ILView over [1, 2, 3, 4, 5, 6] with an offset of 1\n    and a step of 2 will give [2, 4, 6].\n\n    Other than that, it mimics most of a read-only,\n    inert ItemList's behavior.\n\n    XXX Maybe this should be moved to pygui.item.containers?\n    "
	def __init__(self, item_list, offset=0, step=1):
		self._item_list = item_list
		self.offset = offset
		self.step = step
		self.cyclic = False

	menu = property()
	selected_pos = property()
	selected = property()
	def __getitem__(self, k):
		if isinstance(k, slice):
			if k.start is None:
				start = self.offset
			else:
				start = k.start * self.step + self.offset
			if k.stop is None:
				stop = None
			else:
				if not k.start:
					pass
				stop = start + (k.stop - k.start) * self.step
			if k.step is None:
				step = self.step
			else:
				step = k.step * self.step
			return self._item_list[start:stop:step]
		else:
			if isinstance(k, int):
				return self._item_list[k * self.step + self.offset]
			else:
				raise TypeError('_ILView object only supports indexing with ints or slices.')
		return None

	def __setitem__(self, k, value):
		raise TypeError('_ILView object does not support item assignment.')

	def __delitem__(self, k):
		raise TypeError('_ILView object does not support item deletion.')

	def __iter__(self):
		return iter(self._item_list[self.offset::self.step])

	def __len__(self):
		source_len = len(self._item_list)
		return int(ceil((source_len - self.offset) / float(self.step)))



class Grid(DefaultListing):
	__doc__ = 'Grid widget.\n\n    Implemented as a DefaultListing containing [user-set style] listings.\n    Each column is made to scroll by the Grid when necessary.\n\n    Requires a L{pygui.item.containers.ItemGrid} as its underlying model.\n    '
	pre_positions = None
	post_positions = None
	def set_positions(self, positions):
		self._all_positions = positions

	def set_extra_positions(self, pre_positions=None, post_positions=None):
		if pre_positions:
			self.pre_positions = pre_positions
		if post_positions:
			self.post_positions = post_positions

	def create_content(self):
		if self._initialized:
			return None
		self._initialized = True
		pl = self._all_positions
		row_length, self.row_length = self.menu_list.row_length, self.menu_list.row_length
		col_length = len(pl) / row_length
		items = []
		positions = []
		render_lock.__enter__()

	def do_update(self, position):
		current_column = self.item_list.selected
		current_row = self.item_list[current_column].item_list.selected
		updated_row = position // self.row_length
		updated_column = position - updated_row * self.row_length
		col_length = len(self.positions_list)
		render_lock.__enter__()
		try:
			_[1], self.item_list.selected, column, item = render_lock.__exit__, updated_column, enumerate(self.item_list), enumerate(self.item_list)
				if column == updated_column:
					item.do_update(updated_row)
					continue
				item.do_update(-1, updated_row)
		finally:
			del _[1]

	def do_remove(self, position):
		row = position // self.row_length
		column = position - row * self.row_length
		selected_row = self.menu_list.selected_row
		render_lock.__enter__()
		try:
			_[1], index, item = render_lock.__exit__, enumerate(self.item_list), enumerate(self.item_list)
				if index == column:
					item.do_remove(row)
					continue
				item.do_reset()
				item.do_update(-1, selected_row)
		finally:
			del _[1]

	def do_reset(self, position=None):
		if position is None:
			render_lock.__enter__()
			try:
				_[1], selected_row = render_lock.__exit__, self.menu_list.selected_row
				selected_column = self.menu_list.selected_column
				for column, item in enumerate(self.item_list):
					item.do_reset()
					if column != selected_column:
						item.do_update(-1, selected_row)
						continue
			finally:
				del _[1]
		else:
			row = position // self.row_length
			column = position - row * self.row_length
			if column == self.menu_list.selected_column:
				self.item_list[column].do_reset(row)
			else:
				self.item_list[column].do_reset(row, focus=row)
		return None

	def pick(self, x, y):
		col_index = DefaultListing.pick(self, x)
		row_index = self.item_list[col_index].pick(y)
		return row_index * self.row_length + col_index

	def page_jump(self, forward):
		il = self.item_list
		ml = self.menu_list
		pl = self._all_positions
		row_length = self.row_length
		col_length = len(pl) / row_length
		pos = ml.selected_pos
		if forward:
			ml = self.menu_list
			new_pos = pos + row_length * col_length
			ml[pos:new_pos]
			return min(new_pos, len(ml) - 1)
		else:
			new_pos = pos - row_length * col_length
			return max(0, new_pos)

	def do_enable_selection(self, select):
		if self._no_selection != select:
			pass
		self._no_selection = not select
		if not select:
			for sublist in self.item_list:
				sublist.do_enable_selection(False)
		else:
			sublists = self.item_list
			sublists[sublists.selected].do_enable_selection(True)
			for sublist in self.item_list:
				sublist._no_selection = False



