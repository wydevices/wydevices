# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 377
n 377(None)[return out
]:
	i: 362(), 376()
	o: 

nname: 376
n 376(None)[]:
	i: 356(f)
	o: 377()

nname: 362
n 362(None)[out.reverse()
]:
	i: 356(t)
	o: 377()

nname: 356
n 356(use_reverse)[]:
	i: 142(AL), 355()
	o: 362(t), 376(f)

nname: 355
n 355(None)[]:
	i: 145(AF), 333()
	o: 356()

nname: 333
n 333(None)[out.append((start_time, end_time))
]:
	i: 308(), 322()
	o: 355()

nname: 322
n 322(None)[end_time = start_time + duration
]:
	i: 302(f)
	o: 333()

nname: 308
n 308(None)[start_time = end_time - duration
]:
	i: 302(t)
	o: 333()

nname: 302
n 302(use_reverse)[]:
	i: 244(), 268()
	o: 308(t), 322(f)

nname: 268
n 268(None)[duration = max(prog_duration - missing_seconds, min_duration)
missing_seconds -= prog_duration - duration
]:
	i: 232(f)
	o: 302()

nname: 244
n 244(None)[duration = min_duration
missing_seconds += min_duration - prog_duration
]:
	i: 232(t)
	o: 302()

nname: 232
n 232(prog_duration < min_duration)[]:
	i: 207(), 221()
	o: 244(t), 268(f)

nname: 221
n 221(None)[start_time = prog_start_time + missing_seconds
]:
	i: 152(f)
	o: 232()

nname: 207
n 207(None)[end_time = prog_end_time - missing_seconds
]:
	i: 152(t)
	o: 232()

nname: 152
n 152(use_reverse)[for prog in programs:
prog_start_time = max(prog.start_time, global_start_time)
prog_end_time = min(prog.end_time, global_end_time)
prog_duration = prog_end_time - prog_start_time
]:
	i: 145(for)
	o: 207(t), 221(f)

nname: 145
n 145(None)[]:
	i: 142(loop)
	o: 152(for), 355(AF)

nname: 142
n 142(None)[]:
	i: 125(), 141()
	o: 145(loop), 356(AL)

nname: 141
n 141(None)[]:
	i: 64(f)
	o: 142()

nname: 125
n 125(None)[programs = reversed(programs)
]:
	i: 64(t)
	o: 142()

nname: 64
n 64(use_reverse)[global_end_time = global_end_time
midpoint = max(programs[len(programs) / 2].start_time, global_start_time)
use_reverse = midpoint > (global_start_time + global_end_time) / 2
]:
	i: 44(t), 53()
	o: 125(t), 141(f)

nname: 53
n 53(None)[]:
	i: 44(f)
	o: 64()

nname: 44
n 44(global_end_time)[global_start_time = global_start_time
]:
	i: 27(t), 33()
	o: 53(f), 64(t)

nname: 33
n 33(None)[]:
	i: 27(f)
	o: 44()

nname: 27
n 27(global_start_time)[]:
	i: 18(), 26()
	o: 33(f), 44(t)

nname: 26
n 26(None)[]:
	i: 0(t)
	o: 27()

nname: 18
n 18(None)[return out
]:
	i: 0(f)
	o: 27()

nname: 0
n 0(programs)[out = []
missing_seconds = 0
]:
	i: 
	o: 18(f), 26(t)

nname: 356
n 356(None)[if use_reverse:
	out.reverse()
return out
]:
	i: 142(AL), 145(AF), 302()
	o: 

nname: 302
n 302(None)[if use_reverse:
	start_time = end_time - duration
else:
	end_time = start_time + duration
out.append((start_time, end_time))
]:
	i: 152()
	o: 356()

nname: 152
n 152(None)[for prog in programs:
prog_start_time = max(prog.start_time, global_start_time)
prog_end_time = min(prog.end_time, global_end_time)
prog_duration = prog_end_time - prog_start_time
if use_reverse:
	end_time = prog_end_time - missing_seconds
else:
	start_time = prog_start_time + missing_seconds
if prog_duration < min_duration:
	duration = min_duration
	missing_seconds += min_duration - prog_duration
else:
	duration = max(prog_duration - missing_seconds, min_duration)
	missing_seconds -= prog_duration - duration
]:
	i: 145(for)
	o: 302()

nname: 145
n 145(None)[]:
	i: 142(loop)
	o: 152(for), 356(AF)

nname: 142
n 142(None)[]:
	i: 44()
	o: 145(loop), 356(AL)

nname: 44
n 44(None)[global_start_time = global_start_time
if not global_end_time:
	pass
global_end_time = global_end_time
midpoint = max(programs[len(programs) / 2].start_time, global_start_time)
use_reverse = midpoint > (global_start_time + global_end_time) / 2
if use_reverse:
	programs = reversed(programs)
]:
	i: 0(t)
	o: 142()

nname: 0
n 0(None)[out = []
missing_seconds = 0
if not programs:
	return out
if not global_start_time:
	pass
]:
	i: 
	o: 44()

nname: 356
n 356(None)[if use_reverse:
	out.reverse()
return out
]:
	i: 142(AL), 145(AF), 152()
	o: 

nname: 152
n 152(None)[for prog in programs:
prog_start_time = max(prog.start_time, global_start_time)
prog_end_time = min(prog.end_time, global_end_time)
prog_duration = prog_end_time - prog_start_time
if use_reverse:
	end_time = prog_end_time - missing_seconds
else:
	start_time = prog_start_time + missing_seconds
if prog_duration < min_duration:
	duration = min_duration
	missing_seconds += min_duration - prog_duration
else:
	duration = max(prog_duration - missing_seconds, min_duration)
	missing_seconds -= prog_duration - duration
if use_reverse:
	start_time = end_time - duration
else:
	end_time = start_time + duration
out.append((start_time, end_time))
]:
	i: 145(for)
	o: 356()

nname: 145
n 145(None)[]:
	i: 142(loop)
	o: 152(for), 356(AF)

nname: 142
n 142(None)[]:
	i: 0()
	o: 145(loop), 356(AL)

nname: 0
n 0(None)[out = []
missing_seconds = 0
if not programs:
	return out
if not global_start_time:
	pass
global_start_time = global_start_time
if not global_end_time:
	pass
global_end_time = global_end_time
midpoint = max(programs[len(programs) / 2].start_time, global_start_time)
use_reverse = midpoint > (global_start_time + global_end_time) / 2
if use_reverse:
	programs = reversed(programs)
]:
	i: 
	o: 142()

nname: 356
n 356(None)[if use_reverse:
	out.reverse()
return out
]:
	i: 145()
	o: 

nname: 145
n 145(None)[for prog in programs:
	prog_start_time = max(prog.start_time, global_start_time)
	prog_end_time = min(prog.end_time, global_end_time)
	prog_duration = prog_end_time - prog_start_time
	if use_reverse:
		end_time = prog_end_time - missing_seconds
	else:
		start_time = prog_start_time + missing_seconds
	if prog_duration < min_duration:
		duration = min_duration
		missing_seconds += min_duration - prog_duration
	else:
		duration = max(prog_duration - missing_seconds, min_duration)
		missing_seconds -= prog_duration - duration
	if use_reverse:
		start_time = end_time - duration
	else:
		end_time = start_time + duration
	out.append((start_time, end_time))
]:
	i: 0(loop)
	o: 356()

nname: 0
n 0(None)[out = []
missing_seconds = 0
if not programs:
	return out
if not global_start_time:
	pass
global_start_time = global_start_time
if not global_end_time:
	pass
global_end_time = global_end_time
midpoint = max(programs[len(programs) / 2].start_time, global_start_time)
use_reverse = midpoint > (global_start_time + global_end_time) / 2
if use_reverse:
	programs = reversed(programs)
]:
	i: 
	o: 145(loop)

nname: 356
n 356(None)[if use_reverse:
	out.reverse()
return out
]:
	i: 0()
	o: 

nname: 0
n 0(None)[out = []
missing_seconds = 0
if not programs:
	return out
if not global_start_time:
	pass
global_start_time = global_start_time
if not global_end_time:
	pass
global_end_time = global_end_time
midpoint = max(programs[len(programs) / 2].start_time, global_start_time)
use_reverse = midpoint > (global_start_time + global_end_time) / 2
if use_reverse:
	programs = reversed(programs)
for prog in programs:
	prog_start_time = max(prog.start_time, global_start_time)
	prog_end_time = min(prog.end_time, global_end_time)
	prog_duration = prog_end_time - prog_start_time
	if use_reverse:
		end_time = prog_end_time - missing_seconds
	else:
		start_time = prog_start_time + missing_seconds
	if prog_duration < min_duration:
		duration = min_duration
		missing_seconds += min_duration - prog_duration
	else:
		duration = max(prog_duration - missing_seconds, min_duration)
		missing_seconds -= prog_duration - duration
	if use_reverse:
		start_time = end_time - duration
	else:
		end_time = start_time + duration
	out.append((start_time, end_time))
]:
	i: 
	o: 356()

nname: 0
n 0(None)[out = []
missing_seconds = 0
if not programs:
	return out
if not global_start_time:
	pass
global_start_time = global_start_time
if not global_end_time:
	pass
global_end_time = global_end_time
midpoint = max(programs[len(programs) / 2].start_time, global_start_time)
use_reverse = midpoint > (global_start_time + global_end_time) / 2
if use_reverse:
	programs = reversed(programs)
for prog in programs:
	prog_start_time = max(prog.start_time, global_start_time)
	prog_end_time = min(prog.end_time, global_end_time)
	prog_duration = prog_end_time - prog_start_time
	if use_reverse:
		end_time = prog_end_time - missing_seconds
	else:
		start_time = prog_start_time + missing_seconds
	if prog_duration < min_duration:
		duration = min_duration
		missing_seconds += min_duration - prog_duration
	else:
		duration = max(prog_duration - missing_seconds, min_duration)
		missing_seconds -= prog_duration - duration
	if use_reverse:
		start_time = end_time - duration
	else:
		end_time = start_time + duration
	out.append((start_time, end_time))
if use_reverse:
	out.reverse()
return out
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76a878c>}
nname: 0
n 0(None)[Container.__init__(self, **kwargs)
self.start_time_display = TextBlock()
self.title_display = TextBlock(max_width=style.get('maxlen', None))
self.rec_icon = Image(repository=style['repository'], image_or_file=style['rec_icon'])
self.rec_icon.set_keep_real_size(False)
self.rec_status = False
self.progress_bar = Container()
self.progress_bar_fg = Image(repository=style['repository'], image_or_file=style['progress_bar_foreground'])
self.progress_bar_fg.set_keep_real_size(False)
self.progress_bar_bg = Image(repository=style['repository'], image_or_file=style['progress_bar_background'])
self.progress_bar_bg.set_keep_real_size(False)
self.progress_bar.add_child(self.progress_bar_bg, top='0%', left='0%', height='100%', width='100%', aspect=False)
self.progress_bar.add_child(self.progress_bar_fg, top='0%', left='0%', height='100%', width='100%', aspect=False)
bar_left, bar_top = style['progress_bar_offset']
bar_width, bar_height = style['progress_bar_size']
self.add_child(self.progress_bar, top=bar_top, left=bar_left, height=bar_height, width=bar_width, layer=-1)
self.add_child(self.rec_icon, height='0%', width='0%')
self.add_child(self.start_time_display)
self.add_child(self.title_display)
self.set_style(style)
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76a47ec>}
nname: 0
n 0(None)[self.start_time_display.set_style(style=style['time_font_style'])
self.start_time_display.set_color(color=style['time_color'])
time_left, time_top = style['time_offset']
self.start_time_display.move(top=time_top, left=time_left)
self.title_display.set_style(style=style['title_font_style'])
self.title_display.set_color(color=style['title_color'])
title_left, title_top = style['text_offset']
title_width = '%i%%' % (100 - int(title_left.rstrip('%')))
self.title_display.move(top=title_top, left=title_left)
self.title_display.resize(width=title_width)
rec_icon_left, rec_icon_top = style['rec_icon_offset']
self.rec_icon.move(top=rec_icon_top, left=rec_icon_left)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76a8eac>}
nname: 0
n 0(None)[self.progress_bar_fg.resize(height='%i%%' % n)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb769df6c>}
nname: 114
n 114(None)[self.rec_status = record
]:
	i: 17(), 74(), 113()
	o: 

nname: 113
n 113(None)[]:
	i: 56&66(f)
	o: 114()

nname: 74
n 74(None)[self.rec_icon.set_keep_real_size(False)
self.rec_icon.resize(width='0%')
]:
	i: 56&66(t)
	o: 114()

nname: 56&66
n 56&66(self.rec_status and not record)[]:
	i: 0&6(f)
	o: 74(t), 113(f)

nname: 17
n 17(None)[self.rec_icon.set_keep_real_size(True)
self.rec_icon.resize(width='100%')
]:
	i: 0&6(t)
	o: 114()

nname: 0&6
n 0&6(record and not self.rec_status)[]:
	i: 
	o: 17(t), 56&66(f)

nname: 0&6
n 0&6(None)[if record and not self.rec_status:
	self.rec_icon.set_keep_real_size(True)
	self.rec_icon.resize(width='100%')
else:
	if self.rec_status and not record:
		self.rec_icon.set_keep_real_size(False)
		self.rec_icon.resize(width='0%')
self.rec_status = record
]:
	i: 
	o: 

self.nodes: {'0&6': <unpyclib.structure.node instance at 0xb76a82cc>}
nname: 0
n 0(None)[self.start_time_display.set_text(seconds_to_hhmm(start_time))
self.title_display.set_text(name)
self.set_record(record)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76a842c>}
nname: 6
n 6(None)[__doc__ = 'A widget that displays information about a single TV program:\n        - start time\n        - title\n    '
def __init__(self, style, **kwargs):
	Container.__init__(self, **kwargs)
	self.start_time_display = TextBlock()
	self.title_display = TextBlock(max_width=style.get('maxlen', None))
	self.rec_icon = Image(repository=style['repository'], image_or_file=style['rec_icon'])
	self.rec_icon.set_keep_real_size(False)
	self.rec_status = False
	self.progress_bar = Container()
	self.progress_bar_fg = Image(repository=style['repository'], image_or_file=style['progress_bar_foreground'])
	self.progress_bar_fg.set_keep_real_size(False)
	self.progress_bar_bg = Image(repository=style['repository'], image_or_file=style['progress_bar_background'])
	self.progress_bar_bg.set_keep_real_size(False)
	self.progress_bar.add_child(self.progress_bar_bg, top='0%', left='0%', height='100%', width='100%', aspect=False)
	self.progress_bar.add_child(self.progress_bar_fg, top='0%', left='0%', height='100%', width='100%', aspect=False)
	bar_left, bar_top = style['progress_bar_offset']
	bar_width, bar_height = style['progress_bar_size']
	self.add_child(self.progress_bar, top=bar_top, left=bar_left, height=bar_height, width=bar_width, layer=-1)
	self.add_child(self.rec_icon, height='0%', width='0%')
	self.add_child(self.start_time_display)
	self.add_child(self.title_display)
	self.set_style(style)
	return None

def set_style(self, style):
	self.start_time_display.set_style(style=style['time_font_style'])
	self.start_time_display.set_color(color=style['time_color'])
	time_left, time_top = style['time_offset']
	self.start_time_display.move(top=time_top, left=time_left)
	self.title_display.set_style(style=style['title_font_style'])
	self.title_display.set_color(color=style['title_color'])
	title_left, title_top = style['text_offset']
	title_width = '%i%%' % (100 - int(title_left.rstrip('%')))
	self.title_display.move(top=title_top, left=title_left)
	self.title_display.resize(width=title_width)
	rec_icon_left, rec_icon_top = style['rec_icon_offset']
	self.rec_icon.move(top=rec_icon_top, left=rec_icon_left)

def set_progress(self, n):
	self.progress_bar_fg.resize(height='%i%%' % n)

def set_record(self, record):
	if record and not self.rec_status:
		self.rec_icon.set_keep_real_size(True)
		self.rec_icon.resize(width='100%')
	else:
		if self.rec_status and not record:
			self.rec_icon.set_keep_real_size(False)
			self.rec_icon.resize(width='0%')
	self.rec_status = record

def reset(self, start_time, name, record=False):
	self.start_time_display.set_text(seconds_to_hhmm(start_time))
	self.title_display.set_text(name)
	self.set_record(record)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb769dd2c>}
nname: 0
n 0(None)[return {'repository': self.style['repository'], 'progress_bar_offset': self.style['progress_bar_offset'], 'progress_bar_size': self.style['progress_bar_size'], 'progress_bar_background': self.style['progress_bar_background'], 'progress_bar_foreground': self.style['progress_bar_foreground'], 'time_offset': self.style['time_offset'], 'time_font_style': self.style['time_font_style'], 'time_color': self.style['time_color'], 'title_font_style': self.style['title_font_style'], 'title_color': self.style['title_color'], 'text_offset': self.style['text_offset'], 'rec_icon': self.style['rec_icon'], 'rec_icon_offset': self.style['rec_icon_offset'], 'maxlen': self.style['maxlen']}
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76a4cac>}
nname: 0
n 0(None)[return {'repository': self.style['repository'], 'progress_bar_offset': self.style['progress_bar_offset'], 'progress_bar_size': self.style['progress_bar_size'], 'progress_bar_background': self.style['progress_bar_background'], 'progress_bar_foreground': self.style['progress_bar_foreground'], 'time_offset': self.style['time_offset'], 'time_font_style': self.style['time_font_style'], 'time_color': self.style['time_color'], 'title_font_style': self.style['title_font_style'], 'title_color': self.style['title_color'], 'text_offset': self.style['text_offset'], 'rec_icon': self.style['rec_icon'], 'rec_icon_offset': self.style['rec_icon_offset'], 'maxlen': self.style['maxlen']}
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76a442c>}
nname: 0
n 0(None)[return {'repository': self.style['repository'], 'progress_bar_offset': self.style['progress_bar_offset'], 'progress_bar_size': self.style['progress_bar_size'], 'progress_bar_background': self.style['progress_bar_background'], 'progress_bar_foreground': self.style['progress_bar_foreground'], 'time_offset': self.style['time_offset'], 'time_font_style': self.style['selected_time_font_style'], 'time_color': self.style['selected_time_color'], 'title_font_style': self.style['selected_title_font_style'], 'title_color': self.style['selected_title_color'], 'text_offset': self.style['selected_text_offset'], 'rec_icon': self.style['rec_icon'], 'rec_icon_offset': self.style['rec_icon_offset'], 'maxlen': self.style['maxlen']}
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76a44ac>}
nname: 0
n 0(None)[return {'repository': self.style['repository'], 'progress_bar_offset': self.style['progress_bar_offset'], 'progress_bar_size': self.style['progress_bar_size'], 'progress_bar_background': self.style['progress_bar_background'], 'progress_bar_foreground': self.style['progress_bar_foreground'], 'time_offset': self.style['time_offset'], 'time_font_style': self.style['selected_time_font_style'], 'time_color': self.style['selected_time_color'], 'title_font_style': self.style['selected_title_font_style'], 'title_color': self.style['selected_title_color'], 'text_offset': self.style['selected_text_offset'], 'rec_icon': self.style['rec_icon'], 'rec_icon_offset': self.style['rec_icon_offset'], 'maxlen': self.style['maxlen']}
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76a438c>}
nname: 0
n 0(None)[return {'repository': self.style['repository'], 'time_offset': self.style['time_offset'], 'time_font_style': self.style['selected_time_font_style'], 'time_color': self.style['selected_blurb_time_color'], 'title_font_style': self.style['selected_title_font_style'], 'title_color': self.style['selected_blurb_title_color'], 'text_offset': self.style['selected_blurb_text_offset'], 'rec_icon': self.style['rec_icon'], 'rec_icon_offset': self.style['rec_icon_offset'], 'maxlen': self.style['maxlen']}
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76a4a4c>}
nname: 0
n 0(None)[return {'repository': self.style['repository'], 'time_offset': self.style['time_offset'], 'time_font_style': self.style['selected_time_font_style'], 'time_color': self.style['selected_blurb_time_color'], 'title_font_style': self.style['selected_title_font_style'], 'title_color': self.style['selected_blurb_title_color'], 'text_offset': self.style['selected_blurb_text_offset'], 'rec_icon': self.style['rec_icon'], 'rec_icon_offset': self.style['rec_icon_offset'], 'maxlen': self.style['maxlen']}
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76a4cac>}
nname: 138
n 138(None)[]:
	i: 130(AE)
	o: 

nname: 130
n 130(None)[del _[1]
]:
	i: 80(finally), 100()
	o: 138(AE)

nname: 100
n 100(None)[self.set_programs(progs)
self.set_selected_program(-1)
]:
	i: 80(ASF)
	o: 130()

nname: 80
n 80(None)[render_lock.__enter__()
]:
	i: 27(), 73()
	o: 100(ASF), 130(finally)

nname: 73
n 73(None)[progs = []
]:
	i: 0(f)
	o: 80()

nname: 27
n 27(None)[_[1], progs = render_lock.__exit__, self.channel.browse(start_ts, end_ts, limit=10, pad=True, focus=time())
]:
	i: 0(t)
	o: 80()

nname: 0
n 0(self.channel)[self.start_ts = start_ts
self.end_ts = end_ts
]:
	i: 
	o: 27(t), 73(f)

nname: 138
n 138(None)[]:
	i: 100()
	o: 

nname: 100
n 100(None)[try:
	self.set_programs(progs)
	self.set_selected_program(-1)
finally:
	del _[1]
]:
	i: 0(ASF)
	o: 138()

nname: 0
n 0(None)[self.start_ts = start_ts
self.end_ts = end_ts
if self.channel:
	_[1], progs = render_lock.__exit__, self.channel.browse(start_ts, end_ts, limit=10, pad=True, focus=time())
else:
	progs = []
render_lock.__enter__()
]:
	i: 
	o: 100(ASF)

nname: 138
n 138(None)[]:
	i: 0()
	o: 

nname: 0
n 0(None)[self.start_ts = start_ts
self.end_ts = end_ts
if self.channel:
	_[1], progs = render_lock.__exit__, self.channel.browse(start_ts, end_ts, limit=10, pad=True, focus=time())
else:
	progs = []
render_lock.__enter__()
try:
	self.set_programs(progs)
	self.set_selected_program(-1)
finally:
	del _[1]
]:
	i: 
	o: 138()

nname: 0
n 0(None)[self.start_ts = start_ts
self.end_ts = end_ts
if self.channel:
	_[1], progs = render_lock.__exit__, self.channel.browse(start_ts, end_ts, limit=10, pad=True, focus=time())
else:
	progs = []
render_lock.__enter__()
try:
	self.set_programs(progs)
	self.set_selected_program(-1)
finally:
	del _[1]
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb769bd8c>}
nname: 1171
n 1171(None)[self._selected_widget.set_visible(s_visible)
self._not_selected_widget.set_visible(ns_visible)
self.update_progress(time())
return None
]:
	i: 297(AL), 1170()
	o: 

nname: 1170
n 1170(None)[]:
	i: 333(AF), 962()
	o: 1171()

nname: 962
n 962(None)[selected_blurb = ProgramBlurb(self.selected_style)
selected_blurb.reset(displayed_start_time, name, rec)
not_selected_blurb = ProgramBlurb(self.not_selected_style)
not_selected_blurb.reset(displayed_start_time, name, rec)
self._not_selected_widget.add_child(not_selected_blurb, name=program.id, top='%i%%' % top, left='0%', height='%i%%' % height, width='100%')
self._selected_widget.add_child(selected_blurb, name=program.id, top='%i%%' % top, left='0%', height='%i%%' % height, width='100%')
self.blurbs[program.id] = (selected_blurb, not_selected_blurb)
]:
	i: 686&696(f), 706()
	o: 1170()

nname: 706
n 706(None)[selected_blurb = self.spare_selected_blurbs.pop()
not_selected_blurb = self.spare_not_selected_blurbs.pop()
selected_blurb.reset(displayed_start_time, name, rec)
not_selected_blurb.reset(displayed_start_time, name, rec)
selected_blurb.adopted(self._selected_widget)
selected_blurb.move(top='%i%%' % top, left='0%')
selected_blurb.resize(height='%i%%' % height, width='100%')
selected_blurb.set_visible(s_visible)
not_selected_blurb.adopted(self._not_selected_widget)
not_selected_blurb.move(top='%i%%' % top, left='0%')
not_selected_blurb.resize(height='%i%%' % height, width='100%')
not_selected_blurb.set_visible(ns_visible)
self.blurbs[program.id] = (selected_blurb, not_selected_blurb)
continue
]:
	i: 686&696(t)
	o: 962()

nname: 686&696
n 686&696(self.spare_selected_blurbs and self.spare_not_selected_blurbs)[]:
	i: 434(f), 518()
	o: 706(t), 962(f)

nname: 518
n 518(None)[selected_blurb, not_selected_blurb = self.blurbs[program.id]
selected_blurb.reset(displayed_start_time, name, rec)
selected_blurb.move(duration=0, top='%i%%' % top)
selected_blurb.resize(duration=0, height='%i%%' % height)
not_selected_blurb.reset(displayed_start_time, name, rec)
not_selected_blurb.move(duration=0, top='%i%%' % top)
not_selected_blurb.resize(duration=0, height='%i%%' % height)
continue
]:
	i: 434(t)
	o: 686&696()

nname: 434
n 434(program in old_programs)[end_time = min(end_time, self.end_ts)
top = (start_time - self.start_ts) / total_duration * 100
height = (end_time - start_time) / total_duration * 100
rec = program.recording_status in RECS_TO_DISPLAY
]:
	i: 385(), 415()
	o: 518(t), 686&696(f)

nname: 415
n 415(None)[displayed_start_time = program.start_time
name = program.name
]:
	i: 352(f)
	o: 434()

nname: 385
n 385(None)[displayed_start_time, start_time = self.start_ts, self.start_ts
name = u'\u2026\n%s' % program.name
]:
	i: 352(t)
	o: 434()

nname: 352
n 352(program.start_time < self.start_ts)[for program, start_time in izip(progs, self.adjusted_durations):
]:
	i: 333(for)
	o: 385(t), 415(f)

nname: 333
n 333(None)[]:
	i: 297(loop)
	o: 352(for), 1170(AF)

nname: 297
n 297(None)[self.adjusted_durations = adjust_durations(progs, global_start_time=self.start_ts, global_end_time=self.end_ts)
]:
	i: 114(AL), 296()
	o: 333(loop), 1171(AL)

nname: 296
n 296(None)[]:
	i: 142(AF), 221()
	o: 297()

nname: 221
n 221(None)[selected_blurb.hide()
selected_blurb.orphaned()
self.spare_selected_blurbs.add(selected_blurb)
not_selected_blurb.hide()
not_selected_blurb.orphaned()
self.spare_not_selected_blurbs.add(not_selected_blurb)
]:
	i: 200(), 220()
	o: 296()

nname: 220
n 220(None)[]:
	i: 158(f)
	o: 221()

nname: 200
n 200(None)[selected_blurb.set_style(self.selected_style)
]:
	i: 158(t)
	o: 221()

nname: 158
n 158(program is selected_program_item)[for program in old_programs.difference(progs):
selected_blurb, not_selected_blurb = self.blurbs.pop(program.id)
]:
	i: 142(for)
	o: 200(t), 220(f)

nname: 142
n 142(None)[]:
	i: 114(loop)
	o: 158(for), 296(AF)

nname: 114
n 114(None)[old_programs = set(self.displayed_programs)
self.displayed_programs[:] = progs
]:
	i: 87(), 107()
	o: 142(loop), 297(AL)

nname: 107
n 107(None)[selected_program_item = None
]:
	i: 84(f)
	o: 114()

nname: 87
n 87(None)[selected_program_item = self.displayed_programs[self.selected_program]
]:
	i: 84(t)
	o: 114()

nname: 84
n 84(0 <= self.selected_program)[]:
	i: 63(), 82()
	o: 87(t), 107(f)

nname: 82
n 82(None)[self.selected_program
]:
	i: 0(f)
	o: 84()

nname: 63
n 63(None)[]:
	i: 0(t)
	o: 84()

nname: 0
n 0(0 <= self.selected_program)[ns_visible = self._not_selected_widget.get_visible()
s_visible = self._selected_widget.get_visible()
total_duration = self.end_ts - self.start_ts
]:
	i: 
	o: 63(t), 82(f)

nname: 1171
n 1171(None)[self._selected_widget.set_visible(s_visible)
self._not_selected_widget.set_visible(ns_visible)
self.update_progress(time())
return None
]:
	i: 297(AL), 333(AF), 686&696()
	o: 

nname: 686&696
n 686&696(None)[if self.spare_selected_blurbs and self.spare_not_selected_blurbs:
	selected_blurb = self.spare_selected_blurbs.pop()
	not_selected_blurb = self.spare_not_selected_blurbs.pop()
	selected_blurb.reset(displayed_start_time, name, rec)
	not_selected_blurb.reset(displayed_start_time, name, rec)
	selected_blurb.adopted(self._selected_widget)
	selected_blurb.move(top='%i%%' % top, left='0%')
	selected_blurb.resize(height='%i%%' % height, width='100%')
	selected_blurb.set_visible(s_visible)
	not_selected_blurb.adopted(self._not_selected_widget)
	not_selected_blurb.move(top='%i%%' % top, left='0%')
	not_selected_blurb.resize(height='%i%%' % height, width='100%')
	not_selected_blurb.set_visible(ns_visible)
	self.blurbs[program.id] = (selected_blurb, not_selected_blurb)
	continue
selected_blurb = ProgramBlurb(self.selected_style)
selected_blurb.reset(displayed_start_time, name, rec)
not_selected_blurb = ProgramBlurb(self.not_selected_style)
not_selected_blurb.reset(displayed_start_time, name, rec)
self._not_selected_widget.add_child(not_selected_blurb, name=program.id, top='%i%%' % top, left='0%', height='%i%%' % height, width='100%')
self._selected_widget.add_child(selected_blurb, name=program.id, top='%i%%' % top, left='0%', height='%i%%' % height, width='100%')
self.blurbs[program.id] = (selected_blurb, not_selected_blurb)
]:
	i: 352(f)
	o: 1171()

nname: 352
n 352(None)[for program, start_time in izip(progs, self.adjusted_durations):
if program.start_time < self.start_ts:
	displayed_start_time, start_time = self.start_ts, self.start_ts
	name = u'\u2026\n%s' % program.name
else:
	displayed_start_time = program.start_time
	name = program.name
end_time = min(end_time, self.end_ts)
top = (start_time - self.start_ts) / total_duration * 100
height = (end_time - start_time) / total_duration * 100
rec = program.recording_status in RECS_TO_DISPLAY
if program in old_programs:
	selected_blurb, not_selected_blurb = self.blurbs[program.id]
	selected_blurb.reset(displayed_start_time, name, rec)
	selected_blurb.move(duration=0, top='%i%%' % top)
	selected_blurb.resize(duration=0, height='%i%%' % height)
	not_selected_blurb.reset(displayed_start_time, name, rec)
	not_selected_blurb.move(duration=0, top='%i%%' % top)
	not_selected_blurb.resize(duration=0, height='%i%%' % height)
	continue
]:
	i: 333(for)
	o: 686&696()

nname: 333
n 333(None)[]:
	i: 297(loop)
	o: 352(for), 1171(AF)

nname: 297
n 297(None)[self.adjusted_durations = adjust_durations(progs, global_start_time=self.start_ts, global_end_time=self.end_ts)
]:
	i: 114(AL), 142(AF), 158()
	o: 333(loop), 1171(AL)

nname: 158
n 158(None)[for program in old_programs.difference(progs):
selected_blurb, not_selected_blurb = self.blurbs.pop(program.id)
if program is selected_program_item:
	selected_blurb.set_style(self.selected_style)
selected_blurb.hide()
selected_blurb.orphaned()
self.spare_selected_blurbs.add(selected_blurb)
not_selected_blurb.hide()
not_selected_blurb.orphaned()
self.spare_not_selected_blurbs.add(not_selected_blurb)
]:
	i: 142(for)
	o: 297()

nname: 142
n 142(None)[]:
	i: 114(loop)
	o: 158(for), 297(AF)

nname: 114
n 114(None)[old_programs = set(self.displayed_programs)
self.displayed_programs[:] = progs
]:
	i: 0()
	o: 142(loop), 297(AL)

nname: 0
n 0(None)[ns_visible = self._not_selected_widget.get_visible()
s_visible = self._selected_widget.get_visible()
total_duration = self.end_ts - self.start_ts
if 0 <= self.selected_program:
	pass
else:
	self.selected_program
if 0 <= self.selected_program:
	selected_program_item = self.displayed_programs[self.selected_program]
else:
	selected_program_item = None
]:
	i: 
	o: 114()

nname: 1171
n 1171(None)[self._selected_widget.set_visible(s_visible)
self._not_selected_widget.set_visible(ns_visible)
self.update_progress(time())
return None
]:
	i: 297(AL), 333(AF), 352()
	o: 

nname: 352
n 352(None)[for program, start_time in izip(progs, self.adjusted_durations):
if program.start_time < self.start_ts:
	displayed_start_time, start_time = self.start_ts, self.start_ts
	name = u'\u2026\n%s' % program.name
else:
	displayed_start_time = program.start_time
	name = program.name
end_time = min(end_time, self.end_ts)
top = (start_time - self.start_ts) / total_duration * 100
height = (end_time - start_time) / total_duration * 100
rec = program.recording_status in RECS_TO_DISPLAY
if program in old_programs:
	selected_blurb, not_selected_blurb = self.blurbs[program.id]
	selected_blurb.reset(displayed_start_time, name, rec)
	selected_blurb.move(duration=0, top='%i%%' % top)
	selected_blurb.resize(duration=0, height='%i%%' % height)
	not_selected_blurb.reset(displayed_start_time, name, rec)
	not_selected_blurb.move(duration=0, top='%i%%' % top)
	not_selected_blurb.resize(duration=0, height='%i%%' % height)
	continue
if self.spare_selected_blurbs and self.spare_not_selected_blurbs:
	selected_blurb = self.spare_selected_blurbs.pop()
	not_selected_blurb = self.spare_not_selected_blurbs.pop()
	selected_blurb.reset(displayed_start_time, name, rec)
	not_selected_blurb.reset(displayed_start_time, name, rec)
	selected_blurb.adopted(self._selected_widget)
	selected_blurb.move(top='%i%%' % top, left='0%')
	selected_blurb.resize(height='%i%%' % height, width='100%')
	selected_blurb.set_visible(s_visible)
	not_selected_blurb.adopted(self._not_selected_widget)
	not_selected_blurb.move(top='%i%%' % top, left='0%')
	not_selected_blurb.resize(height='%i%%' % height, width='100%')
	not_selected_blurb.set_visible(ns_visible)
	self.blurbs[program.id] = (selected_blurb, not_selected_blurb)
	continue
selected_blurb = ProgramBlurb(self.selected_style)
selected_blurb.reset(displayed_start_time, name, rec)
not_selected_blurb = ProgramBlurb(self.not_selected_style)
not_selected_blurb.reset(displayed_start_time, name, rec)
self._not_selected_widget.add_child(not_selected_blurb, name=program.id, top='%i%%' % top, left='0%', height='%i%%' % height, width='100%')
self._selected_widget.add_child(selected_blurb, name=program.id, top='%i%%' % top, left='0%', height='%i%%' % height, width='100%')
self.blurbs[program.id] = (selected_blurb, not_selected_blurb)
]:
	i: 333(for)
	o: 1171()

nname: 333
n 333(None)[]:
	i: 297(loop)
	o: 352(for), 1171(AF)

nname: 297
n 297(None)[self.adjusted_durations = adjust_durations(progs, global_start_time=self.start_ts, global_end_time=self.end_ts)
]:
	i: 142()
	o: 333(loop), 1171(AL)

nname: 142
n 142(None)[for program in old_programs.difference(progs):
	selected_blurb, not_selected_blurb = self.blurbs.pop(program.id)
	if program is selected_program_item:
		selected_blurb.set_style(self.selected_style)
	selected_blurb.hide()
	selected_blurb.orphaned()
	self.spare_selected_blurbs.add(selected_blurb)
	not_selected_blurb.hide()
	not_selected_blurb.orphaned()
	self.spare_not_selected_blurbs.add(not_selected_blurb)
]:
	i: 0(loop)
	o: 297()

nname: 0
n 0(None)[ns_visible = self._not_selected_widget.get_visible()
s_visible = self._selected_widget.get_visible()
total_duration = self.end_ts - self.start_ts
if 0 <= self.selected_program:
	pass
else:
	self.selected_program
if 0 <= self.selected_program:
	selected_program_item = self.displayed_programs[self.selected_program]
else:
	selected_program_item = None
old_programs = set(self.displayed_programs)
self.displayed_programs[:] = progs
]:
	i: 
	o: 142(loop)

nname: 352
n 352(None)[for program, start_time in izip(progs, self.adjusted_durations):
	if program.start_time < self.start_ts:
		displayed_start_time, start_time = self.start_ts, self.start_ts
		name = u'\u2026\n%s' % program.name
	else:
		displayed_start_time = program.start_time
		name = program.name
	end_time = min(end_time, self.end_ts)
	top = (start_time - self.start_ts) / total_duration * 100
	height = (end_time - start_time) / total_duration * 100
	rec = program.recording_status in RECS_TO_DISPLAY
	if program in old_programs:
		selected_blurb, not_selected_blurb = self.blurbs[program.id]
		selected_blurb.reset(displayed_start_time, name, rec)
		selected_blurb.move(duration=0, top='%i%%' % top)
		selected_blurb.resize(duration=0, height='%i%%' % height)
		not_selected_blurb.reset(displayed_start_time, name, rec)
		not_selected_blurb.move(duration=0, top='%i%%' % top)
		not_selected_blurb.resize(duration=0, height='%i%%' % height)
		continue
	if self.spare_selected_blurbs and self.spare_not_selected_blurbs:
		selected_blurb = self.spare_selected_blurbs.pop()
		not_selected_blurb = self.spare_not_selected_blurbs.pop()
		selected_blurb.reset(displayed_start_time, name, rec)
		not_selected_blurb.reset(displayed_start_time, name, rec)
		selected_blurb.adopted(self._selected_widget)
		selected_blurb.move(top='%i%%' % top, left='0%')
		selected_blurb.resize(height='%i%%' % height, width='100%')
		selected_blurb.set_visible(s_visible)
		not_selected_blurb.adopted(self._not_selected_widget)
		not_selected_blurb.move(top='%i%%' % top, left='0%')
		not_selected_blurb.resize(height='%i%%' % height, width='100%')
		not_selected_blurb.set_visible(ns_visible)
		self.blurbs[program.id] = (selected_blurb, not_selected_blurb)
		continue
	selected_blurb = ProgramBlurb(self.selected_style)
	selected_blurb.reset(displayed_start_time, name, rec)
	not_selected_blurb = ProgramBlurb(self.not_selected_style)
	not_selected_blurb.reset(displayed_start_time, name, rec)
	self._not_selected_widget.add_child(not_selected_blurb, name=program.id, top='%i%%' % top, left='0%', height='%i%%' % height, width='100%')
	self._selected_widget.add_child(selected_blurb, name=program.id, top='%i%%' % top, left='0%', height='%i%%' % height, width='100%')
	self.blurbs[program.id] = (selected_blurb, not_selected_blurb)
self._selected_widget.set_visible(s_visible)
self._not_selected_widget.set_visible(ns_visible)
self.update_progress(time())
return None
]:
	i: 297(for)
	o: 

nname: 297
n 297(None)[self.adjusted_durations = adjust_durations(progs, global_start_time=self.start_ts, global_end_time=self.end_ts)
]:
	i: 0()
	o: 352(for)

nname: 0
n 0(None)[ns_visible = self._not_selected_widget.get_visible()
s_visible = self._selected_widget.get_visible()
total_duration = self.end_ts - self.start_ts
if 0 <= self.selected_program:
	pass
else:
	self.selected_program
if 0 <= self.selected_program:
	selected_program_item = self.displayed_programs[self.selected_program]
else:
	selected_program_item = None
old_programs = set(self.displayed_programs)
self.displayed_programs[:] = progs
for program in old_programs.difference(progs):
	selected_blurb, not_selected_blurb = self.blurbs.pop(program.id)
	if program is selected_program_item:
		selected_blurb.set_style(self.selected_style)
	selected_blurb.hide()
	selected_blurb.orphaned()
	self.spare_selected_blurbs.add(selected_blurb)
	not_selected_blurb.hide()
	not_selected_blurb.orphaned()
	self.spare_not_selected_blurbs.add(not_selected_blurb)
]:
	i: 
	o: 297()

nname: 352
n 352(None)[for program, start_time in izip(progs, self.adjusted_durations):
	if program.start_time < self.start_ts:
		displayed_start_time, start_time = self.start_ts, self.start_ts
		name = u'\u2026\n%s' % program.name
	else:
		displayed_start_time = program.start_time
		name = program.name
	end_time = min(end_time, self.end_ts)
	top = (start_time - self.start_ts) / total_duration * 100
	height = (end_time - start_time) / total_duration * 100
	rec = program.recording_status in RECS_TO_DISPLAY
	if program in old_programs:
		selected_blurb, not_selected_blurb = self.blurbs[program.id]
		selected_blurb.reset(displayed_start_time, name, rec)
		selected_blurb.move(duration=0, top='%i%%' % top)
		selected_blurb.resize(duration=0, height='%i%%' % height)
		not_selected_blurb.reset(displayed_start_time, name, rec)
		not_selected_blurb.move(duration=0, top='%i%%' % top)
		not_selected_blurb.resize(duration=0, height='%i%%' % height)
		continue
	if self.spare_selected_blurbs and self.spare_not_selected_blurbs:
		selected_blurb = self.spare_selected_blurbs.pop()
		not_selected_blurb = self.spare_not_selected_blurbs.pop()
		selected_blurb.reset(displayed_start_time, name, rec)
		not_selected_blurb.reset(displayed_start_time, name, rec)
		selected_blurb.adopted(self._selected_widget)
		selected_blurb.move(top='%i%%' % top, left='0%')
		selected_blurb.resize(height='%i%%' % height, width='100%')
		selected_blurb.set_visible(s_visible)
		not_selected_blurb.adopted(self._not_selected_widget)
		not_selected_blurb.move(top='%i%%' % top, left='0%')
		not_selected_blurb.resize(height='%i%%' % height, width='100%')
		not_selected_blurb.set_visible(ns_visible)
		self.blurbs[program.id] = (selected_blurb, not_selected_blurb)
		continue
	selected_blurb = ProgramBlurb(self.selected_style)
	selected_blurb.reset(displayed_start_time, name, rec)
	not_selected_blurb = ProgramBlurb(self.not_selected_style)
	not_selected_blurb.reset(displayed_start_time, name, rec)
	self._not_selected_widget.add_child(not_selected_blurb, name=program.id, top='%i%%' % top, left='0%', height='%i%%' % height, width='100%')
	self._selected_widget.add_child(selected_blurb, name=program.id, top='%i%%' % top, left='0%', height='%i%%' % height, width='100%')
	self.blurbs[program.id] = (selected_blurb, not_selected_blurb)
self._selected_widget.set_visible(s_visible)
self._not_selected_widget.set_visible(ns_visible)
self.update_progress(time())
return None
]:
	i: 0(for)
	o: 

nname: 0
n 0(None)[ns_visible = self._not_selected_widget.get_visible()
s_visible = self._selected_widget.get_visible()
total_duration = self.end_ts - self.start_ts
if 0 <= self.selected_program:
	pass
else:
	self.selected_program
if 0 <= self.selected_program:
	selected_program_item = self.displayed_programs[self.selected_program]
else:
	selected_program_item = None
old_programs = set(self.displayed_programs)
self.displayed_programs[:] = progs
for program in old_programs.difference(progs):
	selected_blurb, not_selected_blurb = self.blurbs.pop(program.id)
	if program is selected_program_item:
		selected_blurb.set_style(self.selected_style)
	selected_blurb.hide()
	selected_blurb.orphaned()
	self.spare_selected_blurbs.add(selected_blurb)
	not_selected_blurb.hide()
	not_selected_blurb.orphaned()
	self.spare_not_selected_blurbs.add(not_selected_blurb)
self.adjusted_durations = adjust_durations(progs, global_start_time=self.start_ts, global_end_time=self.end_ts)
]:
	i: 
	o: 352(for)

nname: 0
n 0(None)[ns_visible = self._not_selected_widget.get_visible()
s_visible = self._selected_widget.get_visible()
total_duration = self.end_ts - self.start_ts
if 0 <= self.selected_program:
	pass
else:
	self.selected_program
if 0 <= self.selected_program:
	selected_program_item = self.displayed_programs[self.selected_program]
else:
	selected_program_item = None
old_programs = set(self.displayed_programs)
self.displayed_programs[:] = progs
for program in old_programs.difference(progs):
	selected_blurb, not_selected_blurb = self.blurbs.pop(program.id)
	if program is selected_program_item:
		selected_blurb.set_style(self.selected_style)
	selected_blurb.hide()
	selected_blurb.orphaned()
	self.spare_selected_blurbs.add(selected_blurb)
	not_selected_blurb.hide()
	not_selected_blurb.orphaned()
	self.spare_not_selected_blurbs.add(not_selected_blurb)
self.adjusted_durations = adjust_durations(progs, global_start_time=self.start_ts, global_end_time=self.end_ts)
for program, start_time in izip(progs, self.adjusted_durations):
	if program.start_time < self.start_ts:
		displayed_start_time, start_time = self.start_ts, self.start_ts
		name = u'\u2026\n%s' % program.name
	else:
		displayed_start_time = program.start_time
		name = program.name
	end_time = min(end_time, self.end_ts)
	top = (start_time - self.start_ts) / total_duration * 100
	height = (end_time - start_time) / total_duration * 100
	rec = program.recording_status in RECS_TO_DISPLAY
	if program in old_programs:
		selected_blurb, not_selected_blurb = self.blurbs[program.id]
		selected_blurb.reset(displayed_start_time, name, rec)
		selected_blurb.move(duration=0, top='%i%%' % top)
		selected_blurb.resize(duration=0, height='%i%%' % height)
		not_selected_blurb.reset(displayed_start_time, name, rec)
		not_selected_blurb.move(duration=0, top='%i%%' % top)
		not_selected_blurb.resize(duration=0, height='%i%%' % height)
		continue
	if self.spare_selected_blurbs and self.spare_not_selected_blurbs:
		selected_blurb = self.spare_selected_blurbs.pop()
		not_selected_blurb = self.spare_not_selected_blurbs.pop()
		selected_blurb.reset(displayed_start_time, name, rec)
		not_selected_blurb.reset(displayed_start_time, name, rec)
		selected_blurb.adopted(self._selected_widget)
		selected_blurb.move(top='%i%%' % top, left='0%')
		selected_blurb.resize(height='%i%%' % height, width='100%')
		selected_blurb.set_visible(s_visible)
		not_selected_blurb.adopted(self._not_selected_widget)
		not_selected_blurb.move(top='%i%%' % top, left='0%')
		not_selected_blurb.resize(height='%i%%' % height, width='100%')
		not_selected_blurb.set_visible(ns_visible)
		self.blurbs[program.id] = (selected_blurb, not_selected_blurb)
		continue
	selected_blurb = ProgramBlurb(self.selected_style)
	selected_blurb.reset(displayed_start_time, name, rec)
	not_selected_blurb = ProgramBlurb(self.not_selected_style)
	not_selected_blurb.reset(displayed_start_time, name, rec)
	self._not_selected_widget.add_child(not_selected_blurb, name=program.id, top='%i%%' % top, left='0%', height='%i%%' % height, width='100%')
	self._selected_widget.add_child(selected_blurb, name=program.id, top='%i%%' % top, left='0%', height='%i%%' % height, width='100%')
	self.blurbs[program.id] = (selected_blurb, not_selected_blurb)
self._selected_widget.set_visible(s_visible)
self._not_selected_widget.set_visible(ns_visible)
self.update_progress(time())
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb769bc8c>}
nname: 684
n 684(None)[self.selected_program = value
]:
	i: 328(), 667()
	o: 

nname: 667
n 667(None)[self.selection_cursor.set_visible(False)
]:
	i: 325(f)
	o: 684()

nname: 328
n 328(None)[new_program = self.displayed_programs[value]
new_widget, _ = self.blurbs[new_program.id]
start_time, end_time = self.adjusted_durations[value]
start_time = max(self.start_ts, start_time)
end_time = min(end_time, self.end_ts)
left_offset, top_offset = <genexpr>(self.style['selected_blurb_offset'])
top = (start_time - self.start_ts) / total_duration * 100 + top_offset
left = left_offset
new_widget.set_style(self.selected_program_style)
new_widget.move(duration=animation_duration, top='%i%%' % top, left='%i%%' % left)
new_widget.resize(duration=animation_duration, width=self.style['selected_blurb_zoom'])
width, height = new_widget.get_size()
self.selection_cursor.move(duration=animation_duration, top='%i%%' % top, left='%i%%' % left)
self.selection_cursor.resize(duration=animation_duration, width=width, height=height)
self.selection_cursor.set_visible(True)
]:
	i: 325(t)
	o: 684()

nname: 325
n 325(0 <= value)[]:
	i: 304(), 323()
	o: 328(t), 667(f)

nname: 323
n 323(None)[value
]:
	i: 290(f)
	o: 325()

nname: 304
n 304(None)[]:
	i: 290(t)
	o: 325()

nname: 290
n 290(0 <= value)[]:
	i: 88(), 289()
	o: 304(t), 323(f)

nname: 289
n 289(None)[]:
	i: 85(f)
	o: 290()

nname: 88
n 88(None)[current_program = self.displayed_programs[self.selected_program]
current_widget, _ = self.blurbs[current_program.id]
start_time, end_time = self.adjusted_durations[self.selected_program]
start_time = max(self.start_ts, start_time)
end_time = min(end_time, self.end_ts)
top = (start_time - self.start_ts) / total_duration * 100
left = 0
current_widget.set_style(self.selected_style)
current_widget.move(duration=animation_duration, top='%i%%' % top, left='%i%%' % left)
current_widget.resize(duration=animation_duration, width='100%')
]:
	i: 85(t)
	o: 290()

nname: 85
n 85(0 <= self.selected_program)[]:
	i: 64(), 83()
	o: 88(t), 289(f)

nname: 83
n 83(None)[self.selected_program
]:
	i: 18(f)
	o: 85()

nname: 64
n 64(None)[]:
	i: 18(t)
	o: 85()

nname: 18
n 18(0 <= self.selected_program)[total_duration = self.end_ts - self.start_ts
animation_duration = self.style['duration']
]:
	i: 9(), 17()
	o: 64(t), 83(f)

nname: 17
n 17(None)[]:
	i: 0(t)
	o: 18()

nname: 9
n 9(None)[]:
	i: 0(f)
	o: 18()

nname: 0
n 0(self.displayed_programs)[]:
	i: 
	o: 9(f), 17(t)

nname: 325
n 325(None)[if 0 <= value:
	new_program = self.displayed_programs[value]
	new_widget, _ = self.blurbs[new_program.id]
	start_time, end_time = self.adjusted_durations[value]
	start_time = max(self.start_ts, start_time)
	end_time = min(end_time, self.end_ts)
	left_offset, top_offset = <genexpr>(self.style['selected_blurb_offset'])
	top = (start_time - self.start_ts) / total_duration * 100 + top_offset
	left = left_offset
	new_widget.set_style(self.selected_program_style)
	new_widget.move(duration=animation_duration, top='%i%%' % top, left='%i%%' % left)
	new_widget.resize(duration=animation_duration, width=self.style['selected_blurb_zoom'])
	width, height = new_widget.get_size()
	self.selection_cursor.move(duration=animation_duration, top='%i%%' % top, left='%i%%' % left)
	self.selection_cursor.resize(duration=animation_duration, width=width, height=height)
	self.selection_cursor.set_visible(True)
else:
	self.selection_cursor.set_visible(False)
self.selected_program = value
]:
	i: 85()
	o: 

nname: 85
n 85(None)[if 0 <= self.selected_program:
	current_program = self.displayed_programs[self.selected_program]
	current_widget, _ = self.blurbs[current_program.id]
	start_time, end_time = self.adjusted_durations[self.selected_program]
	start_time = max(self.start_ts, start_time)
	end_time = min(end_time, self.end_ts)
	top = (start_time - self.start_ts) / total_duration * 100
	left = 0
	current_widget.set_style(self.selected_style)
	current_widget.move(duration=animation_duration, top='%i%%' % top, left='%i%%' % left)
	current_widget.resize(duration=animation_duration, width='100%')
if 0 <= value:
	pass
else:
	value
]:
	i: 0()
	o: 325()

nname: 0
n 0(None)[if not self.displayed_programs:
	pass
total_duration = self.end_ts - self.start_ts
animation_duration = self.style['duration']
if 0 <= self.selected_program:
	pass
else:
	self.selected_program
]:
	i: 
	o: 85()

nname: 325
n 325(None)[if 0 <= value:
	new_program = self.displayed_programs[value]
	new_widget, _ = self.blurbs[new_program.id]
	start_time, end_time = self.adjusted_durations[value]
	start_time = max(self.start_ts, start_time)
	end_time = min(end_time, self.end_ts)
	left_offset, top_offset = <genexpr>(self.style['selected_blurb_offset'])
	top = (start_time - self.start_ts) / total_duration * 100 + top_offset
	left = left_offset
	new_widget.set_style(self.selected_program_style)
	new_widget.move(duration=animation_duration, top='%i%%' % top, left='%i%%' % left)
	new_widget.resize(duration=animation_duration, width=self.style['selected_blurb_zoom'])
	width, height = new_widget.get_size()
	self.selection_cursor.move(duration=animation_duration, top='%i%%' % top, left='%i%%' % left)
	self.selection_cursor.resize(duration=animation_duration, width=width, height=height)
	self.selection_cursor.set_visible(True)
else:
	self.selection_cursor.set_visible(False)
self.selected_program = value
]:
	i: 0()
	o: 

nname: 0
n 0(None)[if not self.displayed_programs:
	pass
total_duration = self.end_ts - self.start_ts
animation_duration = self.style['duration']
if 0 <= self.selected_program:
	pass
else:
	self.selected_program
if 0 <= self.selected_program:
	current_program = self.displayed_programs[self.selected_program]
	current_widget, _ = self.blurbs[current_program.id]
	start_time, end_time = self.adjusted_durations[self.selected_program]
	start_time = max(self.start_ts, start_time)
	end_time = min(end_time, self.end_ts)
	top = (start_time - self.start_ts) / total_duration * 100
	left = 0
	current_widget.set_style(self.selected_style)
	current_widget.move(duration=animation_duration, top='%i%%' % top, left='%i%%' % left)
	current_widget.resize(duration=animation_duration, width='100%')
if 0 <= value:
	pass
else:
	value
]:
	i: 
	o: 325()

nname: 0
n 0(None)[if not self.displayed_programs:
	pass
total_duration = self.end_ts - self.start_ts
animation_duration = self.style['duration']
if 0 <= self.selected_program:
	pass
else:
	self.selected_program
if 0 <= self.selected_program:
	current_program = self.displayed_programs[self.selected_program]
	current_widget, _ = self.blurbs[current_program.id]
	start_time, end_time = self.adjusted_durations[self.selected_program]
	start_time = max(self.start_ts, start_time)
	end_time = min(end_time, self.end_ts)
	top = (start_time - self.start_ts) / total_duration * 100
	left = 0
	current_widget.set_style(self.selected_style)
	current_widget.move(duration=animation_duration, top='%i%%' % top, left='%i%%' % left)
	current_widget.resize(duration=animation_duration, width='100%')
if 0 <= value:
	pass
else:
	value
if 0 <= value:
	new_program = self.displayed_programs[value]
	new_widget, _ = self.blurbs[new_program.id]
	start_time, end_time = self.adjusted_durations[value]
	start_time = max(self.start_ts, start_time)
	end_time = min(end_time, self.end_ts)
	left_offset, top_offset = <genexpr>(self.style['selected_blurb_offset'])
	top = (start_time - self.start_ts) / total_duration * 100 + top_offset
	left = left_offset
	new_widget.set_style(self.selected_program_style)
	new_widget.move(duration=animation_duration, top='%i%%' % top, left='%i%%' % left)
	new_widget.resize(duration=animation_duration, width=self.style['selected_blurb_zoom'])
	width, height = new_widget.get_size()
	self.selection_cursor.move(duration=animation_duration, top='%i%%' % top, left='%i%%' % left)
	self.selection_cursor.resize(duration=animation_duration, width=width, height=height)
	self.selection_cursor.set_visible(True)
else:
	self.selection_cursor.set_visible(False)
self.selected_program = value
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76bfc2c>}
nname: 197
n 197(None)[]:
	i: 0(AL), 196()
	o: 

nname: 196
n 196(None)[]:
	i: 3(AF), 167()
	o: 197()

nname: 167
n 167(None)[selected_blurb.set_progress(progress)
not_selected_blurb.set_progress(progress)
]:
	i: 93(), 116(), 126()
	o: 196()

nname: 126
n 126(None)[duration = end_ts - start_ts
elapsed = value - start_ts
progress = float(elapsed) / duration * 100
]:
	i: 103(f)
	o: 167()

nname: 116
n 116(None)[progress = 100
]:
	i: 103(t)
	o: 167()

nname: 103
n 103(value > end_ts)[]:
	i: 13(f)
	o: 116(t), 126(f)

nname: 93
n 93(None)[progress = 0
]:
	i: 13(t)
	o: 167()

nname: 13
n 13(value < start_ts)[for prog in self.displayed_programs:
selected_blurb, not_selected_blurb = self.blurbs[prog.id]
start_ts, end_ts = max(prog.start_time, self.start_ts), min(prog.end_time, self.end_ts)
]:
	i: 3(for)
	o: 93(t), 103(f)

nname: 3
n 3(None)[]:
	i: 0(loop)
	o: 13(for), 196(AF)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 197(AL)

nname: 197
n 197(None)[]:
	i: 0(AL), 3(AF), 13()
	o: 

nname: 13
n 13(None)[for prog in self.displayed_programs:
selected_blurb, not_selected_blurb = self.blurbs[prog.id]
start_ts, end_ts = max(prog.start_time, self.start_ts), min(prog.end_time, self.end_ts)
if value < start_ts:
	progress = 0
else:
	if value > end_ts:
		progress = 100
	else:
		duration = end_ts - start_ts
		elapsed = value - start_ts
		progress = float(elapsed) / duration * 100
selected_blurb.set_progress(progress)
not_selected_blurb.set_progress(progress)
]:
	i: 3(for)
	o: 197()

nname: 3
n 3(None)[]:
	i: 0(loop)
	o: 13(for), 197(AF)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 197(AL)

nname: 13
n 13(None)[for prog in self.displayed_programs:
	selected_blurb, not_selected_blurb = self.blurbs[prog.id]
	start_ts, end_ts = max(prog.start_time, self.start_ts), min(prog.end_time, self.end_ts)
	if value < start_ts:
		progress = 0
	else:
		if value > end_ts:
			progress = 100
		else:
			duration = end_ts - start_ts
			elapsed = value - start_ts
			progress = float(elapsed) / duration * 100
	selected_blurb.set_progress(progress)
	not_selected_blurb.set_progress(progress)
]:
	i: 0(for)
	o: 

nname: 0
n 0(None)[]:
	i: 
	o: 13(for)

nname: 0
n 0(None)[for prog in self.displayed_programs:
	selected_blurb, not_selected_blurb = self.blurbs[prog.id]
	start_ts, end_ts = max(prog.start_time, self.start_ts), min(prog.end_time, self.end_ts)
	if value < start_ts:
		progress = 0
	else:
		if value > end_ts:
			progress = 100
		else:
			duration = end_ts - start_ts
			elapsed = value - start_ts
			progress = float(elapsed) / duration * 100
	selected_blurb.set_progress(progress)
	not_selected_blurb.set_progress(progress)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76a8dac>}
nname: 0
n 0(None)[prog = self.displayed_programs[self.selected_program]
scheduled = bool(prog.recording_id)
selected_blurb, not_selected_blurb = self.blurbs[prog.id]
selected_blurb.set_record(scheduled)
not_selected_blurb.set_record(scheduled)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb769be4c>}
nname: 241
n 241(None)[UIItem.reset(self, item, selected)
return None
]:
	i: 41(JA), 67(AL), 204(), 221()
	o: 

nname: 221
n 221(None)[self.widget.set_color(a=0)
]:
	i: 0(f)
	o: 241()

nname: 204
n 204(None)[self.set_selected_program(-1)
]:
	i: 126(AF), 200()
	o: 241()

nname: 200
n 200(None)[]:
	i: 142&166(f), 182()
	o: 204()

nname: 182
n 182(None)[self.set_selected_program(i)
break
continue
]:
	i: 142&166(t)
	o: 200()

nname: 142&166
n 142&166(prog.start_time <= now and prog.end_time >= now)[for i, prog in enumerate(self.displayed_programs):
]:
	i: 126(for)
	o: 182(t), 200(f)

nname: 126
n 126(None)[]:
	i: 67(loop)
	o: 142&166(for), 204(AF)

nname: 67
n 67(None)[start_ts, end_ts = map(ts.datetime_to_timestamp, ts.current_timeslice())
self.set_boundaries(start_ts, end_ts)
now = time()
]:
	i: 12&31(f)
	o: 126(loop), 241(AL)

nname: 41
n 41(None)[self.set_boundaries(self.start_ts, self.end_ts)
]:
	i: 12&31(t)
	o: 241(JA)

nname: 12&31
n 12&31(self.start_ts and self.end_ts)[self.channel = item
]:
	i: 0(t)
	o: 41(t), 67(f)

nname: 0
n 0(item is not None)[]:
	i: 
	o: 12&31(t), 221(f)

nname: 241
n 241(None)[UIItem.reset(self, item, selected)
return None
]:
	i: 41(JA), 67(AL), 204(), 221()
	o: 

nname: 221
n 221(None)[self.widget.set_color(a=0)
]:
	i: 0(f)
	o: 241()

nname: 204
n 204(None)[self.set_selected_program(-1)
]:
	i: 126(AF), 142&166(f)
	o: 241()

nname: 142&166
n 142&166(None)[for i, prog in enumerate(self.displayed_programs):
if prog.start_time <= now and prog.end_time >= now:
	self.set_selected_program(i)
	break
	continue
]:
	i: 126(for)
	o: 204()

nname: 126
n 126(None)[]:
	i: 67(loop)
	o: 142&166(for), 204(AF)

nname: 67
n 67(None)[start_ts, end_ts = map(ts.datetime_to_timestamp, ts.current_timeslice())
self.set_boundaries(start_ts, end_ts)
now = time()
]:
	i: 12&31(f)
	o: 126(loop), 241(AL)

nname: 41
n 41(None)[self.set_boundaries(self.start_ts, self.end_ts)
]:
	i: 12&31(t)
	o: 241(JA)

nname: 12&31
n 12&31(self.start_ts and self.end_ts)[self.channel = item
]:
	i: 0(t)
	o: 41(t), 67(f)

nname: 0
n 0(item is not None)[]:
	i: 
	o: 12&31(t), 221(f)

nname: 241
n 241(None)[UIItem.reset(self, item, selected)
return None
]:
	i: 41(JA), 142&166(), 221()
	o: 

nname: 221
n 221(None)[self.widget.set_color(a=0)
]:
	i: 0(f)
	o: 241()

nname: 142&166
n 142&166(None)[for i, prog in enumerate(self.displayed_programs):
	if prog.start_time <= now and prog.end_time >= now:
		self.set_selected_program(i)
		break
		continue
else:
	self.set_selected_program(-1)
]:
	i: 67(for)
	o: 241()

nname: 67
n 67(None)[start_ts, end_ts = map(ts.datetime_to_timestamp, ts.current_timeslice())
self.set_boundaries(start_ts, end_ts)
now = time()
]:
	i: 12&31(f)
	o: 142&166(for)

nname: 41
n 41(None)[self.set_boundaries(self.start_ts, self.end_ts)
]:
	i: 12&31(t)
	o: 241(JA)

nname: 12&31
n 12&31(self.start_ts and self.end_ts)[self.channel = item
]:
	i: 0(t)
	o: 41(t), 67(f)

nname: 0
n 0(item is not None)[]:
	i: 
	o: 12&31(t), 221(f)

nname: 241
n 241(None)[UIItem.reset(self, item, selected)
return None
]:
	i: 41(JA), 67(), 221()
	o: 

nname: 221
n 221(None)[self.widget.set_color(a=0)
]:
	i: 0(f)
	o: 241()

nname: 67
n 67(None)[start_ts, end_ts = map(ts.datetime_to_timestamp, ts.current_timeslice())
self.set_boundaries(start_ts, end_ts)
now = time()
for i, prog in enumerate(self.displayed_programs):
	if prog.start_time <= now and prog.end_time >= now:
		self.set_selected_program(i)
		break
		continue
else:
	self.set_selected_program(-1)
]:
	i: 12&31(f)
	o: 241()

nname: 41
n 41(None)[self.set_boundaries(self.start_ts, self.end_ts)
]:
	i: 12&31(t)
	o: 241(JA)

nname: 12&31
n 12&31(self.start_ts and self.end_ts)[self.channel = item
]:
	i: 0(t)
	o: 41(t), 67(f)

nname: 0
n 0(item is not None)[]:
	i: 
	o: 12&31(t), 221(f)

nname: 0
n 0(None)[if item is not None:
	self.channel = item
	if self.start_ts and self.end_ts:
		self.set_boundaries(self.start_ts, self.end_ts)
	else:
		start_ts, end_ts = map(ts.datetime_to_timestamp, ts.current_timeslice())
		self.set_boundaries(start_ts, end_ts)
		now = time()
		for i, prog in enumerate(self.displayed_programs):
			if prog.start_time <= now and prog.end_time >= now:
				self.set_selected_program(i)
				break
				continue
		else:
			self.set_selected_program(-1)
else:
	self.widget.set_color(a=0)
UIItem.reset(self, item, selected)
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76a4a2c>}
nname: 333
n 333(None)[return (not_sel_widget, sel_widget)
]:
	i: 0(AL), 332()
	o: 

nname: 332
n 332(None)[]:
	i: 297(AF), 307()
	o: 333()

nname: 307
n 307(None)[for signal in self._UPDATE_DISPATCH:
louie.connect(self.update, signal)
]:
	i: 297(for)
	o: 332()

nname: 297
n 297(None)[]:
	i: 0(loop)
	o: 307(for), 332(AF)

nname: 0
n 0(None)[not_sel_widget = Container()
sel_widget = Container()
self.channel = None
self.displayed_programs = []
self.selected_program = 0
self.start_ts = 0
self.end_ts = 0
self.blurbs = {}
self.spare_selected_blurbs = set()
self.spare_not_selected_blurbs = set()
selection_cursor = Image(image_or_file=self.style['selection_cursor_image'], repository=self.style['repository'])
selection_cursor.set_keep_real_size(False)
selection_cursor.set_color(a=0)
sel_widget.add_child(selection_cursor, aspect=False)
self.selection_cursor = selection_cursor
item_width, item_height = self.style['item_size']
self._not_selected_kwargs.update({'width': item_width, 'height': item_height})
selected_item_width, selected_item_height = self.style['selected_item_size']
self._selected_kwargs.update({'width': selected_item_width, 'height': selected_item_height})
]:
	i: 
	o: 297(loop), 333(AL)

nname: 333
n 333(None)[return (not_sel_widget, sel_widget)
]:
	i: 307()
	o: 

nname: 307
n 307(None)[for signal in self._UPDATE_DISPATCH:
	louie.connect(self.update, signal)
]:
	i: 0(for)
	o: 333()

nname: 0
n 0(None)[not_sel_widget = Container()
sel_widget = Container()
self.channel = None
self.displayed_programs = []
self.selected_program = 0
self.start_ts = 0
self.end_ts = 0
self.blurbs = {}
self.spare_selected_blurbs = set()
self.spare_not_selected_blurbs = set()
selection_cursor = Image(image_or_file=self.style['selection_cursor_image'], repository=self.style['repository'])
selection_cursor.set_keep_real_size(False)
selection_cursor.set_color(a=0)
sel_widget.add_child(selection_cursor, aspect=False)
self.selection_cursor = selection_cursor
item_width, item_height = self.style['item_size']
self._not_selected_kwargs.update({'width': item_width, 'height': item_height})
selected_item_width, selected_item_height = self.style['selected_item_size']
self._selected_kwargs.update({'width': selected_item_width, 'height': selected_item_height})
]:
	i: 
	o: 307(for)

nname: 333
n 333(None)[return (not_sel_widget, sel_widget)
]:
	i: 0()
	o: 

nname: 0
n 0(None)[not_sel_widget = Container()
sel_widget = Container()
self.channel = None
self.displayed_programs = []
self.selected_program = 0
self.start_ts = 0
self.end_ts = 0
self.blurbs = {}
self.spare_selected_blurbs = set()
self.spare_not_selected_blurbs = set()
selection_cursor = Image(image_or_file=self.style['selection_cursor_image'], repository=self.style['repository'])
selection_cursor.set_keep_real_size(False)
selection_cursor.set_color(a=0)
sel_widget.add_child(selection_cursor, aspect=False)
self.selection_cursor = selection_cursor
item_width, item_height = self.style['item_size']
self._not_selected_kwargs.update({'width': item_width, 'height': item_height})
selected_item_width, selected_item_height = self.style['selected_item_size']
self._selected_kwargs.update({'width': selected_item_width, 'height': selected_item_height})
for signal in self._UPDATE_DISPATCH:
	louie.connect(self.update, signal)
]:
	i: 
	o: 333()

nname: 0
n 0(None)[not_sel_widget = Container()
sel_widget = Container()
self.channel = None
self.displayed_programs = []
self.selected_program = 0
self.start_ts = 0
self.end_ts = 0
self.blurbs = {}
self.spare_selected_blurbs = set()
self.spare_not_selected_blurbs = set()
selection_cursor = Image(image_or_file=self.style['selection_cursor_image'], repository=self.style['repository'])
selection_cursor.set_keep_real_size(False)
selection_cursor.set_color(a=0)
sel_widget.add_child(selection_cursor, aspect=False)
self.selection_cursor = selection_cursor
item_width, item_height = self.style['item_size']
self._not_selected_kwargs.update({'width': item_width, 'height': item_height})
selected_item_width, selected_item_height = self.style['selected_item_size']
self._selected_kwargs.update({'width': selected_item_width, 'height': selected_item_height})
for signal in self._UPDATE_DISPATCH:
	louie.connect(self.update, signal)
return (not_sel_widget, sel_widget)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76a4a0c>}
nname: 0
n 0(None)[self._UPDATE_DISPATCH[signal](self, *args, **kw)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb769b88c>}
nname: 0
n 0(None)[self._SELECTED_UPDATE_DISPATCH[signal](self, *args, **kw)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb769b8ac>}
nname: 151
n 151(None)[self.selection_cursor.set_color(a=0)
UIItem._set_selected(self, selected, *args, **kw)
]:
	i: 140(), 147()
	o: 

nname: 147
n 147(None)[]:
	i: 122(f)
	o: 151()

nname: 140
n 140(None)[]:
	i: 122(t)
	o: 151()

nname: 122
n 122(selected)[]:
	i: 6(AL), 45(), 105(), 121()
	o: 140(t), 147(f)

nname: 121
n 121(None)[]:
	i: 49(f)
	o: 122()

nname: 105
n 105(None)[self.set_selected_program(-1)
]:
	i: 59(AL), 104()
	o: 122()

nname: 104
n 104(None)[]:
	i: 63(AF), 73()
	o: 105()

nname: 73
n 73(None)[for signal in self._SELECTED_UPDATE_DISPATCH:
louie.disconnect(self._selected_update, signal, wipe=False)
]:
	i: 63(for)
	o: 104()

nname: 63
n 63(None)[]:
	i: 59(loop)
	o: 73(for), 104(AF)

nname: 59
n 59(None)[]:
	i: 49(t)
	o: 63(loop), 105(AL)

nname: 49
n 49(self.selected)[]:
	i: 0(f)
	o: 59(t), 121(f)

nname: 45
n 45(None)[]:
	i: 10(AF), 20()
	o: 122()

nname: 20
n 20(None)[for signal in self._SELECTED_UPDATE_DISPATCH:
louie.connect(self._selected_update, signal)
]:
	i: 10(for)
	o: 45()

nname: 10
n 10(None)[]:
	i: 6(loop)
	o: 20(for), 45(AF)

nname: 6
n 6(None)[]:
	i: 0(t)
	o: 10(loop), 122(AL)

nname: 0
n 0(selected)[]:
	i: 
	o: 6(t), 49(f)

nname: 122
n 122(None)[if selected:
	pass
self.selection_cursor.set_color(a=0)
UIItem._set_selected(self, selected, *args, **kw)
]:
	i: 20(), 105(), 49(f)
	o: 

nname: 105
n 105(None)[self.set_selected_program(-1)
]:
	i: 73()
	o: 122()

nname: 73
n 73(None)[for signal in self._SELECTED_UPDATE_DISPATCH:
	louie.disconnect(self._selected_update, signal, wipe=False)
]:
	i: 59(for)
	o: 105()

nname: 59
n 59(None)[]:
	i: 49(t)
	o: 73(for)

nname: 49
n 49(self.selected)[]:
	i: 0(f)
	o: 59(t), 122(f)

nname: 20
n 20(None)[for signal in self._SELECTED_UPDATE_DISPATCH:
	louie.connect(self._selected_update, signal)
]:
	i: 6(for)
	o: 122()

nname: 6
n 6(None)[]:
	i: 0(t)
	o: 20(for)

nname: 0
n 0(selected)[]:
	i: 
	o: 6(t), 49(f)

nname: 122
n 122(None)[if selected:
	pass
self.selection_cursor.set_color(a=0)
UIItem._set_selected(self, selected, *args, **kw)
]:
	i: 6(), 105(), 49(f)
	o: 

nname: 105
n 105(None)[self.set_selected_program(-1)
]:
	i: 59()
	o: 122()

nname: 59
n 59(None)[for signal in self._SELECTED_UPDATE_DISPATCH:
	louie.disconnect(self._selected_update, signal, wipe=False)
]:
	i: 49(t)
	o: 105()

nname: 49
n 49(self.selected)[]:
	i: 0(f)
	o: 59(t), 122(f)

nname: 6
n 6(None)[for signal in self._SELECTED_UPDATE_DISPATCH:
	louie.connect(self._selected_update, signal)
]:
	i: 0(t)
	o: 122()

nname: 0
n 0(selected)[]:
	i: 
	o: 6(t), 49(f)

nname: 122
n 122(None)[if selected:
	pass
self.selection_cursor.set_color(a=0)
UIItem._set_selected(self, selected, *args, **kw)
]:
	i: 6(), 59(), 49(f)
	o: 

nname: 59
n 59(None)[for signal in self._SELECTED_UPDATE_DISPATCH:
	louie.disconnect(self._selected_update, signal, wipe=False)
self.set_selected_program(-1)
]:
	i: 49(t)
	o: 122()

nname: 49
n 49(self.selected)[]:
	i: 0(f)
	o: 59(t), 122(f)

nname: 6
n 6(None)[for signal in self._SELECTED_UPDATE_DISPATCH:
	louie.connect(self._selected_update, signal)
]:
	i: 0(t)
	o: 122()

nname: 0
n 0(selected)[]:
	i: 
	o: 6(t), 49(f)

nname: 0
n 0(None)[if selected:
	for signal in self._SELECTED_UPDATE_DISPATCH:
		louie.connect(self._selected_update, signal)
else:
	if self.selected:
		for signal in self._SELECTED_UPDATE_DISPATCH:
			louie.disconnect(self._selected_update, signal, wipe=False)
		self.set_selected_program(-1)
if selected:
	pass
self.selection_cursor.set_color(a=0)
UIItem._set_selected(self, selected, *args, **kw)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76a47ac>}
nname: 75
n 75(None)[return UIItem.destroy(self)
]:
	i: 9(AL), 70(), 74()
	o: 

nname: 74
n 74(None)[]:
	i: 0(f)
	o: 75()

nname: 70
n 70(None)[]:
	i: 29(AF), 39()
	o: 75()

nname: 39
n 39(None)[for signal in self._SELECTED_UPDATE_DISPATCH:
louie.disconnect(self._selected_update, signal, wipe=False)
]:
	i: 29(for)
	o: 70()

nname: 29
n 29(None)[]:
	i: 9(loop)
	o: 39(for), 70(AF)

nname: 9
n 9(None)[self.selection_cursor.set_visible(False)
]:
	i: 0(t)
	o: 29(loop), 75(AL)

nname: 0
n 0(self.selected)[]:
	i: 
	o: 9(t), 74(f)

nname: 75
n 75(None)[return UIItem.destroy(self)
]:
	i: 39(), 0(f)
	o: 

nname: 39
n 39(None)[for signal in self._SELECTED_UPDATE_DISPATCH:
	louie.disconnect(self._selected_update, signal, wipe=False)
]:
	i: 9(for)
	o: 75()

nname: 9
n 9(None)[self.selection_cursor.set_visible(False)
]:
	i: 0(t)
	o: 39(for)

nname: 0
n 0(self.selected)[]:
	i: 
	o: 9(t), 75(f)

nname: 75
n 75(None)[return UIItem.destroy(self)
]:
	i: 9(), 0(f)
	o: 

nname: 9
n 9(None)[self.selection_cursor.set_visible(False)
for signal in self._SELECTED_UPDATE_DISPATCH:
	louie.disconnect(self._selected_update, signal, wipe=False)
]:
	i: 0(t)
	o: 75()

nname: 0
n 0(self.selected)[]:
	i: 
	o: 9(t), 75(f)

nname: 0
n 0(None)[if self.selected:
	self.selection_cursor.set_visible(False)
	for signal in self._SELECTED_UPDATE_DISPATCH:
		louie.disconnect(self._selected_update, signal, wipe=False)
return UIItem.destroy(self)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb769bc2c>}
nname: 6
n 6(None)[__doc__ = 'A list item that displays an electronic program guide for one channel.'
__slots__ = ['_selected', '_marked', '_position', '_edited', 'widget', 'style', 'channel', 'start_ts', 'end_ts', 'displayed_programs', 'adjusted_durations', 'selected_program', '_not_selected_widget', '_selected_widget', 'selection_cursor', 'blurbs', 'spare_selected_blurbs', 'spare_not_selected_blurbs', '__weakref__']
not_selected_style = property((lambda self: {'repository': self.style['repository'], 'progress_bar_offset': self.style['progress_bar_offset'], 'progress_bar_size': self.style['progress_bar_size'], 'progress_bar_background': self.style['progress_bar_background'], 'progress_bar_foreground': self.style['progress_bar_foreground'], 'time_offset': self.style['time_offset'], 'time_font_style': self.style['time_font_style'], 'time_color': self.style['time_color'], 'title_font_style': self.style['title_font_style'], 'title_color': self.style['title_color'], 'text_offset': self.style['text_offset'], 'rec_icon': self.style['rec_icon'], 'rec_icon_offset': self.style['rec_icon_offset'], 'maxlen': self.style['maxlen']}))
selected_style = property((lambda self: {'repository': self.style['repository'], 'progress_bar_offset': self.style['progress_bar_offset'], 'progress_bar_size': self.style['progress_bar_size'], 'progress_bar_background': self.style['progress_bar_background'], 'progress_bar_foreground': self.style['progress_bar_foreground'], 'time_offset': self.style['time_offset'], 'time_font_style': self.style['selected_time_font_style'], 'time_color': self.style['selected_time_color'], 'title_font_style': self.style['selected_title_font_style'], 'title_color': self.style['selected_title_color'], 'text_offset': self.style['selected_text_offset'], 'rec_icon': self.style['rec_icon'], 'rec_icon_offset': self.style['rec_icon_offset'], 'maxlen': self.style['maxlen']}))
selected_program_style = property((lambda self: {'repository': self.style['repository'], 'time_offset': self.style['time_offset'], 'time_font_style': self.style['selected_time_font_style'], 'time_color': self.style['selected_blurb_time_color'], 'title_font_style': self.style['selected_title_font_style'], 'title_color': self.style['selected_blurb_title_color'], 'text_offset': self.style['selected_blurb_text_offset'], 'rec_icon': self.style['rec_icon'], 'rec_icon_offset': self.style['rec_icon_offset'], 'maxlen': self.style['maxlen']}))
def set_boundaries(self, start_ts, end_ts):
	self.start_ts = start_ts
	self.end_ts = end_ts
	if self.channel:
		_[1], progs = render_lock.__exit__, self.channel.browse(start_ts, end_ts, limit=10, pad=True, focus=time())
	else:
		progs = []
	render_lock.__enter__()
	try:
		self.set_programs(progs)
		self.set_selected_program(-1)
	finally:
		del _[1]

def set_programs(self, progs):
	ns_visible = self._not_selected_widget.get_visible()
	s_visible = self._selected_widget.get_visible()
	total_duration = self.end_ts - self.start_ts
	if 0 <= self.selected_program:
		pass
	else:
		self.selected_program
	if 0 <= self.selected_program:
		selected_program_item = self.displayed_programs[self.selected_program]
	else:
		selected_program_item = None
	old_programs = set(self.displayed_programs)
	self.displayed_programs[:] = progs
	for program in old_programs.difference(progs):
		selected_blurb, not_selected_blurb = self.blurbs.pop(program.id)
		if program is selected_program_item:
			selected_blurb.set_style(self.selected_style)
		selected_blurb.hide()
		selected_blurb.orphaned()
		self.spare_selected_blurbs.add(selected_blurb)
		not_selected_blurb.hide()
		not_selected_blurb.orphaned()
		self.spare_not_selected_blurbs.add(not_selected_blurb)
	self.adjusted_durations = adjust_durations(progs, global_start_time=self.start_ts, global_end_time=self.end_ts)
	for program, start_time in izip(progs, self.adjusted_durations):
		if program.start_time < self.start_ts:
			displayed_start_time, start_time = self.start_ts, self.start_ts
			name = u'\u2026\n%s' % program.name
		else:
			displayed_start_time = program.start_time
			name = program.name
		end_time = min(end_time, self.end_ts)
		top = (start_time - self.start_ts) / total_duration * 100
		height = (end_time - start_time) / total_duration * 100
		rec = program.recording_status in RECS_TO_DISPLAY
		if program in old_programs:
			selected_blurb, not_selected_blurb = self.blurbs[program.id]
			selected_blurb.reset(displayed_start_time, name, rec)
			selected_blurb.move(duration=0, top='%i%%' % top)
			selected_blurb.resize(duration=0, height='%i%%' % height)
			not_selected_blurb.reset(displayed_start_time, name, rec)
			not_selected_blurb.move(duration=0, top='%i%%' % top)
			not_selected_blurb.resize(duration=0, height='%i%%' % height)
			continue
		if self.spare_selected_blurbs and self.spare_not_selected_blurbs:
			selected_blurb = self.spare_selected_blurbs.pop()
			not_selected_blurb = self.spare_not_selected_blurbs.pop()
			selected_blurb.reset(displayed_start_time, name, rec)
			not_selected_blurb.reset(displayed_start_time, name, rec)
			selected_blurb.adopted(self._selected_widget)
			selected_blurb.move(top='%i%%' % top, left='0%')
			selected_blurb.resize(height='%i%%' % height, width='100%')
			selected_blurb.set_visible(s_visible)
			not_selected_blurb.adopted(self._not_selected_widget)
			not_selected_blurb.move(top='%i%%' % top, left='0%')
			not_selected_blurb.resize(height='%i%%' % height, width='100%')
			not_selected_blurb.set_visible(ns_visible)
			self.blurbs[program.id] = (selected_blurb, not_selected_blurb)
			continue
		selected_blurb = ProgramBlurb(self.selected_style)
		selected_blurb.reset(displayed_start_time, name, rec)
		not_selected_blurb = ProgramBlurb(self.not_selected_style)
		not_selected_blurb.reset(displayed_start_time, name, rec)
		self._not_selected_widget.add_child(not_selected_blurb, name=program.id, top='%i%%' % top, left='0%', height='%i%%' % height, width='100%')
		self._selected_widget.add_child(selected_blurb, name=program.id, top='%i%%' % top, left='0%', height='%i%%' % height, width='100%')
		self.blurbs[program.id] = (selected_blurb, not_selected_blurb)
	self._selected_widget.set_visible(s_visible)
	self._not_selected_widget.set_visible(ns_visible)
	self.update_progress(time())
	return None

def set_selected_program(self, value):
	if not self.displayed_programs:
		pass
	total_duration = self.end_ts - self.start_ts
	animation_duration = self.style['duration']
	if 0 <= self.selected_program:
		pass
	else:
		self.selected_program
	if 0 <= self.selected_program:
		current_program = self.displayed_programs[self.selected_program]
		current_widget, _ = self.blurbs[current_program.id]
		start_time, end_time = self.adjusted_durations[self.selected_program]
		start_time = max(self.start_ts, start_time)
		end_time = min(end_time, self.end_ts)
		top = (start_time - self.start_ts) / total_duration * 100
		left = 0
		current_widget.set_style(self.selected_style)
		current_widget.move(duration=animation_duration, top='%i%%' % top, left='%i%%' % left)
		current_widget.resize(duration=animation_duration, width='100%')
	if 0 <= value:
		pass
	else:
		value
	if 0 <= value:
		new_program = self.displayed_programs[value]
		new_widget, _ = self.blurbs[new_program.id]
		start_time, end_time = self.adjusted_durations[value]
		start_time = max(self.start_ts, start_time)
		end_time = min(end_time, self.end_ts)
		left_offset, top_offset = <genexpr>(self.style['selected_blurb_offset'])
		top = (start_time - self.start_ts) / total_duration * 100 + top_offset
		left = left_offset
		new_widget.set_style(self.selected_program_style)
		new_widget.move(duration=animation_duration, top='%i%%' % top, left='%i%%' % left)
		new_widget.resize(duration=animation_duration, width=self.style['selected_blurb_zoom'])
		width, height = new_widget.get_size()
		self.selection_cursor.move(duration=animation_duration, top='%i%%' % top, left='%i%%' % left)
		self.selection_cursor.resize(duration=animation_duration, width=width, height=height)
		self.selection_cursor.set_visible(True)
	else:
		self.selection_cursor.set_visible(False)
	self.selected_program = value

def update_progress(self, value):
	for prog in self.displayed_programs:
		selected_blurb, not_selected_blurb = self.blurbs[prog.id]
		start_ts, end_ts = max(prog.start_time, self.start_ts), min(prog.end_time, self.end_ts)
		if value < start_ts:
			progress = 0
		else:
			if value > end_ts:
				progress = 100
			else:
				duration = end_ts - start_ts
				elapsed = value - start_ts
				progress = float(elapsed) / duration * 100
		selected_blurb.set_progress(progress)
		not_selected_blurb.set_progress(progress)

def update_record(self):
	prog = self.displayed_programs[self.selected_program]
	scheduled = bool(prog.recording_id)
	selected_blurb, not_selected_blurb = self.blurbs[prog.id]
	selected_blurb.set_record(scheduled)
	not_selected_blurb.set_record(scheduled)

def reset(self, item, selected, position=None):
	if item is not None:
		self.channel = item
		if self.start_ts and self.end_ts:
			self.set_boundaries(self.start_ts, self.end_ts)
		else:
			start_ts, end_ts = map(ts.datetime_to_timestamp, ts.current_timeslice())
			self.set_boundaries(start_ts, end_ts)
			now = time()
			for i, prog in enumerate(self.displayed_programs):
				if prog.start_time <= now and prog.end_time >= now:
					self.set_selected_program(i)
					break
					continue
			else:
				self.set_selected_program(-1)
	else:
		self.widget.set_color(a=0)
	UIItem.reset(self, item, selected)
	return None

def _create(self):
	not_sel_widget = Container()
	sel_widget = Container()
	self.channel = None
	self.displayed_programs = []
	self.selected_program = 0
	self.start_ts = 0
	self.end_ts = 0
	self.blurbs = {}
	self.spare_selected_blurbs = set()
	self.spare_not_selected_blurbs = set()
	selection_cursor = Image(image_or_file=self.style['selection_cursor_image'], repository=self.style['repository'])
	selection_cursor.set_keep_real_size(False)
	selection_cursor.set_color(a=0)
	sel_widget.add_child(selection_cursor, aspect=False)
	self.selection_cursor = selection_cursor
	item_width, item_height = self.style['item_size']
	self._not_selected_kwargs.update({'width': item_width, 'height': item_height})
	selected_item_width, selected_item_height = self.style['selected_item_size']
	self._selected_kwargs.update({'width': selected_item_width, 'height': selected_item_height})
	for signal in self._UPDATE_DISPATCH:
		louie.connect(self.update, signal)
	return (not_sel_widget, sel_widget)

_UPDATE_DISPATCH = {'set_boundaries': set_boundaries, 'clock': update_progress}
def update(self, signal, sender=None, *args, **args):
	self._UPDATE_DISPATCH[signal](self, *args, **kw)

_SELECTED_UPDATE_DISPATCH = {'set_selected_program': set_selected_program, 'update_record': update_record}
def _selected_update(self, signal, sender=None, *args, **args):
	self._SELECTED_UPDATE_DISPATCH[signal](self, *args, **kw)

def _set_selected(self, selected, *args, **args):
	if selected:
		for signal in self._SELECTED_UPDATE_DISPATCH:
			louie.connect(self._selected_update, signal)
	else:
		if self.selected:
			for signal in self._SELECTED_UPDATE_DISPATCH:
				louie.disconnect(self._selected_update, signal, wipe=False)
			self.set_selected_program(-1)
	if selected:
		pass
	self.selection_cursor.set_color(a=0)
	UIItem._set_selected(self, selected, *args, **kw)

def destroy(self):
	if self.selected:
		self.selection_cursor.set_visible(False)
		for signal in self._SELECTED_UPDATE_DISPATCH:
			louie.disconnect(self._selected_update, signal, wipe=False)
	return UIItem.destroy(self)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb76a8bcc>}
nname: 0
n 0(None)[from __future__ import absolute_import, with_statement
from itertools import izip
from time import time
import peewee.messages as louie
from wyrecord.recording import RECORDING_STATUS_SCHEDULED, RECORDING_STATUS_RUNNING
from wyvas import Container, Image, render_lock
from peewee.formatters import seconds_to_hhmm
from pygui.facilities import timeslices as ts
from pygui.item.mediaitem.tv import RECS_TO_DISPLAY
from ..textblock import TextBlock
from .ui_items import UIItem
def adjust_durations(programs, min_duration=700, global_start_time=None, global_end_time=None):
	out = []
	missing_seconds = 0
	if not programs:
		return out
	if not global_start_time:
		pass
	global_start_time = global_start_time
	if not global_end_time:
		pass
	global_end_time = global_end_time
	midpoint = max(programs[len(programs) / 2].start_time, global_start_time)
	use_reverse = midpoint > (global_start_time + global_end_time) / 2
	if use_reverse:
		programs = reversed(programs)
	for prog in programs:
		prog_start_time = max(prog.start_time, global_start_time)
		prog_end_time = min(prog.end_time, global_end_time)
		prog_duration = prog_end_time - prog_start_time
		if use_reverse:
			end_time = prog_end_time - missing_seconds
		else:
			start_time = prog_start_time + missing_seconds
		if prog_duration < min_duration:
			duration = min_duration
			missing_seconds += min_duration - prog_duration
		else:
			duration = max(prog_duration - missing_seconds, min_duration)
			missing_seconds -= prog_duration - duration
		if use_reverse:
			start_time = end_time - duration
		else:
			end_time = start_time + duration
		out.append((start_time, end_time))
	if use_reverse:
		out.reverse()
	return out

class ProgramBlurb(Container):
	__doc__ = 'A widget that displays information about a single TV program:\n        - start time\n        - title\n    '
	def __init__(self, style, **kwargs):
		Container.__init__(self, **kwargs)
		self.start_time_display = TextBlock()
		self.title_display = TextBlock(max_width=style.get('maxlen', None))
		self.rec_icon = Image(repository=style['repository'], image_or_file=style['rec_icon'])
		self.rec_icon.set_keep_real_size(False)
		self.rec_status = False
		self.progress_bar = Container()
		self.progress_bar_fg = Image(repository=style['repository'], image_or_file=style['progress_bar_foreground'])
		self.progress_bar_fg.set_keep_real_size(False)
		self.progress_bar_bg = Image(repository=style['repository'], image_or_file=style['progress_bar_background'])
		self.progress_bar_bg.set_keep_real_size(False)
		self.progress_bar.add_child(self.progress_bar_bg, top='0%', left='0%', height='100%', width='100%', aspect=False)
		self.progress_bar.add_child(self.progress_bar_fg, top='0%', left='0%', height='100%', width='100%', aspect=False)
		bar_left, bar_top = style['progress_bar_offset']
		bar_width, bar_height = style['progress_bar_size']
		self.add_child(self.progress_bar, top=bar_top, left=bar_left, height=bar_height, width=bar_width, layer=-1)
		self.add_child(self.rec_icon, height='0%', width='0%')
		self.add_child(self.start_time_display)
		self.add_child(self.title_display)
		self.set_style(style)
		return None

	def set_style(self, style):
		self.start_time_display.set_style(style=style['time_font_style'])
		self.start_time_display.set_color(color=style['time_color'])
		time_left, time_top = style['time_offset']
		self.start_time_display.move(top=time_top, left=time_left)
		self.title_display.set_style(style=style['title_font_style'])
		self.title_display.set_color(color=style['title_color'])
		title_left, title_top = style['text_offset']
		title_width = '%i%%' % (100 - int(title_left.rstrip('%')))
		self.title_display.move(top=title_top, left=title_left)
		self.title_display.resize(width=title_width)
		rec_icon_left, rec_icon_top = style['rec_icon_offset']
		self.rec_icon.move(top=rec_icon_top, left=rec_icon_left)

	def set_progress(self, n):
		self.progress_bar_fg.resize(height='%i%%' % n)

	def set_record(self, record):
		if record and not self.rec_status:
			self.rec_icon.set_keep_real_size(True)
			self.rec_icon.resize(width='100%')
		else:
			if self.rec_status and not record:
				self.rec_icon.set_keep_real_size(False)
				self.rec_icon.resize(width='0%')
		self.rec_status = record

	def reset(self, start_time, name, record=False):
		self.start_time_display.set_text(seconds_to_hhmm(start_time))
		self.title_display.set_text(name)
		self.set_record(record)



class EPGItem(UIItem):
	__doc__ = 'A list item that displays an electronic program guide for one channel.'
	__slots__ = ['_selected', '_marked', '_position', '_edited', 'widget', 'style', 'channel', 'start_ts', 'end_ts', 'displayed_programs', 'adjusted_durations', 'selected_program', '_not_selected_widget', '_selected_widget', 'selection_cursor', 'blurbs', 'spare_selected_blurbs', 'spare_not_selected_blurbs', '__weakref__']
	not_selected_style = property((lambda self: {'repository': self.style['repository'], 'progress_bar_offset': self.style['progress_bar_offset'], 'progress_bar_size': self.style['progress_bar_size'], 'progress_bar_background': self.style['progress_bar_background'], 'progress_bar_foreground': self.style['progress_bar_foreground'], 'time_offset': self.style['time_offset'], 'time_font_style': self.style['time_font_style'], 'time_color': self.style['time_color'], 'title_font_style': self.style['title_font_style'], 'title_color': self.style['title_color'], 'text_offset': self.style['text_offset'], 'rec_icon': self.style['rec_icon'], 'rec_icon_offset': self.style['rec_icon_offset'], 'maxlen': self.style['maxlen']}))
	selected_style = property((lambda self: {'repository': self.style['repository'], 'progress_bar_offset': self.style['progress_bar_offset'], 'progress_bar_size': self.style['progress_bar_size'], 'progress_bar_background': self.style['progress_bar_background'], 'progress_bar_foreground': self.style['progress_bar_foreground'], 'time_offset': self.style['time_offset'], 'time_font_style': self.style['selected_time_font_style'], 'time_color': self.style['selected_time_color'], 'title_font_style': self.style['selected_title_font_style'], 'title_color': self.style['selected_title_color'], 'text_offset': self.style['selected_text_offset'], 'rec_icon': self.style['rec_icon'], 'rec_icon_offset': self.style['rec_icon_offset'], 'maxlen': self.style['maxlen']}))
	selected_program_style = property((lambda self: {'repository': self.style['repository'], 'time_offset': self.style['time_offset'], 'time_font_style': self.style['selected_time_font_style'], 'time_color': self.style['selected_blurb_time_color'], 'title_font_style': self.style['selected_title_font_style'], 'title_color': self.style['selected_blurb_title_color'], 'text_offset': self.style['selected_blurb_text_offset'], 'rec_icon': self.style['rec_icon'], 'rec_icon_offset': self.style['rec_icon_offset'], 'maxlen': self.style['maxlen']}))
	def set_boundaries(self, start_ts, end_ts):
		self.start_ts = start_ts
		self.end_ts = end_ts
		if self.channel:
			_[1], progs = render_lock.__exit__, self.channel.browse(start_ts, end_ts, limit=10, pad=True, focus=time())
		else:
			progs = []
		render_lock.__enter__()
		try:
			self.set_programs(progs)
			self.set_selected_program(-1)
		finally:
			del _[1]

	def set_programs(self, progs):
		ns_visible = self._not_selected_widget.get_visible()
		s_visible = self._selected_widget.get_visible()
		total_duration = self.end_ts - self.start_ts
		if 0 <= self.selected_program:
			pass
		else:
			self.selected_program
		if 0 <= self.selected_program:
			selected_program_item = self.displayed_programs[self.selected_program]
		else:
			selected_program_item = None
		old_programs = set(self.displayed_programs)
		self.displayed_programs[:] = progs
		for program in old_programs.difference(progs):
			selected_blurb, not_selected_blurb = self.blurbs.pop(program.id)
			if program is selected_program_item:
				selected_blurb.set_style(self.selected_style)
			selected_blurb.hide()
			selected_blurb.orphaned()
			self.spare_selected_blurbs.add(selected_blurb)
			not_selected_blurb.hide()
			not_selected_blurb.orphaned()
			self.spare_not_selected_blurbs.add(not_selected_blurb)
		self.adjusted_durations = adjust_durations(progs, global_start_time=self.start_ts, global_end_time=self.end_ts)
		for program, start_time in izip(progs, self.adjusted_durations):
			if program.start_time < self.start_ts:
				displayed_start_time, start_time = self.start_ts, self.start_ts
				name = u'\u2026\n%s' % program.name
			else:
				displayed_start_time = program.start_time
				name = program.name
			end_time = min(end_time, self.end_ts)
			top = (start_time - self.start_ts) / total_duration * 100
			height = (end_time - start_time) / total_duration * 100
			rec = program.recording_status in RECS_TO_DISPLAY
			if program in old_programs:
				selected_blurb, not_selected_blurb = self.blurbs[program.id]
				selected_blurb.reset(displayed_start_time, name, rec)
				selected_blurb.move(duration=0, top='%i%%' % top)
				selected_blurb.resize(duration=0, height='%i%%' % height)
				not_selected_blurb.reset(displayed_start_time, name, rec)
				not_selected_blurb.move(duration=0, top='%i%%' % top)
				not_selected_blurb.resize(duration=0, height='%i%%' % height)
				continue
			if self.spare_selected_blurbs and self.spare_not_selected_blurbs:
				selected_blurb = self.spare_selected_blurbs.pop()
				not_selected_blurb = self.spare_not_selected_blurbs.pop()
				selected_blurb.reset(displayed_start_time, name, rec)
				not_selected_blurb.reset(displayed_start_time, name, rec)
				selected_blurb.adopted(self._selected_widget)
				selected_blurb.move(top='%i%%' % top, left='0%')
				selected_blurb.resize(height='%i%%' % height, width='100%')
				selected_blurb.set_visible(s_visible)
				not_selected_blurb.adopted(self._not_selected_widget)
				not_selected_blurb.move(top='%i%%' % top, left='0%')
				not_selected_blurb.resize(height='%i%%' % height, width='100%')
				not_selected_blurb.set_visible(ns_visible)
				self.blurbs[program.id] = (selected_blurb, not_selected_blurb)
				continue
			selected_blurb = ProgramBlurb(self.selected_style)
			selected_blurb.reset(displayed_start_time, name, rec)
			not_selected_blurb = ProgramBlurb(self.not_selected_style)
			not_selected_blurb.reset(displayed_start_time, name, rec)
			self._not_selected_widget.add_child(not_selected_blurb, name=program.id, top='%i%%' % top, left='0%', height='%i%%' % height, width='100%')
			self._selected_widget.add_child(selected_blurb, name=program.id, top='%i%%' % top, left='0%', height='%i%%' % height, width='100%')
			self.blurbs[program.id] = (selected_blurb, not_selected_blurb)
		self._selected_widget.set_visible(s_visible)
		self._not_selected_widget.set_visible(ns_visible)
		self.update_progress(time())
		return None

	def set_selected_program(self, value):
		if not self.displayed_programs:
			pass
		total_duration = self.end_ts - self.start_ts
		animation_duration = self.style['duration']
		if 0 <= self.selected_program:
			pass
		else:
			self.selected_program
		if 0 <= self.selected_program:
			current_program = self.displayed_programs[self.selected_program]
			current_widget, _ = self.blurbs[current_program.id]
			start_time, end_time = self.adjusted_durations[self.selected_program]
			start_time = max(self.start_ts, start_time)
			end_time = min(end_time, self.end_ts)
			top = (start_time - self.start_ts) / total_duration * 100
			left = 0
			current_widget.set_style(self.selected_style)
			current_widget.move(duration=animation_duration, top='%i%%' % top, left='%i%%' % left)
			current_widget.resize(duration=animation_duration, width='100%')
		if 0 <= value:
			pass
		else:
			value
		if 0 <= value:
			new_program = self.displayed_programs[value]
			new_widget, _ = self.blurbs[new_program.id]
			start_time, end_time = self.adjusted_durations[value]
			start_time = max(self.start_ts, start_time)
			end_time = min(end_time, self.end_ts)
			left_offset, top_offset = <genexpr>(self.style['selected_blurb_offset'])
			top = (start_time - self.start_ts) / total_duration * 100 + top_offset
			left = left_offset
			new_widget.set_style(self.selected_program_style)
			new_widget.move(duration=animation_duration, top='%i%%' % top, left='%i%%' % left)
			new_widget.resize(duration=animation_duration, width=self.style['selected_blurb_zoom'])
			width, height = new_widget.get_size()
			self.selection_cursor.move(duration=animation_duration, top='%i%%' % top, left='%i%%' % left)
			self.selection_cursor.resize(duration=animation_duration, width=width, height=height)
			self.selection_cursor.set_visible(True)
		else:
			self.selection_cursor.set_visible(False)
		self.selected_program = value

	def update_progress(self, value):
		for prog in self.displayed_programs:
			selected_blurb, not_selected_blurb = self.blurbs[prog.id]
			start_ts, end_ts = max(prog.start_time, self.start_ts), min(prog.end_time, self.end_ts)
			if value < start_ts:
				progress = 0
			else:
				if value > end_ts:
					progress = 100
				else:
					duration = end_ts - start_ts
					elapsed = value - start_ts
					progress = float(elapsed) / duration * 100
			selected_blurb.set_progress(progress)
			not_selected_blurb.set_progress(progress)

	def update_record(self):
		prog = self.displayed_programs[self.selected_program]
		scheduled = bool(prog.recording_id)
		selected_blurb, not_selected_blurb = self.blurbs[prog.id]
		selected_blurb.set_record(scheduled)
		not_selected_blurb.set_record(scheduled)

	def reset(self, item, selected, position=None):
		if item is not None:
			self.channel = item
			if self.start_ts and self.end_ts:
				self.set_boundaries(self.start_ts, self.end_ts)
			else:
				start_ts, end_ts = map(ts.datetime_to_timestamp, ts.current_timeslice())
				self.set_boundaries(start_ts, end_ts)
				now = time()
				for i, prog in enumerate(self.displayed_programs):
					if prog.start_time <= now and prog.end_time >= now:
						self.set_selected_program(i)
						break
						continue
				else:
					self.set_selected_program(-1)
		else:
			self.widget.set_color(a=0)
		UIItem.reset(self, item, selected)
		return None

	def _create(self):
		not_sel_widget = Container()
		sel_widget = Container()
		self.channel = None
		self.displayed_programs = []
		self.selected_program = 0
		self.start_ts = 0
		self.end_ts = 0
		self.blurbs = {}
		self.spare_selected_blurbs = set()
		self.spare_not_selected_blurbs = set()
		selection_cursor = Image(image_or_file=self.style['selection_cursor_image'], repository=self.style['repository'])
		selection_cursor.set_keep_real_size(False)
		selection_cursor.set_color(a=0)
		sel_widget.add_child(selection_cursor, aspect=False)
		self.selection_cursor = selection_cursor
		item_width, item_height = self.style['item_size']
		self._not_selected_kwargs.update({'width': item_width, 'height': item_height})
		selected_item_width, selected_item_height = self.style['selected_item_size']
		self._selected_kwargs.update({'width': selected_item_width, 'height': selected_item_height})
		for signal in self._UPDATE_DISPATCH:
			louie.connect(self.update, signal)
		return (not_sel_widget, sel_widget)

	_UPDATE_DISPATCH = {'set_boundaries': set_boundaries, 'clock': update_progress}
	def update(self, signal, sender=None, *args, **args):
		self._UPDATE_DISPATCH[signal](self, *args, **kw)

	_SELECTED_UPDATE_DISPATCH = {'set_selected_program': set_selected_program, 'update_record': update_record}
	def _selected_update(self, signal, sender=None, *args, **args):
		self._SELECTED_UPDATE_DISPATCH[signal](self, *args, **kw)

	def _set_selected(self, selected, *args, **args):
		if selected:
			for signal in self._SELECTED_UPDATE_DISPATCH:
				louie.connect(self._selected_update, signal)
		else:
			if self.selected:
				for signal in self._SELECTED_UPDATE_DISPATCH:
					louie.disconnect(self._selected_update, signal, wipe=False)
				self.set_selected_program(-1)
		if selected:
			pass
		self.selection_cursor.set_color(a=0)
		UIItem._set_selected(self, selected, *args, **kw)

	def destroy(self):
		if self.selected:
			self.selection_cursor.set_visible(False)
			for signal in self._SELECTED_UPDATE_DISPATCH:
				louie.disconnect(self._selected_update, signal, wipe=False)
		return UIItem.destroy(self)



]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb769080c>}
from __future__ import absolute_import, with_statement
from itertools import izip
from time import time
import peewee.messages as louie
from wyrecord.recording import RECORDING_STATUS_SCHEDULED, RECORDING_STATUS_RUNNING
from wyvas import Container, Image, render_lock
from peewee.formatters import seconds_to_hhmm
from pygui.facilities import timeslices as ts
from pygui.item.mediaitem.tv import RECS_TO_DISPLAY
from ..textblock import TextBlock
from .ui_items import UIItem
def adjust_durations(programs, min_duration=700, global_start_time=None, global_end_time=None):
	out = []
	missing_seconds = 0
	if not programs:
		return out
	if not global_start_time:
		pass
	global_start_time = global_start_time
	if not global_end_time:
		pass
	global_end_time = global_end_time
	midpoint = max(programs[len(programs) / 2].start_time, global_start_time)
	use_reverse = midpoint > (global_start_time + global_end_time) / 2
	if use_reverse:
		programs = reversed(programs)
	for prog in programs:
		prog_start_time = max(prog.start_time, global_start_time)
		prog_end_time = min(prog.end_time, global_end_time)
		prog_duration = prog_end_time - prog_start_time
		if use_reverse:
			end_time = prog_end_time - missing_seconds
		else:
			start_time = prog_start_time + missing_seconds
		if prog_duration < min_duration:
			duration = min_duration
			missing_seconds += min_duration - prog_duration
		else:
			duration = max(prog_duration - missing_seconds, min_duration)
			missing_seconds -= prog_duration - duration
		if use_reverse:
			start_time = end_time - duration
		else:
			end_time = start_time + duration
		out.append((start_time, end_time))
	if use_reverse:
		out.reverse()
	return out

class ProgramBlurb(Container):
	__doc__ = 'A widget that displays information about a single TV program:\n        - start time\n        - title\n    '
	def __init__(self, style, **kwargs):
		Container.__init__(self, **kwargs)
		self.start_time_display = TextBlock()
		self.title_display = TextBlock(max_width=style.get('maxlen', None))
		self.rec_icon = Image(repository=style['repository'], image_or_file=style['rec_icon'])
		self.rec_icon.set_keep_real_size(False)
		self.rec_status = False
		self.progress_bar = Container()
		self.progress_bar_fg = Image(repository=style['repository'], image_or_file=style['progress_bar_foreground'])
		self.progress_bar_fg.set_keep_real_size(False)
		self.progress_bar_bg = Image(repository=style['repository'], image_or_file=style['progress_bar_background'])
		self.progress_bar_bg.set_keep_real_size(False)
		self.progress_bar.add_child(self.progress_bar_bg, top='0%', left='0%', height='100%', width='100%', aspect=False)
		self.progress_bar.add_child(self.progress_bar_fg, top='0%', left='0%', height='100%', width='100%', aspect=False)
		bar_left, bar_top = style['progress_bar_offset']
		bar_width, bar_height = style['progress_bar_size']
		self.add_child(self.progress_bar, top=bar_top, left=bar_left, height=bar_height, width=bar_width, layer=-1)
		self.add_child(self.rec_icon, height='0%', width='0%')
		self.add_child(self.start_time_display)
		self.add_child(self.title_display)
		self.set_style(style)
		return None

	def set_style(self, style):
		self.start_time_display.set_style(style=style['time_font_style'])
		self.start_time_display.set_color(color=style['time_color'])
		time_left, time_top = style['time_offset']
		self.start_time_display.move(top=time_top, left=time_left)
		self.title_display.set_style(style=style['title_font_style'])
		self.title_display.set_color(color=style['title_color'])
		title_left, title_top = style['text_offset']
		title_width = '%i%%' % (100 - int(title_left.rstrip('%')))
		self.title_display.move(top=title_top, left=title_left)
		self.title_display.resize(width=title_width)
		rec_icon_left, rec_icon_top = style['rec_icon_offset']
		self.rec_icon.move(top=rec_icon_top, left=rec_icon_left)

	def set_progress(self, n):
		self.progress_bar_fg.resize(height='%i%%' % n)

	def set_record(self, record):
		if record and not self.rec_status:
			self.rec_icon.set_keep_real_size(True)
			self.rec_icon.resize(width='100%')
		else:
			if self.rec_status and not record:
				self.rec_icon.set_keep_real_size(False)
				self.rec_icon.resize(width='0%')
		self.rec_status = record

	def reset(self, start_time, name, record=False):
		self.start_time_display.set_text(seconds_to_hhmm(start_time))
		self.title_display.set_text(name)
		self.set_record(record)



class EPGItem(UIItem):
	__doc__ = 'A list item that displays an electronic program guide for one channel.'
	__slots__ = ['_selected', '_marked', '_position', '_edited', 'widget', 'style', 'channel', 'start_ts', 'end_ts', 'displayed_programs', 'adjusted_durations', 'selected_program', '_not_selected_widget', '_selected_widget', 'selection_cursor', 'blurbs', 'spare_selected_blurbs', 'spare_not_selected_blurbs', '__weakref__']
	not_selected_style = property((lambda self: {'repository': self.style['repository'], 'progress_bar_offset': self.style['progress_bar_offset'], 'progress_bar_size': self.style['progress_bar_size'], 'progress_bar_background': self.style['progress_bar_background'], 'progress_bar_foreground': self.style['progress_bar_foreground'], 'time_offset': self.style['time_offset'], 'time_font_style': self.style['time_font_style'], 'time_color': self.style['time_color'], 'title_font_style': self.style['title_font_style'], 'title_color': self.style['title_color'], 'text_offset': self.style['text_offset'], 'rec_icon': self.style['rec_icon'], 'rec_icon_offset': self.style['rec_icon_offset'], 'maxlen': self.style['maxlen']}))
	selected_style = property((lambda self: {'repository': self.style['repository'], 'progress_bar_offset': self.style['progress_bar_offset'], 'progress_bar_size': self.style['progress_bar_size'], 'progress_bar_background': self.style['progress_bar_background'], 'progress_bar_foreground': self.style['progress_bar_foreground'], 'time_offset': self.style['time_offset'], 'time_font_style': self.style['selected_time_font_style'], 'time_color': self.style['selected_time_color'], 'title_font_style': self.style['selected_title_font_style'], 'title_color': self.style['selected_title_color'], 'text_offset': self.style['selected_text_offset'], 'rec_icon': self.style['rec_icon'], 'rec_icon_offset': self.style['rec_icon_offset'], 'maxlen': self.style['maxlen']}))
	selected_program_style = property((lambda self: {'repository': self.style['repository'], 'time_offset': self.style['time_offset'], 'time_font_style': self.style['selected_time_font_style'], 'time_color': self.style['selected_blurb_time_color'], 'title_font_style': self.style['selected_title_font_style'], 'title_color': self.style['selected_blurb_title_color'], 'text_offset': self.style['selected_blurb_text_offset'], 'rec_icon': self.style['rec_icon'], 'rec_icon_offset': self.style['rec_icon_offset'], 'maxlen': self.style['maxlen']}))
	def set_boundaries(self, start_ts, end_ts):
		self.start_ts = start_ts
		self.end_ts = end_ts
		if self.channel:
			_[1], progs = render_lock.__exit__, self.channel.browse(start_ts, end_ts, limit=10, pad=True, focus=time())
		else:
			progs = []
		render_lock.__enter__()
		try:
			self.set_programs(progs)
			self.set_selected_program(-1)
		finally:
			del _[1]

	def set_programs(self, progs):
		ns_visible = self._not_selected_widget.get_visible()
		s_visible = self._selected_widget.get_visible()
		total_duration = self.end_ts - self.start_ts
		if 0 <= self.selected_program:
			pass
		else:
			self.selected_program
		if 0 <= self.selected_program:
			selected_program_item = self.displayed_programs[self.selected_program]
		else:
			selected_program_item = None
		old_programs = set(self.displayed_programs)
		self.displayed_programs[:] = progs
		for program in old_programs.difference(progs):
			selected_blurb, not_selected_blurb = self.blurbs.pop(program.id)
			if program is selected_program_item:
				selected_blurb.set_style(self.selected_style)
			selected_blurb.hide()
			selected_blurb.orphaned()
			self.spare_selected_blurbs.add(selected_blurb)
			not_selected_blurb.hide()
			not_selected_blurb.orphaned()
			self.spare_not_selected_blurbs.add(not_selected_blurb)
		self.adjusted_durations = adjust_durations(progs, global_start_time=self.start_ts, global_end_time=self.end_ts)
		for program, start_time in izip(progs, self.adjusted_durations):
			if program.start_time < self.start_ts:
				displayed_start_time, start_time = self.start_ts, self.start_ts
				name = u'\u2026\n%s' % program.name
			else:
				displayed_start_time = program.start_time
				name = program.name
			end_time = min(end_time, self.end_ts)
			top = (start_time - self.start_ts) / total_duration * 100
			height = (end_time - start_time) / total_duration * 100
			rec = program.recording_status in RECS_TO_DISPLAY
			if program in old_programs:
				selected_blurb, not_selected_blurb = self.blurbs[program.id]
				selected_blurb.reset(displayed_start_time, name, rec)
				selected_blurb.move(duration=0, top='%i%%' % top)
				selected_blurb.resize(duration=0, height='%i%%' % height)
				not_selected_blurb.reset(displayed_start_time, name, rec)
				not_selected_blurb.move(duration=0, top='%i%%' % top)
				not_selected_blurb.resize(duration=0, height='%i%%' % height)
				continue
			if self.spare_selected_blurbs and self.spare_not_selected_blurbs:
				selected_blurb = self.spare_selected_blurbs.pop()
				not_selected_blurb = self.spare_not_selected_blurbs.pop()
				selected_blurb.reset(displayed_start_time, name, rec)
				not_selected_blurb.reset(displayed_start_time, name, rec)
				selected_blurb.adopted(self._selected_widget)
				selected_blurb.move(top='%i%%' % top, left='0%')
				selected_blurb.resize(height='%i%%' % height, width='100%')
				selected_blurb.set_visible(s_visible)
				not_selected_blurb.adopted(self._not_selected_widget)
				not_selected_blurb.move(top='%i%%' % top, left='0%')
				not_selected_blurb.resize(height='%i%%' % height, width='100%')
				not_selected_blurb.set_visible(ns_visible)
				self.blurbs[program.id] = (selected_blurb, not_selected_blurb)
				continue
			selected_blurb = ProgramBlurb(self.selected_style)
			selected_blurb.reset(displayed_start_time, name, rec)
			not_selected_blurb = ProgramBlurb(self.not_selected_style)
			not_selected_blurb.reset(displayed_start_time, name, rec)
			self._not_selected_widget.add_child(not_selected_blurb, name=program.id, top='%i%%' % top, left='0%', height='%i%%' % height, width='100%')
			self._selected_widget.add_child(selected_blurb, name=program.id, top='%i%%' % top, left='0%', height='%i%%' % height, width='100%')
			self.blurbs[program.id] = (selected_blurb, not_selected_blurb)
		self._selected_widget.set_visible(s_visible)
		self._not_selected_widget.set_visible(ns_visible)
		self.update_progress(time())
		return None

	def set_selected_program(self, value):
		if not self.displayed_programs:
			pass
		total_duration = self.end_ts - self.start_ts
		animation_duration = self.style['duration']
		if 0 <= self.selected_program:
			pass
		else:
			self.selected_program
		if 0 <= self.selected_program:
			current_program = self.displayed_programs[self.selected_program]
			current_widget, _ = self.blurbs[current_program.id]
			start_time, end_time = self.adjusted_durations[self.selected_program]
			start_time = max(self.start_ts, start_time)
			end_time = min(end_time, self.end_ts)
			top = (start_time - self.start_ts) / total_duration * 100
			left = 0
			current_widget.set_style(self.selected_style)
			current_widget.move(duration=animation_duration, top='%i%%' % top, left='%i%%' % left)
			current_widget.resize(duration=animation_duration, width='100%')
		if 0 <= value:
			pass
		else:
			value
		if 0 <= value:
			new_program = self.displayed_programs[value]
			new_widget, _ = self.blurbs[new_program.id]
			start_time, end_time = self.adjusted_durations[value]
			start_time = max(self.start_ts, start_time)
			end_time = min(end_time, self.end_ts)
			left_offset, top_offset = <genexpr>(self.style['selected_blurb_offset'])
			top = (start_time - self.start_ts) / total_duration * 100 + top_offset
			left = left_offset
			new_widget.set_style(self.selected_program_style)
			new_widget.move(duration=animation_duration, top='%i%%' % top, left='%i%%' % left)
			new_widget.resize(duration=animation_duration, width=self.style['selected_blurb_zoom'])
			width, height = new_widget.get_size()
			self.selection_cursor.move(duration=animation_duration, top='%i%%' % top, left='%i%%' % left)
			self.selection_cursor.resize(duration=animation_duration, width=width, height=height)
			self.selection_cursor.set_visible(True)
		else:
			self.selection_cursor.set_visible(False)
		self.selected_program = value

	def update_progress(self, value):
		for prog in self.displayed_programs:
			selected_blurb, not_selected_blurb = self.blurbs[prog.id]
			start_ts, end_ts = max(prog.start_time, self.start_ts), min(prog.end_time, self.end_ts)
			if value < start_ts:
				progress = 0
			else:
				if value > end_ts:
					progress = 100
				else:
					duration = end_ts - start_ts
					elapsed = value - start_ts
					progress = float(elapsed) / duration * 100
			selected_blurb.set_progress(progress)
			not_selected_blurb.set_progress(progress)

	def update_record(self):
		prog = self.displayed_programs[self.selected_program]
		scheduled = bool(prog.recording_id)
		selected_blurb, not_selected_blurb = self.blurbs[prog.id]
		selected_blurb.set_record(scheduled)
		not_selected_blurb.set_record(scheduled)

	def reset(self, item, selected, position=None):
		if item is not None:
			self.channel = item
			if self.start_ts and self.end_ts:
				self.set_boundaries(self.start_ts, self.end_ts)
			else:
				start_ts, end_ts = map(ts.datetime_to_timestamp, ts.current_timeslice())
				self.set_boundaries(start_ts, end_ts)
				now = time()
				for i, prog in enumerate(self.displayed_programs):
					if prog.start_time <= now and prog.end_time >= now:
						self.set_selected_program(i)
						break
						continue
				else:
					self.set_selected_program(-1)
		else:
			self.widget.set_color(a=0)
		UIItem.reset(self, item, selected)
		return None

	def _create(self):
		not_sel_widget = Container()
		sel_widget = Container()
		self.channel = None
		self.displayed_programs = []
		self.selected_program = 0
		self.start_ts = 0
		self.end_ts = 0
		self.blurbs = {}
		self.spare_selected_blurbs = set()
		self.spare_not_selected_blurbs = set()
		selection_cursor = Image(image_or_file=self.style['selection_cursor_image'], repository=self.style['repository'])
		selection_cursor.set_keep_real_size(False)
		selection_cursor.set_color(a=0)
		sel_widget.add_child(selection_cursor, aspect=False)
		self.selection_cursor = selection_cursor
		item_width, item_height = self.style['item_size']
		self._not_selected_kwargs.update({'width': item_width, 'height': item_height})
		selected_item_width, selected_item_height = self.style['selected_item_size']
		self._selected_kwargs.update({'width': selected_item_width, 'height': selected_item_height})
		for signal in self._UPDATE_DISPATCH:
			louie.connect(self.update, signal)
		return (not_sel_widget, sel_widget)

	_UPDATE_DISPATCH = {'set_boundaries': set_boundaries, 'clock': update_progress}
	def update(self, signal, sender=None, *args, **args):
		self._UPDATE_DISPATCH[signal](self, *args, **kw)

	_SELECTED_UPDATE_DISPATCH = {'set_selected_program': set_selected_program, 'update_record': update_record}
	def _selected_update(self, signal, sender=None, *args, **args):
		self._SELECTED_UPDATE_DISPATCH[signal](self, *args, **kw)

	def _set_selected(self, selected, *args, **args):
		if selected:
			for signal in self._SELECTED_UPDATE_DISPATCH:
				louie.connect(self._selected_update, signal)
		else:
			if self.selected:
				for signal in self._SELECTED_UPDATE_DISPATCH:
					louie.disconnect(self._selected_update, signal, wipe=False)
				self.set_selected_program(-1)
		if selected:
			pass
		self.selection_cursor.set_color(a=0)
		UIItem._set_selected(self, selected, *args, **kw)

	def destroy(self):
		if self.selected:
			self.selection_cursor.set_visible(False)
			for signal in self._SELECTED_UPDATE_DISPATCH:
				louie.disconnect(self._selected_update, signal, wipe=False)
		return UIItem.destroy(self)



