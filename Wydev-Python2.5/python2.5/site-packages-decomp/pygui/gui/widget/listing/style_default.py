# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 188
n 188(None)[return None
]:
	i: 132(), 187()
	o: 

nname: 187
n 187(None)[]:
	i: 36(f)
	o: 188()

nname: 132
n 132(None)[self._bar.animate('move', vcenter=self.positions_list[il.selected - il.start]._y, duration=self.duration)
]:
	i: 36(t)
	o: 188()

nname: 36
n 36(self._bar is not None)[il = self.item_list
nb_positions = len(il)
il.selected = self.menu_list.selected_pos
il.start = max(0, il.selected // nb_positions * nb_positions)
il.end = il.start + nb_positions
]:
	i: 21(), 35()
	o: 132(t), 187(f)

nname: 35
n 35(None)[]:
	i: 0(t)
	o: 36()

nname: 21
n 21(None)[return self.do_reset()
]:
	i: 0(f)
	o: 36()

nname: 0
n 0(GenericListing._swap_items(self, i1, i2))[]:
	i: 
	o: 21(f), 35(t)

nname: 188
n 188(None)[return None
]:
	i: 0()
	o: 

nname: 0
n 0(None)[if not GenericListing._swap_items(self, i1, i2):
	return self.do_reset()
il = self.item_list
nb_positions = len(il)
il.selected = self.menu_list.selected_pos
il.start = max(0, il.selected // nb_positions * nb_positions)
il.end = il.start + nb_positions
if self._bar is not None:
	self._bar.animate('move', vcenter=self.positions_list[il.selected - il.start]._y, duration=self.duration)
]:
	i: 
	o: 188()

nname: 0
n 0(None)[if not GenericListing._swap_items(self, i1, i2):
	return self.do_reset()
il = self.item_list
nb_positions = len(il)
il.selected = self.menu_list.selected_pos
il.start = max(0, il.selected // nb_positions * nb_positions)
il.end = il.start + nb_positions
if self._bar is not None:
	self._bar.animate('move', vcenter=self.positions_list[il.selected - il.start]._y, duration=self.duration)
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb77349cc>}
nname: 171
n 171(None)[]:
	i: 96(), 129(), 170(AE)
	o: 

nname: 129
n 129(None)[log.error('Unknown page_jump type: %s', self.style_dict['page_jump'])
self._pagejump_func = self._pagejump_reset
]:
	i: 18(except)
	o: 171()

nname: 96
n 96(None)[self._pagejump_func = getattr(self, '_pagejump_' + self.style_dict['page_jump'])
]:
	i: 18(try)
	o: 171()

nname: 18
n 18(None)[self._initialized = True
nb_items = len(self.positions_list)
start = max(0, self.menu_list.selected_pos // nb_items * nb_items)
GenericListing._create_content(self, start, self.style_name)
]:
	i: 9(), 17()
	o: 96(try), 129(except)

nname: 17
n 17(None)[]:
	i: 0(f)
	o: 18()

nname: 9
n 9(None)[]:
	i: 0(t)
	o: 18()

nname: 0
n 0(self._initialized)[]:
	i: 
	o: 9(t), 17(f)

nname: 171
n 171(None)[]:
	i: 96()
	o: 

nname: 96
n 96(None)[try:
	self._pagejump_func = getattr(self, '_pagejump_' + self.style_dict['page_jump'])
except:
	log.error('Unknown page_jump type: %s', self.style_dict['page_jump'])
	self._pagejump_func = self._pagejump_reset
]:
	i: 0(try)
	o: 171()

nname: 0
n 0(None)[if self._initialized:
	pass
self._initialized = True
nb_items = len(self.positions_list)
start = max(0, self.menu_list.selected_pos // nb_items * nb_items)
GenericListing._create_content(self, start, self.style_name)
]:
	i: 
	o: 96(try)

nname: 171
n 171(None)[]:
	i: 0()
	o: 

nname: 0
n 0(None)[if self._initialized:
	pass
self._initialized = True
nb_items = len(self.positions_list)
start = max(0, self.menu_list.selected_pos // nb_items * nb_items)
GenericListing._create_content(self, start, self.style_name)
try:
	self._pagejump_func = getattr(self, '_pagejump_' + self.style_dict['page_jump'])
except:
	log.error('Unknown page_jump type: %s', self.style_dict['page_jump'])
	self._pagejump_func = self._pagejump_reset
]:
	i: 
	o: 171()

nname: 0
n 0(None)[if self._initialized:
	pass
self._initialized = True
nb_items = len(self.positions_list)
start = max(0, self.menu_list.selected_pos // nb_items * nb_items)
GenericListing._create_content(self, start, self.style_name)
try:
	self._pagejump_func = getattr(self, '_pagejump_' + self.style_dict['page_jump'])
except:
	log.error('Unknown page_jump type: %s', self.style_dict['page_jump'])
	self._pagejump_func = self._pagejump_reset
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7734fac>}
nname: 655
n 655(None)[return None
]:
	i: 628(), 654()
	o: 

nname: 654
n 654(None)[]:
	i: 619(f)
	o: 655()

nname: 628
n 628(None)[self._edited = False
self.do_edit(True)
]:
	i: 619(t)
	o: 655()

nname: 619
n 619(self._edited)[]:
	i: 536(JA), 601(), 618()
	o: 628(t), 654(f)

nname: 618
n 618(None)[]:
	i: 471(f)
	o: 619()

nname: 601
n 601(None)[self._bar.hide()
]:
	i: 496&509&525(f)
	o: 619()

nname: 536
n 536(None)[self._bar.animate('move', vcenter=self.positions_list[il.selected - il.start]._y, duration=0)
self._bar.show()
]:
	i: 496&509&525(t)
	o: 619(JA)

nname: 496&509&525
n 496&509&525(len(ml) and il.selected >= 0 and not self._no_selection)[]:
	i: 471(t)
	o: 536(t), 601(f)

nname: 471
n 471(self._bar is not None)[self._refresh_more_items()
]:
	i: 155(JA), 192(JA), 233(), 441()
	o: 496&509&525(t), 618(f)

nname: 441
n 441(None)[il.selected = ml.selected_pos
il.start = start
il.end = end
]:
	i: 265(AL), 440()
	o: 471()

nname: 440
n 440(None)[]:
	i: 269(AF), 411()
	o: 441()

nname: 411
n 411(None)[ui_item.widget.animate_stop()
pos.put(ui_item)
]:
	i: 337(), 378()
	o: 440()

nname: 378
n 378(None)[sel_val = menu_item is selected
ui_item.reset(menu_item, sel_val, position=start + i + 1)
]:
	i: 361(), 368()
	o: 411()

nname: 368
n 368(None)[]:
	i: 351(f)
	o: 378()

nname: 361
n 361(None)[]:
	i: 351(t)
	o: 378()

nname: 351
n 351(self._no_selection)[]:
	i: 307(f)
	o: 361(t), 368(f)

nname: 337
n 337(None)[ui_item.destroy()
]:
	i: 307(t)
	o: 411()

nname: 307
n 307(menu_item is None)[for i, pos in enumerate(map(None, self.positions_list, il, ml[start:end])):
]:
	i: 269(for)
	o: 337(t), 351(f)

nname: 269
n 269(None)[]:
	i: 265(loop)
	o: 307(for), 440(AF)

nname: 265
n 265(None)[]:
	i: 44(f)
	o: 269(loop), 441(AL)

nname: 233
n 233(None)[sel_val = menu_item is selected
ui_item.reset(menu_item, sel_val, position=position + 1)
]:
	i: 216(), 223()
	o: 471()

nname: 223
n 223(None)[]:
	i: 206(f)
	o: 233()

nname: 216
n 216(None)[]:
	i: 206(t)
	o: 233()

nname: 206
n 206(self._no_selection)[]:
	i: 180(f)
	o: 216(t), 223(f)

nname: 192
n 192(None)[ui_item.destroy()
]:
	i: 180(t)
	o: 471(JA)

nname: 180
n 180(menu_item is None)[]:
	i: 117(), 178(AE)
	o: 192(t), 206(f)

nname: 178
n 178(None)[]:
	i: 145(f)
	o: 180(AE)

nname: 155
n 155(None)[log.warn('Trying to reset an out-of-screen item. position: %s', position)
]:
	i: 145(t)
	o: 471(JA)

nname: 145
n 145(<dummy_ex3> EXC_MATCH IndexError)[]:
	i: 113(except)
	o: 155(t), 178(f)

nname: 117
n 117(None)[menu_item = ml[position]
ui_item = il[position - start]
]:
	i: 113(try)
	o: 180()

nname: 113
n 113(None)[]:
	i: 44(t)
	o: 117(try), 145(except)

nname: 44
n 44(position is not None)[nb_items = len(self.positions_list)
start = max(0, focus // nb_items * nb_items)
end = start + nb_items
selected = ml.selected
]:
	i: 30(), 43()
	o: 113(t), 265(f)

nname: 43
n 43(None)[]:
	i: 0(f)
	o: 44()

nname: 30
n 30(None)[focus = ml.selected_pos
]:
	i: 0(t)
	o: 44()

nname: 0
n 0(focus is None)[ml = self.menu_list
il = self.item_list
]:
	i: 
	o: 30(t), 43(f)

nname: 655
n 655(None)[return None
]:
	i: 471()
	o: 

nname: 471
n 471(None)[self._refresh_more_items()
if self._bar is not None:
	if len(ml) and il.selected >= 0 and not self._no_selection:
		self._bar.animate('move', vcenter=self.positions_list[il.selected - il.start]._y, duration=0)
		self._bar.show()
	else:
		self._bar.hide()
if self._edited:
	self._edited = False
	self.do_edit(True)
]:
	i: 155(JA), 192(JA), 206(), 441(), 145(f)
	o: 655()

nname: 441
n 441(None)[il.selected = ml.selected_pos
il.start = start
il.end = end
]:
	i: 265(AL), 269(AF), 411()
	o: 471()

nname: 411
n 411(None)[ui_item.widget.animate_stop()
pos.put(ui_item)
]:
	i: 337(), 351()
	o: 441()

nname: 351
n 351(None)[if self._no_selection:
	pass
sel_val = menu_item is selected
ui_item.reset(menu_item, sel_val, position=start + i + 1)
]:
	i: 307(f)
	o: 411()

nname: 337
n 337(None)[ui_item.destroy()
]:
	i: 307(t)
	o: 411()

nname: 307
n 307(menu_item is None)[for i, pos in enumerate(map(None, self.positions_list, il, ml[start:end])):
]:
	i: 269(for)
	o: 337(t), 351(f)

nname: 269
n 269(None)[]:
	i: 265(loop)
	o: 307(for), 441(AF)

nname: 265
n 265(None)[]:
	i: 0(f)
	o: 269(loop), 441(AL)

nname: 155
n 155(None)[log.warn('Trying to reset an out-of-screen item. position: %s', position)
]:
	i: 145(t)
	o: 471(JA)

nname: 145
n 145(<dummy_ex3> EXC_MATCH IndexError)[]:
	i: 113(except)
	o: 155(t), 471(f)

nname: 206
n 206(None)[if self._no_selection:
	pass
sel_val = menu_item is selected
ui_item.reset(menu_item, sel_val, position=position + 1)
]:
	i: 180(f)
	o: 471()

nname: 192
n 192(None)[ui_item.destroy()
]:
	i: 180(t)
	o: 471(JA)

nname: 180
n 180(menu_item is None)[]:
	i: 117(), 178(AE)
	o: 192(t), 206(f)

nname: 117
n 117(None)[menu_item = ml[position]
ui_item = il[position - start]
]:
	i: 113(try)
	o: 180()

nname: 113
n 113(None)[]:
	i: 0(t)
	o: 117(try), 145(except)

nname: 0
n 0(position is not None)[ml = self.menu_list
il = self.item_list
if focus is None:
	focus = ml.selected_pos
nb_items = len(self.positions_list)
start = max(0, focus // nb_items * nb_items)
end = start + nb_items
selected = ml.selected
]:
	i: 
	o: 113(t), 265(f)

nname: 471
n 471(None)[self._refresh_more_items()
if self._bar is not None:
	if len(ml) and il.selected >= 0 and not self._no_selection:
		self._bar.animate('move', vcenter=self.positions_list[il.selected - il.start]._y, duration=0)
		self._bar.show()
	else:
		self._bar.hide()
if self._edited:
	self._edited = False
	self.do_edit(True)
return None
]:
	i: 145(JA), 441()
	o: 

nname: 441
n 441(None)[il.selected = ml.selected_pos
il.start = start
il.end = end
]:
	i: 265(AL), 269(AF), 307()
	o: 471()

nname: 307
n 307(None)[for i, pos in enumerate(map(None, self.positions_list, il, ml[start:end])):
if menu_item is None:
	ui_item.destroy()
else:
	if self._no_selection:
		pass
	sel_val = menu_item is selected
	ui_item.reset(menu_item, sel_val, position=start + i + 1)
ui_item.widget.animate_stop()
pos.put(ui_item)
]:
	i: 269(for)
	o: 441()

nname: 269
n 269(None)[]:
	i: 265(loop)
	o: 307(for), 441(AF)

nname: 265
n 265(None)[]:
	i: 0(f)
	o: 269(loop), 441(AL)

nname: 145
n 145(None)[except IndexError:
	log.warn('Trying to reset an out-of-screen item. position: %s', position)
else:
	if menu_item is None:
		ui_item.destroy()
	else:
		if self._no_selection:
			pass
		sel_val = menu_item is selected
		ui_item.reset(menu_item, sel_val, position=position + 1)
]:
	i: 113()
	o: 471(JA)

nname: 113
n 113(None)[try:
	menu_item = ml[position]
	ui_item = il[position - start]
]:
	i: 0(t)
	o: 145()

nname: 0
n 0(position is not None)[ml = self.menu_list
il = self.item_list
if focus is None:
	focus = ml.selected_pos
nb_items = len(self.positions_list)
start = max(0, focus // nb_items * nb_items)
end = start + nb_items
selected = ml.selected
]:
	i: 
	o: 113(t), 265(f)

nname: 471
n 471(None)[self._refresh_more_items()
if self._bar is not None:
	if len(ml) and il.selected >= 0 and not self._no_selection:
		self._bar.animate('move', vcenter=self.positions_list[il.selected - il.start]._y, duration=0)
		self._bar.show()
	else:
		self._bar.hide()
if self._edited:
	self._edited = False
	self.do_edit(True)
return None
]:
	i: 113(JA), 307()
	o: 

nname: 307
n 307(None)[for i, pos in enumerate(map(None, self.positions_list, il, ml[start:end])):
	if menu_item is None:
		ui_item.destroy()
	else:
		if self._no_selection:
			pass
		sel_val = menu_item is selected
		ui_item.reset(menu_item, sel_val, position=start + i + 1)
	ui_item.widget.animate_stop()
	pos.put(ui_item)
il.selected = ml.selected_pos
il.start = start
il.end = end
]:
	i: 265(for)
	o: 471()

nname: 265
n 265(None)[]:
	i: 0(f)
	o: 307(for)

nname: 113
n 113(None)[try:
	menu_item = ml[position]
	ui_item = il[position - start]
except IndexError:
	log.warn('Trying to reset an out-of-screen item. position: %s', position)
else:
	if menu_item is None:
		ui_item.destroy()
	else:
		if self._no_selection:
			pass
		sel_val = menu_item is selected
		ui_item.reset(menu_item, sel_val, position=position + 1)
]:
	i: 0(t)
	o: 471(JA)

nname: 0
n 0(position is not None)[ml = self.menu_list
il = self.item_list
if focus is None:
	focus = ml.selected_pos
nb_items = len(self.positions_list)
start = max(0, focus // nb_items * nb_items)
end = start + nb_items
selected = ml.selected
]:
	i: 
	o: 113(t), 265(f)

nname: 471
n 471(None)[self._refresh_more_items()
if self._bar is not None:
	if len(ml) and il.selected >= 0 and not self._no_selection:
		self._bar.animate('move', vcenter=self.positions_list[il.selected - il.start]._y, duration=0)
		self._bar.show()
	else:
		self._bar.hide()
if self._edited:
	self._edited = False
	self.do_edit(True)
return None
]:
	i: 113(JA), 265()
	o: 

nname: 265
n 265(None)[for i, pos in enumerate(map(None, self.positions_list, il, ml[start:end])):
	if menu_item is None:
		ui_item.destroy()
	else:
		if self._no_selection:
			pass
		sel_val = menu_item is selected
		ui_item.reset(menu_item, sel_val, position=start + i + 1)
	ui_item.widget.animate_stop()
	pos.put(ui_item)
il.selected = ml.selected_pos
il.start = start
il.end = end
]:
	i: 0(f)
	o: 471()

nname: 113
n 113(None)[try:
	menu_item = ml[position]
	ui_item = il[position - start]
except IndexError:
	log.warn('Trying to reset an out-of-screen item. position: %s', position)
else:
	if menu_item is None:
		ui_item.destroy()
	else:
		if self._no_selection:
			pass
		sel_val = menu_item is selected
		ui_item.reset(menu_item, sel_val, position=position + 1)
]:
	i: 0(t)
	o: 471(JA)

nname: 0
n 0(position is not None)[ml = self.menu_list
il = self.item_list
if focus is None:
	focus = ml.selected_pos
nb_items = len(self.positions_list)
start = max(0, focus // nb_items * nb_items)
end = start + nb_items
selected = ml.selected
]:
	i: 
	o: 113(t), 265(f)

nname: 0
n 0(None)[ml = self.menu_list
il = self.item_list
if focus is None:
	focus = ml.selected_pos
nb_items = len(self.positions_list)
start = max(0, focus // nb_items * nb_items)
end = start + nb_items
selected = ml.selected
if position is not None:
	try:
		menu_item = ml[position]
		ui_item = il[position - start]
	except IndexError:
		log.warn('Trying to reset an out-of-screen item. position: %s', position)
	else:
		if menu_item is None:
			ui_item.destroy()
		else:
			if self._no_selection:
				pass
			sel_val = menu_item is selected
			ui_item.reset(menu_item, sel_val, position=position + 1)
else:
	for i, pos in enumerate(map(None, self.positions_list, il, ml[start:end])):
		if menu_item is None:
			ui_item.destroy()
		else:
			if self._no_selection:
				pass
			sel_val = menu_item is selected
			ui_item.reset(menu_item, sel_val, position=start + i + 1)
		ui_item.widget.animate_stop()
		pos.put(ui_item)
	il.selected = ml.selected_pos
	il.start = start
	il.end = end
self._refresh_more_items()
if self._bar is not None:
	if len(ml) and il.selected >= 0 and not self._no_selection:
		self._bar.animate('move', vcenter=self.positions_list[il.selected - il.start]._y, duration=0)
		self._bar.show()
	else:
		self._bar.hide()
if self._edited:
	self._edited = False
	self.do_edit(True)
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7747ccc>}
nname: 283
n 283(None)[il[sel_idx].selected = True
return None
]:
	i: 220(JA), 237(), 282()
	o: 

nname: 282
n 282(None)[]:
	i: 110(f)
	o: 283()

nname: 237
n 237(None)[self._bar.animate('move', vcenter=self.positions_list[sel_idx]._y, duration=self.duration)
]:
	i: 204(f)
	o: 283()

nname: 220
n 220(None)[self._bar.hide()
]:
	i: 204(t)
	o: 283(JA)

nname: 204
n 204(ml.selected is None)[]:
	i: 110(t)
	o: 220(t), 237(f)

nname: 110
n 110(self._bar is not None)[GenericListing._remove_item(self, position, True)
il.selected = ml.selected_pos
il.start = start
il.end = start + nb_items
GenericListing._refresh_more_items(self)
sel_idx = ml.selected_pos - start
]:
	i: 101(), 109()
	o: 204(t), 282(f)

nname: 109
n 109(None)[]:
	i: 86(f)
	o: 110()

nname: 101
n 101(None)[return None
]:
	i: 86(t)
	o: 110()

nname: 86
n 86(position >= il.end)[]:
	i: 71(), 85()
	o: 101(t), 109(f)

nname: 85
n 85(None)[]:
	i: 0(f)
	o: 86()

nname: 71
n 71(None)[return self.do_reset()
]:
	i: 0(t)
	o: 86()

nname: 0
n 0(start != il.start)[ml = self.menu_list
il = self.item_list
nb_items = len(il)
start = max(0, ml.selected_pos // nb_items * nb_items)
]:
	i: 
	o: 71(t), 85(f)

nname: 110
n 110(None)[GenericListing._remove_item(self, position, True)
il.selected = ml.selected_pos
il.start = start
il.end = start + nb_items
GenericListing._refresh_more_items(self)
sel_idx = ml.selected_pos - start
if self._bar is not None:
	if ml.selected is None:
		self._bar.hide()
	else:
		self._bar.animate('move', vcenter=self.positions_list[sel_idx]._y, duration=self.duration)
il[sel_idx].selected = True
return None
]:
	i: 0()
	o: 

nname: 0
n 0(None)[ml = self.menu_list
il = self.item_list
nb_items = len(il)
start = max(0, ml.selected_pos // nb_items * nb_items)
if start != il.start:
	return self.do_reset()
if position >= il.end:
	return None
]:
	i: 
	o: 110()

nname: 0
n 0(None)[ml = self.menu_list
il = self.item_list
nb_items = len(il)
start = max(0, ml.selected_pos // nb_items * nb_items)
if start != il.start:
	return self.do_reset()
if position >= il.end:
	return None
GenericListing._remove_item(self, position, True)
il.selected = ml.selected_pos
il.start = start
il.end = start + nb_items
GenericListing._refresh_more_items(self)
sel_idx = ml.selected_pos - start
if self._bar is not None:
	if ml.selected is None:
		self._bar.hide()
	else:
		self._bar.animate('move', vcenter=self.positions_list[sel_idx]._y, duration=self.duration)
il[sel_idx].selected = True
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7734cac>}
nname: 486
n 486(None)[return None
]:
	i: 381(JA), 436(), 485()
	o: 

nname: 485
n 485(None)[]:
	i: 307(f)
	o: 486()

nname: 436
n 436(None)[self._bar.animate('move', vcenter=self.positions_list[position - start]._y, duration=self.duration)
]:
	i: 374(f)
	o: 486()

nname: 381
n 381(None)[self._bar.animate('move', vcenter=self.positions_list[0]._y, duration=0)
self._bar.show()
]:
	i: 374(t)
	o: 486(JA)

nname: 374
n 374(il_get_focused)[]:
	i: 307(t)
	o: 381(t), 436(f)

nname: 307
n 307(self._bar is not None)[il_get_focused = il.selected == -1
il.selected = position
il.start = start
il.end = end
self._refresh_more_items()
]:
	i: 171(), 285(), 306()
	o: 374(t), 485(f)

nname: 306
n 306(None)[]:
	i: 271&274(f)
	o: 307()

nname: 285
n 285(None)[il[position % nb_positions].selected = True
]:
	i: 271&274(t)
	o: 307()

nname: 271&274
n 271&274(start <= position and not self._no_selection)[]:
	i: 259(), 269()
	o: 285(t), 306(f)

nname: 269
n 269(None)[position
]:
	i: 245(f)
	o: 271&274()

nname: 259
n 259(None)[]:
	i: 245(t)
	o: 271&274()

nname: 245
n 245(start <= position)[]:
	i: 227(), 244()
	o: 259(t), 269(f)

nname: 244
n 244(None)[]:
	i: 191(f)
	o: 245()

nname: 227
n 227(None)[il[idx].selected = False
]:
	i: 191(t)
	o: 245()

nname: 191
n 191(il[idx].selected)[idx = max(0, il.selected) % nb_positions
]:
	i: 156(f)
	o: 227(t), 244(f)

nname: 171
n 171(None)[self._pagejump_func(start, end)
]:
	i: 156(t)
	o: 307()

nname: 156
n 156(il.start != start)[]:
	i: 138(), 155()
	o: 171(t), 191(f)

nname: 155
n 155(None)[]:
	i: 81(f)
	o: 156()

nname: 138
n 138(None)[log.warn('Changing selection while editing')
]:
	i: 81(t)
	o: 156()

nname: 81
n 81(self._edited)[nb_positions = len(self.positions_list)
start = max(0, focus // nb_positions * nb_positions)
end = start + nb_positions
]:
	i: 71(), 80()
	o: 138(t), 155(f)

nname: 80
n 80(None)[]:
	i: 0(f)
	o: 81()

nname: 71
n 71(None)[focus = position
]:
	i: 62(), 70()
	o: 81()

nname: 70
n 70(None)[]:
	i: 30&46(f)
	o: 71()

nname: 62
n 62(None)[return True
]:
	i: 30&46(t)
	o: 71()

nname: 30&46
n 30&46(ml.selected is None or il.selected == position)[]:
	i: 0(t)
	o: 62(t), 70(f)

nname: 0
n 0(focus is None)[il = self.item_list
ml = self.menu_list
]:
	i: 
	o: 30&46(t), 80(f)

nname: 307
n 307(None)[il_get_focused = il.selected == -1
il.selected = position
il.start = start
il.end = end
self._refresh_more_items()
if self._bar is not None:
	if il_get_focused:
		self._bar.animate('move', vcenter=self.positions_list[0]._y, duration=0)
		self._bar.show()
	else:
		self._bar.animate('move', vcenter=self.positions_list[position - start]._y, duration=self.duration)
return None
]:
	i: 171(), 271&274()
	o: 

nname: 271&274
n 271&274(None)[if start <= position and not self._no_selection:
	il[position % nb_positions].selected = True
]:
	i: 191()
	o: 307()

nname: 191
n 191(None)[idx = max(0, il.selected) % nb_positions
if il[idx].selected:
	il[idx].selected = False
if start <= position:
	pass
else:
	position
]:
	i: 81(f)
	o: 271&274()

nname: 171
n 171(None)[self._pagejump_func(start, end)
]:
	i: 81(t)
	o: 307()

nname: 81
n 81(il.start != start)[nb_positions = len(self.positions_list)
start = max(0, focus // nb_positions * nb_positions)
end = start + nb_positions
if self._edited:
	log.warn('Changing selection while editing')
]:
	i: 30&46(), 0(f)
	o: 171(t), 191(f)

nname: 30&46
n 30&46(None)[if ml.selected is None or il.selected == position:
	return True
focus = position
]:
	i: 0(t)
	o: 81()

nname: 0
n 0(focus is None)[il = self.item_list
ml = self.menu_list
]:
	i: 
	o: 30&46(t), 81(f)

nname: 307
n 307(None)[il_get_focused = il.selected == -1
il.selected = position
il.start = start
il.end = end
self._refresh_more_items()
if self._bar is not None:
	if il_get_focused:
		self._bar.animate('move', vcenter=self.positions_list[0]._y, duration=0)
		self._bar.show()
	else:
		self._bar.animate('move', vcenter=self.positions_list[position - start]._y, duration=self.duration)
return None
]:
	i: 171(), 191()
	o: 

nname: 191
n 191(None)[idx = max(0, il.selected) % nb_positions
if il[idx].selected:
	il[idx].selected = False
if start <= position:
	pass
else:
	position
if start <= position and not self._no_selection:
	il[position % nb_positions].selected = True
]:
	i: 0(f)
	o: 307()

nname: 171
n 171(None)[self._pagejump_func(start, end)
]:
	i: 0(t)
	o: 307()

nname: 0
n 0(il.start != start)[il = self.item_list
ml = self.menu_list
if focus is None:
	if ml.selected is None or il.selected == position:
		return True
	focus = position
nb_positions = len(self.positions_list)
start = max(0, focus // nb_positions * nb_positions)
end = start + nb_positions
if self._edited:
	log.warn('Changing selection while editing')
]:
	i: 
	o: 171(t), 191(f)

nname: 0
n 0(None)[il = self.item_list
ml = self.menu_list
if focus is None:
	if ml.selected is None or il.selected == position:
		return True
	focus = position
nb_positions = len(self.positions_list)
start = max(0, focus // nb_positions * nb_positions)
end = start + nb_positions
if self._edited:
	log.warn('Changing selection while editing')
if il.start != start:
	self._pagejump_func(start, end)
else:
	idx = max(0, il.selected) % nb_positions
	if il[idx].selected:
		il[idx].selected = False
	if start <= position:
		pass
	else:
		position
	if start <= position and not self._no_selection:
		il[position % nb_positions].selected = True
il_get_focused = il.selected == -1
il.selected = position
il.start = start
il.end = end
self._refresh_more_items()
if self._bar is not None:
	if il_get_focused:
		self._bar.animate('move', vcenter=self.positions_list[0]._y, duration=0)
		self._bar.show()
	else:
		self._bar.animate('move', vcenter=self.positions_list[position - start]._y, duration=self.duration)
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7742d0c>}
nname: 161
n 161(None)[return None
]:
	i: 0(AL), 160()
	o: 

nname: 160
n 160(None)[]:
	i: 31(AF), 147()
	o: 161()

nname: 147
n 147(None)[it_pos += 1
]:
	i: 81(), 122()
	o: 160()

nname: 122
n 122(None)[sel_val = menu_item is selected
ui_item.reset(menu_item, sel_val, position=it_pos)
]:
	i: 105(), 112()
	o: 147()

nname: 112
n 112(None)[]:
	i: 95(f)
	o: 122()

nname: 105
n 105(None)[]:
	i: 95(t)
	o: 122()

nname: 95
n 95(self._no_selection)[]:
	i: 60(f)
	o: 105(t), 112(f)

nname: 81
n 81(None)[ui_item.destroy()
]:
	i: 60(t)
	o: 147()

nname: 60
n 60(menu_item is None)[for ui_item, menu_item in map(None, self.item_list, ml[start:end]):
]:
	i: 31(for)
	o: 81(t), 95(f)

nname: 31
n 31(None)[]:
	i: 0(loop)
	o: 60(for), 160(AF)

nname: 0
n 0(None)[ml = self.menu_list
selected = ml.selected
it_pos = start + 1
]:
	i: 
	o: 31(loop), 161(AL)

nname: 161
n 161(None)[return None
]:
	i: 0(AL), 31(AF), 147()
	o: 

nname: 147
n 147(None)[it_pos += 1
]:
	i: 81(), 95()
	o: 161()

nname: 95
n 95(None)[if self._no_selection:
	pass
sel_val = menu_item is selected
ui_item.reset(menu_item, sel_val, position=it_pos)
]:
	i: 60(f)
	o: 147()

nname: 81
n 81(None)[ui_item.destroy()
]:
	i: 60(t)
	o: 147()

nname: 60
n 60(menu_item is None)[for ui_item, menu_item in map(None, self.item_list, ml[start:end]):
]:
	i: 31(for)
	o: 81(t), 95(f)

nname: 31
n 31(None)[]:
	i: 0(loop)
	o: 60(for), 161(AF)

nname: 0
n 0(None)[ml = self.menu_list
selected = ml.selected
it_pos = start + 1
]:
	i: 
	o: 31(loop), 161(AL)

nname: 161
n 161(None)[return None
]:
	i: 0(AL), 31(AF), 60()
	o: 

nname: 60
n 60(None)[for ui_item, menu_item in map(None, self.item_list, ml[start:end]):
if menu_item is None:
	ui_item.destroy()
else:
	if self._no_selection:
		pass
	sel_val = menu_item is selected
	ui_item.reset(menu_item, sel_val, position=it_pos)
it_pos += 1
]:
	i: 31(for)
	o: 161()

nname: 31
n 31(None)[]:
	i: 0(loop)
	o: 60(for), 161(AF)

nname: 0
n 0(None)[ml = self.menu_list
selected = ml.selected
it_pos = start + 1
]:
	i: 
	o: 31(loop), 161(AL)

nname: 60
n 60(None)[for ui_item, menu_item in map(None, self.item_list, ml[start:end]):
	if menu_item is None:
		ui_item.destroy()
	else:
		if self._no_selection:
			pass
		sel_val = menu_item is selected
		ui_item.reset(menu_item, sel_val, position=it_pos)
	it_pos += 1
return None
]:
	i: 0(for)
	o: 

nname: 0
n 0(None)[ml = self.menu_list
selected = ml.selected
it_pos = start + 1
]:
	i: 
	o: 60(for)

nname: 0
n 0(None)[ml = self.menu_list
selected = ml.selected
it_pos = start + 1
for ui_item, menu_item in map(None, self.item_list, ml[start:end]):
	if menu_item is None:
		ui_item.destroy()
	else:
		if self._no_selection:
			pass
		sel_val = menu_item is selected
		ui_item.reset(menu_item, sel_val, position=it_pos)
	it_pos += 1
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb77347ec>}
nname: 26
n 26(None)[selected = self.menu_list.selected
move = start - self.item_list.start
GenericListing._scroll(self, move, self.duration * 2, selected)
return None
]:
	i: 9(), 16()
	o: 

nname: 16
n 16(None)[]:
	i: 0(f)
	o: 26()

nname: 9
n 9(None)[]:
	i: 0(t)
	o: 26()

nname: 0
n 0(self._no_selection)[]:
	i: 
	o: 9(t), 16(f)

nname: 0
n 0(None)[if self._no_selection:
	pass
selected = self.menu_list.selected
move = start - self.item_list.start
GenericListing._scroll(self, move, self.duration * 2, selected)
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb773436c>}
nname: 475
n 475(None)[return None
]:
	i: 355(AL), 474()
	o: 

nname: 474
n 474(None)[]:
	i: 371(AF), 387()
	o: 475()

nname: 387
n 387(None)[for pos, ui_menu_item in zip(pl, it_map):
animate = ui_menu_item[0].widget.animate
animate('move', duration=0, **{align_type: enter_by})
animate('move', duration=long_duration, **{align_type: pos._y})
]:
	i: 371(for)
	o: 474()

nname: 371
n 371(None)[]:
	i: 355(loop)
	o: 387(for), 474(AF)

nname: 355
n 355(None)[sleep(self.duration)
]:
	i: 154(AL), 354()
	o: 371(loop), 475(AL)

nname: 354
n 354(None)[]:
	i: 217(AF), 317()
	o: 355()

nname: 317
n 317(None)[ui_item.widget.animate('move', duration=long_duration, **{align_type: exit_by})
]:
	i: 245(), 286()
	o: 354()

nname: 286
n 286(None)[sel_val = menu_item is selected
ui_item.reset(menu_item, sel_val, position=it_pos.next())
]:
	i: 269(), 276()
	o: 317()

nname: 276
n 276(None)[]:
	i: 259(f)
	o: 286()

nname: 269
n 269(None)[]:
	i: 259(t)
	o: 286()

nname: 259
n 259(self._no_selection)[]:
	i: 224(f)
	o: 269(t), 276(f)

nname: 245
n 245(None)[ui_item.destroy()
]:
	i: 224(t)
	o: 317()

nname: 224
n 224(menu_item is None)[for ui_item, menu_item in it_map:
]:
	i: 217(for)
	o: 245(t), 259(f)

nname: 217
n 217(None)[]:
	i: 154(loop)
	o: 224(for), 354(AF)

nname: 154
n 154(None)[it_pos = iter(xrange(start + 1, end + 1))
it_map = tuple(map(None, il, ml[start:end]))
]:
	i: 97(), 127()
	o: 217(loop), 355(AL)

nname: 127
n 127(None)[exit_by = pl[-1]._y
enter_by = pl[0]._y
]:
	i: 47&87(f)
	o: 154()

nname: 97
n 97(None)[exit_by = pl[0]._y
enter_by = pl[-1]._y
]:
	i: 47&87(t)
	o: 154()

nname: 47&87
n 47&87(start > il.start and self._reversed_update)[align_type = 'top'
long_duration = self.duration * 2
selected = ml.selected
]:
	i: 36(), 43()
	o: 97(t), 127(f)

nname: 43
n 43(None)[]:
	i: 0(f)
	o: 47&87()

nname: 36
n 36(None)[]:
	i: 0(t)
	o: 47&87()

nname: 0
n 0(self._centered)[il = self.item_list
ml = self.menu_list
pl = self.positions_list
]:
	i: 
	o: 36(t), 43(f)

nname: 475
n 475(None)[return None
]:
	i: 387()
	o: 

nname: 387
n 387(None)[for pos, ui_menu_item in zip(pl, it_map):
	animate = ui_menu_item[0].widget.animate
	animate('move', duration=0, **{align_type: enter_by})
	animate('move', duration=long_duration, **{align_type: pos._y})
]:
	i: 355(for)
	o: 475()

nname: 355
n 355(None)[sleep(self.duration)
]:
	i: 154(AL), 217(AF), 317()
	o: 387(for)

nname: 317
n 317(None)[ui_item.widget.animate('move', duration=long_duration, **{align_type: exit_by})
]:
	i: 245(), 259()
	o: 355()

nname: 259
n 259(None)[if self._no_selection:
	pass
sel_val = menu_item is selected
ui_item.reset(menu_item, sel_val, position=it_pos.next())
]:
	i: 224(f)
	o: 317()

nname: 245
n 245(None)[ui_item.destroy()
]:
	i: 224(t)
	o: 317()

nname: 224
n 224(menu_item is None)[for ui_item, menu_item in it_map:
]:
	i: 217(for)
	o: 245(t), 259(f)

nname: 217
n 217(None)[]:
	i: 154(loop)
	o: 224(for), 355(AF)

nname: 154
n 154(None)[it_pos = iter(xrange(start + 1, end + 1))
it_map = tuple(map(None, il, ml[start:end]))
]:
	i: 0()
	o: 217(loop), 355(AL)

nname: 0
n 0(None)[il = self.item_list
ml = self.menu_list
pl = self.positions_list
if self._centered:
	pass
align_type = 'top'
long_duration = self.duration * 2
selected = ml.selected
if start > il.start and self._reversed_update:
	exit_by = pl[0]._y
	enter_by = pl[-1]._y
else:
	exit_by = pl[-1]._y
	enter_by = pl[0]._y
]:
	i: 
	o: 154()

nname: 475
n 475(None)[return None
]:
	i: 355()
	o: 

nname: 355
n 355(None)[sleep(self.duration)
for pos, ui_menu_item in zip(pl, it_map):
	animate = ui_menu_item[0].widget.animate
	animate('move', duration=0, **{align_type: enter_by})
	animate('move', duration=long_duration, **{align_type: pos._y})
]:
	i: 0(AL), 217(AF), 224()
	o: 475()

nname: 224
n 224(None)[for ui_item, menu_item in it_map:
if menu_item is None:
	ui_item.destroy()
else:
	if self._no_selection:
		pass
	sel_val = menu_item is selected
	ui_item.reset(menu_item, sel_val, position=it_pos.next())
ui_item.widget.animate('move', duration=long_duration, **{align_type: exit_by})
]:
	i: 217(for)
	o: 355()

nname: 217
n 217(None)[]:
	i: 0(loop)
	o: 224(for), 355(AF)

nname: 0
n 0(None)[il = self.item_list
ml = self.menu_list
pl = self.positions_list
if self._centered:
	pass
align_type = 'top'
long_duration = self.duration * 2
selected = ml.selected
if start > il.start and self._reversed_update:
	exit_by = pl[0]._y
	enter_by = pl[-1]._y
else:
	exit_by = pl[-1]._y
	enter_by = pl[0]._y
it_pos = iter(xrange(start + 1, end + 1))
it_map = tuple(map(None, il, ml[start:end]))
]:
	i: 
	o: 217(loop), 355(AL)

nname: 355
n 355(None)[sleep(self.duration)
for pos, ui_menu_item in zip(pl, it_map):
	animate = ui_menu_item[0].widget.animate
	animate('move', duration=0, **{align_type: enter_by})
	animate('move', duration=long_duration, **{align_type: pos._y})
return None
]:
	i: 0(AL), 217(AF), 224()
	o: 

nname: 224
n 224(None)[for ui_item, menu_item in it_map:
if menu_item is None:
	ui_item.destroy()
else:
	if self._no_selection:
		pass
	sel_val = menu_item is selected
	ui_item.reset(menu_item, sel_val, position=it_pos.next())
ui_item.widget.animate('move', duration=long_duration, **{align_type: exit_by})
]:
	i: 217(for)
	o: 355()

nname: 217
n 217(None)[]:
	i: 0(loop)
	o: 224(for), 355(AF)

nname: 0
n 0(None)[il = self.item_list
ml = self.menu_list
pl = self.positions_list
if self._centered:
	pass
align_type = 'top'
long_duration = self.duration * 2
selected = ml.selected
if start > il.start and self._reversed_update:
	exit_by = pl[0]._y
	enter_by = pl[-1]._y
else:
	exit_by = pl[-1]._y
	enter_by = pl[0]._y
it_pos = iter(xrange(start + 1, end + 1))
it_map = tuple(map(None, il, ml[start:end]))
]:
	i: 
	o: 217(loop), 355(AL)

self.nodes: {0: <unpyclib.structure.node instance at 0xb77425ec>, 217: <unpyclib.structure.node instance at 0xb773e40c>, 224: <unpyclib.structure.node instance at 0xb774242c>, 355: <unpyclib.structure.node instance at 0xb774208c>}
nname: 6
n 6(None)[__doc__ = 'List where elements are paged. '
def do_swap(self, i1, i2):
	if not GenericListing._swap_items(self, i1, i2):
		return self.do_reset()
	il = self.item_list
	nb_positions = len(il)
	il.selected = self.menu_list.selected_pos
	il.start = max(0, il.selected // nb_positions * nb_positions)
	il.end = il.start + nb_positions
	if self._bar is not None:
		self._bar.animate('move', vcenter=self.positions_list[il.selected - il.start]._y, duration=self.duration)
	return None

def create_content(self):
	if self._initialized:
		pass
	self._initialized = True
	nb_items = len(self.positions_list)
	start = max(0, self.menu_list.selected_pos // nb_items * nb_items)
	GenericListing._create_content(self, start, self.style_name)
	try:
		self._pagejump_func = getattr(self, '_pagejump_' + self.style_dict['page_jump'])
	except:
		log.error('Unknown page_jump type: %s', self.style_dict['page_jump'])
		self._pagejump_func = self._pagejump_reset

def do_reset(self, position=None, focus=None):
	ml = self.menu_list
	il = self.item_list
	if focus is None:
		focus = ml.selected_pos
	nb_items = len(self.positions_list)
	start = max(0, focus // nb_items * nb_items)
	end = start + nb_items
	selected = ml.selected
	if position is not None:
		try:
			menu_item = ml[position]
			ui_item = il[position - start]
		except IndexError:
			log.warn('Trying to reset an out-of-screen item. position: %s', position)
		else:
			if menu_item is None:
				ui_item.destroy()
			else:
				if self._no_selection:
					pass
				sel_val = menu_item is selected
				ui_item.reset(menu_item, sel_val, position=position + 1)
	else:
		for i, pos in enumerate(map(None, self.positions_list, il, ml[start:end])):
			if menu_item is None:
				ui_item.destroy()
			else:
				if self._no_selection:
					pass
				sel_val = menu_item is selected
				ui_item.reset(menu_item, sel_val, position=start + i + 1)
			ui_item.widget.animate_stop()
			pos.put(ui_item)
		il.selected = ml.selected_pos
		il.start = start
		il.end = end
	self._refresh_more_items()
	if self._bar is not None:
		if len(ml) and il.selected >= 0 and not self._no_selection:
			self._bar.animate('move', vcenter=self.positions_list[il.selected - il.start]._y, duration=0)
			self._bar.show()
		else:
			self._bar.hide()
	if self._edited:
		self._edited = False
		self.do_edit(True)
	return None

def do_remove(self, position):
	ml = self.menu_list
	il = self.item_list
	nb_items = len(il)
	start = max(0, ml.selected_pos // nb_items * nb_items)
	if start != il.start:
		return self.do_reset()
	if position >= il.end:
		return None
	GenericListing._remove_item(self, position, True)
	il.selected = ml.selected_pos
	il.start = start
	il.end = start + nb_items
	GenericListing._refresh_more_items(self)
	sel_idx = ml.selected_pos - start
	if self._bar is not None:
		if ml.selected is None:
			self._bar.hide()
		else:
			self._bar.animate('move', vcenter=self.positions_list[sel_idx]._y, duration=self.duration)
	il[sel_idx].selected = True
	return None

def do_update(self, position, focus=None):
	il = self.item_list
	ml = self.menu_list
	if focus is None:
		if ml.selected is None or il.selected == position:
			return True
		focus = position
	nb_positions = len(self.positions_list)
	start = max(0, focus // nb_positions * nb_positions)
	end = start + nb_positions
	if self._edited:
		log.warn('Changing selection while editing')
	if il.start != start:
		self._pagejump_func(start, end)
	else:
		idx = max(0, il.selected) % nb_positions
		if il[idx].selected:
			il[idx].selected = False
		if start <= position:
			pass
		else:
			position
		if start <= position and not self._no_selection:
			il[position % nb_positions].selected = True
	il_get_focused = il.selected == -1
	il.selected = position
	il.start = start
	il.end = end
	self._refresh_more_items()
	if self._bar is not None:
		if il_get_focused:
			self._bar.animate('move', vcenter=self.positions_list[0]._y, duration=0)
			self._bar.show()
		else:
			self._bar.animate('move', vcenter=self.positions_list[position - start]._y, duration=self.duration)
	return None

def _pagejump_reset(self, start, end):
	ml = self.menu_list
	selected = ml.selected
	it_pos = start + 1
	for ui_item, menu_item in map(None, self.item_list, ml[start:end]):
		if menu_item is None:
			ui_item.destroy()
		else:
			if self._no_selection:
				pass
			sel_val = menu_item is selected
			ui_item.reset(menu_item, sel_val, position=it_pos)
		it_pos += 1
	return None

def _pagejump_smooth(self, start, end):
	if self._no_selection:
		pass
	selected = self.menu_list.selected
	move = start - self.item_list.start
	GenericListing._scroll(self, move, self.duration * 2, selected)
	return None

def _pagejump_shutter(self, start, end):
	il = self.item_list
	ml = self.menu_list
	pl = self.positions_list
	if self._centered:
		pass
	align_type = 'top'
	long_duration = self.duration * 2
	selected = ml.selected
	if start > il.start and self._reversed_update:
		exit_by = pl[0]._y
		enter_by = pl[-1]._y
	else:
		exit_by = pl[-1]._y
		enter_by = pl[0]._y
	it_pos = iter(xrange(start + 1, end + 1))
	it_map = tuple(map(None, il, ml[start:end]))

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb772edec>}
nname: 0
n 0(None)[from __future__ import absolute_import
__all__ = ['DefaultListing']
from .core import GenericListing
from peewee.debug import GET_LOGGER
log = GET_LOGGER(__name__)
from time import sleep
class DefaultListing(GenericListing):
	__doc__ = 'List where elements are paged. '
	def do_swap(self, i1, i2):
		if not GenericListing._swap_items(self, i1, i2):
			return self.do_reset()
		il = self.item_list
		nb_positions = len(il)
		il.selected = self.menu_list.selected_pos
		il.start = max(0, il.selected // nb_positions * nb_positions)
		il.end = il.start + nb_positions
		if self._bar is not None:
			self._bar.animate('move', vcenter=self.positions_list[il.selected - il.start]._y, duration=self.duration)
		return None

	def create_content(self):
		if self._initialized:
			pass
		self._initialized = True
		nb_items = len(self.positions_list)
		start = max(0, self.menu_list.selected_pos // nb_items * nb_items)
		GenericListing._create_content(self, start, self.style_name)
		try:
			self._pagejump_func = getattr(self, '_pagejump_' + self.style_dict['page_jump'])
		except:
			log.error('Unknown page_jump type: %s', self.style_dict['page_jump'])
			self._pagejump_func = self._pagejump_reset

	def do_reset(self, position=None, focus=None):
		ml = self.menu_list
		il = self.item_list
		if focus is None:
			focus = ml.selected_pos
		nb_items = len(self.positions_list)
		start = max(0, focus // nb_items * nb_items)
		end = start + nb_items
		selected = ml.selected
		if position is not None:
			try:
				menu_item = ml[position]
				ui_item = il[position - start]
			except IndexError:
				log.warn('Trying to reset an out-of-screen item. position: %s', position)
			else:
				if menu_item is None:
					ui_item.destroy()
				else:
					if self._no_selection:
						pass
					sel_val = menu_item is selected
					ui_item.reset(menu_item, sel_val, position=position + 1)
		else:
			for i, pos in enumerate(map(None, self.positions_list, il, ml[start:end])):
				if menu_item is None:
					ui_item.destroy()
				else:
					if self._no_selection:
						pass
					sel_val = menu_item is selected
					ui_item.reset(menu_item, sel_val, position=start + i + 1)
				ui_item.widget.animate_stop()
				pos.put(ui_item)
			il.selected = ml.selected_pos
			il.start = start
			il.end = end
		self._refresh_more_items()
		if self._bar is not None:
			if len(ml) and il.selected >= 0 and not self._no_selection:
				self._bar.animate('move', vcenter=self.positions_list[il.selected - il.start]._y, duration=0)
				self._bar.show()
			else:
				self._bar.hide()
		if self._edited:
			self._edited = False
			self.do_edit(True)
		return None

	def do_remove(self, position):
		ml = self.menu_list
		il = self.item_list
		nb_items = len(il)
		start = max(0, ml.selected_pos // nb_items * nb_items)
		if start != il.start:
			return self.do_reset()
		if position >= il.end:
			return None
		GenericListing._remove_item(self, position, True)
		il.selected = ml.selected_pos
		il.start = start
		il.end = start + nb_items
		GenericListing._refresh_more_items(self)
		sel_idx = ml.selected_pos - start
		if self._bar is not None:
			if ml.selected is None:
				self._bar.hide()
			else:
				self._bar.animate('move', vcenter=self.positions_list[sel_idx]._y, duration=self.duration)
		il[sel_idx].selected = True
		return None

	def do_update(self, position, focus=None):
		il = self.item_list
		ml = self.menu_list
		if focus is None:
			if ml.selected is None or il.selected == position:
				return True
			focus = position
		nb_positions = len(self.positions_list)
		start = max(0, focus // nb_positions * nb_positions)
		end = start + nb_positions
		if self._edited:
			log.warn('Changing selection while editing')
		if il.start != start:
			self._pagejump_func(start, end)
		else:
			idx = max(0, il.selected) % nb_positions
			if il[idx].selected:
				il[idx].selected = False
			if start <= position:
				pass
			else:
				position
			if start <= position and not self._no_selection:
				il[position % nb_positions].selected = True
		il_get_focused = il.selected == -1
		il.selected = position
		il.start = start
		il.end = end
		self._refresh_more_items()
		if self._bar is not None:
			if il_get_focused:
				self._bar.animate('move', vcenter=self.positions_list[0]._y, duration=0)
				self._bar.show()
			else:
				self._bar.animate('move', vcenter=self.positions_list[position - start]._y, duration=self.duration)
		return None

	def _pagejump_reset(self, start, end):
		ml = self.menu_list
		selected = ml.selected
		it_pos = start + 1
		for ui_item, menu_item in map(None, self.item_list, ml[start:end]):
			if menu_item is None:
				ui_item.destroy()
			else:
				if self._no_selection:
					pass
				sel_val = menu_item is selected
				ui_item.reset(menu_item, sel_val, position=it_pos)
			it_pos += 1
		return None

	def _pagejump_smooth(self, start, end):
		if self._no_selection:
			pass
		selected = self.menu_list.selected
		move = start - self.item_list.start
		GenericListing._scroll(self, move, self.duration * 2, selected)
		return None

	def _pagejump_shutter(self, start, end):
		il = self.item_list
		ml = self.menu_list
		pl = self.positions_list
		if self._centered:
			pass
		align_type = 'top'
		long_duration = self.duration * 2
		selected = ml.selected
		if start > il.start and self._reversed_update:
			exit_by = pl[0]._y
			enter_by = pl[-1]._y
		else:
			exit_by = pl[-1]._y
			enter_by = pl[0]._y
		it_pos = iter(xrange(start + 1, end + 1))
		it_map = tuple(map(None, il, ml[start:end]))



]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7727c8c>}
from __future__ import absolute_import
__all__ = ['DefaultListing']
from .core import GenericListing
from peewee.debug import GET_LOGGER
log = GET_LOGGER(__name__)
from time import sleep
class DefaultListing(GenericListing):
	__doc__ = 'List where elements are paged. '
	def do_swap(self, i1, i2):
		if not GenericListing._swap_items(self, i1, i2):
			return self.do_reset()
		il = self.item_list
		nb_positions = len(il)
		il.selected = self.menu_list.selected_pos
		il.start = max(0, il.selected // nb_positions * nb_positions)
		il.end = il.start + nb_positions
		if self._bar is not None:
			self._bar.animate('move', vcenter=self.positions_list[il.selected - il.start]._y, duration=self.duration)
		return None

	def create_content(self):
		if self._initialized:
			pass
		self._initialized = True
		nb_items = len(self.positions_list)
		start = max(0, self.menu_list.selected_pos // nb_items * nb_items)
		GenericListing._create_content(self, start, self.style_name)
		try:
			self._pagejump_func = getattr(self, '_pagejump_' + self.style_dict['page_jump'])
		except:
			log.error('Unknown page_jump type: %s', self.style_dict['page_jump'])
			self._pagejump_func = self._pagejump_reset

	def do_reset(self, position=None, focus=None):
		ml = self.menu_list
		il = self.item_list
		if focus is None:
			focus = ml.selected_pos
		nb_items = len(self.positions_list)
		start = max(0, focus // nb_items * nb_items)
		end = start + nb_items
		selected = ml.selected
		if position is not None:
			try:
				menu_item = ml[position]
				ui_item = il[position - start]
			except IndexError:
				log.warn('Trying to reset an out-of-screen item. position: %s', position)
			else:
				if menu_item is None:
					ui_item.destroy()
				else:
					if self._no_selection:
						pass
					sel_val = menu_item is selected
					ui_item.reset(menu_item, sel_val, position=position + 1)
		else:
			for i, pos in enumerate(map(None, self.positions_list, il, ml[start:end])):
				if menu_item is None:
					ui_item.destroy()
				else:
					if self._no_selection:
						pass
					sel_val = menu_item is selected
					ui_item.reset(menu_item, sel_val, position=start + i + 1)
				ui_item.widget.animate_stop()
				pos.put(ui_item)
			il.selected = ml.selected_pos
			il.start = start
			il.end = end
		self._refresh_more_items()
		if self._bar is not None:
			if len(ml) and il.selected >= 0 and not self._no_selection:
				self._bar.animate('move', vcenter=self.positions_list[il.selected - il.start]._y, duration=0)
				self._bar.show()
			else:
				self._bar.hide()
		if self._edited:
			self._edited = False
			self.do_edit(True)
		return None

	def do_remove(self, position):
		ml = self.menu_list
		il = self.item_list
		nb_items = len(il)
		start = max(0, ml.selected_pos // nb_items * nb_items)
		if start != il.start:
			return self.do_reset()
		if position >= il.end:
			return None
		GenericListing._remove_item(self, position, True)
		il.selected = ml.selected_pos
		il.start = start
		il.end = start + nb_items
		GenericListing._refresh_more_items(self)
		sel_idx = ml.selected_pos - start
		if self._bar is not None:
			if ml.selected is None:
				self._bar.hide()
			else:
				self._bar.animate('move', vcenter=self.positions_list[sel_idx]._y, duration=self.duration)
		il[sel_idx].selected = True
		return None

	def do_update(self, position, focus=None):
		il = self.item_list
		ml = self.menu_list
		if focus is None:
			if ml.selected is None or il.selected == position:
				return True
			focus = position
		nb_positions = len(self.positions_list)
		start = max(0, focus // nb_positions * nb_positions)
		end = start + nb_positions
		if self._edited:
			log.warn('Changing selection while editing')
		if il.start != start:
			self._pagejump_func(start, end)
		else:
			idx = max(0, il.selected) % nb_positions
			if il[idx].selected:
				il[idx].selected = False
			if start <= position:
				pass
			else:
				position
			if start <= position and not self._no_selection:
				il[position % nb_positions].selected = True
		il_get_focused = il.selected == -1
		il.selected = position
		il.start = start
		il.end = end
		self._refresh_more_items()
		if self._bar is not None:
			if il_get_focused:
				self._bar.animate('move', vcenter=self.positions_list[0]._y, duration=0)
				self._bar.show()
			else:
				self._bar.animate('move', vcenter=self.positions_list[position - start]._y, duration=self.duration)
		return None

	def _pagejump_reset(self, start, end):
		ml = self.menu_list
		selected = ml.selected
		it_pos = start + 1
		for ui_item, menu_item in map(None, self.item_list, ml[start:end]):
			if menu_item is None:
				ui_item.destroy()
			else:
				if self._no_selection:
					pass
				sel_val = menu_item is selected
				ui_item.reset(menu_item, sel_val, position=it_pos)
			it_pos += 1
		return None

	def _pagejump_smooth(self, start, end):
		if self._no_selection:
			pass
		selected = self.menu_list.selected
		move = start - self.item_list.start
		GenericListing._scroll(self, move, self.duration * 2, selected)
		return None

	def _pagejump_shutter(self, start, end):
		il = self.item_list
		ml = self.menu_list
		pl = self.positions_list
		if self._centered:
			pass
		align_type = 'top'
		long_duration = self.duration * 2
		selected = ml.selected
		if start > il.start and self._reversed_update:
			exit_by = pl[0]._y
			enter_by = pl[-1]._y
		else:
			exit_by = pl[-1]._y
			enter_by = pl[0]._y
		it_pos = iter(xrange(start + 1, end + 1))
		it_map = tuple(map(None, il, ml[start:end]))



