# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 0
n 0(None)[self._connections = dict()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7774f2c>}
nname: 0
n 0(None)[self._connections[fn] = args
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7774eac>}
nname: 94
n 94(None)[]:
	i: 0(AL), 93()
	o: 

nname: 93
n 93(None)[]:
	i: 3(AF), 90()
	o: 94()

nname: 90
n 90(None)[]:
	i: 88(AE)
	o: 93()

nname: 88
n 88(None)[]:
	i: 45(f), 55()
	o: 90(AE)

nname: 55
n 55(None)[log.error('Error while emitting signal %s(%s)', conn, args)
PRINT_EXCEPTION()
continue
]:
	i: 45(t)
	o: 88()

nname: 45
n 45(<dummy_ex3> EXC_MATCH Exception)[]:
	i: 19(except), 31()
	o: 55(t), 88(f)

nname: 31
n 31(None)[conn(*args)
continue
]:
	i: 19(try)
	o: 45()

nname: 19
n 19(None)[for conn, args in self._connections.iteritems():
]:
	i: 3(for)
	o: 31(try), 45(except)

nname: 3
n 3(None)[]:
	i: 0(loop)
	o: 19(for), 93(AF)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 94(AL)

nname: 94
n 94(None)[]:
	i: 0(AL), 3(AF), 45(AE)
	o: 

nname: 45
n 45(None)[except Exception:
	log.error('Error while emitting signal %s(%s)', conn, args)
	PRINT_EXCEPTION()
	continue
]:
	i: 19()
	o: 94(AE)

nname: 19
n 19(None)[for conn, args in self._connections.iteritems():
try:
	conn(*args)
	continue
]:
	i: 3(for)
	o: 45()

nname: 3
n 3(None)[]:
	i: 0(loop)
	o: 19(for), 94(AF)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 94(AL)

nname: 94
n 94(None)[]:
	i: 0(AL), 3(AF), 19(AE)
	o: 

nname: 19
n 19(None)[for conn, args in self._connections.iteritems():
try:
	conn(*args)
	continue
except Exception:
	log.error('Error while emitting signal %s(%s)', conn, args)
	PRINT_EXCEPTION()
	continue
]:
	i: 3(for)
	o: 94(AE)

nname: 3
n 3(None)[]:
	i: 0(loop)
	o: 19(for), 94(AF)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 94(AL)

nname: 94
n 94(None)[]:
	i: 19(AE)
	o: 

nname: 19
n 19(None)[for conn, args in self._connections.iteritems():
	try:
		conn(*args)
		continue
	except Exception:
		log.error('Error while emitting signal %s(%s)', conn, args)
		PRINT_EXCEPTION()
		continue
]:
	i: 0(for)
	o: 94(AE)

nname: 0
n 0(None)[]:
	i: 
	o: 19(for)

nname: 94
n 94(None)[]:
	i: 0(AE)
	o: 

nname: 0
n 0(None)[for conn, args in self._connections.iteritems():
	try:
		conn(*args)
		continue
	except Exception:
		log.error('Error while emitting signal %s(%s)', conn, args)
		PRINT_EXCEPTION()
		continue
]:
	i: 
	o: 94(AE)

self.nodes: {0: <unpyclib.structure.node instance at 0xb7777a2c>, 94: <unpyclib.structure.node instance at 0xb777792c>}
nname: 6
n 6(None)[def __init__(self):
	self._connections = dict()

def connect(self, fn, *args):
	self._connections[fn] = args

def emit(self):
	for conn, args in self._connections.iteritems():
		try:
			conn(*args)
			continue
		except Exception:
			log.error('Error while emitting signal %s(%s)', conn, args)
			PRINT_EXCEPTION()
			continue

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb77749ec>}
nname: 0
n 0(None)[self.name = name
self.selected = selected
self.type = ''
Signal.__init__(self)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb77770ec>}
nname: 6
n 6(None)[__doc__ = '\n    A button used in some windows.\n    '
def __init__(self, name, selected=True):
	self.name = name
	self.selected = selected
	self.type = ''
	Signal.__init__(self)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb7774bac>}
nname: 0
n 0(None)[ret = fn(self, *args, **kw)
handler = pygui_globs['menustack']
handler.update_window(self)
return ret
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7774d6c>}
nname: 0
n 0(None)[def _do_updates(self, *args, **args):
	ret = fn(self, *args, **kw)
	handler = pygui_globs['menustack']
	handler.update_window(self)
	return ret

return _do_updates
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb777484c>}
nname: 38
n 38(None)[self.eventhandler = eventhandler
return None
]:
	i: 21(), 37()
	o: 

nname: 37
n 37(None)[]:
	i: 0(f)
	o: 38()

nname: 21
n 21(None)[eventhandler = NullEventHandler(self)
]:
	i: 0(t)
	o: 38()

nname: 0
n 0(eventhandler is None)[self._visible = False
]:
	i: 
	o: 21(t), 37(f)

nname: 0
n 0(None)[self._visible = False
if eventhandler is None:
	eventhandler = NullEventHandler(self)
self.eventhandler = eventhandler
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7777b0c>}
nname: 18
n 18(None)[self._visible = False
handler = pygui_globs['menustack']
handler.remove_window(self)
return True
]:
	i: 9(), 17()
	o: 

nname: 17
n 17(None)[]:
	i: 0(t)
	o: 18()

nname: 9
n 9(None)[return False
]:
	i: 0(f)
	o: 18()

nname: 0
n 0(self._visible)[]:
	i: 
	o: 9(f), 17(t)

nname: 0
n 0(None)[if not self._visible:
	return False
self._visible = False
handler = pygui_globs['menustack']
handler.remove_window(self)
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7777c6c>}
nname: 0
n 0(None)[]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb77772cc>}
nname: 6
n 6(None)[__doc__ = '\n    A basic empty window, not very usefull on its own.\n    '
type = None
hold = False
def __init__(self, eventhandler=None):
	self._visible = False
	if eventhandler is None:
		eventhandler = NullEventHandler(self)
	self.eventhandler = eventhandler
	return None

show = gui_updater()
def hide(self):
	if not self._visible:
		return False
	self._visible = False
	handler = pygui_globs['menustack']
	handler.remove_window(self)
	return True

def update(self):
	pass

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb7774c4c>}
nname: 0
n 0(None)[Window.__init__(self)
self.text = text
self.eventhandler = CatchEventHandler(self)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb777704c>}
nname: 6
n 6(None)[__doc__ = ' A simple single-text message to help the user wait '
type = 'loading'
def __init__(self, text=''):
	Window.__init__(self)
	self.text = text
	self.eventhandler = CatchEventHandler(self)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb7774c4c>}
nname: 0
n 0(None)[Window.__init__(self)
self.text = text
self.eventhandler = NullEventHandler(self)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb77772ac>}
nname: 6
n 6(None)[__doc__ = ' A simple single-text message to help the user wait '
type = 'keystroke'
persistent = True
def __init__(self, text=''):
	Window.__init__(self)
	self.text = text
	self.eventhandler = NullEventHandler(self)

set_key = gui_updater()
]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb7774a4c>}
nname: 51
n 51(None)[self.title = _('Information:')
self.eventhandler = CatchEventHandler(self)
return None
]:
	i: 34(), 41()
	o: 

nname: 41
n 41(None)[]:
	i: 0(f)
	o: 51()

nname: 34
n 34(None)[]:
	i: 0(t)
	o: 51()

nname: 0
n 0(title is not None)[Window.__init__(self)
self.text = text
]:
	i: 
	o: 34(t), 41(f)

nname: 0
n 0(None)[Window.__init__(self)
self.text = text
if title is not None:
	pass
self.title = _('Information:')
self.eventhandler = CatchEventHandler(self)
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb77773ac>}
nname: 6
n 6(None)[__doc__ = '\n    A simple window without eventhandler showing a text.\n    '
type = 'text'
def __init__(self, text, title=None):
	Window.__init__(self)
	self.text = text
	if title is not None:
		pass
	self.title = _('Information:')
	self.eventhandler = CatchEventHandler(self)
	return None

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb77747cc>}
nname: 66
n 66(None)[self.button = Button(_('OK'))
self._timeout_timer = None
self.eventhandler = MessageEventHandler(self)
return None
]:
	i: 43(), 50()
	o: 

nname: 50
n 50(None)[]:
	i: 0(f)
	o: 66()

nname: 43
n 43(None)[]:
	i: 0(t)
	o: 66()

nname: 0
n 0(button is not False)[Window.__init__(self)
self.text = text
self.title = title
]:
	i: 
	o: 43(t), 50(f)

nname: 0
n 0(None)[Window.__init__(self)
self.text = text
self.title = title
if button is not False:
	pass
self.button = Button(_('OK'))
self._timeout_timer = None
self.eventhandler = MessageEventHandler(self)
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb77774ec>}
nname: 34
n 34(None)[]:
	i: 19(), 33()
	o: 

nname: 33
n 33(None)[]:
	i: 0(f)
	o: 34()

nname: 19
n 19(None)[self.timeout_callback()
]:
	i: 0(t)
	o: 34()

nname: 0
n 0(self.timeout_callback)[self.hide()
]:
	i: 
	o: 19(t), 33(f)

nname: 0
n 0(None)[self.hide()
if self.timeout_callback:
	self.timeout_callback()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76f93ac>}
nname: 81
n 81(None)[return ret
]:
	i: 30(), 80()
	o: 

nname: 80
n 80(None)[]:
	i: 0(f)
	o: 81()

nname: 30
n 30(None)[def _MessageWindow__callback_runner():
	self.hide()
	if self.timeout_callback:
		self.timeout_callback()

self._timeout_timer = Task(_MessageWindow__callback_runner)
self._timeout_timer.start(timeout)
]:
	i: 0(t)
	o: 81()

nname: 0
n 0(timeout)[self.timeout_callback = timeout_callback
ret = Window.show(self)
]:
	i: 
	o: 30(t), 80(f)

nname: 0
n 0(None)[self.timeout_callback = timeout_callback
ret = Window.show(self)
if timeout:
	def _MessageWindow__callback_runner():
		self.hide()
		if self.timeout_callback:
			self.timeout_callback()

	self._timeout_timer = Task(_MessageWindow__callback_runner)
	self._timeout_timer.start(timeout)
return ret
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb77774ec>}
nname: 27
n 27(None)[return Window.hide(self)
]:
	i: 9(), 26()
	o: 

nname: 26
n 26(None)[]:
	i: 0(f)
	o: 27()

nname: 9
n 9(None)[self._timeout_timer.stop()
]:
	i: 0(t)
	o: 27()

nname: 0
n 0(self._timeout_timer)[]:
	i: 
	o: 9(t), 26(f)

nname: 0
n 0(None)[if self._timeout_timer:
	self._timeout_timer.stop()
return Window.hide(self)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb77779ac>}
nname: 6
n 6(None)[__doc__ = '\n    A simple window showing a text. The window will hide on input\n    events.\n    '
type = 'message'
def __init__(self, text, title='', button=False):
	Window.__init__(self)
	self.text = text
	self.title = title
	if button is not False:
		pass
	self.button = Button(_('OK'))
	self._timeout_timer = None
	self.eventhandler = MessageEventHandler(self)
	return None

def show(self, timeout=None, timeout_callback=None):
	self.timeout_callback = timeout_callback
	ret = Window.show(self)
	if timeout:
		def _MessageWindow__callback_runner():
			self.hide()
			if self.timeout_callback:
				self.timeout_callback()

		self._timeout_timer = Task(_MessageWindow__callback_runner)
		self._timeout_timer.start(timeout)
	return ret

def hide(self):
	if self._timeout_timer:
		self._timeout_timer.stop()
	return Window.hide(self)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb7774d4c>}
nname: 6
n 6(None)[__doc__ = "A simple window that's supposed to show a lot more text\n    than the regular MessageWindow."
type = 'bigmessage'
]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb77749ec>}
nname: 0
n 0(None)[from __future__ import absolute_import
from pygui.eventmanager import NullEventHandler, CatchEventHandler
from pygui.eventmanager.windows import *
from peewee.debug import GET_LOGGER, PRINT_EXCEPTION
from peewee.notifier import Task
from peewee.messages import send
from pygui.shared import pygui_globs
log = GET_LOGGER(__name__)
class Signal(object):
	def __init__(self):
		self._connections = dict()

	def connect(self, fn, *args):
		self._connections[fn] = args

	def emit(self):
		for conn, args in self._connections.iteritems():
			try:
				conn(*args)
				continue
			except Exception:
				log.error('Error while emitting signal %s(%s)', conn, args)
				PRINT_EXCEPTION()
				continue



class Button(Signal):
	__doc__ = '\n    A button used in some windows.\n    '
	def __init__(self, name, selected=True):
		self.name = name
		self.selected = selected
		self.type = ''
		Signal.__init__(self)



def gui_updater(fn):
	def _do_updates(self, *args, **args):
		ret = fn(self, *args, **kw)
		handler = pygui_globs['menustack']
		handler.update_window(self)
		return ret

	return _do_updates

class Window(object):
	__doc__ = '\n    A basic empty window, not very usefull on its own.\n    '
	type = None
	hold = False
	def __init__(self, eventhandler=None):
		self._visible = False
		if eventhandler is None:
			eventhandler = NullEventHandler(self)
		self.eventhandler = eventhandler
		return None

	show = gui_updater()
	def hide(self):
		if not self._visible:
			return False
		self._visible = False
		handler = pygui_globs['menustack']
		handler.remove_window(self)
		return True

	def update(self):
		pass



class LoadingWindow(Window):
	__doc__ = ' A simple single-text message to help the user wait '
	type = 'loading'
	def __init__(self, text=''):
		Window.__init__(self)
		self.text = text
		self.eventhandler = CatchEventHandler(self)



class KeystrokeWindow(Window):
	__doc__ = ' A simple single-text message to help the user wait '
	type = 'keystroke'
	persistent = True
	def __init__(self, text=''):
		Window.__init__(self)
		self.text = text
		self.eventhandler = NullEventHandler(self)

	set_key = gui_updater()


class TextWindow(Window):
	__doc__ = '\n    A simple window without eventhandler showing a text.\n    '
	type = 'text'
	def __init__(self, text, title=None):
		Window.__init__(self)
		self.text = text
		if title is not None:
			pass
		self.title = _('Information:')
		self.eventhandler = CatchEventHandler(self)
		return None



class MessageWindow(Window):
	__doc__ = '\n    A simple window showing a text. The window will hide on input\n    events.\n    '
	type = 'message'
	def __init__(self, text, title='', button=False):
		Window.__init__(self)
		self.text = text
		self.title = title
		if button is not False:
			pass
		self.button = Button(_('OK'))
		self._timeout_timer = None
		self.eventhandler = MessageEventHandler(self)
		return None

	def show(self, timeout=None, timeout_callback=None):
		self.timeout_callback = timeout_callback
		ret = Window.show(self)
		if timeout:
			def _MessageWindow__callback_runner():
				self.hide()
				if self.timeout_callback:
					self.timeout_callback()

			self._timeout_timer = Task(_MessageWindow__callback_runner)
			self._timeout_timer.start(timeout)
		return ret

	def hide(self):
		if self._timeout_timer:
			self._timeout_timer.stop()
		return Window.hide(self)



class BigMessageWindow(MessageWindow):
	__doc__ = "A simple window that's supposed to show a lot more text\n    than the regular MessageWindow."
	type = 'bigmessage'


]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb776850c>}
from __future__ import absolute_import
from pygui.eventmanager import NullEventHandler, CatchEventHandler
from pygui.eventmanager.windows import *
from peewee.debug import GET_LOGGER, PRINT_EXCEPTION
from peewee.notifier import Task
from peewee.messages import send
from pygui.shared import pygui_globs
log = GET_LOGGER(__name__)
class Signal(object):
	def __init__(self):
		self._connections = dict()

	def connect(self, fn, *args):
		self._connections[fn] = args

	def emit(self):
		for conn, args in self._connections.iteritems():
			try:
				conn(*args)
				continue
			except Exception:
				log.error('Error while emitting signal %s(%s)', conn, args)
				PRINT_EXCEPTION()
				continue



class Button(Signal):
	__doc__ = '\n    A button used in some windows.\n    '
	def __init__(self, name, selected=True):
		self.name = name
		self.selected = selected
		self.type = ''
		Signal.__init__(self)



def gui_updater(fn):
	def _do_updates(self, *args, **args):
		ret = fn(self, *args, **kw)
		handler = pygui_globs['menustack']
		handler.update_window(self)
		return ret

	return _do_updates

class Window(object):
	__doc__ = '\n    A basic empty window, not very usefull on its own.\n    '
	type = None
	hold = False
	def __init__(self, eventhandler=None):
		self._visible = False
		if eventhandler is None:
			eventhandler = NullEventHandler(self)
		self.eventhandler = eventhandler
		return None

	show = gui_updater()
	def hide(self):
		if not self._visible:
			return False
		self._visible = False
		handler = pygui_globs['menustack']
		handler.remove_window(self)
		return True

	def update(self):
		pass



class LoadingWindow(Window):
	__doc__ = ' A simple single-text message to help the user wait '
	type = 'loading'
	def __init__(self, text=''):
		Window.__init__(self)
		self.text = text
		self.eventhandler = CatchEventHandler(self)



class KeystrokeWindow(Window):
	__doc__ = ' A simple single-text message to help the user wait '
	type = 'keystroke'
	persistent = True
	def __init__(self, text=''):
		Window.__init__(self)
		self.text = text
		self.eventhandler = NullEventHandler(self)

	set_key = gui_updater()


class TextWindow(Window):
	__doc__ = '\n    A simple window without eventhandler showing a text.\n    '
	type = 'text'
	def __init__(self, text, title=None):
		Window.__init__(self)
		self.text = text
		if title is not None:
			pass
		self.title = _('Information:')
		self.eventhandler = CatchEventHandler(self)
		return None



class MessageWindow(Window):
	__doc__ = '\n    A simple window showing a text. The window will hide on input\n    events.\n    '
	type = 'message'
	def __init__(self, text, title='', button=False):
		Window.__init__(self)
		self.text = text
		self.title = title
		if button is not False:
			pass
		self.button = Button(_('OK'))
		self._timeout_timer = None
		self.eventhandler = MessageEventHandler(self)
		return None

	def show(self, timeout=None, timeout_callback=None):
		self.timeout_callback = timeout_callback
		ret = Window.show(self)
		if timeout:
			def _MessageWindow__callback_runner():
				self.hide()
				if self.timeout_callback:
					self.timeout_callback()

			self._timeout_timer = Task(_MessageWindow__callback_runner)
			self._timeout_timer.start(timeout)
		return ret

	def hide(self):
		if self._timeout_timer:
			self._timeout_timer.stop()
		return Window.hide(self)



class BigMessageWindow(MessageWindow):
	__doc__ = "A simple window that's supposed to show a lot more text\n    than the regular MessageWindow."
	type = 'bigmessage'


