# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 0
n 0(None)[Item.__init__(self, _('My scheduled recordings'), 'schedule_dir', menu, display_type, parent)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7778b8c>}
nname: 0
n 0(None)[return item.record.start_time
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb778044c>}
nname: 143
n 143(None)[_list.sort(key=(lambda item: item.record.start_time))
return _list
]:
	i: 86(AL), 142()
	o: 

nname: 142
n 142(None)[]:
	i: 89(AF), 117()
	o: 143()

nname: 117
n 117(None)[for periodic_rule in _wyrec.scheduler.GetPeriodicRecordingList(active=True, unactive=True):
_list.append(PeriodicScheduledRecordItem(periodic_rule))
]:
	i: 89(for)
	o: 142()

nname: 89
n 89(None)[]:
	i: 86(loop)
	o: 117(for), 142(AF)

nname: 86
n 86(None)[]:
	i: 29(AL), 85()
	o: 89(loop), 143(AL)

nname: 85
n 85(None)[]:
	i: 32(AF), 60()
	o: 86()

nname: 60
n 60(None)[for record in _wyrec.scheduler.GetRecordingList(nFlags=flags, ignore_periodic=True):
_list.append(ScheduledRecordItem(record))
]:
	i: 32(for)
	o: 85()

nname: 32
n 32(None)[]:
	i: 29(loop)
	o: 60(for), 85(AF)

nname: 29
n 29(None)[]:
	i: 12(), 22()
	o: 32(loop), 86(AL)

nname: 22
n 22(None)[flags = RECORDING_FLAG_ALL
]:
	i: 0(f)
	o: 29()

nname: 12
n 12(None)[flags = RECORDING_FLAG_SCHEDULED
]:
	i: 0(t)
	o: 29()

nname: 0
n 0(scheduled_only)[_list = []
]:
	i: 
	o: 12(t), 22(f)

nname: 142
n 142(None)[_list.sort(key=(lambda item: item.record.start_time))
return _list
]:
	i: 89()
	o: 

nname: 89
n 89(None)[for periodic_rule in _wyrec.scheduler.GetPeriodicRecordingList(active=True, unactive=True):
	_list.append(PeriodicScheduledRecordItem(periodic_rule))
]:
	i: 85(loop)
	o: 142()

nname: 85
n 85(None)[]:
	i: 32()
	o: 89(loop)

nname: 32
n 32(None)[for record in _wyrec.scheduler.GetRecordingList(nFlags=flags, ignore_periodic=True):
	_list.append(ScheduledRecordItem(record))
]:
	i: 0(loop)
	o: 85()

nname: 0
n 0(None)[_list = []
if scheduled_only:
	flags = RECORDING_FLAG_SCHEDULED
else:
	flags = RECORDING_FLAG_ALL
]:
	i: 
	o: 32(loop)

nname: 142
n 142(None)[_list.sort(key=(lambda item: item.record.start_time))
return _list
]:
	i: 85()
	o: 

nname: 85
n 85(None)[for periodic_rule in _wyrec.scheduler.GetPeriodicRecordingList(active=True, unactive=True):
	_list.append(PeriodicScheduledRecordItem(periodic_rule))
]:
	i: 0()
	o: 142()

nname: 0
n 0(None)[_list = []
if scheduled_only:
	flags = RECORDING_FLAG_SCHEDULED
else:
	flags = RECORDING_FLAG_ALL
for record in _wyrec.scheduler.GetRecordingList(nFlags=flags, ignore_periodic=True):
	_list.append(ScheduledRecordItem(record))
]:
	i: 
	o: 85()

nname: 142
n 142(None)[_list.sort(key=(lambda item: item.record.start_time))
return _list
]:
	i: 0()
	o: 

nname: 0
n 0(None)[_list = []
if scheduled_only:
	flags = RECORDING_FLAG_SCHEDULED
else:
	flags = RECORDING_FLAG_ALL
for record in _wyrec.scheduler.GetRecordingList(nFlags=flags, ignore_periodic=True):
	_list.append(ScheduledRecordItem(record))
for periodic_rule in _wyrec.scheduler.GetPeriodicRecordingList(active=True, unactive=True):
	_list.append(PeriodicScheduledRecordItem(periodic_rule))
]:
	i: 
	o: 142()

nname: 0
n 0(None)[_list = []
if scheduled_only:
	flags = RECORDING_FLAG_SCHEDULED
else:
	flags = RECORDING_FLAG_ALL
for record in _wyrec.scheduler.GetRecordingList(nFlags=flags, ignore_periodic=True):
	_list.append(ScheduledRecordItem(record))
for periodic_rule in _wyrec.scheduler.GetPeriodicRecordingList(active=True, unactive=True):
	_list.append(PeriodicScheduledRecordItem(periodic_rule))
_list.sort(key=(lambda item: item.record.start_time))
return _list
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb777b80c>}
nname: 6
n 6(None)[def __init__(self, menu=None, display_type=None, parent=None):
	Item.__init__(self, _('My scheduled recordings'), 'schedule_dir', menu, display_type, parent)

def browse(self, scheduled_only=True):
	_list = []
	if scheduled_only:
		flags = RECORDING_FLAG_SCHEDULED
	else:
		flags = RECORDING_FLAG_ALL
	for record in _wyrec.scheduler.GetRecordingList(nFlags=flags, ignore_periodic=True):
		_list.append(ScheduledRecordItem(record))
	for periodic_rule in _wyrec.scheduler.GetPeriodicRecordingList(active=True, unactive=True):
		_list.append(PeriodicScheduledRecordItem(periodic_rule))
	_list.sort(key=(lambda item: item.record.start_time))
	return _list

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb777852c>}
nname: 0
n 0(None)[Item.__init__(self, record.name.decode('utf-8', 'ignore'), type_, menu, display_type)
self.record = record
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7778b6c>}
nname: 36
n 36(None)[return False
]:
	i: 15(), 35()
	o: 

nname: 35
n 35(None)[]:
	i: 0(f)
	o: 36()

nname: 15
n 15(None)[return self.record == other.record
]:
	i: 0(t)
	o: 36()

nname: 0
n 0(isinstance(other, ScheduledRecordItem))[]:
	i: 
	o: 15(t), 35(f)

nname: 0
n 0(None)[if isinstance(other, ScheduledRecordItem):
	return self.record == other.record
return False
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7778d6c>}
nname: 6
n 6(None)[def __init__(self, record, type_='schedule', menu=None, display_type=None):
	Item.__init__(self, record.name.decode('utf-8', 'ignore'), type_, menu, display_type)
	self.record = record

def __eq__(self, other):
	if isinstance(other, ScheduledRecordItem):
		return self.record == other.record
	return False

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb77783ac>}
nname: 167
n 167(None)[]:
	i: 117(), 153(), 166(AE)
	o: 

nname: 153
n 153(None)[PRINT_EXCEPTION()
]:
	i: 105(except)
	o: 167()

nname: 117
n 117(None)[ScheduledRecordItem.__init__(self, self.remaining_records[0], type_, menu, display_type)
]:
	i: 105(try)
	o: 167()

nname: 105
n 105(None)[del _[1]
for self.remaining_records in all_records:
]:
	i: 0(AF), 101()
	o: 117(try), 153(except)

nname: 101
n 101(None)[]:
	i: 72(f), 90()
	o: 105()

nname: 90
n 90(None)[continue
]:
	i: 72(t)
	o: 101()

nname: 72
n 72(i.start_time >= now)[for i in all_records:
]:
	i: 0(for)
	o: 90(t), 101(f)

nname: 0
n 0(None)[self.periodic_rule = periodic_rule
self.period = PERIODICITY[periodic_rule.extern_rule_name]
all_records = _wyrec.scheduler.recording_list.GetPeriodicRecordingListByRule(periodic_rule.id)
now = time()
]:
	i: 
	o: 72(for), 105(AF)

nname: 153
n 153(None)[except:
	PRINT_EXCEPTION()
]:
	i: 105()
	o: 

nname: 105
n 105(None)[del _[1]
for self.remaining_records in all_records:
try:
	ScheduledRecordItem.__init__(self, self.remaining_records[0], type_, menu, display_type)
]:
	i: 0(AF), 72()
	o: 153()

nname: 72
n 72(None)[for i in all_records:
if i.start_time >= now:
	continue
]:
	i: 0(for)
	o: 105()

nname: 0
n 0(None)[self.periodic_rule = periodic_rule
self.period = PERIODICITY[periodic_rule.extern_rule_name]
all_records = _wyrec.scheduler.recording_list.GetPeriodicRecordingListByRule(periodic_rule.id)
now = time()
]:
	i: 
	o: 72(for), 105(AF)

nname: 105
n 105(None)[del _[1]
for self.remaining_records in all_records:
try:
	ScheduledRecordItem.__init__(self, self.remaining_records[0], type_, menu, display_type)
except:
	PRINT_EXCEPTION()
]:
	i: 0(AF), 72()
	o: 

nname: 72
n 72(None)[for i in all_records:
if i.start_time >= now:
	continue
]:
	i: 0(for)
	o: 105()

nname: 0
n 0(None)[self.periodic_rule = periodic_rule
self.period = PERIODICITY[periodic_rule.extern_rule_name]
all_records = _wyrec.scheduler.recording_list.GetPeriodicRecordingListByRule(periodic_rule.id)
now = time()
]:
	i: 
	o: 72(for), 105(AF)

self.nodes: {0: <unpyclib.structure.node instance at 0xb777bf8c>, 72: <unpyclib.structure.node instance at 0xb777b78c>, 105: <unpyclib.structure.node instance at 0xb777b5cc>}
nname: 0
n 0(None)[return self.periodic_rule.is_active
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7778e6c>}
nname: 58
n 58(None)[]:
	i: 9(), 35()
	o: 

nname: 35
n 35(None)[_wyrec.scheduler.ActivatePeriodicityRule(self.periodic_rule.id)
]:
	i: 0(f)
	o: 58()

nname: 9
n 9(None)[_wyrec.scheduler.DeactivatePeriodicityRule(self.periodic_rule.id)
]:
	i: 0(t)
	o: 58()

nname: 0
n 0(self.active)[]:
	i: 
	o: 9(t), 35(f)

nname: 0
n 0(None)[if self.active:
	_wyrec.scheduler.DeactivatePeriodicityRule(self.periodic_rule.id)
else:
	_wyrec.scheduler.ActivatePeriodicityRule(self.periodic_rule.id)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb777b16c>}
nname: 6
n 6(None)[def __init__(self, periodic_rule, type_='periodic_schedule', menu=None, display_type=None):
	self.periodic_rule = periodic_rule
	self.period = PERIODICITY[periodic_rule.extern_rule_name]
	all_records = _wyrec.scheduler.recording_list.GetPeriodicRecordingListByRule(periodic_rule.id)
	now = time()

remaining_count = property()
def _get_active(self):
	return self.periodic_rule.is_active

def _set_active(self, active):
	if self.active:
		_wyrec.scheduler.DeactivatePeriodicityRule(self.periodic_rule.id)
	else:
		_wyrec.scheduler.ActivatePeriodicityRule(self.periodic_rule.id)

active = property(_get_active, _set_active, doc="The record's activity status.")
del _get_active
del _set_active
]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb777896c>}
nname: 0
n 0(None)[from __future__ import absolute_import
from time import time
from wyrecord import WyRecord
from wyrecord.recordscheduler import RECORDING_FLAG_SCHEDULED, RECORDING_FLAG_CANCELED, RECORDING_FLAG_COMPLETED, RECORDING_FLAG_ALL
from peewee.debug import PRINT_EXCEPTION, DEBUG
from pygui.facilities.l10n import UnicodeDict
from .containers import GenericContainer
from .core import Item
_wyrec = WyRecord()
PERIODICITY = UnicodeDict({'daily': 'Every day', 'weekly': 'Every week'})
class ScheduledRecordRootItem(GenericContainer):
	def __init__(self, menu=None, display_type=None, parent=None):
		Item.__init__(self, _('My scheduled recordings'), 'schedule_dir', menu, display_type, parent)

	def browse(self, scheduled_only=True):
		_list = []
		if scheduled_only:
			flags = RECORDING_FLAG_SCHEDULED
		else:
			flags = RECORDING_FLAG_ALL
		for record in _wyrec.scheduler.GetRecordingList(nFlags=flags, ignore_periodic=True):
			_list.append(ScheduledRecordItem(record))
		for periodic_rule in _wyrec.scheduler.GetPeriodicRecordingList(active=True, unactive=True):
			_list.append(PeriodicScheduledRecordItem(periodic_rule))
		_list.sort(key=(lambda item: item.record.start_time))
		return _list



class ScheduledRecordItem(Item):
	def __init__(self, record, type_='schedule', menu=None, display_type=None):
		Item.__init__(self, record.name.decode('utf-8', 'ignore'), type_, menu, display_type)
		self.record = record

	def __eq__(self, other):
		if isinstance(other, ScheduledRecordItem):
			return self.record == other.record
		return False



class PeriodicScheduledRecordItem(ScheduledRecordItem):
	def __init__(self, periodic_rule, type_='periodic_schedule', menu=None, display_type=None):
		self.periodic_rule = periodic_rule
		self.period = PERIODICITY[periodic_rule.extern_rule_name]
		all_records = _wyrec.scheduler.recording_list.GetPeriodicRecordingListByRule(periodic_rule.id)
		now = time()

	remaining_count = property()
	def _get_active(self):
		return self.periodic_rule.is_active

	def _set_active(self, active):
		if self.active:
			_wyrec.scheduler.DeactivatePeriodicityRule(self.periodic_rule.id)
		else:
			_wyrec.scheduler.ActivatePeriodicityRule(self.periodic_rule.id)

	active = property(_get_active, _set_active, doc="The record's activity status.")
	del _get_active
	del _set_active


]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb776fe8c>}
from __future__ import absolute_import
from time import time
from wyrecord import WyRecord
from wyrecord.recordscheduler import RECORDING_FLAG_SCHEDULED, RECORDING_FLAG_CANCELED, RECORDING_FLAG_COMPLETED, RECORDING_FLAG_ALL
from peewee.debug import PRINT_EXCEPTION, DEBUG
from pygui.facilities.l10n import UnicodeDict
from .containers import GenericContainer
from .core import Item
_wyrec = WyRecord()
PERIODICITY = UnicodeDict({'daily': 'Every day', 'weekly': 'Every week'})
class ScheduledRecordRootItem(GenericContainer):
	def __init__(self, menu=None, display_type=None, parent=None):
		Item.__init__(self, _('My scheduled recordings'), 'schedule_dir', menu, display_type, parent)

	def browse(self, scheduled_only=True):
		_list = []
		if scheduled_only:
			flags = RECORDING_FLAG_SCHEDULED
		else:
			flags = RECORDING_FLAG_ALL
		for record in _wyrec.scheduler.GetRecordingList(nFlags=flags, ignore_periodic=True):
			_list.append(ScheduledRecordItem(record))
		for periodic_rule in _wyrec.scheduler.GetPeriodicRecordingList(active=True, unactive=True):
			_list.append(PeriodicScheduledRecordItem(periodic_rule))
		_list.sort(key=(lambda item: item.record.start_time))
		return _list



class ScheduledRecordItem(Item):
	def __init__(self, record, type_='schedule', menu=None, display_type=None):
		Item.__init__(self, record.name.decode('utf-8', 'ignore'), type_, menu, display_type)
		self.record = record

	def __eq__(self, other):
		if isinstance(other, ScheduledRecordItem):
			return self.record == other.record
		return False



class PeriodicScheduledRecordItem(ScheduledRecordItem):
	def __init__(self, periodic_rule, type_='periodic_schedule', menu=None, display_type=None):
		self.periodic_rule = periodic_rule
		self.period = PERIODICITY[periodic_rule.extern_rule_name]
		all_records = _wyrec.scheduler.recording_list.GetPeriodicRecordingListByRule(periodic_rule.id)
		now = time()

	remaining_count = property()
	def _get_active(self):
		return self.periodic_rule.is_active

	def _set_active(self, active):
		if self.active:
			_wyrec.scheduler.DeactivatePeriodicityRule(self.periodic_rule.id)
		else:
			_wyrec.scheduler.ActivatePeriodicityRule(self.periodic_rule.id)

	active = property(_get_active, _set_active, doc="The record's activity status.")
	del _get_active
	del _set_active


