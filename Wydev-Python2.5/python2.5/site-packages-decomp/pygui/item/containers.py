# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 0
n 0(None)[list.__init__(self, *args)
self._owners = []
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb757d82c>}
nname: 42
n 42(None)[del _[1]
for it.list_owned in ow:
list.append(self, it)
]:
	i: 0(AF), 23()
	o: 

nname: 23
n 23(None)[for elt in ow:
]:
	i: 0(for)
	o: 42()

nname: 0
n 0(None)[ow = self._owners
]:
	i: 
	o: 23(for), 42(AF)

self.nodes: {0: <unpyclib.structure.node instance at 0xb757de0c>, 42: <unpyclib.structure.node instance at 0xb757db2c>, 23: <unpyclib.structure.node instance at 0xb757daec>}
nname: 42
n 42(None)[del _[1]
for it.list_owned in ow:
list.insert(self, pos, it)
]:
	i: 0(AF), 23()
	o: 

nname: 23
n 23(None)[for elt in ow:
]:
	i: 0(for)
	o: 42()

nname: 0
n 0(None)[ow = self._owners
]:
	i: 
	o: 23(for), 42(AF)

self.nodes: {0: <unpyclib.structure.node instance at 0xb757db4c>, 42: <unpyclib.structure.node instance at 0xb757de0c>, 23: <unpyclib.structure.node instance at 0xb757dbcc>}
nname: 59
n 59(None)[]:
	i: 0(AL), 58()
	o: 

nname: 58
n 58(None)[]:
	i: 3(AF), 55()
	o: 59()

nname: 55
n 55(None)[]:
	i: 53(AE)
	o: 58()

nname: 53
n 53(None)[]:
	i: 36(f), 46()
	o: 55(AE)

nname: 46
n 46(None)[continue
]:
	i: 36(t)
	o: 53()

nname: 36
n 36(<dummy_ex3> EXC_MATCH ValueError)[]:
	i: 10(except), 16()
	o: 46(t), 53(f)

nname: 16
n 16(None)[item.list_owned.remove(list_name)
continue
]:
	i: 10(try)
	o: 36()

nname: 10
n 10(None)[for item in self:
]:
	i: 3(for)
	o: 16(try), 36(except)

nname: 3
n 3(None)[]:
	i: 0(loop)
	o: 10(for), 58(AF)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 59(AL)

nname: 59
n 59(None)[]:
	i: 0(AL), 3(AF), 36(AE)
	o: 

nname: 36
n 36(None)[except ValueError:
	continue
]:
	i: 10()
	o: 59(AE)

nname: 10
n 10(None)[for item in self:
try:
	item.list_owned.remove(list_name)
	continue
]:
	i: 3(for)
	o: 36()

nname: 3
n 3(None)[]:
	i: 0(loop)
	o: 10(for), 59(AF)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 59(AL)

nname: 59
n 59(None)[]:
	i: 0(AL), 3(AF), 10(AE)
	o: 

nname: 10
n 10(None)[for item in self:
try:
	item.list_owned.remove(list_name)
	continue
except ValueError:
	continue
]:
	i: 3(for)
	o: 59(AE)

nname: 3
n 3(None)[]:
	i: 0(loop)
	o: 10(for), 59(AF)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 59(AL)

nname: 59
n 59(None)[]:
	i: 10(AE)
	o: 

nname: 10
n 10(None)[for item in self:
	try:
		item.list_owned.remove(list_name)
		continue
	except ValueError:
		continue
]:
	i: 0(for)
	o: 59(AE)

nname: 0
n 0(None)[]:
	i: 
	o: 10(for)

nname: 59
n 59(None)[]:
	i: 0(AE)
	o: 

nname: 0
n 0(None)[for item in self:
	try:
		item.list_owned.remove(list_name)
		continue
	except ValueError:
		continue
]:
	i: 
	o: 59(AE)

self.nodes: {0: <unpyclib.structure.node instance at 0xb757dbac>, 59: <unpyclib.structure.node instance at 0xb757decc>}
nname: 0
n 0(None)[self._owners.remove(who)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb757d7ec>}
nname: 64
n 64(None)[]:
	i: 0(AL), 63()
	o: 

nname: 63
n 63(None)[]:
	i: 31(AF), 38()
	o: 64()

nname: 38
n 38(None)[for item in self:
item.list_owned.append(who.list_name)
]:
	i: 31(for)
	o: 63()

nname: 31
n 31(None)[]:
	i: 0(loop)
	o: 38(for), 63(AF)

nname: 0
n 0(None)[self._owners.append(ref(who, self._owner_removed))
]:
	i: 
	o: 31(loop), 64(AL)

nname: 64
n 64(None)[]:
	i: 38()
	o: 

nname: 38
n 38(None)[for item in self:
	item.list_owned.append(who.list_name)
]:
	i: 0(for)
	o: 64()

nname: 0
n 0(None)[self._owners.append(ref(who, self._owner_removed))
]:
	i: 
	o: 38(for)

nname: 64
n 64(None)[]:
	i: 0()
	o: 

nname: 0
n 0(None)[self._owners.append(ref(who, self._owner_removed))
for item in self:
	item.list_owned.append(who.list_name)
]:
	i: 
	o: 64()

nname: 0
n 0(None)[self._owners.append(ref(who, self._owner_removed))
for item in self:
	item.list_owned.append(who.list_name)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb757df2c>}
nname: 6
n 6(None)[__slots__ = ['_owners']
def __init__(self, *args):
	list.__init__(self, *args)
	self._owners = []

def append(self, it):
	ow = self._owners

def insert(self, pos, it):
	ow = self._owners

def remove_list(self, list_name):
	for item in self:
		try:
			item.list_owned.remove(list_name)
			continue
		except ValueError:
			continue

def _owner_removed(self, who):
	self._owners.remove(who)

def add_owner(self, who):
	self._owners.append(ref(who, self._owner_removed))
	for item in self:
		item.list_owned.append(who.list_name)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb757bf4c>}
nname: 123
n 123(None)[self._ItemList__sel_observers = set()
]:
	i: 109(), 122()
	o: 

nname: 122
n 122(None)[]:
	i: 26&87(f)
	o: 123()

nname: 109
n 109(None)[self.selected_pos = selected_pos
]:
	i: 26&87(t)
	o: 123()

nname: 26&87
n 26&87(selected_pos >= 0 and selected_pos < len(self._data))[self.list_name = list_name
self.menu = menu
self.cyclic = False
self.set_items(_list)
self.selected_pos = -1
]:
	i: 0(AL), 25()
	o: 109(t), 122(f)

nname: 25
n 25(None)[]:
	i: 3(AF), 10()
	o: 26&87()

nname: 10
n 10(None)[for it in _list:
it.menu = menu
]:
	i: 3(for)
	o: 25()

nname: 3
n 3(None)[]:
	i: 0(loop)
	o: 10(for), 25(AF)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 26&87(AL)

nname: 26&87
n 26&87(None)[self.list_name = list_name
self.menu = menu
self.cyclic = False
self.set_items(_list)
self.selected_pos = -1
if selected_pos >= 0 and selected_pos < len(self._data):
	self.selected_pos = selected_pos
self._ItemList__sel_observers = set()
]:
	i: 10()
	o: 

nname: 10
n 10(None)[for it in _list:
	it.menu = menu
]:
	i: 0(for)
	o: 26&87()

nname: 0
n 0(None)[]:
	i: 
	o: 10(for)

nname: 26&87
n 26&87(None)[self.list_name = list_name
self.menu = menu
self.cyclic = False
self.set_items(_list)
self.selected_pos = -1
if selected_pos >= 0 and selected_pos < len(self._data):
	self.selected_pos = selected_pos
self._ItemList__sel_observers = set()
]:
	i: 0()
	o: 

nname: 0
n 0(None)[for it in _list:
	it.menu = menu
]:
	i: 
	o: 26&87()

nname: 0
n 0(None)[for it in _list:
	it.menu = menu
self.list_name = list_name
self.menu = menu
self.cyclic = False
self.set_items(_list)
self.selected_pos = -1
if selected_pos >= 0 and selected_pos < len(self._data):
	self.selected_pos = selected_pos
self._ItemList__sel_observers = set()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb758198c>}
nname: 62
n 62(None)[return None
]:
	i: 41(), 58()
	o: 

nname: 58
n 58(None)[]:
	i: 38(f)
	o: 62()

nname: 41
n 41(None)[]:
	i: 38(t)
	o: 62()

nname: 38
n 38(0 <= self.selected_pos)[]:
	i: 17(), 36()
	o: 41(t), 58(f)

nname: 36
n 36(None)[self.selected_pos
]:
	i: 0(f)
	o: 38()

nname: 17
n 17(None)[]:
	i: 0(t)
	o: 38()

nname: 0
n 0(0 <= self.selected_pos)[]:
	i: 
	o: 17(t), 36(f)

nname: 62
n 62(None)[return None
]:
	i: 0()
	o: 

nname: 0
n 0(None)[if 0 <= self.selected_pos:
	pass
else:
	self.selected_pos
if 0 <= self.selected_pos:
	pass
]:
	i: 
	o: 62()

nname: 0
n 0(None)[if 0 <= self.selected_pos:
	pass
else:
	self.selected_pos
if 0 <= self.selected_pos:
	pass
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75816ec>}
nname: 0
n 0(None)[return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75810ac>}
nname: 0
n 0(None)[return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb758110c>}
nname: 0
n 0(None)[return '<ItemList pointing %s @%d :: %s>' % (self.selected, self.selected_pos, self._data)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb758124c>}
nname: 45
n 45(None)[]:
	i: 3(), 36(), 43(AE)
	o: 

nname: 43
n 43(None)[]:
	i: 26(f)
	o: 45(AE)

nname: 36
n 36(None)[]:
	i: 26(t)
	o: 45()

nname: 26
n 26(<dummy_ex3> EXC_MATCH AttributeError)[]:
	i: 0(except)
	o: 36(t), 43(f)

nname: 3
n 3(None)[self._data.remove_list(self.list_name)
]:
	i: 0(try)
	o: 45()

nname: 0
n 0(None)[]:
	i: 
	o: 3(try), 26(except)

nname: 26
n 26(None)[except AttributeError:
	pass
]:
	i: 0()
	o: 

nname: 0
n 0(None)[try:
	self._data.remove_list(self.list_name)
]:
	i: 
	o: 26()

nname: 0
n 0(None)[try:
	self._data.remove_list(self.list_name)
except AttributeError:
	pass
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7581aac>}
nname: 0
n 0(None)[self._ItemList__sel_observers.remove(who)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75811ec>}
nname: 36
n 36(None)[]:
	i: 15(), 35()
	o: 

nname: 35
n 35(None)[]:
	i: 0(f)
	o: 36()

nname: 15
n 15(None)[self._ItemList__sel_observers.add(who)
]:
	i: 0(t)
	o: 36()

nname: 0
n 0(who not in self._ItemList__sel_observers)[]:
	i: 
	o: 15(t), 35(f)

nname: 0
n 0(None)[if who not in self._ItemList__sel_observers:
	self._ItemList__sel_observers.add(who)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb758134c>}
nname: 0
n 0(None)[return iter(self._data)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb758110c>}
nname: 0
n 0(None)[return item in self._data
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb758102c>}
nname: 0
n 0(None)[return len(self._data)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75811ec>}
nname: 0
n 0(None)[return self._data[idx]
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb758102c>}
nname: 309
n 309(None)[]:
	i: 81(AL), 159(), 228(AL), 308()
	o: 

nname: 308
n 308(None)[]:
	i: 240(AF), 253()
	o: 309()

nname: 253
n 253(None)[for owner in self._data._owners:
louie_send(owner.list_name, sender=owner.menu, action='reset', value=owner, position=k)
]:
	i: 240(for)
	o: 308()

nname: 240
n 240(None)[]:
	i: 228(loop)
	o: 253(for), 308(AF)

nname: 228
n 228(None)[del _[2]
for value.list_owned in self._data._owners:
]:
	i: 163(AF), 209()
	o: 240(loop), 309(AL)

nname: 209
n 209(None)[for elt in self._data._owners:
]:
	i: 163(for)
	o: 228()

nname: 163
n 163(None)[self._data[k] = value
value.menu = self.menu
]:
	i: 0(f)
	o: 209(for), 228(AF)

nname: 159
n 159(None)[]:
	i: 97(AF), 110()
	o: 309()

nname: 110
n 110(None)[for owner in self._data._owners:
owner = owner()
louie_send(owner.list_name, sender=owner.menu, action='reset', value=owner)
]:
	i: 97(for)
	o: 159()

nname: 97
n 97(None)[]:
	i: 81(loop)
	o: 110(for), 159(AF)

nname: 81
n 81(None)[_[2], owner, self._data[k] = [], owner(), value
]:
	i: 15(AL), 80()
	o: 97(loop), 309(AL)

nname: 80
n 80(None)[]:
	i: 19(AF), 68()
	o: 81()

nname: 68
n 68(None)[del _[1]
for it.list_owned in self._data._owners:
]:
	i: 26(AF), 49()
	o: 80()

nname: 49
n 49(None)[for elt in self._data._owners:
]:
	i: 26(for)
	o: 68()

nname: 26
n 26(None)[for it in value:
]:
	i: 19(for)
	o: 49(for), 68(AF)

nname: 19
n 19(None)[]:
	i: 15(loop)
	o: 26(for), 80(AF)

nname: 15
n 15(None)[]:
	i: 0(t)
	o: 19(loop), 81(AL)

nname: 0
n 0(isinstance(k, slice))[]:
	i: 
	o: 15(t), 163(f)

nname: 309
n 309(None)[]:
	i: 110(), 253()
	o: 

nname: 253
n 253(None)[for owner in self._data._owners:
	louie_send(owner.list_name, sender=owner.menu, action='reset', value=owner, position=k)
]:
	i: 228(for)
	o: 309()

nname: 228
n 228(None)[del _[2]
for value.list_owned in self._data._owners:
]:
	i: 163(AF), 209()
	o: 253(for)

nname: 209
n 209(None)[for elt in self._data._owners:
]:
	i: 163(for)
	o: 228()

nname: 163
n 163(None)[self._data[k] = value
value.menu = self.menu
]:
	i: 0(f)
	o: 209(for), 228(AF)

nname: 110
n 110(None)[for owner in self._data._owners:
	owner = owner()
	louie_send(owner.list_name, sender=owner.menu, action='reset', value=owner)
]:
	i: 81(for)
	o: 309()

nname: 81
n 81(None)[_[2], owner, self._data[k] = [], owner(), value
]:
	i: 15(AL), 19(AF), 68()
	o: 110(for)

nname: 68
n 68(None)[del _[1]
for it.list_owned in self._data._owners:
]:
	i: 26(AF), 49()
	o: 81()

nname: 49
n 49(None)[for elt in self._data._owners:
]:
	i: 26(for)
	o: 68()

nname: 26
n 26(None)[for it in value:
]:
	i: 19(for)
	o: 49(for), 68(AF)

nname: 19
n 19(None)[]:
	i: 15(loop)
	o: 26(for), 81(AF)

nname: 15
n 15(None)[]:
	i: 0(t)
	o: 19(loop), 81(AL)

nname: 0
n 0(isinstance(k, slice))[]:
	i: 
	o: 15(t), 163(f)

nname: 309
n 309(None)[]:
	i: 81(), 228()
	o: 

nname: 228
n 228(None)[del _[2]
for value.list_owned in self._data._owners:
for owner in self._data._owners:
	louie_send(owner.list_name, sender=owner.menu, action='reset', value=owner, position=k)
]:
	i: 163(AF), 209()
	o: 309()

nname: 209
n 209(None)[for elt in self._data._owners:
]:
	i: 163(for)
	o: 228()

nname: 163
n 163(None)[self._data[k] = value
value.menu = self.menu
]:
	i: 0(f)
	o: 209(for), 228(AF)

nname: 81
n 81(None)[_[2], owner, self._data[k] = [], owner(), value
for owner in self._data._owners:
	owner = owner()
	louie_send(owner.list_name, sender=owner.menu, action='reset', value=owner)
]:
	i: 15(AL), 19(AF), 68()
	o: 309()

nname: 68
n 68(None)[del _[1]
for it.list_owned in self._data._owners:
]:
	i: 26(AF), 49()
	o: 81()

nname: 49
n 49(None)[for elt in self._data._owners:
]:
	i: 26(for)
	o: 68()

nname: 26
n 26(None)[for it in value:
]:
	i: 19(for)
	o: 49(for), 68(AF)

nname: 19
n 19(None)[]:
	i: 15(loop)
	o: 26(for), 81(AF)

nname: 15
n 15(None)[]:
	i: 0(t)
	o: 19(loop), 81(AL)

nname: 0
n 0(isinstance(k, slice))[]:
	i: 
	o: 15(t), 163(f)

self.nodes: {0: <unpyclib.structure.node instance at 0xb7508e0c>, 163: <unpyclib.structure.node instance at 0xb75082cc>, 68: <unpyclib.structure.node instance at 0xb750814c>, 81: <unpyclib.structure.node instance at 0xb750854c>, 209: <unpyclib.structure.node instance at 0xb750834c>, 15: <unpyclib.structure.node instance at 0xb750804c>, 49: <unpyclib.structure.node instance at 0xb750810c>, 19: <unpyclib.structure.node instance at 0xb750808c>, 309: <unpyclib.structure.node instance at 0xb75085cc>, 228: <unpyclib.structure.node instance at 0xb750820c>, 26: <unpyclib.structure.node instance at 0xb75080cc>}
nname: 356
n 356(None)[]:
	i: 284(AL), 355()
	o: 

nname: 355
n 355(None)[]:
	i: 287(AF), 300()
	o: 356()

nname: 300
n 300(None)[for owner in self._data._owners:
owner = owner()
louie_send(owner.list_name, sender=owner.menu, action='remove', value=owner, position=i)
]:
	i: 287(for)
	o: 355()

nname: 287
n 287(None)[]:
	i: 284(loop)
	o: 300(for), 355(AF)

nname: 284
n 284(None)[]:
	i: 187(AL), 270(), 274()
	o: 287(loop), 356(AL)

nname: 274
n 274(None)[self.selected_pos = -1
]:
	i: 52(f)
	o: 284()

nname: 270
n 270(None)[]:
	i: 190(AF), 267()
	o: 284()

nname: 267
n 267(None)[]:
	i: 243(JA), 266()
	o: 270()

nname: 266
n 266(None)[]:
	i: 203(f), 262()
	o: 267()

nname: 262
n 262(None)[continue
]:
	i: 227(f)
	o: 266()

nname: 243
n 243(None)[owner.selected_pos -= 1
]:
	i: 227(t)
	o: 267(JA)

nname: 227
n 227(i < owner.selected_pos)[]:
	i: 203(t)
	o: 243(t), 262(f)

nname: 203
n 203(owner != self)[for owner in self._data._owners:
owner = owner()
]:
	i: 190(for)
	o: 227(t), 266(f)

nname: 190
n 190(None)[]:
	i: 187(loop)
	o: 203(for), 270(AF)

nname: 187
n 187(None)[]:
	i: 87(JA), 117(JA), 148(), 167(), 186()
	o: 190(loop), 284(AL)

nname: 186
n 186(None)[]:
	i: 151(f)
	o: 187()

nname: 167
n 167(None)[self.selected_pos -= 1
]:
	i: 151(t)
	o: 187()

nname: 151
n 151(i < self.selected_pos)[]:
	i: 67(f)
	o: 167(t), 186(f)

nname: 148
n 148(None)[]:
	i: 146(AE)
	o: 187()

nname: 146
n 146(None)[]:
	i: 107(f)
	o: 148(AE)

nname: 117
n 117(None)[self.selected_pos = len(self._data) - 1
]:
	i: 107(t)
	o: 187(JA)

nname: 107
n 107(<dummy_ex3> EXC_MATCH IndexError)[]:
	i: 83(except)
	o: 117(t), 146(f)

nname: 87
n 87(None)[sel = self._data[self.selected_pos]
]:
	i: 83(try)
	o: 187(JA)

nname: 83
n 83(None)[]:
	i: 67(t)
	o: 87(try), 107(except)

nname: 67
n 67(i == self.selected_pos)[]:
	i: 52(t)
	o: 83(t), 151(f)

nname: 52
n 52(len(self._data))[]:
	i: 24(), 38()
	o: 67(t), 274(f)

nname: 38
n 38(None)[self._data._fill_cache()
]:
	i: 0(f)
	o: 52()

nname: 24
n 24(None)[del self._data[i]
]:
	i: 0(t)
	o: 52()

nname: 0
n 0(isinstance(self._data, (list, tuple)))[]:
	i: 
	o: 24(t), 38(f)

nname: 356
n 356(None)[]:
	i: 300()
	o: 

nname: 300
n 300(None)[for owner in self._data._owners:
	owner = owner()
	louie_send(owner.list_name, sender=owner.menu, action='remove', value=owner, position=i)
]:
	i: 284(for)
	o: 356()

nname: 284
n 284(None)[]:
	i: 187(AL), 274(), 190(AF), 243(JA), 203(f), 262()
	o: 300(for)

nname: 274
n 274(None)[self.selected_pos = -1
]:
	i: 0(f)
	o: 284()

nname: 262
n 262(None)[continue
]:
	i: 227(f)
	o: 284()

nname: 243
n 243(None)[owner.selected_pos -= 1
]:
	i: 227(t)
	o: 284(JA)

nname: 227
n 227(i < owner.selected_pos)[]:
	i: 203(t)
	o: 243(t), 262(f)

nname: 203
n 203(owner != self)[for owner in self._data._owners:
owner = owner()
]:
	i: 190(for)
	o: 227(t), 284(f)

nname: 190
n 190(None)[]:
	i: 187(loop)
	o: 203(for), 284(AF)

nname: 187
n 187(None)[]:
	i: 87(JA), 117(JA), 151(), 107(f), 146(AE)
	o: 190(loop), 284(AL)

nname: 151
n 151(None)[if i < self.selected_pos:
	self.selected_pos -= 1
]:
	i: 67(f)
	o: 187()

nname: 117
n 117(None)[self.selected_pos = len(self._data) - 1
]:
	i: 107(t)
	o: 187(JA)

nname: 107
n 107(<dummy_ex3> EXC_MATCH IndexError)[]:
	i: 83(except)
	o: 117(t), 187(f)

nname: 87
n 87(None)[sel = self._data[self.selected_pos]
]:
	i: 83(try)
	o: 187(JA)

nname: 83
n 83(None)[]:
	i: 67(t)
	o: 87(try), 107(except)

nname: 67
n 67(i == self.selected_pos)[]:
	i: 0(t)
	o: 83(t), 151(f)

nname: 0
n 0(len(self._data))[if isinstance(self._data, (list, tuple)):
	del self._data[i]
else:
	self._data._fill_cache()
]:
	i: 
	o: 67(t), 274(f)

nname: 356
n 356(None)[]:
	i: 284()
	o: 

nname: 284
n 284(None)[for owner in self._data._owners:
	owner = owner()
	louie_send(owner.list_name, sender=owner.menu, action='remove', value=owner, position=i)
]:
	i: 274(), 203(f)
	o: 356()

nname: 274
n 274(None)[self.selected_pos = -1
]:
	i: 0(f)
	o: 284()

nname: 203
n 203(None)[for owner in self._data._owners:
	owner = owner()
	if owner != self:
		if i < owner.selected_pos:
			owner.selected_pos -= 1
		else:
			continue
]:
	i: 187(for)
	o: 284(JA)

nname: 187
n 187(None)[]:
	i: 151(), 107(f)
	o: 203(for)

nname: 151
n 151(None)[if i < self.selected_pos:
	self.selected_pos -= 1
]:
	i: 67(f)
	o: 187()

nname: 107
n 107(None)[except IndexError:
	self.selected_pos = len(self._data) - 1
]:
	i: 83()
	o: 187(JA)

nname: 83
n 83(None)[try:
	sel = self._data[self.selected_pos]
]:
	i: 67(t)
	o: 107()

nname: 67
n 67(i == self.selected_pos)[]:
	i: 0(t)
	o: 83(t), 151(f)

nname: 0
n 0(len(self._data))[if isinstance(self._data, (list, tuple)):
	del self._data[i]
else:
	self._data._fill_cache()
]:
	i: 
	o: 67(t), 274(f)

nname: 284
n 284(None)[for owner in self._data._owners:
	owner = owner()
	louie_send(owner.list_name, sender=owner.menu, action='remove', value=owner, position=i)
]:
	i: 274(), 187(f)
	o: 

nname: 274
n 274(None)[self.selected_pos = -1
]:
	i: 0(f)
	o: 284()

nname: 187
n 187(None)[for owner in self._data._owners:
	owner = owner()
	if owner != self:
		if i < owner.selected_pos:
			owner.selected_pos -= 1
		else:
			continue
]:
	i: 151(), 83(f)
	o: 284(JA)

nname: 151
n 151(None)[if i < self.selected_pos:
	self.selected_pos -= 1
]:
	i: 67(f)
	o: 187()

nname: 83
n 83(None)[try:
	sel = self._data[self.selected_pos]
except IndexError:
	self.selected_pos = len(self._data) - 1
]:
	i: 67(t)
	o: 187(JA)

nname: 67
n 67(i == self.selected_pos)[]:
	i: 0(t)
	o: 83(t), 151(f)

nname: 0
n 0(len(self._data))[if isinstance(self._data, (list, tuple)):
	del self._data[i]
else:
	self._data._fill_cache()
]:
	i: 
	o: 67(t), 274(f)

nname: 284
n 284(None)[for owner in self._data._owners:
	owner = owner()
	louie_send(owner.list_name, sender=owner.menu, action='remove', value=owner, position=i)
]:
	i: 274(), 67(f)
	o: 

nname: 274
n 274(None)[self.selected_pos = -1
]:
	i: 0(f)
	o: 284()

nname: 67
n 67(None)[if i == self.selected_pos:
	try:
		sel = self._data[self.selected_pos]
	except IndexError:
		self.selected_pos = len(self._data) - 1
else:
	if i < self.selected_pos:
		self.selected_pos -= 1
for owner in self._data._owners:
	owner = owner()
	if owner != self:
		if i < owner.selected_pos:
			owner.selected_pos -= 1
		else:
			continue
]:
	i: 0(t)
	o: 284(JA)

nname: 0
n 0(len(self._data))[if isinstance(self._data, (list, tuple)):
	del self._data[i]
else:
	self._data._fill_cache()
]:
	i: 
	o: 67(t), 274(f)

nname: 0
n 0(None)[if isinstance(self._data, (list, tuple)):
	del self._data[i]
else:
	self._data._fill_cache()
if len(self._data):
	if i == self.selected_pos:
		try:
			sel = self._data[self.selected_pos]
		except IndexError:
			self.selected_pos = len(self._data) - 1
	else:
		if i < self.selected_pos:
			self.selected_pos -= 1
	for owner in self._data._owners:
		owner = owner()
		if owner != self:
			if i < owner.selected_pos:
				owner.selected_pos -= 1
			else:
				continue
else:
	self.selected_pos = -1
for owner in self._data._owners:
	owner = owner()
	louie_send(owner.list_name, sender=owner.menu, action='remove', value=owner, position=i)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb750ce0c>}
nname: 46
n 46(None)[]:
	i: 18(), 35()
	o: 

nname: 35
n 35(None)[return self._data.empty
]:
	i: 0(f)
	o: 46()

nname: 18
n 18(None)[return self._data == []
]:
	i: 0(t)
	o: 46()

nname: 0
n 0(isinstance(self._data, list))[]:
	i: 
	o: 18(t), 35(f)

nname: 0
n 0(None)[if isinstance(self._data, list):
	return self._data == []
else:
	return self._data.empty
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb758138c>}
nname: 0
n 0(None)[return self._data.index(value)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb758120c>}
nname: 227
n 227(None)[]:
	i: 136(AL), 226()
	o: 

nname: 226
n 226(None)[]:
	i: 158(AF), 171()
	o: 227()

nname: 171
n 171(None)[for owner in self._data._owners:
owner = owner()
louie_send(owner.list_name, sender=owner.menu, action='add', value=owner, position=index)
]:
	i: 158(for)
	o: 226()

nname: 158
n 158(None)[]:
	i: 136(loop)
	o: 171(for), 226(AF)

nname: 136
n 136(None)[self._data.insert(i, item)
]:
	i: 116(), 135()
	o: 158(loop), 227(AL)

nname: 135
n 135(None)[]:
	i: 101(f)
	o: 136()

nname: 116
n 116(None)[self.selected_pos += 1
]:
	i: 101(t)
	o: 136()

nname: 101
n 101(index < self.selected_pos)[]:
	i: 81(), 100()
	o: 116(t), 135(f)

nname: 100
n 100(None)[]:
	i: 57(f)
	o: 101()

nname: 81
n 81(None)[index = len(self._data)
]:
	i: 57(t)
	o: 101()

nname: 57
n 57(index > len(self._data))[index = max(0, len(self._data) + i)
]:
	i: 24(), 31()
	o: 81(t), 100(f)

nname: 31
n 31(None)[]:
	i: 0(f)
	o: 57()

nname: 24
n 24(None)[]:
	i: 0(t)
	o: 57()

nname: 0
n 0(i > 0)[item.menu = self.menu
]:
	i: 
	o: 24(t), 31(f)

nname: 226
n 226(None)[]:
	i: 158()
	o: 

nname: 158
n 158(None)[for owner in self._data._owners:
	owner = owner()
	louie_send(owner.list_name, sender=owner.menu, action='add', value=owner, position=index)
]:
	i: 101(loop)
	o: 226()

nname: 101
n 101(None)[if index < self.selected_pos:
	self.selected_pos += 1
self._data.insert(i, item)
]:
	i: 0()
	o: 158(loop)

nname: 0
n 0(None)[item.menu = self.menu
if i > 0:
	pass
index = max(0, len(self._data) + i)
if index > len(self._data):
	index = len(self._data)
]:
	i: 
	o: 101()

nname: 158
n 158(None)[for owner in self._data._owners:
	owner = owner()
	louie_send(owner.list_name, sender=owner.menu, action='add', value=owner, position=index)
]:
	i: 0(loop)
	o: 

nname: 0
n 0(None)[item.menu = self.menu
if i > 0:
	pass
index = max(0, len(self._data) + i)
if index > len(self._data):
	index = len(self._data)
if index < self.selected_pos:
	self.selected_pos += 1
self._data.insert(i, item)
]:
	i: 
	o: 158(loop)

nname: 0
n 0(None)[item.menu = self.menu
if i > 0:
	pass
index = max(0, len(self._data) + i)
if index > len(self._data):
	index = len(self._data)
if index < self.selected_pos:
	self.selected_pos += 1
self._data.insert(i, item)
for owner in self._data._owners:
	owner = owner()
	louie_send(owner.list_name, sender=owner.menu, action='add', value=owner, position=index)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7581a2c>}
nname: 155
n 155(None)[]:
	i: 52(AL), 154()
	o: 

nname: 154
n 154(None)[]:
	i: 86(AF), 99()
	o: 155()

nname: 99
n 99(None)[for owner in self._data._owners:
owner = owner()
louie_send(owner.list_name, sender=owner.menu, action='add', value=owner, position=position)
]:
	i: 86(for)
	o: 154()

nname: 86
n 86(None)[]:
	i: 52(loop)
	o: 99(for), 154(AF)

nname: 52
n 52(None)[position = len(self._data)
self._data.append(x)
]:
	i: 21(), 51()
	o: 86(loop), 155(AL)

nname: 51
n 51(None)[]:
	i: 0(t)
	o: 52()

nname: 21
n 21(None)[x.display_type = self.menu.type + '_' + x.type
]:
	i: 0(f)
	o: 52()

nname: 0
n 0(x.display_type)[x.menu = self.menu
]:
	i: 
	o: 21(f), 51(t)

nname: 154
n 154(None)[]:
	i: 86()
	o: 

nname: 86
n 86(None)[for owner in self._data._owners:
	owner = owner()
	louie_send(owner.list_name, sender=owner.menu, action='add', value=owner, position=position)
]:
	i: 0(loop)
	o: 154()

nname: 0
n 0(None)[x.menu = self.menu
if not x.display_type:
	x.display_type = self.menu.type + '_' + x.type
position = len(self._data)
self._data.append(x)
]:
	i: 
	o: 86(loop)

nname: 154
n 154(None)[]:
	i: 0()
	o: 

nname: 0
n 0(None)[x.menu = self.menu
if not x.display_type:
	x.display_type = self.menu.type + '_' + x.type
position = len(self._data)
self._data.append(x)
for owner in self._data._owners:
	owner = owner()
	louie_send(owner.list_name, sender=owner.menu, action='add', value=owner, position=position)
]:
	i: 
	o: 154()

nname: 0
n 0(None)[x.menu = self.menu
if not x.display_type:
	x.display_type = self.menu.type + '_' + x.type
position = len(self._data)
self._data.append(x)
for owner in self._data._owners:
	owner = owner()
	louie_send(owner.list_name, sender=owner.menu, action='add', value=owner, position=position)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7584fac>}
nname: 197
n 197(None)[]:
	i: 0(AL), 196()
	o: 

nname: 196
n 196(None)[]:
	i: 56(AF), 193()
	o: 197()

nname: 193
n 193(None)[]:
	i: 117(AL), 192()
	o: 196()

nname: 192
n 192(None)[]:
	i: 120(AF), 133()
	o: 193()

nname: 133
n 133(None)[for owner in self._data._owners:
owner = owner()
louie_send(owner.list_name, sender=owner.menu, action='add', value=owner, position=position + i)
]:
	i: 120(for)
	o: 192()

nname: 120
n 120(None)[]:
	i: 117(loop)
	o: 133(for), 192(AF)

nname: 117
n 117(None)[]:
	i: 96(), 116()
	o: 120(loop), 193(AL)

nname: 116
n 116(None)[]:
	i: 69(t)
	o: 117()

nname: 96
n 96(None)[x.display_type = display_prefix + x.type
]:
	i: 69(f)
	o: 117()

nname: 69
n 69(x.display_type)[for i, x in enumerate(other_list):
x.menu = menu
]:
	i: 56(for)
	o: 96(f), 116(t)

nname: 56
n 56(None)[]:
	i: 0(loop)
	o: 69(for), 196(AF)

nname: 0
n 0(None)[menu = self.menu
position = len(self._data)
self._data.extend(other_list)
display_prefix = menu.type + '_'
]:
	i: 
	o: 56(loop), 197(AL)

nname: 197
n 197(None)[]:
	i: 0(AL), 56(AF), 192()
	o: 

nname: 192
n 192(None)[]:
	i: 120()
	o: 197()

nname: 120
n 120(None)[for owner in self._data._owners:
	owner = owner()
	louie_send(owner.list_name, sender=owner.menu, action='add', value=owner, position=position + i)
]:
	i: 69(loop)
	o: 192()

nname: 69
n 69(None)[for i, x in enumerate(other_list):
x.menu = menu
if not x.display_type:
	x.display_type = display_prefix + x.type
]:
	i: 56(for)
	o: 120(loop)

nname: 56
n 56(None)[]:
	i: 0(loop)
	o: 69(for), 197(AF)

nname: 0
n 0(None)[menu = self.menu
position = len(self._data)
self._data.extend(other_list)
display_prefix = menu.type + '_'
]:
	i: 
	o: 56(loop), 197(AL)

nname: 197
n 197(None)[]:
	i: 0(AL), 56(AF), 69()
	o: 

nname: 69
n 69(None)[for i, x in enumerate(other_list):
x.menu = menu
if not x.display_type:
	x.display_type = display_prefix + x.type
for owner in self._data._owners:
	owner = owner()
	louie_send(owner.list_name, sender=owner.menu, action='add', value=owner, position=position + i)
]:
	i: 56(for)
	o: 197()

nname: 56
n 56(None)[]:
	i: 0(loop)
	o: 69(for), 197(AF)

nname: 0
n 0(None)[menu = self.menu
position = len(self._data)
self._data.extend(other_list)
display_prefix = menu.type + '_'
]:
	i: 
	o: 56(loop), 197(AL)

nname: 69
n 69(None)[for i, x in enumerate(other_list):
	x.menu = menu
	if not x.display_type:
		x.display_type = display_prefix + x.type
	for owner in self._data._owners:
		owner = owner()
		louie_send(owner.list_name, sender=owner.menu, action='add', value=owner, position=position + i)
]:
	i: 0(for)
	o: 

nname: 0
n 0(None)[menu = self.menu
position = len(self._data)
self._data.extend(other_list)
display_prefix = menu.type + '_'
]:
	i: 
	o: 69(for)

nname: 0
n 0(None)[menu = self.menu
position = len(self._data)
self._data.extend(other_list)
display_prefix = menu.type + '_'
for i, x in enumerate(other_list):
	x.menu = menu
	if not x.display_type:
		x.display_type = display_prefix + x.type
	for owner in self._data._owners:
		owner = owner()
		louie_send(owner.list_name, sender=owner.menu, action='add', value=owner, position=position + i)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb757db6c>}
nname: 0
n 0(None)[index = self._data.index(x)
del self[index]
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb757d84c>}
nname: 132
n 132(None)[return elt
]:
	i: 42(AL), 131()
	o: 

nname: 131
n 131(None)[]:
	i: 63(AF), 76()
	o: 132()

nname: 76
n 76(None)[for owner in self._data._owners:
owner = owner()
louie_send(owner.list_name, sender=owner.menu, action='remove', value=owner, position=index)
]:
	i: 63(for)
	o: 131()

nname: 63
n 63(None)[]:
	i: 42(loop)
	o: 76(for), 131(AF)

nname: 42
n 42(None)[elt = self._data.pop(i)
]:
	i: 12(), 35()
	o: 63(loop), 132(AL)

nname: 35
n 35(None)[index = i
]:
	i: 0(f)
	o: 42()

nname: 12
n 12(None)[index = len(self._data) + i
]:
	i: 0(t)
	o: 42()

nname: 0
n 0(i < 0)[]:
	i: 
	o: 12(t), 35(f)

nname: 131
n 131(None)[return elt
]:
	i: 63()
	o: 

nname: 63
n 63(None)[for owner in self._data._owners:
	owner = owner()
	louie_send(owner.list_name, sender=owner.menu, action='remove', value=owner, position=index)
]:
	i: 0(loop)
	o: 131()

nname: 0
n 0(None)[if i < 0:
	index = len(self._data) + i
else:
	index = i
elt = self._data.pop(i)
]:
	i: 
	o: 63(loop)

nname: 131
n 131(None)[return elt
]:
	i: 0()
	o: 

nname: 0
n 0(None)[if i < 0:
	index = len(self._data) + i
else:
	index = i
elt = self._data.pop(i)
for owner in self._data._owners:
	owner = owner()
	louie_send(owner.list_name, sender=owner.menu, action='remove', value=owner, position=index)
]:
	i: 
	o: 131()

nname: 0
n 0(None)[if i < 0:
	index = len(self._data) + i
else:
	index = i
elt = self._data.pop(i)
for owner in self._data._owners:
	owner = owner()
	louie_send(owner.list_name, sender=owner.menu, action='remove', value=owner, position=index)
return elt
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7581c0c>}
nname: 365
n 365(None)[]:
	i: 144(JA), 149(), 301(JA), 306(), 309(AL), 364()
	o: 

nname: 364
n 364(None)[]:
	i: 313(AF), 326()
	o: 365()

nname: 326
n 326(None)[for owner in self._data._owners:
owner = owner()
louie_send('%s_no_limit' % owner.list_name, owner.menu)
]:
	i: 313(for)
	o: 364()

nname: 313
n 313(None)[]:
	i: 309(loop)
	o: 326(for), 364(AF)

nname: 309
n 309(None)[]:
	i: 152(f)
	o: 313(loop), 365(AL)

nname: 306
n 306(None)[]:
	i: 246(AL), 305()
	o: 365()

nname: 305
n 305(None)[]:
	i: 234(t)
	o: 306()

nname: 301
n 301(None)[]:
	i: 250(AF), 263()
	o: 365(JA)

nname: 263
n 263(None)[for owner in self._data._owners:
owner = owner()
louie_send('%s_top_limit' % owner.list_name, owner.menu)
]:
	i: 250(for)
	o: 301()

nname: 250
n 250(None)[]:
	i: 246(loop)
	o: 263(for), 301(AF)

nname: 246
n 246(None)[]:
	i: 234(f)
	o: 250(loop), 306(AL)

nname: 234
n 234(len(self))[]:
	i: 178(AL), 233()
	o: 246(f), 305(t)

nname: 233
n 233(None)[]:
	i: 182(AF), 195()
	o: 234()

nname: 195
n 195(None)[for owner in self._data._owners:
owner = owner()
louie_send('%s_bottom_limit' % owner.list_name, owner.menu)
]:
	i: 182(for)
	o: 233()

nname: 182
n 182(None)[]:
	i: 178(loop)
	o: 195(for), 233(AF)

nname: 178
n 178(None)[]:
	i: 152(t)
	o: 182(loop), 234(AL)

nname: 152
n 152(self.selected_pos == len(self) - 1)[]:
	i: 0(f)
	o: 178(t), 309(f)

nname: 149
n 149(None)[]:
	i: 89(AL), 148()
	o: 365()

nname: 148
n 148(None)[]:
	i: 71(f)
	o: 149()

nname: 144
n 144(None)[]:
	i: 93(AF), 106()
	o: 365(JA)

nname: 106
n 106(None)[for owner in self._data._owners:
owner = owner()
louie_send('%s_bottom_limit' % owner.list_name, owner.menu)
]:
	i: 93(for)
	o: 144()

nname: 93
n 93(None)[]:
	i: 89(loop)
	o: 106(for), 144(AF)

nname: 89
n 89(None)[]:
	i: 71(t)
	o: 93(loop), 149(AL)

nname: 71
n 71(len(self) == 1)[]:
	i: 15(AL), 70()
	o: 89(t), 148(f)

nname: 70
n 70(None)[]:
	i: 19(AF), 32()
	o: 71()

nname: 32
n 32(None)[for owner in self._data._owners:
owner = owner()
louie_send('%s_top_limit' % owner.list_name, owner.menu)
]:
	i: 19(for)
	o: 70()

nname: 19
n 19(None)[]:
	i: 15(loop)
	o: 32(for), 70(AF)

nname: 15
n 15(None)[]:
	i: 0(t)
	o: 19(loop), 71(AL)

nname: 0
n 0(self.selected_pos == 0)[]:
	i: 
	o: 15(t), 152(f)

nname: 365
n 365(None)[]:
	i: 326(), 93(AF), 106(), 89(AL), 71(f), 250(AF), 263(), 246(AL), 234(t)
	o: 

nname: 326
n 326(None)[for owner in self._data._owners:
	owner = owner()
	louie_send('%s_no_limit' % owner.list_name, owner.menu)
]:
	i: 309(for)
	o: 365()

nname: 309
n 309(None)[]:
	i: 152(f)
	o: 326(for)

nname: 263
n 263(None)[for owner in self._data._owners:
owner = owner()
louie_send('%s_top_limit' % owner.list_name, owner.menu)
]:
	i: 250(for)
	o: 365()

nname: 250
n 250(None)[]:
	i: 246(loop)
	o: 263(for), 365(AF)

nname: 246
n 246(None)[]:
	i: 234(f)
	o: 250(loop), 365(AL)

nname: 234
n 234(len(self))[]:
	i: 195()
	o: 246(f), 365(t)

nname: 195
n 195(None)[for owner in self._data._owners:
	owner = owner()
	louie_send('%s_bottom_limit' % owner.list_name, owner.menu)
]:
	i: 178(for)
	o: 234()

nname: 178
n 178(None)[]:
	i: 152(t)
	o: 195(for)

nname: 152
n 152(self.selected_pos == len(self) - 1)[]:
	i: 0(f)
	o: 178(t), 309(f)

nname: 106
n 106(None)[for owner in self._data._owners:
owner = owner()
louie_send('%s_bottom_limit' % owner.list_name, owner.menu)
]:
	i: 93(for)
	o: 365()

nname: 93
n 93(None)[]:
	i: 89(loop)
	o: 106(for), 365(AF)

nname: 89
n 89(None)[]:
	i: 71(t)
	o: 93(loop), 365(AL)

nname: 71
n 71(len(self) == 1)[]:
	i: 32()
	o: 89(t), 365(f)

nname: 32
n 32(None)[for owner in self._data._owners:
	owner = owner()
	louie_send('%s_top_limit' % owner.list_name, owner.menu)
]:
	i: 15(for)
	o: 71()

nname: 15
n 15(None)[]:
	i: 0(t)
	o: 32(for)

nname: 0
n 0(self.selected_pos == 0)[]:
	i: 
	o: 15(t), 152(f)

nname: 365
n 365(None)[]:
	i: 309(), 106(), 71(f), 263(), 234(t)
	o: 

nname: 309
n 309(None)[for owner in self._data._owners:
	owner = owner()
	louie_send('%s_no_limit' % owner.list_name, owner.menu)
]:
	i: 152(f)
	o: 365()

nname: 263
n 263(None)[for owner in self._data._owners:
	owner = owner()
	louie_send('%s_top_limit' % owner.list_name, owner.menu)
]:
	i: 246(for)
	o: 365()

nname: 246
n 246(None)[]:
	i: 234(f)
	o: 263(for)

nname: 234
n 234(len(self))[]:
	i: 178()
	o: 246(f), 365(t)

nname: 178
n 178(None)[for owner in self._data._owners:
	owner = owner()
	louie_send('%s_bottom_limit' % owner.list_name, owner.menu)
]:
	i: 152(t)
	o: 234()

nname: 152
n 152(self.selected_pos == len(self) - 1)[]:
	i: 0(f)
	o: 178(t), 309(f)

nname: 106
n 106(None)[for owner in self._data._owners:
	owner = owner()
	louie_send('%s_bottom_limit' % owner.list_name, owner.menu)
]:
	i: 89(for)
	o: 365()

nname: 89
n 89(None)[]:
	i: 71(t)
	o: 106(for)

nname: 71
n 71(len(self) == 1)[]:
	i: 15()
	o: 89(t), 365(f)

nname: 15
n 15(None)[for owner in self._data._owners:
	owner = owner()
	louie_send('%s_top_limit' % owner.list_name, owner.menu)
]:
	i: 0(t)
	o: 71()

nname: 0
n 0(self.selected_pos == 0)[]:
	i: 
	o: 15(t), 152(f)

nname: 365
n 365(None)[]:
	i: 309(), 89(), 15(f), 246(), 178(t)
	o: 

nname: 309
n 309(None)[for owner in self._data._owners:
	owner = owner()
	louie_send('%s_no_limit' % owner.list_name, owner.menu)
]:
	i: 152(f)
	o: 365()

nname: 246
n 246(None)[for owner in self._data._owners:
	owner = owner()
	louie_send('%s_top_limit' % owner.list_name, owner.menu)
]:
	i: 178(f)
	o: 365()

nname: 178
n 178(len(self))[for owner in self._data._owners:
	owner = owner()
	louie_send('%s_bottom_limit' % owner.list_name, owner.menu)
]:
	i: 152(t)
	o: 246(f), 365(t)

nname: 152
n 152(self.selected_pos == len(self) - 1)[]:
	i: 0(f)
	o: 178(t), 309(f)

nname: 89
n 89(None)[for owner in self._data._owners:
	owner = owner()
	louie_send('%s_bottom_limit' % owner.list_name, owner.menu)
]:
	i: 15(t)
	o: 365()

nname: 15
n 15(len(self) == 1)[for owner in self._data._owners:
	owner = owner()
	louie_send('%s_top_limit' % owner.list_name, owner.menu)
]:
	i: 0(t)
	o: 89(t), 365(f)

nname: 0
n 0(self.selected_pos == 0)[]:
	i: 
	o: 15(t), 152(f)

nname: 0
n 0(None)[if self.selected_pos == 0:
	for owner in self._data._owners:
		owner = owner()
		louie_send('%s_top_limit' % owner.list_name, owner.menu)
	if len(self) == 1:
		for owner in self._data._owners:
			owner = owner()
			louie_send('%s_bottom_limit' % owner.list_name, owner.menu)
else:
	if self.selected_pos == len(self) - 1:
		for owner in self._data._owners:
			owner = owner()
			louie_send('%s_bottom_limit' % owner.list_name, owner.menu)
		if not len(self):
			for owner in self._data._owners:
				owner = owner()
				louie_send('%s_top_limit' % owner.list_name, owner.menu)
	else:
		for owner in self._data._owners:
			owner = owner()
			louie_send('%s_no_limit' % owner.list_name, owner.menu)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb758168c>}
nname: 115
n 115(None)[]:
	i: 15(), 91(), 114()
	o: 

nname: 114
n 114(None)[]:
	i: 68&84(f)
	o: 115()

nname: 91
n 91(None)[louie_send('edit_list_not_editable', sender=self.menu)
]:
	i: 68&84(t)
	o: 115()

nname: 68&84
n 68&84(val == self._edited and val)[]:
	i: 0(f)
	o: 91(t), 114(f)

nname: 15
n 15(None)[louie_send(self.list_name, sender=self.menu, action='edit', value=self, edit_mode=val)
self._edited = val
]:
	i: 0(t)
	o: 115()

nname: 0
n 0(val != self._edited)[]:
	i: 
	o: 15(t), 68&84(f)

nname: 0
n 0(None)[if val != self._edited:
	louie_send(self.list_name, sender=self.menu, action='edit', value=self, edit_mode=val)
	self._edited = val
else:
	if val == self._edited and val:
		louie_send('edit_list_not_editable', sender=self.menu)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb758102c>}
nname: 0
n 0(None)[return self._edited
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb758446c>}
nname: 0
n 0(None)[return self._edited
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb758422c>}
nname: 0
n 0(None)[louie_send(self.list_name, sender=self.menu, action='reset', value=self)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb757d40c>}
nname: 1106
n 1106(None)[return None
]:
	i: 12(), 613(), 1102()
	o: 

nname: 1102
n 1102(None)[return False
]:
	i: 896(), 1041(), 1101()
	o: 1106()

nname: 1101
n 1101(None)[]:
	i: 956&969(f)
	o: 1102()

nname: 1041
n 1041(None)[louie_send(self.list_name, sender=self.menu, action='update', value=self, position=self.selected_pos)
self.advertise()
return True
]:
	i: 979(AL), 1040()
	o: 1102()

nname: 1040
n 1040(None)[]:
	i: 1011(AF), 1021()
	o: 1041()

nname: 1021
n 1021(None)[for observer in self._ItemList__sel_observers:
observer(self, old_sel)
]:
	i: 1011(for)
	o: 1040()

nname: 1011
n 1011(None)[]:
	i: 979(loop)
	o: 1021(for), 1040(AF)

nname: 979
n 979(None)[old_sel = self.selected
self.selected_pos = len(self) - 1
]:
	i: 956&969(t)
	o: 1011(loop), 1041(AL)

nname: 956&969
n 956&969(index == -1 and self.cyclic)[]:
	i: 737(f)
	o: 979(t), 1101(f)

nname: 896
n 896(None)[louie_send(self.list_name, sender=self.menu, action='update', value=self, position=self.selected_pos)
self.advertise()
return True
]:
	i: 845(AL), 895()
	o: 1102()

nname: 895
n 895(None)[]:
	i: 866(AF), 876()
	o: 896()

nname: 876
n 876(None)[for observer in self._ItemList__sel_observers:
observer(self, old_sel)
]:
	i: 866(for)
	o: 895()

nname: 866
n 866(None)[]:
	i: 845(loop)
	o: 876(for), 895(AF)

nname: 845
n 845(None)[self.selected_pos = index
old_sel = self.selected
]:
	i: 777(), 825(JA), 835(), 843(AE)
	o: 866(loop), 896(AL)

nname: 843
n 843(None)[]:
	i: 796(f)
	o: 845(AE)

nname: 835
n 835(None)[return False
]:
	i: 812(f)
	o: 845()

nname: 825
n 825(None)[index = 0
]:
	i: 812(t)
	o: 845(JA)

nname: 812
n 812(self.cyclic)[]:
	i: 796(t)
	o: 825(t), 835(f)

nname: 796
n 796(<dummy_ex3> EXC_MATCH (ValueError, IndexError))[]:
	i: 774(except)
	o: 812(t), 843(f)

nname: 777
n 777(None)[index = self._ItemList__find_next_selectable(index)
]:
	i: 774(try)
	o: 845()

nname: 774
n 774(None)[]:
	i: 765(), 773()
	o: 777(try), 796(except)

nname: 773
n 773(None)[]:
	i: 749(f)
	o: 774()

nname: 765
n 765(None)[return False
]:
	i: 749(t)
	o: 774()

nname: 749
n 749(self.selected_pos == index)[]:
	i: 737(t)
	o: 765(t), 773(f)

nname: 737
n 737(0 <= index)[]:
	i: 642(), 709(JA), 719(), 736()
	o: 749(t), 956&969(f)

nname: 736
n 736(None)[]:
	i: 664(f)
	o: 737()

nname: 719
n 719(None)[index = self.selected_pos + item
]:
	i: 680&693(f)
	o: 737()

nname: 709
n 709(None)[index = item
]:
	i: 680&693(t)
	o: 737(JA)

nname: 680&693
n 680&693(force_pos is True or self.selected is None)[]:
	i: 664(t)
	o: 709(t), 719(f)

nname: 664
n 664(isinstance(item, int))[]:
	i: 620(f)
	o: 680&693(t), 736(f)

nname: 642
n 642(None)[index = self._data.index(item)
]:
	i: 620(t)
	o: 737()

nname: 620
n 620(isinstance(item, Item))[index = 0
]:
	i: 68(f)
	o: 642(t), 664(f)

nname: 613
n 613(None)[return True
]:
	i: 370(AL), 612()
	o: 1106()

nname: 612
n 612(None)[]:
	i: 373(AF), 563()
	o: 613()

nname: 563
n 563(None)[louie_send(owner.list_name, sender=owner.menu, action='swap', value=owner, i1=pos1, i2=pos2)
]:
	i: 539(JA), 558(), 562()
	o: 612()

nname: 562
n 562(None)[]:
	i: 386(f)
	o: 563()

nname: 558
n 558(None)[]:
	i: 533(f)
	o: 563()

nname: 539
n 539(None)[owner.selected_pos += offset
]:
	i: 533(t)
	o: 563(JA)

nname: 533
n 533(offset)[]:
	i: 432(), 479(), 522(), 532()
	o: 539(t), 558(f)

nname: 532
n 532(None)[]:
	i: 519(f)
	o: 533()

nname: 522
n 522(None)[offset = 1
]:
	i: 519(t)
	o: 533()

nname: 519
n 519(pos2 <= owner.selected_pos)[]:
	i: 507(), 517()
	o: 522(t), 532(f)

nname: 517
n 517(None)[owner.selected_pos
]:
	i: 489(f)
	o: 519()

nname: 507
n 507(None)[]:
	i: 489(t)
	o: 519()

nname: 489
n 489(pos2 <= owner.selected_pos)[]:
	i: 476(f)
	o: 507(t), 517(f)

nname: 479
n 479(None)[offset = -1
]:
	i: 476(t)
	o: 533()

nname: 476
n 476(pos1 < owner.selected_pos)[]:
	i: 464(), 474()
	o: 479(t), 489(f)

nname: 474
n 474(None)[owner.selected_pos
]:
	i: 446(f)
	o: 476()

nname: 464
n 464(None)[]:
	i: 446(t)
	o: 476()

nname: 446
n 446(pos1 < owner.selected_pos)[]:
	i: 410(f)
	o: 464(t), 474(f)

nname: 432
n 432(None)[offset = pos2 - pos1
]:
	i: 410(t)
	o: 533()

nname: 410
n 410(pos1 == owner.selected_pos)[offset = 0
]:
	i: 386(t)
	o: 432(t), 446(f)

nname: 386
n 386(owner != self)[for owner in self._data._owners:
owner = owner()
]:
	i: 373(for)
	o: 410(t), 562(f)

nname: 373
n 373(None)[]:
	i: 370(loop)
	o: 386(for), 612(AF)

nname: 370
n 370(None)[]:
	i: 292(), 350()
	o: 373(loop), 613(AL)

nname: 350
n 350(None)[self._data.swap(pos1, pos2)
]:
	i: 259(f)
	o: 370()

nname: 292
n 292(None)[tmp = self._data[pos1]
self._data[pos1], self._data[pos2] = self._data[pos2], self._data[pos1]
]:
	i: 259(t)
	o: 370()

nname: 259
n 259(isinstance(self._data, list))[self.selected_pos += item
]:
	i: 250(), 258()
	o: 292(t), 350(f)

nname: 258
n 258(None)[]:
	i: 238(f)
	o: 259()

nname: 250
n 250(None)[return False
]:
	i: 238(t)
	o: 259()

nname: 238
n 238(0 > min_pos)[]:
	i: 200(), 225(), 236(AE)
	o: 250(t), 258(f)

nname: 236
n 236(None)[]:
	i: 215(f)
	o: 238(AE)

nname: 225
n 225(None)[return False
]:
	i: 215(t)
	o: 238()

nname: 215
n 215(<dummy_ex3> EXC_MATCH IndexError)[]:
	i: 188(except)
	o: 225(t), 236(f)

nname: 200
n 200(None)[self._data[max_pos]
]:
	i: 188(try)
	o: 238()

nname: 188
n 188(None)[max_pos, min_pos = (pos2, pos1)
]:
	i: 165(), 178()
	o: 200(try), 215(except)

nname: 178
n 178(None)[]:
	i: 153(f)
	o: 188()

nname: 165
n 165(None)[]:
	i: 153(t)
	o: 188()

nname: 153
n 153(pos1 > pos2)[]:
	i: 91(), 115(), 151(AE)
	o: 165(t), 178(f)

nname: 151
n 151(None)[]:
	i: 105(f)
	o: 153(AE)

nname: 115
n 115(None)[log.error('%s.select(%s, %s)', self.list_name, item, force_pos)
return False
]:
	i: 105(t)
	o: 153()

nname: 105
n 105(<dummy_ex3> EXC_MATCH TypeError)[]:
	i: 78(except)
	o: 115(t), 151(f)

nname: 91
n 91(None)[pos2 = pos1 + item
]:
	i: 78(try)
	o: 153()

nname: 78
n 78(None)[pos1 = self.selected_pos
]:
	i: 68(t)
	o: 91(try), 105(except)

nname: 68
n 68(self._edited)[]:
	i: 0(f)
	o: 78(t), 620(f)

nname: 12
n 12(None)[pos = self.selected_pos
self.selected_pos = -1
louie_send(self.list_name, sender=self.menu, action='reset', value=self)
]:
	i: 0(t)
	o: 1106()

nname: 0
n 0(item is None)[]:
	i: 
	o: 12(t), 68(f)

nname: 1106
n 1106(None)[return None
]:
	i: 12(), 613(), 1102()
	o: 

nname: 1102
n 1102(None)[return False
]:
	i: 896(), 1041(), 956&969(f)
	o: 1106()

nname: 1041
n 1041(None)[louie_send(self.list_name, sender=self.menu, action='update', value=self, position=self.selected_pos)
self.advertise()
return True
]:
	i: 1021()
	o: 1102()

nname: 1021
n 1021(None)[for observer in self._ItemList__sel_observers:
	observer(self, old_sel)
]:
	i: 979(for)
	o: 1041()

nname: 979
n 979(None)[old_sel = self.selected
self.selected_pos = len(self) - 1
]:
	i: 956&969(t)
	o: 1021(for)

nname: 956&969
n 956&969(index == -1 and self.cyclic)[]:
	i: 620(f)
	o: 979(t), 1102(f)

nname: 896
n 896(None)[louie_send(self.list_name, sender=self.menu, action='update', value=self, position=self.selected_pos)
self.advertise()
return True
]:
	i: 876()
	o: 1102()

nname: 876
n 876(None)[for observer in self._ItemList__sel_observers:
	observer(self, old_sel)
]:
	i: 845(for)
	o: 896()

nname: 845
n 845(None)[self.selected_pos = index
old_sel = self.selected
]:
	i: 777(JA)
	o: 876(for)

nname: 777
n 777(None)[try:
	index = self._ItemList__find_next_selectable(index)
except (ValueError, IndexError):
	if self.cyclic:
		index = 0
	else:
		return False
]:
	i: 749(try)
	o: 845(JA)

nname: 749
n 749(None)[if self.selected_pos == index:
	return False
]:
	i: 620(t)
	o: 777(try)

nname: 620
n 620(0 <= index)[index = 0
if isinstance(item, Item):
	index = self._data.index(item)
else:
	if isinstance(item, int):
		if force_pos is True or self.selected is None:
			index = item
		else:
			index = self.selected_pos + item
]:
	i: 68(f)
	o: 749(t), 956&969(f)

nname: 613
n 613(None)[return True
]:
	i: 259(AL), 373(AF), 563()
	o: 1106()

nname: 563
n 563(None)[louie_send(owner.list_name, sender=owner.menu, action='swap', value=owner, i1=pos1, i2=pos2)
]:
	i: 533(JA), 386(f)
	o: 613()

nname: 533
n 533(None)[if offset:
	owner.selected_pos += offset
]:
	i: 432(), 479(), 489()
	o: 563(JA)

nname: 489
n 489(None)[if pos2 <= owner.selected_pos:
	pass
else:
	owner.selected_pos
if pos2 <= owner.selected_pos:
	offset = 1
]:
	i: 446(f)
	o: 533()

nname: 479
n 479(None)[offset = -1
]:
	i: 446(t)
	o: 533()

nname: 446
n 446(pos1 < owner.selected_pos)[if pos1 < owner.selected_pos:
	pass
else:
	owner.selected_pos
]:
	i: 410(f)
	o: 479(t), 489(f)

nname: 432
n 432(None)[offset = pos2 - pos1
]:
	i: 410(t)
	o: 533()

nname: 410
n 410(pos1 == owner.selected_pos)[offset = 0
]:
	i: 386(t)
	o: 432(t), 446(f)

nname: 386
n 386(owner != self)[for owner in self._data._owners:
owner = owner()
]:
	i: 373(for)
	o: 410(t), 563(f)

nname: 373
n 373(None)[]:
	i: 259(loop)
	o: 386(for), 613(AF)

nname: 259
n 259(None)[self.selected_pos += item
if isinstance(self._data, list):
	tmp = self._data[pos1]
	self._data[pos1], self._data[pos2] = self._data[pos2], self._data[pos1]
else:
	self._data.swap(pos1, pos2)
]:
	i: 215()
	o: 373(loop), 613(AL)

nname: 215
n 215(None)[except IndexError:
	return False
if 0 > min_pos:
	return False
]:
	i: 188()
	o: 259()

nname: 188
n 188(None)[max_pos, min_pos = (pos2, pos1)
try:
	self._data[max_pos]
]:
	i: 105()
	o: 215()

nname: 105
n 105(None)[except TypeError:
	log.error('%s.select(%s, %s)', self.list_name, item, force_pos)
	return False
if pos1 > pos2:
	pass
]:
	i: 78()
	o: 188()

nname: 78
n 78(None)[pos1 = self.selected_pos
try:
	pos2 = pos1 + item
]:
	i: 68(t)
	o: 105()

nname: 68
n 68(self._edited)[]:
	i: 0(f)
	o: 78(t), 620(f)

nname: 12
n 12(None)[pos = self.selected_pos
self.selected_pos = -1
louie_send(self.list_name, sender=self.menu, action='reset', value=self)
]:
	i: 0(t)
	o: 1106()

nname: 0
n 0(item is None)[]:
	i: 
	o: 12(t), 68(f)

nname: 1106
n 1106(None)[return None
]:
	i: 12(), 613(), 1102()
	o: 

nname: 1102
n 1102(None)[return False
]:
	i: 896(), 1041(), 956&969(f)
	o: 1106()

nname: 1041
n 1041(None)[louie_send(self.list_name, sender=self.menu, action='update', value=self, position=self.selected_pos)
self.advertise()
return True
]:
	i: 979()
	o: 1102()

nname: 979
n 979(None)[old_sel = self.selected
self.selected_pos = len(self) - 1
for observer in self._ItemList__sel_observers:
	observer(self, old_sel)
]:
	i: 956&969(t)
	o: 1041()

nname: 956&969
n 956&969(index == -1 and self.cyclic)[]:
	i: 620(f)
	o: 979(t), 1102(f)

nname: 896
n 896(None)[louie_send(self.list_name, sender=self.menu, action='update', value=self, position=self.selected_pos)
self.advertise()
return True
]:
	i: 845()
	o: 1102()

nname: 845
n 845(None)[self.selected_pos = index
old_sel = self.selected
for observer in self._ItemList__sel_observers:
	observer(self, old_sel)
]:
	i: 749(JA)
	o: 896()

nname: 749
n 749(None)[if self.selected_pos == index:
	return False
try:
	index = self._ItemList__find_next_selectable(index)
except (ValueError, IndexError):
	if self.cyclic:
		index = 0
	else:
		return False
]:
	i: 620(t)
	o: 845(JA)

nname: 620
n 620(0 <= index)[index = 0
if isinstance(item, Item):
	index = self._data.index(item)
else:
	if isinstance(item, int):
		if force_pos is True or self.selected is None:
			index = item
		else:
			index = self.selected_pos + item
]:
	i: 68(f)
	o: 749(t), 956&969(f)

nname: 613
n 613(None)[return True
]:
	i: 259(AL), 373(AF), 563()
	o: 1106()

nname: 563
n 563(None)[louie_send(owner.list_name, sender=owner.menu, action='swap', value=owner, i1=pos1, i2=pos2)
]:
	i: 410(JA), 386(f)
	o: 613()

nname: 410
n 410(None)[offset = 0
if pos1 == owner.selected_pos:
	offset = pos2 - pos1
else:
	if pos1 < owner.selected_pos:
		pass
	else:
		owner.selected_pos
	if pos1 < owner.selected_pos:
		offset = -1
	else:
		if pos2 <= owner.selected_pos:
			pass
		else:
			owner.selected_pos
		if pos2 <= owner.selected_pos:
			offset = 1
if offset:
	owner.selected_pos += offset
]:
	i: 386(t)
	o: 563(JA)

nname: 386
n 386(owner != self)[for owner in self._data._owners:
owner = owner()
]:
	i: 373(for)
	o: 410(t), 563(f)

nname: 373
n 373(None)[]:
	i: 259(loop)
	o: 386(for), 613(AF)

nname: 259
n 259(None)[self.selected_pos += item
if isinstance(self._data, list):
	tmp = self._data[pos1]
	self._data[pos1], self._data[pos2] = self._data[pos2], self._data[pos1]
else:
	self._data.swap(pos1, pos2)
]:
	i: 188()
	o: 373(loop), 613(AL)

nname: 188
n 188(None)[max_pos, min_pos = (pos2, pos1)
try:
	self._data[max_pos]
except IndexError:
	return False
if 0 > min_pos:
	return False
]:
	i: 78()
	o: 259()

nname: 78
n 78(None)[pos1 = self.selected_pos
try:
	pos2 = pos1 + item
except TypeError:
	log.error('%s.select(%s, %s)', self.list_name, item, force_pos)
	return False
if pos1 > pos2:
	pass
]:
	i: 68(t)
	o: 188()

nname: 68
n 68(self._edited)[]:
	i: 0(f)
	o: 78(t), 620(f)

nname: 12
n 12(None)[pos = self.selected_pos
self.selected_pos = -1
louie_send(self.list_name, sender=self.menu, action='reset', value=self)
]:
	i: 0(t)
	o: 1106()

nname: 0
n 0(item is None)[]:
	i: 
	o: 12(t), 68(f)

nname: 1106
n 1106(None)[return None
]:
	i: 12(), 613(), 1102()
	o: 

nname: 1102
n 1102(None)[return False
]:
	i: 896(), 979(), 956&969(f)
	o: 1106()

nname: 979
n 979(None)[old_sel = self.selected
self.selected_pos = len(self) - 1
for observer in self._ItemList__sel_observers:
	observer(self, old_sel)
louie_send(self.list_name, sender=self.menu, action='update', value=self, position=self.selected_pos)
self.advertise()
return True
]:
	i: 956&969(t)
	o: 1102()

nname: 956&969
n 956&969(index == -1 and self.cyclic)[]:
	i: 620(f)
	o: 979(t), 1102(f)

nname: 896
n 896(None)[louie_send(self.list_name, sender=self.menu, action='update', value=self, position=self.selected_pos)
self.advertise()
return True
]:
	i: 749()
	o: 1102()

nname: 749
n 749(None)[if self.selected_pos == index:
	return False
try:
	index = self._ItemList__find_next_selectable(index)
except (ValueError, IndexError):
	if self.cyclic:
		index = 0
	else:
		return False
self.selected_pos = index
old_sel = self.selected
for observer in self._ItemList__sel_observers:
	observer(self, old_sel)
]:
	i: 620(t)
	o: 896()

nname: 620
n 620(0 <= index)[index = 0
if isinstance(item, Item):
	index = self._data.index(item)
else:
	if isinstance(item, int):
		if force_pos is True or self.selected is None:
			index = item
		else:
			index = self.selected_pos + item
]:
	i: 68(f)
	o: 749(t), 956&969(f)

nname: 613
n 613(None)[return True
]:
	i: 259(AL), 373(AF), 386()
	o: 1106()

nname: 386
n 386(None)[for owner in self._data._owners:
owner = owner()
if owner != self:
	offset = 0
	if pos1 == owner.selected_pos:
		offset = pos2 - pos1
	else:
		if pos1 < owner.selected_pos:
			pass
		else:
			owner.selected_pos
		if pos1 < owner.selected_pos:
			offset = -1
		else:
			if pos2 <= owner.selected_pos:
				pass
			else:
				owner.selected_pos
			if pos2 <= owner.selected_pos:
				offset = 1
	if offset:
		owner.selected_pos += offset
louie_send(owner.list_name, sender=owner.menu, action='swap', value=owner, i1=pos1, i2=pos2)
]:
	i: 373(for)
	o: 613()

nname: 373
n 373(None)[]:
	i: 259(loop)
	o: 386(for), 613(AF)

nname: 259
n 259(None)[self.selected_pos += item
if isinstance(self._data, list):
	tmp = self._data[pos1]
	self._data[pos1], self._data[pos2] = self._data[pos2], self._data[pos1]
else:
	self._data.swap(pos1, pos2)
]:
	i: 78()
	o: 373(loop), 613(AL)

nname: 78
n 78(None)[pos1 = self.selected_pos
try:
	pos2 = pos1 + item
except TypeError:
	log.error('%s.select(%s, %s)', self.list_name, item, force_pos)
	return False
if pos1 > pos2:
	pass
max_pos, min_pos = (pos2, pos1)
try:
	self._data[max_pos]
except IndexError:
	return False
if 0 > min_pos:
	return False
]:
	i: 68(t)
	o: 259()

nname: 68
n 68(self._edited)[]:
	i: 0(f)
	o: 78(t), 620(f)

nname: 12
n 12(None)[pos = self.selected_pos
self.selected_pos = -1
louie_send(self.list_name, sender=self.menu, action='reset', value=self)
]:
	i: 0(t)
	o: 1106()

nname: 0
n 0(item is None)[]:
	i: 
	o: 12(t), 68(f)

nname: 1106
n 1106(None)[return None
]:
	i: 12(), 613(), 1102()
	o: 

nname: 1102
n 1102(None)[return False
]:
	i: 749(), 956&969(f)
	o: 1106()

nname: 956&969
n 956&969(None)[if index == -1 and self.cyclic:
	old_sel = self.selected
	self.selected_pos = len(self) - 1
	for observer in self._ItemList__sel_observers:
		observer(self, old_sel)
	louie_send(self.list_name, sender=self.menu, action='update', value=self, position=self.selected_pos)
	self.advertise()
	return True
]:
	i: 620(f)
	o: 1102()

nname: 749
n 749(None)[if self.selected_pos == index:
	return False
try:
	index = self._ItemList__find_next_selectable(index)
except (ValueError, IndexError):
	if self.cyclic:
		index = 0
	else:
		return False
self.selected_pos = index
old_sel = self.selected
for observer in self._ItemList__sel_observers:
	observer(self, old_sel)
louie_send(self.list_name, sender=self.menu, action='update', value=self, position=self.selected_pos)
self.advertise()
return True
]:
	i: 620(t)
	o: 1102()

nname: 620
n 620(0 <= index)[index = 0
if isinstance(item, Item):
	index = self._data.index(item)
else:
	if isinstance(item, int):
		if force_pos is True or self.selected is None:
			index = item
		else:
			index = self.selected_pos + item
]:
	i: 68(f)
	o: 749(t), 956&969(f)

nname: 613
n 613(None)[return True
]:
	i: 78(AL), 373(AF), 386()
	o: 1106()

nname: 386
n 386(None)[for owner in self._data._owners:
owner = owner()
if owner != self:
	offset = 0
	if pos1 == owner.selected_pos:
		offset = pos2 - pos1
	else:
		if pos1 < owner.selected_pos:
			pass
		else:
			owner.selected_pos
		if pos1 < owner.selected_pos:
			offset = -1
		else:
			if pos2 <= owner.selected_pos:
				pass
			else:
				owner.selected_pos
			if pos2 <= owner.selected_pos:
				offset = 1
	if offset:
		owner.selected_pos += offset
louie_send(owner.list_name, sender=owner.menu, action='swap', value=owner, i1=pos1, i2=pos2)
]:
	i: 373(for)
	o: 613()

nname: 373
n 373(None)[]:
	i: 78(loop)
	o: 386(for), 613(AF)

nname: 78
n 78(None)[pos1 = self.selected_pos
try:
	pos2 = pos1 + item
except TypeError:
	log.error('%s.select(%s, %s)', self.list_name, item, force_pos)
	return False
if pos1 > pos2:
	pass
max_pos, min_pos = (pos2, pos1)
try:
	self._data[max_pos]
except IndexError:
	return False
if 0 > min_pos:
	return False
self.selected_pos += item
if isinstance(self._data, list):
	tmp = self._data[pos1]
	self._data[pos1], self._data[pos2] = self._data[pos2], self._data[pos1]
else:
	self._data.swap(pos1, pos2)
]:
	i: 68(t)
	o: 373(loop), 613(AL)

nname: 68
n 68(self._edited)[]:
	i: 0(f)
	o: 78(t), 620(f)

nname: 12
n 12(None)[pos = self.selected_pos
self.selected_pos = -1
louie_send(self.list_name, sender=self.menu, action='reset', value=self)
]:
	i: 0(t)
	o: 1106()

nname: 0
n 0(item is None)[]:
	i: 
	o: 12(t), 68(f)

nname: 1106
n 1106(None)[return None
]:
	i: 12(), 613(), 620()
	o: 

nname: 620
n 620(None)[index = 0
if isinstance(item, Item):
	index = self._data.index(item)
else:
	if isinstance(item, int):
		if force_pos is True or self.selected is None:
			index = item
		else:
			index = self.selected_pos + item
if 0 <= index:
	if self.selected_pos == index:
		return False
	try:
		index = self._ItemList__find_next_selectable(index)
	except (ValueError, IndexError):
		if self.cyclic:
			index = 0
		else:
			return False
	self.selected_pos = index
	old_sel = self.selected
	for observer in self._ItemList__sel_observers:
		observer(self, old_sel)
	louie_send(self.list_name, sender=self.menu, action='update', value=self, position=self.selected_pos)
	self.advertise()
	return True
else:
	if index == -1 and self.cyclic:
		old_sel = self.selected
		self.selected_pos = len(self) - 1
		for observer in self._ItemList__sel_observers:
			observer(self, old_sel)
		louie_send(self.list_name, sender=self.menu, action='update', value=self, position=self.selected_pos)
		self.advertise()
		return True
return False
]:
	i: 68(f)
	o: 1106()

nname: 613
n 613(None)[return True
]:
	i: 78(AL), 373(AF), 386()
	o: 1106()

nname: 386
n 386(None)[for owner in self._data._owners:
owner = owner()
if owner != self:
	offset = 0
	if pos1 == owner.selected_pos:
		offset = pos2 - pos1
	else:
		if pos1 < owner.selected_pos:
			pass
		else:
			owner.selected_pos
		if pos1 < owner.selected_pos:
			offset = -1
		else:
			if pos2 <= owner.selected_pos:
				pass
			else:
				owner.selected_pos
			if pos2 <= owner.selected_pos:
				offset = 1
	if offset:
		owner.selected_pos += offset
louie_send(owner.list_name, sender=owner.menu, action='swap', value=owner, i1=pos1, i2=pos2)
]:
	i: 373(for)
	o: 613()

nname: 373
n 373(None)[]:
	i: 78(loop)
	o: 386(for), 613(AF)

nname: 78
n 78(None)[pos1 = self.selected_pos
try:
	pos2 = pos1 + item
except TypeError:
	log.error('%s.select(%s, %s)', self.list_name, item, force_pos)
	return False
if pos1 > pos2:
	pass
max_pos, min_pos = (pos2, pos1)
try:
	self._data[max_pos]
except IndexError:
	return False
if 0 > min_pos:
	return False
self.selected_pos += item
if isinstance(self._data, list):
	tmp = self._data[pos1]
	self._data[pos1], self._data[pos2] = self._data[pos2], self._data[pos1]
else:
	self._data.swap(pos1, pos2)
]:
	i: 68(t)
	o: 373(loop), 613(AL)

nname: 68
n 68(self._edited)[]:
	i: 0(f)
	o: 78(t), 620(f)

nname: 12
n 12(None)[pos = self.selected_pos
self.selected_pos = -1
louie_send(self.list_name, sender=self.menu, action='reset', value=self)
]:
	i: 0(t)
	o: 1106()

nname: 0
n 0(item is None)[]:
	i: 
	o: 12(t), 68(f)

self.nodes: {0: <unpyclib.structure.node instance at 0xb7515c8c>, 620: <unpyclib.structure.node instance at 0xb7525e6c>, 12: <unpyclib.structure.node instance at 0xb75159ac>, 386: <unpyclib.structure.node instance at 0xb75252ec>, 68: <unpyclib.structure.node instance at 0xb751532c>, 78: <unpyclib.structure.node instance at 0xb7525e4c>, 1106: <unpyclib.structure.node instance at 0xb75251cc>, 613: <unpyclib.structure.node instance at 0xb75130ac>, 373: <unpyclib.structure.node instance at 0xb751960c>}
nname: 490
n 490(None)[louie_send(self.list_name, sender=menu, action='reset', value=self)
self.advertise()
]:
	i: 329(), 385(JA), 419(JA), 477(), 480()
	o: 

nname: 480
n 480(None)[self.selected_pos = -1
]:
	i: 378(f)
	o: 490()

nname: 477
n 477(None)[]:
	i: 475(AE)
	o: 490()

nname: 475
n 475(None)[]:
	i: 409(f)
	o: 477(AE)

nname: 419
n 419(None)[#, e
log.error('Unable to reload cache %s[%s]: %s', self._data, selected, e)
self.selected_pos = len(self._data) - 1
]:
	i: 409(t)
	o: 490(JA)

nname: 409
n 409(<dummy_ex3> EXC_MATCH IndexError)[]:
	i: 381(except)
	o: 419(t), 475(f)

nname: 385
n 385(None)[self._data[selected]
self.selected_pos = selected
]:
	i: 381(try)
	o: 490(JA)

nname: 381
n 381(None)[]:
	i: 378(t)
	o: 385(try), 409(except)

nname: 378
n 378(selected >= len(self._data))[]:
	i: 366(), 376()
	o: 381(t), 480(f)

nname: 376
n 376(None)[len(self._data)
]:
	i: 342(f)
	o: 378()

nname: 366
n 366(None)[]:
	i: 342(t)
	o: 378()

nname: 342
n 342(selected >= len(self._data))[]:
	i: 326(f)
	o: 366(t), 376(f)

nname: 329
n 329(None)[self.selected_pos = selected
]:
	i: 326(t)
	o: 490()

nname: 326
n 326(0 <= selected)[]:
	i: 305(), 324()
	o: 329(t), 342(f)

nname: 324
n 324(None)[selected
]:
	i: 291(f)
	o: 326()

nname: 305
n 305(None)[]:
	i: 291(t)
	o: 326()

nname: 291
n 291(0 <= selected)[]:
	i: 271(), 290()
	o: 305(t), 324(f)

nname: 290
n 290(None)[]:
	i: 256(f)
	o: 291()

nname: 271
n 271(None)[selected = items.index(selected)
]:
	i: 256(t)
	o: 291()

nname: 256
n 256(isinstance(selected, Item))[]:
	i: 114(AL), 169(), 189(), 221()
	o: 271(t), 290(f)

nname: 221
n 221(None)[self._data = items
self._data.add_owner(self)
self.cyclic = False
]:
	i: 173(f)
	o: 256()

nname: 189
n 189(None)[self._data = items._data
self._data.add_owner(self)
]:
	i: 173(t)
	o: 256()

nname: 173
n 173(isinstance(items, ItemList))[]:
	i: 0(f)
	o: 189(t), 221(f)

nname: 169
n 169(None)[]:
	i: 117(AF), 165()
	o: 256()

nname: 165
n 165(None)[]:
	i: 124(t), 145()
	o: 169()

nname: 145
n 145(None)[it.display_type = display_prefix + it.type
continue
]:
	i: 124(f)
	o: 165()

nname: 124
n 124(it.display_type)[for it in items:
it.menu = menu
]:
	i: 117(for)
	o: 145(f), 165(t)

nname: 117
n 117(None)[]:
	i: 114(loop)
	o: 124(for), 169(AF)

nname: 114
n 114(None)[]:
	i: 99(), 113()
	o: 117(loop), 256(AL)

nname: 113
n 113(None)[]:
	i: 30(f)
	o: 114()

nname: 99
n 99(None)[display_prefix = display_prefix[6:]
]:
	i: 30(t)
	o: 114()

nname: 30
n 30(display_prefix.startswith('marker'))[self.cyclic = cyclic
self._data = _MList(items)
self._data.add_owner(self)
display_prefix = menu.type + '_'
]:
	i: 0(t)
	o: 99(t), 113(f)

nname: 0
n 0(isinstance(items, (tuple, list)))[menu = self.menu
]:
	i: 
	o: 30(t), 173(f)

nname: 490
n 490(None)[louie_send(self.list_name, sender=menu, action='reset', value=self)
self.advertise()
]:
	i: 329(), 385(JA), 419(JA), 480(), 409(f), 475(AE)
	o: 

nname: 480
n 480(None)[self.selected_pos = -1
]:
	i: 342(f)
	o: 490()

nname: 419
n 419(None)[#, e
log.error('Unable to reload cache %s[%s]: %s', self._data, selected, e)
self.selected_pos = len(self._data) - 1
]:
	i: 409(t)
	o: 490(JA)

nname: 409
n 409(<dummy_ex3> EXC_MATCH IndexError)[]:
	i: 381(except)
	o: 419(t), 490(f)

nname: 385
n 385(None)[self._data[selected]
self.selected_pos = selected
]:
	i: 381(try)
	o: 490(JA)

nname: 381
n 381(None)[]:
	i: 342(t)
	o: 385(try), 409(except)

nname: 342
n 342(selected >= len(self._data))[if selected >= len(self._data):
	pass
else:
	len(self._data)
]:
	i: 326(f)
	o: 381(t), 480(f)

nname: 329
n 329(None)[self.selected_pos = selected
]:
	i: 326(t)
	o: 490()

nname: 326
n 326(0 <= selected)[]:
	i: 256()
	o: 329(t), 342(f)

nname: 256
n 256(None)[if isinstance(selected, Item):
	selected = items.index(selected)
if 0 <= selected:
	pass
else:
	selected
]:
	i: 30(AL), 173(), 117(AF), 124()
	o: 326()

nname: 173
n 173(None)[if isinstance(items, ItemList):
	self._data = items._data
	self._data.add_owner(self)
else:
	self._data = items
	self._data.add_owner(self)
	self.cyclic = False
]:
	i: 0(f)
	o: 256()

nname: 124
n 124(None)[for it in items:
it.menu = menu
if not it.display_type:
	it.display_type = display_prefix + it.type
	continue
]:
	i: 117(for)
	o: 256()

nname: 117
n 117(None)[]:
	i: 30(loop)
	o: 124(for), 256(AF)

nname: 30
n 30(None)[self.cyclic = cyclic
self._data = _MList(items)
self._data.add_owner(self)
display_prefix = menu.type + '_'
if display_prefix.startswith('marker'):
	display_prefix = display_prefix[6:]
]:
	i: 0(t)
	o: 117(loop), 256(AL)

nname: 0
n 0(isinstance(items, (tuple, list)))[menu = self.menu
]:
	i: 
	o: 30(t), 173(f)

nname: 490
n 490(None)[louie_send(self.list_name, sender=menu, action='reset', value=self)
self.advertise()
]:
	i: 329(), 480(), 409(f)
	o: 

nname: 480
n 480(None)[self.selected_pos = -1
]:
	i: 342(f)
	o: 490()

nname: 409
n 409(None)[except IndexError, e:
	log.error('Unable to reload cache %s[%s]: %s', self._data, selected, e)
	self.selected_pos = len(self._data) - 1
]:
	i: 381()
	o: 490(JA)

nname: 381
n 381(None)[try:
	self._data[selected]
	self.selected_pos = selected
]:
	i: 342(t)
	o: 409()

nname: 342
n 342(selected >= len(self._data))[if selected >= len(self._data):
	pass
else:
	len(self._data)
]:
	i: 256(f)
	o: 381(t), 480(f)

nname: 329
n 329(None)[self.selected_pos = selected
]:
	i: 256(t)
	o: 490()

nname: 256
n 256(0 <= selected)[if isinstance(selected, Item):
	selected = items.index(selected)
if 0 <= selected:
	pass
else:
	selected
]:
	i: 30(AL), 173(), 117(AF), 124()
	o: 329(t), 342(f)

nname: 173
n 173(None)[if isinstance(items, ItemList):
	self._data = items._data
	self._data.add_owner(self)
else:
	self._data = items
	self._data.add_owner(self)
	self.cyclic = False
]:
	i: 0(f)
	o: 256()

nname: 124
n 124(None)[for it in items:
it.menu = menu
if not it.display_type:
	it.display_type = display_prefix + it.type
	continue
]:
	i: 117(for)
	o: 256()

nname: 117
n 117(None)[]:
	i: 30(loop)
	o: 124(for), 256(AF)

nname: 30
n 30(None)[self.cyclic = cyclic
self._data = _MList(items)
self._data.add_owner(self)
display_prefix = menu.type + '_'
if display_prefix.startswith('marker'):
	display_prefix = display_prefix[6:]
]:
	i: 0(t)
	o: 117(loop), 256(AL)

nname: 0
n 0(isinstance(items, (tuple, list)))[menu = self.menu
]:
	i: 
	o: 30(t), 173(f)

nname: 490
n 490(None)[louie_send(self.list_name, sender=menu, action='reset', value=self)
self.advertise()
]:
	i: 329(), 480(), 381(f)
	o: 

nname: 480
n 480(None)[self.selected_pos = -1
]:
	i: 342(f)
	o: 490()

nname: 381
n 381(None)[try:
	self._data[selected]
	self.selected_pos = selected
except IndexError, e:
	log.error('Unable to reload cache %s[%s]: %s', self._data, selected, e)
	self.selected_pos = len(self._data) - 1
]:
	i: 342(t)
	o: 490(JA)

nname: 342
n 342(selected >= len(self._data))[if selected >= len(self._data):
	pass
else:
	len(self._data)
]:
	i: 256(f)
	o: 381(t), 480(f)

nname: 329
n 329(None)[self.selected_pos = selected
]:
	i: 256(t)
	o: 490()

nname: 256
n 256(0 <= selected)[if isinstance(selected, Item):
	selected = items.index(selected)
if 0 <= selected:
	pass
else:
	selected
]:
	i: 30(AL), 173(), 117(AF), 124()
	o: 329(t), 342(f)

nname: 173
n 173(None)[if isinstance(items, ItemList):
	self._data = items._data
	self._data.add_owner(self)
else:
	self._data = items
	self._data.add_owner(self)
	self.cyclic = False
]:
	i: 0(f)
	o: 256()

nname: 124
n 124(None)[for it in items:
it.menu = menu
if not it.display_type:
	it.display_type = display_prefix + it.type
	continue
]:
	i: 117(for)
	o: 256()

nname: 117
n 117(None)[]:
	i: 30(loop)
	o: 124(for), 256(AF)

nname: 30
n 30(None)[self.cyclic = cyclic
self._data = _MList(items)
self._data.add_owner(self)
display_prefix = menu.type + '_'
if display_prefix.startswith('marker'):
	display_prefix = display_prefix[6:]
]:
	i: 0(t)
	o: 117(loop), 256(AL)

nname: 0
n 0(isinstance(items, (tuple, list)))[menu = self.menu
]:
	i: 
	o: 30(t), 173(f)

nname: 256
n 256(None)[if isinstance(selected, Item):
	selected = items.index(selected)
if 0 <= selected:
	pass
else:
	selected
if 0 <= selected:
	self.selected_pos = selected
else:
	if selected >= len(self._data):
		pass
	else:
		len(self._data)
	if selected >= len(self._data):
		try:
			self._data[selected]
			self.selected_pos = selected
		except IndexError, e:
			log.error('Unable to reload cache %s[%s]: %s', self._data, selected, e)
			self.selected_pos = len(self._data) - 1
	else:
		self.selected_pos = -1
louie_send(self.list_name, sender=menu, action='reset', value=self)
self.advertise()
]:
	i: 30(AL), 173(), 117(AF), 124()
	o: 

nname: 173
n 173(None)[if isinstance(items, ItemList):
	self._data = items._data
	self._data.add_owner(self)
else:
	self._data = items
	self._data.add_owner(self)
	self.cyclic = False
]:
	i: 0(f)
	o: 256()

nname: 124
n 124(None)[for it in items:
it.menu = menu
if not it.display_type:
	it.display_type = display_prefix + it.type
	continue
]:
	i: 117(for)
	o: 256()

nname: 117
n 117(None)[]:
	i: 30(loop)
	o: 124(for), 256(AF)

nname: 30
n 30(None)[self.cyclic = cyclic
self._data = _MList(items)
self._data.add_owner(self)
display_prefix = menu.type + '_'
if display_prefix.startswith('marker'):
	display_prefix = display_prefix[6:]
]:
	i: 0(t)
	o: 117(loop), 256(AL)

nname: 0
n 0(isinstance(items, (tuple, list)))[menu = self.menu
]:
	i: 
	o: 30(t), 173(f)

self.nodes: {0: <unpyclib.structure.node instance at 0xb75130ac>, 256: <unpyclib.structure.node instance at 0xb750c52c>, 30: <unpyclib.structure.node instance at 0xb750caec>, 173: <unpyclib.structure.node instance at 0xb750c5cc>, 117: <unpyclib.structure.node instance at 0xb7513cac>, 124: <unpyclib.structure.node instance at 0xb750c3cc>}
nname: 200
n 200(None)[raise ValueError('find_next_selectable(%s) on "%s" returned nothing !!' % (wanted, self.list_name))
]:
	i: 117(AL), 199()
	o: 

nname: 199
n 199(None)[]:
	i: 138(AF), 195()
	o: 200()

nname: 195
n 195(None)[_POP_TOP pass
]:
	i: 145&177(f), 187()
	o: 199()

nname: 187
n 187(None)[return idx
continue
]:
	i: 145&177(t)
	o: 195()

nname: 145&177
n 145&177(not hasattr(item, 'sensitive') or item.sensitive)[for idx in idxs_to_scan:
item = self._data[idx]
]:
	i: 138(for)
	o: 187(t), 195(f)

nname: 138
n 138(None)[]:
	i: 117(loop)
	o: 145&177(for), 199(AF)

nname: 117
n 117(None)[self._data[start_idx:start_idx + 10]
]:
	i: 62(), 97()
	o: 138(loop), 200(AL)

nname: 97
n 97(None)[idxs_to_scan = range(start_idx, start_idx + 20)
]:
	i: 44(f)
	o: 117()

nname: 62
n 62(None)[idxs_to_scan = range(start_idx, max(-1, start_idx - 19), -1)
]:
	i: 44(t)
	o: 117()

nname: 44
n 44(self.selected_pos > start_idx)[start_idx = self._data.index(wanted)
]:
	i: 21(), 28()
	o: 62(t), 97(f)

nname: 28
n 28(None)[]:
	i: 0(f)
	o: 44()

nname: 21
n 21(None)[]:
	i: 0(t)
	o: 44()

nname: 0
n 0(isinstance(wanted, int))[start_idx = 0
]:
	i: 
	o: 21(t), 28(f)

nname: 200
n 200(None)[raise ValueError('find_next_selectable(%s) on "%s" returned nothing !!' % (wanted, self.list_name))
]:
	i: 117(AL), 138(AF), 145&177()
	o: 

nname: 145&177
n 145&177(None)[for idx in idxs_to_scan:
item = self._data[idx]
if not hasattr(item, 'sensitive') or item.sensitive:
	return idx
	continue
_POP_TOP pass
]:
	i: 138(for)
	o: 200()

nname: 138
n 138(None)[]:
	i: 117(loop)
	o: 145&177(for), 200(AF)

nname: 117
n 117(None)[self._data[start_idx:start_idx + 10]
]:
	i: 0()
	o: 138(loop), 200(AL)

nname: 0
n 0(None)[start_idx = 0
if isinstance(wanted, int):
	pass
start_idx = self._data.index(wanted)
if self.selected_pos > start_idx:
	idxs_to_scan = range(start_idx, max(-1, start_idx - 19), -1)
else:
	idxs_to_scan = range(start_idx, start_idx + 20)
]:
	i: 
	o: 117()

nname: 200
n 200(None)[raise ValueError('find_next_selectable(%s) on "%s" returned nothing !!' % (wanted, self.list_name))
]:
	i: 138()
	o: 

nname: 138
n 138(None)[for idx in idxs_to_scan:
	item = self._data[idx]
	if not hasattr(item, 'sensitive') or item.sensitive:
		return idx
		continue
	_POP_TOP pass
]:
	i: 0(loop)
	o: 200()

nname: 0
n 0(None)[start_idx = 0
if isinstance(wanted, int):
	pass
start_idx = self._data.index(wanted)
if self.selected_pos > start_idx:
	idxs_to_scan = range(start_idx, max(-1, start_idx - 19), -1)
else:
	idxs_to_scan = range(start_idx, start_idx + 20)
self._data[start_idx:start_idx + 10]
]:
	i: 
	o: 138(loop)

nname: 200
n 200(None)[raise ValueError('find_next_selectable(%s) on "%s" returned nothing !!' % (wanted, self.list_name))
]:
	i: 0()
	o: 

nname: 0
n 0(None)[start_idx = 0
if isinstance(wanted, int):
	pass
start_idx = self._data.index(wanted)
if self.selected_pos > start_idx:
	idxs_to_scan = range(start_idx, max(-1, start_idx - 19), -1)
else:
	idxs_to_scan = range(start_idx, start_idx + 20)
self._data[start_idx:start_idx + 10]
for idx in idxs_to_scan:
	item = self._data[idx]
	if not hasattr(item, 'sensitive') or item.sensitive:
		return idx
		continue
	_POP_TOP pass
]:
	i: 
	o: 200()

nname: 0
n 0(None)[start_idx = 0
if isinstance(wanted, int):
	pass
start_idx = self._data.index(wanted)
if self.selected_pos > start_idx:
	idxs_to_scan = range(start_idx, max(-1, start_idx - 19), -1)
else:
	idxs_to_scan = range(start_idx, start_idx + 20)
self._data[start_idx:start_idx + 10]
for idx in idxs_to_scan:
	item = self._data[idx]
	if not hasattr(item, 'sensitive') or item.sensitive:
		return idx
		continue
	_POP_TOP pass
raise ValueError('find_next_selectable(%s) on "%s" returned nothing !!' % (wanted, self.list_name))
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb757dc2c>}
nname: 6
n 6(None)[__doc__ = '\n    A list of Items (in menu context)\n    '
_edited = False
def __init__(self, menu, _list, list_name, selected_pos=0):
	for it in _list:
		it.menu = menu
	self.list_name = list_name
	self.menu = menu
	self.cyclic = False
	self.set_items(_list)
	self.selected_pos = -1
	if selected_pos >= 0 and selected_pos < len(self._data):
		self.selected_pos = selected_pos
	self._ItemList__sel_observers = set()

def _get_selected(self):
	if 0 <= self.selected_pos:
		pass
	else:
		self.selected_pos
	if 0 <= self.selected_pos:
		pass
	return None

selected = property(_get_selected, (lambda self, it: None))
del _get_selected
def __repr__(self):
	return '<ItemList pointing %s @%d :: %s>' % (self.selected, self.selected_pos, self._data)

def __del__(self):
	try:
		self._data.remove_list(self.list_name)
	except AttributeError:
		pass

def del_sel_observer(self, who):
	self._ItemList__sel_observers.remove(who)

def add_sel_observer(self, who):
	if who not in self._ItemList__sel_observers:
		self._ItemList__sel_observers.add(who)

def __iter__(self):
	return iter(self._data)

def __contains__(self, item):
	return item in self._data

def __len__(self):
	return len(self._data)

def __getitem__(self, idx):
	return self._data[idx]

def __setitem__(self, k, value):
	pass

def __delitem__(self, i):
	if isinstance(self._data, (list, tuple)):
		del self._data[i]
	else:
		self._data._fill_cache()
	if len(self._data):
		if i == self.selected_pos:
			try:
				sel = self._data[self.selected_pos]
			except IndexError:
				self.selected_pos = len(self._data) - 1
		else:
			if i < self.selected_pos:
				self.selected_pos -= 1
		for owner in self._data._owners:
			owner = owner()
			if owner != self:
				if i < owner.selected_pos:
					owner.selected_pos -= 1
				else:
					continue
	else:
		self.selected_pos = -1
	for owner in self._data._owners:
		owner = owner()
		louie_send(owner.list_name, sender=owner.menu, action='remove', value=owner, position=i)

def is_empty(self):
	if isinstance(self._data, list):
		return self._data == []
	else:
		return self._data.empty

def index(self, value):
	return self._data.index(value)

def insert(self, i, item):
	item.menu = self.menu
	if i > 0:
		pass
	index = max(0, len(self._data) + i)
	if index > len(self._data):
		index = len(self._data)
	if index < self.selected_pos:
		self.selected_pos += 1
	self._data.insert(i, item)
	for owner in self._data._owners:
		owner = owner()
		louie_send(owner.list_name, sender=owner.menu, action='add', value=owner, position=index)

def append(self, x):
	x.menu = self.menu
	if not x.display_type:
		x.display_type = self.menu.type + '_' + x.type
	position = len(self._data)
	self._data.append(x)
	for owner in self._data._owners:
		owner = owner()
		louie_send(owner.list_name, sender=owner.menu, action='add', value=owner, position=position)

def extend(self, other_list):
	menu = self.menu
	position = len(self._data)
	self._data.extend(other_list)
	display_prefix = menu.type + '_'
	for i, x in enumerate(other_list):
		x.menu = menu
		if not x.display_type:
			x.display_type = display_prefix + x.type
		for owner in self._data._owners:
			owner = owner()
			louie_send(owner.list_name, sender=owner.menu, action='add', value=owner, position=position + i)

def remove(self, x):
	index = self._data.index(x)
	del self[index]

def pop(self, i=-1):
	if i < 0:
		index = len(self._data) + i
	else:
		index = i
	elt = self._data.pop(i)
	for owner in self._data._owners:
		owner = owner()
		louie_send(owner.list_name, sender=owner.menu, action='remove', value=owner, position=index)
	return elt

def advertise(self):
	if self.selected_pos == 0:
		for owner in self._data._owners:
			owner = owner()
			louie_send('%s_top_limit' % owner.list_name, owner.menu)
		if len(self) == 1:
			for owner in self._data._owners:
				owner = owner()
				louie_send('%s_bottom_limit' % owner.list_name, owner.menu)
	else:
		if self.selected_pos == len(self) - 1:
			for owner in self._data._owners:
				owner = owner()
				louie_send('%s_bottom_limit' % owner.list_name, owner.menu)
			if not len(self):
				for owner in self._data._owners:
					owner = owner()
					louie_send('%s_top_limit' % owner.list_name, owner.menu)
		else:
			for owner in self._data._owners:
				owner = owner()
				louie_send('%s_no_limit' % owner.list_name, owner.menu)

def set_edit(self, val):
	if val != self._edited:
		louie_send(self.list_name, sender=self.menu, action='edit', value=self, edit_mode=val)
		self._edited = val
	else:
		if val == self._edited and val:
			louie_send('edit_list_not_editable', sender=self.menu)

edited = property((lambda self: self._edited), set_edit, doc='Toggle edit mode')
del set_edit
def reset_view(self):
	louie_send(self.list_name, sender=self.menu, action='reset', value=self)

def select(self, item=None, force_pos=False):
	pass

def set_items(self, items, selected=-1, cyclic=False):
	menu = self.menu

def _ItemList__find_next_selectable(self, wanted):
	start_idx = 0
	if isinstance(wanted, int):
		pass
	start_idx = self._data.index(wanted)
	if self.selected_pos > start_idx:
		idxs_to_scan = range(start_idx, max(-1, start_idx - 19), -1)
	else:
		idxs_to_scan = range(start_idx, start_idx + 20)
	self._data[start_idx:start_idx + 10]
	for idx in idxs_to_scan:
		item = self._data[idx]
		if not hasattr(item, 'sensitive') or item.sensitive:
			return idx
			continue
		_POP_TOP pass
	raise ValueError('find_next_selectable(%s) on "%s" returned nothing !!' % (wanted, self.list_name))

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb7584f2c>}
nname: 0
n 0(None)[ItemList.__init__(self, menu, _list, list_name, selected_pos)
self.row_length = row_length
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb757d8cc>}
nname: 110
n 110(None)[return self.select(new_pos, True)
]:
	i: 101(), 109()
	o: 

nname: 109
n 109(None)[]:
	i: 83(f)
	o: 110()

nname: 101
n 101(None)[return False
]:
	i: 83(t)
	o: 110()

nname: 83
n 83(new_pos >= len(self))[]:
	i: 38(), 62()
	o: 101(t), 109(f)

nname: 62
n 62(None)[new_pos = self.selected_pos + value * self.row_length
]:
	i: 32(f)
	o: 83()

nname: 38
n 38(None)[new_pos = value * self.row_length + self.selected_column
]:
	i: 32(t)
	o: 83()

nname: 32
n 32(force_pos)[]:
	i: 15(), 31()
	o: 38(t), 62(f)

nname: 31
n 31(None)[]:
	i: 0(f)
	o: 32()

nname: 15
n 15(None)[raise ValueError('An item needs to be selected before you change the selected row.')
]:
	i: 0(t)
	o: 32()

nname: 0
n 0(self.selected_pos == -1)[]:
	i: 
	o: 15(t), 31(f)

nname: 83
n 83(None)[if new_pos >= len(self):
	return False
return self.select(new_pos, True)
]:
	i: 0()
	o: 

nname: 0
n 0(None)[if self.selected_pos == -1:
	raise ValueError('An item needs to be selected before you change the selected row.')
if force_pos:
	new_pos = value * self.row_length + self.selected_column
else:
	new_pos = self.selected_pos + value * self.row_length
]:
	i: 
	o: 83()

nname: 0
n 0(None)[if self.selected_pos == -1:
	raise ValueError('An item needs to be selected before you change the selected row.')
if force_pos:
	new_pos = value * self.row_length + self.selected_column
else:
	new_pos = self.selected_pos + value * self.row_length
if new_pos >= len(self):
	return False
return self.select(new_pos, True)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb757dd6c>}
nname: 92
n 92(None)[]:
	i: 38(), 78()
	o: 

nname: 78
n 78(None)[return self.select(value)
]:
	i: 32(f)
	o: 92()

nname: 38
n 38(None)[new_pos = self.row_length * self.selected_row + value
return self.select(new_pos, True)
]:
	i: 32(t)
	o: 92()

nname: 32
n 32(force_pos)[]:
	i: 15(), 31()
	o: 38(t), 78(f)

nname: 31
n 31(None)[]:
	i: 0(f)
	o: 32()

nname: 15
n 15(None)[raise ValueError('An item needs to be selected before you change the selected row.')
]:
	i: 0(t)
	o: 32()

nname: 0
n 0(self.selected_pos == -1)[]:
	i: 
	o: 15(t), 31(f)

nname: 92
n 92(None)[]:
	i: 0()
	o: 

nname: 0
n 0(None)[if self.selected_pos == -1:
	raise ValueError('An item needs to be selected before you change the selected row.')
if force_pos:
	new_pos = self.row_length * self.selected_row + value
	return self.select(new_pos, True)
else:
	return self.select(value)
]:
	i: 
	o: 92()

nname: 0
n 0(None)[if self.selected_pos == -1:
	raise ValueError('An item needs to be selected before you change the selected row.')
if force_pos:
	new_pos = self.row_length * self.selected_row + value
	return self.select(new_pos, True)
else:
	return self.select(value)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb757db4c>}
nname: 0
n 0(None)[return '<ItemGrid pointing %s @(row:%i, col:%i) :: %s>' % (self.selected, self.selected_row, self.selected_column, self._data)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb757dfec>}
nname: 6
n 6(None)[__doc__ = 'ItemList subclass with a 2-dimensional twist.\n\n    Used to model containers that will be visualized as a grid,\n    and thus require vertical and horizontal selection mechanisms.\n\n    The underlying structure is the same as that of an\n    ItemList, laid out as follows:\n\n    Horizontal selection\n    <---------->\n\n    [0, 1, 2, 3,  ^\n     4, 5, 6, 7,  | Vertical selection\n     8, 9]        v\n\n    (example for a row_length of 4)\n\n    TODO Identify and manage the possible cyclic behavior more explicitly.\n    TODO Add some sort of wrap-around behavior in select_*.\n    '
def __init__(self, menu, _list, list_name, row_length, selected_pos=0):
	ItemList.__init__(self, menu, _list, list_name, selected_pos)
	self.row_length = row_length

def select_vertical(self, value, force_pos=False):
	if self.selected_pos == -1:
		raise ValueError('An item needs to be selected before you change the selected row.')
	if force_pos:
		new_pos = value * self.row_length + self.selected_column
	else:
		new_pos = self.selected_pos + value * self.row_length
	if new_pos >= len(self):
		return False
	return self.select(new_pos, True)

def select_horizontal(self, value, force_pos=False):
	if self.selected_pos == -1:
		raise ValueError('An item needs to be selected before you change the selected row.')
	if force_pos:
		new_pos = self.row_length * self.selected_row + value
		return self.select(new_pos, True)
	else:
		return self.select(value)

selected_row = property()
selected_column = property()
def __repr__(self):
	return '<ItemGrid pointing %s @(row:%i, col:%i) :: %s>' % (self.selected, self.selected_row, self.selected_column, self._data)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb757bfcc>}
nname: 0
n 0(None)[Item.__init__(self, name, type_)
ItemList.__init__(self, menu, _list, list_name, selected_pos)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb757d96c>}
nname: 0
n 0(None)[return False
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb757d26c>}
nname: 48
n 48(None)[]:
	i: 3(), 33(), 46(AE)
	o: 

nname: 46
n 46(None)[]:
	i: 23(f)
	o: 48(AE)

nname: 33
n 33(None)[#, e
return False
]:
	i: 23(t)
	o: 48()

nname: 23
n 23(<dummy_ex3> EXC_MATCH Exception)[]:
	i: 0(except)
	o: 33(t), 46(f)

nname: 3
n 3(None)[return self.name == other.name
]:
	i: 0(try)
	o: 48()

nname: 0
n 0(None)[]:
	i: 
	o: 3(try), 23(except)

nname: 23
n 23(None)[except Exception, e:
	return False
]:
	i: 0()
	o: 

nname: 0
n 0(None)[try:
	return self.name == other.name
]:
	i: 
	o: 23()

nname: 0
n 0(None)[try:
	return self.name == other.name
except Exception, e:
	return False
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb757de2c>}
nname: 51
n 51(None)[]:
	i: 3(), 36(), 49(AE)
	o: 

nname: 49
n 49(None)[]:
	i: 26(f)
	o: 51(AE)

nname: 36
n 36(None)[#, e
return -1
]:
	i: 26(t)
	o: 51()

nname: 26
n 26(<dummy_ex3> EXC_MATCH Exception)[]:
	i: 0(except)
	o: 36(t), 49(f)

nname: 3
n 3(None)[return cmp(self.name, other.name)
]:
	i: 0(try)
	o: 51()

nname: 0
n 0(None)[]:
	i: 
	o: 3(try), 26(except)

nname: 26
n 26(None)[except Exception, e:
	return -1
]:
	i: 0()
	o: 

nname: 0
n 0(None)[try:
	return cmp(self.name, other.name)
]:
	i: 
	o: 26()

nname: 0
n 0(None)[try:
	return cmp(self.name, other.name)
except Exception, e:
	return -1
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb757df4c>}
nname: 6
n 6(None)[def __init__(self, name, type_='item_list', menu=None, _list=[], list_name='main_list', selected_pos=0):
	Item.__init__(self, name, type_)
	ItemList.__init__(self, menu, _list, list_name, selected_pos)

def is_marked(self):
	return False

def __eq__(self, other):
	try:
		return self.name == other.name
	except Exception, e:
		return False

def __cmp__(self, other):
	try:
		return cmp(self.name, other.name)
	except Exception, e:
		return -1

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb757be6c>}
nname: 0
n 0(None)[raise NotImplementedError('browse() method not implemented on %s' % self.__class__.__name__)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb757d1cc>}
nname: 0
n 0(None)[from pygui.item.mediaitem import MediaItem
return <genexpr>(self.browse())
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb757d2cc>}
nname: 6
n 6(None)[__doc__ = ' Interface for containers '
def browse(self):
	raise NotImplementedError('browse() method not implemented on %s' % self.__class__.__name__)

def _get_playable_iterator(self):
	from pygui.item.mediaitem import MediaItem
	return <genexpr>(self.browse())

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb757bdec>}
nname: 152
n 152(None)[]:
	i: 65(AL), 118(), 122()
	o: 

nname: 122
n 122(None)[self.actions_dict[key]['checked'] = not self.actions_dict[key]['checked']
]:
	i: 0&15(f)
	o: 152()

nname: 118
n 118(None)[]:
	i: 68(AF), 114()
	o: 152()

nname: 114
n 114(None)[]:
	i: 78(f), 93()
	o: 118()

nname: 93
n 93(None)[self.actions_dict[k]['checked'] = False
continue
]:
	i: 78(t)
	o: 114()

nname: 78
n 78(k != key)[for k in self.actions_dict:
]:
	i: 68(for)
	o: 93(t), 114(f)

nname: 68
n 68(None)[]:
	i: 65(loop)
	o: 78(for), 118(AF)

nname: 65
n 65(None)[]:
	i: 43(), 64()
	o: 68(loop), 152(AL)

nname: 64
n 64(None)[]:
	i: 25(t)
	o: 65()

nname: 43
n 43(None)[self.actions_dict[key]['checked'] = True
]:
	i: 25(f)
	o: 65()

nname: 25
n 25(self.actions_dict[key]['checked'])[]:
	i: 0&15(t)
	o: 43(f), 64(t)

nname: 0&15
n 0&15(hasattr(self, 'radio') and self.radio)[]:
	i: 
	o: 25(t), 122(f)

nname: 152
n 152(None)[]:
	i: 25(AL), 122(), 68(AF), 78()
	o: 

nname: 122
n 122(None)[self.actions_dict[key]['checked'] = not self.actions_dict[key]['checked']
]:
	i: 0&15(f)
	o: 152()

nname: 78
n 78(None)[for k in self.actions_dict:
if k != key:
	self.actions_dict[k]['checked'] = False
	continue
]:
	i: 68(for)
	o: 152()

nname: 68
n 68(None)[]:
	i: 25(loop)
	o: 78(for), 152(AF)

nname: 25
n 25(None)[if not self.actions_dict[key]['checked']:
	self.actions_dict[key]['checked'] = True
]:
	i: 0&15(t)
	o: 68(loop), 152(AL)

nname: 0&15
n 0&15(hasattr(self, 'radio') and self.radio)[]:
	i: 
	o: 25(t), 122(f)

self.nodes: {68: <unpyclib.structure.node instance at 0xb757d76c>, 78: <unpyclib.structure.node instance at 0xb757d58c>, '0&15': <unpyclib.structure.node instance at 0xb757decc>, 152: <unpyclib.structure.node instance at 0xb757d48c>, 25: <unpyclib.structure.node instance at 0xb757dd4c>, 122: <unpyclib.structure.node instance at 0xb757d68c>}
nname: 90
n 90(None)[return -1
]:
	i: 85(), 89()
	o: 

nname: 89
n 89(None)[]:
	i: 0&19(f)
	o: 90()

nname: 85
n 85(None)[return 1
]:
	i: 74(), 81()
	o: 90()

nname: 81
n 81(None)[]:
	i: 39(f)
	o: 85()

nname: 74
n 74(None)[]:
	i: 39(t)
	o: 85()

nname: 39
n 39(self.actions_dict[a]['pos'] <= self.actions_dict[b]['pos'])[]:
	i: 0&19(t)
	o: 74(t), 81(f)

nname: 0&19
n 0&19('pos' in self.actions_dict[a] and 'pos' in self.actions_dict[b])[]:
	i: 
	o: 39(t), 89(f)

nname: 90
n 90(None)[return -1
]:
	i: 39(), 0&19(f)
	o: 

nname: 39
n 39(None)[if self.actions_dict[a]['pos'] <= self.actions_dict[b]['pos']:
	pass
return 1
]:
	i: 0&19(t)
	o: 90()

nname: 0&19
n 0&19('pos' in self.actions_dict[a] and 'pos' in self.actions_dict[b])[]:
	i: 
	o: 39(t), 90(f)

nname: 0&19
n 0&19(None)[if 'pos' in self.actions_dict[a] and 'pos' in self.actions_dict[b]:
	if self.actions_dict[a]['pos'] <= self.actions_dict[b]['pos']:
		pass
	return 1
return -1
]:
	i: 
	o: 

self.nodes: {'0&19': <unpyclib.structure.node instance at 0xb757d5cc>}
nname: 0
n 0(None)[def sort_action(a, b):
	if 'pos' in self.actions_dict[a] and 'pos' in self.actions_dict[b]:
		if self.actions_dict[a]['pos'] <= self.actions_dict[b]['pos']:
			pass
		return 1
	return -1

keys = d.keys()
keys.sort(sort_action)
return keys
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb757d3ac>}
nname: 199
n 199(None)[return item_list
]:
	i: 0(AL), 198()
	o: 

nname: 198
n 198(None)[]:
	i: 9(AF), 122()
	o: 199()

nname: 122
n 122(None)[caption = act
item_list.append(ActionItem(caption, type_='action', menu=self.menu, display_type=display_type, action=infos['handler'], args=infos['args'], kwargs=infos['kwargs']))
]:
	i: 107(), 118()
	o: 198()

nname: 118
n 118(None)[]:
	i: 95(f)
	o: 122()

nname: 107
n 107(None)[]:
	i: 95(t)
	o: 122()

nname: 95
n 95('caption' in infos)[]:
	i: 54(), 92()
	o: 107(t), 118(f)

nname: 92
n 92(None)[display_type = 'not_checked'
]:
	i: 81(), 88()
	o: 95()

nname: 88
n 88(None)[]:
	i: 64(f)
	o: 92()

nname: 81
n 81(None)[]:
	i: 64(t)
	o: 92()

nname: 64
n 64(infos['checked'] == None)[]:
	i: 28(f)
	o: 81(t), 88(f)

nname: 54
n 54(None)[display_type = 'checked'
]:
	i: 28(t)
	o: 95()

nname: 28
n 28(infos['checked'])[for act in self._ksort(self.actions_dict):
infos = self.actions_dict[act]
]:
	i: 9(for)
	o: 54(t), 64(f)

nname: 9
n 9(None)[]:
	i: 0(loop)
	o: 28(for), 198(AF)

nname: 0
n 0(None)[item_list = []
]:
	i: 
	o: 9(loop), 199(AL)

nname: 199
n 199(None)[return item_list
]:
	i: 0(AL), 9(AF), 95()
	o: 

nname: 95
n 95(None)[if 'caption' in infos:
	pass
caption = act
item_list.append(ActionItem(caption, type_='action', menu=self.menu, display_type=display_type, action=infos['handler'], args=infos['args'], kwargs=infos['kwargs']))
]:
	i: 54(), 64()
	o: 199()

nname: 64
n 64(None)[if infos['checked'] == None:
	pass
display_type = 'not_checked'
]:
	i: 28(f)
	o: 95()

nname: 54
n 54(None)[display_type = 'checked'
]:
	i: 28(t)
	o: 95()

nname: 28
n 28(infos['checked'])[for act in self._ksort(self.actions_dict):
infos = self.actions_dict[act]
]:
	i: 9(for)
	o: 54(t), 64(f)

nname: 9
n 9(None)[]:
	i: 0(loop)
	o: 28(for), 199(AF)

nname: 0
n 0(None)[item_list = []
]:
	i: 
	o: 9(loop), 199(AL)

nname: 199
n 199(None)[return item_list
]:
	i: 0(AL), 9(AF), 28()
	o: 

nname: 28
n 28(None)[for act in self._ksort(self.actions_dict):
infos = self.actions_dict[act]
if infos['checked']:
	display_type = 'checked'
else:
	if infos['checked'] == None:
		pass
	display_type = 'not_checked'
if 'caption' in infos:
	pass
caption = act
item_list.append(ActionItem(caption, type_='action', menu=self.menu, display_type=display_type, action=infos['handler'], args=infos['args'], kwargs=infos['kwargs']))
]:
	i: 9(for)
	o: 199()

nname: 9
n 9(None)[]:
	i: 0(loop)
	o: 28(for), 199(AF)

nname: 0
n 0(None)[item_list = []
]:
	i: 
	o: 9(loop), 199(AL)

nname: 28
n 28(None)[for act in self._ksort(self.actions_dict):
	infos = self.actions_dict[act]
	if infos['checked']:
		display_type = 'checked'
	else:
		if infos['checked'] == None:
			pass
		display_type = 'not_checked'
	if 'caption' in infos:
		pass
	caption = act
	item_list.append(ActionItem(caption, type_='action', menu=self.menu, display_type=display_type, action=infos['handler'], args=infos['args'], kwargs=infos['kwargs']))
return item_list
]:
	i: 0(for)
	o: 

nname: 0
n 0(None)[item_list = []
]:
	i: 
	o: 28(for)

nname: 0
n 0(None)[item_list = []
for act in self._ksort(self.actions_dict):
	infos = self.actions_dict[act]
	if infos['checked']:
		display_type = 'checked'
	else:
		if infos['checked'] == None:
			pass
		display_type = 'not_checked'
	if 'caption' in infos:
		pass
	caption = act
	item_list.append(ActionItem(caption, type_='action', menu=self.menu, display_type=display_type, action=infos['handler'], args=infos['args'], kwargs=infos['kwargs']))
return item_list
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb757da0c>}
nname: 6
n 6(None)[__doc__ = "\n    Base class to handle multi choices options (aka checkbox).\n    Your class must have a self.actions_dict describing the available actions.\n    Your class can have a self.radio boolean attribute to allow only one\n        checkbox to be checked.\n    Example self.actions_dict()\n    self.actions_dict = {\n            'opt1':{'handler':self.check_opt, 'caption': _('Opt1'), 'checked': True, 'args':('opt1'), 'kwargs':{}, 'pos': 1},\n            'opt2':{'handler':self.check_opt, 'caption': _('Opt2'), 'checked': False, 'args':('opt2'), 'kwargs':{}, 'pos': 2}\n        }\n    A list of ActionItem will be built on .browse()\n    "
def _update_checked(self, key):
	pass

def _ksort(self, d):
	def sort_action(a, b):
		if 'pos' in self.actions_dict[a] and 'pos' in self.actions_dict[b]:
			if self.actions_dict[a]['pos'] <= self.actions_dict[b]['pos']:
				pass
			return 1
		return -1

	keys = d.keys()
	keys.sort(sort_action)
	return keys

def browse(self):
	item_list = []
	for act in self._ksort(self.actions_dict):
		infos = self.actions_dict[act]
		if infos['checked']:
			display_type = 'checked'
		else:
			if infos['checked'] == None:
				pass
			display_type = 'not_checked'
		if 'caption' in infos:
			pass
		caption = act
		item_list.append(ActionItem(caption, type_='action', menu=self.menu, display_type=display_type, action=infos['handler'], args=infos['args'], kwargs=infos['kwargs']))
	return item_list

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb757bdac>}
nname: 0
n 0(None)[from __future__ import absolute_import
__all__ = ['ItemList', 'ItemListItem', 'GenericContainer']
from .core import ActionItem, Item
from peewee.messages import send as louie_send
from peewee.debug import GET_LOGGER
from weakref import ref
log = GET_LOGGER(__name__)
class _MList(list):
	__slots__ = ['_owners']
	def __init__(self, *args):
		list.__init__(self, *args)
		self._owners = []

	def append(self, it):
		ow = self._owners

	def insert(self, pos, it):
		ow = self._owners

	def remove_list(self, list_name):
		for item in self:
			try:
				item.list_owned.remove(list_name)
				continue
			except ValueError:
				continue

	def _owner_removed(self, who):
		self._owners.remove(who)

	def add_owner(self, who):
		self._owners.append(ref(who, self._owner_removed))
		for item in self:
			item.list_owned.append(who.list_name)



class ItemList(object):
	__doc__ = '\n    A list of Items (in menu context)\n    '
	_edited = False
	def __init__(self, menu, _list, list_name, selected_pos=0):
		for it in _list:
			it.menu = menu
		self.list_name = list_name
		self.menu = menu
		self.cyclic = False
		self.set_items(_list)
		self.selected_pos = -1
		if selected_pos >= 0 and selected_pos < len(self._data):
			self.selected_pos = selected_pos
		self._ItemList__sel_observers = set()

	def _get_selected(self):
		if 0 <= self.selected_pos:
			pass
		else:
			self.selected_pos
		if 0 <= self.selected_pos:
			pass
		return None

	selected = property(_get_selected, (lambda self, it: None))
	del _get_selected
	def __repr__(self):
		return '<ItemList pointing %s @%d :: %s>' % (self.selected, self.selected_pos, self._data)

	def __del__(self):
		try:
			self._data.remove_list(self.list_name)
		except AttributeError:
			pass

	def del_sel_observer(self, who):
		self._ItemList__sel_observers.remove(who)

	def add_sel_observer(self, who):
		if who not in self._ItemList__sel_observers:
			self._ItemList__sel_observers.add(who)

	def __iter__(self):
		return iter(self._data)

	def __contains__(self, item):
		return item in self._data

	def __len__(self):
		return len(self._data)

	def __getitem__(self, idx):
		return self._data[idx]

	def __setitem__(self, k, value):
		pass

	def __delitem__(self, i):
		if isinstance(self._data, (list, tuple)):
			del self._data[i]
		else:
			self._data._fill_cache()
		if len(self._data):
			if i == self.selected_pos:
				try:
					sel = self._data[self.selected_pos]
				except IndexError:
					self.selected_pos = len(self._data) - 1
			else:
				if i < self.selected_pos:
					self.selected_pos -= 1
			for owner in self._data._owners:
				owner = owner()
				if owner != self:
					if i < owner.selected_pos:
						owner.selected_pos -= 1
					else:
						continue
		else:
			self.selected_pos = -1
		for owner in self._data._owners:
			owner = owner()
			louie_send(owner.list_name, sender=owner.menu, action='remove', value=owner, position=i)

	def is_empty(self):
		if isinstance(self._data, list):
			return self._data == []
		else:
			return self._data.empty

	def index(self, value):
		return self._data.index(value)

	def insert(self, i, item):
		item.menu = self.menu
		if i > 0:
			pass
		index = max(0, len(self._data) + i)
		if index > len(self._data):
			index = len(self._data)
		if index < self.selected_pos:
			self.selected_pos += 1
		self._data.insert(i, item)
		for owner in self._data._owners:
			owner = owner()
			louie_send(owner.list_name, sender=owner.menu, action='add', value=owner, position=index)

	def append(self, x):
		x.menu = self.menu
		if not x.display_type:
			x.display_type = self.menu.type + '_' + x.type
		position = len(self._data)
		self._data.append(x)
		for owner in self._data._owners:
			owner = owner()
			louie_send(owner.list_name, sender=owner.menu, action='add', value=owner, position=position)

	def extend(self, other_list):
		menu = self.menu
		position = len(self._data)
		self._data.extend(other_list)
		display_prefix = menu.type + '_'
		for i, x in enumerate(other_list):
			x.menu = menu
			if not x.display_type:
				x.display_type = display_prefix + x.type
			for owner in self._data._owners:
				owner = owner()
				louie_send(owner.list_name, sender=owner.menu, action='add', value=owner, position=position + i)

	def remove(self, x):
		index = self._data.index(x)
		del self[index]

	def pop(self, i=-1):
		if i < 0:
			index = len(self._data) + i
		else:
			index = i
		elt = self._data.pop(i)
		for owner in self._data._owners:
			owner = owner()
			louie_send(owner.list_name, sender=owner.menu, action='remove', value=owner, position=index)
		return elt

	def advertise(self):
		if self.selected_pos == 0:
			for owner in self._data._owners:
				owner = owner()
				louie_send('%s_top_limit' % owner.list_name, owner.menu)
			if len(self) == 1:
				for owner in self._data._owners:
					owner = owner()
					louie_send('%s_bottom_limit' % owner.list_name, owner.menu)
		else:
			if self.selected_pos == len(self) - 1:
				for owner in self._data._owners:
					owner = owner()
					louie_send('%s_bottom_limit' % owner.list_name, owner.menu)
				if not len(self):
					for owner in self._data._owners:
						owner = owner()
						louie_send('%s_top_limit' % owner.list_name, owner.menu)
			else:
				for owner in self._data._owners:
					owner = owner()
					louie_send('%s_no_limit' % owner.list_name, owner.menu)

	def set_edit(self, val):
		if val != self._edited:
			louie_send(self.list_name, sender=self.menu, action='edit', value=self, edit_mode=val)
			self._edited = val
		else:
			if val == self._edited and val:
				louie_send('edit_list_not_editable', sender=self.menu)

	edited = property((lambda self: self._edited), set_edit, doc='Toggle edit mode')
	del set_edit
	def reset_view(self):
		louie_send(self.list_name, sender=self.menu, action='reset', value=self)

	def select(self, item=None, force_pos=False):
		pass

	def set_items(self, items, selected=-1, cyclic=False):
		menu = self.menu

	def _ItemList__find_next_selectable(self, wanted):
		start_idx = 0
		if isinstance(wanted, int):
			pass
		start_idx = self._data.index(wanted)
		if self.selected_pos > start_idx:
			idxs_to_scan = range(start_idx, max(-1, start_idx - 19), -1)
		else:
			idxs_to_scan = range(start_idx, start_idx + 20)
		self._data[start_idx:start_idx + 10]
		for idx in idxs_to_scan:
			item = self._data[idx]
			if not hasattr(item, 'sensitive') or item.sensitive:
				return idx
				continue
			_POP_TOP pass
		raise ValueError('find_next_selectable(%s) on "%s" returned nothing !!' % (wanted, self.list_name))



class ItemGrid(ItemList):
	__doc__ = 'ItemList subclass with a 2-dimensional twist.\n\n    Used to model containers that will be visualized as a grid,\n    and thus require vertical and horizontal selection mechanisms.\n\n    The underlying structure is the same as that of an\n    ItemList, laid out as follows:\n\n    Horizontal selection\n    <---------->\n\n    [0, 1, 2, 3,  ^\n     4, 5, 6, 7,  | Vertical selection\n     8, 9]        v\n\n    (example for a row_length of 4)\n\n    TODO Identify and manage the possible cyclic behavior more explicitly.\n    TODO Add some sort of wrap-around behavior in select_*.\n    '
	def __init__(self, menu, _list, list_name, row_length, selected_pos=0):
		ItemList.__init__(self, menu, _list, list_name, selected_pos)
		self.row_length = row_length

	def select_vertical(self, value, force_pos=False):
		if self.selected_pos == -1:
			raise ValueError('An item needs to be selected before you change the selected row.')
		if force_pos:
			new_pos = value * self.row_length + self.selected_column
		else:
			new_pos = self.selected_pos + value * self.row_length
		if new_pos >= len(self):
			return False
		return self.select(new_pos, True)

	def select_horizontal(self, value, force_pos=False):
		if self.selected_pos == -1:
			raise ValueError('An item needs to be selected before you change the selected row.')
		if force_pos:
			new_pos = self.row_length * self.selected_row + value
			return self.select(new_pos, True)
		else:
			return self.select(value)

	selected_row = property()
	selected_column = property()
	def __repr__(self):
		return '<ItemGrid pointing %s @(row:%i, col:%i) :: %s>' % (self.selected, self.selected_row, self.selected_column, self._data)



class ItemListItem(ItemList, Item):
	def __init__(self, name, type_='item_list', menu=None, _list=[], list_name='main_list', selected_pos=0):
		Item.__init__(self, name, type_)
		ItemList.__init__(self, menu, _list, list_name, selected_pos)

	def is_marked(self):
		return False

	def __eq__(self, other):
		try:
			return self.name == other.name
		except Exception, e:
			return False

	def __cmp__(self, other):
		try:
			return cmp(self.name, other.name)
		except Exception, e:
			return -1



class GenericContainer(Item):
	__doc__ = ' Interface for containers '
	def browse(self):
		raise NotImplementedError('browse() method not implemented on %s' % self.__class__.__name__)

	def _get_playable_iterator(self):
		from pygui.item.mediaitem import MediaItem
		return <genexpr>(self.browse())



class ActionContainer(GenericContainer):
	__doc__ = "\n    Base class to handle multi choices options (aka checkbox).\n    Your class must have a self.actions_dict describing the available actions.\n    Your class can have a self.radio boolean attribute to allow only one\n        checkbox to be checked.\n    Example self.actions_dict()\n    self.actions_dict = {\n            'opt1':{'handler':self.check_opt, 'caption': _('Opt1'), 'checked': True, 'args':('opt1'), 'kwargs':{}, 'pos': 1},\n            'opt2':{'handler':self.check_opt, 'caption': _('Opt2'), 'checked': False, 'args':('opt2'), 'kwargs':{}, 'pos': 2}\n        }\n    A list of ActionItem will be built on .browse()\n    "
	def _update_checked(self, key):
		pass

	def _ksort(self, d):
		def sort_action(a, b):
			if 'pos' in self.actions_dict[a] and 'pos' in self.actions_dict[b]:
				if self.actions_dict[a]['pos'] <= self.actions_dict[b]['pos']:
					pass
				return 1
			return -1

		keys = d.keys()
		keys.sort(sort_action)
		return keys

	def browse(self):
		item_list = []
		for act in self._ksort(self.actions_dict):
			infos = self.actions_dict[act]
			if infos['checked']:
				display_type = 'checked'
			else:
				if infos['checked'] == None:
					pass
				display_type = 'not_checked'
			if 'caption' in infos:
				pass
			caption = act
			item_list.append(ActionItem(caption, type_='action', menu=self.menu, display_type=display_type, action=infos['handler'], args=infos['args'], kwargs=infos['kwargs']))
		return item_list



]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb756fd0c>}
from __future__ import absolute_import
__all__ = ['ItemList', 'ItemListItem', 'GenericContainer']
from .core import ActionItem, Item
from peewee.messages import send as louie_send
from peewee.debug import GET_LOGGER
from weakref import ref
log = GET_LOGGER(__name__)
class _MList(list):
	__slots__ = ['_owners']
	def __init__(self, *args):
		list.__init__(self, *args)
		self._owners = []

	def append(self, it):
		ow = self._owners

	def insert(self, pos, it):
		ow = self._owners

	def remove_list(self, list_name):
		for item in self:
			try:
				item.list_owned.remove(list_name)
				continue
			except ValueError:
				continue

	def _owner_removed(self, who):
		self._owners.remove(who)

	def add_owner(self, who):
		self._owners.append(ref(who, self._owner_removed))
		for item in self:
			item.list_owned.append(who.list_name)



class ItemList(object):
	__doc__ = '\n    A list of Items (in menu context)\n    '
	_edited = False
	def __init__(self, menu, _list, list_name, selected_pos=0):
		for it in _list:
			it.menu = menu
		self.list_name = list_name
		self.menu = menu
		self.cyclic = False
		self.set_items(_list)
		self.selected_pos = -1
		if selected_pos >= 0 and selected_pos < len(self._data):
			self.selected_pos = selected_pos
		self._ItemList__sel_observers = set()

	def _get_selected(self):
		if 0 <= self.selected_pos:
			pass
		else:
			self.selected_pos
		if 0 <= self.selected_pos:
			pass
		return None

	selected = property(_get_selected, (lambda self, it: None))
	del _get_selected
	def __repr__(self):
		return '<ItemList pointing %s @%d :: %s>' % (self.selected, self.selected_pos, self._data)

	def __del__(self):
		try:
			self._data.remove_list(self.list_name)
		except AttributeError:
			pass

	def del_sel_observer(self, who):
		self._ItemList__sel_observers.remove(who)

	def add_sel_observer(self, who):
		if who not in self._ItemList__sel_observers:
			self._ItemList__sel_observers.add(who)

	def __iter__(self):
		return iter(self._data)

	def __contains__(self, item):
		return item in self._data

	def __len__(self):
		return len(self._data)

	def __getitem__(self, idx):
		return self._data[idx]

	def __setitem__(self, k, value):
		pass

	def __delitem__(self, i):
		if isinstance(self._data, (list, tuple)):
			del self._data[i]
		else:
			self._data._fill_cache()
		if len(self._data):
			if i == self.selected_pos:
				try:
					sel = self._data[self.selected_pos]
				except IndexError:
					self.selected_pos = len(self._data) - 1
			else:
				if i < self.selected_pos:
					self.selected_pos -= 1
			for owner in self._data._owners:
				owner = owner()
				if owner != self:
					if i < owner.selected_pos:
						owner.selected_pos -= 1
					else:
						continue
		else:
			self.selected_pos = -1
		for owner in self._data._owners:
			owner = owner()
			louie_send(owner.list_name, sender=owner.menu, action='remove', value=owner, position=i)

	def is_empty(self):
		if isinstance(self._data, list):
			return self._data == []
		else:
			return self._data.empty

	def index(self, value):
		return self._data.index(value)

	def insert(self, i, item):
		item.menu = self.menu
		if i > 0:
			pass
		index = max(0, len(self._data) + i)
		if index > len(self._data):
			index = len(self._data)
		if index < self.selected_pos:
			self.selected_pos += 1
		self._data.insert(i, item)
		for owner in self._data._owners:
			owner = owner()
			louie_send(owner.list_name, sender=owner.menu, action='add', value=owner, position=index)

	def append(self, x):
		x.menu = self.menu
		if not x.display_type:
			x.display_type = self.menu.type + '_' + x.type
		position = len(self._data)
		self._data.append(x)
		for owner in self._data._owners:
			owner = owner()
			louie_send(owner.list_name, sender=owner.menu, action='add', value=owner, position=position)

	def extend(self, other_list):
		menu = self.menu
		position = len(self._data)
		self._data.extend(other_list)
		display_prefix = menu.type + '_'
		for i, x in enumerate(other_list):
			x.menu = menu
			if not x.display_type:
				x.display_type = display_prefix + x.type
			for owner in self._data._owners:
				owner = owner()
				louie_send(owner.list_name, sender=owner.menu, action='add', value=owner, position=position + i)

	def remove(self, x):
		index = self._data.index(x)
		del self[index]

	def pop(self, i=-1):
		if i < 0:
			index = len(self._data) + i
		else:
			index = i
		elt = self._data.pop(i)
		for owner in self._data._owners:
			owner = owner()
			louie_send(owner.list_name, sender=owner.menu, action='remove', value=owner, position=index)
		return elt

	def advertise(self):
		if self.selected_pos == 0:
			for owner in self._data._owners:
				owner = owner()
				louie_send('%s_top_limit' % owner.list_name, owner.menu)
			if len(self) == 1:
				for owner in self._data._owners:
					owner = owner()
					louie_send('%s_bottom_limit' % owner.list_name, owner.menu)
		else:
			if self.selected_pos == len(self) - 1:
				for owner in self._data._owners:
					owner = owner()
					louie_send('%s_bottom_limit' % owner.list_name, owner.menu)
				if not len(self):
					for owner in self._data._owners:
						owner = owner()
						louie_send('%s_top_limit' % owner.list_name, owner.menu)
			else:
				for owner in self._data._owners:
					owner = owner()
					louie_send('%s_no_limit' % owner.list_name, owner.menu)

	def set_edit(self, val):
		if val != self._edited:
			louie_send(self.list_name, sender=self.menu, action='edit', value=self, edit_mode=val)
			self._edited = val
		else:
			if val == self._edited and val:
				louie_send('edit_list_not_editable', sender=self.menu)

	edited = property((lambda self: self._edited), set_edit, doc='Toggle edit mode')
	del set_edit
	def reset_view(self):
		louie_send(self.list_name, sender=self.menu, action='reset', value=self)

	def select(self, item=None, force_pos=False):
		pass

	def set_items(self, items, selected=-1, cyclic=False):
		menu = self.menu

	def _ItemList__find_next_selectable(self, wanted):
		start_idx = 0
		if isinstance(wanted, int):
			pass
		start_idx = self._data.index(wanted)
		if self.selected_pos > start_idx:
			idxs_to_scan = range(start_idx, max(-1, start_idx - 19), -1)
		else:
			idxs_to_scan = range(start_idx, start_idx + 20)
		self._data[start_idx:start_idx + 10]
		for idx in idxs_to_scan:
			item = self._data[idx]
			if not hasattr(item, 'sensitive') or item.sensitive:
				return idx
				continue
			_POP_TOP pass
		raise ValueError('find_next_selectable(%s) on "%s" returned nothing !!' % (wanted, self.list_name))



class ItemGrid(ItemList):
	__doc__ = 'ItemList subclass with a 2-dimensional twist.\n\n    Used to model containers that will be visualized as a grid,\n    and thus require vertical and horizontal selection mechanisms.\n\n    The underlying structure is the same as that of an\n    ItemList, laid out as follows:\n\n    Horizontal selection\n    <---------->\n\n    [0, 1, 2, 3,  ^\n     4, 5, 6, 7,  | Vertical selection\n     8, 9]        v\n\n    (example for a row_length of 4)\n\n    TODO Identify and manage the possible cyclic behavior more explicitly.\n    TODO Add some sort of wrap-around behavior in select_*.\n    '
	def __init__(self, menu, _list, list_name, row_length, selected_pos=0):
		ItemList.__init__(self, menu, _list, list_name, selected_pos)
		self.row_length = row_length

	def select_vertical(self, value, force_pos=False):
		if self.selected_pos == -1:
			raise ValueError('An item needs to be selected before you change the selected row.')
		if force_pos:
			new_pos = value * self.row_length + self.selected_column
		else:
			new_pos = self.selected_pos + value * self.row_length
		if new_pos >= len(self):
			return False
		return self.select(new_pos, True)

	def select_horizontal(self, value, force_pos=False):
		if self.selected_pos == -1:
			raise ValueError('An item needs to be selected before you change the selected row.')
		if force_pos:
			new_pos = self.row_length * self.selected_row + value
			return self.select(new_pos, True)
		else:
			return self.select(value)

	selected_row = property()
	selected_column = property()
	def __repr__(self):
		return '<ItemGrid pointing %s @(row:%i, col:%i) :: %s>' % (self.selected, self.selected_row, self.selected_column, self._data)



class ItemListItem(ItemList, Item):
	def __init__(self, name, type_='item_list', menu=None, _list=[], list_name='main_list', selected_pos=0):
		Item.__init__(self, name, type_)
		ItemList.__init__(self, menu, _list, list_name, selected_pos)

	def is_marked(self):
		return False

	def __eq__(self, other):
		try:
			return self.name == other.name
		except Exception, e:
			return False

	def __cmp__(self, other):
		try:
			return cmp(self.name, other.name)
		except Exception, e:
			return -1



class GenericContainer(Item):
	__doc__ = ' Interface for containers '
	def browse(self):
		raise NotImplementedError('browse() method not implemented on %s' % self.__class__.__name__)

	def _get_playable_iterator(self):
		from pygui.item.mediaitem import MediaItem
		return <genexpr>(self.browse())



class ActionContainer(GenericContainer):
	__doc__ = "\n    Base class to handle multi choices options (aka checkbox).\n    Your class must have a self.actions_dict describing the available actions.\n    Your class can have a self.radio boolean attribute to allow only one\n        checkbox to be checked.\n    Example self.actions_dict()\n    self.actions_dict = {\n            'opt1':{'handler':self.check_opt, 'caption': _('Opt1'), 'checked': True, 'args':('opt1'), 'kwargs':{}, 'pos': 1},\n            'opt2':{'handler':self.check_opt, 'caption': _('Opt2'), 'checked': False, 'args':('opt2'), 'kwargs':{}, 'pos': 2}\n        }\n    A list of ActionItem will be built on .browse()\n    "
	def _update_checked(self, key):
		pass

	def _ksort(self, d):
		def sort_action(a, b):
			if 'pos' in self.actions_dict[a] and 'pos' in self.actions_dict[b]:
				if self.actions_dict[a]['pos'] <= self.actions_dict[b]['pos']:
					pass
				return 1
			return -1

		keys = d.keys()
		keys.sort(sort_action)
		return keys

	def browse(self):
		item_list = []
		for act in self._ksort(self.actions_dict):
			infos = self.actions_dict[act]
			if infos['checked']:
				display_type = 'checked'
			else:
				if infos['checked'] == None:
					pass
				display_type = 'not_checked'
			if 'caption' in infos:
				pass
			caption = act
			item_list.append(ActionItem(caption, type_='action', menu=self.menu, display_type=display_type, action=infos['handler'], args=infos['args'], kwargs=infos['kwargs']))
		return item_list



