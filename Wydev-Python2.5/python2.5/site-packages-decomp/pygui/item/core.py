# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 0
n 0(None)[self._name = name
self.type = type_
self.menu = menu
self.display_type = display_type
self.parent = parent
self.list_owned = []
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb774bf8c>}
nname: 0
n 0(None)[self._name = name
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb774bd4c>}
nname: 0
n 0(None)[return self._name
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb774bcac>}
nname: 0
n 0(None)[return self._name
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb774bd8c>}
nname: 0
n 0(None)[log.info('This is not an executable item (%s).' % self.__class__.__name__)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb774bcec>}
nname: 0
n 0(None)[return '<%s::%s(%s)>' % (self.__class__.__name__, self.type, repr(self.name))
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb774bf0c>}
nname: 0
n 0(None)[return hash(self.name)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb774bdac>}
nname: 36
n 36(None)[return False
]:
	i: 15(), 35()
	o: 

nname: 35
n 35(None)[]:
	i: 0(f)
	o: 36()

nname: 15
n 15(None)[return self.name == other.name
]:
	i: 0(t)
	o: 36()

nname: 0
n 0(isinstance(other, Item))[]:
	i: 
	o: 15(t), 35(f)

nname: 0
n 0(None)[if isinstance(other, Item):
	return self.name == other.name
return False
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb774bcac>}
nname: 64
n 64(None)[]:
	i: 15(), 38()
	o: 

nname: 38
n 38(None)[return cmp(type(self), type(other))
]:
	i: 0(f)
	o: 64()

nname: 15
n 15(None)[return cmp(self.name, other.name)
]:
	i: 0(t)
	o: 64()

nname: 0
n 0(isinstance(other, Item))[]:
	i: 
	o: 15(t), 38(f)

nname: 0
n 0(None)[if isinstance(other, Item):
	return cmp(self.name, other.name)
else:
	return cmp(type(self), type(other))
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb775240c>}
nname: 0
n 0(None)[log.debug('This item has no marking support.')
return False
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb774bcac>}
nname: 22
n 22(None)[return self.menu.universe
]:
	i: 0(t), 12()
	o: 

nname: 12
n 12(None)[]:
	i: 0(f)
	o: 22()

nname: 0
n 0(self.menu.universe)[]:
	i: 
	o: 12(f), 22(t)

nname: 0
n 0(None)[if not self.menu.universe:
	pass
return self.menu.universe
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb774bdcc>}
nname: 22
n 22(None)[return self.menu.universe
]:
	i: 0(t), 12()
	o: 

nname: 12
n 12(None)[]:
	i: 0(f)
	o: 22()

nname: 0
n 0(self.menu.universe)[]:
	i: 
	o: 12(f), 22(t)

nname: 0
n 0(None)[if not self.menu.universe:
	pass
return self.menu.universe
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb774bc6c>}
nname: 0
n 0(None)[from pygui.shared import pygui_globs
pygui_globs['menustack'].back_to_menu(self.menu)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb774becc>}
nname: 72
n 72(None)[]:
	i: 15(AL), 67(), 71()
	o: 

nname: 71
n 71(None)[]:
	i: 0(f)
	o: 72()

nname: 67
n 67(None)[]:
	i: 19(AF), 29()
	o: 72()

nname: 29
n 29(None)[for name in self.list_owned:
louie_send(name, sender=menu, action='reset', value=menu[name])
]:
	i: 19(for)
	o: 67()

nname: 19
n 19(None)[]:
	i: 15(loop)
	o: 29(for), 67(AF)

nname: 15
n 15(None)[]:
	i: 0(t)
	o: 19(loop), 72(AL)

nname: 0
n 0(menu)[menu = self.menu
]:
	i: 
	o: 15(t), 71(f)

nname: 72
n 72(None)[]:
	i: 29(), 0(f)
	o: 

nname: 29
n 29(None)[for name in self.list_owned:
	louie_send(name, sender=menu, action='reset', value=menu[name])
]:
	i: 15(for)
	o: 72()

nname: 15
n 15(None)[]:
	i: 0(t)
	o: 29(for)

nname: 0
n 0(menu)[menu = self.menu
]:
	i: 
	o: 15(t), 72(f)

nname: 72
n 72(None)[]:
	i: 15(), 0(f)
	o: 

nname: 15
n 15(None)[for name in self.list_owned:
	louie_send(name, sender=menu, action='reset', value=menu[name])
]:
	i: 0(t)
	o: 72()

nname: 0
n 0(menu)[menu = self.menu
]:
	i: 
	o: 15(t), 72(f)

nname: 0
n 0(None)[menu = self.menu
if menu:
	for name in self.list_owned:
		louie_send(name, sender=menu, action='reset', value=menu[name])
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb775270c>}
nname: 6
n 6(None)[__doc__ = '\n    Base class for all Items\n    '
locked = False
hidden = False
def __init__(self, name, type_, menu=None, display_type=None, parent=None):
	self._name = name
	self.type = type_
	self.menu = menu
	self.display_type = display_type
	self.parent = parent
	self.list_owned = []

def _set_name(self, name):
	self._name = name

name = property((lambda self: self._name), _set_name)
del _set_name
def execute(self):
	log.info('This is not an executable item (%s).' % self.__class__.__name__)

def __repr__(self):
	return '<%s::%s(%s)>' % (self.__class__.__name__, self.type, repr(self.name))

def __hash__(self):
	return hash(self.name)

def __eq__(self, other):
	if isinstance(other, Item):
		return self.name == other.name
	return False

def __cmp__(self, other):
	if isinstance(other, Item):
		return cmp(self.name, other.name)
	else:
		return cmp(type(self), type(other))

sensitive = True
def is_marked(self):
	log.debug('This item has no marking support.')
	return False

universe = property((lambda self: self.menu.universe:
	pass
return self.menu.universe))
def show_menu(self):
	from pygui.shared import pygui_globs
	pygui_globs['menustack'].back_to_menu(self.menu)

def reset_view(self):
	menu = self.menu
	if menu:
		for name in self.list_owned:
			louie_send(name, sender=menu, action='reset', value=menu[name])

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb774b66c>}
nname: 72
n 72(None)[self.kwargs = kwargs
]:
	i: 53(t), 65()
	o: 

nname: 65
n 65(None)[]:
	i: 53(f)
	o: 72()

nname: 53
n 53(kwargs)[self.args = args
]:
	i: 0(t), 46()
	o: 65(f), 72(t)

nname: 46
n 46(None)[]:
	i: 0(f)
	o: 53()

nname: 0
n 0(args)[Item.__init__(self, name, type_, menu=menu, display_type=display_type)
self.action = action
]:
	i: 
	o: 46(f), 53(t)

nname: 72
n 72(None)[self.kwargs = kwargs
]:
	i: 0(t)
	o: 

nname: 0
n 0(None)[Item.__init__(self, name, type_, menu=menu, display_type=display_type)
self.action = action
if not args:
	pass
self.args = args
if not kwargs:
	pass
]:
	i: 
	o: 72()

nname: 0
n 0(None)[Item.__init__(self, name, type_, menu=menu, display_type=display_type)
self.action = action
if not args:
	pass
self.args = args
if not kwargs:
	pass
self.kwargs = kwargs
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb774ba4c>}
nname: 97
n 97(None)[return None
]:
	i: 40(), 76(), 95(AE)
	o: 

nname: 95
n 95(None)[]:
	i: 66(f)
	o: 97(AE)

nname: 76
n 76(None)[#, e
PRINT_EXCEPTION(e)
]:
	i: 66(t)
	o: 97()

nname: 66
n 66(<dummy_ex3> EXC_MATCH Exception)[]:
	i: 37(except)
	o: 76(t), 95(f)

nname: 40
n 40(None)[self.action(*self.args, **self.kwargs)
]:
	i: 37(try)
	o: 97()

nname: 37
n 37(None)[]:
	i: 15(), 36()
	o: 40(try), 66(except)

nname: 36
n 36(None)[]:
	i: 0(f)
	o: 37()

nname: 15
n 15(None)[log.info('nothing to do for this item')
return None
]:
	i: 0(t)
	o: 37()

nname: 0
n 0(self.action is None)[]:
	i: 
	o: 15(t), 36(f)

nname: 97
n 97(None)[return None
]:
	i: 40()
	o: 

nname: 40
n 40(None)[try:
	self.action(*self.args, **self.kwargs)
except Exception, e:
	PRINT_EXCEPTION(e)
]:
	i: 0(try)
	o: 97()

nname: 0
n 0(None)[if self.action is None:
	log.info('nothing to do for this item')
	return None
]:
	i: 
	o: 40(try)

nname: 97
n 97(None)[return None
]:
	i: 0()
	o: 

nname: 0
n 0(None)[if self.action is None:
	log.info('nothing to do for this item')
	return None
try:
	self.action(*self.args, **self.kwargs)
except Exception, e:
	PRINT_EXCEPTION(e)
]:
	i: 
	o: 97()

nname: 0
n 0(None)[if self.action is None:
	log.info('nothing to do for this item')
	return None
try:
	self.action(*self.args, **self.kwargs)
except Exception, e:
	PRINT_EXCEPTION(e)
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb774bacc>}
nname: 64
n 64(None)[return Item.__eq__(self, other)
]:
	i: 0(f), 18()
	o: 

nname: 18
n 18(None)[]:
	i: 0(t)
	o: 64()

nname: 0
n 0(Item.__eq__(self, other))[]:
	i: 
	o: 18(t), 64(f)

nname: 0
n 0(None)[if Item.__eq__(self, other):
	pass
return Item.__eq__(self, other)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb774b8ac>}
nname: 6
n 6(None)[__doc__ = '\n    ActionItem is an Item for which we precise an action to launch\n    when item is executed\n    '
def __init__(self, name, type_, menu=None, display_type=None, action=None, args=None, kwargs=None):
	Item.__init__(self, name, type_, menu=menu, display_type=display_type)
	self.action = action
	if not args:
		pass
	self.args = args
	if not kwargs:
		pass
	self.kwargs = kwargs

def execute(self):
	if self.action is None:
		log.info('nothing to do for this item')
		return None
	try:
		self.action(*self.args, **self.kwargs)
	except Exception, e:
		PRINT_EXCEPTION(e)
	return None

def __eq__(self, other):
	if Item.__eq__(self, other):
		pass
	return Item.__eq__(self, other)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb7745e8c>}
nname: 0
n 0(None)[from __future__ import absolute_import
__all__ = ['Item', 'ActionItem']
from peewee.debug import GET_LOGGER, PRINT_EXCEPTION
from peewee.messages import send as louie_send
log = GET_LOGGER(__name__)
class Item(object):
	__doc__ = '\n    Base class for all Items\n    '
	locked = False
	hidden = False
	def __init__(self, name, type_, menu=None, display_type=None, parent=None):
		self._name = name
		self.type = type_
		self.menu = menu
		self.display_type = display_type
		self.parent = parent
		self.list_owned = []

	def _set_name(self, name):
		self._name = name

	name = property((lambda self: self._name), _set_name)
	del _set_name
	def execute(self):
		log.info('This is not an executable item (%s).' % self.__class__.__name__)

	def __repr__(self):
		return '<%s::%s(%s)>' % (self.__class__.__name__, self.type, repr(self.name))

	def __hash__(self):
		return hash(self.name)

	def __eq__(self, other):
		if isinstance(other, Item):
			return self.name == other.name
		return False

	def __cmp__(self, other):
		if isinstance(other, Item):
			return cmp(self.name, other.name)
		else:
			return cmp(type(self), type(other))

	sensitive = True
	def is_marked(self):
		log.debug('This item has no marking support.')
		return False

	universe = property((lambda self: self.menu.universe:
		pass
	return self.menu.universe))
	def show_menu(self):
		from pygui.shared import pygui_globs
		pygui_globs['menustack'].back_to_menu(self.menu)

	def reset_view(self):
		menu = self.menu
		if menu:
			for name in self.list_owned:
				louie_send(name, sender=menu, action='reset', value=menu[name])



class ActionItem(Item):
	__doc__ = '\n    ActionItem is an Item for which we precise an action to launch\n    when item is executed\n    '
	def __init__(self, name, type_, menu=None, display_type=None, action=None, args=None, kwargs=None):
		Item.__init__(self, name, type_, menu=menu, display_type=display_type)
		self.action = action
		if not args:
			pass
		self.args = args
		if not kwargs:
			pass
		self.kwargs = kwargs

	def execute(self):
		if self.action is None:
			log.info('nothing to do for this item')
			return None
		try:
			self.action(*self.args, **self.kwargs)
		except Exception, e:
			PRINT_EXCEPTION(e)
		return None

	def __eq__(self, other):
		if Item.__eq__(self, other):
			pass
		return Item.__eq__(self, other)



]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb774582c>}
from __future__ import absolute_import
__all__ = ['Item', 'ActionItem']
from peewee.debug import GET_LOGGER, PRINT_EXCEPTION
from peewee.messages import send as louie_send
log = GET_LOGGER(__name__)
class Item(object):
	__doc__ = '\n    Base class for all Items\n    '
	locked = False
	hidden = False
	def __init__(self, name, type_, menu=None, display_type=None, parent=None):
		self._name = name
		self.type = type_
		self.menu = menu
		self.display_type = display_type
		self.parent = parent
		self.list_owned = []

	def _set_name(self, name):
		self._name = name

	name = property((lambda self: self._name), _set_name)
	del _set_name
	def execute(self):
		log.info('This is not an executable item (%s).' % self.__class__.__name__)

	def __repr__(self):
		return '<%s::%s(%s)>' % (self.__class__.__name__, self.type, repr(self.name))

	def __hash__(self):
		return hash(self.name)

	def __eq__(self, other):
		if isinstance(other, Item):
			return self.name == other.name
		return False

	def __cmp__(self, other):
		if isinstance(other, Item):
			return cmp(self.name, other.name)
		else:
			return cmp(type(self), type(other))

	sensitive = True
	def is_marked(self):
		log.debug('This item has no marking support.')
		return False

	universe = property((lambda self: self.menu.universe:
		pass
	return self.menu.universe))
	def show_menu(self):
		from pygui.shared import pygui_globs
		pygui_globs['menustack'].back_to_menu(self.menu)

	def reset_view(self):
		menu = self.menu
		if menu:
			for name in self.list_owned:
				louie_send(name, sender=menu, action='reset', value=menu[name])



class ActionItem(Item):
	__doc__ = '\n    ActionItem is an Item for which we precise an action to launch\n    when item is executed\n    '
	def __init__(self, name, type_, menu=None, display_type=None, action=None, args=None, kwargs=None):
		Item.__init__(self, name, type_, menu=menu, display_type=display_type)
		self.action = action
		if not args:
			pass
		self.args = args
		if not kwargs:
			pass
		self.kwargs = kwargs

	def execute(self):
		if self.action is None:
			log.info('nothing to do for this item')
			return None
		try:
			self.action(*self.args, **self.kwargs)
		except Exception, e:
			PRINT_EXCEPTION(e)
		return None

	def __eq__(self, other):
		if Item.__eq__(self, other):
			pass
		return Item.__eq__(self, other)



