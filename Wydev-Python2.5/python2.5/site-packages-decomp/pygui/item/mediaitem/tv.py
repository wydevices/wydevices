# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 0
n 0(None)[return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb773e5ec>}
nname: 0
n 0(None)[return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb773ef2c>}
nname: 225
n 225(None)[return None
]:
	i: 115(JA), 188(JA), 221(), 224()
	o: 

nname: 224
n 224(None)[]:
	i: 71(f)
	o: 225()

nname: 221
n 221(None)[]:
	i: 219(AE)
	o: 225()

nname: 219
n 219(None)[]:
	i: 178(f)
	o: 221(AE)

nname: 188
n 188(None)[#, e
log.error('Unable to spawn TV player: %s', str(e))
]:
	i: 178(t)
	o: 225(JA)

nname: 178
n 178(<dummy_ex3> EXC_MATCH Exception)[]:
	i: 111(except)
	o: 188(t), 219(f)

nname: 115
n 115(None)[from pygui.menu.players import TVPlayer
from pygui.menu.players.core import wyplayer_instance
ChannelItem.player = TVPlayer(player=wyplayer_instance(), type='tvplayer')
]:
	i: 111(try)
	o: 225(JA)

nname: 111
n 111(None)[]:
	i: 71(t)
	o: 115(try), 178(except)

nname: 71
n 71(ChannelItem.player is None)[MediaItem.__init__(self, wymedia_resource, type_=type_, **kw)
]:
	i: 56(), 70()
	o: 111(t), 224(f)

nname: 70
n 70(None)[]:
	i: 0&43(f)
	o: 71()

nname: 56
n 56(None)[type_ += '_recording'
]:
	i: 0&43(t)
	o: 71()

nname: 0&43
n 0&43(live and live.isRecording())[service_id = int(wymedia_resource['serviceId'])
live = WyRecord().live_manager._GetLiveFromServiceID(service_id)
]:
	i: 
	o: 56(t), 70(f)

nname: 225
n 225(None)[return None
]:
	i: 115(JA), 188(JA), 178(f), 219(AE), 0&43(f)
	o: 

nname: 188
n 188(None)[#, e
log.error('Unable to spawn TV player: %s', str(e))
]:
	i: 178(t)
	o: 225(JA)

nname: 178
n 178(<dummy_ex3> EXC_MATCH Exception)[]:
	i: 111(except)
	o: 188(t), 225(f)

nname: 115
n 115(None)[from pygui.menu.players import TVPlayer
from pygui.menu.players.core import wyplayer_instance
ChannelItem.player = TVPlayer(player=wyplayer_instance(), type='tvplayer')
]:
	i: 111(try)
	o: 225(JA)

nname: 111
n 111(None)[]:
	i: 0&43(t)
	o: 115(try), 178(except)

nname: 0&43
n 0&43(ChannelItem.player is None)[service_id = int(wymedia_resource['serviceId'])
live = WyRecord().live_manager._GetLiveFromServiceID(service_id)
if live and live.isRecording():
	type_ += '_recording'
MediaItem.__init__(self, wymedia_resource, type_=type_, **kw)
]:
	i: 
	o: 111(t), 225(f)

nname: 225
n 225(None)[return None
]:
	i: 178(f), 0&43(f)
	o: 

nname: 178
n 178(None)[except Exception, e:
	log.error('Unable to spawn TV player: %s', str(e))
]:
	i: 111()
	o: 225(JA)

nname: 111
n 111(None)[try:
	from pygui.menu.players import TVPlayer
	from pygui.menu.players.core import wyplayer_instance
	ChannelItem.player = TVPlayer(player=wyplayer_instance(), type='tvplayer')
]:
	i: 0&43(t)
	o: 178()

nname: 0&43
n 0&43(ChannelItem.player is None)[service_id = int(wymedia_resource['serviceId'])
live = WyRecord().live_manager._GetLiveFromServiceID(service_id)
if live and live.isRecording():
	type_ += '_recording'
MediaItem.__init__(self, wymedia_resource, type_=type_, **kw)
]:
	i: 
	o: 111(t), 225(f)

nname: 225
n 225(None)[return None
]:
	i: 111(f), 0&43(f)
	o: 

nname: 111
n 111(None)[try:
	from pygui.menu.players import TVPlayer
	from pygui.menu.players.core import wyplayer_instance
	ChannelItem.player = TVPlayer(player=wyplayer_instance(), type='tvplayer')
except Exception, e:
	log.error('Unable to spawn TV player: %s', str(e))
]:
	i: 0&43(t)
	o: 225(JA)

nname: 0&43
n 0&43(ChannelItem.player is None)[service_id = int(wymedia_resource['serviceId'])
live = WyRecord().live_manager._GetLiveFromServiceID(service_id)
if live and live.isRecording():
	type_ += '_recording'
MediaItem.__init__(self, wymedia_resource, type_=type_, **kw)
]:
	i: 
	o: 111(t), 225(f)

nname: 0&43
n 0&43(None)[service_id = int(wymedia_resource['serviceId'])
live = WyRecord().live_manager._GetLiveFromServiceID(service_id)
if live and live.isRecording():
	type_ += '_recording'
MediaItem.__init__(self, wymedia_resource, type_=type_, **kw)
if ChannelItem.player is None:
	try:
		from pygui.menu.players import TVPlayer
		from pygui.menu.players.core import wyplayer_instance
		ChannelItem.player = TVPlayer(player=wyplayer_instance(), type='tvplayer')
	except Exception, e:
		log.error('Unable to spawn TV player: %s', str(e))
return None
]:
	i: 
	o: 

self.nodes: {'0&43': <unpyclib.structure.node instance at 0xb7742c8c>}
nname: 0
n 0(None)[return self.wymedia_resource['logical_channel_number']
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb773ef8c>}
nname: 0
n 0(None)[]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb773ef8c>}
nname: 0
n 0(None)[self.player.play(item=self, favorite=self.parent)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb77421ac>}
nname: 110
n 110(None)[return browse_ng(get_root('epg'), 0, limit, ['+scheduledStartTime'], options)
]:
	i: 0(t), 106()
	o: 

nname: 106
n 106(None)[]:
	i: 0(f)
	o: 110()

nname: 0
n 0(browse_ng(get_root('epg'), 0, limit, ['+scheduledStartTime'], options))[options = {'universe': 'tv', 'serviceId': self.wymedia_resource['serviceId'], 'scheduledStartTime': str(int(start_time)), 'scheduledEndTime': str(int(end_time))}
]:
	i: 
	o: 106(f), 110(t)

nname: 0
n 0(None)[options = {'universe': 'tv', 'serviceId': self.wymedia_resource['serviceId'], 'scheduledStartTime': str(int(start_time)), 'scheduledEndTime': str(int(end_time))}
if not browse_ng(get_root('epg'), 0, limit, ['+scheduledStartTime'], options):
	pass
return browse_ng(get_root('epg'), 0, limit, ['+scheduledStartTime'], options)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb77424cc>}
nname: 559
n 559(None)[return list(WMedia2MMIObjects(resources, self.menu, self))
]:
	i: 429(JA), 555(), 558()
	o: 

nname: 558
n 558(None)[]:
	i: 87(f)
	o: 559()

nname: 555
n 555(None)[]:
	i: 304(JA), 433()
	o: 559()

nname: 433
n 433(None)[new_prog = {'id': '%s%i' % (my_id, start_time), 'class': 'object.item.epgItem.dummy', 'title': _('EPG not available'), 'description': _('EPG not available'), 'language': 'unknown', 'scheduledStartTime': '%i' % start_time, 'scheduledEndTime': '%i' % end_time, 'rating': '0'}
resources.append(new_prog)
]:
	i: 93(f)
	o: 555()

nname: 429
n 429(None)[]:
	i: 292(f)
	o: 559(JA)

nname: 304
n 304(None)[new_prog = {'id': '%s%i' % (my_id, max_time), 'class': 'object.item.epgItem.dummy', 'title': _('EPG not available'), 'description': _('EPG not available'), 'language': 'unknown', 'scheduledStartTime': '%i' % max_time, 'scheduledEndTime': '%i' % end_time, 'rating': '0'}
resources.append(new_prog)
]:
	i: 292(t)
	o: 555(JA)

nname: 292
n 292(max_time < end_time)[]:
	i: 163(), 291()
	o: 304(t), 429(f)

nname: 291
n 291(None)[]:
	i: 110(f)
	o: 292()

nname: 163
n 163(None)[new_prog = {'id': '%s%i' % (my_id, start_time), 'class': 'object.item.epgItem.dummy', 'title': _('EPG not available'), 'description': _('EPG not available'), 'language': 'unknown', 'scheduledStartTime': '%i' % start_time, 'scheduledEndTime': '%i' % min_time, 'rating': '0'}
resources.insert(0, new_prog)
]:
	i: 110(t)
	o: 292()

nname: 110
n 110(start_time < min_time)[min_time = int(resources[0]['scheduledStartTime'])
max_time = int(resources[-1]['scheduledEndTime'])
]:
	i: 93(t)
	o: 163(t), 291(f)

nname: 93
n 93(resources)[my_id = self['id']
]:
	i: 87(t)
	o: 110(t), 433(f)

nname: 87
n 87(pad)[]:
	i: 61(), 75()
	o: 93(t), 558(f)

nname: 75
n 75(None)[resources = raw_resources[-limit:]
]:
	i: 17(f)
	o: 87()

nname: 61
n 61(None)[resources = raw_resources[:limit]
]:
	i: 17(t)
	o: 87()

nname: 17
n 17(focus < (start_time + end_time) / 2)[l = limit
raw_resources = self.scrape_database(start_time, end_time, l)
]:
	i: 6(), 13()
	o: 61(t), 75(f)

nname: 13
n 13(None)[]:
	i: 0(f)
	o: 17()

nname: 6
n 6(None)[]:
	i: 0(t)
	o: 17()

nname: 0
n 0(focus)[]:
	i: 
	o: 6(t), 13(f)

nname: 559
n 559(None)[return list(WMedia2MMIObjects(resources, self.menu, self))
]:
	i: 110(f), 304(JA), 433(), 87(f)
	o: 

nname: 433
n 433(None)[new_prog = {'id': '%s%i' % (my_id, start_time), 'class': 'object.item.epgItem.dummy', 'title': _('EPG not available'), 'description': _('EPG not available'), 'language': 'unknown', 'scheduledStartTime': '%i' % start_time, 'scheduledEndTime': '%i' % end_time, 'rating': '0'}
resources.append(new_prog)
]:
	i: 93(f)
	o: 559()

nname: 304
n 304(None)[new_prog = {'id': '%s%i' % (my_id, max_time), 'class': 'object.item.epgItem.dummy', 'title': _('EPG not available'), 'description': _('EPG not available'), 'language': 'unknown', 'scheduledStartTime': '%i' % max_time, 'scheduledEndTime': '%i' % end_time, 'rating': '0'}
resources.append(new_prog)
]:
	i: 110(t)
	o: 559(JA)

nname: 110
n 110(max_time < end_time)[min_time = int(resources[0]['scheduledStartTime'])
max_time = int(resources[-1]['scheduledEndTime'])
if start_time < min_time:
	new_prog = {'id': '%s%i' % (my_id, start_time), 'class': 'object.item.epgItem.dummy', 'title': _('EPG not available'), 'description': _('EPG not available'), 'language': 'unknown', 'scheduledStartTime': '%i' % start_time, 'scheduledEndTime': '%i' % min_time, 'rating': '0'}
	resources.insert(0, new_prog)
]:
	i: 93(t)
	o: 304(t), 559(f)

nname: 93
n 93(resources)[my_id = self['id']
]:
	i: 87(t)
	o: 110(t), 433(f)

nname: 87
n 87(pad)[]:
	i: 0()
	o: 93(t), 559(f)

nname: 0
n 0(None)[if focus:
	pass
l = limit
raw_resources = self.scrape_database(start_time, end_time, l)
if focus < (start_time + end_time) / 2:
	resources = raw_resources[:limit]
else:
	resources = raw_resources[-limit:]
]:
	i: 
	o: 87()

nname: 559
n 559(None)[return list(WMedia2MMIObjects(resources, self.menu, self))
]:
	i: 0(f)
	o: 

nname: 0
n 0(None)[if focus:
	pass
l = limit
raw_resources = self.scrape_database(start_time, end_time, l)
if focus < (start_time + end_time) / 2:
	resources = raw_resources[:limit]
else:
	resources = raw_resources[-limit:]
if pad:
	my_id = self['id']
	if resources:
		min_time = int(resources[0]['scheduledStartTime'])
		max_time = int(resources[-1]['scheduledEndTime'])
		if start_time < min_time:
			new_prog = {'id': '%s%i' % (my_id, start_time), 'class': 'object.item.epgItem.dummy', 'title': _('EPG not available'), 'description': _('EPG not available'), 'language': 'unknown', 'scheduledStartTime': '%i' % start_time, 'scheduledEndTime': '%i' % min_time, 'rating': '0'}
			resources.insert(0, new_prog)
		if max_time < end_time:
			new_prog = {'id': '%s%i' % (my_id, max_time), 'class': 'object.item.epgItem.dummy', 'title': _('EPG not available'), 'description': _('EPG not available'), 'language': 'unknown', 'scheduledStartTime': '%i' % max_time, 'scheduledEndTime': '%i' % end_time, 'rating': '0'}
			resources.append(new_prog)
	else:
		new_prog = {'id': '%s%i' % (my_id, start_time), 'class': 'object.item.epgItem.dummy', 'title': _('EPG not available'), 'description': _('EPG not available'), 'language': 'unknown', 'scheduledStartTime': '%i' % start_time, 'scheduledEndTime': '%i' % end_time, 'rating': '0'}
		resources.append(new_prog)
]:
	i: 
	o: 559(JA)

nname: 0
n 0(None)[if focus:
	pass
l = limit
raw_resources = self.scrape_database(start_time, end_time, l)
if focus < (start_time + end_time) / 2:
	resources = raw_resources[:limit]
else:
	resources = raw_resources[-limit:]
if pad:
	my_id = self['id']
	if resources:
		min_time = int(resources[0]['scheduledStartTime'])
		max_time = int(resources[-1]['scheduledEndTime'])
		if start_time < min_time:
			new_prog = {'id': '%s%i' % (my_id, start_time), 'class': 'object.item.epgItem.dummy', 'title': _('EPG not available'), 'description': _('EPG not available'), 'language': 'unknown', 'scheduledStartTime': '%i' % start_time, 'scheduledEndTime': '%i' % min_time, 'rating': '0'}
			resources.insert(0, new_prog)
		if max_time < end_time:
			new_prog = {'id': '%s%i' % (my_id, max_time), 'class': 'object.item.epgItem.dummy', 'title': _('EPG not available'), 'description': _('EPG not available'), 'language': 'unknown', 'scheduledStartTime': '%i' % max_time, 'scheduledEndTime': '%i' % end_time, 'rating': '0'}
			resources.append(new_prog)
	else:
		new_prog = {'id': '%s%i' % (my_id, start_time), 'class': 'object.item.epgItem.dummy', 'title': _('EPG not available'), 'description': _('EPG not available'), 'language': 'unknown', 'scheduledStartTime': '%i' % start_time, 'scheduledEndTime': '%i' % end_time, 'rating': '0'}
		resources.append(new_prog)
return list(WMedia2MMIObjects(resources, self.menu, self))
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb774dd0c>}
nname: 6
n 6(None)[__doc__ = 'Generic TV channel item.'
player = None
def unwatch(self, observer):
	return None

def watch(self, observer):
	return None

def __init__(self, wymedia_resource, type_='channel', **kw):
	service_id = int(wymedia_resource['serviceId'])
	live = WyRecord().live_manager._GetLiveFromServiceID(service_id)
	if live and live.isRecording():
		type_ += '_recording'
	MediaItem.__init__(self, wymedia_resource, type_=type_, **kw)
	if ChannelItem.player is None:
		try:
			from pygui.menu.players import TVPlayer
			from pygui.menu.players.core import wyplayer_instance
			ChannelItem.player = TVPlayer(player=wyplayer_instance(), type='tvplayer')
		except Exception, e:
			log.error('Unable to spawn TV player: %s', str(e))
	return None

def _get_dt(self):
	return self.wymedia_resource['logical_channel_number']

def _set_dt(self, dt):
	pass

def execute(self):
	self.player.play(item=self, favorite=self.parent)

def scrape_database(self, start_time, end_time, limit):
	options = {'universe': 'tv', 'serviceId': self.wymedia_resource['serviceId'], 'scheduledStartTime': str(int(start_time)), 'scheduledEndTime': str(int(end_time))}
	if not browse_ng(get_root('epg'), 0, limit, ['+scheduledStartTime'], options):
		pass
	return browse_ng(get_root('epg'), 0, limit, ['+scheduledStartTime'], options)

def browse(self, start_time=0, end_time=2147483640, limit=10, pad=False, focus=0):
	if focus:
		pass
	l = limit
	raw_resources = self.scrape_database(start_time, end_time, l)
	if focus < (start_time + end_time) / 2:
		resources = raw_resources[:limit]
	else:
		resources = raw_resources[-limit:]
	if pad:
		my_id = self['id']
		if resources:
			min_time = int(resources[0]['scheduledStartTime'])
			max_time = int(resources[-1]['scheduledEndTime'])
			if start_time < min_time:
				new_prog = {'id': '%s%i' % (my_id, start_time), 'class': 'object.item.epgItem.dummy', 'title': _('EPG not available'), 'description': _('EPG not available'), 'language': 'unknown', 'scheduledStartTime': '%i' % start_time, 'scheduledEndTime': '%i' % min_time, 'rating': '0'}
				resources.insert(0, new_prog)
			if max_time < end_time:
				new_prog = {'id': '%s%i' % (my_id, max_time), 'class': 'object.item.epgItem.dummy', 'title': _('EPG not available'), 'description': _('EPG not available'), 'language': 'unknown', 'scheduledStartTime': '%i' % max_time, 'scheduledEndTime': '%i' % end_time, 'rating': '0'}
				resources.append(new_prog)
		else:
			new_prog = {'id': '%s%i' % (my_id, start_time), 'class': 'object.item.epgItem.dummy', 'title': _('EPG not available'), 'description': _('EPG not available'), 'language': 'unknown', 'scheduledStartTime': '%i' % start_time, 'scheduledEndTime': '%i' % end_time, 'rating': '0'}
			resources.append(new_prog)
	return list(WMedia2MMIObjects(resources, self.menu, self))

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb7733cec>}
nname: 0
n 0(None)[ChannelItem.__init__(self, wymedia_resource, type_, **kw)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7733e0c>}
nname: 0
n 0(None)[return []
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7733b0c>}
nname: 6
n 6(None)[__doc__ = 'Capture service (AUX, line in, etc.).'
def __init__(self, wymedia_resource, type_='capture_channel', **kw):
	ChannelItem.__init__(self, wymedia_resource, type_, **kw)

def scrape_database(self, start_time, end_time, limit):
	return []

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb77338ac>}
nname: 0
n 0(None)[return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb77469cc>}
nname: 0
n 0(None)[return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb77467cc>}
nname: 421
n 421(None)[self.wymedia_resource['maturityRating'] = maturity_rating
]:
	i: 301(), 324(), 364(), 404(), 414()
	o: 

nname: 414
n 414(None)[maturity_rating = '18'
]:
	i: 401(f)
	o: 421()

nname: 404
n 404(None)[maturity_rating = '16'
]:
	i: 401(t)
	o: 421()

nname: 401
n 401(12 < rating)[]:
	i: 389(), 399()
	o: 404(t), 414(f)

nname: 399
n 399(None)[rating
]:
	i: 374(f)
	o: 401()

nname: 389
n 389(None)[]:
	i: 374(t)
	o: 401()

nname: 374
n 374(12 < rating)[]:
	i: 361(f)
	o: 389(t), 399(f)

nname: 364
n 364(None)[maturity_rating = '12'
]:
	i: 361(t)
	o: 421()

nname: 361
n 361(10 < rating)[]:
	i: 349(), 359()
	o: 364(t), 374(f)

nname: 359
n 359(None)[rating
]:
	i: 334(f)
	o: 361()

nname: 349
n 349(None)[]:
	i: 334(t)
	o: 361()

nname: 334
n 334(10 < rating)[]:
	i: 311(f)
	o: 349(t), 359(f)

nname: 324
n 324(None)[maturity_rating = '10'
]:
	i: 311(t)
	o: 421()

nname: 311
n 311(rating == 10)[]:
	i: 289(f)
	o: 324(t), 334(f)

nname: 301
n 301(None)[maturity_rating = '0'
]:
	i: 289(t)
	o: 421()

nname: 289
n 289(rating < 10)[]:
	i: 226(), 256(), 287(AE)
	o: 301(t), 311(f)

nname: 287
n 287(None)[]:
	i: 246(f)
	o: 289(AE)

nname: 256
n 256(None)[rating = int(wymedia_resource.get('rating', '0'))
]:
	i: 246(t)
	o: 289()

nname: 246
n 246(<dummy_ex3> EXC_MATCH KeyError)[]:
	i: 43(except)
	o: 256(t), 287(f)

nname: 226
n 226(None)[rating = int(wymedia_resource['maturityRating'])
]:
	i: 43(try)
	o: 289()

nname: 43
n 43(None)[MediaItem.__init__(self, wymedia_resource, type_=type_, **kw)
self.start_time = int(wymedia_resource['scheduledStartTime'])
self.end_time = int(wymedia_resource['scheduledEndTime'])
self.duration, wymedia_resource['duration'] = self.end_time - self.start_time, self.end_time - self.start_time
self.description = wymedia_resource.get('longDescription', '')
self.short_description = wymedia_resource.get('description', '')
desc_code = int(wymedia_resource.get('contentDesc', 0))
self.content_type = self._CONTENT_DESC_MAPPING.get(desc_code, 'Undefined content')
]:
	i: 28(), 42()
	o: 226(try), 246(except)

nname: 42
n 42(None)[]:
	i: 0(f)
	o: 43()

nname: 28
n 28(None)[type_ += '_recording'
]:
	i: 0(t)
	o: 43()

nname: 0
n 0(self.recording_status in RECS_TO_DISPLAY)[self.id = wymedia_resource['id']
]:
	i: 
	o: 28(t), 42(f)

nname: 421
n 421(None)[self.wymedia_resource['maturityRating'] = maturity_rating
]:
	i: 301(), 324(), 364(), 374()
	o: 

nname: 374
n 374(None)[if 12 < rating:
	pass
else:
	rating
if 12 < rating:
	maturity_rating = '16'
else:
	maturity_rating = '18'
]:
	i: 334(f)
	o: 421()

nname: 364
n 364(None)[maturity_rating = '12'
]:
	i: 334(t)
	o: 421()

nname: 334
n 334(10 < rating)[if 10 < rating:
	pass
else:
	rating
]:
	i: 311(f)
	o: 364(t), 374(f)

nname: 324
n 324(None)[maturity_rating = '10'
]:
	i: 311(t)
	o: 421()

nname: 311
n 311(rating == 10)[]:
	i: 289(f)
	o: 324(t), 334(f)

nname: 301
n 301(None)[maturity_rating = '0'
]:
	i: 289(t)
	o: 421()

nname: 289
n 289(rating < 10)[]:
	i: 226()
	o: 301(t), 311(f)

nname: 226
n 226(None)[try:
	rating = int(wymedia_resource['maturityRating'])
except KeyError:
	rating = int(wymedia_resource.get('rating', '0'))
]:
	i: 0(try)
	o: 289()

nname: 0
n 0(None)[self.id = wymedia_resource['id']
if self.recording_status in RECS_TO_DISPLAY:
	type_ += '_recording'
MediaItem.__init__(self, wymedia_resource, type_=type_, **kw)
self.start_time = int(wymedia_resource['scheduledStartTime'])
self.end_time = int(wymedia_resource['scheduledEndTime'])
self.duration, wymedia_resource['duration'] = self.end_time - self.start_time, self.end_time - self.start_time
self.description = wymedia_resource.get('longDescription', '')
self.short_description = wymedia_resource.get('description', '')
desc_code = int(wymedia_resource.get('contentDesc', 0))
self.content_type = self._CONTENT_DESC_MAPPING.get(desc_code, 'Undefined content')
]:
	i: 
	o: 226(try)

nname: 289
n 289(None)[if rating < 10:
	maturity_rating = '0'
else:
	if rating == 10:
		maturity_rating = '10'
	else:
		if 10 < rating:
			pass
		else:
			rating
		if 10 < rating:
			maturity_rating = '12'
		else:
			if 12 < rating:
				pass
			else:
				rating
			if 12 < rating:
				maturity_rating = '16'
			else:
				maturity_rating = '18'
self.wymedia_resource['maturityRating'] = maturity_rating
]:
	i: 0()
	o: 

nname: 0
n 0(None)[self.id = wymedia_resource['id']
if self.recording_status in RECS_TO_DISPLAY:
	type_ += '_recording'
MediaItem.__init__(self, wymedia_resource, type_=type_, **kw)
self.start_time = int(wymedia_resource['scheduledStartTime'])
self.end_time = int(wymedia_resource['scheduledEndTime'])
self.duration, wymedia_resource['duration'] = self.end_time - self.start_time, self.end_time - self.start_time
self.description = wymedia_resource.get('longDescription', '')
self.short_description = wymedia_resource.get('description', '')
desc_code = int(wymedia_resource.get('contentDesc', 0))
self.content_type = self._CONTENT_DESC_MAPPING.get(desc_code, 'Undefined content')
try:
	rating = int(wymedia_resource['maturityRating'])
except KeyError:
	rating = int(wymedia_resource.get('rating', '0'))
]:
	i: 
	o: 289()

nname: 0
n 0(None)[self.id = wymedia_resource['id']
if self.recording_status in RECS_TO_DISPLAY:
	type_ += '_recording'
MediaItem.__init__(self, wymedia_resource, type_=type_, **kw)
self.start_time = int(wymedia_resource['scheduledStartTime'])
self.end_time = int(wymedia_resource['scheduledEndTime'])
self.duration, wymedia_resource['duration'] = self.end_time - self.start_time, self.end_time - self.start_time
self.description = wymedia_resource.get('longDescription', '')
self.short_description = wymedia_resource.get('description', '')
desc_code = int(wymedia_resource.get('contentDesc', 0))
self.content_type = self._CONTENT_DESC_MAPPING.get(desc_code, 'Undefined content')
try:
	rating = int(wymedia_resource['maturityRating'])
except KeyError:
	rating = int(wymedia_resource.get('rating', '0'))
if rating < 10:
	maturity_rating = '0'
else:
	if rating == 10:
		maturity_rating = '10'
	else:
		if 10 < rating:
			pass
		else:
			rating
		if 10 < rating:
			maturity_rating = '12'
		else:
			if 12 < rating:
				pass
			else:
				rating
			if 12 < rating:
				maturity_rating = '16'
			else:
				maturity_rating = '18'
self.wymedia_resource['maturityRating'] = maturity_rating
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7735dec>}
nname: 0
n 0(None)[self.parent.execute()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76f664c>}
nname: 6
n 6(None)[__doc__ = 'EPG information for a single program.'
EXTRA_INFO_FIELDS = [('videoFormat_16_9', _('16:9')), ('videoFormatHD', _('High definition')), ('nrAudioChannels', _('Multiple audio tracks')), ('nrSubtitleTracks', _('Subtitles')), ('subtitleHardOfHearing', _('Subtitles for hearing impaired')), ('audioHardOfHearing', _('Audio for hearing impaired')), ('audioVisuallyImpaired', _('Audio for visually impaired')), ('freeCaMode', _('Scrambled'))]
_CONTENT_DESC_MAPPING = UnicodeDict({0: 'Undefined content', 16: 'Movie/Drama', 17: 'Detective/Thriller', 18: 'Adventure/Western/War', 19: 'Science fiction/Fantasy/Horror', 20: 'Comedy', 21: 'Soap/Melodrama/Folkloric', 22: 'Romance', 23: 'Serious/Classical/Religious/Historical movie/drama', 24: 'Adult movie/drama', 31: 'User defined', 32: 'News/Current affairs', 33: 'News/Weather report', 34: 'News magazine', 35: 'Documentary', 36: 'Discussion/Interview/Debate', 47: 'User defined', 48: 'Show/Game show', 49: 'Game show/Quiz/Contest', 50: 'Variety show', 51: 'Talk show', 63: 'User defined', 64: 'Sports', 65: 'Special Events (Olympic games, World cup...)', 66: 'Sports magazine', 67: 'Football/Soccer', 68: 'Tennis/Squash', 69: 'Team sports (other than football)', 70: 'Athletics', 71: 'Motor sports', 72: 'Water sports', 73: 'Winter sports', 74: 'Equestrian sports', 75: 'Martial arts', 79: 'User defined', 80: "Children's/Youth program", 81: "Pre-school children's program", 82: 'Entertainment program (6 to 14 years old)', 83: 'Entertainment program (10 to 16 years old)', 84: 'Informational/Educational/School program', 85: 'Cartoon/Puppet show', 95: 'User defined', 96: 'Music/Ballet/Dance', 97: 'Rock/Pop', 98: 'Serious/Classical music', 99: 'Folk/Traditional music', 100: 'Jazz', 101: 'Musical/Opera', 102: 'Ballet', 111: 'User defined', 112: 'Arts/Culture (other than music)', 113: 'Performing arts', 114: 'Fine arts', 115: 'Religion', 116: 'Popular culture/Traditional arts', 117: 'Literature', 118: 'Film/Cinema', 119: 'Experimental film/video', 120: 'Broadcasting/Press', 121: 'New media', 122: 'Arts/Culture magazine', 123: 'Fashion', 127: 'User defined', 128: 'Social/political issues/Economics', 129: 'Magazine/Report/Documentary', 130: 'Economics/Social advisory', 131: 'Remarkable people', 143: 'User defined', 144: 'Education/Science/Factual topic', 145: 'Nature/Animals/Environment', 146: 'Technology/Natural sciences', 147: 'Medicine/Physiology/Psychology', 148: 'Foreign countries/Expeditions', 149: 'Social/Spiritual sciences', 150: 'Further education', 151: 'Languages', 159: 'User defined', 160: 'Leisure hobby', 161: 'Tourism/Travel', 162: 'Handicraft', 163: 'Motoring', 164: 'Fitness and health', 165: 'Cooking', 166: 'Advertisement/Shopping', 167: 'Gardening', 175: 'User defined'})
_SPECIAL_ATTRIBUTES_MAPPING = UnicodeDict({176: 'Original language', 177: 'Black and white', 178: 'Unpublished', 179: 'Live broadcast', 191: 'User defined', 255: 'User defined'})
def unwatch(self, observer):
	return None

def watch(self, observer):
	return None

def __init__(self, wymedia_resource, type_='epg', **kw):
	self.id = wymedia_resource['id']
	if self.recording_status in RECS_TO_DISPLAY:
		type_ += '_recording'
	MediaItem.__init__(self, wymedia_resource, type_=type_, **kw)
	self.start_time = int(wymedia_resource['scheduledStartTime'])
	self.end_time = int(wymedia_resource['scheduledEndTime'])
	self.duration, wymedia_resource['duration'] = self.end_time - self.start_time, self.end_time - self.start_time
	self.description = wymedia_resource.get('longDescription', '')
	self.short_description = wymedia_resource.get('description', '')
	desc_code = int(wymedia_resource.get('contentDesc', 0))
	self.content_type = self._CONTENT_DESC_MAPPING.get(desc_code, 'Undefined content')
	try:
		rating = int(wymedia_resource['maturityRating'])
	except KeyError:
		rating = int(wymedia_resource.get('rating', '0'))
	if rating < 10:
		maturity_rating = '0'
	else:
		if rating == 10:
			maturity_rating = '10'
		else:
			if 10 < rating:
				pass
			else:
				rating
			if 10 < rating:
				maturity_rating = '12'
			else:
				if 12 < rating:
					pass
				else:
					rating
				if 12 < rating:
					maturity_rating = '16'
				else:
					maturity_rating = '18'
	self.wymedia_resource['maturityRating'] = maturity_rating

recording_id = property()
recording_status = property()
def execute(self):
	self.parent.execute()

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb774404c>}
nname: 0
n 0(None)[DirItem.__init__(self, wymedia_resource, type_='all_channels_list', menu=menu, parent=TVRootItem())
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb773350c>}
nname: 89
n 89(None)[return get_mmi_object(res[0], self.menu, self)
]:
	i: 71(), 88()
	o: 

nname: 88
n 88(None)[]:
	i: 53(f)
	o: 89()

nname: 71
n 71(None)[log.warn('Wymedia knows more than 1 channel with that service ID.')
]:
	i: 53(t)
	o: 89()

nname: 53
n 53(len(res) > 1)[]:
	i: 33(), 52()
	o: 71(t), 88(f)

nname: 52
n 52(None)[]:
	i: 0(t)
	o: 53()

nname: 33
n 33(None)[raise KeyError('AllChannelsList.get_channel_from_service_id: no such service ID', service_id)
]:
	i: 0(f)
	o: 53()

nname: 0
n 0(res)[res = container_search(self.wymedia_resource, 'serviceId', str(service_id))
]:
	i: 
	o: 33(f), 52(t)

nname: 89
n 89(None)[return get_mmi_object(res[0], self.menu, self)
]:
	i: 0()
	o: 

nname: 0
n 0(None)[res = container_search(self.wymedia_resource, 'serviceId', str(service_id))
if not res:
	raise KeyError('AllChannelsList.get_channel_from_service_id: no such service ID', service_id)
if len(res) > 1:
	log.warn('Wymedia knows more than 1 channel with that service ID.')
]:
	i: 
	o: 89()

nname: 0
n 0(None)[res = container_search(self.wymedia_resource, 'serviceId', str(service_id))
if not res:
	raise KeyError('AllChannelsList.get_channel_from_service_id: no such service ID', service_id)
if len(res) > 1:
	log.warn('Wymedia knows more than 1 channel with that service ID.')
return get_mmi_object(res[0], self.menu, self)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb773efec>}
nname: 32
n 32(None)[return WindowedItemList(self, menu=self.menu, universe=self.universe, sort_order=['logical_channel_number'], filter=filter)
]:
	i: 6(), 16()
	o: 

nname: 16
n 16(None)[filter = {'class': 'object.item.videoItem.videoBroadcast'}
]:
	i: 0(f)
	o: 32()

nname: 6
n 6(None)[filter = None
]:
	i: 0(t)
	o: 32()

nname: 0
n 0(include_aux)[]:
	i: 
	o: 6(t), 16(f)

nname: 0
n 0(None)[if include_aux:
	filter = None
else:
	filter = {'class': 'object.item.videoItem.videoBroadcast'}
return WindowedItemList(self, menu=self.menu, universe=self.universe, sort_order=['logical_channel_number'], filter=filter)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb773e3ec>}
nname: 6
n 6(None)[__doc__ = "All Channels list. It's basically a read-only playlist with a minimal interface.\n    "
def __init__(self, wymedia_resource, menu):
	DirItem.__init__(self, wymedia_resource, type_='all_channels_list', menu=menu, parent=TVRootItem())

def get_channel_from_service_id(self, service_id):
	res = container_search(self.wymedia_resource, 'serviceId', str(service_id))
	if not res:
		raise KeyError('AllChannelsList.get_channel_from_service_id: no such service ID', service_id)
	if len(res) > 1:
		log.warn('Wymedia knows more than 1 channel with that service ID.')
	return get_mmi_object(res[0], self.menu, self)

name = property()
def browse(self, include_aux=True):
	if include_aux:
		filter = None
	else:
		filter = {'class': 'object.item.videoItem.videoBroadcast'}
	return WindowedItemList(self, menu=self.menu, universe=self.universe, sort_order=['logical_channel_number'], filter=filter)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb7733b2c>}
nname: 0
n 0(None)[DirItem.__init__(self, get_root('recordings'), menu=menu, type_='video_dir')
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7733cec>}
nname: 6
n 6(None)[__doc__ = 'The root container for TV recordings.'
def __init__(self, menu):
	DirItem.__init__(self, get_root('recordings'), menu=menu, type_='video_dir')

universe = property()
]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb773396c>}
nname: 0
n 0(None)[RootItem()
MediaItem.__init__(self, _('TV Universe'), type_='tv_root', menu=menu)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb773e48c>}
nname: 62
n 62(None)[return dispatch[source](menu)
]:
	i: 0(t), 55()
	o: 

nname: 55
n 55(None)[]:
	i: 0(f)
	o: 62()

nname: 0
n 0(menu)[dispatch = {'acl': self.browse_acl, 'favorites': self.browse_favorites, 'recordings': self.browse_recordings}
]:
	i: 
	o: 55(f), 62(t)

nname: 0
n 0(None)[dispatch = {'acl': self.browse_acl, 'favorites': self.browse_favorites, 'recordings': self.browse_recordings}
if not menu:
	pass
return dispatch[source](menu)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76db96c>}
nname: 0
n 0(None)[pygui_globs['menustack'].back_one_menu()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb773e58c>}
nname: 41
n 41(None)[return AllChannelsList(res, menu)
]:
	i: 0(t), 34()
	o: 

nname: 34
n 34(None)[]:
	i: 0(f)
	o: 41()

nname: 0
n 0(menu)[res = get_root('channel')
res['title'] = u'all_channels_list'
]:
	i: 
	o: 34(f), 41(t)

nname: 0
n 0(None)[res = get_root('channel')
res['title'] = u'all_channels_list'
if not menu:
	pass
return AllChannelsList(res, menu)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb773ef0c>}
nname: 0
n 0(None)[return [self.get_acl(menu)]
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb773e64c>}
nname: 0
n 0(None)[return HiddenRoot().get_child(TV_FAVORITES_FOLDER, menu)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb773ef0c>}
nname: 0
n 0(None)[return self.get_favorites_root(menu).browse()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb773e42c>}
nname: 16
n 16(None)[return RecordingsRootItem(menu)
]:
	i: 0(t), 9()
	o: 

nname: 9
n 9(None)[]:
	i: 0(f)
	o: 16()

nname: 0
n 0(menu)[]:
	i: 
	o: 9(f), 16(t)

nname: 0
n 0(None)[if not menu:
	pass
return RecordingsRootItem(menu)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb773ef8c>}
nname: 0
n 0(None)[return self.get_recordings(menu).browse()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb773ef4c>}
nname: 6
n 6(None)[__metaclass__ = MetaSingleton
def __init__(self, menu=None):
	RootItem()
	MediaItem.__init__(self, _('TV Universe'), type_='tv_root', menu=menu)

def browse(self, source='acl', menu=None):
	dispatch = {'acl': self.browse_acl, 'favorites': self.browse_favorites, 'recordings': self.browse_recordings}
	if not menu:
		pass
	return dispatch[source](menu)

def show_menu(self):
	pygui_globs['menustack'].back_one_menu()

def get_acl(self, menu=None):
	res = get_root('channel')
	res['title'] = u'all_channels_list'
	if not menu:
		pass
	return AllChannelsList(res, menu)

def browse_acl(self, menu=None):
	return [self.get_acl(menu)]

def get_favorites_root(self, menu=None):
	return HiddenRoot().get_child(TV_FAVORITES_FOLDER, menu)

def browse_favorites(self, menu=None):
	return self.get_favorites_root(menu).browse()

def get_recordings(self, menu=None):
	if not menu:
		pass
	return RecordingsRootItem(menu)

def browse_recordings(self, menu=None):
	return self.get_recordings(menu).browse()

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb7733dec>}
nname: 319
n 319(None)[log = GET_LOGGER(__name__)
class ChannelItem(MediaItem):
	__doc__ = 'Generic TV channel item.'
	player = None
	def unwatch(self, observer):
		return None

	def watch(self, observer):
		return None

	def __init__(self, wymedia_resource, type_='channel', **kw):
		service_id = int(wymedia_resource['serviceId'])
		live = WyRecord().live_manager._GetLiveFromServiceID(service_id)
		if live and live.isRecording():
			type_ += '_recording'
		MediaItem.__init__(self, wymedia_resource, type_=type_, **kw)
		if ChannelItem.player is None:
			try:
				from pygui.menu.players import TVPlayer
				from pygui.menu.players.core import wyplayer_instance
				ChannelItem.player = TVPlayer(player=wyplayer_instance(), type='tvplayer')
			except Exception, e:
				log.error('Unable to spawn TV player: %s', str(e))
		return None

	def _get_dt(self):
		return self.wymedia_resource['logical_channel_number']

	def _set_dt(self, dt):
		pass

	def execute(self):
		self.player.play(item=self, favorite=self.parent)

	def scrape_database(self, start_time, end_time, limit):
		options = {'universe': 'tv', 'serviceId': self.wymedia_resource['serviceId'], 'scheduledStartTime': str(int(start_time)), 'scheduledEndTime': str(int(end_time))}
		if not browse_ng(get_root('epg'), 0, limit, ['+scheduledStartTime'], options):
			pass
		return browse_ng(get_root('epg'), 0, limit, ['+scheduledStartTime'], options)

	def browse(self, start_time=0, end_time=2147483640, limit=10, pad=False, focus=0):
		if focus:
			pass
		l = limit
		raw_resources = self.scrape_database(start_time, end_time, l)
		if focus < (start_time + end_time) / 2:
			resources = raw_resources[:limit]
		else:
			resources = raw_resources[-limit:]
		if pad:
			my_id = self['id']
			if resources:
				min_time = int(resources[0]['scheduledStartTime'])
				max_time = int(resources[-1]['scheduledEndTime'])
				if start_time < min_time:
					new_prog = {'id': '%s%i' % (my_id, start_time), 'class': 'object.item.epgItem.dummy', 'title': _('EPG not available'), 'description': _('EPG not available'), 'language': 'unknown', 'scheduledStartTime': '%i' % start_time, 'scheduledEndTime': '%i' % min_time, 'rating': '0'}
					resources.insert(0, new_prog)
				if max_time < end_time:
					new_prog = {'id': '%s%i' % (my_id, max_time), 'class': 'object.item.epgItem.dummy', 'title': _('EPG not available'), 'description': _('EPG not available'), 'language': 'unknown', 'scheduledStartTime': '%i' % max_time, 'scheduledEndTime': '%i' % end_time, 'rating': '0'}
					resources.append(new_prog)
			else:
				new_prog = {'id': '%s%i' % (my_id, start_time), 'class': 'object.item.epgItem.dummy', 'title': _('EPG not available'), 'description': _('EPG not available'), 'language': 'unknown', 'scheduledStartTime': '%i' % start_time, 'scheduledEndTime': '%i' % end_time, 'rating': '0'}
				resources.append(new_prog)
		return list(WMedia2MMIObjects(resources, self.menu, self))



class CaptureChannelItem(ChannelItem):
	__doc__ = 'Capture service (AUX, line in, etc.).'
	def __init__(self, wymedia_resource, type_='capture_channel', **kw):
		ChannelItem.__init__(self, wymedia_resource, type_, **kw)

	def scrape_database(self, start_time, end_time, limit):
		return []



class ProgramItem(MediaItem):
	__doc__ = 'EPG information for a single program.'
	EXTRA_INFO_FIELDS = [('videoFormat_16_9', _('16:9')), ('videoFormatHD', _('High definition')), ('nrAudioChannels', _('Multiple audio tracks')), ('nrSubtitleTracks', _('Subtitles')), ('subtitleHardOfHearing', _('Subtitles for hearing impaired')), ('audioHardOfHearing', _('Audio for hearing impaired')), ('audioVisuallyImpaired', _('Audio for visually impaired')), ('freeCaMode', _('Scrambled'))]
	_CONTENT_DESC_MAPPING = UnicodeDict({0: 'Undefined content', 16: 'Movie/Drama', 17: 'Detective/Thriller', 18: 'Adventure/Western/War', 19: 'Science fiction/Fantasy/Horror', 20: 'Comedy', 21: 'Soap/Melodrama/Folkloric', 22: 'Romance', 23: 'Serious/Classical/Religious/Historical movie/drama', 24: 'Adult movie/drama', 31: 'User defined', 32: 'News/Current affairs', 33: 'News/Weather report', 34: 'News magazine', 35: 'Documentary', 36: 'Discussion/Interview/Debate', 47: 'User defined', 48: 'Show/Game show', 49: 'Game show/Quiz/Contest', 50: 'Variety show', 51: 'Talk show', 63: 'User defined', 64: 'Sports', 65: 'Special Events (Olympic games, World cup...)', 66: 'Sports magazine', 67: 'Football/Soccer', 68: 'Tennis/Squash', 69: 'Team sports (other than football)', 70: 'Athletics', 71: 'Motor sports', 72: 'Water sports', 73: 'Winter sports', 74: 'Equestrian sports', 75: 'Martial arts', 79: 'User defined', 80: "Children's/Youth program", 81: "Pre-school children's program", 82: 'Entertainment program (6 to 14 years old)', 83: 'Entertainment program (10 to 16 years old)', 84: 'Informational/Educational/School program', 85: 'Cartoon/Puppet show', 95: 'User defined', 96: 'Music/Ballet/Dance', 97: 'Rock/Pop', 98: 'Serious/Classical music', 99: 'Folk/Traditional music', 100: 'Jazz', 101: 'Musical/Opera', 102: 'Ballet', 111: 'User defined', 112: 'Arts/Culture (other than music)', 113: 'Performing arts', 114: 'Fine arts', 115: 'Religion', 116: 'Popular culture/Traditional arts', 117: 'Literature', 118: 'Film/Cinema', 119: 'Experimental film/video', 120: 'Broadcasting/Press', 121: 'New media', 122: 'Arts/Culture magazine', 123: 'Fashion', 127: 'User defined', 128: 'Social/political issues/Economics', 129: 'Magazine/Report/Documentary', 130: 'Economics/Social advisory', 131: 'Remarkable people', 143: 'User defined', 144: 'Education/Science/Factual topic', 145: 'Nature/Animals/Environment', 146: 'Technology/Natural sciences', 147: 'Medicine/Physiology/Psychology', 148: 'Foreign countries/Expeditions', 149: 'Social/Spiritual sciences', 150: 'Further education', 151: 'Languages', 159: 'User defined', 160: 'Leisure hobby', 161: 'Tourism/Travel', 162: 'Handicraft', 163: 'Motoring', 164: 'Fitness and health', 165: 'Cooking', 166: 'Advertisement/Shopping', 167: 'Gardening', 175: 'User defined'})
	_SPECIAL_ATTRIBUTES_MAPPING = UnicodeDict({176: 'Original language', 177: 'Black and white', 178: 'Unpublished', 179: 'Live broadcast', 191: 'User defined', 255: 'User defined'})
	def unwatch(self, observer):
		return None

	def watch(self, observer):
		return None

	def __init__(self, wymedia_resource, type_='epg', **kw):
		self.id = wymedia_resource['id']
		if self.recording_status in RECS_TO_DISPLAY:
			type_ += '_recording'
		MediaItem.__init__(self, wymedia_resource, type_=type_, **kw)
		self.start_time = int(wymedia_resource['scheduledStartTime'])
		self.end_time = int(wymedia_resource['scheduledEndTime'])
		self.duration, wymedia_resource['duration'] = self.end_time - self.start_time, self.end_time - self.start_time
		self.description = wymedia_resource.get('longDescription', '')
		self.short_description = wymedia_resource.get('description', '')
		desc_code = int(wymedia_resource.get('contentDesc', 0))
		self.content_type = self._CONTENT_DESC_MAPPING.get(desc_code, 'Undefined content')
		try:
			rating = int(wymedia_resource['maturityRating'])
		except KeyError:
			rating = int(wymedia_resource.get('rating', '0'))
		if rating < 10:
			maturity_rating = '0'
		else:
			if rating == 10:
				maturity_rating = '10'
			else:
				if 10 < rating:
					pass
				else:
					rating
				if 10 < rating:
					maturity_rating = '12'
				else:
					if 12 < rating:
						pass
					else:
						rating
					if 12 < rating:
						maturity_rating = '16'
					else:
						maturity_rating = '18'
		self.wymedia_resource['maturityRating'] = maturity_rating

	recording_id = property()
	recording_status = property()
	def execute(self):
		self.parent.execute()



class AllChannelsList(DirItem):
	__doc__ = "All Channels list. It's basically a read-only playlist with a minimal interface.\n    "
	def __init__(self, wymedia_resource, menu):
		DirItem.__init__(self, wymedia_resource, type_='all_channels_list', menu=menu, parent=TVRootItem())

	def get_channel_from_service_id(self, service_id):
		res = container_search(self.wymedia_resource, 'serviceId', str(service_id))
		if not res:
			raise KeyError('AllChannelsList.get_channel_from_service_id: no such service ID', service_id)
		if len(res) > 1:
			log.warn('Wymedia knows more than 1 channel with that service ID.')
		return get_mmi_object(res[0], self.menu, self)

	name = property()
	def browse(self, include_aux=True):
		if include_aux:
			filter = None
		else:
			filter = {'class': 'object.item.videoItem.videoBroadcast'}
		return WindowedItemList(self, menu=self.menu, universe=self.universe, sort_order=['logical_channel_number'], filter=filter)



class RecordingsRootItem(DirItem):
	__doc__ = 'The root container for TV recordings.'
	def __init__(self, menu):
		DirItem.__init__(self, get_root('recordings'), menu=menu, type_='video_dir')

	universe = property()


class TVRootItem(MediaItem, GenericContainer):
	__metaclass__ = MetaSingleton
	def __init__(self, menu=None):
		RootItem()
		MediaItem.__init__(self, _('TV Universe'), type_='tv_root', menu=menu)

	def browse(self, source='acl', menu=None):
		dispatch = {'acl': self.browse_acl, 'favorites': self.browse_favorites, 'recordings': self.browse_recordings}
		if not menu:
			pass
		return dispatch[source](menu)

	def show_menu(self):
		pygui_globs['menustack'].back_one_menu()

	def get_acl(self, menu=None):
		res = get_root('channel')
		res['title'] = u'all_channels_list'
		if not menu:
			pass
		return AllChannelsList(res, menu)

	def browse_acl(self, menu=None):
		return [self.get_acl(menu)]

	def get_favorites_root(self, menu=None):
		return HiddenRoot().get_child(TV_FAVORITES_FOLDER, menu)

	def browse_favorites(self, menu=None):
		return self.get_favorites_root(menu).browse()

	def get_recordings(self, menu=None):
		if not menu:
			pass
		return RecordingsRootItem(menu)

	def browse_recordings(self, menu=None):
		return self.get_recordings(menu).browse()



]:
	i: 252(), 318()
	o: 

nname: 318
n 318(None)[]:
	i: 0(f)
	o: 319()

nname: 252
n 252(None)[from wyrecord import WyRecord
from wyrecord.recording import RECORDING_STATUS_UNKNOWN, RECORDING_STATUS_SCHEDULED, RECORDING_STATUS_RUNNING
RECS_TO_DISPLAY = frozenset([RECORDING_STATUS_SCHEDULED, RECORDING_STATUS_RUNNING])
]:
	i: 0(t)
	o: 319()

nname: 0
n 0('tv' in plugins)[from __future__ import absolute_import
from wymedia.wmplus import get_root, browse_ng, container_search
from peewee.debug import GET_LOGGER
from peewee.misc_utils import MetaSingleton
from ..containers import GenericContainer
from .core import MediaItem, DirItem, RootItem, HiddenRoot, TV_FAVORITES_FOLDER
from .core import get_mmi_object, WMedia2MMIObjects
from .progressive_result import WindowedItemList
from pygui.config import user_config, plugins
from pygui.facilities.codemapping import country_dict
from pygui.facilities.l10n import UnicodeDict
from pygui.shared import pygui_globs
]:
	i: 
	o: 252(t), 318(f)

nname: 0
n 0(None)[from __future__ import absolute_import
from wymedia.wmplus import get_root, browse_ng, container_search
from peewee.debug import GET_LOGGER
from peewee.misc_utils import MetaSingleton
from ..containers import GenericContainer
from .core import MediaItem, DirItem, RootItem, HiddenRoot, TV_FAVORITES_FOLDER
from .core import get_mmi_object, WMedia2MMIObjects
from .progressive_result import WindowedItemList
from pygui.config import user_config, plugins
from pygui.facilities.codemapping import country_dict
from pygui.facilities.l10n import UnicodeDict
from pygui.shared import pygui_globs
if 'tv' in plugins:
	from wyrecord import WyRecord
	from wyrecord.recording import RECORDING_STATUS_UNKNOWN, RECORDING_STATUS_SCHEDULED, RECORDING_STATUS_RUNNING
	RECS_TO_DISPLAY = frozenset([RECORDING_STATUS_SCHEDULED, RECORDING_STATUS_RUNNING])
log = GET_LOGGER(__name__)
class ChannelItem(MediaItem):
	__doc__ = 'Generic TV channel item.'
	player = None
	def unwatch(self, observer):
		return None

	def watch(self, observer):
		return None

	def __init__(self, wymedia_resource, type_='channel', **kw):
		service_id = int(wymedia_resource['serviceId'])
		live = WyRecord().live_manager._GetLiveFromServiceID(service_id)
		if live and live.isRecording():
			type_ += '_recording'
		MediaItem.__init__(self, wymedia_resource, type_=type_, **kw)
		if ChannelItem.player is None:
			try:
				from pygui.menu.players import TVPlayer
				from pygui.menu.players.core import wyplayer_instance
				ChannelItem.player = TVPlayer(player=wyplayer_instance(), type='tvplayer')
			except Exception, e:
				log.error('Unable to spawn TV player: %s', str(e))
		return None

	def _get_dt(self):
		return self.wymedia_resource['logical_channel_number']

	def _set_dt(self, dt):
		pass

	def execute(self):
		self.player.play(item=self, favorite=self.parent)

	def scrape_database(self, start_time, end_time, limit):
		options = {'universe': 'tv', 'serviceId': self.wymedia_resource['serviceId'], 'scheduledStartTime': str(int(start_time)), 'scheduledEndTime': str(int(end_time))}
		if not browse_ng(get_root('epg'), 0, limit, ['+scheduledStartTime'], options):
			pass
		return browse_ng(get_root('epg'), 0, limit, ['+scheduledStartTime'], options)

	def browse(self, start_time=0, end_time=2147483640, limit=10, pad=False, focus=0):
		if focus:
			pass
		l = limit
		raw_resources = self.scrape_database(start_time, end_time, l)
		if focus < (start_time + end_time) / 2:
			resources = raw_resources[:limit]
		else:
			resources = raw_resources[-limit:]
		if pad:
			my_id = self['id']
			if resources:
				min_time = int(resources[0]['scheduledStartTime'])
				max_time = int(resources[-1]['scheduledEndTime'])
				if start_time < min_time:
					new_prog = {'id': '%s%i' % (my_id, start_time), 'class': 'object.item.epgItem.dummy', 'title': _('EPG not available'), 'description': _('EPG not available'), 'language': 'unknown', 'scheduledStartTime': '%i' % start_time, 'scheduledEndTime': '%i' % min_time, 'rating': '0'}
					resources.insert(0, new_prog)
				if max_time < end_time:
					new_prog = {'id': '%s%i' % (my_id, max_time), 'class': 'object.item.epgItem.dummy', 'title': _('EPG not available'), 'description': _('EPG not available'), 'language': 'unknown', 'scheduledStartTime': '%i' % max_time, 'scheduledEndTime': '%i' % end_time, 'rating': '0'}
					resources.append(new_prog)
			else:
				new_prog = {'id': '%s%i' % (my_id, start_time), 'class': 'object.item.epgItem.dummy', 'title': _('EPG not available'), 'description': _('EPG not available'), 'language': 'unknown', 'scheduledStartTime': '%i' % start_time, 'scheduledEndTime': '%i' % end_time, 'rating': '0'}
				resources.append(new_prog)
		return list(WMedia2MMIObjects(resources, self.menu, self))



class CaptureChannelItem(ChannelItem):
	__doc__ = 'Capture service (AUX, line in, etc.).'
	def __init__(self, wymedia_resource, type_='capture_channel', **kw):
		ChannelItem.__init__(self, wymedia_resource, type_, **kw)

	def scrape_database(self, start_time, end_time, limit):
		return []



class ProgramItem(MediaItem):
	__doc__ = 'EPG information for a single program.'
	EXTRA_INFO_FIELDS = [('videoFormat_16_9', _('16:9')), ('videoFormatHD', _('High definition')), ('nrAudioChannels', _('Multiple audio tracks')), ('nrSubtitleTracks', _('Subtitles')), ('subtitleHardOfHearing', _('Subtitles for hearing impaired')), ('audioHardOfHearing', _('Audio for hearing impaired')), ('audioVisuallyImpaired', _('Audio for visually impaired')), ('freeCaMode', _('Scrambled'))]
	_CONTENT_DESC_MAPPING = UnicodeDict({0: 'Undefined content', 16: 'Movie/Drama', 17: 'Detective/Thriller', 18: 'Adventure/Western/War', 19: 'Science fiction/Fantasy/Horror', 20: 'Comedy', 21: 'Soap/Melodrama/Folkloric', 22: 'Romance', 23: 'Serious/Classical/Religious/Historical movie/drama', 24: 'Adult movie/drama', 31: 'User defined', 32: 'News/Current affairs', 33: 'News/Weather report', 34: 'News magazine', 35: 'Documentary', 36: 'Discussion/Interview/Debate', 47: 'User defined', 48: 'Show/Game show', 49: 'Game show/Quiz/Contest', 50: 'Variety show', 51: 'Talk show', 63: 'User defined', 64: 'Sports', 65: 'Special Events (Olympic games, World cup...)', 66: 'Sports magazine', 67: 'Football/Soccer', 68: 'Tennis/Squash', 69: 'Team sports (other than football)', 70: 'Athletics', 71: 'Motor sports', 72: 'Water sports', 73: 'Winter sports', 74: 'Equestrian sports', 75: 'Martial arts', 79: 'User defined', 80: "Children's/Youth program", 81: "Pre-school children's program", 82: 'Entertainment program (6 to 14 years old)', 83: 'Entertainment program (10 to 16 years old)', 84: 'Informational/Educational/School program', 85: 'Cartoon/Puppet show', 95: 'User defined', 96: 'Music/Ballet/Dance', 97: 'Rock/Pop', 98: 'Serious/Classical music', 99: 'Folk/Traditional music', 100: 'Jazz', 101: 'Musical/Opera', 102: 'Ballet', 111: 'User defined', 112: 'Arts/Culture (other than music)', 113: 'Performing arts', 114: 'Fine arts', 115: 'Religion', 116: 'Popular culture/Traditional arts', 117: 'Literature', 118: 'Film/Cinema', 119: 'Experimental film/video', 120: 'Broadcasting/Press', 121: 'New media', 122: 'Arts/Culture magazine', 123: 'Fashion', 127: 'User defined', 128: 'Social/political issues/Economics', 129: 'Magazine/Report/Documentary', 130: 'Economics/Social advisory', 131: 'Remarkable people', 143: 'User defined', 144: 'Education/Science/Factual topic', 145: 'Nature/Animals/Environment', 146: 'Technology/Natural sciences', 147: 'Medicine/Physiology/Psychology', 148: 'Foreign countries/Expeditions', 149: 'Social/Spiritual sciences', 150: 'Further education', 151: 'Languages', 159: 'User defined', 160: 'Leisure hobby', 161: 'Tourism/Travel', 162: 'Handicraft', 163: 'Motoring', 164: 'Fitness and health', 165: 'Cooking', 166: 'Advertisement/Shopping', 167: 'Gardening', 175: 'User defined'})
	_SPECIAL_ATTRIBUTES_MAPPING = UnicodeDict({176: 'Original language', 177: 'Black and white', 178: 'Unpublished', 179: 'Live broadcast', 191: 'User defined', 255: 'User defined'})
	def unwatch(self, observer):
		return None

	def watch(self, observer):
		return None

	def __init__(self, wymedia_resource, type_='epg', **kw):
		self.id = wymedia_resource['id']
		if self.recording_status in RECS_TO_DISPLAY:
			type_ += '_recording'
		MediaItem.__init__(self, wymedia_resource, type_=type_, **kw)
		self.start_time = int(wymedia_resource['scheduledStartTime'])
		self.end_time = int(wymedia_resource['scheduledEndTime'])
		self.duration, wymedia_resource['duration'] = self.end_time - self.start_time, self.end_time - self.start_time
		self.description = wymedia_resource.get('longDescription', '')
		self.short_description = wymedia_resource.get('description', '')
		desc_code = int(wymedia_resource.get('contentDesc', 0))
		self.content_type = self._CONTENT_DESC_MAPPING.get(desc_code, 'Undefined content')
		try:
			rating = int(wymedia_resource['maturityRating'])
		except KeyError:
			rating = int(wymedia_resource.get('rating', '0'))
		if rating < 10:
			maturity_rating = '0'
		else:
			if rating == 10:
				maturity_rating = '10'
			else:
				if 10 < rating:
					pass
				else:
					rating
				if 10 < rating:
					maturity_rating = '12'
				else:
					if 12 < rating:
						pass
					else:
						rating
					if 12 < rating:
						maturity_rating = '16'
					else:
						maturity_rating = '18'
		self.wymedia_resource['maturityRating'] = maturity_rating

	recording_id = property()
	recording_status = property()
	def execute(self):
		self.parent.execute()



class AllChannelsList(DirItem):
	__doc__ = "All Channels list. It's basically a read-only playlist with a minimal interface.\n    "
	def __init__(self, wymedia_resource, menu):
		DirItem.__init__(self, wymedia_resource, type_='all_channels_list', menu=menu, parent=TVRootItem())

	def get_channel_from_service_id(self, service_id):
		res = container_search(self.wymedia_resource, 'serviceId', str(service_id))
		if not res:
			raise KeyError('AllChannelsList.get_channel_from_service_id: no such service ID', service_id)
		if len(res) > 1:
			log.warn('Wymedia knows more than 1 channel with that service ID.')
		return get_mmi_object(res[0], self.menu, self)

	name = property()
	def browse(self, include_aux=True):
		if include_aux:
			filter = None
		else:
			filter = {'class': 'object.item.videoItem.videoBroadcast'}
		return WindowedItemList(self, menu=self.menu, universe=self.universe, sort_order=['logical_channel_number'], filter=filter)



class RecordingsRootItem(DirItem):
	__doc__ = 'The root container for TV recordings.'
	def __init__(self, menu):
		DirItem.__init__(self, get_root('recordings'), menu=menu, type_='video_dir')

	universe = property()


class TVRootItem(MediaItem, GenericContainer):
	__metaclass__ = MetaSingleton
	def __init__(self, menu=None):
		RootItem()
		MediaItem.__init__(self, _('TV Universe'), type_='tv_root', menu=menu)

	def browse(self, source='acl', menu=None):
		dispatch = {'acl': self.browse_acl, 'favorites': self.browse_favorites, 'recordings': self.browse_recordings}
		if not menu:
			pass
		return dispatch[source](menu)

	def show_menu(self):
		pygui_globs['menustack'].back_one_menu()

	def get_acl(self, menu=None):
		res = get_root('channel')
		res['title'] = u'all_channels_list'
		if not menu:
			pass
		return AllChannelsList(res, menu)

	def browse_acl(self, menu=None):
		return [self.get_acl(menu)]

	def get_favorites_root(self, menu=None):
		return HiddenRoot().get_child(TV_FAVORITES_FOLDER, menu)

	def browse_favorites(self, menu=None):
		return self.get_favorites_root(menu).browse()

	def get_recordings(self, menu=None):
		if not menu:
			pass
		return RecordingsRootItem(menu)

	def browse_recordings(self, menu=None):
		return self.get_recordings(menu).browse()



]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb773322c>}
from __future__ import absolute_import
from wymedia.wmplus import get_root, browse_ng, container_search
from peewee.debug import GET_LOGGER
from peewee.misc_utils import MetaSingleton
from ..containers import GenericContainer
from .core import MediaItem, DirItem, RootItem, HiddenRoot, TV_FAVORITES_FOLDER
from .core import get_mmi_object, WMedia2MMIObjects
from .progressive_result import WindowedItemList
from pygui.config import user_config, plugins
from pygui.facilities.codemapping import country_dict
from pygui.facilities.l10n import UnicodeDict
from pygui.shared import pygui_globs
if 'tv' in plugins:
	from wyrecord import WyRecord
	from wyrecord.recording import RECORDING_STATUS_UNKNOWN, RECORDING_STATUS_SCHEDULED, RECORDING_STATUS_RUNNING
	RECS_TO_DISPLAY = frozenset([RECORDING_STATUS_SCHEDULED, RECORDING_STATUS_RUNNING])
log = GET_LOGGER(__name__)
class ChannelItem(MediaItem):
	__doc__ = 'Generic TV channel item.'
	player = None
	def unwatch(self, observer):
		return None

	def watch(self, observer):
		return None

	def __init__(self, wymedia_resource, type_='channel', **kw):
		service_id = int(wymedia_resource['serviceId'])
		live = WyRecord().live_manager._GetLiveFromServiceID(service_id)
		if live and live.isRecording():
			type_ += '_recording'
		MediaItem.__init__(self, wymedia_resource, type_=type_, **kw)
		if ChannelItem.player is None:
			try:
				from pygui.menu.players import TVPlayer
				from pygui.menu.players.core import wyplayer_instance
				ChannelItem.player = TVPlayer(player=wyplayer_instance(), type='tvplayer')
			except Exception, e:
				log.error('Unable to spawn TV player: %s', str(e))
		return None

	def _get_dt(self):
		return self.wymedia_resource['logical_channel_number']

	def _set_dt(self, dt):
		pass

	def execute(self):
		self.player.play(item=self, favorite=self.parent)

	def scrape_database(self, start_time, end_time, limit):
		options = {'universe': 'tv', 'serviceId': self.wymedia_resource['serviceId'], 'scheduledStartTime': str(int(start_time)), 'scheduledEndTime': str(int(end_time))}
		if not browse_ng(get_root('epg'), 0, limit, ['+scheduledStartTime'], options):
			pass
		return browse_ng(get_root('epg'), 0, limit, ['+scheduledStartTime'], options)

	def browse(self, start_time=0, end_time=2147483640, limit=10, pad=False, focus=0):
		if focus:
			pass
		l = limit
		raw_resources = self.scrape_database(start_time, end_time, l)
		if focus < (start_time + end_time) / 2:
			resources = raw_resources[:limit]
		else:
			resources = raw_resources[-limit:]
		if pad:
			my_id = self['id']
			if resources:
				min_time = int(resources[0]['scheduledStartTime'])
				max_time = int(resources[-1]['scheduledEndTime'])
				if start_time < min_time:
					new_prog = {'id': '%s%i' % (my_id, start_time), 'class': 'object.item.epgItem.dummy', 'title': _('EPG not available'), 'description': _('EPG not available'), 'language': 'unknown', 'scheduledStartTime': '%i' % start_time, 'scheduledEndTime': '%i' % min_time, 'rating': '0'}
					resources.insert(0, new_prog)
				if max_time < end_time:
					new_prog = {'id': '%s%i' % (my_id, max_time), 'class': 'object.item.epgItem.dummy', 'title': _('EPG not available'), 'description': _('EPG not available'), 'language': 'unknown', 'scheduledStartTime': '%i' % max_time, 'scheduledEndTime': '%i' % end_time, 'rating': '0'}
					resources.append(new_prog)
			else:
				new_prog = {'id': '%s%i' % (my_id, start_time), 'class': 'object.item.epgItem.dummy', 'title': _('EPG not available'), 'description': _('EPG not available'), 'language': 'unknown', 'scheduledStartTime': '%i' % start_time, 'scheduledEndTime': '%i' % end_time, 'rating': '0'}
				resources.append(new_prog)
		return list(WMedia2MMIObjects(resources, self.menu, self))



class CaptureChannelItem(ChannelItem):
	__doc__ = 'Capture service (AUX, line in, etc.).'
	def __init__(self, wymedia_resource, type_='capture_channel', **kw):
		ChannelItem.__init__(self, wymedia_resource, type_, **kw)

	def scrape_database(self, start_time, end_time, limit):
		return []



class ProgramItem(MediaItem):
	__doc__ = 'EPG information for a single program.'
	EXTRA_INFO_FIELDS = [('videoFormat_16_9', _('16:9')), ('videoFormatHD', _('High definition')), ('nrAudioChannels', _('Multiple audio tracks')), ('nrSubtitleTracks', _('Subtitles')), ('subtitleHardOfHearing', _('Subtitles for hearing impaired')), ('audioHardOfHearing', _('Audio for hearing impaired')), ('audioVisuallyImpaired', _('Audio for visually impaired')), ('freeCaMode', _('Scrambled'))]
	_CONTENT_DESC_MAPPING = UnicodeDict({0: 'Undefined content', 16: 'Movie/Drama', 17: 'Detective/Thriller', 18: 'Adventure/Western/War', 19: 'Science fiction/Fantasy/Horror', 20: 'Comedy', 21: 'Soap/Melodrama/Folkloric', 22: 'Romance', 23: 'Serious/Classical/Religious/Historical movie/drama', 24: 'Adult movie/drama', 31: 'User defined', 32: 'News/Current affairs', 33: 'News/Weather report', 34: 'News magazine', 35: 'Documentary', 36: 'Discussion/Interview/Debate', 47: 'User defined', 48: 'Show/Game show', 49: 'Game show/Quiz/Contest', 50: 'Variety show', 51: 'Talk show', 63: 'User defined', 64: 'Sports', 65: 'Special Events (Olympic games, World cup...)', 66: 'Sports magazine', 67: 'Football/Soccer', 68: 'Tennis/Squash', 69: 'Team sports (other than football)', 70: 'Athletics', 71: 'Motor sports', 72: 'Water sports', 73: 'Winter sports', 74: 'Equestrian sports', 75: 'Martial arts', 79: 'User defined', 80: "Children's/Youth program", 81: "Pre-school children's program", 82: 'Entertainment program (6 to 14 years old)', 83: 'Entertainment program (10 to 16 years old)', 84: 'Informational/Educational/School program', 85: 'Cartoon/Puppet show', 95: 'User defined', 96: 'Music/Ballet/Dance', 97: 'Rock/Pop', 98: 'Serious/Classical music', 99: 'Folk/Traditional music', 100: 'Jazz', 101: 'Musical/Opera', 102: 'Ballet', 111: 'User defined', 112: 'Arts/Culture (other than music)', 113: 'Performing arts', 114: 'Fine arts', 115: 'Religion', 116: 'Popular culture/Traditional arts', 117: 'Literature', 118: 'Film/Cinema', 119: 'Experimental film/video', 120: 'Broadcasting/Press', 121: 'New media', 122: 'Arts/Culture magazine', 123: 'Fashion', 127: 'User defined', 128: 'Social/political issues/Economics', 129: 'Magazine/Report/Documentary', 130: 'Economics/Social advisory', 131: 'Remarkable people', 143: 'User defined', 144: 'Education/Science/Factual topic', 145: 'Nature/Animals/Environment', 146: 'Technology/Natural sciences', 147: 'Medicine/Physiology/Psychology', 148: 'Foreign countries/Expeditions', 149: 'Social/Spiritual sciences', 150: 'Further education', 151: 'Languages', 159: 'User defined', 160: 'Leisure hobby', 161: 'Tourism/Travel', 162: 'Handicraft', 163: 'Motoring', 164: 'Fitness and health', 165: 'Cooking', 166: 'Advertisement/Shopping', 167: 'Gardening', 175: 'User defined'})
	_SPECIAL_ATTRIBUTES_MAPPING = UnicodeDict({176: 'Original language', 177: 'Black and white', 178: 'Unpublished', 179: 'Live broadcast', 191: 'User defined', 255: 'User defined'})
	def unwatch(self, observer):
		return None

	def watch(self, observer):
		return None

	def __init__(self, wymedia_resource, type_='epg', **kw):
		self.id = wymedia_resource['id']
		if self.recording_status in RECS_TO_DISPLAY:
			type_ += '_recording'
		MediaItem.__init__(self, wymedia_resource, type_=type_, **kw)
		self.start_time = int(wymedia_resource['scheduledStartTime'])
		self.end_time = int(wymedia_resource['scheduledEndTime'])
		self.duration, wymedia_resource['duration'] = self.end_time - self.start_time, self.end_time - self.start_time
		self.description = wymedia_resource.get('longDescription', '')
		self.short_description = wymedia_resource.get('description', '')
		desc_code = int(wymedia_resource.get('contentDesc', 0))
		self.content_type = self._CONTENT_DESC_MAPPING.get(desc_code, 'Undefined content')
		try:
			rating = int(wymedia_resource['maturityRating'])
		except KeyError:
			rating = int(wymedia_resource.get('rating', '0'))
		if rating < 10:
			maturity_rating = '0'
		else:
			if rating == 10:
				maturity_rating = '10'
			else:
				if 10 < rating:
					pass
				else:
					rating
				if 10 < rating:
					maturity_rating = '12'
				else:
					if 12 < rating:
						pass
					else:
						rating
					if 12 < rating:
						maturity_rating = '16'
					else:
						maturity_rating = '18'
		self.wymedia_resource['maturityRating'] = maturity_rating

	recording_id = property()
	recording_status = property()
	def execute(self):
		self.parent.execute()



class AllChannelsList(DirItem):
	__doc__ = "All Channels list. It's basically a read-only playlist with a minimal interface.\n    "
	def __init__(self, wymedia_resource, menu):
		DirItem.__init__(self, wymedia_resource, type_='all_channels_list', menu=menu, parent=TVRootItem())

	def get_channel_from_service_id(self, service_id):
		res = container_search(self.wymedia_resource, 'serviceId', str(service_id))
		if not res:
			raise KeyError('AllChannelsList.get_channel_from_service_id: no such service ID', service_id)
		if len(res) > 1:
			log.warn('Wymedia knows more than 1 channel with that service ID.')
		return get_mmi_object(res[0], self.menu, self)

	name = property()
	def browse(self, include_aux=True):
		if include_aux:
			filter = None
		else:
			filter = {'class': 'object.item.videoItem.videoBroadcast'}
		return WindowedItemList(self, menu=self.menu, universe=self.universe, sort_order=['logical_channel_number'], filter=filter)



class RecordingsRootItem(DirItem):
	__doc__ = 'The root container for TV recordings.'
	def __init__(self, menu):
		DirItem.__init__(self, get_root('recordings'), menu=menu, type_='video_dir')

	universe = property()


class TVRootItem(MediaItem, GenericContainer):
	__metaclass__ = MetaSingleton
	def __init__(self, menu=None):
		RootItem()
		MediaItem.__init__(self, _('TV Universe'), type_='tv_root', menu=menu)

	def browse(self, source='acl', menu=None):
		dispatch = {'acl': self.browse_acl, 'favorites': self.browse_favorites, 'recordings': self.browse_recordings}
		if not menu:
			pass
		return dispatch[source](menu)

	def show_menu(self):
		pygui_globs['menustack'].back_one_menu()

	def get_acl(self, menu=None):
		res = get_root('channel')
		res['title'] = u'all_channels_list'
		if not menu:
			pass
		return AllChannelsList(res, menu)

	def browse_acl(self, menu=None):
		return [self.get_acl(menu)]

	def get_favorites_root(self, menu=None):
		return HiddenRoot().get_child(TV_FAVORITES_FOLDER, menu)

	def browse_favorites(self, menu=None):
		return self.get_favorites_root(menu).browse()

	def get_recordings(self, menu=None):
		if not menu:
			pass
		return RecordingsRootItem(menu)

	def browse_recordings(self, menu=None):
		return self.get_recordings(menu).browse()



