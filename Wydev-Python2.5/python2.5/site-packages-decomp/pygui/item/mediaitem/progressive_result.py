# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 253
n 253(None)[self._browse_options.update(filter)
self._update_browse_options()
self._range = Range(0, 0)
self._cached = []
self._owners = set()
self._fill_cache(Range(0, 11))
return None
]:
	i: 234(t), 249()
	o: 

nname: 249
n 249(None)[]:
	i: 234(f)
	o: 253()

nname: 234
n 234(filter)[]:
	i: 202(), 215()
	o: 249(f), 253(t)

nname: 215
n 215(None)[self._browse_options = dict(universe=universe)
]:
	i: 190(f)
	o: 234()

nname: 202
n 202(None)[self._browse_options = {}
]:
	i: 190(t)
	o: 234()

nname: 190
n 190(universe == 'multiverse')[]:
	i: 115(JA), 140(), 165()
	o: 202(t), 215(f)

nname: 165
n 165(None)[self._browse_fn = functools.partial(browse_ng, source_item.wymedia_resource)
]:
	i: 66(f)
	o: 190()

nname: 140
n 140(None)[self._browse_fn = functools.partial(browse_fn, source_item)
]:
	i: 102(f)
	o: 190()

nname: 115
n 115(None)[self._browse_fn = functools.partial(browse_fn, pattern)
]:
	i: 102(t)
	o: 190(JA)

nname: 102
n 102(pattern is not None)[]:
	i: 66(t)
	o: 115(t), 140(f)

nname: 66
n 66(browse_fn is not None)[self._sort = sort_order
self._pattern = pattern
self.end_reached = False
]:
	i: 53(t), 62()
	o: 102(t), 165(f)

nname: 62
n 62(None)[]:
	i: 53(f)
	o: 66()

nname: 53
n 53(sort_order)[universe = universe
]:
	i: 31(t), 43()
	o: 62(f), 66(t)

nname: 43
n 43(None)[]:
	i: 31(f)
	o: 53()

nname: 31
n 31(universe)[self.menu = menu
]:
	i: 0(t), 24()
	o: 43(f), 53(t)

nname: 24
n 24(None)[]:
	i: 0(f)
	o: 31()

nname: 0
n 0(menu)[self._length = 0
self._si = source_item
]:
	i: 
	o: 24(f), 31(t)

nname: 253
n 253(None)[self._browse_options.update(filter)
self._update_browse_options()
self._range = Range(0, 0)
self._cached = []
self._owners = set()
self._fill_cache(Range(0, 11))
return None
]:
	i: 190(t)
	o: 

nname: 190
n 190(None)[if universe == 'multiverse':
	self._browse_options = {}
else:
	self._browse_options = dict(universe=universe)
if not filter:
	pass
]:
	i: 53(JA)
	o: 253()

nname: 53
n 53(None)[universe = universe
if not sort_order:
	pass
self._sort = sort_order
self._pattern = pattern
self.end_reached = False
if browse_fn is not None:
	if pattern is not None:
		self._browse_fn = functools.partial(browse_fn, pattern)
	else:
		self._browse_fn = functools.partial(browse_fn, source_item)
else:
	self._browse_fn = functools.partial(browse_ng, source_item.wymedia_resource)
]:
	i: 0(t)
	o: 190(JA)

nname: 0
n 0(None)[self._length = 0
self._si = source_item
if not menu:
	pass
self.menu = menu
if not universe:
	pass
]:
	i: 
	o: 53()

nname: 190
n 190(None)[if universe == 'multiverse':
	self._browse_options = {}
else:
	self._browse_options = dict(universe=universe)
if not filter:
	pass
self._browse_options.update(filter)
self._update_browse_options()
self._range = Range(0, 0)
self._cached = []
self._owners = set()
self._fill_cache(Range(0, 11))
return None
]:
	i: 0(JA)
	o: 

nname: 0
n 0(None)[self._length = 0
self._si = source_item
if not menu:
	pass
self.menu = menu
if not universe:
	pass
universe = universe
if not sort_order:
	pass
self._sort = sort_order
self._pattern = pattern
self.end_reached = False
if browse_fn is not None:
	if pattern is not None:
		self._browse_fn = functools.partial(browse_fn, pattern)
	else:
		self._browse_fn = functools.partial(browse_fn, source_item)
else:
	self._browse_fn = functools.partial(browse_ng, source_item.wymedia_resource)
]:
	i: 
	o: 190(JA)

nname: 0
n 0(None)[self._length = 0
self._si = source_item
if not menu:
	pass
self.menu = menu
if not universe:
	pass
universe = universe
if not sort_order:
	pass
self._sort = sort_order
self._pattern = pattern
self.end_reached = False
if browse_fn is not None:
	if pattern is not None:
		self._browse_fn = functools.partial(browse_fn, pattern)
	else:
		self._browse_fn = functools.partial(browse_fn, source_item)
else:
	self._browse_fn = functools.partial(browse_ng, source_item.wymedia_resource)
if universe == 'multiverse':
	self._browse_options = {}
else:
	self._browse_options = dict(universe=universe)
if not filter:
	pass
self._browse_options.update(filter)
self._update_browse_options()
self._range = Range(0, 0)
self._cached = []
self._owners = set()
self._fill_cache(Range(0, 11))
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9f0662c>}
nname: 0
n 0(None)[self._owners.remove(who)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9f0446c>}
nname: 96
n 96(None)[]:
	i: 0(AL), 95()
	o: 

nname: 95
n 95(None)[]:
	i: 37(AF), 83()
	o: 96()

nname: 83
n 83(None)[del _[1]
for item.list_owned in ow:
]:
	i: 47(AF), 64()
	o: 95()

nname: 64
n 64(None)[for elt in ow:
]:
	i: 47(for)
	o: 83()

nname: 47
n 47(None)[for item in self._cached:
]:
	i: 37(for)
	o: 64(for), 83(AF)

nname: 37
n 37(None)[]:
	i: 0(loop)
	o: 47(for), 95(AF)

nname: 0
n 0(None)[ow = self._owners
ow.add(ref(who, self._owner_removed))
]:
	i: 
	o: 37(loop), 96(AL)

nname: 96
n 96(None)[]:
	i: 0(AL), 37(AF), 83()
	o: 

nname: 83
n 83(None)[del _[1]
for item.list_owned in ow:
]:
	i: 47(AF), 64()
	o: 96()

nname: 64
n 64(None)[for elt in ow:
]:
	i: 47(for)
	o: 83()

nname: 47
n 47(None)[for item in self._cached:
]:
	i: 37(for)
	o: 64(for), 83(AF)

nname: 37
n 37(None)[]:
	i: 0(loop)
	o: 47(for), 96(AF)

nname: 0
n 0(None)[ow = self._owners
ow.add(ref(who, self._owner_removed))
]:
	i: 
	o: 37(loop), 96(AL)

self.nodes: {0: <unpyclib.structure.node instance at 0x9f04bec>, 64: <unpyclib.structure.node instance at 0x9f047ec>, 37: <unpyclib.structure.node instance at 0x9f0476c>, 96: <unpyclib.structure.node instance at 0x9f048ac>, 47: <unpyclib.structure.node instance at 0x9f047ac>, 83: <unpyclib.structure.node instance at 0x9f0482c>}
nname: 0
n 0(None)[return iter(self._cached)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9f0434c>}
nname: 32
n 32(None)[name = self._pattern
return '<WIL(%s)%s of len %d> %s' % (name, self._range, len(self), self._cached)
]:
	i: 15(), 25()
	o: 

nname: 25
n 25(None)[]:
	i: 0(f)
	o: 32()

nname: 15
n 15(None)[]:
	i: 0(t)
	o: 32()

nname: 0
n 0(self._si is not None)[]:
	i: 
	o: 15(t), 25(f)

nname: 0
n 0(None)[if self._si is not None:
	pass
name = self._pattern
return '<WIL(%s)%s of len %d> %s' % (name, self._range, len(self), self._cached)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9f045ec>}
nname: 62
n 62(None)[]:
	i: 0(AL), 61()
	o: 

nname: 61
n 61(None)[]:
	i: 3(AF), 58()
	o: 62()

nname: 58
n 58(None)[]:
	i: 56(AE)
	o: 61()

nname: 56
n 56(None)[]:
	i: 39(f), 49()
	o: 58(AE)

nname: 49
n 49(None)[continue
]:
	i: 39(t)
	o: 56()

nname: 39
n 39(<dummy_ex3> EXC_MATCH ValueError)[]:
	i: 13(except), 19()
	o: 49(t), 56(f)

nname: 19
n 19(None)[it.list_owned.remove(list_name)
continue
]:
	i: 13(try)
	o: 39()

nname: 13
n 13(None)[for it in self._cached:
]:
	i: 3(for)
	o: 19(try), 39(except)

nname: 3
n 3(None)[]:
	i: 0(loop)
	o: 13(for), 61(AF)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 62(AL)

nname: 62
n 62(None)[]:
	i: 0(AL), 3(AF), 39(AE)
	o: 

nname: 39
n 39(None)[except ValueError:
	continue
]:
	i: 13()
	o: 62(AE)

nname: 13
n 13(None)[for it in self._cached:
try:
	it.list_owned.remove(list_name)
	continue
]:
	i: 3(for)
	o: 39()

nname: 3
n 3(None)[]:
	i: 0(loop)
	o: 13(for), 62(AF)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 62(AL)

nname: 62
n 62(None)[]:
	i: 0(AL), 3(AF), 13(AE)
	o: 

nname: 13
n 13(None)[for it in self._cached:
try:
	it.list_owned.remove(list_name)
	continue
except ValueError:
	continue
]:
	i: 3(for)
	o: 62(AE)

nname: 3
n 3(None)[]:
	i: 0(loop)
	o: 13(for), 62(AF)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 62(AL)

nname: 62
n 62(None)[]:
	i: 13(AE)
	o: 

nname: 13
n 13(None)[for it in self._cached:
	try:
		it.list_owned.remove(list_name)
		continue
	except ValueError:
		continue
]:
	i: 0(for)
	o: 62(AE)

nname: 0
n 0(None)[]:
	i: 
	o: 13(for)

nname: 62
n 62(None)[]:
	i: 0(AE)
	o: 

nname: 0
n 0(None)[for it in self._cached:
	try:
		it.list_owned.remove(list_name)
		continue
	except ValueError:
		continue
]:
	i: 
	o: 62(AE)

self.nodes: {0: <unpyclib.structure.node instance at 0x9f04f6c>, 62: <unpyclib.structure.node instance at 0x9f0460c>}
nname: 420
n 420(None)[]:
	i: 224(), 389(), 418(AE)
	o: 

nname: 418
n 418(None)[]:
	i: 254(f)
	o: 420(AE)

nname: 389
n 389(None)[return self._cached.index(wmedia_elt) + self._range.start
]:
	i: 277(), 315(), 368(), 387(AE)
	o: 420()

nname: 387
n 387(None)[]:
	i: 357(f)
	o: 389(AE)

nname: 368
n 368(None)[#, e
PRINT_EXCEPTION(e)
]:
	i: 357(t)
	o: 389()

nname: 357
n 357(<dummy_ex3> EXC_MATCH Exception)[]:
	i: 305(f)
	o: 368(t), 387(f)

nname: 315
n 315(None)[log.debug('No index attribute. Fetching it from the DB.')
return get_browse_position(wmedia_elt, self._sort, self._browse_options)
]:
	i: 305(t)
	o: 389()

nname: 305
n 305(<dummy_ex3> EXC_MATCH KeyError)[]:
	i: 270(except)
	o: 315(t), 357(f)

nname: 277
n 277(None)[idx = int(wmedia_elt['index'])
self[idx]
]:
	i: 270(try)
	o: 389()

nname: 270
n 270(None)[]:
	i: 254(t)
	o: 277(try), 305(except)

nname: 254
n 254(<dummy_ex3> EXC_MATCH (ValueError, IndexError))[]:
	i: 221(except)
	o: 270(t), 418(f)

nname: 224
n 224(None)[return self._cached.index(wmedia_elt) + self._range.start
]:
	i: 221(try)
	o: 420()

nname: 221
n 221(None)[]:
	i: 52(JA), 136(JA), 208(), 211()
	o: 224(try), 254(except)

nname: 211
n 211(None)[wmedia_elt = elt.wymedia_resource
]:
	i: 0&18(f)
	o: 221()

nname: 208
n 208(None)[]:
	i: 206(AE)
	o: 221()

nname: 206
n 206(None)[]:
	i: 126(f)
	o: 208(AE)

nname: 136
n 136(None)[log.error('container_search(%s, "refid", %s) ->  []', self._si.wymedia_resource, elt.wymedia_resource.get('refid', elt.wymedia_resource['id']))
wmedia_elt = elt.wymedia_resource
PRINT_EXCEPTION()
]:
	i: 126(t)
	o: 221(JA)

nname: 126
n 126(<dummy_ex3> EXC_MATCH IndexError)[]:
	i: 48(except)
	o: 136(t), 206(f)

nname: 52
n 52(None)[idx = int(container_search(self._si.wymedia_resource, 'refid', elt.wymedia_resource.get('refid', elt.wymedia_resource['id']))[0]['rank'])
return int(idx)
]:
	i: 48(try)
	o: 221(JA)

nname: 48
n 48(None)[]:
	i: 0&18(t)
	o: 52(try), 126(except)

nname: 0&18
n 0&18(isinstance(self._si, Playlist) and self._si.wymedia_resource['id'] != elt.wymedia_resource['parentid'])[]:
	i: 
	o: 48(t), 211(f)

nname: 420
n 420(None)[]:
	i: 224(), 389(), 418(AE)
	o: 

nname: 389
n 389(None)[return self._cached.index(wmedia_elt) + self._range.start
]:
	i: 277()
	o: 420()

nname: 277
n 277(None)[try:
	idx = int(wmedia_elt['index'])
	self[idx]
except KeyError:
	log.debug('No index attribute. Fetching it from the DB.')
	return get_browse_position(wmedia_elt, self._sort, self._browse_options)
except:
	except Exception, e:
		PRINT_EXCEPTION(e)
]:
	i: 254(f), 254(t)
	o: 389()

nname: 254
n 254(<dummy_ex3> EXC_MATCH (ValueError, IndexError))[]:
	i: 221(except)
	o: 277(f)

nname: 224
n 224(None)[return self._cached.index(wmedia_elt) + self._range.start
]:
	i: 221(try)
	o: 420()

nname: 221
n 221(None)[]:
	i: 52(JA), 136(JA), 211(), 126(f), 206(AE)
	o: 224(try), 254(except)

structureSingleExcept Exception 'NoneType' object has no attribute 'toNode'
nname: 211
n 211(None)[wmedia_elt = elt.wymedia_resource
]:
	i: 0&18(f)
	o: 221()

nname: 136
n 136(None)[log.error('container_search(%s, "refid", %s) ->  []', self._si.wymedia_resource, elt.wymedia_resource.get('refid', elt.wymedia_resource['id']))
wmedia_elt = elt.wymedia_resource
PRINT_EXCEPTION()
]:
	i: 126(t)
	o: 221(JA)

nname: 126
n 126(<dummy_ex3> EXC_MATCH IndexError)[]:
	i: 48(except)
	o: 136(t), 221(f)

nname: 52
n 52(None)[idx = int(container_search(self._si.wymedia_resource, 'refid', elt.wymedia_resource.get('refid', elt.wymedia_resource['id']))[0]['rank'])
return int(idx)
]:
	i: 48(try)
	o: 221(JA)

nname: 48
n 48(None)[]:
	i: 0&18(t)
	o: 52(try), 126(except)

nname: 0&18
n 0&18(isinstance(self._si, Playlist) and self._si.wymedia_resource['id'] != elt.wymedia_resource['parentid'])[]:
	i: 
	o: 48(t), 211(f)

nname: 420
n 420(None)[]:
	i: 224(), 277(), 418(AE)
	o: 

nname: 277
n 277(None)[try:
	idx = int(wmedia_elt['index'])
	self[idx]
except KeyError:
	log.debug('No index attribute. Fetching it from the DB.')
	return get_browse_position(wmedia_elt, self._sort, self._browse_options)
except:
	except Exception, e:
		PRINT_EXCEPTION(e)
return self._cached.index(wmedia_elt) + self._range.start
]:
	i: 254(t), 221(except)
	o: 420()

nname: 224
n 224(None)[return self._cached.index(wmedia_elt) + self._range.start
]:
	i: 221(try)
	o: 420()

nname: 221
n 221(None)[]:
	i: 211(), 126(f)
	o: 224(try), 277(except)

nname: 211
n 211(None)[wmedia_elt = elt.wymedia_resource
]:
	i: 0&18(f)
	o: 221()

nname: 126
n 126(None)[except IndexError:
	log.error('container_search(%s, "refid", %s) ->  []', self._si.wymedia_resource, elt.wymedia_resource.get('refid', elt.wymedia_resource['id']))
	wmedia_elt = elt.wymedia_resource
	PRINT_EXCEPTION()
]:
	i: 48()
	o: 221(JA)

nname: 48
n 48(None)[try:
	idx = int(container_search(self._si.wymedia_resource, 'refid', elt.wymedia_resource.get('refid', elt.wymedia_resource['id']))[0]['rank'])
	return int(idx)
]:
	i: 0&18(t)
	o: 126()

nname: 0&18
n 0&18(isinstance(self._si, Playlist) and self._si.wymedia_resource['id'] != elt.wymedia_resource['parentid'])[]:
	i: 
	o: 48(t), 211(f)

nname: 277
n 277(None)[except:
	try:
		idx = int(wmedia_elt['index'])
		self[idx]
	except KeyError:
		log.debug('No index attribute. Fetching it from the DB.')
		return get_browse_position(wmedia_elt, self._sort, self._browse_options)
	except:
		except Exception, e:
			PRINT_EXCEPTION(e)
	return self._cached.index(wmedia_elt) + self._range.start
]:
	i: 254(t), 221()
	o: 

nname: 221
n 221(None)[try:
	return self._cached.index(wmedia_elt) + self._range.start
]:
	i: 211(), 48(f)
	o: 277()

nname: 211
n 211(None)[wmedia_elt = elt.wymedia_resource
]:
	i: 0&18(f)
	o: 221()

nname: 48
n 48(None)[try:
	idx = int(container_search(self._si.wymedia_resource, 'refid', elt.wymedia_resource.get('refid', elt.wymedia_resource['id']))[0]['rank'])
	return int(idx)
except IndexError:
	log.error('container_search(%s, "refid", %s) ->  []', self._si.wymedia_resource, elt.wymedia_resource.get('refid', elt.wymedia_resource['id']))
	wmedia_elt = elt.wymedia_resource
	PRINT_EXCEPTION()
]:
	i: 0&18(t)
	o: 221(JA)

nname: 0&18
n 0&18(isinstance(self._si, Playlist) and self._si.wymedia_resource['id'] != elt.wymedia_resource['parentid'])[]:
	i: 
	o: 48(t), 211(f)

nname: 277
n 277(None)[except:
	try:
		idx = int(wmedia_elt['index'])
		self[idx]
	except KeyError:
		log.debug('No index attribute. Fetching it from the DB.')
		return get_browse_position(wmedia_elt, self._sort, self._browse_options)
	except:
		except Exception, e:
			PRINT_EXCEPTION(e)
	return self._cached.index(wmedia_elt) + self._range.start
]:
	i: 254(t), 0&18()
	o: 

nname: 0&18
n 0&18(None)[if isinstance(self._si, Playlist) and self._si.wymedia_resource['id'] != elt.wymedia_resource['parentid']:
	try:
		idx = int(container_search(self._si.wymedia_resource, 'refid', elt.wymedia_resource.get('refid', elt.wymedia_resource['id']))[0]['rank'])
		return int(idx)
	except IndexError:
		log.error('container_search(%s, "refid", %s) ->  []', self._si.wymedia_resource, elt.wymedia_resource.get('refid', elt.wymedia_resource['id']))
		wmedia_elt = elt.wymedia_resource
		PRINT_EXCEPTION()
else:
	wmedia_elt = elt.wymedia_resource
try:
	return self._cached.index(wmedia_elt) + self._range.start
]:
	i: 
	o: 277()

self.nodes: {277: <unpyclib.structure.node instance at 0x9f0630c>, '0&18': <unpyclib.structure.node instance at 0x9f0650c>}
nname: 71
n 71(None)[return self._length
]:
	i: 52(JA), 66(), 70()
	o: 

nname: 70
n 70(None)[]:
	i: 0(f)
	o: 71()

nname: 66
n 66(None)[]:
	i: 18(f)
	o: 71()

nname: 52
n 52(None)[return int(cc)
]:
	i: 18(t)
	o: 71(JA)

nname: 18
n 18(cc is not None)[cc = self._si.wymedia_resource.get('childCount')
]:
	i: 0(t)
	o: 52(t), 66(f)

nname: 0
n 0(hasattr(self._si, 'wymedia_resource'))[]:
	i: 
	o: 18(t), 70(f)

nname: 0
n 0(None)[if hasattr(self._si, 'wymedia_resource'):
	cc = self._si.wymedia_resource.get('childCount')
	if cc is not None:
		return int(cc)
return self._length
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9f0486c>}
nname: 171
n 171(None)[]:
	i: 94(JA), 145(), 170()
	o: 

nname: 170
n 170(None)[]:
	i: 30(f)
	o: 171()

nname: 145
n 145(None)[maturity_rating = 19
self._browse_options['maturity_rating'] = str(maturity_rating)
]:
	i: 134(), 141()
	o: 171()

nname: 141
n 141(None)[]:
	i: 119(f)
	o: 145()

nname: 134
n 134(None)[]:
	i: 119(t)
	o: 145()

nname: 119
n 119(user_config['security']['show_hidden'])[]:
	i: 60(t)
	o: 134(t), 141(f)

nname: 94
n 94(None)[maturity_rating = user_config['security']['maturity_rating']
self._browse_options['maturity_rating'] = str(maturity_rating)
]:
	i: 75(t), 90()
	o: 171(JA)

nname: 90
n 90(None)[]:
	i: 75(f)
	o: 94()

nname: 75
n 75(user_config['security']['maturity_rating'])[]:
	i: 60(f)
	o: 90(f), 94(t)

nname: 60
n 60(user_config['security']['parent_mode'])[]:
	i: 30(t)
	o: 75(f), 119(t)

nname: 30
n 30(user_config['security']['parental_control'])[from pygui.config import user_config
]:
	i: 15(), 29()
	o: 60(t), 170(f)

nname: 29
n 29(None)[]:
	i: 0(f)
	o: 30()

nname: 15
n 15(None)[del self._browse_options['maturity_rating']
]:
	i: 0(t)
	o: 30()

nname: 0
n 0('maturity_rating' in self._browse_options)[]:
	i: 
	o: 15(t), 29(f)

nname: 171
n 171(None)[]:
	i: 75(JA), 119(), 0(f)
	o: 

nname: 119
n 119(None)[if user_config['security']['show_hidden']:
	pass
maturity_rating = 19
self._browse_options['maturity_rating'] = str(maturity_rating)
]:
	i: 60(t)
	o: 171()

nname: 75
n 75(None)[if not user_config['security']['maturity_rating']:
	pass
maturity_rating = user_config['security']['maturity_rating']
self._browse_options['maturity_rating'] = str(maturity_rating)
]:
	i: 60(f)
	o: 171(JA)

nname: 60
n 60(user_config['security']['parent_mode'])[]:
	i: 0(t)
	o: 75(f), 119(t)

nname: 0
n 0(user_config['security']['parental_control'])[if 'maturity_rating' in self._browse_options:
	del self._browse_options['maturity_rating']
from pygui.config import user_config
]:
	i: 
	o: 60(t), 171(f)

nname: 0
n 0(None)[if 'maturity_rating' in self._browse_options:
	del self._browse_options['maturity_rating']
from pygui.config import user_config
if user_config['security']['parental_control']:
	if not user_config['security']['parent_mode']:
		if not user_config['security']['maturity_rating']:
			pass
		maturity_rating = user_config['security']['maturity_rating']
		self._browse_options['maturity_rating'] = str(maturity_rating)
	else:
		if user_config['security']['show_hidden']:
			pass
		maturity_rating = 19
		self._browse_options['maturity_rating'] = str(maturity_rating)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9f048ac>}
nname: 809
n 809(None)[louie_send(signal, sender=self.menu.universe, items=items)
return None
]:
	i: 736(), 768()
	o: 

nname: 768
n 768(None)[self._length = max(self._length, self._range.start + len(self._cached))
]:
	i: 712(f)
	o: 809()

nname: 736
n 736(None)[self._length = self._range.start + len(self._cached)
]:
	i: 712(t)
	o: 809()

nname: 712
n 712(self._length in fill_range)[self._range = fill_range
]:
	i: 647(AL), 711()
	o: 736(t), 768(f)

nname: 711
n 711(None)[]:
	i: 650(AF), 699()
	o: 712()

nname: 699
n 699(None)[del _[1]
for it.list_owned in self._owners:
]:
	i: 660(AF), 680()
	o: 711()

nname: 680
n 680(None)[for elt in self._owners:
]:
	i: 660(for)
	o: 699()

nname: 660
n 660(None)[for it in self._cached:
]:
	i: 650(for)
	o: 680(for), 699(AF)

nname: 650
n 650(None)[]:
	i: 647(loop)
	o: 660(for), 711(AF)

nname: 647
n 647(None)[]:
	i: 246(JA), 486(JA), 520(), 601()
	o: 650(loop), 712(AL)

nname: 601
n 601(None)[items = list(WMedia2MMIObjects(windowed_childrens, self.menu, self._si))
self._cached[:] = items
signal = 'everything'
]:
	i: 587(), 600()
	o: 647()

nname: 600
n 600(None)[]:
	i: 523(f)
	o: 601()

nname: 587
n 587(None)[_[1], self.end_reached = [], True
]:
	i: 523(t)
	o: 601()

nname: 523
n 523(len(windowed_childrens) < len(fill_range))[windowed_childrens = self._browse_fn(fill_range.start, len(fill_range), self._sort, self._browse_options)
]:
	i: 59&134(f)
	o: 587(t), 600(f)

nname: 520
n 520(None)[]:
	i: 443(JA), 519()
	o: 647()

nname: 519
n 519(None)[]:
	i: 325(f)
	o: 520()

nname: 486
n 486(None)[del self._cached[fill_range.stop:]
self._cached[0:0] = items
]:
	i: 347&411&427(f)
	o: 647(JA)

nname: 443
n 443(None)[del self._cached[fill_range.stop - self._range.start:]
self._cached[0:0] = items
]:
	i: 347&411&427(t)
	o: 520(JA)

nname: 347&411&427
n 347&411&427(fill_range.stop < my_len or fill_range.start < my_len and fill_range.stop >= my_len)[items = list(WMedia2MMIObjects(windowed_childrens, self.menu, self._si))
signal = 'scroll_up'
my_len = len(self)
]:
	i: 325(t)
	o: 443(t), 486(f)

nname: 325
n 325(delta_range.stop == self._range.start)[]:
	i: 225(f)
	o: 347&411&427(t), 519(f)

nname: 246
n 246(None)[items = list(WMedia2MMIObjects(windowed_childrens, self.menu, self._si))
del self._cached[:fill_range.start - self._range.start]
self._cached.extend(items)
signal = 'scroll_down'
]:
	i: 225(t)
	o: 647(JA)

nname: 225
n 225(delta_range.start == self._range.stop)[]:
	i: 211(), 224()
	o: 246(t), 325(f)

nname: 224
n 224(None)[]:
	i: 147(f)
	o: 225()

nname: 211
n 211(None)[self.end_reached = True
]:
	i: 147(t)
	o: 225()

nname: 147
n 147(len(windowed_childrens) < len(delta_range))[windowed_childrens = self._browse_fn(delta_range.start, len(delta_range), self._sort, self._browse_options)
]:
	i: 59&134(t)
	o: 211(t), 224(f)

nname: 59&134
n 59&134(delta_range and delta_range < fill_range)[self._update_browse_options()
signal = None
log.debug('MR: %s DR: %s FR: %s', self._range, delta_range, fill_range)
log.debug('requesting %d items starting at %d', len(fill_range), fill_range.start)
]:
	i: 45(), 58()
	o: 147(t), 523(f)

nname: 58
n 58(None)[]:
	i: 33(f)
	o: 59&134()

nname: 45
n 45(None)[fill_range = self._range
]:
	i: 33(t)
	o: 59&134()

nname: 33
n 33(fill_range is None)[]:
	i: 3(), 20(), 32(AE)
	o: 45(t), 58(f)

nname: 20
n 20(None)[delta_range = None
]:
	i: 0(except)
	o: 33()

nname: 3
n 3(None)[delta_range = fill_range - self._range
]:
	i: 0(try)
	o: 33()

nname: 0
n 0(None)[]:
	i: 
	o: 3(try), 20(except)

nname: 712
n 712(None)[self._range = fill_range
if self._length in fill_range:
	self._length = self._range.start + len(self._cached)
else:
	self._length = max(self._length, self._range.start + len(self._cached))
louie_send(signal, sender=self.menu.universe, items=items)
return None
]:
	i: 647(AL), 650(AF), 699()
	o: 

nname: 699
n 699(None)[del _[1]
for it.list_owned in self._owners:
]:
	i: 660(AF), 680()
	o: 712()

nname: 680
n 680(None)[for elt in self._owners:
]:
	i: 660(for)
	o: 699()

nname: 660
n 660(None)[for it in self._cached:
]:
	i: 650(for)
	o: 680(for), 699(AF)

nname: 650
n 650(None)[]:
	i: 647(loop)
	o: 660(for), 712(AF)

nname: 647
n 647(None)[]:
	i: 246(JA), 486(JA), 523(), 443(JA), 325(f)
	o: 650(loop), 712(AL)

nname: 523
n 523(None)[windowed_childrens = self._browse_fn(fill_range.start, len(fill_range), self._sort, self._browse_options)
if len(windowed_childrens) < len(fill_range):
	_[1], self.end_reached = [], True
items = list(WMedia2MMIObjects(windowed_childrens, self.menu, self._si))
self._cached[:] = items
signal = 'everything'
]:
	i: 59&134(f)
	o: 647()

nname: 486
n 486(None)[del self._cached[fill_range.stop:]
self._cached[0:0] = items
]:
	i: 347&411&427(f)
	o: 647(JA)

nname: 443
n 443(None)[del self._cached[fill_range.stop - self._range.start:]
self._cached[0:0] = items
]:
	i: 347&411&427(t)
	o: 647(JA)

nname: 347&411&427
n 347&411&427(fill_range.stop < my_len or fill_range.start < my_len and fill_range.stop >= my_len)[items = list(WMedia2MMIObjects(windowed_childrens, self.menu, self._si))
signal = 'scroll_up'
my_len = len(self)
]:
	i: 325(t)
	o: 443(t), 486(f)

nname: 325
n 325(delta_range.stop == self._range.start)[]:
	i: 147(f)
	o: 347&411&427(t), 647(f)

nname: 246
n 246(None)[items = list(WMedia2MMIObjects(windowed_childrens, self.menu, self._si))
del self._cached[:fill_range.start - self._range.start]
self._cached.extend(items)
signal = 'scroll_down'
]:
	i: 147(t)
	o: 647(JA)

nname: 147
n 147(delta_range.start == self._range.stop)[windowed_childrens = self._browse_fn(delta_range.start, len(delta_range), self._sort, self._browse_options)
if len(windowed_childrens) < len(delta_range):
	self.end_reached = True
]:
	i: 59&134(t)
	o: 246(t), 325(f)

nname: 59&134
n 59&134(delta_range and delta_range < fill_range)[self._update_browse_options()
signal = None
log.debug('MR: %s DR: %s FR: %s', self._range, delta_range, fill_range)
log.debug('requesting %d items starting at %d', len(fill_range), fill_range.start)
]:
	i: 20()
	o: 147(t), 523(f)

nname: 20
n 20(None)[except:
	delta_range = None
if fill_range is None:
	fill_range = self._range
]:
	i: 0()
	o: 59&134()

nname: 0
n 0(None)[try:
	delta_range = fill_range - self._range
]:
	i: 
	o: 20()

nname: 712
n 712(None)[self._range = fill_range
if self._length in fill_range:
	self._length = self._range.start + len(self._cached)
else:
	self._length = max(self._length, self._range.start + len(self._cached))
louie_send(signal, sender=self.menu.universe, items=items)
return None
]:
	i: 59&134(AL), 650(AF), 699()
	o: 

nname: 699
n 699(None)[del _[1]
for it.list_owned in self._owners:
]:
	i: 660(AF), 680()
	o: 712()

nname: 680
n 680(None)[for elt in self._owners:
]:
	i: 660(for)
	o: 699()

nname: 660
n 660(None)[for it in self._cached:
]:
	i: 650(for)
	o: 680(for), 699(AF)

nname: 650
n 650(None)[]:
	i: 59&134(loop)
	o: 660(for), 712(AF)

nname: 59&134
n 59&134(None)[self._update_browse_options()
signal = None
log.debug('MR: %s DR: %s FR: %s', self._range, delta_range, fill_range)
log.debug('requesting %d items starting at %d', len(fill_range), fill_range.start)
if delta_range and delta_range < fill_range:
	windowed_childrens = self._browse_fn(delta_range.start, len(delta_range), self._sort, self._browse_options)
	if len(windowed_childrens) < len(delta_range):
		self.end_reached = True
	if delta_range.start == self._range.stop:
		items = list(WMedia2MMIObjects(windowed_childrens, self.menu, self._si))
		del self._cached[:fill_range.start - self._range.start]
		self._cached.extend(items)
		signal = 'scroll_down'
	else:
		if delta_range.stop == self._range.start:
			items = list(WMedia2MMIObjects(windowed_childrens, self.menu, self._si))
			signal = 'scroll_up'
			my_len = len(self)
			if fill_range.stop < my_len or fill_range.start < my_len and fill_range.stop >= my_len:
				del self._cached[fill_range.stop - self._range.start:]
				self._cached[0:0] = items
			else:
				del self._cached[fill_range.stop:]
				self._cached[0:0] = items
else:
	windowed_childrens = self._browse_fn(fill_range.start, len(fill_range), self._sort, self._browse_options)
	if len(windowed_childrens) < len(fill_range):
		_[1], self.end_reached = [], True
	items = list(WMedia2MMIObjects(windowed_childrens, self.menu, self._si))
	self._cached[:] = items
	signal = 'everything'
]:
	i: 0()
	o: 650(loop), 712(AL)

nname: 0
n 0(None)[try:
	delta_range = fill_range - self._range
except:
	delta_range = None
if fill_range is None:
	fill_range = self._range
]:
	i: 
	o: 59&134()

nname: 712
n 712(None)[self._range = fill_range
if self._length in fill_range:
	self._length = self._range.start + len(self._cached)
else:
	self._length = max(self._length, self._range.start + len(self._cached))
louie_send(signal, sender=self.menu.universe, items=items)
return None
]:
	i: 0(AL), 650(AF), 699()
	o: 

nname: 699
n 699(None)[del _[1]
for it.list_owned in self._owners:
]:
	i: 660(AF), 680()
	o: 712()

nname: 680
n 680(None)[for elt in self._owners:
]:
	i: 660(for)
	o: 699()

nname: 660
n 660(None)[for it in self._cached:
]:
	i: 650(for)
	o: 680(for), 699(AF)

nname: 650
n 650(None)[]:
	i: 0(loop)
	o: 660(for), 712(AF)

nname: 0
n 0(None)[try:
	delta_range = fill_range - self._range
except:
	delta_range = None
if fill_range is None:
	fill_range = self._range
self._update_browse_options()
signal = None
log.debug('MR: %s DR: %s FR: %s', self._range, delta_range, fill_range)
log.debug('requesting %d items starting at %d', len(fill_range), fill_range.start)
if delta_range and delta_range < fill_range:
	windowed_childrens = self._browse_fn(delta_range.start, len(delta_range), self._sort, self._browse_options)
	if len(windowed_childrens) < len(delta_range):
		self.end_reached = True
	if delta_range.start == self._range.stop:
		items = list(WMedia2MMIObjects(windowed_childrens, self.menu, self._si))
		del self._cached[:fill_range.start - self._range.start]
		self._cached.extend(items)
		signal = 'scroll_down'
	else:
		if delta_range.stop == self._range.start:
			items = list(WMedia2MMIObjects(windowed_childrens, self.menu, self._si))
			signal = 'scroll_up'
			my_len = len(self)
			if fill_range.stop < my_len or fill_range.start < my_len and fill_range.stop >= my_len:
				del self._cached[fill_range.stop - self._range.start:]
				self._cached[0:0] = items
			else:
				del self._cached[fill_range.stop:]
				self._cached[0:0] = items
else:
	windowed_childrens = self._browse_fn(fill_range.start, len(fill_range), self._sort, self._browse_options)
	if len(windowed_childrens) < len(fill_range):
		_[1], self.end_reached = [], True
	items = list(WMedia2MMIObjects(windowed_childrens, self.menu, self._si))
	self._cached[:] = items
	signal = 'everything'
]:
	i: 
	o: 650(loop), 712(AL)

self.nodes: {0: <unpyclib.structure.node instance at 0x9f067cc>, 699: <unpyclib.structure.node instance at 0x9f0f58c>, 650: <unpyclib.structure.node instance at 0x9f0fb8c>, 680: <unpyclib.structure.node instance at 0x9f0fd2c>, 712: <unpyclib.structure.node instance at 0x9f075cc>, 660: <unpyclib.structure.node instance at 0x9f0f9ec>}
nname: 99
n 99(None)[return ret
]:
	i: 69(), 98()
	o: 

nname: 98
n 98(None)[]:
	i: 0(f)
	o: 99()

nname: 69
n 69(None)[self._browse_options.update(dict(universe=_d))
]:
	i: 0(t)
	o: 99()

nname: 0
n 0(_d is not None)[_d = self._browse_options.pop('universe', None)
ret = self._browse_fn(0, 1, self._sort, self._browse_options) == []
]:
	i: 
	o: 69(t), 98(f)

nname: 0
n 0(None)[_d = self._browse_options.pop('universe', None)
ret = self._browse_fn(0, 1, self._sort, self._browse_options) == []
if _d is not None:
	self._browse_options.update(dict(universe=_d))
return ret
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9f047ac>}
nname: 640
n 640(None)[return None
]:
	i: 366(JA), 424(), 619()
	o: 

nname: 619
n 619(None)[return self._cached[item - self._range.start]
]:
	i: 569(), 618()
	o: 640()

nname: 618
n 618(None)[]:
	i: 477&513(f), 565(f)
	o: 619()

nname: 569
n 569(None)[self._fill_cache(Range(max(0, item - self.delta), item + self.delta))
]:
	i: 565(t)
	o: 619()

nname: 565
n 565(not item == 0)[]:
	i: 547(), 563()
	o: 569(t), 618(f)

nname: 563
n 563(None)[0
]:
	i: 532(f)
	o: 565()

nname: 547
n 547(None)[]:
	i: 532(t)
	o: 565()

nname: 532
n 532(item == 0)[]:
	i: 477&513(t)
	o: 547(t), 563(f)

nname: 477&513
n 477&513(item >= self._range.stop - 1 or item <= self._range.start)[log.debug('WIL single integer')
]:
	i: 0(f)
	o: 532(t), 565(f)

nname: 424
n 424(None)[log.debug('cache MISS (little sunshine)')
self._fill_cache(req_range.get_range(grow=self.delta))
return self[item]
]:
	i: 351(f)
	o: 640()

nname: 366
n 366(None)[log.debug('cache HIT (%d cached)', len(self._cached))
return self._cached[req_range.get_slice(offset=self._range.start)]
]:
	i: 351(t)
	o: 640(JA)

nname: 351
n 351(req_range in self._range)[]:
	i: 330(), 350()
	o: 366(t), 424(f)

nname: 350
n 350(None)[]:
	i: 306(f)
	o: 351()

nname: 330
n 330(None)[req_range.stop = req_range.start + 10
]:
	i: 306(t)
	o: 351()

nname: 306
n 306(req_range.start > req_range.stop)[req_range = Range(max(0, item.start), len(self))
]:
	i: 267(), 296()
	o: 330(t), 350(f)

nname: 296
n 296(None)[]:
	i: 255(f)
	o: 306()

nname: 267
n 267(None)[]:
	i: 255(t)
	o: 306()

nname: 255
n 255(item.stop)[]:
	i: 235(), 248()
	o: 267(t), 296(f)

nname: 248
n 248(None)[]:
	i: 211(f)
	o: 255()

nname: 235
n 235(None)[]:
	i: 211(t)
	o: 255()

nname: 211
n 211(item.start is None)[]:
	i: 203(), 210()
	o: 235(t), 248(f)

nname: 210
n 210(None)[]:
	i: 37(f)
	o: 211()

nname: 203
n 203(None)[del _[1]
return xrange(start, stop, step)
]:
	i: 160(AF), 186()
	o: 211()

nname: 186
n 186(None)[for i in xrange(start, stop, step):
]:
	i: 160(for)
	o: 203()

nname: 160
n 160(None)[]:
	i: 134(), 159()
	o: 186(for), 203(AF)

nname: 159
n 159(None)[]:
	i: 119(f)
	o: 160()

nname: 134
n 134(None)[_[1], stop = [], min(stop, self._range.stop)
]:
	i: 119(t)
	o: 160()

nname: 119
n 119(item.stop is None)[]:
	i: 93(), 118()
	o: 134(t), 159(f)

nname: 118
n 118(None)[]:
	i: 47(f)
	o: 119()

nname: 93
n 93(None)[start = max(start, self._range.start)
]:
	i: 47(t)
	o: 119()

nname: 47
n 47(item.start is None)[start, stop, step = item.indices(len(self))
]:
	i: 37(t)
	o: 93(t), 118(f)

nname: 37
n 37(item.step)[]:
	i: 0(t)
	o: 47(t), 210(f)

nname: 0
n 0(isinstance(item, slice))[log.debug('WIL%s getitem(%s)', self._range, item)
]:
	i: 
	o: 37(t), 477&513(f)

nname: 640
n 640(None)[return None
]:
	i: 306(JA), 477&513()
	o: 

nname: 477&513
n 477&513(None)[log.debug('WIL single integer')
if item >= self._range.stop - 1 or item <= self._range.start:
	if item == 0:
		pass
	else:
		0
if not item == 0:
	self._fill_cache(Range(max(0, item - self.delta), item + self.delta))
return self._cached[item - self._range.start]
]:
	i: 0(f)
	o: 640()

nname: 306
n 306(None)[req_range = Range(max(0, item.start), len(self))
if req_range.start > req_range.stop:
	req_range.stop = req_range.start + 10
if req_range in self._range:
	log.debug('cache HIT (%d cached)', len(self._cached))
	return self._cached[req_range.get_slice(offset=self._range.start)]
else:
	log.debug('cache MISS (little sunshine)')
	self._fill_cache(req_range.get_range(grow=self.delta))
	return self[item]
]:
	i: 211()
	o: 640(JA)

nname: 211
n 211(None)[if item.start is None:
	pass
if item.stop:
	pass
]:
	i: 203(), 37(f)
	o: 306()

nname: 203
n 203(None)[del _[1]
return xrange(start, stop, step)
]:
	i: 160(AF), 186()
	o: 211()

nname: 186
n 186(None)[for i in xrange(start, stop, step):
]:
	i: 160(for)
	o: 203()

nname: 160
n 160(None)[]:
	i: 47()
	o: 186(for), 203(AF)

nname: 47
n 47(None)[start, stop, step = item.indices(len(self))
if item.start is None:
	start = max(start, self._range.start)
if item.stop is None:
	_[1], stop = [], min(stop, self._range.stop)
]:
	i: 37(t)
	o: 160()

nname: 37
n 37(item.step)[]:
	i: 0(t)
	o: 47(t), 211(f)

nname: 0
n 0(isinstance(item, slice))[log.debug('WIL%s getitem(%s)', self._range, item)
]:
	i: 
	o: 37(t), 477&513(f)

nname: 640
n 640(None)[return None
]:
	i: 211(JA), 477&513()
	o: 

nname: 477&513
n 477&513(None)[log.debug('WIL single integer')
if item >= self._range.stop - 1 or item <= self._range.start:
	if item == 0:
		pass
	else:
		0
if not item == 0:
	self._fill_cache(Range(max(0, item - self.delta), item + self.delta))
return self._cached[item - self._range.start]
]:
	i: 0(f)
	o: 640()

nname: 211
n 211(None)[if item.start is None:
	pass
if item.stop:
	pass
req_range = Range(max(0, item.start), len(self))
if req_range.start > req_range.stop:
	req_range.stop = req_range.start + 10
if req_range in self._range:
	log.debug('cache HIT (%d cached)', len(self._cached))
	return self._cached[req_range.get_slice(offset=self._range.start)]
else:
	log.debug('cache MISS (little sunshine)')
	self._fill_cache(req_range.get_range(grow=self.delta))
	return self[item]
]:
	i: 203(), 37(f)
	o: 640(JA)

nname: 203
n 203(None)[del _[1]
return xrange(start, stop, step)
]:
	i: 47(AF), 186()
	o: 211()

nname: 186
n 186(None)[for i in xrange(start, stop, step):
]:
	i: 47(for)
	o: 203()

nname: 47
n 47(None)[start, stop, step = item.indices(len(self))
if item.start is None:
	start = max(start, self._range.start)
if item.stop is None:
	_[1], stop = [], min(stop, self._range.stop)
]:
	i: 37(t)
	o: 186(for), 203(AF)

nname: 37
n 37(item.step)[]:
	i: 0(t)
	o: 47(t), 211(f)

nname: 0
n 0(isinstance(item, slice))[log.debug('WIL%s getitem(%s)', self._range, item)
]:
	i: 
	o: 37(t), 477&513(f)

self.nodes: {0: <unpyclib.structure.node instance at 0x9f212ac>, '477&513': <unpyclib.structure.node instance at 0x9f070ac>, 640: <unpyclib.structure.node instance at 0x9f211ec>, 37: <unpyclib.structure.node instance at 0x9f215cc>, 47: <unpyclib.structure.node instance at 0x9f0708c>, 186: <unpyclib.structure.node instance at 0x9f21dcc>, 203: <unpyclib.structure.node instance at 0x9f21e4c>, 211: <unpyclib.structure.node instance at 0x9f071cc>}
nname: 0
n 0(None)[ret = playlist_swap_children(self[i1].wymedia_resource, self[i2].wymedia_resource)
offset = self._range.start
t = self._cached
ri1 = i1 - offset
ri2 = i2 - offset
t[ri1], t[ri2] = t[ri2], t[ri1]
return ret
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9f0460c>}
nname: 52
n 52(None)[return False
]:
	i: 15(), 51()
	o: 

nname: 51
n 51(None)[]:
	i: 0(f)
	o: 52()

nname: 15
n 15(None)[ret = self._si.vfs_add_item(item)
self._fill_cache()
return ret
]:
	i: 0(t)
	o: 52()

nname: 0
n 0(self._si is not None)[]:
	i: 
	o: 15(t), 51(f)

nname: 0
n 0(None)[if self._si is not None:
	ret = self._si.vfs_add_item(item)
	self._fill_cache()
	return ret
return False
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9f0430c>}
nname: 71
n 71(None)[return False
]:
	i: 31(), 70()
	o: 

nname: 70
n 70(None)[]:
	i: 0&15(f)
	o: 71()

nname: 31
n 31(None)[ret = self._si.vfs_add_item(other_list._si)
self._fill_cache()
return ret
]:
	i: 0&15(t)
	o: 71()

nname: 0&15
n 0&15(self._si is not None and isinstance(other_list, WindowedItemList))[]:
	i: 
	o: 31(t), 70(f)

nname: 0&15
n 0&15(None)[if self._si is not None and isinstance(other_list, WindowedItemList):
	ret = self._si.vfs_add_item(other_list._si)
	self._fill_cache()
	return ret
return False
]:
	i: 
	o: 

self.nodes: {'0&15': <unpyclib.structure.node instance at 0x9f0464c>}
nname: 6
n 6(None)[__doc__ = "Windowed item list.\n\n    This list is a view over a bigger, usually database-backed list, that we'd like\n    to avoid being entirely loaded in memory at once (see the documentation for\n    __init__ for details on how this is done).\n\n    The WindowedItemList maintains an internal cache of usually 2*WindowedItemList.delta\n    items around the last accessed item (refreshed whenever an item outside the cache\n    is accessed).\n\n    /!\\ **WARNING** /!\\ While WindowedItemList implements __getitem__ in a list-like\n    fashion, its behavior differs from that of list when the argument to __getitem__\n    is a slice:\n        - If the slice's start or stop is None (e.g. [foo:], [:foo] or [:]), the\n          beginning and end *of the cache* (*not* of the WIL) are used instead. To\n          retrieve the entire actual contents of the WIL (although this isn't\n          recommended, for obvious reasons), use my_wil[0:len(my_wil)].\n\n    /!\\ **WARNING TOO** /!\\ Iterating over a WIL actually only iterates over its cache.\n    If you want to iterate over the whole list, you'll have to use the good old C-ism:\n        for i in xrange(len(wil)):\n            # do stuff with wil[i]\n    "
__slots__ = ['_si', '_range', '_cached', 'menu', '_browse_options', '_browse_fn', '_sort', '_length', '_owners', '_pattern', 'end_reached']
delta = 20
def __init__(self, source_item, menu=None, universe=None, browse_fn=None, sort_order=None, pattern=None, filter=None):
	self._length = 0
	self._si = source_item
	if not menu:
		pass
	self.menu = menu
	if not universe:
		pass
	universe = universe
	if not sort_order:
		pass
	self._sort = sort_order
	self._pattern = pattern
	self.end_reached = False
	if browse_fn is not None:
		if pattern is not None:
			self._browse_fn = functools.partial(browse_fn, pattern)
		else:
			self._browse_fn = functools.partial(browse_fn, source_item)
	else:
		self._browse_fn = functools.partial(browse_ng, source_item.wymedia_resource)
	if universe == 'multiverse':
		self._browse_options = {}
	else:
		self._browse_options = dict(universe=universe)
	if not filter:
		pass
	self._browse_options.update(filter)
	self._update_browse_options()
	self._range = Range(0, 0)
	self._cached = []
	self._owners = set()
	self._fill_cache(Range(0, 11))
	return None

def _owner_removed(self, who):
	self._owners.remove(who)

def add_owner(self, who):
	ow = self._owners
	ow.add(ref(who, self._owner_removed))

def __iter__(self):
	return iter(self._cached)

def __repr__(self):
	if self._si is not None:
		pass
	name = self._pattern
	return '<WIL(%s)%s of len %d> %s' % (name, self._range, len(self), self._cached)

def remove_list(self, list_name):
	for it in self._cached:
		try:
			it.list_owned.remove(list_name)
			continue
		except ValueError:
			continue

def index(self, elt):
	if isinstance(self._si, Playlist) and self._si.wymedia_resource['id'] != elt.wymedia_resource['parentid']:
		try:
			idx = int(container_search(self._si.wymedia_resource, 'refid', elt.wymedia_resource.get('refid', elt.wymedia_resource['id']))[0]['rank'])
			return int(idx)
		except IndexError:
			log.error('container_search(%s, "refid", %s) ->  []', self._si.wymedia_resource, elt.wymedia_resource.get('refid', elt.wymedia_resource['id']))
			wmedia_elt = elt.wymedia_resource
			PRINT_EXCEPTION()
	else:
		wmedia_elt = elt.wymedia_resource
	try:
		return self._cached.index(wmedia_elt) + self._range.start

def __len__(self):
	if hasattr(self._si, 'wymedia_resource'):
		cc = self._si.wymedia_resource.get('childCount')
		if cc is not None:
			return int(cc)
	return self._length

def _update_browse_options(self):
	if 'maturity_rating' in self._browse_options:
		del self._browse_options['maturity_rating']
	from pygui.config import user_config
	if user_config['security']['parental_control']:
		if not user_config['security']['parent_mode']:
			if not user_config['security']['maturity_rating']:
				pass
			maturity_rating = user_config['security']['maturity_rating']
			self._browse_options['maturity_rating'] = str(maturity_rating)
		else:
			if user_config['security']['show_hidden']:
				pass
			maturity_rating = 19
			self._browse_options['maturity_rating'] = str(maturity_rating)

def _fill_cache(self, fill_range=None):
	try:
		delta_range = fill_range - self._range
	except:
		delta_range = None
	if fill_range is None:
		fill_range = self._range
	self._update_browse_options()
	signal = None
	log.debug('MR: %s DR: %s FR: %s', self._range, delta_range, fill_range)
	log.debug('requesting %d items starting at %d', len(fill_range), fill_range.start)
	if delta_range and delta_range < fill_range:
		windowed_childrens = self._browse_fn(delta_range.start, len(delta_range), self._sort, self._browse_options)
		if len(windowed_childrens) < len(delta_range):
			self.end_reached = True
		if delta_range.start == self._range.stop:
			items = list(WMedia2MMIObjects(windowed_childrens, self.menu, self._si))
			del self._cached[:fill_range.start - self._range.start]
			self._cached.extend(items)
			signal = 'scroll_down'
		else:
			if delta_range.stop == self._range.start:
				items = list(WMedia2MMIObjects(windowed_childrens, self.menu, self._si))
				signal = 'scroll_up'
				my_len = len(self)
				if fill_range.stop < my_len or fill_range.start < my_len and fill_range.stop >= my_len:
					del self._cached[fill_range.stop - self._range.start:]
					self._cached[0:0] = items
				else:
					del self._cached[fill_range.stop:]
					self._cached[0:0] = items
	else:
		windowed_childrens = self._browse_fn(fill_range.start, len(fill_range), self._sort, self._browse_options)
		if len(windowed_childrens) < len(fill_range):
			_[1], self.end_reached = [], True
		items = list(WMedia2MMIObjects(windowed_childrens, self.menu, self._si))
		self._cached[:] = items
		signal = 'everything'

def _second_browse(self):
	_d = self._browse_options.pop('universe', None)
	ret = self._browse_fn(0, 1, self._sort, self._browse_options) == []
	if _d is not None:
		self._browse_options.update(dict(universe=_d))
	return ret

empty = property(_second_browse)
del _second_browse
def __getitem__(self, item):
	log.debug('WIL%s getitem(%s)', self._range, item)

def swap(self, i1, i2):
	ret = playlist_swap_children(self[i1].wymedia_resource, self[i2].wymedia_resource)
	offset = self._range.start
	t = self._cached
	ri1 = i1 - offset
	ri2 = i2 - offset
	t[ri1], t[ri2] = t[ri2], t[ri1]
	return ret

def append(self, item):
	if self._si is not None:
		ret = self._si.vfs_add_item(item)
		self._fill_cache()
		return ret
	return False

def extend(self, other_list):
	if self._si is not None and isinstance(other_list, WindowedItemList):
		ret = self._si.vfs_add_item(other_list._si)
		self._fill_cache()
		return ret
	return False

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb7752f0c>}
nname: 0
n 0(None)[from __future__ import absolute_import
__all__ = ['WindowedItemList']
import functools
from weakref import ref
from peewee.ranges import Range
from peewee.debug import GET_LOGGER, PRINT_EXCEPTION
from peewee.messages import send as louie_send
from wymedia.wmplus import browse_ng, playlist_swap_children, container_search, get_browse_position
from .core import WMedia2MMIObjects, wymedia_sorting, Playlist
from pygui.config import admin_age
log = GET_LOGGER(__name__)
class WindowedItemList(object):
	__doc__ = "Windowed item list.\n\n    This list is a view over a bigger, usually database-backed list, that we'd like\n    to avoid being entirely loaded in memory at once (see the documentation for\n    __init__ for details on how this is done).\n\n    The WindowedItemList maintains an internal cache of usually 2*WindowedItemList.delta\n    items around the last accessed item (refreshed whenever an item outside the cache\n    is accessed).\n\n    /!\\ **WARNING** /!\\ While WindowedItemList implements __getitem__ in a list-like\n    fashion, its behavior differs from that of list when the argument to __getitem__\n    is a slice:\n        - If the slice's start or stop is None (e.g. [foo:], [:foo] or [:]), the\n          beginning and end *of the cache* (*not* of the WIL) are used instead. To\n          retrieve the entire actual contents of the WIL (although this isn't\n          recommended, for obvious reasons), use my_wil[0:len(my_wil)].\n\n    /!\\ **WARNING TOO** /!\\ Iterating over a WIL actually only iterates over its cache.\n    If you want to iterate over the whole list, you'll have to use the good old C-ism:\n        for i in xrange(len(wil)):\n            # do stuff with wil[i]\n    "
	__slots__ = ['_si', '_range', '_cached', 'menu', '_browse_options', '_browse_fn', '_sort', '_length', '_owners', '_pattern', 'end_reached']
	delta = 20
	def __init__(self, source_item, menu=None, universe=None, browse_fn=None, sort_order=None, pattern=None, filter=None):
		self._length = 0
		self._si = source_item
		if not menu:
			pass
		self.menu = menu
		if not universe:
			pass
		universe = universe
		if not sort_order:
			pass
		self._sort = sort_order
		self._pattern = pattern
		self.end_reached = False
		if browse_fn is not None:
			if pattern is not None:
				self._browse_fn = functools.partial(browse_fn, pattern)
			else:
				self._browse_fn = functools.partial(browse_fn, source_item)
		else:
			self._browse_fn = functools.partial(browse_ng, source_item.wymedia_resource)
		if universe == 'multiverse':
			self._browse_options = {}
		else:
			self._browse_options = dict(universe=universe)
		if not filter:
			pass
		self._browse_options.update(filter)
		self._update_browse_options()
		self._range = Range(0, 0)
		self._cached = []
		self._owners = set()
		self._fill_cache(Range(0, 11))
		return None

	def _owner_removed(self, who):
		self._owners.remove(who)

	def add_owner(self, who):
		ow = self._owners
		ow.add(ref(who, self._owner_removed))

	def __iter__(self):
		return iter(self._cached)

	def __repr__(self):
		if self._si is not None:
			pass
		name = self._pattern
		return '<WIL(%s)%s of len %d> %s' % (name, self._range, len(self), self._cached)

	def remove_list(self, list_name):
		for it in self._cached:
			try:
				it.list_owned.remove(list_name)
				continue
			except ValueError:
				continue

	def index(self, elt):
		if isinstance(self._si, Playlist) and self._si.wymedia_resource['id'] != elt.wymedia_resource['parentid']:
			try:
				idx = int(container_search(self._si.wymedia_resource, 'refid', elt.wymedia_resource.get('refid', elt.wymedia_resource['id']))[0]['rank'])
				return int(idx)
			except IndexError:
				log.error('container_search(%s, "refid", %s) ->  []', self._si.wymedia_resource, elt.wymedia_resource.get('refid', elt.wymedia_resource['id']))
				wmedia_elt = elt.wymedia_resource
				PRINT_EXCEPTION()
		else:
			wmedia_elt = elt.wymedia_resource
		try:
			return self._cached.index(wmedia_elt) + self._range.start

	def __len__(self):
		if hasattr(self._si, 'wymedia_resource'):
			cc = self._si.wymedia_resource.get('childCount')
			if cc is not None:
				return int(cc)
		return self._length

	def _update_browse_options(self):
		if 'maturity_rating' in self._browse_options:
			del self._browse_options['maturity_rating']
		from pygui.config import user_config
		if user_config['security']['parental_control']:
			if not user_config['security']['parent_mode']:
				if not user_config['security']['maturity_rating']:
					pass
				maturity_rating = user_config['security']['maturity_rating']
				self._browse_options['maturity_rating'] = str(maturity_rating)
			else:
				if user_config['security']['show_hidden']:
					pass
				maturity_rating = 19
				self._browse_options['maturity_rating'] = str(maturity_rating)

	def _fill_cache(self, fill_range=None):
		try:
			delta_range = fill_range - self._range
		except:
			delta_range = None
		if fill_range is None:
			fill_range = self._range
		self._update_browse_options()
		signal = None
		log.debug('MR: %s DR: %s FR: %s', self._range, delta_range, fill_range)
		log.debug('requesting %d items starting at %d', len(fill_range), fill_range.start)
		if delta_range and delta_range < fill_range:
			windowed_childrens = self._browse_fn(delta_range.start, len(delta_range), self._sort, self._browse_options)
			if len(windowed_childrens) < len(delta_range):
				self.end_reached = True
			if delta_range.start == self._range.stop:
				items = list(WMedia2MMIObjects(windowed_childrens, self.menu, self._si))
				del self._cached[:fill_range.start - self._range.start]
				self._cached.extend(items)
				signal = 'scroll_down'
			else:
				if delta_range.stop == self._range.start:
					items = list(WMedia2MMIObjects(windowed_childrens, self.menu, self._si))
					signal = 'scroll_up'
					my_len = len(self)
					if fill_range.stop < my_len or fill_range.start < my_len and fill_range.stop >= my_len:
						del self._cached[fill_range.stop - self._range.start:]
						self._cached[0:0] = items
					else:
						del self._cached[fill_range.stop:]
						self._cached[0:0] = items
		else:
			windowed_childrens = self._browse_fn(fill_range.start, len(fill_range), self._sort, self._browse_options)
			if len(windowed_childrens) < len(fill_range):
				_[1], self.end_reached = [], True
			items = list(WMedia2MMIObjects(windowed_childrens, self.menu, self._si))
			self._cached[:] = items
			signal = 'everything'

	def _second_browse(self):
		_d = self._browse_options.pop('universe', None)
		ret = self._browse_fn(0, 1, self._sort, self._browse_options) == []
		if _d is not None:
			self._browse_options.update(dict(universe=_d))
		return ret

	empty = property(_second_browse)
	del _second_browse
	def __getitem__(self, item):
		log.debug('WIL%s getitem(%s)', self._range, item)

	def swap(self, i1, i2):
		ret = playlist_swap_children(self[i1].wymedia_resource, self[i2].wymedia_resource)
		offset = self._range.start
		t = self._cached
		ri1 = i1 - offset
		ri2 = i2 - offset
		t[ri1], t[ri2] = t[ri2], t[ri1]
		return ret

	def append(self, item):
		if self._si is not None:
			ret = self._si.vfs_add_item(item)
			self._fill_cache()
			return ret
		return False

	def extend(self, other_list):
		if self._si is not None and isinstance(other_list, WindowedItemList):
			ret = self._si.vfs_add_item(other_list._si)
			self._fill_cache()
			return ret
		return False



]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7745e6c>}
from __future__ import absolute_import
__all__ = ['WindowedItemList']
import functools
from weakref import ref
from peewee.ranges import Range
from peewee.debug import GET_LOGGER, PRINT_EXCEPTION
from peewee.messages import send as louie_send
from wymedia.wmplus import browse_ng, playlist_swap_children, container_search, get_browse_position
from .core import WMedia2MMIObjects, wymedia_sorting, Playlist
from pygui.config import admin_age
log = GET_LOGGER(__name__)
class WindowedItemList(object):
	__doc__ = "Windowed item list.\n\n    This list is a view over a bigger, usually database-backed list, that we'd like\n    to avoid being entirely loaded in memory at once (see the documentation for\n    __init__ for details on how this is done).\n\n    The WindowedItemList maintains an internal cache of usually 2*WindowedItemList.delta\n    items around the last accessed item (refreshed whenever an item outside the cache\n    is accessed).\n\n    /!\\ **WARNING** /!\\ While WindowedItemList implements __getitem__ in a list-like\n    fashion, its behavior differs from that of list when the argument to __getitem__\n    is a slice:\n        - If the slice's start or stop is None (e.g. [foo:], [:foo] or [:]), the\n          beginning and end *of the cache* (*not* of the WIL) are used instead. To\n          retrieve the entire actual contents of the WIL (although this isn't\n          recommended, for obvious reasons), use my_wil[0:len(my_wil)].\n\n    /!\\ **WARNING TOO** /!\\ Iterating over a WIL actually only iterates over its cache.\n    If you want to iterate over the whole list, you'll have to use the good old C-ism:\n        for i in xrange(len(wil)):\n            # do stuff with wil[i]\n    "
	__slots__ = ['_si', '_range', '_cached', 'menu', '_browse_options', '_browse_fn', '_sort', '_length', '_owners', '_pattern', 'end_reached']
	delta = 20
	def __init__(self, source_item, menu=None, universe=None, browse_fn=None, sort_order=None, pattern=None, filter=None):
		self._length = 0
		self._si = source_item
		if not menu:
			pass
		self.menu = menu
		if not universe:
			pass
		universe = universe
		if not sort_order:
			pass
		self._sort = sort_order
		self._pattern = pattern
		self.end_reached = False
		if browse_fn is not None:
			if pattern is not None:
				self._browse_fn = functools.partial(browse_fn, pattern)
			else:
				self._browse_fn = functools.partial(browse_fn, source_item)
		else:
			self._browse_fn = functools.partial(browse_ng, source_item.wymedia_resource)
		if universe == 'multiverse':
			self._browse_options = {}
		else:
			self._browse_options = dict(universe=universe)
		if not filter:
			pass
		self._browse_options.update(filter)
		self._update_browse_options()
		self._range = Range(0, 0)
		self._cached = []
		self._owners = set()
		self._fill_cache(Range(0, 11))
		return None

	def _owner_removed(self, who):
		self._owners.remove(who)

	def add_owner(self, who):
		ow = self._owners
		ow.add(ref(who, self._owner_removed))

	def __iter__(self):
		return iter(self._cached)

	def __repr__(self):
		if self._si is not None:
			pass
		name = self._pattern
		return '<WIL(%s)%s of len %d> %s' % (name, self._range, len(self), self._cached)

	def remove_list(self, list_name):
		for it in self._cached:
			try:
				it.list_owned.remove(list_name)
				continue
			except ValueError:
				continue

	def index(self, elt):
		if isinstance(self._si, Playlist) and self._si.wymedia_resource['id'] != elt.wymedia_resource['parentid']:
			try:
				idx = int(container_search(self._si.wymedia_resource, 'refid', elt.wymedia_resource.get('refid', elt.wymedia_resource['id']))[0]['rank'])
				return int(idx)
			except IndexError:
				log.error('container_search(%s, "refid", %s) ->  []', self._si.wymedia_resource, elt.wymedia_resource.get('refid', elt.wymedia_resource['id']))
				wmedia_elt = elt.wymedia_resource
				PRINT_EXCEPTION()
		else:
			wmedia_elt = elt.wymedia_resource
		try:
			return self._cached.index(wmedia_elt) + self._range.start

	def __len__(self):
		if hasattr(self._si, 'wymedia_resource'):
			cc = self._si.wymedia_resource.get('childCount')
			if cc is not None:
				return int(cc)
		return self._length

	def _update_browse_options(self):
		if 'maturity_rating' in self._browse_options:
			del self._browse_options['maturity_rating']
		from pygui.config import user_config
		if user_config['security']['parental_control']:
			if not user_config['security']['parent_mode']:
				if not user_config['security']['maturity_rating']:
					pass
				maturity_rating = user_config['security']['maturity_rating']
				self._browse_options['maturity_rating'] = str(maturity_rating)
			else:
				if user_config['security']['show_hidden']:
					pass
				maturity_rating = 19
				self._browse_options['maturity_rating'] = str(maturity_rating)

	def _fill_cache(self, fill_range=None):
		try:
			delta_range = fill_range - self._range
		except:
			delta_range = None
		if fill_range is None:
			fill_range = self._range
		self._update_browse_options()
		signal = None
		log.debug('MR: %s DR: %s FR: %s', self._range, delta_range, fill_range)
		log.debug('requesting %d items starting at %d', len(fill_range), fill_range.start)
		if delta_range and delta_range < fill_range:
			windowed_childrens = self._browse_fn(delta_range.start, len(delta_range), self._sort, self._browse_options)
			if len(windowed_childrens) < len(delta_range):
				self.end_reached = True
			if delta_range.start == self._range.stop:
				items = list(WMedia2MMIObjects(windowed_childrens, self.menu, self._si))
				del self._cached[:fill_range.start - self._range.start]
				self._cached.extend(items)
				signal = 'scroll_down'
			else:
				if delta_range.stop == self._range.start:
					items = list(WMedia2MMIObjects(windowed_childrens, self.menu, self._si))
					signal = 'scroll_up'
					my_len = len(self)
					if fill_range.stop < my_len or fill_range.start < my_len and fill_range.stop >= my_len:
						del self._cached[fill_range.stop - self._range.start:]
						self._cached[0:0] = items
					else:
						del self._cached[fill_range.stop:]
						self._cached[0:0] = items
		else:
			windowed_childrens = self._browse_fn(fill_range.start, len(fill_range), self._sort, self._browse_options)
			if len(windowed_childrens) < len(fill_range):
				_[1], self.end_reached = [], True
			items = list(WMedia2MMIObjects(windowed_childrens, self.menu, self._si))
			self._cached[:] = items
			signal = 'everything'

	def _second_browse(self):
		_d = self._browse_options.pop('universe', None)
		ret = self._browse_fn(0, 1, self._sort, self._browse_options) == []
		if _d is not None:
			self._browse_options.update(dict(universe=_d))
		return ret

	empty = property(_second_browse)
	del _second_browse
	def __getitem__(self, item):
		log.debug('WIL%s getitem(%s)', self._range, item)

	def swap(self, i1, i2):
		ret = playlist_swap_children(self[i1].wymedia_resource, self[i2].wymedia_resource)
		offset = self._range.start
		t = self._cached
		ri1 = i1 - offset
		ri2 = i2 - offset
		t[ri1], t[ri2] = t[ri2], t[ri1]
		return ret

	def append(self, item):
		if self._si is not None:
			ret = self._si.vfs_add_item(item)
			self._fill_cache()
			return ret
		return False

	def extend(self, other_list):
		if self._si is not None and isinstance(other_list, WindowedItemList):
			ret = self._si.vfs_add_item(other_list._si)
			self._fill_cache()
			return ret
		return False



