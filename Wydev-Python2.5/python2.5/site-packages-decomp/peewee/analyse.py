# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 217
n 217(None)[]:
	i: 137(), 191(), 215(AE)
	o: 

nname: 215
n 215(None)[]:
	i: 181(f)
	o: 217(AE)

nname: 191
n 191(None)[#, e
print "WARNING trace2html not found : html code coverage won't be created : %s" % str(e)
]:
	i: 181(t)
	o: 217()

nname: 181
n 181(<dummy_ex3> EXC_MATCH Exception)[]:
	i: 0(except)
	o: 191(t), 215(f)

nname: 137
n 137(None)[import trace2html
trace2html.main(['trace2html.py', '-f', out_file, '-o', out_dir])
]:
	i: 0(try)
	o: 217()

nname: 0
n 0(None)[print '*' * 100,
print '\nCODE COVERAGE ANALYSIS STARTED\n',
print '*' * 100
import trace
out_dir = 'wybox_code_coverage'
out_file = '.wybox.trace'
my_trace = trace.Trace(ignoremods=['wyvas', 'peewee'], trace=0, count=1, outfile=out_file)
my_trace.runfunc(main)
r = my_trace.results()
r.write_results(show_missing=False, summary=False)
]:
	i: 
	o: 137(try), 181(except)

nname: 181
n 181(None)[except Exception, e:
	print "WARNING trace2html not found : html code coverage won't be created : %s" % str(e)
]:
	i: 0()
	o: 

nname: 0
n 0(None)[print '*' * 100,
print '\nCODE COVERAGE ANALYSIS STARTED\n',
print '*' * 100
import trace
out_dir = 'wybox_code_coverage'
out_file = '.wybox.trace'
my_trace = trace.Trace(ignoremods=['wyvas', 'peewee'], trace=0, count=1, outfile=out_file)
my_trace.runfunc(main)
r = my_trace.results()
r.write_results(show_missing=False, summary=False)
try:
	import trace2html
	trace2html.main(['trace2html.py', '-f', out_file, '-o', out_dir])
]:
	i: 
	o: 181()

nname: 0
n 0(None)[print '*' * 100,
print '\nCODE COVERAGE ANALYSIS STARTED\n',
print '*' * 100
import trace
out_dir = 'wybox_code_coverage'
out_file = '.wybox.trace'
my_trace = trace.Trace(ignoremods=['wyvas', 'peewee'], trace=0, count=1, outfile=out_file)
my_trace.runfunc(main)
r = my_trace.results()
r.write_results(show_missing=False, summary=False)
try:
	import trace2html
	trace2html.main(['trace2html.py', '-f', out_file, '-o', out_dir])
except Exception, e:
	print "WARNING trace2html not found : html code coverage won't be created : %s" % str(e)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb753d12c>}
nname: 6
n 6(None)[def start(self, main):
	print '*' * 100,
	print '\nCODE COVERAGE ANALYSIS STARTED\n',
	print '*' * 100
	import trace
	out_dir = 'wybox_code_coverage'
	out_file = '.wybox.trace'
	my_trace = trace.Trace(ignoremods=['wyvas', 'peewee'], trace=0, count=1, outfile=out_file)
	my_trace.runfunc(main)
	r = my_trace.results()
	r.write_results(show_missing=False, summary=False)
	try:
		import trace2html
		trace2html.main(['trace2html.py', '-f', out_file, '-o', out_dir])
	except Exception, e:
		print "WARNING trace2html not found : html code coverage won't be created : %s" % str(e)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb753956c>}
nname: 0
n 0(None)[print '*' * 100,
print '\nTIME PROFILER STARTED\n',
print '*' * 100
import hotshot
import hotshot.stats
my_profiler = hotshot.Profile('.wybox.prof')
my_profiler.runcall(main)
my_profiler.close()
profiler_stats = hotshot.stats.load('.wybox.prof')
profiler_stats.sort_stats('time', 'calls')
profiler_stats.dump_stats('wybox_profiling_time_call.prof')
profiler_stats.print_stats()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb752f9ac>}
nname: 6
n 6(None)[def start(self, main):
	print '*' * 100,
	print '\nTIME PROFILER STARTED\n',
	print '*' * 100
	import hotshot
	import hotshot.stats
	my_profiler = hotshot.Profile('.wybox.prof')
	my_profiler.runcall(main)
	my_profiler.close()
	profiler_stats = hotshot.stats.load('.wybox.prof')
	profiler_stats.sort_stats('time', 'calls')
	profiler_stats.dump_stats('wybox_profiling_time_call.prof')
	profiler_stats.print_stats()

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75396ac>}
nname: 0
n 0(None)[self.stop_trace = stop_trace
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb752f38c>}
DFADecompile Exception need more than 0 values to unpack
nname: 102
n 102(None)[102]:
	i: 97(AE)
	o: 

nname: 97
n 97(None)[return res
]:
	i: 0(finally), 19()
	o: 102(AE)

nname: 19
n 19(None)[res = f(*args, **kwds)
open(os.path.join('/tmp', '%s.dot' % f.__name__), 'w').write(pycallgraph.get_dot(stop=self.stop_trace))
]:
	i: 0(ASF)
	o: 97()

nname: 0
n 0(None)[res = None
pycallgraph.start_trace()
]:
	i: 
	o: 19(ASF), 97(finally)

nname: 97
n 97(None)[finally:
	return res
102]:
	i: 0()
	o: 

nname: 0
n 0(None)[res = None
pycallgraph.start_trace()
try:
	res = f(*args, **kwds)
	open(os.path.join('/tmp', '%s.dot' % f.__name__), 'w').write(pycallgraph.get_dot(stop=self.stop_trace))
]:
	i: 
	o: 97()

nname: 0
n 0(None)[res = None
pycallgraph.start_trace()
try:
	res = f(*args, **kwds)
	open(os.path.join('/tmp', '%s.dot' % f.__name__), 'w').write(pycallgraph.get_dot(stop=self.stop_trace))
finally:
	return res
102]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7539e0c>}
nname: 0
n 0(None)[def trace(*args, **args):
	res = None
	pycallgraph.start_trace()
	try:
		res = f(*args, **kwds)
		open(os.path.join('/tmp', '%s.dot' % f.__name__), 'w').write(pycallgraph.get_dot(stop=self.stop_trace))
	finally:
		return res
	102
return trace
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb752fd4c>}
nname: 6
n 6(None)[__doc__ = '\n        @CallGraph(stop_trace=True)\n        def test_func(*args, **kw):\n            ...\n\n        write a file called /tmp/test_func.dot containing the call graph of\n        decorated function.\n        To obtain a more readable view of this file, you can use the dot utility on your own PC:\n            "dot -Tjpg/png/gif/ps -oyour_file /tmp/test_func.dot"\n        N.B : dot utility is a part of the GraphViz project.\n\n\n        pycallgraph can be installed by easy_install (pure python -> works with sh4):\n             easy_install pycallgraph\n        '
def __init__(self, stop_trace=True):
	self.stop_trace = stop_trace

def __call__(self, f):
	def trace(*args, **args):
		res = None
		pycallgraph.start_trace()
		try:
			res = f(*args, **kwds)
			open(os.path.join('/tmp', '%s.dot' % f.__name__), 'w').write(pycallgraph.get_dot(stop=self.stop_trace))
		finally:
			return res
		102
	return trace

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb752ff6c>}
nname: 0
n 0(None)[self.aspects = set(aspects)
self.limit = 0
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb752fdec>}
nname: 327
n 327(None)[return f_result
]:
	i: 313(), 326()
	o: 

nname: 326
n 326(None)[]:
	i: 172(f)
	o: 327()

nname: 313
n 313(None)[_call_queue.pop()
]:
	i: 246(AL), 312()
	o: 327()

nname: 312
n 312(None)[]:
	i: 250(AF), 261()
	o: 313()

nname: 261
n 261(None)[for func_timed in _call_queue[_decal]:
log.debug('%s %s : %.1f%% with %fs' % (_dec, func_timed[0], func_timed[1] * factor, func_timed[1]))
]:
	i: 250(for)
	o: 312()

nname: 250
n 250(None)[]:
	i: 246(loop)
	o: 261(for), 312(AF)

nname: 246
n 246(None)[]:
	i: 172(t)
	o: 250(loop), 313(AL)

nname: 172
n 172(_decal < len(_call_queue))[_call_queue[_decal - 1].append((f.func_name, res))
]:
	i: 138(), 171()
	o: 246(t), 326(f)

nname: 171
n 171(None)[]:
	i: 0(f)
	o: 172()

nname: 138
n 138(None)[log.debug('%s %s executed in %fs' % (_prefix, f.func_name, res))
]:
	i: 0(t)
	o: 172()

nname: 0
n 0(res > self.limit)[_call_queue.append(list())
log.debug('%s %s called' % (_prefix + '>', f.func_name))
]:
	i: 
	o: 138(t), 171(f)

nname: 327
n 327(None)[return f_result
]:
	i: 313(), 0(f)
	o: 

nname: 313
n 313(None)[_call_queue.pop()
]:
	i: 261()
	o: 327()

nname: 261
n 261(None)[for func_timed in _call_queue[_decal]:
	log.debug('%s %s : %.1f%% with %fs' % (_dec, func_timed[0], func_timed[1] * factor, func_timed[1]))
]:
	i: 246(for)
	o: 313()

nname: 246
n 246(None)[]:
	i: 0(t)
	o: 261(for)

nname: 0
n 0(_decal < len(_call_queue))[_call_queue.append(list())
log.debug('%s %s called' % (_prefix + '>', f.func_name))
if res > self.limit:
	log.debug('%s %s executed in %fs' % (_prefix, f.func_name, res))
_call_queue[_decal - 1].append((f.func_name, res))
]:
	i: 
	o: 246(t), 327(f)

nname: 327
n 327(None)[return f_result
]:
	i: 313(), 0(f)
	o: 

nname: 313
n 313(None)[_call_queue.pop()
]:
	i: 246()
	o: 327()

nname: 246
n 246(None)[for func_timed in _call_queue[_decal]:
	log.debug('%s %s : %.1f%% with %fs' % (_dec, func_timed[0], func_timed[1] * factor, func_timed[1]))
]:
	i: 0(t)
	o: 313()

nname: 0
n 0(_decal < len(_call_queue))[_call_queue.append(list())
log.debug('%s %s called' % (_prefix + '>', f.func_name))
if res > self.limit:
	log.debug('%s %s executed in %fs' % (_prefix, f.func_name, res))
_call_queue[_decal - 1].append((f.func_name, res))
]:
	i: 
	o: 246(t), 327(f)

nname: 327
n 327(None)[return f_result
]:
	i: 246(), 0(f)
	o: 

nname: 246
n 246(None)[for func_timed in _call_queue[_decal]:
	log.debug('%s %s : %.1f%% with %fs' % (_dec, func_timed[0], func_timed[1] * factor, func_timed[1]))
_call_queue.pop()
]:
	i: 0(t)
	o: 327()

nname: 0
n 0(_decal < len(_call_queue))[_call_queue.append(list())
log.debug('%s %s called' % (_prefix + '>', f.func_name))
if res > self.limit:
	log.debug('%s %s executed in %fs' % (_prefix, f.func_name, res))
_call_queue[_decal - 1].append((f.func_name, res))
]:
	i: 
	o: 246(t), 327(f)

nname: 0
n 0(None)[_call_queue.append(list())
log.debug('%s %s called' % (_prefix + '>', f.func_name))
if res > self.limit:
	log.debug('%s %s executed in %fs' % (_prefix, f.func_name, res))
_call_queue[_decal - 1].append((f.func_name, res))
if _decal < len(_call_queue):
	for func_timed in _call_queue[_decal]:
		log.debug('%s %s : %.1f%% with %fs' % (_dec, func_timed[0], func_timed[1] * factor, func_timed[1]))
	_call_queue.pop()
return f_result
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb754f14c>}
nname: 64
n 64(None)[]:
	i: 13(), 59()
	o: 

nname: 59
n 59(None)[return f
]:
	i: 0(f)
	o: 64()

nname: 13
n 13(None)[log.debug('trace call for %s' % f.func_name)
def measure(*args, **args):
	_call_queue.append(list())
	log.debug('%s %s called' % (_prefix + '>', f.func_name))
	if res > self.limit:
		log.debug('%s %s executed in %fs' % (_prefix, f.func_name, res))
	_call_queue[_decal - 1].append((f.func_name, res))
	if _decal < len(_call_queue):
		for func_timed in _call_queue[_decal]:
			log.debug('%s %s : %.1f%% with %fs' % (_dec, func_timed[0], func_timed[1] * factor, func_timed[1]))
		_call_queue.pop()
	return f_result

return measure
]:
	i: 0(t)
	o: 64()

nname: 0
n 0(self.aspects & WHAT_TO_CHRONO)[]:
	i: 
	o: 13(t), 59(f)

nname: 0
n 0(None)[if self.aspects & WHAT_TO_CHRONO:
	log.debug('trace call for %s' % f.func_name)
	def measure(*args, **args):
		_call_queue.append(list())
		log.debug('%s %s called' % (_prefix + '>', f.func_name))
		if res > self.limit:
			log.debug('%s %s executed in %fs' % (_prefix, f.func_name, res))
		_call_queue[_decal - 1].append((f.func_name, res))
		if _decal < len(_call_queue):
			for func_timed in _call_queue[_decal]:
				log.debug('%s %s : %.1f%% with %fs' % (_dec, func_timed[0], func_timed[1] * factor, func_timed[1]))
			_call_queue.pop()
		return f_result

	return measure
else:
	return f
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb753df2c>}
nname: 6
n 6(None)[__doc__ = " Decorator which helps to control what aspects of a program to debug\n    on per-function basis. Aspects are provided as list of arguments.\n    It DOESN'T slowdown functions which aren't supposed to be debugged.\n    example:\n        @Chrono(['johan'])\n        def func_to_measure(*args, **kwargs):\n            ...\n\n        --> DEBUG : func_to_measure executed in ...s\n    "
def __init__(self, aspects=None, limit=0):
	self.aspects = set(aspects)
	self.limit = 0

def __call__(self, f):
	if self.aspects & WHAT_TO_CHRONO:
		log.debug('trace call for %s' % f.func_name)
		def measure(*args, **args):
			_call_queue.append(list())
			log.debug('%s %s called' % (_prefix + '>', f.func_name))
			if res > self.limit:
				log.debug('%s %s executed in %fs' % (_prefix, f.func_name, res))
			_call_queue[_decal - 1].append((f.func_name, res))
			if _decal < len(_call_queue):
				for func_timed in _call_queue[_decal]:
					log.debug('%s %s : %.1f%% with %fs' % (_dec, func_timed[0], func_timed[1] * factor, func_timed[1]))
				_call_queue.pop()
			return f_result

		return measure
	else:
		return f

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb752fdcc>}
nname: 0
n 0(None)[now = time()
logger.debug('TIMESTEP: %s %.3f' % (what, now - __ts))
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb752f34c>}
nname: 46
n 46(None)[return None
]:
	i: 35(), 45()
	o: 

nname: 45
n 45(None)[]:
	i: 23(f)
	o: 46()

nname: 35
n 35(None)[]:
	i: 23(t)
	o: 46()

nname: 23
n 23(r is not None)[]:
	i: 12(), 22()
	o: 35(t), 45(f)

nname: 22
n 22(None)[]:
	i: 0(f)
	o: 23()

nname: 12
n 12(None)[]:
	i: 0(t)
	o: 23()

nname: 0
n 0(n is not None)[]:
	i: 
	o: 12(t), 22(f)

nname: 46
n 46(None)[return None
]:
	i: 0()
	o: 

nname: 0
n 0(None)[if n is not None:
	pass
if r is not None:
	pass
]:
	i: 
	o: 46()

nname: 0
n 0(None)[if n is not None:
	pass
if r is not None:
	pass
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb752fd8c>}
nname: 306
n 306(None)[return None
]:
	i: 206(AL), 305()
	o: 

nname: 305
n 305(None)[]:
	i: 249(AF), 256()
	o: 306()

nname: 256
n 256(None)[print '%s: %s (%.1f%%) (%fms/call)' % (expr, score, 100 * score / reference, score * 1000 / total_iterations)
]:
	i: 249(for)
	o: 305()

nname: 249
n 249(None)[]:
	i: 206(loop)
	o: 256(for), 305(AF)

nname: 206
n 206(None)[del _[1]
for score_expr_list in scores_dict.iteritems():
score_expr_list.sort()
]:
	i: 156(AF), 181()
	o: 249(loop), 306(AL)

nname: 181
n 181(None)[]:
	i: 156(for)
	o: 206()

nname: 156
n 156(None)[print '\nScores (bigger is slower):\n'
]:
	i: 38(AL), 155()
	o: 181(for), 206(AF)

nname: 155
n 155(None)[]:
	i: 41(AF), 48()
	o: 156()

nname: 48
n 48(None)[_[1], reference, total_iterations, score, expr, k, v, expression, setup = [], score_expr_list[0][0], bench_repeat * bench_number, score_expr_list, score_expr_list, scores_dict.iteritems(), scores_dict.iteritems(), expression_setup_list, expression_setup_list
sys.stdout.write('%s..' % expression)
sys.stdout.flush()
v = sum(timeit.Timer(expression, setup).repeat(bench_repeat, bench_number))
scores_dict[expression] = v
sys.stdout.write('.')
]:
	i: 41(for)
	o: 155()

nname: 41
n 41(None)[]:
	i: 38(loop)
	o: 48(for), 155(AF)

nname: 38
n 38(None)[]:
	i: 21(), 37()
	o: 41(loop), 156(AL)

nname: 37
n 37(None)[]:
	i: 0(f)
	o: 38()

nname: 21
n 21(None)[expression_setup_list = [expression_setup_list, prepare]
]:
	i: 0(t)
	o: 38()

nname: 0
n 0(prepare is not None)[scores_dict = dict()
]:
	i: 
	o: 21(t), 37(f)

nname: 306
n 306(None)[return None
]:
	i: 256()
	o: 

nname: 256
n 256(None)[print '%s: %s (%.1f%%) (%fms/call)' % (expr, score, 100 * score / reference, score * 1000 / total_iterations)
	pass]:
	i: 206(for)
	o: 306()

nname: 206
n 206(None)[del _[1]
for score_expr_list in scores_dict.iteritems():
score_expr_list.sort()
]:
	i: 155(AF), 155(for)
	o: 256(for)

nname: 155
n 155(None)[print '\nScores (bigger is slower):\n'
]:
	i: 41()
	o: 206(AF)

nname: 41
n 41(None)[_[1], reference, total_iterations, score, expr, k, v, expression, setup = [], score_expr_list[0][0], bench_repeat * bench_number, score_expr_list, score_expr_list, scores_dict.iteritems(), scores_dict.iteritems(), expression_setup_list, expression_setup_list
	sys.stdout.write('%s..' % expression)
	sys.stdout.flush()
	v = sum(timeit.Timer(expression, setup).repeat(bench_repeat, bench_number))
	scores_dict[expression] = v
	sys.stdout.write('.')
]:
	i: 0(loop)
	o: 155()

nname: 0
n 0(None)[scores_dict = dict()
if prepare is not None:
	expression_setup_list = [expression_setup_list, prepare]
]:
	i: 
	o: 41(loop)

nname: 306
n 306(None)[return None
]:
	i: 206()
	o: 

nname: 206
n 206(None)[del _[1]
for score_expr_list in scores_dict.iteritems():
score_expr_list.sort()
print '%s: %s (%.1f%%) (%fms/call)' % (expr, score, 100 * score / reference, score * 1000 / total_iterations)
	pass]:
	i: 155(AF), 155(for)
	o: 306()

nname: 155
n 155(None)[print '\nScores (bigger is slower):\n'
]:
	i: 0()
	o: 206(AF)

nname: 0
n 0(None)[scores_dict = dict()
if prepare is not None:
	expression_setup_list = [expression_setup_list, prepare]
_[1], reference, total_iterations, score, expr, k, v, expression, setup = [], score_expr_list[0][0], bench_repeat * bench_number, score_expr_list, score_expr_list, scores_dict.iteritems(), scores_dict.iteritems(), expression_setup_list, expression_setup_list
	sys.stdout.write('%s..' % expression)
	sys.stdout.flush()
	v = sum(timeit.Timer(expression, setup).repeat(bench_repeat, bench_number))
	scores_dict[expression] = v
	sys.stdout.write('.')
]:
	i: 
	o: 155()

nname: 206
n 206(None)[del _[1]
for score_expr_list in scores_dict.iteritems():
score_expr_list.sort()
print '%s: %s (%.1f%%) (%fms/call)' % (expr, score, 100 * score / reference, score * 1000 / total_iterations)
	passreturn None
]:
	i: 0(AF)
	o: 

nname: 0
n 0(None)[scores_dict = dict()
if prepare is not None:
	expression_setup_list = [expression_setup_list, prepare]
_[1], reference, total_iterations, score, expr, k, v, expression, setup = [], score_expr_list[0][0], bench_repeat * bench_number, score_expr_list, score_expr_list, scores_dict.iteritems(), scores_dict.iteritems(), expression_setup_list, expression_setup_list
	sys.stdout.write('%s..' % expression)
	sys.stdout.flush()
	v = sum(timeit.Timer(expression, setup).repeat(bench_repeat, bench_number))
	scores_dict[expression] = v
	sys.stdout.write('.')
print '\nScores (bigger is slower):\n'
]:
	i: 
	o: 206(AF)

nname: 0
n 0(None)[scores_dict = dict()
if prepare is not None:
	expression_setup_list = [expression_setup_list, prepare]
_[1], reference, total_iterations, score, expr, k, v, expression, setup = [], score_expr_list[0][0], bench_repeat * bench_number, score_expr_list, score_expr_list, scores_dict.iteritems(), scores_dict.iteritems(), expression_setup_list, expression_setup_list
	sys.stdout.write('%s..' % expression)
	sys.stdout.flush()
	v = sum(timeit.Timer(expression, setup).repeat(bench_repeat, bench_number))
	scores_dict[expression] = v
	sys.stdout.write('.')
print '\nScores (bigger is slower):\n'
del _[1]
for score_expr_list in scores_dict.iteritems():
score_expr_list.sort()
print '%s: %s (%.1f%%) (%fms/call)' % (expr, score, 100 * score / reference, score * 1000 / total_iterations)
	passreturn None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75452cc>}
nname: 0
n 0(None)[set_bench_values(100, 10000)
print "Legend:\n    p_time = python library's time.time\n    g_time = python library's time.gmtime\n    l_time = python library's time.localtime\n    c_time = peewee's clock_gettime wrapper\n    clock = python library's time.clock\n    "
benchmark((('p_time()', 'from time import time as p_time'), ('g_time()', 'from time import gmtime as g_time'), ('l_time()', 'from time import localtime as l_time'), ('c_time()', 'from peewee.gettime import time as c_time'), ('clock()', 'from time import clock')))
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb752fd8c>}
nname: 62
n 62(None)[self.output = sys.stdout
return None
]:
	i: 48(), 55()
	o: 

nname: 55
n 55(None)[]:
	i: 0(f)
	o: 62()

nname: 48
n 48(None)[]:
	i: 0(t)
	o: 62()

nname: 0
n 0(output is not None)[self.file = file
self.name = name
self.pathname = pathname
self.desc = desc
]:
	i: 
	o: 48(t), 55(f)

nname: 0
n 0(None)[self.file = file
self.name = name
self.pathname = pathname
self.desc = desc
if output is not None:
	pass
self.output = sys.stdout
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb753d86c>}
nname: 167
n 167(None)[sys.modules[fullname] = mod
return mod
]:
	i: 166(AE)
	o: 

nname: 166
n 166(None)[]:
	i: 148(), 165()
	o: 167(AE)

nname: 165
n 165(None)[]:
	i: 139(f)
	o: 166()

nname: 148
n 148(None)[self.file.close()
]:
	i: 139(t)
	o: 166()

nname: 139
n 139(self.file)[]:
	i: 0(finally), 135()
	o: 148(t), 165(f)

nname: 135
n 135(None)[]:
	i: 6(), 122(), 134(AE)
	o: 139()

nname: 122
n 122(None)[mod = None
]:
	i: 3(except)
	o: 135()

nname: 6
n 6(None)[t_init = time()
mod = imp.load_module(self.name, self.file, self.pathname, self.desc)
t_fin = time() - t_init
self.output.write('-> %s ( %.4f sec ) --- %s\n' % (fullname, t_fin, self.pathname))
VerboseImporter.imported.append((fullname, t_fin))
]:
	i: 3(try)
	o: 135()

nname: 3
n 3(None)[]:
	i: 0(ASF)
	o: 6(try), 122(except)

nname: 0
n 0(None)[]:
	i: 
	o: 3(ASF2), 139(finally)

nname: 167
n 167(None)[sys.modules[fullname] = mod
return mod
]:
	i: 139(AE)
	o: 

nname: 139
n 139(None)[if self.file:
	self.file.close()
]:
	i: 0(finally), 122()
	o: 167(AE)

nname: 122
n 122(None)[except:
	mod = None
]:
	i: 3()
	o: 139()

nname: 3
n 3(None)[try:
	t_init = time()
	mod = imp.load_module(self.name, self.file, self.pathname, self.desc)
	t_fin = time() - t_init
	self.output.write('-> %s ( %.4f sec ) --- %s\n' % (fullname, t_fin, self.pathname))
	VerboseImporter.imported.append((fullname, t_fin))
]:
	i: 0(ASF2)
	o: 122()

nname: 0
n 0(None)[]:
	i: 
	o: 3(ASF2), 139(finally)

nname: 167
n 167(None)[sys.modules[fullname] = mod
return mod
]:
	i: 139(AE)
	o: 

nname: 139
n 139(None)[if self.file:
	self.file.close()
]:
	i: 0(finally), 3()
	o: 167(AE)

nname: 3
n 3(None)[try:
	t_init = time()
	mod = imp.load_module(self.name, self.file, self.pathname, self.desc)
	t_fin = time() - t_init
	self.output.write('-> %s ( %.4f sec ) --- %s\n' % (fullname, t_fin, self.pathname))
	VerboseImporter.imported.append((fullname, t_fin))
except:
	mod = None
]:
	i: 0(ASF2)
	o: 139()

nname: 0
n 0(None)[]:
	i: 
	o: 3(ASF2), 139(finally)

nname: 139
n 139(None)[finally:
	if self.file:
		self.file.close()
sys.modules[fullname] = mod
return mod
]:
	i: 0()
	o: 

nname: 0
n 0(None)[try:
	t_init = time()
	mod = imp.load_module(self.name, self.file, self.pathname, self.desc)
	t_fin = time() - t_init
	self.output.write('-> %s ( %.4f sec ) --- %s\n' % (fullname, t_fin, self.pathname))
	VerboseImporter.imported.append((fullname, t_fin))
except:
	mod = None
]:
	i: 
	o: 139()

nname: 0
n 0(None)[try:
	t_init = time()
	mod = imp.load_module(self.name, self.file, self.pathname, self.desc)
	t_fin = time() - t_init
	self.output.write('-> %s ( %.4f sec ) --- %s\n' % (fullname, t_fin, self.pathname))
	VerboseImporter.imported.append((fullname, t_fin))
except:
	mod = None
finally:
	if self.file:
		self.file.close()
sys.modules[fullname] = mod
return mod
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7545a4c>}
nname: 6
n 6(None)[__doc__ = ' The loader takes a name and info about the module to load and\n        "loads" it - in this case write to definied output some data, such as\n        module name, time taken to import it.\n    '
def __init__(self, name, file, pathname, desc, output=None):
	self.file = file
	self.name = name
	self.pathname = pathname
	self.desc = desc
	if output is not None:
		pass
	self.output = sys.stdout
	return None

def load_module(self, fullname):
	try:
		t_init = time()
		mod = imp.load_module(self.name, self.file, self.pathname, self.desc)
		t_fin = time() - t_init
		self.output.write('-> %s ( %.4f sec ) --- %s\n' % (fullname, t_fin, self.pathname))
		VerboseImporter.imported.append((fullname, t_fin))
	except:
		mod = None
	finally:
		if self.file:
			self.file.close()
	sys.modules[fullname] = mod
	return mod

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb752fdec>}
nname: 67
n 67(None)[self.report_output = sys.stdout
self.report_threshold = report_threshold
return None
]:
	i: 53(), 60()
	o: 

nname: 60
n 60(None)[]:
	i: 26(f)
	o: 67()

nname: 53
n 53(None)[]:
	i: 26(t)
	o: 67()

nname: 26
n 26(report_output is not None)[self.output = sys.stdout
self.report = report
]:
	i: 12(), 19()
	o: 53(t), 60(f)

nname: 19
n 19(None)[]:
	i: 0(f)
	o: 26()

nname: 12
n 12(None)[]:
	i: 0(t)
	o: 26()

nname: 0
n 0(output is not None)[]:
	i: 
	o: 12(t), 19(f)

nname: 67
n 67(None)[self.report_output = sys.stdout
self.report_threshold = report_threshold
return None
]:
	i: 0()
	o: 

nname: 0
n 0(None)[if output is not None:
	pass
self.output = sys.stdout
self.report = report
if report_output is not None:
	pass
]:
	i: 
	o: 67()

nname: 0
n 0(None)[if output is not None:
	pass
self.output = sys.stdout
self.report = report
if report_output is not None:
	pass
self.report_output = sys.stdout
self.report_threshold = report_threshold
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb753d8cc>}
nname: 0
n 0(None)[sys.meta_path.append(self)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb753dc2c>}
nname: 191
n 191(None)[]:
	i: 178(), 190()
	o: 

nname: 190
n 190(None)[]:
	i: 0&34(f)
	o: 191()

nname: 178
n 178(None)[VerboseImporter.imported = []
]:
	i: 41(AL), 177()
	o: 191()

nname: 177
n 177(None)[]:
	i: 76(AF), 173()
	o: 178()

nname: 173
n 173(None)[]:
	i: 107(f), 126()
	o: 177()

nname: 126
n 126(None)[output.write('| %s %.4f\n' % (elt[0].ljust(50, '.'), elt[1]))
continue
]:
	i: 107(t)
	o: 173()

nname: 107
n 107(elt[1] > threshold)[for elt in sorted(l, key=itemgetter(1), reverse=True):
]:
	i: 76(for)
	o: 126(t), 173(f)

nname: 76
n 76(None)[]:
	i: 41(loop)
	o: 107(for), 177(AF)

nname: 41
n 41(None)[output = self.report_output
threshold = self.report_threshold
output.write('\n\n##########################\nIMPORTS REPORTING\n\n')
]:
	i: 0&34(t)
	o: 76(loop), 178(AL)

nname: 0&34
n 0&34(self.report and l)[sys.meta_path.remove(self)
l = VerboseImporter.imported
]:
	i: 
	o: 41(t), 190(f)

nname: 191
n 191(None)[]:
	i: 178(), 0&34(f)
	o: 

nname: 178
n 178(None)[VerboseImporter.imported = []
]:
	i: 41(AL), 76(AF), 107()
	o: 191()

nname: 107
n 107(None)[for elt in sorted(l, key=itemgetter(1), reverse=True):
if elt[1] > threshold:
	output.write('| %s %.4f\n' % (elt[0].ljust(50, '.'), elt[1]))
	continue
]:
	i: 76(for)
	o: 178()

nname: 76
n 76(None)[]:
	i: 41(loop)
	o: 107(for), 178(AF)

nname: 41
n 41(None)[output = self.report_output
threshold = self.report_threshold
output.write('\n\n##########################\nIMPORTS REPORTING\n\n')
]:
	i: 0&34(t)
	o: 76(loop), 178(AL)

nname: 0&34
n 0&34(self.report and l)[sys.meta_path.remove(self)
l = VerboseImporter.imported
]:
	i: 
	o: 41(t), 191(f)

nname: 191
n 191(None)[]:
	i: 107(), 0&34(f)
	o: 

nname: 107
n 107(None)[for elt in sorted(l, key=itemgetter(1), reverse=True):
	if elt[1] > threshold:
		output.write('| %s %.4f\n' % (elt[0].ljust(50, '.'), elt[1]))
		continue
VerboseImporter.imported = []
]:
	i: 41(for)
	o: 191()

nname: 41
n 41(None)[output = self.report_output
threshold = self.report_threshold
output.write('\n\n##########################\nIMPORTS REPORTING\n\n')
]:
	i: 0&34(t)
	o: 107(for)

nname: 0&34
n 0&34(self.report and l)[sys.meta_path.remove(self)
l = VerboseImporter.imported
]:
	i: 
	o: 41(t), 191(f)

nname: 191
n 191(None)[]:
	i: 41(), 0&34(f)
	o: 

nname: 41
n 41(None)[output = self.report_output
threshold = self.report_threshold
output.write('\n\n##########################\nIMPORTS REPORTING\n\n')
for elt in sorted(l, key=itemgetter(1), reverse=True):
	if elt[1] > threshold:
		output.write('| %s %.4f\n' % (elt[0].ljust(50, '.'), elt[1]))
		continue
VerboseImporter.imported = []
]:
	i: 0&34(t)
	o: 191()

nname: 0&34
n 0&34(self.report and l)[sys.meta_path.remove(self)
l = VerboseImporter.imported
]:
	i: 
	o: 41(t), 191(f)

nname: 0&34
n 0&34(None)[sys.meta_path.remove(self)
l = VerboseImporter.imported
if self.report and l:
	output = self.report_output
	threshold = self.report_threshold
	output.write('\n\n##########################\nIMPORTS REPORTING\n\n')
	for elt in sorted(l, key=itemgetter(1), reverse=True):
		if elt[1] > threshold:
			output.write('| %s %.4f\n' % (elt[0].ljust(50, '.'), elt[1]))
			continue
	VerboseImporter.imported = []
]:
	i: 
	o: 

self.nodes: {'0&34': <unpyclib.structure.node instance at 0xb754548c>}
nname: 279
n 279(None)[return None
]:
	i: 200(), 266(), 277(AE)
	o: 

nname: 277
n 277(None)[]:
	i: 256(f)
	o: 279(AE)

nname: 266
n 266(None)[return None
]:
	i: 256(t)
	o: 279()

nname: 256
n 256(<dummy_ex3> EXC_MATCH ImportError)[]:
	i: 197(except)
	o: 266(t), 277(f)

nname: 200
n 200(None)[file, pathname, desc = imp.find_module(fullname, path)
return VerboseLoader(origName, file, pathname, desc, self.output)
]:
	i: 197(try)
	o: 279()

nname: 197
n 197(None)[]:
	i: 179(JA), 192(), 196()
	o: 200(try), 256(except)

nname: 196
n 196(None)[]:
	i: 85(f)
	o: 197()

nname: 192
n 192(None)[]:
	i: 164(f)
	o: 197()

nname: 179
n 179(None)[path = mod.__path__
]:
	i: 164(t)
	o: 197(JA)

nname: 164
n 164(hasattr(mod, '__path__'))[]:
	i: 155(), 163()
	o: 179(t), 192(f)

nname: 163
n 163(None)[]:
	i: 97(f)
	o: 164()

nname: 155
n 155(None)[return None
]:
	i: 97(t)
	o: 164()

nname: 97
n 97(mod is None)[head, fullname = fullname.rsplit('.', 1)
mod = sys.modules.get(head, None)
]:
	i: 85(t)
	o: 155(t), 163(f)

nname: 85
n 85('.' in fullname)[]:
	i: 72(JA), 80(), 84()
	o: 97(t), 196(f)

nname: 84
n 84(None)[]:
	i: 0(t)
	o: 85()

nname: 80
n 80(None)[]:
	i: 12&46&53(f)
	o: 85()

nname: 72
n 72(None)[return mod
]:
	i: 12&46&53(t)
	o: 85(JA)

nname: 12&46&53
n 12&46&53(mod is None or mod and isinstance(mod, types.ModuleType))[mod = sys.modules.get(fullname, False)
]:
	i: 0(f)
	o: 72(t), 80(f)

nname: 0
n 0(path)[origName = fullname
]:
	i: 
	o: 12&46&53(f), 84(t)

nname: 256
n 256(None)[except ImportError:
	return None
return None
]:
	i: 197()
	o: 

nname: 197
n 197(None)[try:
	file, pathname, desc = imp.find_module(fullname, path)
	return VerboseLoader(origName, file, pathname, desc, self.output)
]:
	i: 97(JA), 0(f)
	o: 256()

nname: 97
n 97(None)[head, fullname = fullname.rsplit('.', 1)
mod = sys.modules.get(head, None)
if mod is None:
	return None
if hasattr(mod, '__path__'):
	path = mod.__path__
]:
	i: 0(t)
	o: 197(JA)

nname: 0
n 0('.' in fullname)[origName = fullname
if not path:
	mod = sys.modules.get(fullname, False)
	if mod is None or mod and isinstance(mod, types.ModuleType):
		return mod
]:
	i: 
	o: 97(t), 197(f)

nname: 256
n 256(None)[except ImportError:
	return None
return None
]:
	i: 0()
	o: 

nname: 0
n 0(None)[origName = fullname
if not path:
	mod = sys.modules.get(fullname, False)
	if mod is None or mod and isinstance(mod, types.ModuleType):
		return mod
if '.' in fullname:
	head, fullname = fullname.rsplit('.', 1)
	mod = sys.modules.get(head, None)
	if mod is None:
		return None
	if hasattr(mod, '__path__'):
		path = mod.__path__
try:
	file, pathname, desc = imp.find_module(fullname, path)
	return VerboseLoader(origName, file, pathname, desc, self.output)
]:
	i: 
	o: 256()

nname: 0
n 0(None)[origName = fullname
if not path:
	mod = sys.modules.get(fullname, False)
	if mod is None or mod and isinstance(mod, types.ModuleType):
		return mod
if '.' in fullname:
	head, fullname = fullname.rsplit('.', 1)
	mod = sys.modules.get(head, None)
	if mod is None:
		return None
	if hasattr(mod, '__path__'):
		path = mod.__path__
try:
	file, pathname, desc = imp.find_module(fullname, path)
	return VerboseLoader(origName, file, pathname, desc, self.output)
except ImportError:
	return None
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7545ecc>}
nname: 6
n 6(None)[imported = []
def __init__(self, output=None, report=True, report_output=None, report_threshold=0.10000000000000001):
	if output is not None:
		pass
	self.output = sys.stdout
	self.report = report
	if report_output is not None:
		pass
	self.report_output = sys.stdout
	self.report_threshold = report_threshold
	return None

def __enter__(self):
	sys.meta_path.append(self)

def __exit__(self, exc_type, exc_val, exc_tb):
	sys.meta_path.remove(self)
	l = VerboseImporter.imported
	if self.report and l:
		output = self.report_output
		threshold = self.report_threshold
		output.write('\n\n##########################\nIMPORTS REPORTING\n\n')
		for elt in sorted(l, key=itemgetter(1), reverse=True):
			if elt[1] > threshold:
				output.write('| %s %.4f\n' % (elt[0].ljust(50, '.'), elt[1]))
				continue
		VerboseImporter.imported = []

def find_module(self, fullname, path=None):
	origName = fullname
	if not path:
		mod = sys.modules.get(fullname, False)
		if mod is None or mod and isinstance(mod, types.ModuleType):
			return mod
	if '.' in fullname:
		head, fullname = fullname.rsplit('.', 1)
		mod = sys.modules.get(head, None)
		if mod is None:
			return None
		if hasattr(mod, '__path__'):
			path = mod.__path__
	try:
		file, pathname, desc = imp.find_module(fullname, path)
		return VerboseLoader(origName, file, pathname, desc, self.output)
	except ImportError:
		return None
	return None

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb7539fec>}
nname: 0
n 0(None)[sys.meta_path.append(VerboseImporter(output, report, report_output, report_threshold))
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb752fcac>}
nname: 0
n 0(None)[self.stop_trace = stop_trace
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb752f62c>}
DFADecompile Exception need more than 0 values to unpack
nname: 102
n 102(None)[102]:
	i: 97(AE)
	o: 

nname: 97
n 97(None)[return res
]:
	i: 0(finally), 19()
	o: 102(AE)

nname: 19
n 19(None)[res = f(*args, **kwds)
open(os.path.join('/tmp', '%s.dot' % f.__name__), 'w').write(pycallgraph.get_dot(stop=self.stop_trace))
]:
	i: 0(ASF)
	o: 97()

nname: 0
n 0(None)[res = None
pycallgraph.start_trace()
]:
	i: 
	o: 19(ASF), 97(finally)

nname: 97
n 97(None)[finally:
	return res
102]:
	i: 0()
	o: 

nname: 0
n 0(None)[res = None
pycallgraph.start_trace()
try:
	res = f(*args, **kwds)
	open(os.path.join('/tmp', '%s.dot' % f.__name__), 'w').write(pycallgraph.get_dot(stop=self.stop_trace))
]:
	i: 
	o: 97()

nname: 0
n 0(None)[res = None
pycallgraph.start_trace()
try:
	res = f(*args, **kwds)
	open(os.path.join('/tmp', '%s.dot' % f.__name__), 'w').write(pycallgraph.get_dot(stop=self.stop_trace))
finally:
	return res
102]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75397ac>}
nname: 0
n 0(None)[def trace(*args, **args):
	res = None
	pycallgraph.start_trace()
	try:
		res = f(*args, **kwds)
		open(os.path.join('/tmp', '%s.dot' % f.__name__), 'w').write(pycallgraph.get_dot(stop=self.stop_trace))
	finally:
		return res
	102
return trace
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb752f3ac>}
nname: 6
n 6(None)[__doc__ = '\n        @CallGraph(stop_trace=True)\n        def test_func(*args, **kw):\n            ...\n\n        write a file called /tmp/test_func.dot containing the call graph of\n        decorated function.\n        To obtain a more readable view of this file, you can use the dot utility on your own PC:\n            "dot -Tjpg/png/gif/ps -oyour_file /tmp/test_func.dot"\n        N.B : dot utility is a part of the GraphViz project.\n\n\n        pycallgraph can be installed by easy_install (pure python -> works with sh4):\n             easy_install pycallgraph\n        '
def __init__(self, stop_trace=True):
	self.stop_trace = stop_trace

def __call__(self, f):
	def trace(*args, **args):
		res = None
		pycallgraph.start_trace()
		try:
			res = f(*args, **kwds)
			open(os.path.join('/tmp', '%s.dot' % f.__name__), 'w').write(pycallgraph.get_dot(stop=self.stop_trace))
		finally:
			return res
		102
	return trace

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb752fc4c>}
nname: 555
n 555(None)[]:
	i: 543(), 554()
	o: 

nname: 554
n 554(None)[]:
	i: 170(f)
	o: 555()

nname: 543
n 543(None)[test_benchmark()
]:
	i: 170(t)
	o: 555()

nname: 170
n 170(__name__ == '__main__')[from time import time
WHAT_TO_CHRONO = set(['wyrecord', 'wyscan', 'gui', 'dvd', 'actions', 'wymedia'])
class Chrono(object):
	__doc__ = " Decorator which helps to control what aspects of a program to debug\n    on per-function basis. Aspects are provided as list of arguments.\n    It DOESN'T slowdown functions which aren't supposed to be debugged.\n    example:\n        @Chrono(['johan'])\n        def func_to_measure(*args, **kwargs):\n            ...\n\n        --> DEBUG : func_to_measure executed in ...s\n    "
	def __init__(self, aspects=None, limit=0):
		self.aspects = set(aspects)
		self.limit = 0

	def __call__(self, f):
		if self.aspects & WHAT_TO_CHRONO:
			log.debug('trace call for %s' % f.func_name)
			def measure(*args, **args):
				_call_queue.append(list())
				log.debug('%s %s called' % (_prefix + '>', f.func_name))
				if res > self.limit:
					log.debug('%s %s executed in %fs' % (_prefix, f.func_name, res))
				_call_queue[_decal - 1].append((f.func_name, res))
				if _decal < len(_call_queue):
					for func_timed in _call_queue[_decal]:
						log.debug('%s %s : %.1f%% with %fs' % (_dec, func_timed[0], func_timed[1] * factor, func_timed[1]))
					_call_queue.pop()
				return f_result

			return measure
		else:
			return f



def timestep(what='step', logger=log):
	now = time()
	logger.debug('TIMESTEP: %s %.3f' % (what, now - __ts))

import sys
import timeit
def set_bench_values(r=None, n=None):
	if n is not None:
		pass
	if r is not None:
		pass
	return None

def benchmark(expression_setup_list, prepare=None):
	scores_dict = dict()
	if prepare is not None:
		expression_setup_list = [expression_setup_list, prepare]
	_[1], reference, total_iterations, score, expr, k, v, expression, setup = [], score_expr_list[0][0], bench_repeat * bench_number, score_expr_list, score_expr_list, scores_dict.iteritems(), scores_dict.iteritems(), expression_setup_list, expression_setup_list
		sys.stdout.write('%s..' % expression)
		sys.stdout.flush()
		v = sum(timeit.Timer(expression, setup).repeat(bench_repeat, bench_number))
		scores_dict[expression] = v
		sys.stdout.write('.')
	print '\nScores (bigger is slower):\n'
	del _[1]
	for score_expr_list in scores_dict.iteritems():
	score_expr_list.sort()
	print '%s: %s (%.1f%%) (%fms/call)' % (expr, score, 100 * score / reference, score * 1000 / total_iterations)
		passreturn None

def test_benchmark():
	set_bench_values(100, 10000)
	print "Legend:\n    p_time = python library's time.time\n    g_time = python library's time.gmtime\n    l_time = python library's time.localtime\n    c_time = peewee's clock_gettime wrapper\n    clock = python library's time.clock\n    "
	benchmark((('p_time()', 'from time import time as p_time'), ('g_time()', 'from time import gmtime as g_time'), ('l_time()', 'from time import localtime as l_time'), ('c_time()', 'from peewee.gettime import time as c_time'), ('clock()', 'from time import clock')))

import imp
import types
from operator import itemgetter
class VerboseLoader(object):
	__doc__ = ' The loader takes a name and info about the module to load and\n        "loads" it - in this case write to definied output some data, such as\n        module name, time taken to import it.\n    '
	def __init__(self, name, file, pathname, desc, output=None):
		self.file = file
		self.name = name
		self.pathname = pathname
		self.desc = desc
		if output is not None:
			pass
		self.output = sys.stdout
		return None

	def load_module(self, fullname):
		try:
			t_init = time()
			mod = imp.load_module(self.name, self.file, self.pathname, self.desc)
			t_fin = time() - t_init
			self.output.write('-> %s ( %.4f sec ) --- %s\n' % (fullname, t_fin, self.pathname))
			VerboseImporter.imported.append((fullname, t_fin))
		except:
			mod = None
		finally:
			if self.file:
				self.file.close()
		sys.modules[fullname] = mod
		return mod



class VerboseImporter(object):
	imported = []
	def __init__(self, output=None, report=True, report_output=None, report_threshold=0.10000000000000001):
		if output is not None:
			pass
		self.output = sys.stdout
		self.report = report
		if report_output is not None:
			pass
		self.report_output = sys.stdout
		self.report_threshold = report_threshold
		return None

	def __enter__(self):
		sys.meta_path.append(self)

	def __exit__(self, exc_type, exc_val, exc_tb):
		sys.meta_path.remove(self)
		l = VerboseImporter.imported
		if self.report and l:
			output = self.report_output
			threshold = self.report_threshold
			output.write('\n\n##########################\nIMPORTS REPORTING\n\n')
			for elt in sorted(l, key=itemgetter(1), reverse=True):
				if elt[1] > threshold:
					output.write('| %s %.4f\n' % (elt[0].ljust(50, '.'), elt[1]))
					continue
			VerboseImporter.imported = []

	def find_module(self, fullname, path=None):
		origName = fullname
		if not path:
			mod = sys.modules.get(fullname, False)
			if mod is None or mod and isinstance(mod, types.ModuleType):
				return mod
		if '.' in fullname:
			head, fullname = fullname.rsplit('.', 1)
			mod = sys.modules.get(head, None)
			if mod is None:
				return None
			if hasattr(mod, '__path__'):
				path = mod.__path__
		try:
			file, pathname, desc = imp.find_module(fullname, path)
			return VerboseLoader(origName, file, pathname, desc, self.output)
		except ImportError:
			return None
		return None



def install_importer(output=None, report=True, report_output=None, report_threshold=0.10000000000000001):
	sys.meta_path.append(VerboseImporter(output, report, report_output, report_threshold))

]:
	i: 91(), 141(), 169(AE)
	o: 543(t), 554(f)

nname: 141
n 141(None)[class CallGraph(object):
	__doc__ = '\n        @CallGraph(stop_trace=True)\n        def test_func(*args, **kw):\n            ...\n\n        write a file called /tmp/test_func.dot containing the call graph of\n        decorated function.\n        To obtain a more readable view of this file, you can use the dot utility on your own PC:\n            "dot -Tjpg/png/gif/ps -oyour_file /tmp/test_func.dot"\n        N.B : dot utility is a part of the GraphViz project.\n\n\n        pycallgraph can be installed by easy_install (pure python -> works with sh4):\n             easy_install pycallgraph\n        '
	def __init__(self, stop_trace=True):
		self.stop_trace = stop_trace

	def __call__(self, f):
		def trace(*args, **args):
			res = None
			pycallgraph.start_trace()
			try:
				res = f(*args, **kwds)
				open(os.path.join('/tmp', '%s.dot' % f.__name__), 'w').write(pycallgraph.get_dot(stop=self.stop_trace))
			finally:
				return res
			102
		return trace



]:
	i: 0(except)
	o: 170()

nname: 91
n 91(None)[import pycallgraph
import os
class CallGraph(object):
	__doc__ = '\n        @CallGraph(stop_trace=True)\n        def test_func(*args, **kw):\n            ...\n\n        write a file called /tmp/test_func.dot containing the call graph of\n        decorated function.\n        To obtain a more readable view of this file, you can use the dot utility on your own PC:\n            "dot -Tjpg/png/gif/ps -oyour_file /tmp/test_func.dot"\n        N.B : dot utility is a part of the GraphViz project.\n\n\n        pycallgraph can be installed by easy_install (pure python -> works with sh4):\n             easy_install pycallgraph\n        '
	def __init__(self, stop_trace=True):
		self.stop_trace = stop_trace

	def __call__(self, f):
		def trace(*args, **args):
			res = None
			pycallgraph.start_trace()
			try:
				res = f(*args, **kwds)
				open(os.path.join('/tmp', '%s.dot' % f.__name__), 'w').write(pycallgraph.get_dot(stop=self.stop_trace))
			finally:
				return res
			102
		return trace



]:
	i: 0(try)
	o: 170()

nname: 0
n 0(None)[from __future__ import absolute_import
from .debug import GET_LOGGER
log = GET_LOGGER('analyse')
class Cover(object):
	def start(self, main):
		print '*' * 100,
		print '\nCODE COVERAGE ANALYSIS STARTED\n',
		print '*' * 100
		import trace
		out_dir = 'wybox_code_coverage'
		out_file = '.wybox.trace'
		my_trace = trace.Trace(ignoremods=['wyvas', 'peewee'], trace=0, count=1, outfile=out_file)
		my_trace.runfunc(main)
		r = my_trace.results()
		r.write_results(show_missing=False, summary=False)
		try:
			import trace2html
			trace2html.main(['trace2html.py', '-f', out_file, '-o', out_dir])
		except Exception, e:
			print "WARNING trace2html not found : html code coverage won't be created : %s" % str(e)



class Profiler(object):
	def start(self, main):
		print '*' * 100,
		print '\nTIME PROFILER STARTED\n',
		print '*' * 100
		import hotshot
		import hotshot.stats
		my_profiler = hotshot.Profile('.wybox.prof')
		my_profiler.runcall(main)
		my_profiler.close()
		profiler_stats = hotshot.stats.load('.wybox.prof')
		profiler_stats.sort_stats('time', 'calls')
		profiler_stats.dump_stats('wybox_profiling_time_call.prof')
		profiler_stats.print_stats()



]:
	i: 
	o: 91(try), 141(except)

nname: 555
n 555(None)[]:
	i: 141()
	o: 

nname: 141
n 141(None)[except:
	class CallGraph(object):
		__doc__ = '\n        @CallGraph(stop_trace=True)\n        def test_func(*args, **kw):\n            ...\n\n        write a file called /tmp/test_func.dot containing the call graph of\n        decorated function.\n        To obtain a more readable view of this file, you can use the dot utility on your own PC:\n            "dot -Tjpg/png/gif/ps -oyour_file /tmp/test_func.dot"\n        N.B : dot utility is a part of the GraphViz project.\n\n\n        pycallgraph can be installed by easy_install (pure python -> works with sh4):\n             easy_install pycallgraph\n        '
		def __init__(self, stop_trace=True):
			self.stop_trace = stop_trace

		def __call__(self, f):
			def trace(*args, **args):
				res = None
				pycallgraph.start_trace()
				try:
					res = f(*args, **kwds)
					open(os.path.join('/tmp', '%s.dot' % f.__name__), 'w').write(pycallgraph.get_dot(stop=self.stop_trace))
				finally:
					return res
				102
			return trace



from time import time
WHAT_TO_CHRONO = set(['wyrecord', 'wyscan', 'gui', 'dvd', 'actions', 'wymedia'])
class Chrono(object):
	__doc__ = " Decorator which helps to control what aspects of a program to debug\n    on per-function basis. Aspects are provided as list of arguments.\n    It DOESN'T slowdown functions which aren't supposed to be debugged.\n    example:\n        @Chrono(['johan'])\n        def func_to_measure(*args, **kwargs):\n            ...\n\n        --> DEBUG : func_to_measure executed in ...s\n    "
	def __init__(self, aspects=None, limit=0):
		self.aspects = set(aspects)
		self.limit = 0

	def __call__(self, f):
		if self.aspects & WHAT_TO_CHRONO:
			log.debug('trace call for %s' % f.func_name)
			def measure(*args, **args):
				_call_queue.append(list())
				log.debug('%s %s called' % (_prefix + '>', f.func_name))
				if res > self.limit:
					log.debug('%s %s executed in %fs' % (_prefix, f.func_name, res))
				_call_queue[_decal - 1].append((f.func_name, res))
				if _decal < len(_call_queue):
					for func_timed in _call_queue[_decal]:
						log.debug('%s %s : %.1f%% with %fs' % (_dec, func_timed[0], func_timed[1] * factor, func_timed[1]))
					_call_queue.pop()
				return f_result

			return measure
		else:
			return f



def timestep(what='step', logger=log):
	now = time()
	logger.debug('TIMESTEP: %s %.3f' % (what, now - __ts))

import sys
import timeit
def set_bench_values(r=None, n=None):
	if n is not None:
		pass
	if r is not None:
		pass
	return None

def benchmark(expression_setup_list, prepare=None):
	scores_dict = dict()
	if prepare is not None:
		expression_setup_list = [expression_setup_list, prepare]
	_[1], reference, total_iterations, score, expr, k, v, expression, setup = [], score_expr_list[0][0], bench_repeat * bench_number, score_expr_list, score_expr_list, scores_dict.iteritems(), scores_dict.iteritems(), expression_setup_list, expression_setup_list
		sys.stdout.write('%s..' % expression)
		sys.stdout.flush()
		v = sum(timeit.Timer(expression, setup).repeat(bench_repeat, bench_number))
		scores_dict[expression] = v
		sys.stdout.write('.')
	print '\nScores (bigger is slower):\n'
	del _[1]
	for score_expr_list in scores_dict.iteritems():
	score_expr_list.sort()
	print '%s: %s (%.1f%%) (%fms/call)' % (expr, score, 100 * score / reference, score * 1000 / total_iterations)
		passreturn None

def test_benchmark():
	set_bench_values(100, 10000)
	print "Legend:\n    p_time = python library's time.time\n    g_time = python library's time.gmtime\n    l_time = python library's time.localtime\n    c_time = peewee's clock_gettime wrapper\n    clock = python library's time.clock\n    "
	benchmark((('p_time()', 'from time import time as p_time'), ('g_time()', 'from time import gmtime as g_time'), ('l_time()', 'from time import localtime as l_time'), ('c_time()', 'from peewee.gettime import time as c_time'), ('clock()', 'from time import clock')))

import imp
import types
from operator import itemgetter
class VerboseLoader(object):
	__doc__ = ' The loader takes a name and info about the module to load and\n        "loads" it - in this case write to definied output some data, such as\n        module name, time taken to import it.\n    '
	def __init__(self, name, file, pathname, desc, output=None):
		self.file = file
		self.name = name
		self.pathname = pathname
		self.desc = desc
		if output is not None:
			pass
		self.output = sys.stdout
		return None

	def load_module(self, fullname):
		try:
			t_init = time()
			mod = imp.load_module(self.name, self.file, self.pathname, self.desc)
			t_fin = time() - t_init
			self.output.write('-> %s ( %.4f sec ) --- %s\n' % (fullname, t_fin, self.pathname))
			VerboseImporter.imported.append((fullname, t_fin))
		except:
			mod = None
		finally:
			if self.file:
				self.file.close()
		sys.modules[fullname] = mod
		return mod



class VerboseImporter(object):
	imported = []
	def __init__(self, output=None, report=True, report_output=None, report_threshold=0.10000000000000001):
		if output is not None:
			pass
		self.output = sys.stdout
		self.report = report
		if report_output is not None:
			pass
		self.report_output = sys.stdout
		self.report_threshold = report_threshold
		return None

	def __enter__(self):
		sys.meta_path.append(self)

	def __exit__(self, exc_type, exc_val, exc_tb):
		sys.meta_path.remove(self)
		l = VerboseImporter.imported
		if self.report and l:
			output = self.report_output
			threshold = self.report_threshold
			output.write('\n\n##########################\nIMPORTS REPORTING\n\n')
			for elt in sorted(l, key=itemgetter(1), reverse=True):
				if elt[1] > threshold:
					output.write('| %s %.4f\n' % (elt[0].ljust(50, '.'), elt[1]))
					continue
			VerboseImporter.imported = []

	def find_module(self, fullname, path=None):
		origName = fullname
		if not path:
			mod = sys.modules.get(fullname, False)
			if mod is None or mod and isinstance(mod, types.ModuleType):
				return mod
		if '.' in fullname:
			head, fullname = fullname.rsplit('.', 1)
			mod = sys.modules.get(head, None)
			if mod is None:
				return None
			if hasattr(mod, '__path__'):
				path = mod.__path__
		try:
			file, pathname, desc = imp.find_module(fullname, path)
			return VerboseLoader(origName, file, pathname, desc, self.output)
		except ImportError:
			return None
		return None



def install_importer(output=None, report=True, report_output=None, report_threshold=0.10000000000000001):
	sys.meta_path.append(VerboseImporter(output, report, report_output, report_threshold))

if __name__ == '__main__':
	test_benchmark()
]:
	i: 0()
	o: 555()

nname: 0
n 0(None)[from __future__ import absolute_import
from .debug import GET_LOGGER
log = GET_LOGGER('analyse')
class Cover(object):
	def start(self, main):
		print '*' * 100,
		print '\nCODE COVERAGE ANALYSIS STARTED\n',
		print '*' * 100
		import trace
		out_dir = 'wybox_code_coverage'
		out_file = '.wybox.trace'
		my_trace = trace.Trace(ignoremods=['wyvas', 'peewee'], trace=0, count=1, outfile=out_file)
		my_trace.runfunc(main)
		r = my_trace.results()
		r.write_results(show_missing=False, summary=False)
		try:
			import trace2html
			trace2html.main(['trace2html.py', '-f', out_file, '-o', out_dir])
		except Exception, e:
			print "WARNING trace2html not found : html code coverage won't be created : %s" % str(e)



class Profiler(object):
	def start(self, main):
		print '*' * 100,
		print '\nTIME PROFILER STARTED\n',
		print '*' * 100
		import hotshot
		import hotshot.stats
		my_profiler = hotshot.Profile('.wybox.prof')
		my_profiler.runcall(main)
		my_profiler.close()
		profiler_stats = hotshot.stats.load('.wybox.prof')
		profiler_stats.sort_stats('time', 'calls')
		profiler_stats.dump_stats('wybox_profiling_time_call.prof')
		profiler_stats.print_stats()



try:
	import pycallgraph
	import os
	class CallGraph(object):
		__doc__ = '\n        @CallGraph(stop_trace=True)\n        def test_func(*args, **kw):\n            ...\n\n        write a file called /tmp/test_func.dot containing the call graph of\n        decorated function.\n        To obtain a more readable view of this file, you can use the dot utility on your own PC:\n            "dot -Tjpg/png/gif/ps -oyour_file /tmp/test_func.dot"\n        N.B : dot utility is a part of the GraphViz project.\n\n\n        pycallgraph can be installed by easy_install (pure python -> works with sh4):\n             easy_install pycallgraph\n        '
		def __init__(self, stop_trace=True):
			self.stop_trace = stop_trace

		def __call__(self, f):
			def trace(*args, **args):
				res = None
				pycallgraph.start_trace()
				try:
					res = f(*args, **kwds)
					open(os.path.join('/tmp', '%s.dot' % f.__name__), 'w').write(pycallgraph.get_dot(stop=self.stop_trace))
				finally:
					return res
				102
			return trace



]:
	i: 
	o: 141()

nname: 555
n 555(None)[]:
	i: 0()
	o: 

nname: 0
n 0(None)[from __future__ import absolute_import
from .debug import GET_LOGGER
log = GET_LOGGER('analyse')
class Cover(object):
	def start(self, main):
		print '*' * 100,
		print '\nCODE COVERAGE ANALYSIS STARTED\n',
		print '*' * 100
		import trace
		out_dir = 'wybox_code_coverage'
		out_file = '.wybox.trace'
		my_trace = trace.Trace(ignoremods=['wyvas', 'peewee'], trace=0, count=1, outfile=out_file)
		my_trace.runfunc(main)
		r = my_trace.results()
		r.write_results(show_missing=False, summary=False)
		try:
			import trace2html
			trace2html.main(['trace2html.py', '-f', out_file, '-o', out_dir])
		except Exception, e:
			print "WARNING trace2html not found : html code coverage won't be created : %s" % str(e)



class Profiler(object):
	def start(self, main):
		print '*' * 100,
		print '\nTIME PROFILER STARTED\n',
		print '*' * 100
		import hotshot
		import hotshot.stats
		my_profiler = hotshot.Profile('.wybox.prof')
		my_profiler.runcall(main)
		my_profiler.close()
		profiler_stats = hotshot.stats.load('.wybox.prof')
		profiler_stats.sort_stats('time', 'calls')
		profiler_stats.dump_stats('wybox_profiling_time_call.prof')
		profiler_stats.print_stats()



try:
	import pycallgraph
	import os
	class CallGraph(object):
		__doc__ = '\n        @CallGraph(stop_trace=True)\n        def test_func(*args, **kw):\n            ...\n\n        write a file called /tmp/test_func.dot containing the call graph of\n        decorated function.\n        To obtain a more readable view of this file, you can use the dot utility on your own PC:\n            "dot -Tjpg/png/gif/ps -oyour_file /tmp/test_func.dot"\n        N.B : dot utility is a part of the GraphViz project.\n\n\n        pycallgraph can be installed by easy_install (pure python -> works with sh4):\n             easy_install pycallgraph\n        '
		def __init__(self, stop_trace=True):
			self.stop_trace = stop_trace

		def __call__(self, f):
			def trace(*args, **args):
				res = None
				pycallgraph.start_trace()
				try:
					res = f(*args, **kwds)
					open(os.path.join('/tmp', '%s.dot' % f.__name__), 'w').write(pycallgraph.get_dot(stop=self.stop_trace))
				finally:
					return res
				102
			return trace



except:
	class CallGraph(object):
		__doc__ = '\n        @CallGraph(stop_trace=True)\n        def test_func(*args, **kw):\n            ...\n\n        write a file called /tmp/test_func.dot containing the call graph of\n        decorated function.\n        To obtain a more readable view of this file, you can use the dot utility on your own PC:\n            "dot -Tjpg/png/gif/ps -oyour_file /tmp/test_func.dot"\n        N.B : dot utility is a part of the GraphViz project.\n\n\n        pycallgraph can be installed by easy_install (pure python -> works with sh4):\n             easy_install pycallgraph\n        '
		def __init__(self, stop_trace=True):
			self.stop_trace = stop_trace

		def __call__(self, f):
			def trace(*args, **args):
				res = None
				pycallgraph.start_trace()
				try:
					res = f(*args, **kwds)
					open(os.path.join('/tmp', '%s.dot' % f.__name__), 'w').write(pycallgraph.get_dot(stop=self.stop_trace))
				finally:
					return res
				102
			return trace



from time import time
WHAT_TO_CHRONO = set(['wyrecord', 'wyscan', 'gui', 'dvd', 'actions', 'wymedia'])
class Chrono(object):
	__doc__ = " Decorator which helps to control what aspects of a program to debug\n    on per-function basis. Aspects are provided as list of arguments.\n    It DOESN'T slowdown functions which aren't supposed to be debugged.\n    example:\n        @Chrono(['johan'])\n        def func_to_measure(*args, **kwargs):\n            ...\n\n        --> DEBUG : func_to_measure executed in ...s\n    "
	def __init__(self, aspects=None, limit=0):
		self.aspects = set(aspects)
		self.limit = 0

	def __call__(self, f):
		if self.aspects & WHAT_TO_CHRONO:
			log.debug('trace call for %s' % f.func_name)
			def measure(*args, **args):
				_call_queue.append(list())
				log.debug('%s %s called' % (_prefix + '>', f.func_name))
				if res > self.limit:
					log.debug('%s %s executed in %fs' % (_prefix, f.func_name, res))
				_call_queue[_decal - 1].append((f.func_name, res))
				if _decal < len(_call_queue):
					for func_timed in _call_queue[_decal]:
						log.debug('%s %s : %.1f%% with %fs' % (_dec, func_timed[0], func_timed[1] * factor, func_timed[1]))
					_call_queue.pop()
				return f_result

			return measure
		else:
			return f



def timestep(what='step', logger=log):
	now = time()
	logger.debug('TIMESTEP: %s %.3f' % (what, now - __ts))

import sys
import timeit
def set_bench_values(r=None, n=None):
	if n is not None:
		pass
	if r is not None:
		pass
	return None

def benchmark(expression_setup_list, prepare=None):
	scores_dict = dict()
	if prepare is not None:
		expression_setup_list = [expression_setup_list, prepare]
	_[1], reference, total_iterations, score, expr, k, v, expression, setup = [], score_expr_list[0][0], bench_repeat * bench_number, score_expr_list, score_expr_list, scores_dict.iteritems(), scores_dict.iteritems(), expression_setup_list, expression_setup_list
		sys.stdout.write('%s..' % expression)
		sys.stdout.flush()
		v = sum(timeit.Timer(expression, setup).repeat(bench_repeat, bench_number))
		scores_dict[expression] = v
		sys.stdout.write('.')
	print '\nScores (bigger is slower):\n'
	del _[1]
	for score_expr_list in scores_dict.iteritems():
	score_expr_list.sort()
	print '%s: %s (%.1f%%) (%fms/call)' % (expr, score, 100 * score / reference, score * 1000 / total_iterations)
		passreturn None

def test_benchmark():
	set_bench_values(100, 10000)
	print "Legend:\n    p_time = python library's time.time\n    g_time = python library's time.gmtime\n    l_time = python library's time.localtime\n    c_time = peewee's clock_gettime wrapper\n    clock = python library's time.clock\n    "
	benchmark((('p_time()', 'from time import time as p_time'), ('g_time()', 'from time import gmtime as g_time'), ('l_time()', 'from time import localtime as l_time'), ('c_time()', 'from peewee.gettime import time as c_time'), ('clock()', 'from time import clock')))

import imp
import types
from operator import itemgetter
class VerboseLoader(object):
	__doc__ = ' The loader takes a name and info about the module to load and\n        "loads" it - in this case write to definied output some data, such as\n        module name, time taken to import it.\n    '
	def __init__(self, name, file, pathname, desc, output=None):
		self.file = file
		self.name = name
		self.pathname = pathname
		self.desc = desc
		if output is not None:
			pass
		self.output = sys.stdout
		return None

	def load_module(self, fullname):
		try:
			t_init = time()
			mod = imp.load_module(self.name, self.file, self.pathname, self.desc)
			t_fin = time() - t_init
			self.output.write('-> %s ( %.4f sec ) --- %s\n' % (fullname, t_fin, self.pathname))
			VerboseImporter.imported.append((fullname, t_fin))
		except:
			mod = None
		finally:
			if self.file:
				self.file.close()
		sys.modules[fullname] = mod
		return mod



class VerboseImporter(object):
	imported = []
	def __init__(self, output=None, report=True, report_output=None, report_threshold=0.10000000000000001):
		if output is not None:
			pass
		self.output = sys.stdout
		self.report = report
		if report_output is not None:
			pass
		self.report_output = sys.stdout
		self.report_threshold = report_threshold
		return None

	def __enter__(self):
		sys.meta_path.append(self)

	def __exit__(self, exc_type, exc_val, exc_tb):
		sys.meta_path.remove(self)
		l = VerboseImporter.imported
		if self.report and l:
			output = self.report_output
			threshold = self.report_threshold
			output.write('\n\n##########################\nIMPORTS REPORTING\n\n')
			for elt in sorted(l, key=itemgetter(1), reverse=True):
				if elt[1] > threshold:
					output.write('| %s %.4f\n' % (elt[0].ljust(50, '.'), elt[1]))
					continue
			VerboseImporter.imported = []

	def find_module(self, fullname, path=None):
		origName = fullname
		if not path:
			mod = sys.modules.get(fullname, False)
			if mod is None or mod and isinstance(mod, types.ModuleType):
				return mod
		if '.' in fullname:
			head, fullname = fullname.rsplit('.', 1)
			mod = sys.modules.get(head, None)
			if mod is None:
				return None
			if hasattr(mod, '__path__'):
				path = mod.__path__
		try:
			file, pathname, desc = imp.find_module(fullname, path)
			return VerboseLoader(origName, file, pathname, desc, self.output)
		except ImportError:
			return None
		return None



def install_importer(output=None, report=True, report_output=None, report_threshold=0.10000000000000001):
	sys.meta_path.append(VerboseImporter(output, report, report_output, report_threshold))

if __name__ == '__main__':
	test_benchmark()
]:
	i: 
	o: 555()

nname: 0
n 0(None)[from __future__ import absolute_import
from .debug import GET_LOGGER
log = GET_LOGGER('analyse')
class Cover(object):
	def start(self, main):
		print '*' * 100,
		print '\nCODE COVERAGE ANALYSIS STARTED\n',
		print '*' * 100
		import trace
		out_dir = 'wybox_code_coverage'
		out_file = '.wybox.trace'
		my_trace = trace.Trace(ignoremods=['wyvas', 'peewee'], trace=0, count=1, outfile=out_file)
		my_trace.runfunc(main)
		r = my_trace.results()
		r.write_results(show_missing=False, summary=False)
		try:
			import trace2html
			trace2html.main(['trace2html.py', '-f', out_file, '-o', out_dir])
		except Exception, e:
			print "WARNING trace2html not found : html code coverage won't be created : %s" % str(e)



class Profiler(object):
	def start(self, main):
		print '*' * 100,
		print '\nTIME PROFILER STARTED\n',
		print '*' * 100
		import hotshot
		import hotshot.stats
		my_profiler = hotshot.Profile('.wybox.prof')
		my_profiler.runcall(main)
		my_profiler.close()
		profiler_stats = hotshot.stats.load('.wybox.prof')
		profiler_stats.sort_stats('time', 'calls')
		profiler_stats.dump_stats('wybox_profiling_time_call.prof')
		profiler_stats.print_stats()



try:
	import pycallgraph
	import os
	class CallGraph(object):
		__doc__ = '\n        @CallGraph(stop_trace=True)\n        def test_func(*args, **kw):\n            ...\n\n        write a file called /tmp/test_func.dot containing the call graph of\n        decorated function.\n        To obtain a more readable view of this file, you can use the dot utility on your own PC:\n            "dot -Tjpg/png/gif/ps -oyour_file /tmp/test_func.dot"\n        N.B : dot utility is a part of the GraphViz project.\n\n\n        pycallgraph can be installed by easy_install (pure python -> works with sh4):\n             easy_install pycallgraph\n        '
		def __init__(self, stop_trace=True):
			self.stop_trace = stop_trace

		def __call__(self, f):
			def trace(*args, **args):
				res = None
				pycallgraph.start_trace()
				try:
					res = f(*args, **kwds)
					open(os.path.join('/tmp', '%s.dot' % f.__name__), 'w').write(pycallgraph.get_dot(stop=self.stop_trace))
				finally:
					return res
				102
			return trace



except:
	class CallGraph(object):
		__doc__ = '\n        @CallGraph(stop_trace=True)\n        def test_func(*args, **kw):\n            ...\n\n        write a file called /tmp/test_func.dot containing the call graph of\n        decorated function.\n        To obtain a more readable view of this file, you can use the dot utility on your own PC:\n            "dot -Tjpg/png/gif/ps -oyour_file /tmp/test_func.dot"\n        N.B : dot utility is a part of the GraphViz project.\n\n\n        pycallgraph can be installed by easy_install (pure python -> works with sh4):\n             easy_install pycallgraph\n        '
		def __init__(self, stop_trace=True):
			self.stop_trace = stop_trace

		def __call__(self, f):
			def trace(*args, **args):
				res = None
				pycallgraph.start_trace()
				try:
					res = f(*args, **kwds)
					open(os.path.join('/tmp', '%s.dot' % f.__name__), 'w').write(pycallgraph.get_dot(stop=self.stop_trace))
				finally:
					return res
				102
			return trace



from time import time
WHAT_TO_CHRONO = set(['wyrecord', 'wyscan', 'gui', 'dvd', 'actions', 'wymedia'])
class Chrono(object):
	__doc__ = " Decorator which helps to control what aspects of a program to debug\n    on per-function basis. Aspects are provided as list of arguments.\n    It DOESN'T slowdown functions which aren't supposed to be debugged.\n    example:\n        @Chrono(['johan'])\n        def func_to_measure(*args, **kwargs):\n            ...\n\n        --> DEBUG : func_to_measure executed in ...s\n    "
	def __init__(self, aspects=None, limit=0):
		self.aspects = set(aspects)
		self.limit = 0

	def __call__(self, f):
		if self.aspects & WHAT_TO_CHRONO:
			log.debug('trace call for %s' % f.func_name)
			def measure(*args, **args):
				_call_queue.append(list())
				log.debug('%s %s called' % (_prefix + '>', f.func_name))
				if res > self.limit:
					log.debug('%s %s executed in %fs' % (_prefix, f.func_name, res))
				_call_queue[_decal - 1].append((f.func_name, res))
				if _decal < len(_call_queue):
					for func_timed in _call_queue[_decal]:
						log.debug('%s %s : %.1f%% with %fs' % (_dec, func_timed[0], func_timed[1] * factor, func_timed[1]))
					_call_queue.pop()
				return f_result

			return measure
		else:
			return f



def timestep(what='step', logger=log):
	now = time()
	logger.debug('TIMESTEP: %s %.3f' % (what, now - __ts))

import sys
import timeit
def set_bench_values(r=None, n=None):
	if n is not None:
		pass
	if r is not None:
		pass
	return None

def benchmark(expression_setup_list, prepare=None):
	scores_dict = dict()
	if prepare is not None:
		expression_setup_list = [expression_setup_list, prepare]
	_[1], reference, total_iterations, score, expr, k, v, expression, setup = [], score_expr_list[0][0], bench_repeat * bench_number, score_expr_list, score_expr_list, scores_dict.iteritems(), scores_dict.iteritems(), expression_setup_list, expression_setup_list
		sys.stdout.write('%s..' % expression)
		sys.stdout.flush()
		v = sum(timeit.Timer(expression, setup).repeat(bench_repeat, bench_number))
		scores_dict[expression] = v
		sys.stdout.write('.')
	print '\nScores (bigger is slower):\n'
	del _[1]
	for score_expr_list in scores_dict.iteritems():
	score_expr_list.sort()
	print '%s: %s (%.1f%%) (%fms/call)' % (expr, score, 100 * score / reference, score * 1000 / total_iterations)
		passreturn None

def test_benchmark():
	set_bench_values(100, 10000)
	print "Legend:\n    p_time = python library's time.time\n    g_time = python library's time.gmtime\n    l_time = python library's time.localtime\n    c_time = peewee's clock_gettime wrapper\n    clock = python library's time.clock\n    "
	benchmark((('p_time()', 'from time import time as p_time'), ('g_time()', 'from time import gmtime as g_time'), ('l_time()', 'from time import localtime as l_time'), ('c_time()', 'from peewee.gettime import time as c_time'), ('clock()', 'from time import clock')))

import imp
import types
from operator import itemgetter
class VerboseLoader(object):
	__doc__ = ' The loader takes a name and info about the module to load and\n        "loads" it - in this case write to definied output some data, such as\n        module name, time taken to import it.\n    '
	def __init__(self, name, file, pathname, desc, output=None):
		self.file = file
		self.name = name
		self.pathname = pathname
		self.desc = desc
		if output is not None:
			pass
		self.output = sys.stdout
		return None

	def load_module(self, fullname):
		try:
			t_init = time()
			mod = imp.load_module(self.name, self.file, self.pathname, self.desc)
			t_fin = time() - t_init
			self.output.write('-> %s ( %.4f sec ) --- %s\n' % (fullname, t_fin, self.pathname))
			VerboseImporter.imported.append((fullname, t_fin))
		except:
			mod = None
		finally:
			if self.file:
				self.file.close()
		sys.modules[fullname] = mod
		return mod



class VerboseImporter(object):
	imported = []
	def __init__(self, output=None, report=True, report_output=None, report_threshold=0.10000000000000001):
		if output is not None:
			pass
		self.output = sys.stdout
		self.report = report
		if report_output is not None:
			pass
		self.report_output = sys.stdout
		self.report_threshold = report_threshold
		return None

	def __enter__(self):
		sys.meta_path.append(self)

	def __exit__(self, exc_type, exc_val, exc_tb):
		sys.meta_path.remove(self)
		l = VerboseImporter.imported
		if self.report and l:
			output = self.report_output
			threshold = self.report_threshold
			output.write('\n\n##########################\nIMPORTS REPORTING\n\n')
			for elt in sorted(l, key=itemgetter(1), reverse=True):
				if elt[1] > threshold:
					output.write('| %s %.4f\n' % (elt[0].ljust(50, '.'), elt[1]))
					continue
			VerboseImporter.imported = []

	def find_module(self, fullname, path=None):
		origName = fullname
		if not path:
			mod = sys.modules.get(fullname, False)
			if mod is None or mod and isinstance(mod, types.ModuleType):
				return mod
		if '.' in fullname:
			head, fullname = fullname.rsplit('.', 1)
			mod = sys.modules.get(head, None)
			if mod is None:
				return None
			if hasattr(mod, '__path__'):
				path = mod.__path__
		try:
			file, pathname, desc = imp.find_module(fullname, path)
			return VerboseLoader(origName, file, pathname, desc, self.output)
		except ImportError:
			return None
		return None



def install_importer(output=None, report=True, report_output=None, report_threshold=0.10000000000000001):
	sys.meta_path.append(VerboseImporter(output, report, report_output, report_threshold))

if __name__ == '__main__':
	test_benchmark()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb752f32c>}
from __future__ import absolute_import
from .debug import GET_LOGGER
log = GET_LOGGER('analyse')
class Cover(object):
	def start(self, main):
		print '*' * 100,
		print '\nCODE COVERAGE ANALYSIS STARTED\n',
		print '*' * 100
		import trace
		out_dir = 'wybox_code_coverage'
		out_file = '.wybox.trace'
		my_trace = trace.Trace(ignoremods=['wyvas', 'peewee'], trace=0, count=1, outfile=out_file)
		my_trace.runfunc(main)
		r = my_trace.results()
		r.write_results(show_missing=False, summary=False)
		try:
			import trace2html
			trace2html.main(['trace2html.py', '-f', out_file, '-o', out_dir])
		except Exception, e:
			print "WARNING trace2html not found : html code coverage won't be created : %s" % str(e)



class Profiler(object):
	def start(self, main):
		print '*' * 100,
		print '\nTIME PROFILER STARTED\n',
		print '*' * 100
		import hotshot
		import hotshot.stats
		my_profiler = hotshot.Profile('.wybox.prof')
		my_profiler.runcall(main)
		my_profiler.close()
		profiler_stats = hotshot.stats.load('.wybox.prof')
		profiler_stats.sort_stats('time', 'calls')
		profiler_stats.dump_stats('wybox_profiling_time_call.prof')
		profiler_stats.print_stats()



try:
	import pycallgraph
	import os
	class CallGraph(object):
		__doc__ = '\n        @CallGraph(stop_trace=True)\n        def test_func(*args, **kw):\n            ...\n\n        write a file called /tmp/test_func.dot containing the call graph of\n        decorated function.\n        To obtain a more readable view of this file, you can use the dot utility on your own PC:\n            "dot -Tjpg/png/gif/ps -oyour_file /tmp/test_func.dot"\n        N.B : dot utility is a part of the GraphViz project.\n\n\n        pycallgraph can be installed by easy_install (pure python -> works with sh4):\n             easy_install pycallgraph\n        '
		def __init__(self, stop_trace=True):
			self.stop_trace = stop_trace

		def __call__(self, f):
			def trace(*args, **args):
				res = None
				pycallgraph.start_trace()
				try:
					res = f(*args, **kwds)
					open(os.path.join('/tmp', '%s.dot' % f.__name__), 'w').write(pycallgraph.get_dot(stop=self.stop_trace))
				finally:
					return res
				102
			return trace



except:
	class CallGraph(object):
		__doc__ = '\n        @CallGraph(stop_trace=True)\n        def test_func(*args, **kw):\n            ...\n\n        write a file called /tmp/test_func.dot containing the call graph of\n        decorated function.\n        To obtain a more readable view of this file, you can use the dot utility on your own PC:\n            "dot -Tjpg/png/gif/ps -oyour_file /tmp/test_func.dot"\n        N.B : dot utility is a part of the GraphViz project.\n\n\n        pycallgraph can be installed by easy_install (pure python -> works with sh4):\n             easy_install pycallgraph\n        '
		def __init__(self, stop_trace=True):
			self.stop_trace = stop_trace

		def __call__(self, f):
			def trace(*args, **args):
				res = None
				pycallgraph.start_trace()
				try:
					res = f(*args, **kwds)
					open(os.path.join('/tmp', '%s.dot' % f.__name__), 'w').write(pycallgraph.get_dot(stop=self.stop_trace))
				finally:
					return res
				102
			return trace



from time import time
WHAT_TO_CHRONO = set(['wyrecord', 'wyscan', 'gui', 'dvd', 'actions', 'wymedia'])
class Chrono(object):
	__doc__ = " Decorator which helps to control what aspects of a program to debug\n    on per-function basis. Aspects are provided as list of arguments.\n    It DOESN'T slowdown functions which aren't supposed to be debugged.\n    example:\n        @Chrono(['johan'])\n        def func_to_measure(*args, **kwargs):\n            ...\n\n        --> DEBUG : func_to_measure executed in ...s\n    "
	def __init__(self, aspects=None, limit=0):
		self.aspects = set(aspects)
		self.limit = 0

	def __call__(self, f):
		if self.aspects & WHAT_TO_CHRONO:
			log.debug('trace call for %s' % f.func_name)
			def measure(*args, **args):
				_call_queue.append(list())
				log.debug('%s %s called' % (_prefix + '>', f.func_name))
				if res > self.limit:
					log.debug('%s %s executed in %fs' % (_prefix, f.func_name, res))
				_call_queue[_decal - 1].append((f.func_name, res))
				if _decal < len(_call_queue):
					for func_timed in _call_queue[_decal]:
						log.debug('%s %s : %.1f%% with %fs' % (_dec, func_timed[0], func_timed[1] * factor, func_timed[1]))
					_call_queue.pop()
				return f_result

			return measure
		else:
			return f



def timestep(what='step', logger=log):
	now = time()
	logger.debug('TIMESTEP: %s %.3f' % (what, now - __ts))

import sys
import timeit
def set_bench_values(r=None, n=None):
	if n is not None:
		pass
	if r is not None:
		pass
	return None

def benchmark(expression_setup_list, prepare=None):
	scores_dict = dict()
	if prepare is not None:
		expression_setup_list = [expression_setup_list, prepare]
	_[1], reference, total_iterations, score, expr, k, v, expression, setup = [], score_expr_list[0][0], bench_repeat * bench_number, score_expr_list, score_expr_list, scores_dict.iteritems(), scores_dict.iteritems(), expression_setup_list, expression_setup_list
		sys.stdout.write('%s..' % expression)
		sys.stdout.flush()
		v = sum(timeit.Timer(expression, setup).repeat(bench_repeat, bench_number))
		scores_dict[expression] = v
		sys.stdout.write('.')
	print '\nScores (bigger is slower):\n'
	del _[1]
	for score_expr_list in scores_dict.iteritems():
	score_expr_list.sort()
	print '%s: %s (%.1f%%) (%fms/call)' % (expr, score, 100 * score / reference, score * 1000 / total_iterations)
		passreturn None

def test_benchmark():
	set_bench_values(100, 10000)
	print "Legend:\n    p_time = python library's time.time\n    g_time = python library's time.gmtime\n    l_time = python library's time.localtime\n    c_time = peewee's clock_gettime wrapper\n    clock = python library's time.clock\n    "
	benchmark((('p_time()', 'from time import time as p_time'), ('g_time()', 'from time import gmtime as g_time'), ('l_time()', 'from time import localtime as l_time'), ('c_time()', 'from peewee.gettime import time as c_time'), ('clock()', 'from time import clock')))

import imp
import types
from operator import itemgetter
class VerboseLoader(object):
	__doc__ = ' The loader takes a name and info about the module to load and\n        "loads" it - in this case write to definied output some data, such as\n        module name, time taken to import it.\n    '
	def __init__(self, name, file, pathname, desc, output=None):
		self.file = file
		self.name = name
		self.pathname = pathname
		self.desc = desc
		if output is not None:
			pass
		self.output = sys.stdout
		return None

	def load_module(self, fullname):
		try:
			t_init = time()
			mod = imp.load_module(self.name, self.file, self.pathname, self.desc)
			t_fin = time() - t_init
			self.output.write('-> %s ( %.4f sec ) --- %s\n' % (fullname, t_fin, self.pathname))
			VerboseImporter.imported.append((fullname, t_fin))
		except:
			mod = None
		finally:
			if self.file:
				self.file.close()
		sys.modules[fullname] = mod
		return mod



class VerboseImporter(object):
	imported = []
	def __init__(self, output=None, report=True, report_output=None, report_threshold=0.10000000000000001):
		if output is not None:
			pass
		self.output = sys.stdout
		self.report = report
		if report_output is not None:
			pass
		self.report_output = sys.stdout
		self.report_threshold = report_threshold
		return None

	def __enter__(self):
		sys.meta_path.append(self)

	def __exit__(self, exc_type, exc_val, exc_tb):
		sys.meta_path.remove(self)
		l = VerboseImporter.imported
		if self.report and l:
			output = self.report_output
			threshold = self.report_threshold
			output.write('\n\n##########################\nIMPORTS REPORTING\n\n')
			for elt in sorted(l, key=itemgetter(1), reverse=True):
				if elt[1] > threshold:
					output.write('| %s %.4f\n' % (elt[0].ljust(50, '.'), elt[1]))
					continue
			VerboseImporter.imported = []

	def find_module(self, fullname, path=None):
		origName = fullname
		if not path:
			mod = sys.modules.get(fullname, False)
			if mod is None or mod and isinstance(mod, types.ModuleType):
				return mod
		if '.' in fullname:
			head, fullname = fullname.rsplit('.', 1)
			mod = sys.modules.get(head, None)
			if mod is None:
				return None
			if hasattr(mod, '__path__'):
				path = mod.__path__
		try:
			file, pathname, desc = imp.find_module(fullname, path)
			return VerboseLoader(origName, file, pathname, desc, self.output)
		except ImportError:
			return None
		return None



def install_importer(output=None, report=True, report_output=None, report_threshold=0.10000000000000001):
	sys.meta_path.append(VerboseImporter(output, report, report_output, report_threshold))

if __name__ == '__main__':
	test_benchmark()
