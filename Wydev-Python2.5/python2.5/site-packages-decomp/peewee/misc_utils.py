# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 102
n 102(None)[super(late_property, self).__init__(None, None, None, doc)
return None
]:
	i: 88(), 98()
	o: 

nname: 98
n 98(None)[]:
	i: 82(f)
	o: 102()

nname: 88
n 88(None)[]:
	i: 82(t)
	o: 102()

nname: 82
n 82(fdel)[]:
	i: 68(), 78()
	o: 88(t), 98(f)

nname: 78
n 78(None)[]:
	i: 62(f)
	o: 82()

nname: 68
n 68(None)[]:
	i: 62(t)
	o: 82()

nname: 62
n 62(fset)[]:
	i: 48(), 58()
	o: 68(t), 78(f)

nname: 58
n 58(None)[]:
	i: 0(f)
	o: 62()

nname: 48
n 48(None)[]:
	i: 0(t)
	o: 62()

nname: 0
n 0(fget)[self._fget = fget
self._fset = fset
self._fdel = fdel
]:
	i: 
	o: 48(t), 58(f)

nname: 82
n 82(None)[if fdel:
	pass
super(late_property, self).__init__(None, None, None, doc)
return None
]:
	i: 0()
	o: 

nname: 0
n 0(None)[self._fget = fget
self._fset = fset
self._fdel = fdel
if fget:
	pass
if fset:
	pass
]:
	i: 
	o: 82()

nname: 0
n 0(None)[self._fget = fget
self._fset = fset
self._fdel = fdel
if fget:
	pass
if fset:
	pass
if fdel:
	pass
super(late_property, self).__init__(None, None, None, doc)
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75cfe4c>}
nname: 0
n 0(None)[return getattr(target, self._fget.__name__)()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75cf96c>}
nname: 0
n 0(None)[getattr(target, self._fset.__name__)(value)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75cfa2c>}
nname: 0
n 0(None)[getattr(target, self._fdel.__name__)()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75cf9cc>}
nname: 6
n 6(None)[__doc__ = 'Extension to the standard Python property mechanism that follows the\n    overriding of the fset, fget and fdel methods. Used just like a property.'
__doc__ = property.__dict__['__doc__']
def __init__(self, fget=None, fset=None, fdel=None, doc=None):
	self._fget = fget
	self._fset = fset
	self._fdel = fdel
	if fget:
		pass
	if fset:
		pass
	if fdel:
		pass
	super(late_property, self).__init__(None, None, None, doc)
	return None

def fget(self, target):
	return getattr(target, self._fget.__name__)()

def fset(self, target, value):
	getattr(target, self._fset.__name__)(value)

def fdel(self, target):
	getattr(target, self._fdel.__name__)()

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75cf56c>}
nname: 0
n 0(None)[self._MultiProxy__po = tuple(proxified_objects)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75cf4ac>}
nname: 30
n 30(None)[]:
	i: 0(AL), 29()
	o: 

nname: 29
n 29(None)[]:
	i: 3(AF), 10()
	o: 30()

nname: 10
n 10(None)[for fn in li:
fn(*args, **kw)
]:
	i: 3(for)
	o: 29()

nname: 3
n 3(None)[]:
	i: 0(loop)
	o: 10(for), 29(AF)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 30(AL)

nname: 30
n 30(None)[]:
	i: 10()
	o: 

nname: 10
n 10(None)[for fn in li:
	fn(*args, **kw)
]:
	i: 0(for)
	o: 30()

nname: 0
n 0(None)[]:
	i: 
	o: 10(for)

nname: 30
n 30(None)[]:
	i: 0()
	o: 

nname: 0
n 0(None)[for fn in li:
	fn(*args, **kw)
]:
	i: 
	o: 30()

nname: 0
n 0(None)[for fn in li:
	fn(*args, **kw)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75d640c>}
nname: 125
n 125(None)[]:
	i: 61(), 100()
	o: 

nname: 100
n 100(None)[log.debug('Not callable proxy (for %s) !!!', attr)
return li[0]
]:
	i: 39(f)
	o: 125()

nname: 61
n 61(None)[def _run_me(*args, **args):
	for fn in li:
		fn(*args, **kw)

setattr(self, attr, _run_me)
return _run_me
]:
	i: 39(t)
	o: 125()

nname: 39
n 39(callable(li[0]))[del _[1]
for li in self._MultiProxy__po:
]:
	i: 0(AF), 17()
	o: 61(t), 100(f)

nname: 17
n 17(None)[for obj in self._MultiProxy__po:
]:
	i: 0(for)
	o: 39()

nname: 0
n 0(None)[]:
	i: 
	o: 17(for), 39(AF)

nname: 39
n 39(None)[del _[1]
for li in self._MultiProxy__po:
if callable(li[0]):
	def _run_me(*args, **args):
		for fn in li:
			fn(*args, **kw)

	setattr(self, attr, _run_me)
	return _run_me
else:
	log.debug('Not callable proxy (for %s) !!!', attr)
	return li[0]
]:
	i: 0(AF), 17()
	o: 

nname: 17
n 17(None)[for obj in self._MultiProxy__po:
]:
	i: 0(for)
	o: 39()

nname: 0
n 0(None)[]:
	i: 
	o: 17(for), 39(AF)

self.nodes: {0: <unpyclib.structure.node instance at 0xb75cfa2c>, 39: <unpyclib.structure.node instance at 0xb75cfbec>, 17: <unpyclib.structure.node instance at 0xb75cf90c>}
nname: 6
n 6(None)[def __init__(self, proxified_objects):
	self._MultiProxy__po = tuple(proxified_objects)

def __getattr__(self, attr):
	pass

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75c8fcc>}
nname: 0
n 0(None)[super(MetaSingleton, cls).__init__(name, bases, dic)
cls._s_instance_ = None
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75cf42c>}
nname: 50
n 50(None)[return cls._s_instance_
]:
	i: 15(), 49()
	o: 

nname: 49
n 49(None)[]:
	i: 0(f)
	o: 50()

nname: 15
n 15(None)[cls._s_instance_ = super(MetaSingleton, cls).__call__(*args, **kw)
]:
	i: 0(t)
	o: 50()

nname: 0
n 0(cls._s_instance_ is None)[]:
	i: 
	o: 15(t), 49(f)

nname: 0
n 0(None)[if cls._s_instance_ is None:
	cls._s_instance_ = super(MetaSingleton, cls).__call__(*args, **kw)
return cls._s_instance_
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75cf68c>}
nname: 6
n 6(None)[def __init__(cls, name, bases, dic):
	super(MetaSingleton, cls).__init__(name, bases, dic)
	cls._s_instance_ = None
	return None

def __call__(cls, *args, **args):
	if cls._s_instance_ is None:
		cls._s_instance_ = super(MetaSingleton, cls).__call__(*args, **kw)
	return cls._s_instance_

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75c8f8c>}
nname: 0
n 0(None)[from __future__ import absolute_import
from .debug import GET_LOGGER
log = GET_LOGGER('utils')
class late_property(property):
	__doc__ = 'Extension to the standard Python property mechanism that follows the\n    overriding of the fset, fget and fdel methods. Used just like a property.'
	__doc__ = property.__dict__['__doc__']
	def __init__(self, fget=None, fset=None, fdel=None, doc=None):
		self._fget = fget
		self._fset = fset
		self._fdel = fdel
		if fget:
			pass
		if fset:
			pass
		if fdel:
			pass
		super(late_property, self).__init__(None, None, None, doc)
		return None

	def fget(self, target):
		return getattr(target, self._fget.__name__)()

	def fset(self, target, value):
		getattr(target, self._fset.__name__)(value)

	def fdel(self, target):
		getattr(target, self._fdel.__name__)()



class MultiProxy(object):
	def __init__(self, proxified_objects):
		self._MultiProxy__po = tuple(proxified_objects)

	def __getattr__(self, attr):
		pass



class MetaSingleton(type):
	def __init__(cls, name, bases, dic):
		super(MetaSingleton, cls).__init__(name, bases, dic)
		cls._s_instance_ = None
		return None

	def __call__(cls, *args, **args):
		if cls._s_instance_ is None:
			cls._s_instance_ = super(MetaSingleton, cls).__call__(*args, **kw)
		return cls._s_instance_



]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75c8b0c>}
from __future__ import absolute_import
from .debug import GET_LOGGER
log = GET_LOGGER('utils')
class late_property(property):
	__doc__ = 'Extension to the standard Python property mechanism that follows the\n    overriding of the fset, fget and fdel methods. Used just like a property.'
	__doc__ = property.__dict__['__doc__']
	def __init__(self, fget=None, fset=None, fdel=None, doc=None):
		self._fget = fget
		self._fset = fset
		self._fdel = fdel
		if fget:
			pass
		if fset:
			pass
		if fdel:
			pass
		super(late_property, self).__init__(None, None, None, doc)
		return None

	def fget(self, target):
		return getattr(target, self._fget.__name__)()

	def fset(self, target, value):
		getattr(target, self._fset.__name__)(value)

	def fdel(self, target):
		getattr(target, self._fdel.__name__)()



class MultiProxy(object):
	def __init__(self, proxified_objects):
		self._MultiProxy__po = tuple(proxified_objects)

	def __getattr__(self, attr):
		pass



class MetaSingleton(type):
	def __init__(cls, name, bases, dic):
		super(MetaSingleton, cls).__init__(name, bases, dic)
		cls._s_instance_ = None
		return None

	def __call__(cls, *args, **args):
		if cls._s_instance_ is None:
			cls._s_instance_ = super(MetaSingleton, cls).__call__(*args, **kw)
		return cls._s_instance_



