# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 62
n 62(None)[]:
	i: 15(), 43()
	o: 

nname: 43
n 43(None)[self.start = start
self.stop = stop
]:
	i: 0(f)
	o: 62()

nname: 15
n 15(None)[self.start = start.start
self.stop = start.stop
]:
	i: 0(t)
	o: 62()

nname: 0
n 0(isinstance(start, slice))[]:
	i: 
	o: 15(t), 43(f)

nname: 0
n 0(None)[if isinstance(start, slice):
	self.start = start.start
	self.stop = start.stop
else:
	self.start = start
	self.stop = stop
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7600e8c>}
nname: 0
n 0(None)[return '[%d:%d]' % (self.start, self.stop)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7600bec>}
nname: 34
n 34(None)[return self.start == other.start
]:
	i: 0(f), 18()
	o: 

nname: 18
n 18(None)[]:
	i: 0(t)
	o: 34()

nname: 0
n 0(self.start == other.start)[]:
	i: 
	o: 18(t), 34(f)

nname: 0
n 0(None)[if self.start == other.start:
	pass
return self.start == other.start
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7600c0c>}
nname: 34
n 34(None)[return self.start != other.start
]:
	i: 0(t), 18()
	o: 

nname: 18
n 18(None)[]:
	i: 0(f)
	o: 34()

nname: 0
n 0(self.start != other.start)[]:
	i: 
	o: 18(f), 34(t)

nname: 0
n 0(None)[if not self.start != other.start:
	pass
return self.start != other.start
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7600fec>}
nname: 0
n 0(None)[return len(self) < len(other)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7600dec>}
nname: 0
n 0(None)[return len(self) > len(other)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7600bcc>}
nname: 0
n 0(None)[return self.stop - self.start
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7600a8c>}
nname: 0
n 0(None)[return self.stop > self.start
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7600b0c>}
nname: 88
n 88(None)[]:
	i: 50(), 87()
	o: 

nname: 87
n 87(None)[return self.start <= other
]:
	i: 72(), 85()
	o: 88()

nname: 85
n 85(None)[other
]:
	i: 54(f)
	o: 87()

nname: 72
n 72(None)[]:
	i: 54(t)
	o: 87()

nname: 54
n 54(self.start <= other)[]:
	i: 0(f)
	o: 72(t), 85(f)

nname: 50
n 50(None)[return other.start >= self.start
]:
	i: 15(f), 34()
	o: 88()

nname: 34
n 34(None)[]:
	i: 15(t)
	o: 50()

nname: 15
n 15(other.start >= self.start)[]:
	i: 0(t)
	o: 34(t), 50(f)

nname: 0
n 0(isinstance(other, Range))[]:
	i: 
	o: 15(t), 54(f)

nname: 88
n 88(None)[]:
	i: 15(), 54()
	o: 

nname: 54
n 54(None)[if self.start <= other:
	pass
else:
	other
return self.start <= other
]:
	i: 0(f)
	o: 88()

nname: 15
n 15(None)[if other.start >= self.start:
	pass
return other.start >= self.start
]:
	i: 0(t)
	o: 88()

nname: 0
n 0(isinstance(other, Range))[]:
	i: 
	o: 15(t), 54(f)

nname: 0
n 0(None)[if isinstance(other, Range):
	if other.start >= self.start:
		pass
	return other.start >= self.start
else:
	if self.start <= other:
		pass
	else:
		other
	return self.start <= other
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb760862c>}
nname: 85
n 85(None)[]:
	i: 21(), 68()
	o: 

nname: 68
n 68(None)[raise RuntimeError("Range objects can't cope with %s !" % other)
]:
	i: 0(f)
	o: 85()

nname: 21
n 21(None)[return Range(min(self.start, other.start), max(self.stop, other.stop))
]:
	i: 0(t)
	o: 85()

nname: 0
n 0(isinstance(other, (Range, slice)))[]:
	i: 
	o: 21(t), 68(f)

nname: 0
n 0(None)[if isinstance(other, (Range, slice)):
	return Range(min(self.start, other.start), max(self.stop, other.stop))
else:
	raise RuntimeError("Range objects can't cope with %s !" % other)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb760898c>}
nname: 262
n 262(None)[]:
	i: 34(JA), 89(JA), 135(JA), 196(JA), 219(), 245()
	o: 

nname: 245
n 245(None)[raise RuntimeError("Range objects can't cope with %s !" % other)
]:
	i: 0(f)
	o: 262()

nname: 219
n 219(None)[raise RuntimeError("Range class don't handle this case (%s minus %s) !!" % (self, other))
]:
	i: 158&177(f)
	o: 262()

nname: 196
n 196(None)[return Range(self.start, other.start)
]:
	i: 158&177(t)
	o: 262(JA)

nname: 158&177
n 158&177(other.start <= self.stop and other.stop >= self.stop)[]:
	i: 97&116(f)
	o: 196(t), 219(f)

nname: 135
n 135(None)[return Range(other.stop, self.stop)
]:
	i: 97&116(t)
	o: 262(JA)

nname: 97&116
n 97&116(other.start <= self.start and other.stop <= self.stop)[]:
	i: 51&70(f)
	o: 135(t), 158&177(f)

nname: 89
n 89(None)[return self
]:
	i: 51&70(t)
	o: 262(JA)

nname: 51&70
n 51&70(other.stop <= self.start or other.start >= self.stop)[]:
	i: 21(f)
	o: 89(t), 97&116(f)

nname: 34
n 34(None)[return Range(0, 0)
]:
	i: 21(t)
	o: 262(JA)

nname: 21
n 21(self in other)[]:
	i: 0(t)
	o: 34(t), 51&70(f)

nname: 0
n 0(isinstance(other, (Range, slice)))[]:
	i: 
	o: 21(t), 245(f)

nname: 0
n 0(None)[if isinstance(other, (Range, slice)):
	if self in other:
		return Range(0, 0)
	else:
		if other.stop <= self.start or other.start >= self.stop:
			return self
		else:
			if other.start <= self.start and other.stop <= self.stop:
				return Range(other.stop, self.stop)
			else:
				if other.start <= self.stop and other.stop >= self.stop:
					return Range(self.start, other.start)
				else:
					raise RuntimeError("Range class don't handle this case (%s minus %s) !!" % (self, other))
else:
	raise RuntimeError("Range objects can't cope with %s !" % other)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7608fcc>}
nname: 0
n 0(None)[return slice(max(0, self.start - offset - grow), self.stop - offset + grow)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7600fac>}
nname: 0
n 0(None)[return Range(max(0, self.start - offset - grow), self.stop - offset + grow)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7600e6c>}
nname: 6
n 6(None)[__doc__ = ' Offers a slice-like class but mutable and supporting some basic operations '
__slots__ = ['start', 'stop']
def __init__(self, start, stop=None):
	if isinstance(start, slice):
		self.start = start.start
		self.stop = start.stop
	else:
		self.start = start
		self.stop = stop

def __repr__(self):
	return '[%d:%d]' % (self.start, self.stop)

def __eq__(self, other):
	if self.start == other.start:
		pass
	return self.start == other.start

def __ne__(self, other):
	if not self.start != other.start:
		pass
	return self.start != other.start

def __lt__(self, other):
	return len(self) < len(other)

def __gt__(self, other):
	return len(self) > len(other)

def __len__(self):
	return self.stop - self.start

def __nonzero__(self):
	return self.stop > self.start

def __contains__(self, other):
	if isinstance(other, Range):
		if other.start >= self.start:
			pass
		return other.start >= self.start
	else:
		if self.start <= other:
			pass
		else:
			other
		return self.start <= other

def __add__(self, other):
	if isinstance(other, (Range, slice)):
		return Range(min(self.start, other.start), max(self.stop, other.stop))
	else:
		raise RuntimeError("Range objects can't cope with %s !" % other)

def __sub__(self, other):
	if isinstance(other, (Range, slice)):
		if self in other:
			return Range(0, 0)
		else:
			if other.stop <= self.start or other.start >= self.stop:
				return self
			else:
				if other.start <= self.start and other.stop <= self.stop:
					return Range(other.stop, self.stop)
				else:
					if other.start <= self.stop and other.stop >= self.stop:
						return Range(self.start, other.start)
					else:
						raise RuntimeError("Range class don't handle this case (%s minus %s) !!" % (self, other))
	else:
		raise RuntimeError("Range objects can't cope with %s !" % other)

def get_slice(self, offset=0, grow=0):
	return slice(max(0, self.start - offset - grow), self.stop - offset + grow)

def get_range(self, offset=0, grow=0):
	return Range(max(0, self.start - offset - grow), self.stop - offset + grow)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb76003cc>}
nname: 0
n 0(None)[self._delta_range = kw.pop('range', 0.001)
list.__init__(self, *args, **kw)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb760062c>}
nname: 150
n 150(None)[]:
	i: 126(), 133()
	o: 

nname: 133
n 133(None)[return list.__contains__(self, item)
]:
	i: 0(f)
	o: 150()

nname: 126
n 126(None)[return False
]:
	i: 21(AL), 125()
	o: 150()

nname: 125
n 125(None)[]:
	i: 78(AF), 121()
	o: 126()

nname: 121
n 121(None)[]:
	i: 85(f), 113()
	o: 125()

nname: 113
n 113(None)[return True
continue
]:
	i: 85(t)
	o: 121()

nname: 85
n 85(abs(item - it) < self._delta_range)[for it in self:
]:
	i: 78(for)
	o: 113(t), 121(f)

nname: 78
n 78(None)[del _[1]
]:
	i: 25(AF), 74()
	o: 85(for), 125(AF)

nname: 74
n 74(None)[]:
	i: 39(f), 63()
	o: 78()

nname: 63
n 63(None)[continue
]:
	i: 39(t)
	o: 74()

nname: 39
n 39(isinstance(_it, (int, float)))[for _it in self:
]:
	i: 25(for)
	o: 63(t), 74(f)

nname: 25
n 25(None)[]:
	i: 21(loop)
	o: 39(for), 78(AF)

nname: 21
n 21(None)[]:
	i: 0(t)
	o: 25(loop), 126(AL)

nname: 0
n 0(isinstance(item, (int, float)))[]:
	i: 
	o: 21(t), 133(f)

nname: 150
n 150(None)[]:
	i: 126(), 133()
	o: 

nname: 133
n 133(None)[return list.__contains__(self, item)
]:
	i: 0(f)
	o: 150()

nname: 126
n 126(None)[return False
]:
	i: 21(AL), 78(AF), 85()
	o: 150()

nname: 85
n 85(None)[for it in self:
if abs(item - it) < self._delta_range:
	return True
	continue
]:
	i: 78(for)
	o: 126()

nname: 78
n 78(None)[del _[1]
]:
	i: 25(AF), 39()
	o: 85(for), 126(AF)

nname: 39
n 39(None)[for _it in self:
if isinstance(_it, (int, float)):
	continue
]:
	i: 25(for)
	o: 78()

nname: 25
n 25(None)[]:
	i: 21(loop)
	o: 39(for), 78(AF)

nname: 21
n 21(None)[]:
	i: 0(t)
	o: 25(loop), 126(AL)

nname: 0
n 0(isinstance(item, (int, float)))[]:
	i: 
	o: 21(t), 133(f)

self.nodes: {0: <unpyclib.structure.node instance at 0xb760058c>, 133: <unpyclib.structure.node instance at 0xb76009cc>, 39: <unpyclib.structure.node instance at 0xb760806c>, 126: <unpyclib.structure.node instance at 0xb7600c2c>, 78: <unpyclib.structure.node instance at 0xb76002cc>, 21: <unpyclib.structure.node instance at 0xb76008cc>, 150: <unpyclib.structure.node instance at 0xb7600b0c>, 25: <unpyclib.structure.node instance at 0xb760040c>, 85: <unpyclib.structure.node instance at 0xb7608eac>}
nname: 114
n 114(None)[]:
	i: 85(), 94()
	o: 

nname: 94
n 94(None)[return list.index(self, item, **kw)
]:
	i: 0(f)
	o: 114()

nname: 85
n 85(None)[raise ValueError
]:
	i: 21(AL), 84()
	o: 114()

nname: 84
n 84(None)[]:
	i: 25(AF), 80()
	o: 85()

nname: 80
n 80(None)[]:
	i: 38(f), 72()
	o: 84()

nname: 72
n 72(None)[return i
continue
]:
	i: 38(t)
	o: 80()

nname: 38
n 38(abs(item - it) < self._delta_range)[for i, it in enumerate(self):
]:
	i: 25(for)
	o: 72(t), 80(f)

nname: 25
n 25(None)[]:
	i: 21(loop)
	o: 38(for), 84(AF)

nname: 21
n 21(None)[]:
	i: 0(t)
	o: 25(loop), 85(AL)

nname: 0
n 0(isinstance(item, (int, float)))[]:
	i: 
	o: 21(t), 94(f)

nname: 114
n 114(None)[]:
	i: 85(), 94()
	o: 

nname: 94
n 94(None)[return list.index(self, item, **kw)
]:
	i: 0(f)
	o: 114()

nname: 85
n 85(None)[raise ValueError
]:
	i: 21(AL), 25(AF), 38()
	o: 114()

nname: 38
n 38(None)[for i, it in enumerate(self):
if abs(item - it) < self._delta_range:
	return i
	continue
]:
	i: 25(for)
	o: 85()

nname: 25
n 25(None)[]:
	i: 21(loop)
	o: 38(for), 85(AF)

nname: 21
n 21(None)[]:
	i: 0(t)
	o: 25(loop), 85(AL)

nname: 0
n 0(isinstance(item, (int, float)))[]:
	i: 
	o: 21(t), 94(f)

nname: 114
n 114(None)[]:
	i: 38(), 94()
	o: 

nname: 94
n 94(None)[return list.index(self, item, **kw)
]:
	i: 0(f)
	o: 114()

nname: 38
n 38(None)[for i, it in enumerate(self):
	if abs(item - it) < self._delta_range:
		return i
		continue
raise ValueError
]:
	i: 21(for)
	o: 114()

nname: 21
n 21(None)[]:
	i: 0(t)
	o: 38(for)

nname: 0
n 0(isinstance(item, (int, float)))[]:
	i: 
	o: 21(t), 94(f)

nname: 114
n 114(None)[]:
	i: 21(), 94()
	o: 

nname: 94
n 94(None)[return list.index(self, item, **kw)
]:
	i: 0(f)
	o: 114()

nname: 21
n 21(None)[for i, it in enumerate(self):
	if abs(item - it) < self._delta_range:
		return i
		continue
raise ValueError
]:
	i: 0(t)
	o: 114()

nname: 0
n 0(isinstance(item, (int, float)))[]:
	i: 
	o: 21(t), 94(f)

nname: 0
n 0(None)[if isinstance(item, (int, float)):
	for i, it in enumerate(self):
		if abs(item - it) < self._delta_range:
			return i
			continue
	raise ValueError
else:
	return list.index(self, item, **kw)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7608b6c>}
nname: 0
n 0(None)[return f_list(list.__add__(self, other))
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75fafcc>}
nname: 6
n 6(None)[__doc__ = ' Offers a new list type supporting some basic operations\n    but dedicated to float values. Most important change concern\n    __contains__ method to manage imprecisions: 0.2000000008 == 0.2.\n    '
def __init__(self, *args, **args):
	self._delta_range = kw.pop('range', 0.001)
	list.__init__(self, *args, **kw)

def __contains__(self, item):
	pass

def index(self, item, **kw):
	if isinstance(item, (int, float)):
		for i, it in enumerate(self):
			if abs(item - it) < self._delta_range:
				return i
				continue
		raise ValueError
	else:
		return list.index(self, item, **kw)

def __add__(self, other):
	return f_list(list.__add__(self, other))

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75fad4c>}
nname: 0
n 0(None)[from __future__ import absolute_import
__all__ = ['Range', 'f_list']
class Range(object):
	__doc__ = ' Offers a slice-like class but mutable and supporting some basic operations '
	__slots__ = ['start', 'stop']
	def __init__(self, start, stop=None):
		if isinstance(start, slice):
			self.start = start.start
			self.stop = start.stop
		else:
			self.start = start
			self.stop = stop

	def __repr__(self):
		return '[%d:%d]' % (self.start, self.stop)

	def __eq__(self, other):
		if self.start == other.start:
			pass
		return self.start == other.start

	def __ne__(self, other):
		if not self.start != other.start:
			pass
		return self.start != other.start

	def __lt__(self, other):
		return len(self) < len(other)

	def __gt__(self, other):
		return len(self) > len(other)

	def __len__(self):
		return self.stop - self.start

	def __nonzero__(self):
		return self.stop > self.start

	def __contains__(self, other):
		if isinstance(other, Range):
			if other.start >= self.start:
				pass
			return other.start >= self.start
		else:
			if self.start <= other:
				pass
			else:
				other
			return self.start <= other

	def __add__(self, other):
		if isinstance(other, (Range, slice)):
			return Range(min(self.start, other.start), max(self.stop, other.stop))
		else:
			raise RuntimeError("Range objects can't cope with %s !" % other)

	def __sub__(self, other):
		if isinstance(other, (Range, slice)):
			if self in other:
				return Range(0, 0)
			else:
				if other.stop <= self.start or other.start >= self.stop:
					return self
				else:
					if other.start <= self.start and other.stop <= self.stop:
						return Range(other.stop, self.stop)
					else:
						if other.start <= self.stop and other.stop >= self.stop:
							return Range(self.start, other.start)
						else:
							raise RuntimeError("Range class don't handle this case (%s minus %s) !!" % (self, other))
		else:
			raise RuntimeError("Range objects can't cope with %s !" % other)

	def get_slice(self, offset=0, grow=0):
		return slice(max(0, self.start - offset - grow), self.stop - offset + grow)

	def get_range(self, offset=0, grow=0):
		return Range(max(0, self.start - offset - grow), self.stop - offset + grow)



class f_list(list):
	__doc__ = ' Offers a new list type supporting some basic operations\n    but dedicated to float values. Most important change concern\n    __contains__ method to manage imprecisions: 0.2000000008 == 0.2.\n    '
	def __init__(self, *args, **args):
		self._delta_range = kw.pop('range', 0.001)
		list.__init__(self, *args, **kw)

	def __contains__(self, item):
		pass

	def index(self, item, **kw):
		if isinstance(item, (int, float)):
			for i, it in enumerate(self):
				if abs(item - it) < self._delta_range:
					return i
					continue
			raise ValueError
		else:
			return list.index(self, item, **kw)

	def __add__(self, other):
		return f_list(list.__add__(self, other))



]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75fa6ac>}
from __future__ import absolute_import
__all__ = ['Range', 'f_list']
class Range(object):
	__doc__ = ' Offers a slice-like class but mutable and supporting some basic operations '
	__slots__ = ['start', 'stop']
	def __init__(self, start, stop=None):
		if isinstance(start, slice):
			self.start = start.start
			self.stop = start.stop
		else:
			self.start = start
			self.stop = stop

	def __repr__(self):
		return '[%d:%d]' % (self.start, self.stop)

	def __eq__(self, other):
		if self.start == other.start:
			pass
		return self.start == other.start

	def __ne__(self, other):
		if not self.start != other.start:
			pass
		return self.start != other.start

	def __lt__(self, other):
		return len(self) < len(other)

	def __gt__(self, other):
		return len(self) > len(other)

	def __len__(self):
		return self.stop - self.start

	def __nonzero__(self):
		return self.stop > self.start

	def __contains__(self, other):
		if isinstance(other, Range):
			if other.start >= self.start:
				pass
			return other.start >= self.start
		else:
			if self.start <= other:
				pass
			else:
				other
			return self.start <= other

	def __add__(self, other):
		if isinstance(other, (Range, slice)):
			return Range(min(self.start, other.start), max(self.stop, other.stop))
		else:
			raise RuntimeError("Range objects can't cope with %s !" % other)

	def __sub__(self, other):
		if isinstance(other, (Range, slice)):
			if self in other:
				return Range(0, 0)
			else:
				if other.stop <= self.start or other.start >= self.stop:
					return self
				else:
					if other.start <= self.start and other.stop <= self.stop:
						return Range(other.stop, self.stop)
					else:
						if other.start <= self.stop and other.stop >= self.stop:
							return Range(self.start, other.start)
						else:
							raise RuntimeError("Range class don't handle this case (%s minus %s) !!" % (self, other))
		else:
			raise RuntimeError("Range objects can't cope with %s !" % other)

	def get_slice(self, offset=0, grow=0):
		return slice(max(0, self.start - offset - grow), self.stop - offset + grow)

	def get_range(self, offset=0, grow=0):
		return Range(max(0, self.start - offset - grow), self.stop - offset + grow)



class f_list(list):
	__doc__ = ' Offers a new list type supporting some basic operations\n    but dedicated to float values. Most important change concern\n    __contains__ method to manage imprecisions: 0.2000000008 == 0.2.\n    '
	def __init__(self, *args, **args):
		self._delta_range = kw.pop('range', 0.001)
		list.__init__(self, *args, **kw)

	def __contains__(self, item):
		pass

	def index(self, item, **kw):
		if isinstance(item, (int, float)):
			for i, it in enumerate(self):
				if abs(item - it) < self._delta_range:
					return i
					continue
			raise ValueError
		else:
			return list.index(self, item, **kw)

	def __add__(self, other):
		return f_list(list.__add__(self, other))



