# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 222
n 222(None)[self.tuple_repr = (self.w, self.h, 0, self.freq)
]:
	i: 211(), 218()
	o: 

nname: 218
n 218(None)[]:
	i: 0(f)
	o: 222()

nname: 211
n 211(None)[]:
	i: 0(t)
	o: 222()

nname: 0
n 0(self.lace == 'i')[self.w = int(mstr.split(':', 1)[1].split('x', 1)[0])
self.h = int(mstr.split('x', 1)[1].split('-', 1)[0].rstrip('ip'))
self.lace = mstr.split('x', 1)[1].split('-', 1)[0].lstrip('01239456789')
self.freq = int(mstr.split('-', 1)[1])
]:
	i: 
	o: 211(t), 218(f)

nname: 0
n 0(None)[self.w = int(mstr.split(':', 1)[1].split('x', 1)[0])
self.h = int(mstr.split('x', 1)[1].split('-', 1)[0].rstrip('ip'))
self.lace = mstr.split('x', 1)[1].split('-', 1)[0].lstrip('01239456789')
self.freq = int(mstr.split('-', 1)[1])
if self.lace == 'i':
	pass
self.tuple_repr = (self.w, self.h, 0, self.freq)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb766beec>}
nname: 0
n 0(None)[return '%ux%u-%u%s %s' % (self.w, self.h, self.freq, self.lace, self.tuple_repr)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb766b4ec>}
nname: 47
n 47(None)[]:
	i: 25(), 42()
	o: 

nname: 42
n 42(None)[return True
]:
	i: 0(f)
	o: 47()

nname: 25
n 25(None)[print "couldn't set video mode '%s'" % self
return False
]:
	i: 0(t)
	o: 47()

nname: 0
n 0(os.system('/usr/bin/fbset %s' % self) != 0)[]:
	i: 
	o: 25(t), 42(f)

nname: 0
n 0(None)[if os.system('/usr/bin/fbset %s' % self) != 0:
	print "couldn't set video mode '%s'" % self
	return False
else:
	return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb766b66c>}
nname: 0
n 0(None)[self.wvs.set_resolution((self.w, self.h), self.lace, self.freq)
return False
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb766b80c>}
nname: 40
n 40(None)[return None
]:
	i: 15(), 29()
	o: 

nname: 29
n 29(None)[return self.set_fbset()
]:
	i: 0(f)
	o: 40()

nname: 15
n 15(None)[return self.set_wyvas()
]:
	i: 0(t)
	o: 40()

nname: 0
n 0(self.wvs is not None)[]:
	i: 
	o: 15(t), 29(f)

nname: 0
n 0(None)[if self.wvs is not None:
	return self.set_wyvas()
else:
	return self.set_fbset()
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb766b5ac>}
nname: 135
n 135(None)[]:
	i: 100(), 134()
	o: 

nname: 134
n 134(None)[return False
]:
	i: 123(), 130()
	o: 135()

nname: 130
n 130(None)[]:
	i: 107(f)
	o: 134()

nname: 123
n 123(None)[]:
	i: 107(t)
	o: 134()

nname: 107
n 107(self.tuple_repr == other)[]:
	i: 0(f)
	o: 123(t), 130(f)

nname: 100
n 100(None)[return False
]:
	i: 91(), 99()
	o: 135()

nname: 99
n 99(None)[]:
	i: 15&34&53&72(f)
	o: 100()

nname: 91
n 91(None)[return True
]:
	i: 15&34&53&72(t)
	o: 100()

nname: 15&34&53&72
n 15&34&53&72(self.w == other.w and self.h == other.h and self.lace == other.lace and self.freq == other.freq)[]:
	i: 0(t)
	o: 91(t), 99(f)

nname: 0
n 0(isinstance(other, VideoMode))[]:
	i: 
	o: 15&34&53&72(t), 107(f)

nname: 135
n 135(None)[]:
	i: 15&34&53&72(), 107()
	o: 

nname: 107
n 107(None)[if self.tuple_repr == other:
	pass
return False
]:
	i: 0(f)
	o: 135()

nname: 15&34&53&72
n 15&34&53&72(None)[if self.w == other.w and self.h == other.h and self.lace == other.lace and self.freq == other.freq:
	return True
return False
]:
	i: 0(t)
	o: 135()

nname: 0
n 0(isinstance(other, VideoMode))[]:
	i: 
	o: 15&34&53&72(t), 107(f)

nname: 0
n 0(None)[if isinstance(other, VideoMode):
	if self.w == other.w and self.h == other.h and self.lace == other.lace and self.freq == other.freq:
		return True
	return False
else:
	if self.tuple_repr == other:
		pass
	return False
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb766b8ec>}
nname: 59
n 59(None)[]:
	i: 15(), 38()
	o: 

nname: 38
n 38(None)[return cmp(self.h, other[1])
]:
	i: 0(f)
	o: 59()

nname: 15
n 15(None)[return cmp(self.h, other.h)
]:
	i: 0(t)
	o: 59()

nname: 0
n 0(isinstance(other, VideoMode))[]:
	i: 
	o: 15(t), 38(f)

nname: 0
n 0(None)[if isinstance(other, VideoMode):
	return cmp(self.h, other.h)
else:
	return cmp(self.h, other[1])
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb766ba8c>}
nname: 6
n 6(None)[__doc__ = 'Representation of a video mode supported by an HDMI sink.\n    The following attributes are exported:\n\n        - h: mode height in pixels\n        - w: mode width in pixels\n        - lace: interlacing (True if mode is interlaced)\n        - freq: refresh rate in Hertz\n    '
def __init__(self, mstr):
	self.w = int(mstr.split(':', 1)[1].split('x', 1)[0])
	self.h = int(mstr.split('x', 1)[1].split('-', 1)[0].rstrip('ip'))
	self.lace = mstr.split('x', 1)[1].split('-', 1)[0].lstrip('01239456789')
	self.freq = int(mstr.split('-', 1)[1])
	if self.lace == 'i':
		pass
	self.tuple_repr = (self.w, self.h, 0, self.freq)

def __repr__(self):
	return '%ux%u-%u%s %s' % (self.w, self.h, self.freq, self.lace, self.tuple_repr)

def set_fbset(self):
	if os.system('/usr/bin/fbset %s' % self) != 0:
		print "couldn't set video mode '%s'" % self
		return False
	else:
		return True

def set_wyvas(self):
	self.wvs.set_resolution((self.w, self.h), self.lace, self.freq)
	return False

def set(self):
	if self.wvs is not None:
		return self.set_wyvas()
	else:
		return self.set_fbset()
	return None

def __eq__(self, other):
	if isinstance(other, VideoMode):
		if self.w == other.w and self.h == other.h and self.lace == other.lace and self.freq == other.freq:
			return True
		return False
	else:
		if self.tuple_repr == other:
			pass
		return False

def __cmp__(self, other):
	if isinstance(other, VideoMode):
		return cmp(self.h, other.h)
	else:
		return cmp(self.h, other[1])

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb7663d6c>}
nname: 127
n 127(None)[]:
	i: 92(), 111(), 126(AE)
	o: 

nname: 111
n 111(None)[raise Exception, "couldn't get modes list"
]:
	i: 89(except)
	o: 127()

nname: 92
n 92(None)[self.modes = self.get_modes()
]:
	i: 89(try)
	o: 127()

nname: 89
n 89(None)[]:
	i: 54(), 73(), 88(AE)
	o: 92(try), 111(except)

nname: 73
n 73(None)[raise Exception, "couldn't get EDID info"
]:
	i: 51(except)
	o: 89()

nname: 54
n 54(None)[self.id = self.get_id()
]:
	i: 51(try)
	o: 89()

nname: 51
n 51(None)[]:
	i: 37(), 50()
	o: 54(try), 73(except)

nname: 50
n 50(None)[]:
	i: 0(t)
	o: 51()

nname: 37
n 37(None)[raise Exception, 'HDMI hotplug failed'
]:
	i: 0(f)
	o: 51()

nname: 0
n 0(self.get_hpd())[self.display = display
self.syspath = '/sys/class/stmcoredisplay/display%u' % self.display
]:
	i: 
	o: 37(f), 50(t)

nname: 111
n 111(None)[except:
	raise Exception, "couldn't get modes list"
]:
	i: 89()
	o: 

nname: 89
n 89(None)[try:
	self.modes = self.get_modes()
]:
	i: 54()
	o: 111()

nname: 54
n 54(None)[try:
	self.id = self.get_id()
except:
	raise Exception, "couldn't get EDID info"
]:
	i: 0(try)
	o: 89()

nname: 0
n 0(None)[self.display = display
self.syspath = '/sys/class/stmcoredisplay/display%u' % self.display
if not self.get_hpd():
	raise Exception, 'HDMI hotplug failed'
]:
	i: 
	o: 54(try)

nname: 89
n 89(None)[try:
	self.modes = self.get_modes()
except:
	raise Exception, "couldn't get modes list"
]:
	i: 0()
	o: 

nname: 0
n 0(None)[self.display = display
self.syspath = '/sys/class/stmcoredisplay/display%u' % self.display
if not self.get_hpd():
	raise Exception, 'HDMI hotplug failed'
try:
	self.id = self.get_id()
except:
	raise Exception, "couldn't get EDID info"
]:
	i: 
	o: 89()

nname: 0
n 0(None)[self.display = display
self.syspath = '/sys/class/stmcoredisplay/display%u' % self.display
if not self.get_hpd():
	raise Exception, 'HDMI hotplug failed'
try:
	self.id = self.get_id()
except:
	raise Exception, "couldn't get EDID info"
try:
	self.modes = self.get_modes()
except:
	raise Exception, "couldn't get modes list"
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb766f30c>}
nname: 0
n 0(None)[return self.id
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb766f86c>}
nname: 68
n 68(None)[]:
	i: 55(), 63()
	o: 

nname: 63
n 63(None)[return True
]:
	i: 43(f)
	o: 68()

nname: 55
n 55(None)[return False
]:
	i: 43(t)
	o: 68()

nname: 43
n 43(hpd != 'y\n')[]:
	i: 3(), 32(), 42(AE)
	o: 55(t), 63(f)

nname: 32
n 32(None)[return False
]:
	i: 0(except)
	o: 43()

nname: 3
n 3(None)[hpd = open('%s/hdmi0.0/hotplug' % self.syspath).readline()
]:
	i: 0(try)
	o: 43()

nname: 0
n 0(None)[]:
	i: 
	o: 3(try), 32(except)

nname: 68
n 68(None)[]:
	i: 32()
	o: 

nname: 32
n 32(None)[except:
	return False
if hpd != 'y\n':
	return False
else:
	return True
]:
	i: 0()
	o: 68()

nname: 0
n 0(None)[try:
	hpd = open('%s/hdmi0.0/hotplug' % self.syspath).readline()
]:
	i: 
	o: 32()

nname: 68
n 68(None)[]:
	i: 0()
	o: 

nname: 0
n 0(None)[try:
	hpd = open('%s/hdmi0.0/hotplug' % self.syspath).readline()
except:
	return False
if hpd != 'y\n':
	return False
else:
	return True
]:
	i: 
	o: 68()

nname: 0
n 0(None)[try:
	hpd = open('%s/hdmi0.0/hotplug' % self.syspath).readline()
except:
	return False
if hpd != 'y\n':
	return False
else:
	return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb766fa8c>}
nname: 67
n 67(None)[del _[1]
for modes in mf.readlines():
mf.close()
return modes
]:
	i: 0(AF), 39()
	o: 

nname: 39
n 39(None)[for m in mf.readlines():
]:
	i: 0(for)
	o: 67()

nname: 0
n 0(None)[mf = open('%s/hdmi0.0/modes' % self.syspath)
]:
	i: 
	o: 39(for), 67(AF)

self.nodes: {0: <unpyclib.structure.node instance at 0xb766fe8c>, 67: <unpyclib.structure.node instance at 0xb766f52c>, 39: <unpyclib.structure.node instance at 0xb766f7ac>}
nname: 0
n 0(None)[path = '%s/hdmi0.0/rawedid' % self.syspath
checksum = md5(open(path).read())
return checksum.digest()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb766fd6c>}
nname: 6
n 6(None)[__doc__ = "Class representing a sink (TV, projector, receiver, ...) plugged\n    on the 710x's HDMI connector (TODO: support stx7200).\n\n    Each specific sink brand/model is uniquely identified by making\n    a MD5 hash of its EDID block data.\n    "
def __init__(self, display=0):
	self.display = display
	self.syspath = '/sys/class/stmcoredisplay/display%u' % self.display
	if not self.get_hpd():
		raise Exception, 'HDMI hotplug failed'
	try:
		self.id = self.get_id()
	except:
		raise Exception, "couldn't get EDID info"
	try:
		self.modes = self.get_modes()
	except:
		raise Exception, "couldn't get modes list"

def __str__(self):
	return self.id

def get_hpd(self):
	try:
		hpd = open('%s/hdmi0.0/hotplug' % self.syspath).readline()
	except:
		return False
	if hpd != 'y\n':
		return False
	else:
		return True

def get_modes(self):
	mf = open('%s/hdmi0.0/modes' % self.syspath)

def get_id(self):
	path = '%s/hdmi0.0/rawedid' % self.syspath
	checksum = md5(open(path).read())
	return checksum.digest()

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb7663fcc>}
nname: 0
n 0(None)[from hashlib import md5
import os
import sys
class VideoMode(object):
	__doc__ = 'Representation of a video mode supported by an HDMI sink.\n    The following attributes are exported:\n\n        - h: mode height in pixels\n        - w: mode width in pixels\n        - lace: interlacing (True if mode is interlaced)\n        - freq: refresh rate in Hertz\n    '
	def __init__(self, mstr):
		self.w = int(mstr.split(':', 1)[1].split('x', 1)[0])
		self.h = int(mstr.split('x', 1)[1].split('-', 1)[0].rstrip('ip'))
		self.lace = mstr.split('x', 1)[1].split('-', 1)[0].lstrip('01239456789')
		self.freq = int(mstr.split('-', 1)[1])
		if self.lace == 'i':
			pass
		self.tuple_repr = (self.w, self.h, 0, self.freq)

	def __repr__(self):
		return '%ux%u-%u%s %s' % (self.w, self.h, self.freq, self.lace, self.tuple_repr)

	def set_fbset(self):
		if os.system('/usr/bin/fbset %s' % self) != 0:
			print "couldn't set video mode '%s'" % self
			return False
		else:
			return True

	def set_wyvas(self):
		self.wvs.set_resolution((self.w, self.h), self.lace, self.freq)
		return False

	def set(self):
		if self.wvs is not None:
			return self.set_wyvas()
		else:
			return self.set_fbset()
		return None

	def __eq__(self, other):
		if isinstance(other, VideoMode):
			if self.w == other.w and self.h == other.h and self.lace == other.lace and self.freq == other.freq:
				return True
			return False
		else:
			if self.tuple_repr == other:
				pass
			return False

	def __cmp__(self, other):
		if isinstance(other, VideoMode):
			return cmp(self.h, other.h)
		else:
			return cmp(self.h, other[1])



class HDMISink(object):
	__doc__ = "Class representing a sink (TV, projector, receiver, ...) plugged\n    on the 710x's HDMI connector (TODO: support stx7200).\n\n    Each specific sink brand/model is uniquely identified by making\n    a MD5 hash of its EDID block data.\n    "
	def __init__(self, display=0):
		self.display = display
		self.syspath = '/sys/class/stmcoredisplay/display%u' % self.display
		if not self.get_hpd():
			raise Exception, 'HDMI hotplug failed'
		try:
			self.id = self.get_id()
		except:
			raise Exception, "couldn't get EDID info"
		try:
			self.modes = self.get_modes()
		except:
			raise Exception, "couldn't get modes list"

	def __str__(self):
		return self.id

	def get_hpd(self):
		try:
			hpd = open('%s/hdmi0.0/hotplug' % self.syspath).readline()
		except:
			return False
		if hpd != 'y\n':
			return False
		else:
			return True

	def get_modes(self):
		mf = open('%s/hdmi0.0/modes' % self.syspath)

	def get_id(self):
		path = '%s/hdmi0.0/rawedid' % self.syspath
		checksum = md5(open(path).read())
		return checksum.digest()



]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb766360c>}
from hashlib import md5
import os
import sys
class VideoMode(object):
	__doc__ = 'Representation of a video mode supported by an HDMI sink.\n    The following attributes are exported:\n\n        - h: mode height in pixels\n        - w: mode width in pixels\n        - lace: interlacing (True if mode is interlaced)\n        - freq: refresh rate in Hertz\n    '
	def __init__(self, mstr):
		self.w = int(mstr.split(':', 1)[1].split('x', 1)[0])
		self.h = int(mstr.split('x', 1)[1].split('-', 1)[0].rstrip('ip'))
		self.lace = mstr.split('x', 1)[1].split('-', 1)[0].lstrip('01239456789')
		self.freq = int(mstr.split('-', 1)[1])
		if self.lace == 'i':
			pass
		self.tuple_repr = (self.w, self.h, 0, self.freq)

	def __repr__(self):
		return '%ux%u-%u%s %s' % (self.w, self.h, self.freq, self.lace, self.tuple_repr)

	def set_fbset(self):
		if os.system('/usr/bin/fbset %s' % self) != 0:
			print "couldn't set video mode '%s'" % self
			return False
		else:
			return True

	def set_wyvas(self):
		self.wvs.set_resolution((self.w, self.h), self.lace, self.freq)
		return False

	def set(self):
		if self.wvs is not None:
			return self.set_wyvas()
		else:
			return self.set_fbset()
		return None

	def __eq__(self, other):
		if isinstance(other, VideoMode):
			if self.w == other.w and self.h == other.h and self.lace == other.lace and self.freq == other.freq:
				return True
			return False
		else:
			if self.tuple_repr == other:
				pass
			return False

	def __cmp__(self, other):
		if isinstance(other, VideoMode):
			return cmp(self.h, other.h)
		else:
			return cmp(self.h, other[1])



class HDMISink(object):
	__doc__ = "Class representing a sink (TV, projector, receiver, ...) plugged\n    on the 710x's HDMI connector (TODO: support stx7200).\n\n    Each specific sink brand/model is uniquely identified by making\n    a MD5 hash of its EDID block data.\n    "
	def __init__(self, display=0):
		self.display = display
		self.syspath = '/sys/class/stmcoredisplay/display%u' % self.display
		if not self.get_hpd():
			raise Exception, 'HDMI hotplug failed'
		try:
			self.id = self.get_id()
		except:
			raise Exception, "couldn't get EDID info"
		try:
			self.modes = self.get_modes()
		except:
			raise Exception, "couldn't get modes list"

	def __str__(self):
		return self.id

	def get_hpd(self):
		try:
			hpd = open('%s/hdmi0.0/hotplug' % self.syspath).readline()
		except:
			return False
		if hpd != 'y\n':
			return False
		else:
			return True

	def get_modes(self):
		mf = open('%s/hdmi0.0/modes' % self.syspath)

	def get_id(self):
		path = '%s/hdmi0.0/rawedid' % self.syspath
		checksum = md5(open(path).read())
		return checksum.digest()



