# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 0
n 0(None)[self.apm_state_dict = {0: 'apm_ready', 1: 'apm_standby', 2: 'apm_suspend', 3: 'apm_off'}
_wystandby = peewee_dbus.reference('com.wyplay.wycrs', '/com/wyplay/wycrs/wystandby', 'com.wyplay.wycrs')
self._add_standby_module = _wystandby.method('AddStandbyModule', 's', 's')
self._remove_standby_module = _wystandby.method('RemoveStandbyModule', 's', 'i')
self._change_apm_state = _wystandby.method('ChangeGlobalPowerState', 'i', '')
self._get_apm_state = _wystandby.method('GetGlobalPowerState', '', 'i')
self.notify_new_max_power_state = _wystandby.method('NotifyNewMaxPowerState', 'si', '')
self.notify_power_state_changed = _wystandby.method('NotifyPowerStateChanged', 'si', '')
self.set_alarm = _wystandby.method('SetAlarm', 'x', '')
self.inst = peewee_dbus.instance('/com/wyplay/wycrs/wystandby')
self.inst.signal('ChangePowerState', 'i', self.wms_change_power_state, WDB_AS_THREAD)
self._apm_interested_modules = []
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76b0e4c>}
nname: 0
n 0(None)[return self._change_apm_state(state)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76ae46c>}
nname: 0
n 0(None)[return self._change_apm_state(state)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76ae4ac>}
nname: 0
n 0(None)[return self._get_apm_state()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76ae40c>}
nname: 0
n 0(None)[return self._get_apm_state()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76ae46c>}
nname: 61
n 61(None)[]:
	i: 0(AL), 60()
	o: 

nname: 60
n 60(None)[]:
	i: 16(AF), 26()
	o: 61()

nname: 26
n 26(None)[for module in self._apm_interested_modules:
Task(getattr(module, str_state)).start(0.01)
]:
	i: 16(for)
	o: 60()

nname: 16
n 16(None)[]:
	i: 0(loop)
	o: 26(for), 60(AF)

nname: 0
n 0(None)[str_state = self.apm_state_dict[apm_state]
]:
	i: 
	o: 16(loop), 61(AL)

nname: 61
n 61(None)[]:
	i: 26()
	o: 

nname: 26
n 26(None)[for module in self._apm_interested_modules:
	Task(getattr(module, str_state)).start(0.01)
]:
	i: 0(for)
	o: 61()

nname: 0
n 0(None)[str_state = self.apm_state_dict[apm_state]
]:
	i: 
	o: 26(for)

nname: 61
n 61(None)[]:
	i: 0()
	o: 

nname: 0
n 0(None)[str_state = self.apm_state_dict[apm_state]
for module in self._apm_interested_modules:
	Task(getattr(module, str_state)).start(0.01)
]:
	i: 
	o: 61()

nname: 0
n 0(None)[str_state = self.apm_state_dict[apm_state]
for module in self._apm_interested_modules:
	Task(getattr(module, str_state)).start(0.01)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76ae6ec>}
nname: 0
n 0(None)[name = self._add_standby_module(name)
self._apm_interested_modules.append(module)
return name
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76ae40c>}
nname: 52
n 52(None)[]:
	i: 15(), 51()
	o: 

nname: 51
n 51(None)[]:
	i: 0(f)
	o: 52()

nname: 15
n 15(None)[self._remove_standby_module(module.name)
self._apm_interested_modules.delete(module)
]:
	i: 0(t)
	o: 52()

nname: 0
n 0(module in self._apm_interested_modules)[]:
	i: 
	o: 15(t), 51(f)

nname: 0
n 0(None)[if module in self._apm_interested_modules:
	self._remove_standby_module(module.name)
	self._apm_interested_modules.delete(module)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76ae98c>}
nname: 6
n 6(None)[__doc__ = "\n        This class is a wrapper provided to manage communications between the wystandby\n        module and other modules who use the peewee notifier.\n        Dbus instances can't be dispatched among all receivers if the receivers are using\n        the same dbus loop.\n        "
__metaclass__ = MetaSingleton
def __init__(self):
	self.apm_state_dict = {0: 'apm_ready', 1: 'apm_standby', 2: 'apm_suspend', 3: 'apm_off'}
	_wystandby = peewee_dbus.reference('com.wyplay.wycrs', '/com/wyplay/wycrs/wystandby', 'com.wyplay.wycrs')
	self._add_standby_module = _wystandby.method('AddStandbyModule', 's', 's')
	self._remove_standby_module = _wystandby.method('RemoveStandbyModule', 's', 'i')
	self._change_apm_state = _wystandby.method('ChangeGlobalPowerState', 'i', '')
	self._get_apm_state = _wystandby.method('GetGlobalPowerState', '', 'i')
	self.notify_new_max_power_state = _wystandby.method('NotifyNewMaxPowerState', 'si', '')
	self.notify_power_state_changed = _wystandby.method('NotifyPowerStateChanged', 'si', '')
	self.set_alarm = _wystandby.method('SetAlarm', 'x', '')
	self.inst = peewee_dbus.instance('/com/wyplay/wycrs/wystandby')
	self.inst.signal('ChangePowerState', 'i', self.wms_change_power_state, WDB_AS_THREAD)
	self._apm_interested_modules = []

apm_state = property((lambda self: self._get_apm_state()), (lambda self, state: self._change_apm_state(state)))
def wms_change_power_state(self, apm_state):
	str_state = self.apm_state_dict[apm_state]
	for module in self._apm_interested_modules:
		Task(getattr(module, str_state)).start(0.01)

def add_module(self, module, name):
	name = self._add_standby_module(name)
	self._apm_interested_modules.append(module)
	return name

def remove_module(self, module):
	if module in self._apm_interested_modules:
		self._remove_standby_module(module.name)
		self._apm_interested_modules.delete(module)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb76a57ac>}
nname: 0
n 0(None)[self.pm = PowerManager()
self.name = self.pm.add_module(self, name)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76ae32c>}
nname: 0
n 0(None)[return self.pm.notify_power_state_changed(self.name, state)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76ae58c>}
nname: 0
n 0(None)[return self.pm.notify_new_max_power_state(self.name, state)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76ae40c>}
nname: 0
n 0(None)[self.notify_power_state_changed(0)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76ae58c>}
nname: 0
n 0(None)[self.notify_power_state_changed(1)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76ae1cc>}
nname: 0
n 0(None)[self.notify_power_state_changed(2)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76ae7cc>}
nname: 0
n 0(None)[self.notify_power_state_changed(3)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76ae4ec>}
nname: 6
n 6(None)[def __init__(self, name):
	self.pm = PowerManager()
	self.name = self.pm.add_module(self, name)

def notify_power_state_changed(self, state):
	return self.pm.notify_power_state_changed(self.name, state)

def notify_new_max_power_state(self, state):
	return self.pm.notify_new_max_power_state(self.name, state)

def apm_ready(self):
	self.notify_power_state_changed(0)

def apm_standby(self):
	self.notify_power_state_changed(1)

def apm_suspend(self):
	self.notify_power_state_changed(2)

def apm_off(self):
	self.notify_power_state_changed(3)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb76a5bac>}
nname: 0
n 0(None)[self.apm_state_dict = {0: 'apm_ready', 1: 'apm_standby', 2: 'apm_suspend', 3: 'apm_off'}
_wystandby = peewee_dbus.reference('com.wyplay.wycrs', '/com/wyplay/wycrs/wystandby', 'com.wyplay.wycrs')
self._add_standby_module = _wystandby.method('AddStandbyModule', 's', 's')
self._remove_standby_module = _wystandby.method('RemoveStandbyModule', 's', 'i')
self._change_apm_state = _wystandby.method('ChangeGlobalPowerState', 'i', '')
self._get_apm_state = _wystandby.method('GetGlobalPowerState', '', 'i')
self.notify_new_max_power_state = _wystandby.method('NotifyNewMaxPowerState', 'si', '')
self.notify_power_state_changed = _wystandby.method('NotifyPowerStateChanged', 'si', '')
self.set_alarm = _wystandby.method('SetAlarm', 'x', '')
self.inst = peewee_dbus.instance('/com/wyplay/wycrs/wystandby')
self.inst.signal('ChangePowerState', 'i', self.wms_change_power_state, WDB_AS_THREAD)
self._apm_interested_modules = []
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76b034c>}
nname: 0
n 0(None)[return self._change_apm_state(state)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76ae7cc>}
nname: 0
n 0(None)[return self._change_apm_state(state)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76ae4ac>}
nname: 0
n 0(None)[return self._get_apm_state()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76ae62c>}
nname: 0
n 0(None)[return self._get_apm_state()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76ae7cc>}
nname: 61
n 61(None)[]:
	i: 0(AL), 60()
	o: 

nname: 60
n 60(None)[]:
	i: 16(AF), 26()
	o: 61()

nname: 26
n 26(None)[for module in self._apm_interested_modules:
Task(getattr(module, str_state)).start(0.01)
]:
	i: 16(for)
	o: 60()

nname: 16
n 16(None)[]:
	i: 0(loop)
	o: 26(for), 60(AF)

nname: 0
n 0(None)[str_state = self.apm_state_dict[apm_state]
]:
	i: 
	o: 16(loop), 61(AL)

nname: 61
n 61(None)[]:
	i: 26()
	o: 

nname: 26
n 26(None)[for module in self._apm_interested_modules:
	Task(getattr(module, str_state)).start(0.01)
]:
	i: 0(for)
	o: 61()

nname: 0
n 0(None)[str_state = self.apm_state_dict[apm_state]
]:
	i: 
	o: 26(for)

nname: 61
n 61(None)[]:
	i: 0()
	o: 

nname: 0
n 0(None)[str_state = self.apm_state_dict[apm_state]
for module in self._apm_interested_modules:
	Task(getattr(module, str_state)).start(0.01)
]:
	i: 
	o: 61()

nname: 0
n 0(None)[str_state = self.apm_state_dict[apm_state]
for module in self._apm_interested_modules:
	Task(getattr(module, str_state)).start(0.01)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76ae84c>}
nname: 0
n 0(None)[name = self._add_standby_module(name)
self._apm_interested_modules.append(module)
return name
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76ae62c>}
nname: 52
n 52(None)[]:
	i: 15(), 51()
	o: 

nname: 51
n 51(None)[]:
	i: 0(f)
	o: 52()

nname: 15
n 15(None)[self._remove_standby_module(module.name)
self._apm_interested_modules.delete(module)
]:
	i: 0(t)
	o: 52()

nname: 0
n 0(module in self._apm_interested_modules)[]:
	i: 
	o: 15(t), 51(f)

nname: 0
n 0(None)[if module in self._apm_interested_modules:
	self._remove_standby_module(module.name)
	self._apm_interested_modules.delete(module)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76ae88c>}
nname: 6
n 6(None)[__doc__ = "\n        This class is a wrapper provided to manage communications between the wystandby\n        module and other modules who use the peewee notifier.\n        Dbus instances can't be dispatched among all receivers if the receivers are using\n        the same dbus loop.\n        "
__metaclass__ = MetaSingleton
def __init__(self):
	self.apm_state_dict = {0: 'apm_ready', 1: 'apm_standby', 2: 'apm_suspend', 3: 'apm_off'}
	_wystandby = peewee_dbus.reference('com.wyplay.wycrs', '/com/wyplay/wycrs/wystandby', 'com.wyplay.wycrs')
	self._add_standby_module = _wystandby.method('AddStandbyModule', 's', 's')
	self._remove_standby_module = _wystandby.method('RemoveStandbyModule', 's', 'i')
	self._change_apm_state = _wystandby.method('ChangeGlobalPowerState', 'i', '')
	self._get_apm_state = _wystandby.method('GetGlobalPowerState', '', 'i')
	self.notify_new_max_power_state = _wystandby.method('NotifyNewMaxPowerState', 'si', '')
	self.notify_power_state_changed = _wystandby.method('NotifyPowerStateChanged', 'si', '')
	self.set_alarm = _wystandby.method('SetAlarm', 'x', '')
	self.inst = peewee_dbus.instance('/com/wyplay/wycrs/wystandby')
	self.inst.signal('ChangePowerState', 'i', self.wms_change_power_state, WDB_AS_THREAD)
	self._apm_interested_modules = []

apm_state = property((lambda self: self._get_apm_state()), (lambda self, state: self._change_apm_state(state)))
def wms_change_power_state(self, apm_state):
	str_state = self.apm_state_dict[apm_state]
	for module in self._apm_interested_modules:
		Task(getattr(module, str_state)).start(0.01)

def add_module(self, module, name):
	name = self._add_standby_module(name)
	self._apm_interested_modules.append(module)
	return name

def remove_module(self, module):
	if module in self._apm_interested_modules:
		self._remove_standby_module(module.name)
		self._apm_interested_modules.delete(module)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb76a536c>}
nname: 200
n 200(None)[class PowerManagerModule(object):
	def __init__(self, name):
		self.pm = PowerManager()
		self.name = self.pm.add_module(self, name)

	def notify_power_state_changed(self, state):
		return self.pm.notify_power_state_changed(self.name, state)

	def notify_new_max_power_state(self, state):
		return self.pm.notify_new_max_power_state(self.name, state)

	def apm_ready(self):
		self.notify_power_state_changed(0)

	def apm_standby(self):
		self.notify_power_state_changed(1)

	def apm_suspend(self):
		self.notify_power_state_changed(2)

	def apm_off(self):
		self.notify_power_state_changed(3)



]:
	i: 138(), 164()
	o: 

nname: 164
n 164(None)[log.warn('Non-SH target detected. Falling back to dummy PowerManager implementation.')
class PowerManager(object):
	__doc__ = "\n        This class is a wrapper provided to manage communications between the wystandby\n        module and other modules who use the peewee notifier.\n        Dbus instances can't be dispatched among all receivers if the receivers are using\n        the same dbus loop.\n        "
	__metaclass__ = MetaSingleton
	def __init__(self):
		self.apm_state_dict = {0: 'apm_ready', 1: 'apm_standby', 2: 'apm_suspend', 3: 'apm_off'}
		_wystandby = peewee_dbus.reference('com.wyplay.wycrs', '/com/wyplay/wycrs/wystandby', 'com.wyplay.wycrs')
		self._add_standby_module = _wystandby.method('AddStandbyModule', 's', 's')
		self._remove_standby_module = _wystandby.method('RemoveStandbyModule', 's', 'i')
		self._change_apm_state = _wystandby.method('ChangeGlobalPowerState', 'i', '')
		self._get_apm_state = _wystandby.method('GetGlobalPowerState', '', 'i')
		self.notify_new_max_power_state = _wystandby.method('NotifyNewMaxPowerState', 'si', '')
		self.notify_power_state_changed = _wystandby.method('NotifyPowerStateChanged', 'si', '')
		self.set_alarm = _wystandby.method('SetAlarm', 'x', '')
		self.inst = peewee_dbus.instance('/com/wyplay/wycrs/wystandby')
		self.inst.signal('ChangePowerState', 'i', self.wms_change_power_state, WDB_AS_THREAD)
		self._apm_interested_modules = []

	apm_state = property((lambda self: self._get_apm_state()), (lambda self, state: self._change_apm_state(state)))
	def wms_change_power_state(self, apm_state):
		str_state = self.apm_state_dict[apm_state]
		for module in self._apm_interested_modules:
			Task(getattr(module, str_state)).start(0.01)

	def add_module(self, module, name):
		name = self._add_standby_module(name)
		self._apm_interested_modules.append(module)
		return name

	def remove_module(self, module):
		if module in self._apm_interested_modules:
			self._remove_standby_module(module.name)
			self._apm_interested_modules.delete(module)



]:
	i: 0(f)
	o: 200()

nname: 138
n 138(None)[class PowerManager(object):
	__doc__ = "\n        This class is a wrapper provided to manage communications between the wystandby\n        module and other modules who use the peewee notifier.\n        Dbus instances can't be dispatched among all receivers if the receivers are using\n        the same dbus loop.\n        "
	__metaclass__ = MetaSingleton
	def __init__(self):
		self.apm_state_dict = {0: 'apm_ready', 1: 'apm_standby', 2: 'apm_suspend', 3: 'apm_off'}
		_wystandby = peewee_dbus.reference('com.wyplay.wycrs', '/com/wyplay/wycrs/wystandby', 'com.wyplay.wycrs')
		self._add_standby_module = _wystandby.method('AddStandbyModule', 's', 's')
		self._remove_standby_module = _wystandby.method('RemoveStandbyModule', 's', 'i')
		self._change_apm_state = _wystandby.method('ChangeGlobalPowerState', 'i', '')
		self._get_apm_state = _wystandby.method('GetGlobalPowerState', '', 'i')
		self.notify_new_max_power_state = _wystandby.method('NotifyNewMaxPowerState', 'si', '')
		self.notify_power_state_changed = _wystandby.method('NotifyPowerStateChanged', 'si', '')
		self.set_alarm = _wystandby.method('SetAlarm', 'x', '')
		self.inst = peewee_dbus.instance('/com/wyplay/wycrs/wystandby')
		self.inst.signal('ChangePowerState', 'i', self.wms_change_power_state, WDB_AS_THREAD)
		self._apm_interested_modules = []

	apm_state = property((lambda self: self._get_apm_state()), (lambda self, state: self._change_apm_state(state)))
	def wms_change_power_state(self, apm_state):
		str_state = self.apm_state_dict[apm_state]
		for module in self._apm_interested_modules:
			Task(getattr(module, str_state)).start(0.01)

	def add_module(self, module, name):
		name = self._add_standby_module(name)
		self._apm_interested_modules.append(module)
		return name

	def remove_module(self, module):
		if module in self._apm_interested_modules:
			self._remove_standby_module(module.name)
			self._apm_interested_modules.delete(module)



]:
	i: 0(t)
	o: 200()

nname: 0
n 0(platform.machine() == 'sh4')[from __future__ import absolute_import
__all__ = ['PowerManager', 'PowerManagerModule']
import platform
from .dbus import peewee_dbus
from .debug import log
from .misc_utils import MetaSingleton
from .notifier import Task
from wydbus import WDB_AS_THREAD
]:
	i: 
	o: 138(t), 164(f)

nname: 0
n 0(None)[from __future__ import absolute_import
__all__ = ['PowerManager', 'PowerManagerModule']
import platform
from .dbus import peewee_dbus
from .debug import log
from .misc_utils import MetaSingleton
from .notifier import Task
from wydbus import WDB_AS_THREAD
if platform.machine() == 'sh4':
	class PowerManager(object):
		__doc__ = "\n        This class is a wrapper provided to manage communications between the wystandby\n        module and other modules who use the peewee notifier.\n        Dbus instances can't be dispatched among all receivers if the receivers are using\n        the same dbus loop.\n        "
		__metaclass__ = MetaSingleton
		def __init__(self):
			self.apm_state_dict = {0: 'apm_ready', 1: 'apm_standby', 2: 'apm_suspend', 3: 'apm_off'}
			_wystandby = peewee_dbus.reference('com.wyplay.wycrs', '/com/wyplay/wycrs/wystandby', 'com.wyplay.wycrs')
			self._add_standby_module = _wystandby.method('AddStandbyModule', 's', 's')
			self._remove_standby_module = _wystandby.method('RemoveStandbyModule', 's', 'i')
			self._change_apm_state = _wystandby.method('ChangeGlobalPowerState', 'i', '')
			self._get_apm_state = _wystandby.method('GetGlobalPowerState', '', 'i')
			self.notify_new_max_power_state = _wystandby.method('NotifyNewMaxPowerState', 'si', '')
			self.notify_power_state_changed = _wystandby.method('NotifyPowerStateChanged', 'si', '')
			self.set_alarm = _wystandby.method('SetAlarm', 'x', '')
			self.inst = peewee_dbus.instance('/com/wyplay/wycrs/wystandby')
			self.inst.signal('ChangePowerState', 'i', self.wms_change_power_state, WDB_AS_THREAD)
			self._apm_interested_modules = []

		apm_state = property((lambda self: self._get_apm_state()), (lambda self, state: self._change_apm_state(state)))
		def wms_change_power_state(self, apm_state):
			str_state = self.apm_state_dict[apm_state]
			for module in self._apm_interested_modules:
				Task(getattr(module, str_state)).start(0.01)

		def add_module(self, module, name):
			name = self._add_standby_module(name)
			self._apm_interested_modules.append(module)
			return name

		def remove_module(self, module):
			if module in self._apm_interested_modules:
				self._remove_standby_module(module.name)
				self._apm_interested_modules.delete(module)



else:
	log.warn('Non-SH target detected. Falling back to dummy PowerManager implementation.')
	class PowerManager(object):
		__doc__ = "\n        This class is a wrapper provided to manage communications between the wystandby\n        module and other modules who use the peewee notifier.\n        Dbus instances can't be dispatched among all receivers if the receivers are using\n        the same dbus loop.\n        "
		__metaclass__ = MetaSingleton
		def __init__(self):
			self.apm_state_dict = {0: 'apm_ready', 1: 'apm_standby', 2: 'apm_suspend', 3: 'apm_off'}
			_wystandby = peewee_dbus.reference('com.wyplay.wycrs', '/com/wyplay/wycrs/wystandby', 'com.wyplay.wycrs')
			self._add_standby_module = _wystandby.method('AddStandbyModule', 's', 's')
			self._remove_standby_module = _wystandby.method('RemoveStandbyModule', 's', 'i')
			self._change_apm_state = _wystandby.method('ChangeGlobalPowerState', 'i', '')
			self._get_apm_state = _wystandby.method('GetGlobalPowerState', '', 'i')
			self.notify_new_max_power_state = _wystandby.method('NotifyNewMaxPowerState', 'si', '')
			self.notify_power_state_changed = _wystandby.method('NotifyPowerStateChanged', 'si', '')
			self.set_alarm = _wystandby.method('SetAlarm', 'x', '')
			self.inst = peewee_dbus.instance('/com/wyplay/wycrs/wystandby')
			self.inst.signal('ChangePowerState', 'i', self.wms_change_power_state, WDB_AS_THREAD)
			self._apm_interested_modules = []

		apm_state = property((lambda self: self._get_apm_state()), (lambda self, state: self._change_apm_state(state)))
		def wms_change_power_state(self, apm_state):
			str_state = self.apm_state_dict[apm_state]
			for module in self._apm_interested_modules:
				Task(getattr(module, str_state)).start(0.01)

		def add_module(self, module, name):
			name = self._add_standby_module(name)
			self._apm_interested_modules.append(module)
			return name

		def remove_module(self, module):
			if module in self._apm_interested_modules:
				self._remove_standby_module(module.name)
				self._apm_interested_modules.delete(module)



class PowerManagerModule(object):
	def __init__(self, name):
		self.pm = PowerManager()
		self.name = self.pm.add_module(self, name)

	def notify_power_state_changed(self, state):
		return self.pm.notify_power_state_changed(self.name, state)

	def notify_new_max_power_state(self, state):
		return self.pm.notify_new_max_power_state(self.name, state)

	def apm_ready(self):
		self.notify_power_state_changed(0)

	def apm_standby(self):
		self.notify_power_state_changed(1)

	def apm_suspend(self):
		self.notify_power_state_changed(2)

	def apm_off(self):
		self.notify_power_state_changed(3)



]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb769ff4c>}
from __future__ import absolute_import
__all__ = ['PowerManager', 'PowerManagerModule']
import platform
from .dbus import peewee_dbus
from .debug import log
from .misc_utils import MetaSingleton
from .notifier import Task
from wydbus import WDB_AS_THREAD
if platform.machine() == 'sh4':
	class PowerManager(object):
		__doc__ = "\n        This class is a wrapper provided to manage communications between the wystandby\n        module and other modules who use the peewee notifier.\n        Dbus instances can't be dispatched among all receivers if the receivers are using\n        the same dbus loop.\n        "
		__metaclass__ = MetaSingleton
		def __init__(self):
			self.apm_state_dict = {0: 'apm_ready', 1: 'apm_standby', 2: 'apm_suspend', 3: 'apm_off'}
			_wystandby = peewee_dbus.reference('com.wyplay.wycrs', '/com/wyplay/wycrs/wystandby', 'com.wyplay.wycrs')
			self._add_standby_module = _wystandby.method('AddStandbyModule', 's', 's')
			self._remove_standby_module = _wystandby.method('RemoveStandbyModule', 's', 'i')
			self._change_apm_state = _wystandby.method('ChangeGlobalPowerState', 'i', '')
			self._get_apm_state = _wystandby.method('GetGlobalPowerState', '', 'i')
			self.notify_new_max_power_state = _wystandby.method('NotifyNewMaxPowerState', 'si', '')
			self.notify_power_state_changed = _wystandby.method('NotifyPowerStateChanged', 'si', '')
			self.set_alarm = _wystandby.method('SetAlarm', 'x', '')
			self.inst = peewee_dbus.instance('/com/wyplay/wycrs/wystandby')
			self.inst.signal('ChangePowerState', 'i', self.wms_change_power_state, WDB_AS_THREAD)
			self._apm_interested_modules = []

		apm_state = property((lambda self: self._get_apm_state()), (lambda self, state: self._change_apm_state(state)))
		def wms_change_power_state(self, apm_state):
			str_state = self.apm_state_dict[apm_state]
			for module in self._apm_interested_modules:
				Task(getattr(module, str_state)).start(0.01)

		def add_module(self, module, name):
			name = self._add_standby_module(name)
			self._apm_interested_modules.append(module)
			return name

		def remove_module(self, module):
			if module in self._apm_interested_modules:
				self._remove_standby_module(module.name)
				self._apm_interested_modules.delete(module)



else:
	log.warn('Non-SH target detected. Falling back to dummy PowerManager implementation.')
	class PowerManager(object):
		__doc__ = "\n        This class is a wrapper provided to manage communications between the wystandby\n        module and other modules who use the peewee notifier.\n        Dbus instances can't be dispatched among all receivers if the receivers are using\n        the same dbus loop.\n        "
		__metaclass__ = MetaSingleton
		def __init__(self):
			self.apm_state_dict = {0: 'apm_ready', 1: 'apm_standby', 2: 'apm_suspend', 3: 'apm_off'}
			_wystandby = peewee_dbus.reference('com.wyplay.wycrs', '/com/wyplay/wycrs/wystandby', 'com.wyplay.wycrs')
			self._add_standby_module = _wystandby.method('AddStandbyModule', 's', 's')
			self._remove_standby_module = _wystandby.method('RemoveStandbyModule', 's', 'i')
			self._change_apm_state = _wystandby.method('ChangeGlobalPowerState', 'i', '')
			self._get_apm_state = _wystandby.method('GetGlobalPowerState', '', 'i')
			self.notify_new_max_power_state = _wystandby.method('NotifyNewMaxPowerState', 'si', '')
			self.notify_power_state_changed = _wystandby.method('NotifyPowerStateChanged', 'si', '')
			self.set_alarm = _wystandby.method('SetAlarm', 'x', '')
			self.inst = peewee_dbus.instance('/com/wyplay/wycrs/wystandby')
			self.inst.signal('ChangePowerState', 'i', self.wms_change_power_state, WDB_AS_THREAD)
			self._apm_interested_modules = []

		apm_state = property((lambda self: self._get_apm_state()), (lambda self, state: self._change_apm_state(state)))
		def wms_change_power_state(self, apm_state):
			str_state = self.apm_state_dict[apm_state]
			for module in self._apm_interested_modules:
				Task(getattr(module, str_state)).start(0.01)

		def add_module(self, module, name):
			name = self._add_standby_module(name)
			self._apm_interested_modules.append(module)
			return name

		def remove_module(self, module):
			if module in self._apm_interested_modules:
				self._remove_standby_module(module.name)
				self._apm_interested_modules.delete(module)



class PowerManagerModule(object):
	def __init__(self, name):
		self.pm = PowerManager()
		self.name = self.pm.add_module(self, name)

	def notify_power_state_changed(self, state):
		return self.pm.notify_power_state_changed(self.name, state)

	def notify_new_max_power_state(self, state):
		return self.pm.notify_new_max_power_state(self.name, state)

	def apm_ready(self):
		self.notify_power_state_changed(0)

	def apm_standby(self):
		self.notify_power_state_changed(1)

	def apm_suspend(self):
		self.notify_power_state_changed(2)

	def apm_off(self):
		self.notify_power_state_changed(3)



