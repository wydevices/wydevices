# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 0
n 0(None)[self._uri = uri
self._must_delete = 0
self._file = ''
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb77068ec>}
nname: 0
n 0(None)[self.cleanup()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb770688c>}
nname: 107
n 107(None)[]:
	i: 42(JA), 69(JA), 103(), 106()
	o: 

nname: 106
n 106(None)[]:
	i: 0(f)
	o: 107()

nname: 103
n 103(None)[]:
	i: 101(AE)
	o: 107()

nname: 101
n 101(None)[]:
	i: 59(f)
	o: 103(AE)

nname: 69
n 69(None)[#, e
log.debug('Error removing file: %s' % str(e))
]:
	i: 59(t)
	o: 107(JA)

nname: 59
n 59(<dummy_ex3> EXC_MATCH Exception)[]:
	i: 9(except)
	o: 69(t), 101(f)

nname: 42
n 42(None)[unlink(self._file)
]:
	i: 9(try)
	o: 107(JA)

nname: 9
n 9(None)[self._must_delete = 0
log.debug('Removing file %s' % self._file)
]:
	i: 0(t)
	o: 42(try), 59(except)

nname: 0
n 0(self._must_delete)[]:
	i: 
	o: 9(t), 106(f)

nname: 107
n 107(None)[]:
	i: 42(JA), 69(JA), 59(f), 101(AE), 0(f)
	o: 

nname: 69
n 69(None)[#, e
log.debug('Error removing file: %s' % str(e))
]:
	i: 59(t)
	o: 107(JA)

nname: 59
n 59(<dummy_ex3> EXC_MATCH Exception)[]:
	i: 9(except)
	o: 69(t), 107(f)

nname: 42
n 42(None)[unlink(self._file)
]:
	i: 9(try)
	o: 107(JA)

nname: 9
n 9(None)[self._must_delete = 0
log.debug('Removing file %s' % self._file)
]:
	i: 0(t)
	o: 42(try), 59(except)

nname: 0
n 0(self._must_delete)[]:
	i: 
	o: 9(t), 107(f)

nname: 107
n 107(None)[]:
	i: 59(f), 0(f)
	o: 

nname: 59
n 59(None)[except Exception, e:
	log.debug('Error removing file: %s' % str(e))
]:
	i: 9()
	o: 107(JA)

nname: 9
n 9(None)[self._must_delete = 0
log.debug('Removing file %s' % self._file)
try:
	unlink(self._file)
]:
	i: 0(t)
	o: 59()

nname: 0
n 0(self._must_delete)[]:
	i: 
	o: 9(t), 107(f)

nname: 107
n 107(None)[]:
	i: 9(f), 0(f)
	o: 

nname: 9
n 9(None)[self._must_delete = 0
log.debug('Removing file %s' % self._file)
try:
	unlink(self._file)
except Exception, e:
	log.debug('Error removing file: %s' % str(e))
]:
	i: 0(t)
	o: 107(JA)

nname: 0
n 0(self._must_delete)[]:
	i: 
	o: 9(t), 107(f)

nname: 0
n 0(None)[if self._must_delete:
	self._must_delete = 0
	log.debug('Removing file %s' % self._file)
	try:
		unlink(self._file)
	except Exception, e:
		log.debug('Error removing file: %s' % str(e))
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7706f8c>}
nname: 0
n 0(None)[return self._uri
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb770688c>}
nname: 0
n 0(None)[return self._file
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb770662c>}
nname: 418
n 418(None)[return self._file
]:
	i: 346(), 379()
	o: 

nname: 379
n 379(None)[log.debug('Fetching [%s] -> [%s] : Ok' % (self._uri, self._file))
self._must_delete = 1
]:
	i: 331(f)
	o: 418()

nname: 346
n 346(None)[log.debug('Fetching [%s] -> [%s] : Error' % (self._uri, self._file))
]:
	i: 331(t)
	o: 418()

nname: 331
n 331(self._file is None)[]:
	i: 289(JA), 302(), 306()
	o: 346(t), 379(f)

nname: 306
n 306(None)[self._file = wt.wt_do_download(self._uri, '/wymedia/tmp/tmpdest_XXXXXX')
]:
	i: 159(f)
	o: 331()

nname: 302
n 302(None)[]:
	i: 171(f)
	o: 331()

nname: 289
n 289(None)[self._file = None
]:
	i: 171(t)
	o: 331(JA)

nname: 171
n 171(res != wt.WT_COMPLETED)[job = wt.wt_create_job(self._uri, None)
wt.wt_set_transfer_mode(job, wt.WT_DLNA_INTERACTIVE)
wt.wt_set_friendly_name(job, 'wyvas_image')
res = wt.wt_start_job(job)
self._file = wt.wt_get_filename(job)
wt.wt_destroy_job(job)
]:
	i: 159(t)
	o: 289(t), 302(f)

nname: 159
n 159(wytransport_version == 1)[]:
	i: 92(), 128(), 157(AE)
	o: 171(t), 306(f)

nname: 157
n 157(None)[]:
	i: 118(f)
	o: 159(AE)

nname: 128
n 128(None)[from wytransport import pywytransport as wt
wytransport_version = 1
]:
	i: 118(t)
	o: 159()

nname: 118
n 118(<dummy_ex3> EXC_MATCH ImportError)[]:
	i: 89(except)
	o: 128(t), 157(f)

nname: 92
n 92(None)[from wytransport import wtpython as wt
wytransport_version = 2
]:
	i: 89(try)
	o: 159()

nname: 89
n 89(None)[]:
	i: 24(), 88()
	o: 92(try), 118(except)

nname: 88
n 88(None)[]:
	i: 0(f)
	o: 89()

nname: 24
n 24(None)[fn = urllib.unquote(self._uri).replace('file://', '')
log.debug('Fetching [%s] -> [%s] : Ok' % (self._uri, fn))
return fn
]:
	i: 0(t)
	o: 89()

nname: 0
n 0(self._uri.find('file://') == 0)[]:
	i: 
	o: 24(t), 88(f)

nname: 418
n 418(None)[return self._file
]:
	i: 159()
	o: 

nname: 159
n 159(None)[if wytransport_version == 1:
	job = wt.wt_create_job(self._uri, None)
	wt.wt_set_transfer_mode(job, wt.WT_DLNA_INTERACTIVE)
	wt.wt_set_friendly_name(job, 'wyvas_image')
	res = wt.wt_start_job(job)
	self._file = wt.wt_get_filename(job)
	wt.wt_destroy_job(job)
	if res != wt.WT_COMPLETED:
		self._file = None
else:
	self._file = wt.wt_do_download(self._uri, '/wymedia/tmp/tmpdest_XXXXXX')
if self._file is None:
	log.debug('Fetching [%s] -> [%s] : Error' % (self._uri, self._file))
else:
	log.debug('Fetching [%s] -> [%s] : Ok' % (self._uri, self._file))
	self._must_delete = 1
]:
	i: 92()
	o: 418()

nname: 92
n 92(None)[try:
	from wytransport import wtpython as wt
	wytransport_version = 2
except ImportError:
	from wytransport import pywytransport as wt
	wytransport_version = 1
]:
	i: 0(try)
	o: 159()

nname: 0
n 0(None)[if self._uri.find('file://') == 0:
	fn = urllib.unquote(self._uri).replace('file://', '')
	log.debug('Fetching [%s] -> [%s] : Ok' % (self._uri, fn))
	return fn
]:
	i: 
	o: 92(try)

nname: 159
n 159(None)[if wytransport_version == 1:
	job = wt.wt_create_job(self._uri, None)
	wt.wt_set_transfer_mode(job, wt.WT_DLNA_INTERACTIVE)
	wt.wt_set_friendly_name(job, 'wyvas_image')
	res = wt.wt_start_job(job)
	self._file = wt.wt_get_filename(job)
	wt.wt_destroy_job(job)
	if res != wt.WT_COMPLETED:
		self._file = None
else:
	self._file = wt.wt_do_download(self._uri, '/wymedia/tmp/tmpdest_XXXXXX')
if self._file is None:
	log.debug('Fetching [%s] -> [%s] : Error' % (self._uri, self._file))
else:
	log.debug('Fetching [%s] -> [%s] : Ok' % (self._uri, self._file))
	self._must_delete = 1
return self._file
]:
	i: 0()
	o: 

nname: 0
n 0(None)[if self._uri.find('file://') == 0:
	fn = urllib.unquote(self._uri).replace('file://', '')
	log.debug('Fetching [%s] -> [%s] : Ok' % (self._uri, fn))
	return fn
try:
	from wytransport import wtpython as wt
	wytransport_version = 2
except ImportError:
	from wytransport import pywytransport as wt
	wytransport_version = 1
]:
	i: 
	o: 159()

nname: 0
n 0(None)[if self._uri.find('file://') == 0:
	fn = urllib.unquote(self._uri).replace('file://', '')
	log.debug('Fetching [%s] -> [%s] : Ok' % (self._uri, fn))
	return fn
try:
	from wytransport import wtpython as wt
	wytransport_version = 2
except ImportError:
	from wytransport import pywytransport as wt
	wytransport_version = 1
if wytransport_version == 1:
	job = wt.wt_create_job(self._uri, None)
	wt.wt_set_transfer_mode(job, wt.WT_DLNA_INTERACTIVE)
	wt.wt_set_friendly_name(job, 'wyvas_image')
	res = wt.wt_start_job(job)
	self._file = wt.wt_get_filename(job)
	wt.wt_destroy_job(job)
	if res != wt.WT_COMPLETED:
		self._file = None
else:
	self._file = wt.wt_do_download(self._uri, '/wymedia/tmp/tmpdest_XXXXXX')
if self._file is None:
	log.debug('Fetching [%s] -> [%s] : Error' % (self._uri, self._file))
else:
	log.debug('Fetching [%s] -> [%s] : Ok' % (self._uri, self._file))
	self._must_delete = 1
return self._file
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76a318c>}
nname: 6
n 6(None)[def __init__(self, uri):
	self._uri = uri
	self._must_delete = 0
	self._file = ''

def __del__(self):
	self.cleanup()

def cleanup(self):
	if self._must_delete:
		self._must_delete = 0
		log.debug('Removing file %s' % self._file)
		try:
			unlink(self._file)
		except Exception, e:
			log.debug('Error removing file: %s' % str(e))

def get_uri(self):
	return self._uri

def get_file(self):
	return self._file

def get_file_path(self):
	if self._uri.find('file://') == 0:
		fn = urllib.unquote(self._uri).replace('file://', '')
		log.debug('Fetching [%s] -> [%s] : Ok' % (self._uri, fn))
		return fn
	try:
		from wytransport import wtpython as wt
		wytransport_version = 2
	except ImportError:
		from wytransport import pywytransport as wt
		wytransport_version = 1
	if wytransport_version == 1:
		job = wt.wt_create_job(self._uri, None)
		wt.wt_set_transfer_mode(job, wt.WT_DLNA_INTERACTIVE)
		wt.wt_set_friendly_name(job, 'wyvas_image')
		res = wt.wt_start_job(job)
		self._file = wt.wt_get_filename(job)
		wt.wt_destroy_job(job)
		if res != wt.WT_COMPLETED:
			self._file = None
	else:
		self._file = wt.wt_do_download(self._uri, '/wymedia/tmp/tmpdest_XXXXXX')
	if self._file is None:
		log.debug('Fetching [%s] -> [%s] : Error' % (self._uri, self._file))
	else:
		log.debug('Fetching [%s] -> [%s] : Ok' % (self._uri, self._file))
		self._must_delete = 1
	return self._file

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb77063ac>}
nname: 0
n 0(None)[print 'UPDATE ON OBJECT NOT IMPLEMENTING IT:',
print self,
print args,
print kw
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb769480c>}
nname: 0
n 0(None)[print 'INITIALIZE ON OBJECT NOT IMPLEMENTING IT:',
print self,
print args,
print kw
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb769490c>}
nname: 0
n 0(None)[self.obj = WyvasObject(0)
self.parent = None
self.name = 'obj'
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76942ec>}
nname: 0
n 0(None)[print '--------------------------'
print 'OBJ CANVAS :',
print self
print 'parent     :',
print self.parent
print '------properties----------'
print 'visibled   :',
print self.get_visible()
print 'pos        :',
print self.get_pos()
print 'size       :',
print self.get_size()
print 'layer      :',
print self.get_layer()
print 'color      :',
print self.get_color()
print '------internal------------'
self.obj.debug()
print '--------------------------'
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb769428c>}
nname: 54
n 54(None)[self.obj.move(**kw)
]:
	i: 0(AL), 53()
	o: 

nname: 53
n 53(None)[]:
	i: 12(AF), 25()
	o: 54()

nname: 25
n 25(None)[for k, v in kw.iteritems():
kw[k] = arg_str_per(v)
]:
	i: 12(for)
	o: 53()

nname: 12
n 12(None)[]:
	i: 0(loop)
	o: 25(for), 53(AF)

nname: 0
n 0(None)[arg_str_per = Object._arg_str_per
]:
	i: 
	o: 12(loop), 54(AL)

nname: 54
n 54(None)[self.obj.move(**kw)
]:
	i: 25()
	o: 

nname: 25
n 25(None)[for k, v in kw.iteritems():
	kw[k] = arg_str_per(v)
]:
	i: 0(for)
	o: 54()

nname: 0
n 0(None)[arg_str_per = Object._arg_str_per
]:
	i: 
	o: 25(for)

nname: 54
n 54(None)[self.obj.move(**kw)
]:
	i: 0()
	o: 

nname: 0
n 0(None)[arg_str_per = Object._arg_str_per
for k, v in kw.iteritems():
	kw[k] = arg_str_per(v)
]:
	i: 
	o: 54()

nname: 0
n 0(None)[arg_str_per = Object._arg_str_per
for k, v in kw.iteritems():
	kw[k] = arg_str_per(v)
self.obj.move(**kw)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb769494c>}
nname: 35
n 35(None)[self.obj.set_color(color=Object._arg_color(r, g, b, a))
return None
]:
	i: 12(), 34()
	o: 

nname: 34
n 34(None)[]:
	i: 0(f)
	o: 35()

nname: 12
n 12(None)[r, g, b, a = color
]:
	i: 0(t)
	o: 35()

nname: 0
n 0(color is not None)[]:
	i: 
	o: 12(t), 34(f)

nname: 0
n 0(None)[if color is not None:
	r, g, b, a = color
self.obj.set_color(color=Object._arg_color(r, g, b, a))
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb769446c>}
nname: 0
n 0(None)[return self.parent
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb769472c>}
nname: 45
n 45(None)[return None
]:
	i: 15(), 44()
	o: 

nname: 44
n 44(None)[]:
	i: 0(f)
	o: 45()

nname: 15
n 15(None)[self.parent.remove_child(self)
self.parent = None
]:
	i: 0(t)
	o: 45()

nname: 0
n 0(self.parent is not None)[]:
	i: 
	o: 15(t), 44(f)

nname: 0
n 0(None)[if self.parent is not None:
	self.parent.remove_child(self)
	self.parent = None
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7694a8c>}
nname: 0
n 0(None)[self.parent = parent
self.parent._children.append(self)
self.obj.adopted(parent.obj)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb769444c>}
nname: 61
n 61(None)[return None
]:
	i: 15(), 60()
	o: 

nname: 60
n 60(None)[]:
	i: 0(f)
	o: 61()

nname: 15
n 15(None)[self.parent._children.remove(self)
self.parent = None
self.obj.orphaned()
]:
	i: 0(t)
	o: 61()

nname: 0
n 0(self.parent is not None)[]:
	i: 
	o: 15(t), 60(f)

nname: 0
n 0(None)[if self.parent is not None:
	self.parent._children.remove(self)
	self.parent = None
	self.obj.orphaned()
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7694a8c>}
nname: 96
n 96(None)[del _[1]
[](*args, **kw)
]:
	i: 54(AF), 77()
	o: 

nname: 77
n 77(None)[for a in args:
]:
	i: 54(for)
	o: 96()

nname: 54
n 54(None)[]:
	i: 0(AL), 53()
	o: 77(for), 96(AF)

nname: 53
n 53(None)[]:
	i: 12(AF), 25()
	o: 54()

nname: 25
n 25(None)[_[1], k, v = [], kw.iteritems(), kw.iteritems()
kw[k] = arg_str_per(v)
]:
	i: 12(for)
	o: 53()

nname: 12
n 12(None)[]:
	i: 0(loop)
	o: 25(for), 53(AF)

nname: 0
n 0(None)[arg_str_per = Object._arg_str_per
]:
	i: 
	o: 12(loop), 54(AL)

nname: 96
n 96(None)[del _[1]
[](*args, **kw)
]:
	i: 54(AF), 77()
	o: 

nname: 77
n 77(None)[for a in args:
]:
	i: 54(for)
	o: 96()

nname: 54
n 54(None)[]:
	i: 25()
	o: 77(for), 96(AF)

nname: 25
n 25(None)[_[1], k, v = [], kw.iteritems(), kw.iteritems()
	kw[k] = arg_str_per(v)
]:
	i: 0(for)
	o: 54()

nname: 0
n 0(None)[arg_str_per = Object._arg_str_per
]:
	i: 
	o: 25(for)

nname: 96
n 96(None)[del _[1]
[](*args, **kw)
]:
	i: 54(AF), 77()
	o: 

nname: 77
n 77(None)[for a in args:
]:
	i: 54(for)
	o: 96()

nname: 54
n 54(None)[]:
	i: 0()
	o: 77(for), 96(AF)

nname: 0
n 0(None)[arg_str_per = Object._arg_str_per
_[1], k, v = [], kw.iteritems(), kw.iteritems()
	kw[k] = arg_str_per(v)
]:
	i: 
	o: 54()

nname: 96
n 96(None)[del _[1]
[](*args, **kw)
]:
	i: 0(AF), 77()
	o: 

nname: 77
n 77(None)[for a in args:
]:
	i: 0(for)
	o: 96()

nname: 0
n 0(None)[arg_str_per = Object._arg_str_per
_[1], k, v = [], kw.iteritems(), kw.iteritems()
	kw[k] = arg_str_per(v)
]:
	i: 
	o: 77(for), 96(AF)

self.nodes: {0: <unpyclib.structure.node instance at 0xb769482c>, 96: <unpyclib.structure.node instance at 0xb7694fac>, 77: <unpyclib.structure.node instance at 0xb769486c>}
nname: 0
n 0(None)[return self.obj.get_pos()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76946ec>}
nname: 0
n 0(None)[return self.obj.get_size()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76948ac>}
nname: 0
n 0(None)[return self.obj.get_color()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76946cc>}
nname: 0
n 0(None)[self.set_color(a=opacity)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb769490c>}
nname: 0
n 0(None)[return self.get_color()[3]
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb769470c>}
nname: 0
n 0(None)[self.name = name
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb769478c>}
nname: 0
n 0(None)[return self.name
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb769470c>}
nname: 49
n 49(None)[]:
	i: 6(), 29()
	o: 

nname: 29
n 29(None)[self.obj.set_layer(layer=layer)
]:
	i: 0(f)
	o: 49()

nname: 6
n 6(None)[self.obj.set_layer(abs_layer=layer)
]:
	i: 0(t)
	o: 49()

nname: 0
n 0(absolute)[]:
	i: 
	o: 6(t), 29(f)

nname: 0
n 0(None)[if absolute:
	self.obj.set_layer(abs_layer=layer)
else:
	self.obj.set_layer(layer=layer)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7694dec>}
nname: 0
n 0(None)[return self.obj.get_layer(absolute)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7694b2c>}
nname: 0
n 0(None)[self.obj.show()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb769472c>}
nname: 0
n 0(None)[self.obj.hide()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7694eac>}
nname: 0
n 0(None)[self.obj.set_visible(visible)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb769476c>}
nname: 0
n 0(None)[return self.obj.get_visible()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb769436c>}
nname: 0
n 0(None)[self.obj.set_aspect_preserve(preserve_aspect)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7694dec>}
nname: 42
n 42(None)[return None
]:
	i: 21(), 41()
	o: 

nname: 41
n 41(None)[]:
	i: 0(f)
	o: 42()

nname: 21
n 21(None)[self._end_callback = None
ec()
]:
	i: 0(t)
	o: 42()

nname: 0
n 0(ec is not None)[ec = self._end_callback
]:
	i: 
	o: 21(t), 41(f)

nname: 0
n 0(None)[ec = self._end_callback
if ec is not None:
	self._end_callback = None
	ec()
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb769472c>}
nname: 40
n 40(None)[self.obj.animate_stop(type)
self._end_callback = None
return None
]:
	i: 12(), 22()
	o: 

nname: 22
n 22(None)[type = self.animator_dict[type][0]
]:
	i: 0(f)
	o: 40()

nname: 12
n 12(None)[type = 4
]:
	i: 0(t)
	o: 40()

nname: 0
n 0(type is None)[]:
	i: 
	o: 12(t), 22(f)

nname: 0
n 0(None)[if type is None:
	type = 4
else:
	type = self.animator_dict[type][0]
self.obj.animate_stop(type)
self._end_callback = None
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7694fac>}
nname: 499
n 499(None)[return None
]:
	i: 447(), 466()
	o: 

nname: 466
n 466(None)[getattr(self.obj, animator_call)(**arg)
self._invoke_end_callback()
]:
	i: 386(f)
	o: 499()

nname: 447
n 447(None)[self.obj.animate(**arg)
]:
	i: 429(), 446()
	o: 499()

nname: 446
n 446(None)[]:
	i: 413(f)
	o: 447()

nname: 429
n 429(None)[arg['end_callback'] = self._invoke_end_callback
]:
	i: 413(t)
	o: 447()

nname: 413
n 413(self._end_callback is not None)[]:
	i: 386(t)
	o: 429(t), 446(f)

nname: 386
n 386(duration != 0)[self._end_callback = kwargs_get('end_callback')
]:
	i: 361(), 385()
	o: 413(t), 466(f)

nname: 385
n 385(None)[]:
	i: 346(f)
	o: 386()

nname: 361
n 361(None)[log.debug('WYVAS WARNING, end_callback overridden !! (%s)' % self._end_callback)
]:
	i: 346(t)
	o: 386()

nname: 346
n 346(self._end_callback is not None)[]:
	i: 217(), 318()
	o: 361(t), 385(f)

nname: 318
n 318(None)[arg['color'] = Object._arg_color(r, g, b, a)
]:
	i: 301(), 317()
	o: 346()

nname: 317
n 317(None)[]:
	i: 240(f)
	o: 318()

nname: 301
n 301(None)[a = kwargs_get('opacity')
]:
	i: 240(t)
	o: 318()

nname: 240
n 240(a is None)[r = kwargs_get('r')
g = kwargs_get('g')
b = kwargs_get('b')
a = kwargs_get('a')
]:
	i: 193(f)
	o: 301(t), 317(f)

nname: 217
n 217(None)[arg['color'] = Object._arg_color(*color)
]:
	i: 193(t)
	o: 346()

nname: 193
n 193(color is not None)[color = kwargs_get('color')
]:
	i: 0(AL), 192()
	o: 217(t), 240(f)

nname: 192
n 192(None)[]:
	i: 131(AF), 188()
	o: 193()

nname: 188
n 188(None)[]:
	i: 141(f), 168()
	o: 192()

nname: 168
n 168(None)[arg[argname] = arg_str_per(val)
continue
]:
	i: 141(t)
	o: 188()

nname: 141
n 141(val is not None)[for argname in Object.percentage_arg_tuple:
val = kwargs_get(argname)
]:
	i: 131(for)
	o: 168(t), 188(f)

nname: 131
n 131(None)[]:
	i: 0(loop)
	o: 141(for), 192(AF)

nname: 0
n 0(None)[arg = {}
kwargs_get = kwargs.get
duration = kwargs_get('duration', 1) * 1000
arg['duration'] = duration
arg['animator'], animator_call = self.animator_dict[method]
arg['step_type'] = Object.step_type_dict[kwargs_get('step_type', 'linear')]
arg['loop_type'] = Object.loop_type_dict[kwargs_get('loop_type', 'none')]
arg_str_per = Object._arg_str_per
]:
	i: 
	o: 131(loop), 193(AL)

nname: 499
n 499(None)[return None
]:
	i: 413(), 466()
	o: 

nname: 466
n 466(None)[getattr(self.obj, animator_call)(**arg)
self._invoke_end_callback()
]:
	i: 346(f)
	o: 499()

nname: 413
n 413(None)[if self._end_callback is not None:
	arg['end_callback'] = self._invoke_end_callback
self.obj.animate(**arg)
]:
	i: 346(t)
	o: 499()

nname: 346
n 346(duration != 0)[if self._end_callback is not None:
	log.debug('WYVAS WARNING, end_callback overridden !! (%s)' % self._end_callback)
self._end_callback = kwargs_get('end_callback')
]:
	i: 217(), 240()
	o: 413(t), 466(f)

nname: 240
n 240(None)[r = kwargs_get('r')
g = kwargs_get('g')
b = kwargs_get('b')
a = kwargs_get('a')
if a is None:
	a = kwargs_get('opacity')
arg['color'] = Object._arg_color(r, g, b, a)
]:
	i: 193(f)
	o: 346()

nname: 217
n 217(None)[arg['color'] = Object._arg_color(*color)
]:
	i: 193(t)
	o: 346()

nname: 193
n 193(color is not None)[color = kwargs_get('color')
]:
	i: 0(AL), 131(AF), 141()
	o: 217(t), 240(f)

nname: 141
n 141(None)[for argname in Object.percentage_arg_tuple:
val = kwargs_get(argname)
if val is not None:
	arg[argname] = arg_str_per(val)
	continue
]:
	i: 131(for)
	o: 193()

nname: 131
n 131(None)[]:
	i: 0(loop)
	o: 141(for), 193(AF)

nname: 0
n 0(None)[arg = {}
kwargs_get = kwargs.get
duration = kwargs_get('duration', 1) * 1000
arg['duration'] = duration
arg['animator'], animator_call = self.animator_dict[method]
arg['step_type'] = Object.step_type_dict[kwargs_get('step_type', 'linear')]
arg['loop_type'] = Object.loop_type_dict[kwargs_get('loop_type', 'none')]
arg_str_per = Object._arg_str_per
]:
	i: 
	o: 131(loop), 193(AL)

nname: 346
n 346(None)[if self._end_callback is not None:
	log.debug('WYVAS WARNING, end_callback overridden !! (%s)' % self._end_callback)
self._end_callback = kwargs_get('end_callback')
if duration != 0:
	if self._end_callback is not None:
		arg['end_callback'] = self._invoke_end_callback
	self.obj.animate(**arg)
else:
	getattr(self.obj, animator_call)(**arg)
	self._invoke_end_callback()
return None
]:
	i: 141()
	o: 

nname: 141
n 141(None)[for argname in Object.percentage_arg_tuple:
	val = kwargs_get(argname)
	if val is not None:
		arg[argname] = arg_str_per(val)
		continue
color = kwargs_get('color')
if color is not None:
	arg['color'] = Object._arg_color(*color)
else:
	r = kwargs_get('r')
	g = kwargs_get('g')
	b = kwargs_get('b')
	a = kwargs_get('a')
	if a is None:
		a = kwargs_get('opacity')
	arg['color'] = Object._arg_color(r, g, b, a)
]:
	i: 0(for)
	o: 346()

nname: 0
n 0(None)[arg = {}
kwargs_get = kwargs.get
duration = kwargs_get('duration', 1) * 1000
arg['duration'] = duration
arg['animator'], animator_call = self.animator_dict[method]
arg['step_type'] = Object.step_type_dict[kwargs_get('step_type', 'linear')]
arg['loop_type'] = Object.loop_type_dict[kwargs_get('loop_type', 'none')]
arg_str_per = Object._arg_str_per
]:
	i: 
	o: 141(for)

nname: 346
n 346(None)[if self._end_callback is not None:
	log.debug('WYVAS WARNING, end_callback overridden !! (%s)' % self._end_callback)
self._end_callback = kwargs_get('end_callback')
if duration != 0:
	if self._end_callback is not None:
		arg['end_callback'] = self._invoke_end_callback
	self.obj.animate(**arg)
else:
	getattr(self.obj, animator_call)(**arg)
	self._invoke_end_callback()
return None
]:
	i: 0()
	o: 

nname: 0
n 0(None)[arg = {}
kwargs_get = kwargs.get
duration = kwargs_get('duration', 1) * 1000
arg['duration'] = duration
arg['animator'], animator_call = self.animator_dict[method]
arg['step_type'] = Object.step_type_dict[kwargs_get('step_type', 'linear')]
arg['loop_type'] = Object.loop_type_dict[kwargs_get('loop_type', 'none')]
arg_str_per = Object._arg_str_per
for argname in Object.percentage_arg_tuple:
	val = kwargs_get(argname)
	if val is not None:
		arg[argname] = arg_str_per(val)
		continue
color = kwargs_get('color')
if color is not None:
	arg['color'] = Object._arg_color(*color)
else:
	r = kwargs_get('r')
	g = kwargs_get('g')
	b = kwargs_get('b')
	a = kwargs_get('a')
	if a is None:
		a = kwargs_get('opacity')
	arg['color'] = Object._arg_color(r, g, b, a)
]:
	i: 
	o: 346()

nname: 0
n 0(None)[arg = {}
kwargs_get = kwargs.get
duration = kwargs_get('duration', 1) * 1000
arg['duration'] = duration
arg['animator'], animator_call = self.animator_dict[method]
arg['step_type'] = Object.step_type_dict[kwargs_get('step_type', 'linear')]
arg['loop_type'] = Object.loop_type_dict[kwargs_get('loop_type', 'none')]
arg_str_per = Object._arg_str_per
for argname in Object.percentage_arg_tuple:
	val = kwargs_get(argname)
	if val is not None:
		arg[argname] = arg_str_per(val)
		continue
color = kwargs_get('color')
if color is not None:
	arg['color'] = Object._arg_color(*color)
else:
	r = kwargs_get('r')
	g = kwargs_get('g')
	b = kwargs_get('b')
	a = kwargs_get('a')
	if a is None:
		a = kwargs_get('opacity')
	arg['color'] = Object._arg_color(r, g, b, a)
if self._end_callback is not None:
	log.debug('WYVAS WARNING, end_callback overridden !! (%s)' % self._end_callback)
self._end_callback = kwargs_get('end_callback')
if duration != 0:
	if self._end_callback is not None:
		arg['end_callback'] = self._invoke_end_callback
	self.obj.animate(**arg)
else:
	getattr(self.obj, animator_call)(**arg)
	self._invoke_end_callback()
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76a548c>}
nname: 0
n 0(None)[self.obj.set_aspect_ratio(ratio)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7694eac>}
nname: 0
n 0(None)[self.obj.set_keep_real_size(keep_real_size)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76942ac>}
nname: 6
n 6(None)[__doc__ = '\n    Root class for all Wyvas objects.\n\n    This class defines the default methods that may or should be\n    overriden by other more specialized Wyvas objects such as\n    L{Container}, L{Image}...\n    '
_end_callback = None
animator_dict = dict(move=(1, 'move'), size=(2, 'resize'), scale=(2, 'resize'), color=(3, 'set_color'), opacity=(3, 'set_color'))
step_type_dict = dict(linear=0, log=1, exp=2, samples=3, easeinout=3, easein=4, easeout=5, bounce=6)
loop_type_dict = dict(none=0, redo=1, boom=2)
percentage_arg_tuple = ('top', 'bottom', 'right', 'left', 'hcenter', 'vcenter', 'width', 'height')
def update(self, *args, **args):
	print 'UPDATE ON OBJECT NOT IMPLEMENTING IT:',
	print self,
	print args,
	print kw

def initialize(self, *args, **args):
	print 'INITIALIZE ON OBJECT NOT IMPLEMENTING IT:',
	print self,
	print args,
	print kw

def __init__(self):
	self.obj = WyvasObject(0)
	self.parent = None
	self.name = 'obj'
	return None

def _print_attributes(self):
	print '--------------------------'
	print 'OBJ CANVAS :',
	print self
	print 'parent     :',
	print self.parent
	print '------properties----------'
	print 'visibled   :',
	print self.get_visible()
	print 'pos        :',
	print self.get_pos()
	print 'size       :',
	print self.get_size()
	print 'layer      :',
	print self.get_layer()
	print 'color      :',
	print self.get_color()
	print '------internal------------'
	self.obj.debug()
	print '--------------------------'

_arg_str_per = staticmethod()
_arg_color = staticmethod()
def move(self, **kw):
	arg_str_per = Object._arg_str_per
	for k, v in kw.iteritems():
		kw[k] = arg_str_per(v)
	self.obj.move(**kw)

def set_color(self, r=None, g=None, b=None, a=None, color=None):
	if color is not None:
		r, g, b, a = color
	self.obj.set_color(color=Object._arg_color(r, g, b, a))
	return None

def get_parent(self):
	return self.parent

def unparent(self):
	if self.parent is not None:
		self.parent.remove_child(self)
		self.parent = None
	return None

def adopted(self, parent):
	self.parent = parent
	self.parent._children.append(self)
	self.obj.adopted(parent.obj)

def orphaned(self):
	if self.parent is not None:
		self.parent._children.remove(self)
		self.parent = None
		self.obj.orphaned()
	return None

def resize(self, *args, **args):
	arg_str_per = Object._arg_str_per
	_[1], k, v = [], kw.iteritems(), kw.iteritems()
		kw[k] = arg_str_per(v)

def get_pos(self):
	return self.obj.get_pos()

def get_size(self):
	return self.obj.get_size()

def get_color(self):
	return self.obj.get_color()

def set_opacity(self, opacity):
	self.set_color(a=opacity)

def get_opacity(self):
	return self.get_color()[3]

def set_name(self, name):
	self.name = name

def get_name(self):
	return self.name

def set_layer(self, layer, absolute=0):
	if absolute:
		self.obj.set_layer(abs_layer=layer)
	else:
		self.obj.set_layer(layer=layer)

def get_layer(self, absolute=0):
	return self.obj.get_layer(absolute)

def show(self):
	self.obj.show()

def hide(self):
	self.obj.hide()

def set_visible(self, visible):
	self.obj.set_visible(visible)

def get_visible(self):
	return self.obj.get_visible()

def set_aspect(self, preserve_aspect=0):
	self.obj.set_aspect_preserve(preserve_aspect)

def _invoke_end_callback(self):
	ec = self._end_callback
	if ec is not None:
		self._end_callback = None
		ec()
	return None

def animate_stop(self, type=None):
	if type is None:
		type = 4
	else:
		type = self.animator_dict[type][0]
	self.obj.animate_stop(type)
	self._end_callback = None
	return None

def animate(self, method, **kwargs):
	arg = {}
	kwargs_get = kwargs.get
	duration = kwargs_get('duration', 1) * 1000
	arg['duration'] = duration
	arg['animator'], animator_call = self.animator_dict[method]
	arg['step_type'] = Object.step_type_dict[kwargs_get('step_type', 'linear')]
	arg['loop_type'] = Object.loop_type_dict[kwargs_get('loop_type', 'none')]
	arg_str_per = Object._arg_str_per
	for argname in Object.percentage_arg_tuple:
		val = kwargs_get(argname)
		if val is not None:
			arg[argname] = arg_str_per(val)
			continue
	color = kwargs_get('color')
	if color is not None:
		arg['color'] = Object._arg_color(*color)
	else:
		r = kwargs_get('r')
		g = kwargs_get('g')
		b = kwargs_get('b')
		a = kwargs_get('a')
		if a is None:
			a = kwargs_get('opacity')
		arg['color'] = Object._arg_color(r, g, b, a)
	if self._end_callback is not None:
		log.debug('WYVAS WARNING, end_callback overridden !! (%s)' % self._end_callback)
	self._end_callback = kwargs_get('end_callback')
	if duration != 0:
		if self._end_callback is not None:
			arg['end_callback'] = self._invoke_end_callback
		self.obj.animate(**arg)
	else:
		getattr(self.obj, animator_call)(**arg)
		self._invoke_end_callback()
	return None

def set_aspect_ratio(self, ratio=0):
	self.obj.set_aspect_ratio(ratio)

def set_keep_real_size(self, keep_real_size=0):
	self.obj.set_keep_real_size(keep_real_size)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb76a318c>}
nname: 344
n 344(None)[self.parent = None
return None
]:
	i: 244(), 281(), 331()
	o: 

nname: 331
n 331(None)[raise TypeError('Images can be build from a string or a buffer only !!')
]:
	i: 265(f)
	o: 344()

nname: 281
n 281(None)[data = image_or_file
self.obj = WyvasObject(1, **arg)
self.obj.set_data(data, size, False)
]:
	i: 265(t)
	o: 344()

nname: 265
n 265(isinstance(image_or_file, buffer))[]:
	i: 108&129(f)
	o: 281(t), 331(f)

nname: 244
n 244(None)[self.obj = WyvasObject(1, **arg)
]:
	i: 168(JA), 201(JA), 240(), 243()
	o: 344()

nname: 243
n 243(None)[]:
	i: 142(f)
	o: 244()

nname: 240
n 240(None)[]:
	i: 238(AE)
	o: 244()

nname: 238
n 238(None)[]:
	i: 191(f)
	o: 240(AE)

nname: 201
n 201(None)[#, e
log.error(str(e))
self._file = None
]:
	i: 191(t)
	o: 244(JA)

nname: 191
n 191(<dummy_ex3> EXC_MATCH NameError)[]:
	i: 155(except)
	o: 201(t), 238(f)

nname: 168
n 168(None)[arg['filename'] = self._find_file(image_or_file)
]:
	i: 155(try)
	o: 244(JA)

nname: 155
n 155(None)[self._file = image_or_file
]:
	i: 142(t)
	o: 168(try), 191(except)

nname: 142
n 142(image_or_file is not None)[]:
	i: 108&129(t)
	o: 155(t), 243(f)

nname: 108&129
n 108&129(isinstance(image_or_file, basestring) or image_or_file is None)[arg = {}
]:
	i: 73(), 107()
	o: 142(t), 265(f)

nname: 107
n 107(None)[]:
	i: 0&57(f)
	o: 108&129()

nname: 73
n 73(None)[self._url = InternalUrl(url)
image_or_file = self._url.get_file_path()
]:
	i: 0&57(t)
	o: 108&129()

nname: 0&57
n 0&57(url is not None and isinstance(url, basestring))[self.name = 'obj'
self._repository = repository
self._file = None
self._url = None
self._angle = 0
]:
	i: 
	o: 73(t), 107(f)

nname: 344
n 344(None)[self.parent = None
return None
]:
	i: 244(), 265()
	o: 

nname: 265
n 265(None)[if isinstance(image_or_file, buffer):
	data = image_or_file
	self.obj = WyvasObject(1, **arg)
	self.obj.set_data(data, size, False)
else:
	raise TypeError('Images can be build from a string or a buffer only !!')
]:
	i: 0&57(f)
	o: 344()

nname: 244
n 244(None)[self.obj = WyvasObject(1, **arg)
]:
	i: 168(JA), 201(JA), 191(f), 238(AE), 142(f)
	o: 344()

nname: 201
n 201(None)[#, e
log.error(str(e))
self._file = None
]:
	i: 191(t)
	o: 244(JA)

nname: 191
n 191(<dummy_ex3> EXC_MATCH NameError)[]:
	i: 155(except)
	o: 201(t), 244(f)

nname: 168
n 168(None)[arg['filename'] = self._find_file(image_or_file)
]:
	i: 155(try)
	o: 244(JA)

nname: 155
n 155(None)[self._file = image_or_file
]:
	i: 142(t)
	o: 168(try), 191(except)

nname: 142
n 142(image_or_file is not None)[]:
	i: 0&57(t)
	o: 155(t), 244(f)

nname: 0&57
n 0&57(isinstance(image_or_file, basestring) or image_or_file is None)[self.name = 'obj'
self._repository = repository
self._file = None
self._url = None
self._angle = 0
if url is not None and isinstance(url, basestring):
	self._url = InternalUrl(url)
	image_or_file = self._url.get_file_path()
arg = {}
]:
	i: 
	o: 142(t), 265(f)

nname: 344
n 344(None)[self.parent = None
return None
]:
	i: 244(), 265()
	o: 

nname: 265
n 265(None)[if isinstance(image_or_file, buffer):
	data = image_or_file
	self.obj = WyvasObject(1, **arg)
	self.obj.set_data(data, size, False)
else:
	raise TypeError('Images can be build from a string or a buffer only !!')
]:
	i: 0&57(f)
	o: 344()

nname: 244
n 244(None)[self.obj = WyvasObject(1, **arg)
]:
	i: 191(f), 142(f)
	o: 344()

nname: 191
n 191(None)[except NameError, e:
	log.error(str(e))
	self._file = None
]:
	i: 155()
	o: 244(JA)

nname: 155
n 155(None)[self._file = image_or_file
try:
	arg['filename'] = self._find_file(image_or_file)
]:
	i: 142(t)
	o: 191()

nname: 142
n 142(image_or_file is not None)[]:
	i: 0&57(t)
	o: 155(t), 244(f)

nname: 0&57
n 0&57(isinstance(image_or_file, basestring) or image_or_file is None)[self.name = 'obj'
self._repository = repository
self._file = None
self._url = None
self._angle = 0
if url is not None and isinstance(url, basestring):
	self._url = InternalUrl(url)
	image_or_file = self._url.get_file_path()
arg = {}
]:
	i: 
	o: 142(t), 265(f)

nname: 344
n 344(None)[self.parent = None
return None
]:
	i: 244(), 265()
	o: 

nname: 265
n 265(None)[if isinstance(image_or_file, buffer):
	data = image_or_file
	self.obj = WyvasObject(1, **arg)
	self.obj.set_data(data, size, False)
else:
	raise TypeError('Images can be build from a string or a buffer only !!')
]:
	i: 0&57(f)
	o: 344()

nname: 244
n 244(None)[self.obj = WyvasObject(1, **arg)
]:
	i: 155(f), 142(f)
	o: 344()

nname: 155
n 155(None)[self._file = image_or_file
try:
	arg['filename'] = self._find_file(image_or_file)
except NameError, e:
	log.error(str(e))
	self._file = None
]:
	i: 142(t)
	o: 244(JA)

nname: 142
n 142(image_or_file is not None)[]:
	i: 0&57(t)
	o: 155(t), 244(f)

nname: 0&57
n 0&57(isinstance(image_or_file, basestring) or image_or_file is None)[self.name = 'obj'
self._repository = repository
self._file = None
self._url = None
self._angle = 0
if url is not None and isinstance(url, basestring):
	self._url = InternalUrl(url)
	image_or_file = self._url.get_file_path()
arg = {}
]:
	i: 
	o: 142(t), 265(f)

nname: 344
n 344(None)[self.parent = None
return None
]:
	i: 142(), 265()
	o: 

nname: 265
n 265(None)[if isinstance(image_or_file, buffer):
	data = image_or_file
	self.obj = WyvasObject(1, **arg)
	self.obj.set_data(data, size, False)
else:
	raise TypeError('Images can be build from a string or a buffer only !!')
]:
	i: 0&57(f)
	o: 344()

nname: 142
n 142(None)[if image_or_file is not None:
	self._file = image_or_file
	try:
		arg['filename'] = self._find_file(image_or_file)
	except NameError, e:
		log.error(str(e))
		self._file = None
self.obj = WyvasObject(1, **arg)
]:
	i: 0&57(t)
	o: 344()

nname: 0&57
n 0&57(isinstance(image_or_file, basestring) or image_or_file is None)[self.name = 'obj'
self._repository = repository
self._file = None
self._url = None
self._angle = 0
if url is not None and isinstance(url, basestring):
	self._url = InternalUrl(url)
	image_or_file = self._url.get_file_path()
arg = {}
]:
	i: 
	o: 142(t), 265(f)

nname: 0&57
n 0&57(None)[self.name = 'obj'
self._repository = repository
self._file = None
self._url = None
self._angle = 0
if url is not None and isinstance(url, basestring):
	self._url = InternalUrl(url)
	image_or_file = self._url.get_file_path()
arg = {}
if isinstance(image_or_file, basestring) or image_or_file is None:
	if image_or_file is not None:
		self._file = image_or_file
		try:
			arg['filename'] = self._find_file(image_or_file)
		except NameError, e:
			log.error(str(e))
			self._file = None
	self.obj = WyvasObject(1, **arg)
else:
	if isinstance(image_or_file, buffer):
		data = image_or_file
		self.obj = WyvasObject(1, **arg)
		self.obj.set_data(data, size, False)
	else:
		raise TypeError('Images can be build from a string or a buffer only !!')
self.parent = None
return None
]:
	i: 
	o: 

self.nodes: {'0&57': <unpyclib.structure.node instance at 0xb76a352c>}
nname: 91
n 91(None)[]:
	i: 45(), 71()
	o: 

nname: 71
n 71(None)[self.load(value, callback=callback)
]:
	i: 0&15&32(f)
	o: 91()

nname: 45
n 45(None)[self.load(url=value, callback=callback)
]:
	i: 0&15&32(t)
	o: 91()

nname: 0&15&32
n 0&15&32(isinstance(value, basestring) and value[0] != '/' and '://' in value)[]:
	i: 
	o: 45(t), 71(f)

nname: 0&15&32
n 0&15&32(None)[if isinstance(value, basestring) and value[0] != '/' and '://' in value:
	self.load(url=value, callback=callback)
else:
	self.load(value, callback=callback)
]:
	i: 
	o: 

self.nodes: {'0&15&32': <unpyclib.structure.node instance at 0xb76a344c>}
nname: 0
n 0(None)[self.obj.set_border(left, right, top, bottom)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7694d8c>}
nname: 244
n 244(None)[self._angle = 0
self.obj.load(self._file, callback)
return None
]:
	i: 133(JA), 150(JA), 182(JA), 216(), 235(), 243()
	o: 

nname: 243
n 243(None)[]:
	i: 219(f)
	o: 244()

nname: 235
n 235(None)[return None
]:
	i: 219(t)
	o: 244()

nname: 219
n 219(self._angle == 0)[]:
	i: 105(f)
	o: 235(t), 243(f)

nname: 216
n 216(None)[]:
	i: 214(AE)
	o: 244()

nname: 214
n 214(None)[]:
	i: 172(f)
	o: 216(AE)

nname: 182
n 182(None)[log.info("Can't find '%s' !", file)
self._file = ''
]:
	i: 172(t)
	o: 244(JA)

nname: 172
n 172(<dummy_ex3> EXC_MATCH NameError)[]:
	i: 146(except)
	o: 182(t), 214(f)

nname: 150
n 150(None)[self._file = self._find_file(file)
]:
	i: 146(try)
	o: 244(JA)

nname: 146
n 146(None)[]:
	i: 120(f)
	o: 150(try), 172(except)

nname: 133
n 133(None)[self._file = ''
]:
	i: 120(t)
	o: 244(JA)

nname: 120
n 120(file is None)[]:
	i: 105(t)
	o: 133(t), 146(f)

nname: 105
n 105(file != self._file)[]:
	i: 70(), 104()
	o: 120(t), 219(f)

nname: 104
n 104(None)[]:
	i: 42&54(f)
	o: 105()

nname: 70
n 70(None)[self._url = InternalUrl(url)
file = self._url.get_file_path()
]:
	i: 42&54(t)
	o: 105()

nname: 42&54
n 42&54(url is not None and isinstance(url, basestring))[]:
	i: 15(), 41()
	o: 70(t), 104(f)

nname: 41
n 41(None)[]:
	i: 0(f)
	o: 42&54()

nname: 15
n 15(None)[self._url.cleanup()
self._url = None
]:
	i: 0(t)
	o: 42&54()

nname: 0
n 0(self._url is not None)[]:
	i: 
	o: 15(t), 41(f)

nname: 244
n 244(None)[self._angle = 0
self.obj.load(self._file, callback)
return None
]:
	i: 133(JA), 150(JA), 182(JA), 219(), 172(f), 214(AE)
	o: 

nname: 219
n 219(None)[if self._angle == 0:
	return None
]:
	i: 105(f)
	o: 244()

nname: 182
n 182(None)[log.info("Can't find '%s' !", file)
self._file = ''
]:
	i: 172(t)
	o: 244(JA)

nname: 172
n 172(<dummy_ex3> EXC_MATCH NameError)[]:
	i: 146(except)
	o: 182(t), 244(f)

nname: 150
n 150(None)[self._file = self._find_file(file)
]:
	i: 146(try)
	o: 244(JA)

nname: 146
n 146(None)[]:
	i: 120(f)
	o: 150(try), 172(except)

nname: 133
n 133(None)[self._file = ''
]:
	i: 120(t)
	o: 244(JA)

nname: 120
n 120(file is None)[]:
	i: 105(t)
	o: 133(t), 146(f)

nname: 105
n 105(file != self._file)[]:
	i: 0()
	o: 120(t), 219(f)

nname: 0
n 0(None)[if self._url is not None:
	self._url.cleanup()
	self._url = None
if url is not None and isinstance(url, basestring):
	self._url = InternalUrl(url)
	file = self._url.get_file_path()
]:
	i: 
	o: 105()

nname: 244
n 244(None)[self._angle = 0
self.obj.load(self._file, callback)
return None
]:
	i: 133(JA), 219(), 172(f)
	o: 

nname: 219
n 219(None)[if self._angle == 0:
	return None
]:
	i: 0(f)
	o: 244()

nname: 172
n 172(None)[except NameError:
	log.info("Can't find '%s' !", file)
	self._file = ''
]:
	i: 146()
	o: 244(JA)

nname: 146
n 146(None)[try:
	self._file = self._find_file(file)
]:
	i: 120(f)
	o: 172()

nname: 133
n 133(None)[self._file = ''
]:
	i: 120(t)
	o: 244(JA)

nname: 120
n 120(file is None)[]:
	i: 0(t)
	o: 133(t), 146(f)

nname: 0
n 0(file != self._file)[if self._url is not None:
	self._url.cleanup()
	self._url = None
if url is not None and isinstance(url, basestring):
	self._url = InternalUrl(url)
	file = self._url.get_file_path()
]:
	i: 
	o: 120(t), 219(f)

nname: 244
n 244(None)[self._angle = 0
self.obj.load(self._file, callback)
return None
]:
	i: 133(JA), 219(), 146(f)
	o: 

nname: 219
n 219(None)[if self._angle == 0:
	return None
]:
	i: 0(f)
	o: 244()

nname: 146
n 146(None)[try:
	self._file = self._find_file(file)
except NameError:
	log.info("Can't find '%s' !", file)
	self._file = ''
]:
	i: 120(f)
	o: 244(JA)

nname: 133
n 133(None)[self._file = ''
]:
	i: 120(t)
	o: 244(JA)

nname: 120
n 120(file is None)[]:
	i: 0(t)
	o: 133(t), 146(f)

nname: 0
n 0(file != self._file)[if self._url is not None:
	self._url.cleanup()
	self._url = None
if url is not None and isinstance(url, basestring):
	self._url = InternalUrl(url)
	file = self._url.get_file_path()
]:
	i: 
	o: 120(t), 219(f)

nname: 0
n 0(None)[if self._url is not None:
	self._url.cleanup()
	self._url = None
if url is not None and isinstance(url, basestring):
	self._url = InternalUrl(url)
	file = self._url.get_file_path()
if file != self._file:
	if file is None:
		self._file = ''
	else:
		try:
			self._file = self._find_file(file)
		except NameError:
			log.info("Can't find '%s' !", file)
			self._file = ''
else:
	if self._angle == 0:
		return None
self._angle = 0
self.obj.load(self._file, callback)
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76a34cc>}
nname: 67
n 67(None)[]:
	i: 16(), 66()
	o: 

nname: 66
n 66(None)[]:
	i: 0(f)
	o: 67()

nname: 16
n 16(None)[self.obj.rotate(angle)
self._angle += angle
self._angle %= 4
]:
	i: 0(t)
	o: 67()

nname: 0
n 0(angle)[angle %= 4
]:
	i: 
	o: 16(t), 66(f)

nname: 0
n 0(None)[angle %= 4
if angle:
	self.obj.rotate(angle)
	self._angle += angle
	self._angle %= 4
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7694fcc>}
nname: 83
n 83(None)[raise NameError('Unable to find file %s!' % filename)
]:
	i: 15(), 70(JA), 78(), 82()
	o: 

nname: 82
n 82(None)[]:
	i: 23(f)
	o: 83()

nname: 78
n 78(None)[]:
	i: 33(f)
	o: 83()

nname: 70
n 70(None)[return fullpath
]:
	i: 33(t)
	o: 83(JA)

nname: 33
n 33(path.exists(fullpath))[fullpath = path.join(self._repository, filename)
]:
	i: 23(t)
	o: 70(t), 78(f)

nname: 23
n 23(self._repository)[]:
	i: 0(f)
	o: 33(t), 82(f)

nname: 15
n 15(None)[return filename
]:
	i: 0(t)
	o: 83()

nname: 0
n 0(path.exists(filename))[]:
	i: 
	o: 15(t), 23(f)

nname: 0
n 0(None)[if path.exists(filename):
	return filename
else:
	if self._repository:
		fullpath = path.join(self._repository, filename)
		if path.exists(fullpath):
			return fullpath
raise NameError('Unable to find file %s!' % filename)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76a3d2c>}
nname: 39
n 39(None)[]:
	i: 18(), 38()
	o: 

nname: 38
n 38(None)[]:
	i: 0(f)
	o: 39()

nname: 18
n 18(None)[self.load(self._file)
]:
	i: 0(t)
	o: 39()

nname: 0
n 0(self._file)[self._repository = repository
]:
	i: 
	o: 18(t), 38(f)

nname: 0
n 0(None)[self._repository = repository
if self._file:
	self.load(self._file)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb769430c>}
nname: 0
n 0(None)[return self._repository
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb769480c>}
nname: 6
n 6(None)[__doc__ = " This class handles image object.\n\n    It's generic enough to display a lot of types of image such as:\n    jpeg, png, giff...\n\n    It's based on imlib2 library.\n    "
def __init__(self, image_or_file=None, repository=None, size=None, url=None):
	self.name = 'obj'
	self._repository = repository
	self._file = None
	self._url = None
	self._angle = 0
	if url is not None and isinstance(url, basestring):
		self._url = InternalUrl(url)
		image_or_file = self._url.get_file_path()
	arg = {}
	if isinstance(image_or_file, basestring) or image_or_file is None:
		if image_or_file is not None:
			self._file = image_or_file
			try:
				arg['filename'] = self._find_file(image_or_file)
			except NameError, e:
				log.error(str(e))
				self._file = None
		self.obj = WyvasObject(1, **arg)
	else:
		if isinstance(image_or_file, buffer):
			data = image_or_file
			self.obj = WyvasObject(1, **arg)
			self.obj.set_data(data, size, False)
		else:
			raise TypeError('Images can be build from a string or a buffer only !!')
	self.parent = None
	return None

def update(self, signal, sender, value, action=None, callback=None):
	if isinstance(value, basestring) and value[0] != '/' and '://' in value:
		self.load(url=value, callback=callback)
	else:
		self.load(value, callback=callback)

initialize = update
def set_border(self, left, right, top, bottom):
	self.obj.set_border(left, right, top, bottom)

def load(self, file=None, url=None, callback=None):
	if self._url is not None:
		self._url.cleanup()
		self._url = None
	if url is not None and isinstance(url, basestring):
		self._url = InternalUrl(url)
		file = self._url.get_file_path()
	if file != self._file:
		if file is None:
			self._file = ''
		else:
			try:
				self._file = self._find_file(file)
			except NameError:
				log.info("Can't find '%s' !", file)
				self._file = ''
	else:
		if self._angle == 0:
			return None
	self._angle = 0
	self.obj.load(self._file, callback)
	return None

def rotate(self, angle=1):
	angle %= 4
	if angle:
		self.obj.rotate(angle)
		self._angle += angle
		self._angle %= 4

def _find_file(self, filename):
	if path.exists(filename):
		return filename
	else:
		if self._repository:
			fullpath = path.join(self._repository, filename)
			if path.exists(fullpath):
				return fullpath
	raise NameError('Unable to find file %s!' % filename)

def set_repository(self, repository=None):
	self._repository = repository
	if self._file:
		self.load(self._file)

def get_repository(self):
	return self._repository

repository = property(get_repository, set_repository)
]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb769444c>}
nname: 156
n 156(None)[return None
]:
	i: 135(), 155()
	o: 

nname: 155
n 155(None)[]:
	i: 96(f)
	o: 156()

nname: 135
n 135(None)[self.set_color(color=color)
]:
	i: 96(t)
	o: 156()

nname: 96
n 96(color is not None)[self.obj = WyvasObject(2, **arg)
self.parent = None
]:
	i: 81(), 95()
	o: 135(t), 155(f)

nname: 95
n 95(None)[]:
	i: 69(f)
	o: 96()

nname: 81
n 81(None)[arg['font_size'] = size
]:
	i: 69(t)
	o: 96()

nname: 69
n 69(size is not None)[]:
	i: 54(), 68()
	o: 81(t), 95(f)

nname: 68
n 68(None)[]:
	i: 42(f)
	o: 69()

nname: 54
n 54(None)[arg['font'] = font
]:
	i: 42(t)
	o: 69()

nname: 42
n 42(font is not None)[]:
	i: 27(), 41()
	o: 54(t), 68(f)

nname: 41
n 41(None)[]:
	i: 0(f)
	o: 42()

nname: 27
n 27(None)[arg['text'] = text
]:
	i: 0(t)
	o: 42()

nname: 0
n 0(text is not None)[self.name = 'obj'
arg = {}
]:
	i: 
	o: 27(t), 41(f)

nname: 156
n 156(None)[return None
]:
	i: 69()
	o: 

nname: 69
n 69(None)[if size is not None:
	arg['font_size'] = size
self.obj = WyvasObject(2, **arg)
self.parent = None
if color is not None:
	self.set_color(color=color)
]:
	i: 0()
	o: 156()

nname: 0
n 0(None)[self.name = 'obj'
arg = {}
if text is not None:
	arg['text'] = text
if font is not None:
	arg['font'] = font
]:
	i: 
	o: 69()

nname: 156
n 156(None)[return None
]:
	i: 0()
	o: 

nname: 0
n 0(None)[self.name = 'obj'
arg = {}
if text is not None:
	arg['text'] = text
if font is not None:
	arg['font'] = font
if size is not None:
	arg['font_size'] = size
self.obj = WyvasObject(2, **arg)
self.parent = None
if color is not None:
	self.set_color(color=color)
]:
	i: 
	o: 156()

nname: 0
n 0(None)[self.name = 'obj'
arg = {}
if text is not None:
	arg['text'] = text
if font is not None:
	arg['font'] = font
if size is not None:
	arg['font_size'] = size
self.obj = WyvasObject(2, **arg)
self.parent = None
if color is not None:
	self.set_color(color=color)
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76a3dcc>}
nname: 0
n 0(None)[self.set_text(value)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76a346c>}
nname: 60
n 60(None)[self.obj.set_font(**arg)
return None
]:
	i: 45(), 59()
	o: 

nname: 59
n 59(None)[]:
	i: 33(f)
	o: 60()

nname: 45
n 45(None)[arg['font_size'] = size
]:
	i: 33(t)
	o: 60()

nname: 33
n 33(size is not None)[]:
	i: 18(), 32()
	o: 45(t), 59(f)

nname: 32
n 32(None)[]:
	i: 0(f)
	o: 33()

nname: 18
n 18(None)[arg['font'] = font
]:
	i: 0(t)
	o: 33()

nname: 0
n 0(font is not None)[arg = {}
]:
	i: 
	o: 18(t), 32(f)

nname: 60
n 60(None)[self.obj.set_font(**arg)
return None
]:
	i: 0()
	o: 

nname: 0
n 0(None)[arg = {}
if font is not None:
	arg['font'] = font
if size is not None:
	arg['font_size'] = size
]:
	i: 
	o: 60()

nname: 0
n 0(None)[arg = {}
if font is not None:
	arg['font'] = font
if size is not None:
	arg['font_size'] = size
self.obj.set_font(**arg)
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76a378c>}
nname: 46
n 46(None)[return None
]:
	i: 28(), 45()
	o: 

nname: 45
n 45(None)[]:
	i: 0(f)
	o: 46()

nname: 28
n 28(None)[self.set_color(*color)
]:
	i: 0(t)
	o: 46()

nname: 0
n 0(color is not None)[self.obj.set_text(text)
]:
	i: 
	o: 28(t), 45(f)

nname: 0
n 0(None)[self.obj.set_text(text)
if color is not None:
	self.set_color(*color)
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76a30cc>}
nname: 6
n 6(None)[__doc__ = " A class to create text.\n\n    It's based on Evas Text object.\n    "
def __init__(self, text='', font='Vera', size=20, color=None):
	self.name = 'obj'
	arg = {}
	if text is not None:
		arg['text'] = text
	if font is not None:
		arg['font'] = font
	if size is not None:
		arg['font_size'] = size
	self.obj = WyvasObject(2, **arg)
	self.parent = None
	if color is not None:
		self.set_color(color=color)
	return None

def update(self, signal, sender, value, action=None):
	self.set_text(value)

initialize = update
def set_font(self, font=None, size=None):
	arg = {}
	if font is not None:
		arg['font'] = font
	if size is not None:
		arg['font_size'] = size
	self.obj.set_font(**arg)
	return None

def set_text(self, text, color=None):
	self.obj.set_text(text)
	if color is not None:
		self.set_color(*color)
	return None

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb7694f4c>}
nname: 122
n 122(None)[arg['textblock'] = 1
self.obj = WyvasObject(7, **arg)
self.parent = None
return None
]:
	i: 107(), 121()
	o: 

nname: 121
n 121(None)[]:
	i: 95(f)
	o: 122()

nname: 107
n 107(None)[arg['font_size'] = size
]:
	i: 95(t)
	o: 122()

nname: 95
n 95(size is not None)[]:
	i: 80(), 94()
	o: 107(t), 121(f)

nname: 94
n 94(None)[]:
	i: 68(f)
	o: 95()

nname: 80
n 80(None)[arg['font'] = font
]:
	i: 68(t)
	o: 95()

nname: 68
n 68(font is not None)[]:
	i: 57(), 67()
	o: 80(t), 94(f)

nname: 67
n 67(None)[]:
	i: 0(f)
	o: 68()

nname: 57
n 57(None)[arg['text'] = text
]:
	i: 34(), 53()
	o: 68()

nname: 53
n 53(None)[]:
	i: 27(f)
	o: 57()

nname: 34
n 34(None)[]:
	i: 27(t)
	o: 57()

nname: 27
n 27(replace_and_sign)[]:
	i: 0(t)
	o: 34(t), 53(f)

nname: 0
n 0(text is not None)[self.name = 'obj'
arg = {}
]:
	i: 
	o: 27(t), 67(f)

nname: 122
n 122(None)[arg['textblock'] = 1
self.obj = WyvasObject(7, **arg)
self.parent = None
return None
]:
	i: 68()
	o: 

nname: 68
n 68(None)[if font is not None:
	arg['font'] = font
if size is not None:
	arg['font_size'] = size
]:
	i: 27(), 0(f)
	o: 122()

nname: 27
n 27(None)[if replace_and_sign:
	pass
arg['text'] = text
]:
	i: 0(t)
	o: 68()

nname: 0
n 0(text is not None)[self.name = 'obj'
arg = {}
]:
	i: 
	o: 27(t), 68(f)

nname: 122
n 122(None)[arg['textblock'] = 1
self.obj = WyvasObject(7, **arg)
self.parent = None
return None
]:
	i: 0()
	o: 

nname: 0
n 0(None)[self.name = 'obj'
arg = {}
if text is not None:
	if replace_and_sign:
		pass
	arg['text'] = text
if font is not None:
	arg['font'] = font
if size is not None:
	arg['font_size'] = size
]:
	i: 
	o: 122()

nname: 0
n 0(None)[self.name = 'obj'
arg = {}
if text is not None:
	if replace_and_sign:
		pass
	arg['text'] = text
if font is not None:
	arg['font'] = font
if size is not None:
	arg['font_size'] = size
arg['textblock'] = 1
self.obj = WyvasObject(7, **arg)
self.parent = None
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76a3dec>}
nname: 0
n 0(None)[return self.obj.get_text_geometry()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76a308c>}
nname: 6
n 6(None)[__doc__ = " A class to create text block object.\n\n    It's based on Evas Text Block object.\n    "
def __init__(self, text='', font='Vera', size=20, color=None, replace_and_sign=True):
	self.name = 'obj'
	arg = {}
	if text is not None:
		if replace_and_sign:
			pass
		arg['text'] = text
	if font is not None:
		arg['font'] = font
	if size is not None:
		arg['font_size'] = size
	arg['textblock'] = 1
	self.obj = WyvasObject(7, **arg)
	self.parent = None
	return None

def get_text_geometry(self):
	return self.obj.get_text_geometry()

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb770dfcc>}
nname: 0
n 0(None)[self.name = 'obj'
self._children = []
self.obj = WyvasObject(3)
self.parent = None
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76a31ec>}
nname: 184
n 184(None)[print '--------------------------'
print '-------END CONTAINER------'
print '--------------------------'
]:
	i: 0(AL), 183()
	o: 

nname: 183
n 183(None)[]:
	i: 157(AF), 167()
	o: 184()

nname: 167
n 167(None)[for child in self._children:
child._print_attributes()
]:
	i: 157(for)
	o: 183()

nname: 157
n 157(None)[]:
	i: 0(loop)
	o: 167(for), 183(AF)

nname: 0
n 0(None)[print '--------------------------'
print '-------CONTAINER----------'
print '--------------------------'
print 'OBJ CANVAS :',
print self
print 'parent     :',
print self.parent
print '------properties----------'
print 'visible    :',
print self.get_visible()
print 'pos        :',
print self.get_pos()
print 'size       :',
print self.get_size()
print 'layer      :',
print self.get_layer()
print 'color      :',
print self.get_color()
print '------internal------------'
self.obj.debug()
print '--------------------------'
print '--------------------------'
print '--------CHILD-------------'
print '--------------------------'
]:
	i: 
	o: 157(loop), 184(AL)

nname: 184
n 184(None)[print '--------------------------'
print '-------END CONTAINER------'
print '--------------------------'
]:
	i: 167()
	o: 

nname: 167
n 167(None)[for child in self._children:
	child._print_attributes()
]:
	i: 0(for)
	o: 184()

nname: 0
n 0(None)[print '--------------------------'
print '-------CONTAINER----------'
print '--------------------------'
print 'OBJ CANVAS :',
print self
print 'parent     :',
print self.parent
print '------properties----------'
print 'visible    :',
print self.get_visible()
print 'pos        :',
print self.get_pos()
print 'size       :',
print self.get_size()
print 'layer      :',
print self.get_layer()
print 'color      :',
print self.get_color()
print '------internal------------'
self.obj.debug()
print '--------------------------'
print '--------------------------'
print '--------CHILD-------------'
print '--------------------------'
]:
	i: 
	o: 167(for)

nname: 184
n 184(None)[print '--------------------------'
print '-------END CONTAINER------'
print '--------------------------'
]:
	i: 0()
	o: 

nname: 0
n 0(None)[print '--------------------------'
print '-------CONTAINER----------'
print '--------------------------'
print 'OBJ CANVAS :',
print self
print 'parent     :',
print self.parent
print '------properties----------'
print 'visible    :',
print self.get_visible()
print 'pos        :',
print self.get_pos()
print 'size       :',
print self.get_size()
print 'layer      :',
print self.get_layer()
print 'color      :',
print self.get_color()
print '------internal------------'
self.obj.debug()
print '--------------------------'
print '--------------------------'
print '--------CHILD-------------'
print '--------------------------'
for child in self._children:
	child._print_attributes()
]:
	i: 
	o: 184()

nname: 0
n 0(None)[print '--------------------------'
print '-------CONTAINER----------'
print '--------------------------'
print 'OBJ CANVAS :',
print self
print 'parent     :',
print self.parent
print '------properties----------'
print 'visible    :',
print self.get_visible()
print 'pos        :',
print self.get_pos()
print 'size       :',
print self.get_size()
print 'layer      :',
print self.get_layer()
print 'color      :',
print self.get_color()
print '------internal------------'
self.obj.debug()
print '--------------------------'
print '--------------------------'
print '--------CHILD-------------'
print '--------------------------'
for child in self._children:
	child._print_attributes()
print '--------------------------'
print '-------END CONTAINER------'
print '--------------------------'
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76945ec>}
nname: 269
n 269(None)[self.obj.add_child(child.obj, **kwargs)
return child
]:
	i: 255(), 268()
	o: 

nname: 268
n 268(None)[]:
	i: 231(f)
	o: 269()

nname: 255
n 255(None)[child.name = name
]:
	i: 231(t)
	o: 269()

nname: 231
n 231(name is not None)[name = kwargs_get('name')
]:
	i: 204(), 230()
	o: 255(t), 268(f)

nname: 230
n 230(None)[]:
	i: 180(f)
	o: 231()

nname: 204
n 204(None)[kwargs['aspect'] = int(aspect == 'preserve')
]:
	i: 180(t)
	o: 231()

nname: 180
n 180(aspect is not None)[aspect = kwargs_get('aspect')
]:
	i: 156(), 179()
	o: 204(t), 230(f)

nname: 179
n 179(None)[]:
	i: 132(f)
	o: 180()

nname: 156
n 156(None)[kwargs['color'] = Object._arg_color(*color)
]:
	i: 132(t)
	o: 180()

nname: 132
n 132(color is not None)[color = kwargs_get('color')
]:
	i: 24(AL), 131()
	o: 156(t), 179(f)

nname: 131
n 131(None)[]:
	i: 70(AF), 127()
	o: 132()

nname: 127
n 127(None)[]:
	i: 80(f), 107()
	o: 131()

nname: 107
n 107(None)[kwargs[attr] = arg_str_per(val)
continue
]:
	i: 80(t)
	o: 127()

nname: 80
n 80(val is not None)[for attr in Object.percentage_arg_tuple:
val = kwargs_get(attr)
]:
	i: 70(for)
	o: 107(t), 127(f)

nname: 70
n 70(None)[]:
	i: 24(loop)
	o: 80(for), 131(AF)

nname: 24
n 24(None)[self._children.append(child)
child.parent = self
arg_str_per = Object._arg_str_per
kwargs_get = kwargs.get
]:
	i: 15(), 23()
	o: 70(loop), 132(AL)

nname: 23
n 23(None)[]:
	i: 0(f)
	o: 24()

nname: 15
n 15(None)[return None
]:
	i: 0(t)
	o: 24()

nname: 0
n 0(child in self._children)[]:
	i: 
	o: 15(t), 23(f)

nname: 231
n 231(None)[name = kwargs_get('name')
if name is not None:
	child.name = name
self.obj.add_child(child.obj, **kwargs)
return child
]:
	i: 132()
	o: 

nname: 132
n 132(None)[color = kwargs_get('color')
if color is not None:
	kwargs['color'] = Object._arg_color(*color)
aspect = kwargs_get('aspect')
if aspect is not None:
	kwargs['aspect'] = int(aspect == 'preserve')
]:
	i: 0(AL), 70(AF), 80()
	o: 231()

nname: 80
n 80(None)[for attr in Object.percentage_arg_tuple:
val = kwargs_get(attr)
if val is not None:
	kwargs[attr] = arg_str_per(val)
	continue
]:
	i: 70(for)
	o: 132()

nname: 70
n 70(None)[]:
	i: 0(loop)
	o: 80(for), 132(AF)

nname: 0
n 0(None)[if child in self._children:
	return None
self._children.append(child)
child.parent = self
arg_str_per = Object._arg_str_per
kwargs_get = kwargs.get
]:
	i: 
	o: 70(loop), 132(AL)

nname: 132
n 132(None)[color = kwargs_get('color')
if color is not None:
	kwargs['color'] = Object._arg_color(*color)
aspect = kwargs_get('aspect')
if aspect is not None:
	kwargs['aspect'] = int(aspect == 'preserve')
name = kwargs_get('name')
if name is not None:
	child.name = name
self.obj.add_child(child.obj, **kwargs)
return child
]:
	i: 0(AL), 70(AF), 80()
	o: 

nname: 80
n 80(None)[for attr in Object.percentage_arg_tuple:
val = kwargs_get(attr)
if val is not None:
	kwargs[attr] = arg_str_per(val)
	continue
]:
	i: 70(for)
	o: 132()

nname: 70
n 70(None)[]:
	i: 0(loop)
	o: 80(for), 132(AF)

nname: 0
n 0(None)[if child in self._children:
	return None
self._children.append(child)
child.parent = self
arg_str_per = Object._arg_str_per
kwargs_get = kwargs.get
]:
	i: 
	o: 70(loop), 132(AL)

self.nodes: {0: <unpyclib.structure.node instance at 0xb770674c>, 132: <unpyclib.structure.node instance at 0xb770688c>, 70: <unpyclib.structure.node instance at 0xb76946cc>, 80: <unpyclib.structure.node instance at 0xb770604c>}
nname: 29
n 29(None)[self.obj.remove_child(child.obj)
self._children.remove(child)
child.parent = None
return None
]:
	i: 15(), 28()
	o: 

nname: 28
n 28(None)[]:
	i: 0(f)
	o: 29()

nname: 15
n 15(None)[raise ValueError, 'Child not found'
]:
	i: 0(t)
	o: 29()

nname: 0
n 0(child not in self._children)[]:
	i: 
	o: 15(t), 28(f)

nname: 0
n 0(None)[if child not in self._children:
	raise ValueError, 'Child not found'
self.obj.remove_child(child.obj)
self._children.remove(child)
child.parent = None
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76a3a2c>}
nname: 0
n 0(None)[self.obj.wipe()
self._children = []
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76a33ac>}
nname: 103
n 103(None)[return None
]:
	i: 0(AL), 102()
	o: 

nname: 102
n 102(None)[]:
	i: 3(AF), 99()
	o: 103()

nname: 99
n 99(None)[]:
	i: 86(JA), 98()
	o: 102()

nname: 98
n 98(None)[]:
	i: 42(f), 94()
	o: 99()

nname: 94
n 94(None)[continue
]:
	i: 58(f)
	o: 98()

nname: 86
n 86(None)[return result
]:
	i: 58(t)
	o: 99(JA)

nname: 58
n 58(result is not None)[result = child.get_obj_by_name(name)
]:
	i: 42(t)
	o: 86(t), 94(f)

nname: 42
n 42(isinstance(child, Container))[]:
	i: 13(f), 34()
	o: 58(t), 98(f)

nname: 34
n 34(None)[return child
continue
]:
	i: 13(t)
	o: 42()

nname: 13
n 13(child.get_name() == name)[for child in self._children:
]:
	i: 3(for)
	o: 34(t), 42(f)

nname: 3
n 3(None)[]:
	i: 0(loop)
	o: 13(for), 102(AF)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 103(AL)

nname: 103
n 103(None)[return None
]:
	i: 0(AL), 3(AF), 86(JA), 13(f), 94()
	o: 

nname: 94
n 94(None)[continue
]:
	i: 58(f)
	o: 103()

nname: 86
n 86(None)[return result
]:
	i: 58(t)
	o: 103(JA)

nname: 58
n 58(result is not None)[result = child.get_obj_by_name(name)
]:
	i: 13(t)
	o: 86(t), 94(f)

nname: 13
n 13(isinstance(child, Container))[for child in self._children:
if child.get_name() == name:
	return child
	continue
]:
	i: 3(for)
	o: 58(t), 103(f)

nname: 3
n 3(None)[]:
	i: 0(loop)
	o: 13(for), 103(AF)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 103(AL)

nname: 13
n 13(None)[for child in self._children:
	if child.get_name() == name:
		return child
		continue
	if isinstance(child, Container):
		result = child.get_obj_by_name(name)
		if result is not None:
			return result
		else:
			continue
return None
]:
	i: 0(for)
	o: 

nname: 0
n 0(None)[]:
	i: 
	o: 13(for)

nname: 0
n 0(None)[for child in self._children:
	if child.get_name() == name:
		return child
		continue
	if isinstance(child, Container):
		result = child.get_obj_by_name(name)
		if result is not None:
			return result
		else:
			continue
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7706ccc>}
nname: 111
n 111(None)[return result
]:
	i: 0(AL), 110()
	o: 

nname: 110
n 110(None)[]:
	i: 9(AF), 106()
	o: 111()

nname: 106
n 106(None)[]:
	i: 64(f), 80()
	o: 110()

nname: 80
n 80(None)[result.extend(child.get_list_obj_by_name(name))
continue
]:
	i: 64(t)
	o: 106()

nname: 64
n 64(isinstance(child, Container))[]:
	i: 19&28(f), 47()
	o: 80(t), 106(f)

nname: 47
n 47(None)[result.append(child)
continue
]:
	i: 19&28(t)
	o: 64()

nname: 19&28
n 19&28(child and child.get_name() == name)[for child in self._children:
]:
	i: 9(for)
	o: 47(t), 64(f)

nname: 9
n 9(None)[]:
	i: 0(loop)
	o: 19&28(for), 110(AF)

nname: 0
n 0(None)[result = []
]:
	i: 
	o: 9(loop), 111(AL)

nname: 111
n 111(None)[return result
]:
	i: 0(AL), 9(AF), 19&28()
	o: 

nname: 19&28
n 19&28(None)[for child in self._children:
if child and child.get_name() == name:
	result.append(child)
	continue
if isinstance(child, Container):
	result.extend(child.get_list_obj_by_name(name))
	continue
]:
	i: 9(for)
	o: 111()

nname: 9
n 9(None)[]:
	i: 0(loop)
	o: 19&28(for), 111(AF)

nname: 0
n 0(None)[result = []
]:
	i: 
	o: 9(loop), 111(AL)

nname: 19&28
n 19&28(None)[for child in self._children:
	if child and child.get_name() == name:
		result.append(child)
		continue
	if isinstance(child, Container):
		result.extend(child.get_list_obj_by_name(name))
		continue
return result
]:
	i: 0(for)
	o: 

nname: 0
n 0(None)[result = []
]:
	i: 
	o: 19&28(for)

nname: 0
n 0(None)[result = []
for child in self._children:
	if child and child.get_name() == name:
		result.append(child)
		continue
	if isinstance(child, Container):
		result.extend(child.get_list_obj_by_name(name))
		continue
return result
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb77060cc>}
nname: 61
n 61(None)[return None
]:
	i: 27(), 47()
	o: 

nname: 47
n 47(None)[self.resize(*size)
]:
	i: 0(f)
	o: 61()

nname: 27
n 27(None)[self.obj.resize_size(size)
]:
	i: 0(t)
	o: 61()

nname: 0
n 0(self.parent is not None)[size = (width, height)
]:
	i: 
	o: 27(t), 47(f)

nname: 0
n 0(None)[size = (width, height)
if self.parent is not None:
	self.obj.resize_size(size)
else:
	self.resize(*size)
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb77066cc>}
nname: 6
n 6(None)[__doc__ = ' A class used to manage others Wyvas objects.\n\n    All objects attached to the container are subject to modification\n    is the container itself is moved for example.\n    '
def __init__(self):
	self.name = 'obj'
	self._children = []
	self.obj = WyvasObject(3)
	self.parent = None
	return None

def _print_attributes(self):
	print '--------------------------'
	print '-------CONTAINER----------'
	print '--------------------------'
	print 'OBJ CANVAS :',
	print self
	print 'parent     :',
	print self.parent
	print '------properties----------'
	print 'visible    :',
	print self.get_visible()
	print 'pos        :',
	print self.get_pos()
	print 'size       :',
	print self.get_size()
	print 'layer      :',
	print self.get_layer()
	print 'color      :',
	print self.get_color()
	print '------internal------------'
	self.obj.debug()
	print '--------------------------'
	print '--------------------------'
	print '--------CHILD-------------'
	print '--------------------------'
	for child in self._children:
		child._print_attributes()
	print '--------------------------'
	print '-------END CONTAINER------'
	print '--------------------------'

def add_child(self, child, **kwargs):
	if child in self._children:
		return None
	self._children.append(child)
	child.parent = self
	arg_str_per = Object._arg_str_per
	kwargs_get = kwargs.get

def remove_child(self, child):
	if child not in self._children:
		raise ValueError, 'Child not found'
	self.obj.remove_child(child.obj)
	self._children.remove(child)
	child.parent = None
	return None

def wipe(self):
	self.obj.wipe()
	self._children = []

def get_obj_by_name(self, name):
	for child in self._children:
		if child.get_name() == name:
			return child
			continue
		if isinstance(child, Container):
			result = child.get_obj_by_name(name)
			if result is not None:
				return result
			else:
				continue
	return None

def get_list_obj_by_name(self, name):
	result = []
	for child in self._children:
		if child and child.get_name() == name:
			result.append(child)
			continue
		if isinstance(child, Container):
			result.extend(child.get_list_obj_by_name(name))
			continue
	return result

def set_size(self, width=None, height=None):
	size = (width, height)
	if self.parent is not None:
		self.obj.resize_size(size)
	else:
		self.resize(*size)
	return None

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb76a3d0c>}
nname: 144
n 144(None)[return None
]:
	i: 117(), 143()
	o: 

nname: 143
n 143(None)[]:
	i: 0(f)
	o: 144()

nname: 117
n 117(None)[self._init_event(self._event_callback, queue_size, key_repeat)
]:
	i: 0(t)
	o: 144()

nname: 0
n 0(event == 1)[self.name = 'obj'
self._children = []
self.obj = WyvasObject(5, size=size, type=type, font_path=font_path, fb_dev=fb_dev, fps=fps)
self._current_resolution = (size, type)
self.parent = None
self._callback = None
self._event_compat = 0
]:
	i: 
	o: 117(t), 143(f)

nname: 0
n 0(None)[self.name = 'obj'
self._children = []
self.obj = WyvasObject(5, size=size, type=type, font_path=font_path, fb_dev=fb_dev, fps=fps)
self._current_resolution = (size, type)
self.parent = None
self._callback = None
self._event_compat = 0
if event == 1:
	self._init_event(self._event_callback, queue_size, key_repeat)
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76a3e0c>}
nname: 0
n 0(None)[self.obj.set_resolution(size=size, interlaced=interlaced, frequency=frequency)
self._current_resolution = (size, interlaced)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7706d6c>}
nname: 0
n 0(None)[return self._current_resolution
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7706f8c>}
nname: 0
n 0(None)[arg = {}
arg['callback'] = callback
arg['queue_size'] = queue_size
arg['key_repeat'] = key_repeat
self.obj.init_event(**arg)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7706b0c>}
nname: 87
n 87(None)[return None
]:
	i: 43(JA), 63(), 86()
	o: 

nname: 86
n 86(None)[]:
	i: 0(f)
	o: 87()

nname: 63
n 63(None)[self._callback(key, press, time)
]:
	i: 15(f)
	o: 87()

nname: 43
n 43(None)[self._callback(key, press)
]:
	i: 15(t)
	o: 87(JA)

nname: 15
n 15(self._event_compat == 1)[press = bool(press)
]:
	i: 0(t)
	o: 43(t), 63(f)

nname: 0
n 0(self._callback != None)[]:
	i: 
	o: 15(t), 86(f)

nname: 0
n 0(None)[if self._callback != None:
	press = bool(press)
	if self._event_compat == 1:
		self._callback(key, press)
	else:
		self._callback(key, press, time)
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76a316c>}
nname: 0
n 0(None)[self._callback = callback
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7706aec>}
nname: 0
n 0(None)[print 'UNSUPPORTED NOW'
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7706fcc>}
nname: 0
n 0(None)[print 'UNSUPPORTED NOW'
print '->activate fallback'
self._event_compat = 1
self._callback = callback
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb770632c>}
nname: 6
n 6(None)[__doc__ = ' A class which represents the screen.\n\n    You should create one instance of this object.\n    '
def __init__(self, size, type=1, event=0, font_path='/usr/share/fonts', fb_dev=0, queue_size=5, key_repeat=2, fps=60):
	self.name = 'obj'
	self._children = []
	self.obj = WyvasObject(5, size=size, type=type, font_path=font_path, fb_dev=fb_dev, fps=fps)
	self._current_resolution = (size, type)
	self.parent = None
	self._callback = None
	self._event_compat = 0
	if event == 1:
		self._init_event(self._event_callback, queue_size, key_repeat)
	return None

def set_resolution(self, size, interlaced=0, frequency=60):
	self.obj.set_resolution(size=size, interlaced=interlaced, frequency=frequency)
	self._current_resolution = (size, interlaced)

def get_resolution(self):
	return self._current_resolution

def _init_event(self, callback, queue_size, key_repeat):
	arg = {}
	arg['callback'] = callback
	arg['queue_size'] = queue_size
	arg['key_repeat'] = key_repeat
	self.obj.init_event(**arg)

def _event_callback(self, key, press, time):
	if self._callback != None:
		press = bool(press)
		if self._event_compat == 1:
			self._callback(key, press)
		else:
			self._callback(key, press, time)
	return None

def register_event(self, callback):
	self._callback = callback

def register_event_keyboard(self, callback):
	print 'UNSUPPORTED NOW'

def register_event_remote(self, callback):
	print 'UNSUPPORTED NOW'
	print '->activate fallback'
	self._event_compat = 1
	self._callback = callback

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb7706d8c>}
nname: 113
n 113(None)[self.parent = None
return None
]:
	i: 30(), 73()
	o: 

nname: 73
n 73(None)[self.obj = WyvasObject(5, size=size, type=1, font_path=font_path, fb_dev=fb_dev)
]:
	i: 0(f)
	o: 113()

nname: 30
n 30(None)[self.obj = WyvasObject(5, size=size, type=0, font_path=font_path, fb_dev=fb_dev)
]:
	i: 0(t)
	o: 113()

nname: 0
n 0(use_framebuffer == True)[self.name = 'obj'
self._children = []
]:
	i: 
	o: 30(t), 73(f)

nname: 0
n 0(None)[self.name = 'obj'
self._children = []
if use_framebuffer == True:
	self.obj = WyvasObject(5, size=size, type=0, font_path=font_path, fb_dev=fb_dev)
else:
	self.obj = WyvasObject(5, size=size, type=1, font_path=font_path, fb_dev=fb_dev)
self.parent = None
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb770648c>}
nname: 6
n 6(None)[def __init__(self, size=(160, 128), font_path='/usr/share/fonts', fb_dev=1, use_framebuffer=True):
	self.name = 'obj'
	self._children = []
	if use_framebuffer == True:
		self.obj = WyvasObject(5, size=size, type=0, font_path=font_path, fb_dev=fb_dev)
	else:
		self.obj = WyvasObject(5, size=size, type=1, font_path=font_path, fb_dev=fb_dev)
	self.parent = None
	return None

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb770df2c>}
nname: 108
n 108(None)[self.obj = WyvasObject(6, **arg)
self.parent = None
return None
]:
	i: 84(), 107()
	o: 

nname: 107
n 107(None)[]:
	i: 72(f)
	o: 108()

nname: 84
n 84(None)[arg['color'] = Object._arg_color(*color)
]:
	i: 72(t)
	o: 108()

nname: 72
n 72(color is not None)[]:
	i: 27(), 71()
	o: 84(t), 107(f)

nname: 71
n 71(None)[]:
	i: 0(f)
	o: 72()

nname: 27
n 27(None)[arg['width'] = (size[0], 0)
arg['height'] = (size[1], 0)
]:
	i: 0(t)
	o: 72()

nname: 0
n 0(size is not None)[self.name = 'obj'
arg = {}
]:
	i: 
	o: 27(t), 71(f)

nname: 108
n 108(None)[self.obj = WyvasObject(6, **arg)
self.parent = None
return None
]:
	i: 0()
	o: 

nname: 0
n 0(None)[self.name = 'obj'
arg = {}
if size is not None:
	arg['width'] = (size[0], 0)
	arg['height'] = (size[1], 0)
if color is not None:
	arg['color'] = Object._arg_color(*color)
]:
	i: 
	o: 108()

nname: 0
n 0(None)[self.name = 'obj'
arg = {}
if size is not None:
	arg['width'] = (size[0], 0)
	arg['height'] = (size[1], 0)
if color is not None:
	arg['color'] = Object._arg_color(*color)
self.obj = WyvasObject(6, **arg)
self.parent = None
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb770636c>}
nname: 6
n 6(None)[__doc__ = " A class to create rectangle object.\n\n    It's based Evas Rectangle Object.\n    "
def __init__(self, size=None, color=None):
	self.name = 'obj'
	arg = {}
	if size is not None:
		arg['width'] = (size[0], 0)
		arg['height'] = (size[1], 0)
	if color is not None:
		arg['color'] = Object._arg_color(*color)
	self.obj = WyvasObject(6, **arg)
	self.parent = None
	return None

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb770dfac>}
nname: 251
n 251(None)[return None
]:
	i: 197(), 238()
	o: 

nname: 238
n 238(None)[raise TypeError('Images can be build from a string only !!')
]:
	i: 117&138(f)
	o: 251()

nname: 197
n 197(None)[arg['output_size'] = output_size
arg['use_hardware'] = use_hardware
self.obj = WyvasObject(8, **arg)
]:
	i: 164(), 196()
	o: 251()

nname: 196
n 196(None)[]:
	i: 151(f)
	o: 197()

nname: 164
n 164(None)[self._file = image_or_file
arg['filename'] = self._find_file(image_or_file)
]:
	i: 151(t)
	o: 197()

nname: 151
n 151(image_or_file is not None)[]:
	i: 117&138(t)
	o: 164(t), 196(f)

nname: 117&138
n 117&138(isinstance(image_or_file, basestring) or image_or_file is None)[arg = {}
]:
	i: 82(), 116()
	o: 151(t), 238(f)

nname: 116
n 116(None)[]:
	i: 0&66(f)
	o: 117&138()

nname: 82
n 82(None)[self._url = InternalUrl(url)
image_or_file = self._url.get_file_path()
]:
	i: 0&66(t)
	o: 117&138()

nname: 0&66
n 0&66(url is not None and isinstance(url, basestring))[self.name = 'obj'
self.parent = None
self._repository = repository
self._file = None
self._url = None
self._angle = 0
]:
	i: 
	o: 82(t), 116(f)

nname: 251
n 251(None)[return None
]:
	i: 151(), 238()
	o: 

nname: 238
n 238(None)[raise TypeError('Images can be build from a string only !!')
]:
	i: 0&66(f)
	o: 251()

nname: 151
n 151(None)[if image_or_file is not None:
	self._file = image_or_file
	arg['filename'] = self._find_file(image_or_file)
arg['output_size'] = output_size
arg['use_hardware'] = use_hardware
self.obj = WyvasObject(8, **arg)
]:
	i: 0&66(t)
	o: 251()

nname: 0&66
n 0&66(isinstance(image_or_file, basestring) or image_or_file is None)[self.name = 'obj'
self.parent = None
self._repository = repository
self._file = None
self._url = None
self._angle = 0
if url is not None and isinstance(url, basestring):
	self._url = InternalUrl(url)
	image_or_file = self._url.get_file_path()
arg = {}
]:
	i: 
	o: 151(t), 238(f)

nname: 0&66
n 0&66(None)[self.name = 'obj'
self.parent = None
self._repository = repository
self._file = None
self._url = None
self._angle = 0
if url is not None and isinstance(url, basestring):
	self._url = InternalUrl(url)
	image_or_file = self._url.get_file_path()
arg = {}
if isinstance(image_or_file, basestring) or image_or_file is None:
	if image_or_file is not None:
		self._file = image_or_file
		arg['filename'] = self._find_file(image_or_file)
	arg['output_size'] = output_size
	arg['use_hardware'] = use_hardware
	self.obj = WyvasObject(8, **arg)
else:
	raise TypeError('Images can be build from a string only !!')
return None
]:
	i: 
	o: 

self.nodes: {'0&66': <unpyclib.structure.node instance at 0xb76a34cc>}
nname: 0
n 0(None)[self.obj.set_output_size(output_size)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb770642c>}
nname: 6
n 6(None)[__doc__ = " This class as L{Image} display image.\n\n    But unlike L{Image}, it's faster to display jpeg image because it\n    uses the libjpeg in that case. Otherwise it uses the same method\n    as L{Image}.\n\n    It can also load all type of image asynchronously.\n    "
def __init__(self, image_or_file=None, repository=None, output_size=(1280, 720), use_hardware=0, url=None):
	self.name = 'obj'
	self.parent = None
	self._repository = repository
	self._file = None
	self._url = None
	self._angle = 0
	if url is not None and isinstance(url, basestring):
		self._url = InternalUrl(url)
		image_or_file = self._url.get_file_path()
	arg = {}
	if isinstance(image_or_file, basestring) or image_or_file is None:
		if image_or_file is not None:
			self._file = image_or_file
			arg['filename'] = self._find_file(image_or_file)
		arg['output_size'] = output_size
		arg['use_hardware'] = use_hardware
		self.obj = WyvasObject(8, **arg)
	else:
		raise TypeError('Images can be build from a string only !!')
	return None

def set_output_size(self, output_size=(1280, 720)):
	self.obj.set_output_size(output_size)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb770df6c>}
nname: 0
n 0(None)[self.name = 'obj'
self.parent = None
self.obj = WyvasObject(9, wydget_name=wydget_name, size=size)
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7706bec>}
nname: 0
n 0(None)[self.obj.send_data(motif, *data)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7706bec>}
nname: 0
n 0(None)[print 'Not Yet implemented'
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7706bec>}
nname: 6
n 6(None)[def __init__(self, wydget_name=None, size=(1280, 720)):
	self.name = 'obj'
	self.parent = None
	self.obj = WyvasObject(9, wydget_name=wydget_name, size=size)
	return None

def send_data(self, motif, *data):
	self.obj.send_data(motif, *data)

def update(self, signal, sender, value, action=None):
	print 'Not Yet implemented'

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb770df2c>}
nname: 29
n 29(None)[self.name = 'obj'
self.parent = None
self.obj = WyvasObject(9, wydget_name='animage', size=size)
return None
]:
	i: 12(), 28()
	o: 

nname: 28
n 28(None)[]:
	i: 0(f)
	o: 29()

nname: 12
n 12(None)[raise ValueError('Browser accept only valid url !')
]:
	i: 0(t)
	o: 29()

nname: 0
n 0(size is None)[]:
	i: 
	o: 12(t), 28(f)

nname: 0
n 0(None)[if size is None:
	raise ValueError('Browser accept only valid url !')
self.name = 'obj'
self.parent = None
self.obj = WyvasObject(9, wydget_name='animage', size=size)
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb770672c>}
nname: 0
n 0(None)[sleep = value['sleep']
filename = value['filename']
self.send_data('si', filename, sleep)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb77062cc>}
nname: 6
n 6(None)[def __init__(self, size=None):
	if size is None:
		raise ValueError('Browser accept only valid url !')
	self.name = 'obj'
	self.parent = None
	self.obj = WyvasObject(9, wydget_name='animage', size=size)
	return None

def update(self, signal, sender, value, action=None):
	sleep = value['sleep']
	filename = value['filename']
	self.send_data('si', filename, sleep)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb770df2c>}
nname: 0
n 0(None)[self.name = 'obj'
self.parent = None
self.obj = WyvasObject(9, wydget_name='pleyo', size=size)
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb770698c>}
nname: 61
n 61(None)[]:
	i: 28(), 48()
	o: 

nname: 48
n 48(None)[raise TypeError('Browser accept only valid url !')
]:
	i: 0&15(f)
	o: 61()

nname: 28
n 28(None)[self.send_data('s', value)
]:
	i: 0&15(t)
	o: 61()

nname: 0&15
n 0&15(isinstance(value, basestring) and '://' in value)[]:
	i: 
	o: 28(t), 48(f)

nname: 0&15
n 0&15(None)[if isinstance(value, basestring) and '://' in value:
	self.send_data('s', value)
else:
	raise TypeError('Browser accept only valid url !')
]:
	i: 
	o: 

self.nodes: {'0&15': <unpyclib.structure.node instance at 0xb770612c>}
nname: 6
n 6(None)[def __init__(self, size=(1280, 720)):
	self.name = 'obj'
	self.parent = None
	self.obj = WyvasObject(9, wydget_name='pleyo', size=size)
	return None

def update(self, signal, sender, value, action=None):
	if isinstance(value, basestring) and '://' in value:
		self.send_data('s', value)
	else:
		raise TypeError('Browser accept only valid url !')

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb770df6c>}
nname: 0
n 0(None)[self.name = 'obj'
self.parent = None
self.obj = WyvasObject(9, wydget_name='webcam', size=size)
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb770674c>}
nname: 6
n 6(None)[def __init__(self, size=(0, 0)):
	self.name = 'obj'
	self.parent = None
	self.obj = WyvasObject(9, wydget_name='webcam', size=size)
	return None

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb770de6c>}
nname: 0
n 0(None)[lock()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb77064cc>}
nname: 0
n 0(None)[unlock()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb77066ec>}
nname: 6
n 6(None)[__slots__ = []
def __enter__(self):
	lock()

def __exit__(self, type, value, tb):
	unlock()

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb770dd0c>}
nname: 0
n 0(None)[from __future__ import with_statement
from _wyvas import WyvasObject, lock, unlock
from os import path, unlink
import urllib
import logging
log = logging.getLogger('wyvas')
class InternalUrl(object):
	def __init__(self, uri):
		self._uri = uri
		self._must_delete = 0
		self._file = ''

	def __del__(self):
		self.cleanup()

	def cleanup(self):
		if self._must_delete:
			self._must_delete = 0
			log.debug('Removing file %s' % self._file)
			try:
				unlink(self._file)
			except Exception, e:
				log.debug('Error removing file: %s' % str(e))

	def get_uri(self):
		return self._uri

	def get_file(self):
		return self._file

	def get_file_path(self):
		if self._uri.find('file://') == 0:
			fn = urllib.unquote(self._uri).replace('file://', '')
			log.debug('Fetching [%s] -> [%s] : Ok' % (self._uri, fn))
			return fn
		try:
			from wytransport import wtpython as wt
			wytransport_version = 2
		except ImportError:
			from wytransport import pywytransport as wt
			wytransport_version = 1
		if wytransport_version == 1:
			job = wt.wt_create_job(self._uri, None)
			wt.wt_set_transfer_mode(job, wt.WT_DLNA_INTERACTIVE)
			wt.wt_set_friendly_name(job, 'wyvas_image')
			res = wt.wt_start_job(job)
			self._file = wt.wt_get_filename(job)
			wt.wt_destroy_job(job)
			if res != wt.WT_COMPLETED:
				self._file = None
		else:
			self._file = wt.wt_do_download(self._uri, '/wymedia/tmp/tmpdest_XXXXXX')
		if self._file is None:
			log.debug('Fetching [%s] -> [%s] : Error' % (self._uri, self._file))
		else:
			log.debug('Fetching [%s] -> [%s] : Ok' % (self._uri, self._file))
			self._must_delete = 1
		return self._file



class Object(object):
	__doc__ = '\n    Root class for all Wyvas objects.\n\n    This class defines the default methods that may or should be\n    overriden by other more specialized Wyvas objects such as\n    L{Container}, L{Image}...\n    '
	_end_callback = None
	animator_dict = dict(move=(1, 'move'), size=(2, 'resize'), scale=(2, 'resize'), color=(3, 'set_color'), opacity=(3, 'set_color'))
	step_type_dict = dict(linear=0, log=1, exp=2, samples=3, easeinout=3, easein=4, easeout=5, bounce=6)
	loop_type_dict = dict(none=0, redo=1, boom=2)
	percentage_arg_tuple = ('top', 'bottom', 'right', 'left', 'hcenter', 'vcenter', 'width', 'height')
	def update(self, *args, **args):
		print 'UPDATE ON OBJECT NOT IMPLEMENTING IT:',
		print self,
		print args,
		print kw

	def initialize(self, *args, **args):
		print 'INITIALIZE ON OBJECT NOT IMPLEMENTING IT:',
		print self,
		print args,
		print kw

	def __init__(self):
		self.obj = WyvasObject(0)
		self.parent = None
		self.name = 'obj'
		return None

	def _print_attributes(self):
		print '--------------------------'
		print 'OBJ CANVAS :',
		print self
		print 'parent     :',
		print self.parent
		print '------properties----------'
		print 'visibled   :',
		print self.get_visible()
		print 'pos        :',
		print self.get_pos()
		print 'size       :',
		print self.get_size()
		print 'layer      :',
		print self.get_layer()
		print 'color      :',
		print self.get_color()
		print '------internal------------'
		self.obj.debug()
		print '--------------------------'

	_arg_str_per = staticmethod()
	_arg_color = staticmethod()
	def move(self, **kw):
		arg_str_per = Object._arg_str_per
		for k, v in kw.iteritems():
			kw[k] = arg_str_per(v)
		self.obj.move(**kw)

	def set_color(self, r=None, g=None, b=None, a=None, color=None):
		if color is not None:
			r, g, b, a = color
		self.obj.set_color(color=Object._arg_color(r, g, b, a))
		return None

	def get_parent(self):
		return self.parent

	def unparent(self):
		if self.parent is not None:
			self.parent.remove_child(self)
			self.parent = None
		return None

	def adopted(self, parent):
		self.parent = parent
		self.parent._children.append(self)
		self.obj.adopted(parent.obj)

	def orphaned(self):
		if self.parent is not None:
			self.parent._children.remove(self)
			self.parent = None
			self.obj.orphaned()
		return None

	def resize(self, *args, **args):
		arg_str_per = Object._arg_str_per
		_[1], k, v = [], kw.iteritems(), kw.iteritems()
			kw[k] = arg_str_per(v)

	def get_pos(self):
		return self.obj.get_pos()

	def get_size(self):
		return self.obj.get_size()

	def get_color(self):
		return self.obj.get_color()

	def set_opacity(self, opacity):
		self.set_color(a=opacity)

	def get_opacity(self):
		return self.get_color()[3]

	def set_name(self, name):
		self.name = name

	def get_name(self):
		return self.name

	def set_layer(self, layer, absolute=0):
		if absolute:
			self.obj.set_layer(abs_layer=layer)
		else:
			self.obj.set_layer(layer=layer)

	def get_layer(self, absolute=0):
		return self.obj.get_layer(absolute)

	def show(self):
		self.obj.show()

	def hide(self):
		self.obj.hide()

	def set_visible(self, visible):
		self.obj.set_visible(visible)

	def get_visible(self):
		return self.obj.get_visible()

	def set_aspect(self, preserve_aspect=0):
		self.obj.set_aspect_preserve(preserve_aspect)

	def _invoke_end_callback(self):
		ec = self._end_callback
		if ec is not None:
			self._end_callback = None
			ec()
		return None

	def animate_stop(self, type=None):
		if type is None:
			type = 4
		else:
			type = self.animator_dict[type][0]
		self.obj.animate_stop(type)
		self._end_callback = None
		return None

	def animate(self, method, **kwargs):
		arg = {}
		kwargs_get = kwargs.get
		duration = kwargs_get('duration', 1) * 1000
		arg['duration'] = duration
		arg['animator'], animator_call = self.animator_dict[method]
		arg['step_type'] = Object.step_type_dict[kwargs_get('step_type', 'linear')]
		arg['loop_type'] = Object.loop_type_dict[kwargs_get('loop_type', 'none')]
		arg_str_per = Object._arg_str_per
		for argname in Object.percentage_arg_tuple:
			val = kwargs_get(argname)
			if val is not None:
				arg[argname] = arg_str_per(val)
				continue
		color = kwargs_get('color')
		if color is not None:
			arg['color'] = Object._arg_color(*color)
		else:
			r = kwargs_get('r')
			g = kwargs_get('g')
			b = kwargs_get('b')
			a = kwargs_get('a')
			if a is None:
				a = kwargs_get('opacity')
			arg['color'] = Object._arg_color(r, g, b, a)
		if self._end_callback is not None:
			log.debug('WYVAS WARNING, end_callback overridden !! (%s)' % self._end_callback)
		self._end_callback = kwargs_get('end_callback')
		if duration != 0:
			if self._end_callback is not None:
				arg['end_callback'] = self._invoke_end_callback
			self.obj.animate(**arg)
		else:
			getattr(self.obj, animator_call)(**arg)
			self._invoke_end_callback()
		return None

	def set_aspect_ratio(self, ratio=0):
		self.obj.set_aspect_ratio(ratio)

	def set_keep_real_size(self, keep_real_size=0):
		self.obj.set_keep_real_size(keep_real_size)



class Image(Object):
	__doc__ = " This class handles image object.\n\n    It's generic enough to display a lot of types of image such as:\n    jpeg, png, giff...\n\n    It's based on imlib2 library.\n    "
	def __init__(self, image_or_file=None, repository=None, size=None, url=None):
		self.name = 'obj'
		self._repository = repository
		self._file = None
		self._url = None
		self._angle = 0
		if url is not None and isinstance(url, basestring):
			self._url = InternalUrl(url)
			image_or_file = self._url.get_file_path()
		arg = {}
		if isinstance(image_or_file, basestring) or image_or_file is None:
			if image_or_file is not None:
				self._file = image_or_file
				try:
					arg['filename'] = self._find_file(image_or_file)
				except NameError, e:
					log.error(str(e))
					self._file = None
			self.obj = WyvasObject(1, **arg)
		else:
			if isinstance(image_or_file, buffer):
				data = image_or_file
				self.obj = WyvasObject(1, **arg)
				self.obj.set_data(data, size, False)
			else:
				raise TypeError('Images can be build from a string or a buffer only !!')
		self.parent = None
		return None

	def update(self, signal, sender, value, action=None, callback=None):
		if isinstance(value, basestring) and value[0] != '/' and '://' in value:
			self.load(url=value, callback=callback)
		else:
			self.load(value, callback=callback)

	initialize = update
	def set_border(self, left, right, top, bottom):
		self.obj.set_border(left, right, top, bottom)

	def load(self, file=None, url=None, callback=None):
		if self._url is not None:
			self._url.cleanup()
			self._url = None
		if url is not None and isinstance(url, basestring):
			self._url = InternalUrl(url)
			file = self._url.get_file_path()
		if file != self._file:
			if file is None:
				self._file = ''
			else:
				try:
					self._file = self._find_file(file)
				except NameError:
					log.info("Can't find '%s' !", file)
					self._file = ''
		else:
			if self._angle == 0:
				return None
		self._angle = 0
		self.obj.load(self._file, callback)
		return None

	def rotate(self, angle=1):
		angle %= 4
		if angle:
			self.obj.rotate(angle)
			self._angle += angle
			self._angle %= 4

	def _find_file(self, filename):
		if path.exists(filename):
			return filename
		else:
			if self._repository:
				fullpath = path.join(self._repository, filename)
				if path.exists(fullpath):
					return fullpath
		raise NameError('Unable to find file %s!' % filename)

	def set_repository(self, repository=None):
		self._repository = repository
		if self._file:
			self.load(self._file)

	def get_repository(self):
		return self._repository

	repository = property(get_repository, set_repository)


class Text(Object):
	__doc__ = " A class to create text.\n\n    It's based on Evas Text object.\n    "
	def __init__(self, text='', font='Vera', size=20, color=None):
		self.name = 'obj'
		arg = {}
		if text is not None:
			arg['text'] = text
		if font is not None:
			arg['font'] = font
		if size is not None:
			arg['font_size'] = size
		self.obj = WyvasObject(2, **arg)
		self.parent = None
		if color is not None:
			self.set_color(color=color)
		return None

	def update(self, signal, sender, value, action=None):
		self.set_text(value)

	initialize = update
	def set_font(self, font=None, size=None):
		arg = {}
		if font is not None:
			arg['font'] = font
		if size is not None:
			arg['font_size'] = size
		self.obj.set_font(**arg)
		return None

	def set_text(self, text, color=None):
		self.obj.set_text(text)
		if color is not None:
			self.set_color(*color)
		return None



class TextBlock(Text):
	__doc__ = " A class to create text block object.\n\n    It's based on Evas Text Block object.\n    "
	def __init__(self, text='', font='Vera', size=20, color=None, replace_and_sign=True):
		self.name = 'obj'
		arg = {}
		if text is not None:
			if replace_and_sign:
				pass
			arg['text'] = text
		if font is not None:
			arg['font'] = font
		if size is not None:
			arg['font_size'] = size
		arg['textblock'] = 1
		self.obj = WyvasObject(7, **arg)
		self.parent = None
		return None

	def get_text_geometry(self):
		return self.obj.get_text_geometry()



class Container(Object):
	__doc__ = ' A class used to manage others Wyvas objects.\n\n    All objects attached to the container are subject to modification\n    is the container itself is moved for example.\n    '
	def __init__(self):
		self.name = 'obj'
		self._children = []
		self.obj = WyvasObject(3)
		self.parent = None
		return None

	def _print_attributes(self):
		print '--------------------------'
		print '-------CONTAINER----------'
		print '--------------------------'
		print 'OBJ CANVAS :',
		print self
		print 'parent     :',
		print self.parent
		print '------properties----------'
		print 'visible    :',
		print self.get_visible()
		print 'pos        :',
		print self.get_pos()
		print 'size       :',
		print self.get_size()
		print 'layer      :',
		print self.get_layer()
		print 'color      :',
		print self.get_color()
		print '------internal------------'
		self.obj.debug()
		print '--------------------------'
		print '--------------------------'
		print '--------CHILD-------------'
		print '--------------------------'
		for child in self._children:
			child._print_attributes()
		print '--------------------------'
		print '-------END CONTAINER------'
		print '--------------------------'

	def add_child(self, child, **kwargs):
		if child in self._children:
			return None
		self._children.append(child)
		child.parent = self
		arg_str_per = Object._arg_str_per
		kwargs_get = kwargs.get

	def remove_child(self, child):
		if child not in self._children:
			raise ValueError, 'Child not found'
		self.obj.remove_child(child.obj)
		self._children.remove(child)
		child.parent = None
		return None

	def wipe(self):
		self.obj.wipe()
		self._children = []

	def get_obj_by_name(self, name):
		for child in self._children:
			if child.get_name() == name:
				return child
				continue
			if isinstance(child, Container):
				result = child.get_obj_by_name(name)
				if result is not None:
					return result
				else:
					continue
		return None

	def get_list_obj_by_name(self, name):
		result = []
		for child in self._children:
			if child and child.get_name() == name:
				result.append(child)
				continue
			if isinstance(child, Container):
				result.extend(child.get_list_obj_by_name(name))
				continue
		return result

	def set_size(self, width=None, height=None):
		size = (width, height)
		if self.parent is not None:
			self.obj.resize_size(size)
		else:
			self.resize(*size)
		return None



class Canvas(Container):
	__doc__ = ' A class which represents the screen.\n\n    You should create one instance of this object.\n    '
	def __init__(self, size, type=1, event=0, font_path='/usr/share/fonts', fb_dev=0, queue_size=5, key_repeat=2, fps=60):
		self.name = 'obj'
		self._children = []
		self.obj = WyvasObject(5, size=size, type=type, font_path=font_path, fb_dev=fb_dev, fps=fps)
		self._current_resolution = (size, type)
		self.parent = None
		self._callback = None
		self._event_compat = 0
		if event == 1:
			self._init_event(self._event_callback, queue_size, key_repeat)
		return None

	def set_resolution(self, size, interlaced=0, frequency=60):
		self.obj.set_resolution(size=size, interlaced=interlaced, frequency=frequency)
		self._current_resolution = (size, interlaced)

	def get_resolution(self):
		return self._current_resolution

	def _init_event(self, callback, queue_size, key_repeat):
		arg = {}
		arg['callback'] = callback
		arg['queue_size'] = queue_size
		arg['key_repeat'] = key_repeat
		self.obj.init_event(**arg)

	def _event_callback(self, key, press, time):
		if self._callback != None:
			press = bool(press)
			if self._event_compat == 1:
				self._callback(key, press)
			else:
				self._callback(key, press, time)
		return None

	def register_event(self, callback):
		self._callback = callback

	def register_event_keyboard(self, callback):
		print 'UNSUPPORTED NOW'

	def register_event_remote(self, callback):
		print 'UNSUPPORTED NOW'
		print '->activate fallback'
		self._event_compat = 1
		self._callback = callback



class LCD(Container):
	def __init__(self, size=(160, 128), font_path='/usr/share/fonts', fb_dev=1, use_framebuffer=True):
		self.name = 'obj'
		self._children = []
		if use_framebuffer == True:
			self.obj = WyvasObject(5, size=size, type=0, font_path=font_path, fb_dev=fb_dev)
		else:
			self.obj = WyvasObject(5, size=size, type=1, font_path=font_path, fb_dev=fb_dev)
		self.parent = None
		return None



class Rectangle(Object):
	__doc__ = " A class to create rectangle object.\n\n    It's based Evas Rectangle Object.\n    "
	def __init__(self, size=None, color=None):
		self.name = 'obj'
		arg = {}
		if size is not None:
			arg['width'] = (size[0], 0)
			arg['height'] = (size[1], 0)
		if color is not None:
			arg['color'] = Object._arg_color(*color)
		self.obj = WyvasObject(6, **arg)
		self.parent = None
		return None



class Viewer(Image):
	__doc__ = " This class as L{Image} display image.\n\n    But unlike L{Image}, it's faster to display jpeg image because it\n    uses the libjpeg in that case. Otherwise it uses the same method\n    as L{Image}.\n\n    It can also load all type of image asynchronously.\n    "
	def __init__(self, image_or_file=None, repository=None, output_size=(1280, 720), use_hardware=0, url=None):
		self.name = 'obj'
		self.parent = None
		self._repository = repository
		self._file = None
		self._url = None
		self._angle = 0
		if url is not None and isinstance(url, basestring):
			self._url = InternalUrl(url)
			image_or_file = self._url.get_file_path()
		arg = {}
		if isinstance(image_or_file, basestring) or image_or_file is None:
			if image_or_file is not None:
				self._file = image_or_file
				arg['filename'] = self._find_file(image_or_file)
			arg['output_size'] = output_size
			arg['use_hardware'] = use_hardware
			self.obj = WyvasObject(8, **arg)
		else:
			raise TypeError('Images can be build from a string only !!')
		return None

	def set_output_size(self, output_size=(1280, 720)):
		self.obj.set_output_size(output_size)



class Wydget(Image):
	def __init__(self, wydget_name=None, size=(1280, 720)):
		self.name = 'obj'
		self.parent = None
		self.obj = WyvasObject(9, wydget_name=wydget_name, size=size)
		return None

	def send_data(self, motif, *data):
		self.obj.send_data(motif, *data)

	def update(self, signal, sender, value, action=None):
		print 'Not Yet implemented'



class Animage(Wydget):
	def __init__(self, size=None):
		if size is None:
			raise ValueError('Browser accept only valid url !')
		self.name = 'obj'
		self.parent = None
		self.obj = WyvasObject(9, wydget_name='animage', size=size)
		return None

	def update(self, signal, sender, value, action=None):
		sleep = value['sleep']
		filename = value['filename']
		self.send_data('si', filename, sleep)



class Browser(Wydget):
	def __init__(self, size=(1280, 720)):
		self.name = 'obj'
		self.parent = None
		self.obj = WyvasObject(9, wydget_name='pleyo', size=size)
		return None

	def update(self, signal, sender, value, action=None):
		if isinstance(value, basestring) and '://' in value:
			self.send_data('s', value)
		else:
			raise TypeError('Browser accept only valid url !')



class Webcam(Wydget):
	def __init__(self, size=(0, 0)):
		self.name = 'obj'
		self.parent = None
		self.obj = WyvasObject(9, wydget_name='webcam', size=size)
		return None



class _WyvasLock(object):
	__slots__ = []
	def __enter__(self):
		lock()

	def __exit__(self, type, value, tb):
		unlock()



render_lock = _WyvasLock()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb770362c>}
from __future__ import with_statement
from _wyvas import WyvasObject, lock, unlock
from os import path, unlink
import urllib
import logging
log = logging.getLogger('wyvas')
class InternalUrl(object):
	def __init__(self, uri):
		self._uri = uri
		self._must_delete = 0
		self._file = ''

	def __del__(self):
		self.cleanup()

	def cleanup(self):
		if self._must_delete:
			self._must_delete = 0
			log.debug('Removing file %s' % self._file)
			try:
				unlink(self._file)
			except Exception, e:
				log.debug('Error removing file: %s' % str(e))

	def get_uri(self):
		return self._uri

	def get_file(self):
		return self._file

	def get_file_path(self):
		if self._uri.find('file://') == 0:
			fn = urllib.unquote(self._uri).replace('file://', '')
			log.debug('Fetching [%s] -> [%s] : Ok' % (self._uri, fn))
			return fn
		try:
			from wytransport import wtpython as wt
			wytransport_version = 2
		except ImportError:
			from wytransport import pywytransport as wt
			wytransport_version = 1
		if wytransport_version == 1:
			job = wt.wt_create_job(self._uri, None)
			wt.wt_set_transfer_mode(job, wt.WT_DLNA_INTERACTIVE)
			wt.wt_set_friendly_name(job, 'wyvas_image')
			res = wt.wt_start_job(job)
			self._file = wt.wt_get_filename(job)
			wt.wt_destroy_job(job)
			if res != wt.WT_COMPLETED:
				self._file = None
		else:
			self._file = wt.wt_do_download(self._uri, '/wymedia/tmp/tmpdest_XXXXXX')
		if self._file is None:
			log.debug('Fetching [%s] -> [%s] : Error' % (self._uri, self._file))
		else:
			log.debug('Fetching [%s] -> [%s] : Ok' % (self._uri, self._file))
			self._must_delete = 1
		return self._file



class Object(object):
	__doc__ = '\n    Root class for all Wyvas objects.\n\n    This class defines the default methods that may or should be\n    overriden by other more specialized Wyvas objects such as\n    L{Container}, L{Image}...\n    '
	_end_callback = None
	animator_dict = dict(move=(1, 'move'), size=(2, 'resize'), scale=(2, 'resize'), color=(3, 'set_color'), opacity=(3, 'set_color'))
	step_type_dict = dict(linear=0, log=1, exp=2, samples=3, easeinout=3, easein=4, easeout=5, bounce=6)
	loop_type_dict = dict(none=0, redo=1, boom=2)
	percentage_arg_tuple = ('top', 'bottom', 'right', 'left', 'hcenter', 'vcenter', 'width', 'height')
	def update(self, *args, **args):
		print 'UPDATE ON OBJECT NOT IMPLEMENTING IT:',
		print self,
		print args,
		print kw

	def initialize(self, *args, **args):
		print 'INITIALIZE ON OBJECT NOT IMPLEMENTING IT:',
		print self,
		print args,
		print kw

	def __init__(self):
		self.obj = WyvasObject(0)
		self.parent = None
		self.name = 'obj'
		return None

	def _print_attributes(self):
		print '--------------------------'
		print 'OBJ CANVAS :',
		print self
		print 'parent     :',
		print self.parent
		print '------properties----------'
		print 'visibled   :',
		print self.get_visible()
		print 'pos        :',
		print self.get_pos()
		print 'size       :',
		print self.get_size()
		print 'layer      :',
		print self.get_layer()
		print 'color      :',
		print self.get_color()
		print '------internal------------'
		self.obj.debug()
		print '--------------------------'

	_arg_str_per = staticmethod()
	_arg_color = staticmethod()
	def move(self, **kw):
		arg_str_per = Object._arg_str_per
		for k, v in kw.iteritems():
			kw[k] = arg_str_per(v)
		self.obj.move(**kw)

	def set_color(self, r=None, g=None, b=None, a=None, color=None):
		if color is not None:
			r, g, b, a = color
		self.obj.set_color(color=Object._arg_color(r, g, b, a))
		return None

	def get_parent(self):
		return self.parent

	def unparent(self):
		if self.parent is not None:
			self.parent.remove_child(self)
			self.parent = None
		return None

	def adopted(self, parent):
		self.parent = parent
		self.parent._children.append(self)
		self.obj.adopted(parent.obj)

	def orphaned(self):
		if self.parent is not None:
			self.parent._children.remove(self)
			self.parent = None
			self.obj.orphaned()
		return None

	def resize(self, *args, **args):
		arg_str_per = Object._arg_str_per
		_[1], k, v = [], kw.iteritems(), kw.iteritems()
			kw[k] = arg_str_per(v)

	def get_pos(self):
		return self.obj.get_pos()

	def get_size(self):
		return self.obj.get_size()

	def get_color(self):
		return self.obj.get_color()

	def set_opacity(self, opacity):
		self.set_color(a=opacity)

	def get_opacity(self):
		return self.get_color()[3]

	def set_name(self, name):
		self.name = name

	def get_name(self):
		return self.name

	def set_layer(self, layer, absolute=0):
		if absolute:
			self.obj.set_layer(abs_layer=layer)
		else:
			self.obj.set_layer(layer=layer)

	def get_layer(self, absolute=0):
		return self.obj.get_layer(absolute)

	def show(self):
		self.obj.show()

	def hide(self):
		self.obj.hide()

	def set_visible(self, visible):
		self.obj.set_visible(visible)

	def get_visible(self):
		return self.obj.get_visible()

	def set_aspect(self, preserve_aspect=0):
		self.obj.set_aspect_preserve(preserve_aspect)

	def _invoke_end_callback(self):
		ec = self._end_callback
		if ec is not None:
			self._end_callback = None
			ec()
		return None

	def animate_stop(self, type=None):
		if type is None:
			type = 4
		else:
			type = self.animator_dict[type][0]
		self.obj.animate_stop(type)
		self._end_callback = None
		return None

	def animate(self, method, **kwargs):
		arg = {}
		kwargs_get = kwargs.get
		duration = kwargs_get('duration', 1) * 1000
		arg['duration'] = duration
		arg['animator'], animator_call = self.animator_dict[method]
		arg['step_type'] = Object.step_type_dict[kwargs_get('step_type', 'linear')]
		arg['loop_type'] = Object.loop_type_dict[kwargs_get('loop_type', 'none')]
		arg_str_per = Object._arg_str_per
		for argname in Object.percentage_arg_tuple:
			val = kwargs_get(argname)
			if val is not None:
				arg[argname] = arg_str_per(val)
				continue
		color = kwargs_get('color')
		if color is not None:
			arg['color'] = Object._arg_color(*color)
		else:
			r = kwargs_get('r')
			g = kwargs_get('g')
			b = kwargs_get('b')
			a = kwargs_get('a')
			if a is None:
				a = kwargs_get('opacity')
			arg['color'] = Object._arg_color(r, g, b, a)
		if self._end_callback is not None:
			log.debug('WYVAS WARNING, end_callback overridden !! (%s)' % self._end_callback)
		self._end_callback = kwargs_get('end_callback')
		if duration != 0:
			if self._end_callback is not None:
				arg['end_callback'] = self._invoke_end_callback
			self.obj.animate(**arg)
		else:
			getattr(self.obj, animator_call)(**arg)
			self._invoke_end_callback()
		return None

	def set_aspect_ratio(self, ratio=0):
		self.obj.set_aspect_ratio(ratio)

	def set_keep_real_size(self, keep_real_size=0):
		self.obj.set_keep_real_size(keep_real_size)



class Image(Object):
	__doc__ = " This class handles image object.\n\n    It's generic enough to display a lot of types of image such as:\n    jpeg, png, giff...\n\n    It's based on imlib2 library.\n    "
	def __init__(self, image_or_file=None, repository=None, size=None, url=None):
		self.name = 'obj'
		self._repository = repository
		self._file = None
		self._url = None
		self._angle = 0
		if url is not None and isinstance(url, basestring):
			self._url = InternalUrl(url)
			image_or_file = self._url.get_file_path()
		arg = {}
		if isinstance(image_or_file, basestring) or image_or_file is None:
			if image_or_file is not None:
				self._file = image_or_file
				try:
					arg['filename'] = self._find_file(image_or_file)
				except NameError, e:
					log.error(str(e))
					self._file = None
			self.obj = WyvasObject(1, **arg)
		else:
			if isinstance(image_or_file, buffer):
				data = image_or_file
				self.obj = WyvasObject(1, **arg)
				self.obj.set_data(data, size, False)
			else:
				raise TypeError('Images can be build from a string or a buffer only !!')
		self.parent = None
		return None

	def update(self, signal, sender, value, action=None, callback=None):
		if isinstance(value, basestring) and value[0] != '/' and '://' in value:
			self.load(url=value, callback=callback)
		else:
			self.load(value, callback=callback)

	initialize = update
	def set_border(self, left, right, top, bottom):
		self.obj.set_border(left, right, top, bottom)

	def load(self, file=None, url=None, callback=None):
		if self._url is not None:
			self._url.cleanup()
			self._url = None
		if url is not None and isinstance(url, basestring):
			self._url = InternalUrl(url)
			file = self._url.get_file_path()
		if file != self._file:
			if file is None:
				self._file = ''
			else:
				try:
					self._file = self._find_file(file)
				except NameError:
					log.info("Can't find '%s' !", file)
					self._file = ''
		else:
			if self._angle == 0:
				return None
		self._angle = 0
		self.obj.load(self._file, callback)
		return None

	def rotate(self, angle=1):
		angle %= 4
		if angle:
			self.obj.rotate(angle)
			self._angle += angle
			self._angle %= 4

	def _find_file(self, filename):
		if path.exists(filename):
			return filename
		else:
			if self._repository:
				fullpath = path.join(self._repository, filename)
				if path.exists(fullpath):
					return fullpath
		raise NameError('Unable to find file %s!' % filename)

	def set_repository(self, repository=None):
		self._repository = repository
		if self._file:
			self.load(self._file)

	def get_repository(self):
		return self._repository

	repository = property(get_repository, set_repository)


class Text(Object):
	__doc__ = " A class to create text.\n\n    It's based on Evas Text object.\n    "
	def __init__(self, text='', font='Vera', size=20, color=None):
		self.name = 'obj'
		arg = {}
		if text is not None:
			arg['text'] = text
		if font is not None:
			arg['font'] = font
		if size is not None:
			arg['font_size'] = size
		self.obj = WyvasObject(2, **arg)
		self.parent = None
		if color is not None:
			self.set_color(color=color)
		return None

	def update(self, signal, sender, value, action=None):
		self.set_text(value)

	initialize = update
	def set_font(self, font=None, size=None):
		arg = {}
		if font is not None:
			arg['font'] = font
		if size is not None:
			arg['font_size'] = size
		self.obj.set_font(**arg)
		return None

	def set_text(self, text, color=None):
		self.obj.set_text(text)
		if color is not None:
			self.set_color(*color)
		return None



class TextBlock(Text):
	__doc__ = " A class to create text block object.\n\n    It's based on Evas Text Block object.\n    "
	def __init__(self, text='', font='Vera', size=20, color=None, replace_and_sign=True):
		self.name = 'obj'
		arg = {}
		if text is not None:
			if replace_and_sign:
				pass
			arg['text'] = text
		if font is not None:
			arg['font'] = font
		if size is not None:
			arg['font_size'] = size
		arg['textblock'] = 1
		self.obj = WyvasObject(7, **arg)
		self.parent = None
		return None

	def get_text_geometry(self):
		return self.obj.get_text_geometry()



class Container(Object):
	__doc__ = ' A class used to manage others Wyvas objects.\n\n    All objects attached to the container are subject to modification\n    is the container itself is moved for example.\n    '
	def __init__(self):
		self.name = 'obj'
		self._children = []
		self.obj = WyvasObject(3)
		self.parent = None
		return None

	def _print_attributes(self):
		print '--------------------------'
		print '-------CONTAINER----------'
		print '--------------------------'
		print 'OBJ CANVAS :',
		print self
		print 'parent     :',
		print self.parent
		print '------properties----------'
		print 'visible    :',
		print self.get_visible()
		print 'pos        :',
		print self.get_pos()
		print 'size       :',
		print self.get_size()
		print 'layer      :',
		print self.get_layer()
		print 'color      :',
		print self.get_color()
		print '------internal------------'
		self.obj.debug()
		print '--------------------------'
		print '--------------------------'
		print '--------CHILD-------------'
		print '--------------------------'
		for child in self._children:
			child._print_attributes()
		print '--------------------------'
		print '-------END CONTAINER------'
		print '--------------------------'

	def add_child(self, child, **kwargs):
		if child in self._children:
			return None
		self._children.append(child)
		child.parent = self
		arg_str_per = Object._arg_str_per
		kwargs_get = kwargs.get

	def remove_child(self, child):
		if child not in self._children:
			raise ValueError, 'Child not found'
		self.obj.remove_child(child.obj)
		self._children.remove(child)
		child.parent = None
		return None

	def wipe(self):
		self.obj.wipe()
		self._children = []

	def get_obj_by_name(self, name):
		for child in self._children:
			if child.get_name() == name:
				return child
				continue
			if isinstance(child, Container):
				result = child.get_obj_by_name(name)
				if result is not None:
					return result
				else:
					continue
		return None

	def get_list_obj_by_name(self, name):
		result = []
		for child in self._children:
			if child and child.get_name() == name:
				result.append(child)
				continue
			if isinstance(child, Container):
				result.extend(child.get_list_obj_by_name(name))
				continue
		return result

	def set_size(self, width=None, height=None):
		size = (width, height)
		if self.parent is not None:
			self.obj.resize_size(size)
		else:
			self.resize(*size)
		return None



class Canvas(Container):
	__doc__ = ' A class which represents the screen.\n\n    You should create one instance of this object.\n    '
	def __init__(self, size, type=1, event=0, font_path='/usr/share/fonts', fb_dev=0, queue_size=5, key_repeat=2, fps=60):
		self.name = 'obj'
		self._children = []
		self.obj = WyvasObject(5, size=size, type=type, font_path=font_path, fb_dev=fb_dev, fps=fps)
		self._current_resolution = (size, type)
		self.parent = None
		self._callback = None
		self._event_compat = 0
		if event == 1:
			self._init_event(self._event_callback, queue_size, key_repeat)
		return None

	def set_resolution(self, size, interlaced=0, frequency=60):
		self.obj.set_resolution(size=size, interlaced=interlaced, frequency=frequency)
		self._current_resolution = (size, interlaced)

	def get_resolution(self):
		return self._current_resolution

	def _init_event(self, callback, queue_size, key_repeat):
		arg = {}
		arg['callback'] = callback
		arg['queue_size'] = queue_size
		arg['key_repeat'] = key_repeat
		self.obj.init_event(**arg)

	def _event_callback(self, key, press, time):
		if self._callback != None:
			press = bool(press)
			if self._event_compat == 1:
				self._callback(key, press)
			else:
				self._callback(key, press, time)
		return None

	def register_event(self, callback):
		self._callback = callback

	def register_event_keyboard(self, callback):
		print 'UNSUPPORTED NOW'

	def register_event_remote(self, callback):
		print 'UNSUPPORTED NOW'
		print '->activate fallback'
		self._event_compat = 1
		self._callback = callback



class LCD(Container):
	def __init__(self, size=(160, 128), font_path='/usr/share/fonts', fb_dev=1, use_framebuffer=True):
		self.name = 'obj'
		self._children = []
		if use_framebuffer == True:
			self.obj = WyvasObject(5, size=size, type=0, font_path=font_path, fb_dev=fb_dev)
		else:
			self.obj = WyvasObject(5, size=size, type=1, font_path=font_path, fb_dev=fb_dev)
		self.parent = None
		return None



class Rectangle(Object):
	__doc__ = " A class to create rectangle object.\n\n    It's based Evas Rectangle Object.\n    "
	def __init__(self, size=None, color=None):
		self.name = 'obj'
		arg = {}
		if size is not None:
			arg['width'] = (size[0], 0)
			arg['height'] = (size[1], 0)
		if color is not None:
			arg['color'] = Object._arg_color(*color)
		self.obj = WyvasObject(6, **arg)
		self.parent = None
		return None



class Viewer(Image):
	__doc__ = " This class as L{Image} display image.\n\n    But unlike L{Image}, it's faster to display jpeg image because it\n    uses the libjpeg in that case. Otherwise it uses the same method\n    as L{Image}.\n\n    It can also load all type of image asynchronously.\n    "
	def __init__(self, image_or_file=None, repository=None, output_size=(1280, 720), use_hardware=0, url=None):
		self.name = 'obj'
		self.parent = None
		self._repository = repository
		self._file = None
		self._url = None
		self._angle = 0
		if url is not None and isinstance(url, basestring):
			self._url = InternalUrl(url)
			image_or_file = self._url.get_file_path()
		arg = {}
		if isinstance(image_or_file, basestring) or image_or_file is None:
			if image_or_file is not None:
				self._file = image_or_file
				arg['filename'] = self._find_file(image_or_file)
			arg['output_size'] = output_size
			arg['use_hardware'] = use_hardware
			self.obj = WyvasObject(8, **arg)
		else:
			raise TypeError('Images can be build from a string only !!')
		return None

	def set_output_size(self, output_size=(1280, 720)):
		self.obj.set_output_size(output_size)



class Wydget(Image):
	def __init__(self, wydget_name=None, size=(1280, 720)):
		self.name = 'obj'
		self.parent = None
		self.obj = WyvasObject(9, wydget_name=wydget_name, size=size)
		return None

	def send_data(self, motif, *data):
		self.obj.send_data(motif, *data)

	def update(self, signal, sender, value, action=None):
		print 'Not Yet implemented'



class Animage(Wydget):
	def __init__(self, size=None):
		if size is None:
			raise ValueError('Browser accept only valid url !')
		self.name = 'obj'
		self.parent = None
		self.obj = WyvasObject(9, wydget_name='animage', size=size)
		return None

	def update(self, signal, sender, value, action=None):
		sleep = value['sleep']
		filename = value['filename']
		self.send_data('si', filename, sleep)



class Browser(Wydget):
	def __init__(self, size=(1280, 720)):
		self.name = 'obj'
		self.parent = None
		self.obj = WyvasObject(9, wydget_name='pleyo', size=size)
		return None

	def update(self, signal, sender, value, action=None):
		if isinstance(value, basestring) and '://' in value:
			self.send_data('s', value)
		else:
			raise TypeError('Browser accept only valid url !')



class Webcam(Wydget):
	def __init__(self, size=(0, 0)):
		self.name = 'obj'
		self.parent = None
		self.obj = WyvasObject(9, wydget_name='webcam', size=size)
		return None



class _WyvasLock(object):
	__slots__ = []
	def __enter__(self):
		lock()

	def __exit__(self, type, value, tb):
		unlock()



render_lock = _WyvasLock()
