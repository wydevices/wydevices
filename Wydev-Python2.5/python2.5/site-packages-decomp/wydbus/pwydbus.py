# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 110
n 110(None)[]:
	i: 0(AL), 108()
	o: 

nname: 108
n 108(None)[]:
	i: 31(f), 104()
	o: 110()

nname: 104
n 104(None)[]:
	i: 68(f), 99()
	o: 108()

nname: 99
n 99(None)[break
continue
]:
	i: 68(t)
	o: 104()

nname: 68
n 68(dbus_signature_iter_next(sigiter) == 0)[elements.append(py_object)
]:
	i: 62(), 67()
	o: 99(t), 104(f)

nname: 67
n 67(None)[]:
	i: 37(f)
	o: 68()

nname: 62
n 62(None)[break
]:
	i: 37(t)
	o: 68()

nname: 37
n 37(t == DBUS_TYPE_INVALID)[t = dbus_signature_iter_get_current_type(sigiter)
]:
	i: 31(t)
	o: 62(t), 67(f)

nname: 31
n 31(True)[]:
	i: 0(loop)
	o: 37(t), 108(f)

nname: 0
n 0(None)[sigiter = pointer(DBusSignatureIter())
dbus_signature_iter_init(sigiter, sig)
]:
	i: 
	o: 31(loop), 110(AL)

nname: 110
n 110(None)[]:
	i: 0(AL), 31(f), 37(f)
	o: 

nname: 37
n 37(None)[t = dbus_signature_iter_get_current_type(sigiter)
if t == DBUS_TYPE_INVALID:
	break
elements.append(py_object)
if dbus_signature_iter_next(sigiter) == 0:
	break
	continue
]:
	i: 31(t)
	o: 110()

nname: 31
n 31(True)[]:
	i: 0(loop)
	o: 37(t), 110(f)

nname: 0
n 0(None)[sigiter = pointer(DBusSignatureIter())
dbus_signature_iter_init(sigiter, sig)
]:
	i: 
	o: 31(loop), 110(AL)

nname: 37
n 37(None)[	t = dbus_signature_iter_get_current_type(sigiter)
	if t == DBUS_TYPE_INVALID:
		break
	elements.append(py_object)
	if dbus_signature_iter_next(sigiter) == 0:
		break
		continue
]:
	i: 0(t)
	o: 

nname: 0
n 0(True)[sigiter = pointer(DBusSignatureIter())
dbus_signature_iter_init(sigiter, sig)
while True:
]:
	i: 
	o: 37(t)

nname: 0
n 0(None)[sigiter = pointer(DBusSignatureIter())
dbus_signature_iter_init(sigiter, sig)
while True:
	t = dbus_signature_iter_get_current_type(sigiter)
	if t == DBUS_TYPE_INVALID:
		break
	elements.append(py_object)
	if dbus_signature_iter_next(sigiter) == 0:
		break
		continue
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb763cfac>}
nname: 95
n 95(None)[argtypes = []
_sigiter(argtypes, asig)
return CFUNCTYPE(restype, *argtypes)
]:
	i: 66(), 80(), 93(AE)
	o: 

nname: 93
n 93(None)[]:
	i: 70(f)
	o: 95(AE)

nname: 80
n 80(None)[restype = None
]:
	i: 70(t)
	o: 95()

nname: 70
n 70(<dummy_ex3> EXC_MATCH IndexError)[]:
	i: 0(except)
	o: 80(t), 93(f)

nname: 66
n 66(None)[]:
	i: 56(), 65()
	o: 95()

nname: 65
n 65(None)[]:
	i: 28(f)
	o: 66()

nname: 56
n 56(None)[print 'warning: method return signatures should have only one element!'
]:
	i: 28(t)
	o: 66()

nname: 28
n 28(len(rtypes) > 1)[restype = rtypes[0]
]:
	i: 0(try)
	o: 56(t), 65(f)

nname: 0
n 0(None)[rtypes = []
real_restype = None
_sigiter(rtypes, rsig)
]:
	i: 
	o: 28(try), 70(except)

nname: 95
n 95(None)[argtypes = []
_sigiter(argtypes, asig)
return CFUNCTYPE(restype, *argtypes)
]:
	i: 70(), 0()
	o: 

nname: 70
n 70(None)[except IndexError:
	restype = None
]:
	i: 0()
	o: 95()

nname: 95
n 95(None)[argtypes = []
_sigiter(argtypes, asig)
return CFUNCTYPE(restype, *argtypes)
]:
	i: 70(), 0()
	o: 

nname: 0
n 0(None)[rtypes = []
real_restype = None
_sigiter(rtypes, rsig)
try:
	restype = rtypes[0]
	if len(rtypes) > 1:
		print 'warning: method return signatures should have only one element!'
]:
	i: 
	o: 95(), 70()

self.nodes: {0: <unpyclib.structure.node instance at 0xb76402ac>, 70: <unpyclib.structure.node instance at 0xb76409cc>, 95: <unpyclib.structure.node instance at 0xb764076c>}
nname: 0
n 0(None)[self._proxy = proxy
self.free = wydbus_free_proxy
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb763cfac>}
nname: 88
n 88(None)[return None
]:
	i: 9(), 84()
	o: 

nname: 84
n 84(None)[return ret
]:
	i: 64(), 83()
	o: 88()

nname: 83
n 83(None)[]:
	i: 17&48(f)
	o: 84()

nname: 64
n 64(None)[raise ret(ret.__error__)
]:
	i: 17&48(t)
	o: 84()

nname: 17&48
n 17&48(isinstance(ret, type) and issubclass(ret, BaseException))[ret = self._proxy(*args)
]:
	i: 0(t)
	o: 64(t), 83(f)

nname: 9
n 9(None)[return None
]:
	i: 0(f)
	o: 88()

nname: 0
n 0(self._proxy)[]:
	i: 
	o: 9(f), 17&48(t)

nname: 88
n 88(None)[return None
]:
	i: 9(), 17&48()
	o: 

nname: 17&48
n 17&48(None)[ret = self._proxy(*args)
if isinstance(ret, type) and issubclass(ret, BaseException):
	raise ret(ret.__error__)
return ret
]:
	i: 0(t)
	o: 88()

nname: 9
n 9(None)[return None
]:
	i: 0(f)
	o: 88()

nname: 0
n 0(self._proxy)[]:
	i: 
	o: 9(f), 17&48(t)

nname: 0
n 0(None)[if not self._proxy:
	return None
else:
	ret = self._proxy(*args)
	if isinstance(ret, type) and issubclass(ret, BaseException):
		raise ret(ret.__error__)
	return ret
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7640f6c>}
nname: 52
n 52(None)[return None
]:
	i: 31(), 51()
	o: 

nname: 51
n 51(None)[]:
	i: 0&15(f)
	o: 52()

nname: 31
n 31(None)[self.free(self._proxy)
]:
	i: 0&15(t)
	o: 52()

nname: 0&15
n 0&15(self._proxy != None and self.free != None)[]:
	i: 
	o: 31(t), 51(f)

nname: 0&15
n 0&15(None)[if self._proxy != None and self.free != None:
	self.free(self._proxy)
return None
]:
	i: 
	o: 

self.nodes: {'0&15': <unpyclib.structure.node instance at 0xb7640c6c>}
nname: 6
n 6(None)[def __init__(self, proxy):
	self._proxy = proxy
	self.free = wydbus_free_proxy

def __call__(self, *args):
	if not self._proxy:
		return None
	else:
		ret = self._proxy(*args)
		if isinstance(ret, type) and issubclass(ret, BaseException):
			raise ret(ret.__error__)
		return ret
	return None

def __del__(self):
	if self._proxy != None and self.free != None:
		self.free(self._proxy)
	return None

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb763cacc>}
nname: 0
n 0(None)[self._ref = wydbus_reference2(parent._bus, name, path, interface)
self._path = path
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb763ceac>}
nname: 0
n 0(None)[px = _sig2func(rsig, asig)(_wydbus_proxy(self._ref, name, asig, rsig, pointer(pymarshal)))
return WyDbusProxy(px)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb763ce4c>}
nname: 6
n 6(None)[def __init__(self, parent, name, path, interface):
	self._ref = wydbus_reference2(parent._bus, name, path, interface)
	self._path = path

def method(self, name, asig, rsig):
	px = _sig2func(rsig, asig)(_wydbus_proxy(self._ref, name, asig, rsig, pointer(pymarshal)))
	return WyDbusProxy(px)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb763ca4c>}
nname: 0
n 0(None)[self._obj = wydbus_instance(bus, path)
self._handlers = {}
self._path = path
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb764050c>}
nname: 0
n 0(None)[ccb = _sig2func(rsig, asig)
handler_t = type('%s_%s' % (rsig, asig), (Structure,), {})
handler_t._fields_ = [('name', c_char_p), ('sig', c_char_p * 2), ('fn', ccb), ('data', c_void_p), ('flags', c_int), ('free', CFUNCTYPE(None, c_void_p)), ('m', POINTER(wydbus_marshal_t))]
h = handler_t()
h.name = name
h.sig[0] = asig
h.sig[1] = rsig
h.fn = ccb(cb)
h.flags = flags
h.data = None
h.m = pointer(pymarshal)
wydbus_register_handler(self._obj, byref(h), None, htype)
self._handlers[name] = h.fn
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x9374e6c>}
nname: 0
n 0(None)[self._handler(name, asig, rsig, cb, flags | WDB_FREE_ARGS, 0)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb764076c>}
nname: 0
n 0(None)[self._handler(name, asig, '', cb, flags, 1)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb764050c>}
nname: 6
n 6(None)[def __init__(self, bus, path):
	self._obj = wydbus_instance(bus, path)
	self._handlers = {}
	self._path = path

def _handler(self, name, asig, rsig, cb, flags, htype):
	ccb = _sig2func(rsig, asig)
	handler_t = type('%s_%s' % (rsig, asig), (Structure,), {})
	handler_t._fields_ = [('name', c_char_p), ('sig', c_char_p * 2), ('fn', ccb), ('data', c_void_p), ('flags', c_int), ('free', CFUNCTYPE(None, c_void_p)), ('m', POINTER(wydbus_marshal_t))]
	h = handler_t()
	h.name = name
	h.sig[0] = asig
	h.sig[1] = rsig
	h.fn = ccb(cb)
	h.flags = flags
	h.data = None
	h.m = pointer(pymarshal)
	wydbus_register_handler(self._obj, byref(h), None, htype)
	self._handlers[name] = h.fn
	return None

def method(self, name, asig, rsig, cb, flags):
	self._handler(name, asig, rsig, cb, flags | WDB_FREE_ARGS, 0)

def signal(self, name, asig, cb, flags):
	self._handler(name, asig, '', cb, flags, 1)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb763cc0c>}
nname: 0
n 0(None)[super(WyDbusSingleton, klass).__init__(name, bases, dikt)
klass._s_instances_ = {}
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb763cfac>}
nname: 60
n 60(None)[return klass._s_instances_[name]
]:
	i: 18(), 59()
	o: 

nname: 59
n 59(None)[]:
	i: 0(t)
	o: 60()

nname: 18
n 18(None)[klass._s_instances_[name] = super(WyDbusSingleton, klass).__call__(name, *args, **kw)
]:
	i: 0(f)
	o: 60()

nname: 0
n 0(klass._s_instances_.has_key(name))[]:
	i: 
	o: 18(f), 59(t)

nname: 0
n 0(None)[if not klass._s_instances_.has_key(name):
	klass._s_instances_[name] = super(WyDbusSingleton, klass).__call__(name, *args, **kw)
return klass._s_instances_[name]
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7640e4c>}
nname: 6
n 6(None)[def __init__(klass, name, bases, dikt):
	super(WyDbusSingleton, klass).__init__(name, bases, dikt)
	klass._s_instances_ = {}

def __call__(klass, name='', *args, **args):
	if not klass._s_instances_.has_key(name):
		klass._s_instances_[name] = super(WyDbusSingleton, klass).__call__(name, *args, **kw)
	return klass._s_instances_[name]

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb763cbac>}
nname: 89
n 89(None)[]:
	i: 72(), 88()
	o: 

nname: 88
n 88(None)[]:
	i: 32(t)
	o: 89()

nname: 72
n 72(None)[raise OSError('unable to get a dbus connection')
]:
	i: 32(f)
	o: 89()

nname: 32
n 32(self._bus)[self._bus = wydbus_new(type, name)
wydbus_run(self._bus)
]:
	i: 15(), 25()
	o: 72(f), 88(t)

nname: 25
n 25(None)[type = DBUS_BUS_SESSION
]:
	i: 0(f)
	o: 32()

nname: 15
n 15(None)[type = DBUS_BUS_SYSTEM
]:
	i: 0(t)
	o: 32()

nname: 0
n 0(system)[self.free = wydbus_free
]:
	i: 
	o: 15(t), 25(f)

nname: 89
n 89(None)[]:
	i: 0()
	o: 

nname: 0
n 0(None)[self.free = wydbus_free
if system:
	type = DBUS_BUS_SYSTEM
else:
	type = DBUS_BUS_SESSION
self._bus = wydbus_new(type, name)
wydbus_run(self._bus)
if not self._bus:
	raise OSError('unable to get a dbus connection')
]:
	i: 
	o: 89()

nname: 0
n 0(None)[self.free = wydbus_free
if system:
	type = DBUS_BUS_SYSTEM
else:
	type = DBUS_BUS_SESSION
self._bus = wydbus_new(type, name)
wydbus_run(self._bus)
if not self._bus:
	raise OSError('unable to get a dbus connection')
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7640dec>}
nname: 0
n 0(None)[return WyDbusReference(self, name, path, interface)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7640d8c>}
nname: 0
n 0(None)[return WyDbusInstance(self._bus, path)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb764036c>}
nname: 0
n 0(None)[px = _sig2func('', sig)(_wydbus_proxy(self._bus, path, name, sig, pointer(pymarshal), interface))
return WyDbusProxy(px)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7640d0c>}
nname: 0
n 0(None)[self.free(self._bus)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76400cc>}
nname: 6
n 6(None)[__metaclass__ = WyDbusSingleton
def __init__(self, name='', system=True):
	self.free = wydbus_free
	if system:
		type = DBUS_BUS_SYSTEM
	else:
		type = DBUS_BUS_SESSION
	self._bus = wydbus_new(type, name)
	wydbus_run(self._bus)
	if not self._bus:
		raise OSError('unable to get a dbus connection')

def reference(self, name, path, interface=None):
	return WyDbusReference(self, name, path, interface)

def instance(self, path):
	return WyDbusInstance(self._bus, path)

def signal(self, path, name, sig, interface='com.wyplay.XXX_USE_WYDBUS_SIGNAL_PROPERLY'):
	px = _sig2func('', sig)(_wydbus_proxy(self._bus, path, name, sig, pointer(pymarshal), interface))
	return WyDbusProxy(px)

def __del__(self):
	self.free(self._bus)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb763cccc>}
nname: 0
n 0(None)[from _wydbus import *
from ctypes import py_object, c_char_p, c_void_p, c_int, Structure, CDLL
from ctypes import byref, pointer, POINTER, CFUNCTYPE
import exceptions
import sys
from time import sleep
libmarshal = CDLL(__file__[:__file__.rfind('/')] + '/_py_marshal.so')
pymarshal = wydbus_marshal_t.in_dll(libmarshal, 'python_marshal')
def _sigiter(elements, sig):
	sigiter = pointer(DBusSignatureIter())
	dbus_signature_iter_init(sigiter, sig)
	while True:
		t = dbus_signature_iter_get_current_type(sigiter)
		if t == DBUS_TYPE_INVALID:
			break
		elements.append(py_object)
		if dbus_signature_iter_next(sigiter) == 0:
			break
			continue

def _sig2func(rsig, asig):
	rtypes = []
	real_restype = None
	_sigiter(rtypes, rsig)
	try:
		restype = rtypes[0]
		if len(rtypes) > 1:
			print 'warning: method return signatures should have only one element!'

class WyDbusProxy(object):
	def __init__(self, proxy):
		self._proxy = proxy
		self.free = wydbus_free_proxy

	def __call__(self, *args):
		if not self._proxy:
			return None
		else:
			ret = self._proxy(*args)
			if isinstance(ret, type) and issubclass(ret, BaseException):
				raise ret(ret.__error__)
			return ret
		return None

	def __del__(self):
		if self._proxy != None and self.free != None:
			self.free(self._proxy)
		return None



class WyDbusReference(object):
	def __init__(self, parent, name, path, interface):
		self._ref = wydbus_reference2(parent._bus, name, path, interface)
		self._path = path

	def method(self, name, asig, rsig):
		px = _sig2func(rsig, asig)(_wydbus_proxy(self._ref, name, asig, rsig, pointer(pymarshal)))
		return WyDbusProxy(px)



class WyDbusInstance(object):
	def __init__(self, bus, path):
		self._obj = wydbus_instance(bus, path)
		self._handlers = {}
		self._path = path

	def _handler(self, name, asig, rsig, cb, flags, htype):
		ccb = _sig2func(rsig, asig)
		handler_t = type('%s_%s' % (rsig, asig), (Structure,), {})
		handler_t._fields_ = [('name', c_char_p), ('sig', c_char_p * 2), ('fn', ccb), ('data', c_void_p), ('flags', c_int), ('free', CFUNCTYPE(None, c_void_p)), ('m', POINTER(wydbus_marshal_t))]
		h = handler_t()
		h.name = name
		h.sig[0] = asig
		h.sig[1] = rsig
		h.fn = ccb(cb)
		h.flags = flags
		h.data = None
		h.m = pointer(pymarshal)
		wydbus_register_handler(self._obj, byref(h), None, htype)
		self._handlers[name] = h.fn
		return None

	def method(self, name, asig, rsig, cb, flags):
		self._handler(name, asig, rsig, cb, flags | WDB_FREE_ARGS, 0)

	def signal(self, name, asig, cb, flags):
		self._handler(name, asig, '', cb, flags, 1)



class WyDbusSingleton(type):
	def __init__(klass, name, bases, dikt):
		super(WyDbusSingleton, klass).__init__(name, bases, dikt)
		klass._s_instances_ = {}

	def __call__(klass, name='', *args, **args):
		if not klass._s_instances_.has_key(name):
			klass._s_instances_[name] = super(WyDbusSingleton, klass).__call__(name, *args, **kw)
		return klass._s_instances_[name]



class WyDbus(object):
	__metaclass__ = WyDbusSingleton
	def __init__(self, name='', system=True):
		self.free = wydbus_free
		if system:
			type = DBUS_BUS_SYSTEM
		else:
			type = DBUS_BUS_SESSION
		self._bus = wydbus_new(type, name)
		wydbus_run(self._bus)
		if not self._bus:
			raise OSError('unable to get a dbus connection')

	def reference(self, name, path, interface=None):
		return WyDbusReference(self, name, path, interface)

	def instance(self, path):
		return WyDbusInstance(self._bus, path)

	def signal(self, path, name, sig, interface='com.wyplay.XXX_USE_WYDBUS_SIGNAL_PROPERLY'):
		px = _sig2func('', sig)(_wydbus_proxy(self._bus, path, name, sig, pointer(pymarshal), interface))
		return WyDbusProxy(px)

	def __del__(self):
		self.free(self._bus)



WyDBus = WyDbus
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb763374c>}
from _wydbus import *
from ctypes import py_object, c_char_p, c_void_p, c_int, Structure, CDLL
from ctypes import byref, pointer, POINTER, CFUNCTYPE
import exceptions
import sys
from time import sleep
libmarshal = CDLL(__file__[:__file__.rfind('/')] + '/_py_marshal.so')
pymarshal = wydbus_marshal_t.in_dll(libmarshal, 'python_marshal')
def _sigiter(elements, sig):
	sigiter = pointer(DBusSignatureIter())
	dbus_signature_iter_init(sigiter, sig)
	while True:
		t = dbus_signature_iter_get_current_type(sigiter)
		if t == DBUS_TYPE_INVALID:
			break
		elements.append(py_object)
		if dbus_signature_iter_next(sigiter) == 0:
			break
			continue

def _sig2func(rsig, asig):
	rtypes = []
	real_restype = None
	_sigiter(rtypes, rsig)
	try:
		restype = rtypes[0]
		if len(rtypes) > 1:
			print 'warning: method return signatures should have only one element!'

class WyDbusProxy(object):
	def __init__(self, proxy):
		self._proxy = proxy
		self.free = wydbus_free_proxy

	def __call__(self, *args):
		if not self._proxy:
			return None
		else:
			ret = self._proxy(*args)
			if isinstance(ret, type) and issubclass(ret, BaseException):
				raise ret(ret.__error__)
			return ret
		return None

	def __del__(self):
		if self._proxy != None and self.free != None:
			self.free(self._proxy)
		return None



class WyDbusReference(object):
	def __init__(self, parent, name, path, interface):
		self._ref = wydbus_reference2(parent._bus, name, path, interface)
		self._path = path

	def method(self, name, asig, rsig):
		px = _sig2func(rsig, asig)(_wydbus_proxy(self._ref, name, asig, rsig, pointer(pymarshal)))
		return WyDbusProxy(px)



class WyDbusInstance(object):
	def __init__(self, bus, path):
		self._obj = wydbus_instance(bus, path)
		self._handlers = {}
		self._path = path

	def _handler(self, name, asig, rsig, cb, flags, htype):
		ccb = _sig2func(rsig, asig)
		handler_t = type('%s_%s' % (rsig, asig), (Structure,), {})
		handler_t._fields_ = [('name', c_char_p), ('sig', c_char_p * 2), ('fn', ccb), ('data', c_void_p), ('flags', c_int), ('free', CFUNCTYPE(None, c_void_p)), ('m', POINTER(wydbus_marshal_t))]
		h = handler_t()
		h.name = name
		h.sig[0] = asig
		h.sig[1] = rsig
		h.fn = ccb(cb)
		h.flags = flags
		h.data = None
		h.m = pointer(pymarshal)
		wydbus_register_handler(self._obj, byref(h), None, htype)
		self._handlers[name] = h.fn
		return None

	def method(self, name, asig, rsig, cb, flags):
		self._handler(name, asig, rsig, cb, flags | WDB_FREE_ARGS, 0)

	def signal(self, name, asig, cb, flags):
		self._handler(name, asig, '', cb, flags, 1)



class WyDbusSingleton(type):
	def __init__(klass, name, bases, dikt):
		super(WyDbusSingleton, klass).__init__(name, bases, dikt)
		klass._s_instances_ = {}

	def __call__(klass, name='', *args, **args):
		if not klass._s_instances_.has_key(name):
			klass._s_instances_[name] = super(WyDbusSingleton, klass).__call__(name, *args, **kw)
		return klass._s_instances_[name]



class WyDbus(object):
	__metaclass__ = WyDbusSingleton
	def __init__(self, name='', system=True):
		self.free = wydbus_free
		if system:
			type = DBUS_BUS_SYSTEM
		else:
			type = DBUS_BUS_SESSION
		self._bus = wydbus_new(type, name)
		wydbus_run(self._bus)
		if not self._bus:
			raise OSError('unable to get a dbus connection')

	def reference(self, name, path, interface=None):
		return WyDbusReference(self, name, path, interface)

	def instance(self, path):
		return WyDbusInstance(self._bus, path)

	def signal(self, path, name, sig, interface='com.wyplay.XXX_USE_WYDBUS_SIGNAL_PROPERLY'):
		px = _sig2func('', sig)(_wydbus_proxy(self._bus, path, name, sig, pointer(pymarshal), interface))
		return WyDbusProxy(px)

	def __del__(self):
		self.free(self._bus)



WyDBus = WyDbus
