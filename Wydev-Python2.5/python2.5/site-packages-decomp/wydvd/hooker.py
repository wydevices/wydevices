# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 0
n 0(None)[self.obj, self.func, self.name = obj, func, name
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75ca9cc>}
nname: 0
n 0(None)[return self.obj._method_call(self.name, self.func, *args, **kwds)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75cabcc>}
nname: 6
n 6(None)[__doc__ = '\n    Wrapper object for a method to be called.\n    '
def __init__(self, obj, func, name):
	self.obj, self.func, self.name = obj, func, name

def __call__(self, *args, **args):
	return self.obj._method_call(self.name, self.func, *args, **kwds)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75ca56c>}
nname: 0
n 0(None)[self._objname, self._obj = objname, obj
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75caecc>}
nname: 100
n 100(None)[]:
	i: 15(), 75(), 95()
	o: 

nname: 95
n 95(None)[return att
]:
	i: 35(f)
	o: 100()

nname: 75
n 75(None)[return ProxyMethodWrapper(self, att, name)
]:
	i: 35(t)
	o: 100()

nname: 35
n 35(type(att) is types.MethodType)[att = getattr(self._obj, name)
]:
	i: 0(f)
	o: 75(t), 95(f)

nname: 15
n 15(None)[return object.__getattribute__(self, name)
]:
	i: 0(t)
	o: 100()

nname: 0
n 0(name.startswith('_'))[]:
	i: 
	o: 15(t), 35(f)

nname: 0
n 0(None)[if name.startswith('_'):
	return object.__getattribute__(self, name)
else:
	att = getattr(self._obj, name)
	if type(att) is types.MethodType:
		return ProxyMethodWrapper(self, att, name)
	else:
		return att
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75cfb0c>}
nname: 0
n 0(None)[name = '__setitem__'
att = getattr(self._obj, name)
pmeth = ProxyMethodWrapper(self, att, name)
pmeth(key, value)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75cafcc>}
nname: 97
n 97(None)[return '%s.%s(%s)' % (self._objname, name, ', '.join(pargs))
]:
	i: 33(AL), 96()
	o: 

nname: 96
n 96(None)[]:
	i: 42(AF), 55()
	o: 97()

nname: 55
n 55(None)[pargs.append('%s=%s' % (k, pformat(v)))
]:
	i: 42(for)
	o: 96()

nname: 42
n 42(None)[]:
	i: 33(loop)
	o: 55(for), 96(AF)

nname: 33
n 33(None)[del _[1]
for pargs in args:
]:
	i: 0(AF), 14()
	o: 42(loop), 97(AL)

nname: 14
n 14(None)[for x in args:
]:
	i: 0(for)
	o: 33()

nname: 0
n 0(None)[]:
	i: 
	o: 14(for), 33(AF)

nname: 97
n 97(None)[return '%s.%s(%s)' % (self._objname, name, ', '.join(pargs))
]:
	i: 55()
	o: 

nname: 55
n 55(None)[pargs.append('%s=%s' % (k, pformat(v)))
	pass]:
	i: 33(for)
	o: 97()

nname: 33
n 33(None)[del _[1]
for pargs in args:
]:
	i: 0(AF), 14()
	o: 55(for)

nname: 14
n 14(None)[for x in args:
]:
	i: 0(for)
	o: 33()

nname: 0
n 0(None)[]:
	i: 
	o: 14(for), 33(AF)

nname: 97
n 97(None)[return '%s.%s(%s)' % (self._objname, name, ', '.join(pargs))
]:
	i: 33()
	o: 

nname: 33
n 33(None)[del _[1]
for pargs in args:
pargs.append('%s=%s' % (k, pformat(v)))
	pass]:
	i: 0(AF), 14()
	o: 97()

nname: 14
n 14(None)[for x in args:
]:
	i: 0(for)
	o: 33()

nname: 0
n 0(None)[]:
	i: 
	o: 14(for), 33(AF)

nname: 33
n 33(None)[del _[1]
for pargs in args:
pargs.append('%s=%s' % (k, pformat(v)))
	passreturn '%s.%s(%s)' % (self._objname, name, ', '.join(pargs))
]:
	i: 0(AF), 14()
	o: 

nname: 14
n 14(None)[for x in args:
]:
	i: 0(for)
	o: 33()

nname: 0
n 0(None)[]:
	i: 
	o: 14(for), 33(AF)

self.nodes: {0: <unpyclib.structure.node instance at 0xb75cfbec>, 33: <unpyclib.structure.node instance at 0xb75cf2cc>, 14: <unpyclib.structure.node instance at 0xb75cf88c>}
nname: 252
n 252(None)[return rval
]:
	i: 217(), 226()
	o: 

nname: 226
n 226(None)[kwds['rval_intercepted'] = rval
postfunc(name, *args, **kwds)
]:
	i: 188(), 224(AE)
	o: 252()

nname: 224
n 224(None)[]:
	i: 207(f)
	o: 226(AE)

nname: 217
n 217(None)[]:
	i: 207(t)
	o: 252()

nname: 207
n 207(<dummy_ex3> EXC_MATCH AttributeError)[]:
	i: 185(except)
	o: 217(t), 224(f)

nname: 188
n 188(None)[postfunc = getattr(self, '_post')
]:
	i: 185(try)
	o: 226()

nname: 185
n 185(None)[]:
	i: 166(), 175()
	o: 188(try), 207(except)

nname: 175
n 175(None)[postfunc(rval)
]:
	i: 133(), 173(AE)
	o: 185()

nname: 173
n 173(None)[]:
	i: 156(f)
	o: 175(AE)

nname: 166
n 166(None)[]:
	i: 156(t)
	o: 185()

nname: 156
n 156(<dummy_ex3> EXC_MATCH AttributeError)[]:
	i: 115(except)
	o: 166(t), 173(f)

nname: 133
n 133(None)[postfunc = getattr(self, '_post_%s' % name)
]:
	i: 115(try)
	o: 175()

nname: 115
n 115(None)[rval = func(*args, **kwds)
]:
	i: 93(), 102()
	o: 133(try), 156(except)

nname: 102
n 102(None)[prefunc(*args, **kwds)
]:
	i: 60(), 100(AE)
	o: 115()

nname: 100
n 100(None)[]:
	i: 83(f)
	o: 102(AE)

nname: 93
n 93(None)[]:
	i: 83(t)
	o: 115()

nname: 83
n 83(<dummy_ex3> EXC_MATCH AttributeError)[]:
	i: 57(except)
	o: 93(t), 100(f)

nname: 60
n 60(None)[prefunc = getattr(self, '_pre_%s' % name)
]:
	i: 57(try)
	o: 102()

nname: 57
n 57(None)[]:
	i: 32(), 41()
	o: 60(try), 83(except)

nname: 41
n 41(None)[prefunc(name, *args, **kwds)
]:
	i: 3(), 39(AE)
	o: 57()

nname: 39
n 39(None)[]:
	i: 22(f)
	o: 41(AE)

nname: 32
n 32(None)[]:
	i: 22(t)
	o: 57()

nname: 22
n 22(<dummy_ex3> EXC_MATCH AttributeError)[]:
	i: 0(except)
	o: 32(t), 39(f)

nname: 3
n 3(None)[prefunc = getattr(self, '_pre')
]:
	i: 0(try)
	o: 41()

nname: 0
n 0(None)[]:
	i: 
	o: 3(try), 22(except)

nname: 252
n 252(None)[return rval
]:
	i: 226(), 207(f), 207(t)
	o: 

nname: 207
n 207(<dummy_ex3> EXC_MATCH AttributeError)[]:
	i: 185(except)
	o: 252(f)

nname: 226
n 226(None)[kwds['rval_intercepted'] = rval
postfunc(name, *args, **kwds)
]:
	i: 188(), 224(AE)
	o: 252()

nname: 188
n 188(None)[postfunc = getattr(self, '_post')
]:
	i: 185(try)
	o: 226()

nname: 185
n 185(None)[]:
	i: 175(), 156(f), 156(t)
	o: 188(try), 207(except)

structureSingleExcept Exception 'NoneType' object has no attribute 'toNode'
nname: 156
n 156(<dummy_ex3> EXC_MATCH AttributeError)[]:
	i: 115(except)
	o: 185(f)

nname: 175
n 175(None)[postfunc(rval)
]:
	i: 133(), 173(AE)
	o: 185()

nname: 133
n 133(None)[postfunc = getattr(self, '_post_%s' % name)
]:
	i: 115(try)
	o: 175()

nname: 115
n 115(None)[rval = func(*args, **kwds)
]:
	i: 102(), 83(f), 83(t)
	o: 133(try), 156(except)

structureSingleExcept Exception 'NoneType' object has no attribute 'toNode'
nname: 83
n 83(<dummy_ex3> EXC_MATCH AttributeError)[]:
	i: 57(except)
	o: 115(f)

nname: 102
n 102(None)[prefunc(*args, **kwds)
]:
	i: 60(), 100(AE)
	o: 115()

nname: 60
n 60(None)[prefunc = getattr(self, '_pre_%s' % name)
]:
	i: 57(try)
	o: 102()

nname: 57
n 57(None)[]:
	i: 41(), 22(f), 22(t)
	o: 60(try), 83(except)

structureSingleExcept Exception 'NoneType' object has no attribute 'toNode'
nname: 22
n 22(<dummy_ex3> EXC_MATCH AttributeError)[]:
	i: 0(except)
	o: 57(f)

nname: 41
n 41(None)[prefunc(name, *args, **kwds)
]:
	i: 3(), 39(AE)
	o: 57()

nname: 3
n 3(None)[prefunc = getattr(self, '_pre')
]:
	i: 0(try)
	o: 41()

nname: 0
n 0(None)[]:
	i: 
	o: 3(try), 22(except)

structureSingleExcept Exception 'NoneType' object has no attribute 'toNode'
nname: 252
n 252(None)[return rval
]:
	i: 226(), 207(t), 185(except)
	o: 

nname: 226
n 226(None)[kwds['rval_intercepted'] = rval
postfunc(name, *args, **kwds)
]:
	i: 188(), 224(AE)
	o: 252()

nname: 188
n 188(None)[postfunc = getattr(self, '_post')
]:
	i: 185(try)
	o: 226()

nname: 185
n 185(None)[]:
	i: 175(), 156(t), 115(except)
	o: 188(try), 252(except)

nname: 175
n 175(None)[postfunc(rval)
]:
	i: 133(), 173(AE)
	o: 185()

nname: 133
n 133(None)[postfunc = getattr(self, '_post_%s' % name)
]:
	i: 115(try)
	o: 175()

nname: 115
n 115(None)[rval = func(*args, **kwds)
]:
	i: 102(), 83(t), 57(except)
	o: 133(try), 185(except)

nname: 102
n 102(None)[prefunc(*args, **kwds)
]:
	i: 60(), 100(AE)
	o: 115()

nname: 60
n 60(None)[prefunc = getattr(self, '_pre_%s' % name)
]:
	i: 57(try)
	o: 102()

nname: 57
n 57(None)[]:
	i: 41(), 22(t), 0(except)
	o: 60(try), 115(except)

nname: 41
n 41(None)[prefunc(name, *args, **kwds)
]:
	i: 3(), 39(AE)
	o: 57()

nname: 3
n 3(None)[prefunc = getattr(self, '_pre')
]:
	i: 0(try)
	o: 41()

nname: 0
n 0(None)[]:
	i: 
	o: 3(try), 57(except)

nname: 252
n 252(None)[except:
	return rval
]:
	i: 226(), 207(t), 185(except)
	o: 

nname: 226
n 226(None)[kwds['rval_intercepted'] = rval
postfunc(name, *args, **kwds)
]:
	i: 188(), 224(AE)
	o: 252()

nname: 188
n 188(None)[postfunc = getattr(self, '_post')
]:
	i: 185(try)
	o: 226()

nname: 185
n 185(None)[except:
	pass
]:
	i: 175(), 156(t), 115(except)
	o: 188(try), 252(except)

nname: 175
n 175(None)[postfunc(rval)
]:
	i: 133(), 173(AE)
	o: 185()

nname: 133
n 133(None)[postfunc = getattr(self, '_post_%s' % name)
]:
	i: 115(try)
	o: 175()

nname: 115
n 115(None)[except:
	rval = func(*args, **kwds)
]:
	i: 102(), 83(t), 57(except)
	o: 133(try), 185(except)

nname: 102
n 102(None)[prefunc(*args, **kwds)
]:
	i: 60(), 100(AE)
	o: 115()

nname: 60
n 60(None)[prefunc = getattr(self, '_pre_%s' % name)
]:
	i: 57(try)
	o: 102()

nname: 57
n 57(None)[except:
	pass
]:
	i: 41(), 22(t), 0(except)
	o: 60(try), 115(except)

nname: 41
n 41(None)[prefunc(name, *args, **kwds)
]:
	i: 3(), 39(AE)
	o: 57()

nname: 3
n 3(None)[prefunc = getattr(self, '_pre')
]:
	i: 0(try)
	o: 41()

nname: 0
n 0(None)[]:
	i: 
	o: 3(try), 57(except)

self.nodes: {0: <unpyclib.structure.node instance at 0xb75d5ccc>, 3: <unpyclib.structure.node instance at 0xb75d514c>, 133: <unpyclib.structure.node instance at 0xb75d544c>, 39: <unpyclib.structure.node instance at 0xb75d512c>, 41: <unpyclib.structure.node instance at 0xb75d518c>, 173: <unpyclib.structure.node instance at 0xb75d55cc>, 175: <unpyclib.structure.node instance at 0xb75d564c>, 185: <unpyclib.structure.node instance at 0xb75d56cc>, 188: <unpyclib.structure.node instance at 0xb75d574c>, 57: <unpyclib.structure.node instance at 0xb75d51cc>, 224: <unpyclib.structure.node instance at 0xb75d58cc>, 226: <unpyclib.structure.node instance at 0xb75d594c>, 100: <unpyclib.structure.node instance at 0xb75d52cc>, 102: <unpyclib.structure.node instance at 0xb75d534c>, 60: <unpyclib.structure.node instance at 0xb75d504c>, 115: <unpyclib.structure.node instance at 0xb75d53cc>, 252: <unpyclib.structure.node instance at 0xb75d59cc>}
nname: 6
n 6(None)[__doc__ = "\n    Proxy object that delegates methods and attributes that don't start with _.\n    You can derive from this and add appropriate hooks where needed.\n    Override _pre/_post to do something before/afer all method calls.\n    Override _pre_<name>/_post_<name> to hook before/after a specific call.\n    "
def __init__(self, objname, obj):
	self._objname, self._obj = objname, obj

def __getattribute__(self, name):
	if name.startswith('_'):
		return object.__getattribute__(self, name)
	else:
		att = getattr(self._obj, name)
		if type(att) is types.MethodType:
			return ProxyMethodWrapper(self, att, name)
		else:
			return att

def __setitem__(self, key, value):
	name = '__setitem__'
	att = getattr(self._obj, name)
	pmeth = ProxyMethodWrapper(self, att, name)
	pmeth(key, value)

def _call_str(self, name, *args, **args):
	pass

def _method_call(self, name, func, *args, **args):
	pass

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75ca88c>}
nname: 0
n 0(None)[print '       (running foo -> %s)' % bli
return 42
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75d5c0c>}
nname: 6
n 6(None)[def foo(self, bli):
	print '       (running foo -> %s)' % bli
	return 42

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75cff8c>}
nname: 0
n 0(None)[print 'Hello BOB'
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75d58ec>}
nname: 6
n 6(None)[def hello(self, bibi):
	print 'Hello BOB'

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75cf58c>}
nname: 0
n 0(None)[print >> sys.stderr, 'LOG :: %s' % self._call_str(name, *args, **kwds)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75d5fec>}
nname: 0
n 0(None)[print 'after all'
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75d544c>}
nname: 0
n 0(None)[print 'before foo...'
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75d512c>}
nname: 0
n 0(None)[print 'after foo...'
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75d5b6c>}
nname: 6
n 6(None)[__doc__ = 'Proxy for Foo.'
def _pre(self, name, *args, **args):
	print >> sys.stderr, 'LOG :: %s' % self._call_str(name, *args, **kwds)

def _post(self, name, *args, **args):
	print 'after all'

def _pre_foo(self, *args, **args):
	print 'before foo...'

def _post_foo(self, *args, **args):
	print 'after foo...'

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75d51cc>}
nname: 0
n 0(None)[print >> sys.stderr, 'LOG :: %s' % self._call_str(name, *args, **kwds)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75d5c4c>}
nname: 6
n 6(None)[__doc__ = 'Proxy for To'
def _pre(self, name, *args, **args):
	print >> sys.stderr, 'LOG :: %s' % self._call_str(name, *args, **kwds)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75cf4ec>}
nname: 215
n 215(None)[]:
	i: 176(), 206(), 213(AE)
	o: 

nname: 213
n 213(None)[]:
	i: 196(f)
	o: 215(AE)

nname: 206
n 206(None)[]:
	i: 196(t)
	o: 215()

nname: 196
n 196(<dummy_ex3> EXC_MATCH AttributeError)[]:
	i: 0(except)
	o: 206(t), 213(f)

nname: 176
n 176(None)[f.nonexisting()
raise RuntimeError
]:
	i: 0(try)
	o: 215()

nname: 0
n 0(None)[import sys
class Foo():
	def foo(self, bli):
		print '       (running foo -> %s)' % bli
		return 42



class To():
	def hello(self, bibi):
		print 'Hello BOB'



class BabblingFoo(HookProxy):
	__doc__ = 'Proxy for Foo.'
	def _pre(self, name, *args, **args):
		print >> sys.stderr, 'LOG :: %s' % self._call_str(name, *args, **kwds)

	def _post(self, name, *args, **args):
		print 'after all'

	def _pre_foo(self, *args, **args):
		print 'before foo...'

	def _post_foo(self, *args, **args):
		print 'after foo...'



class EtTo(HookProxy):
	__doc__ = 'Proxy for To'
	def _pre(self, name, *args, **args):
		print >> sys.stderr, 'LOG :: %s' % self._call_str(name, *args, **kwds)



f = BabblingFoo('f', Foo())
t = EtTo('t', To())
print 'rval = %s' % f.foo(17)
t.hello(345)
]:
	i: 
	o: 176(try), 196(except)

nname: 196
n 196(None)[except AttributeError:
	pass
]:
	i: 0()
	o: 

nname: 0
n 0(None)[import sys
class Foo():
	def foo(self, bli):
		print '       (running foo -> %s)' % bli
		return 42



class To():
	def hello(self, bibi):
		print 'Hello BOB'



class BabblingFoo(HookProxy):
	__doc__ = 'Proxy for Foo.'
	def _pre(self, name, *args, **args):
		print >> sys.stderr, 'LOG :: %s' % self._call_str(name, *args, **kwds)

	def _post(self, name, *args, **args):
		print 'after all'

	def _pre_foo(self, *args, **args):
		print 'before foo...'

	def _post_foo(self, *args, **args):
		print 'after foo...'



class EtTo(HookProxy):
	__doc__ = 'Proxy for To'
	def _pre(self, name, *args, **args):
		print >> sys.stderr, 'LOG :: %s' % self._call_str(name, *args, **kwds)



f = BabblingFoo('f', Foo())
t = EtTo('t', To())
print 'rval = %s' % f.foo(17)
t.hello(345)
try:
	f.nonexisting()
	raise RuntimeError
]:
	i: 
	o: 196()

nname: 0
n 0(None)[import sys
class Foo():
	def foo(self, bli):
		print '       (running foo -> %s)' % bli
		return 42



class To():
	def hello(self, bibi):
		print 'Hello BOB'



class BabblingFoo(HookProxy):
	__doc__ = 'Proxy for Foo.'
	def _pre(self, name, *args, **args):
		print >> sys.stderr, 'LOG :: %s' % self._call_str(name, *args, **kwds)

	def _post(self, name, *args, **args):
		print 'after all'

	def _pre_foo(self, *args, **args):
		print 'before foo...'

	def _post_foo(self, *args, **args):
		print 'after foo...'



class EtTo(HookProxy):
	__doc__ = 'Proxy for To'
	def _pre(self, name, *args, **args):
		print >> sys.stderr, 'LOG :: %s' % self._call_str(name, *args, **kwds)



f = BabblingFoo('f', Foo())
t = EtTo('t', To())
print 'rval = %s' % f.foo(17)
t.hello(345)
try:
	f.nonexisting()
	raise RuntimeError
except AttributeError:
	pass
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75cadcc>}
nname: 129
n 129(None)[]:
	i: 117(), 128()
	o: 

nname: 128
n 128(None)[]:
	i: 0(f)
	o: 129()

nname: 117
n 117(None)[test()
]:
	i: 0(t)
	o: 129()

nname: 0
n 0(__name__ == '__main__')[__doc__ = '\nProxy objects for any library, that allow you to add hooks before or after\nmethods on a specific object.\n\n'
__version__ = '$Revision$'
__author__ = 'Martin Blais <blais@furius.ca>'
import types
from pprint import pformat
__all__ = ['HookProxy']
class ProxyMethodWrapper():
	__doc__ = '\n    Wrapper object for a method to be called.\n    '
	def __init__(self, obj, func, name):
		self.obj, self.func, self.name = obj, func, name

	def __call__(self, *args, **args):
		return self.obj._method_call(self.name, self.func, *args, **kwds)



class HookProxy(object):
	__doc__ = "\n    Proxy object that delegates methods and attributes that don't start with _.\n    You can derive from this and add appropriate hooks where needed.\n    Override _pre/_post to do something before/afer all method calls.\n    Override _pre_<name>/_post_<name> to hook before/after a specific call.\n    "
	def __init__(self, objname, obj):
		self._objname, self._obj = objname, obj

	def __getattribute__(self, name):
		if name.startswith('_'):
			return object.__getattribute__(self, name)
		else:
			att = getattr(self._obj, name)
			if type(att) is types.MethodType:
				return ProxyMethodWrapper(self, att, name)
			else:
				return att

	def __setitem__(self, key, value):
		name = '__setitem__'
		att = getattr(self._obj, name)
		pmeth = ProxyMethodWrapper(self, att, name)
		pmeth(key, value)

	def _call_str(self, name, *args, **args):
		pass

	def _method_call(self, name, func, *args, **args):
		pass



def test():
	import sys
	class Foo():
		def foo(self, bli):
			print '       (running foo -> %s)' % bli
			return 42



	class To():
		def hello(self, bibi):
			print 'Hello BOB'



	class BabblingFoo(HookProxy):
		__doc__ = 'Proxy for Foo.'
		def _pre(self, name, *args, **args):
			print >> sys.stderr, 'LOG :: %s' % self._call_str(name, *args, **kwds)

		def _post(self, name, *args, **args):
			print 'after all'

		def _pre_foo(self, *args, **args):
			print 'before foo...'

		def _post_foo(self, *args, **args):
			print 'after foo...'



	class EtTo(HookProxy):
		__doc__ = 'Proxy for To'
		def _pre(self, name, *args, **args):
			print >> sys.stderr, 'LOG :: %s' % self._call_str(name, *args, **kwds)



	f = BabblingFoo('f', Foo())
	t = EtTo('t', To())
	print 'rval = %s' % f.foo(17)
	t.hello(345)
	try:
		f.nonexisting()
		raise RuntimeError
	except AttributeError:
		pass

]:
	i: 
	o: 117(t), 128(f)

nname: 0
n 0(None)[__doc__ = '\nProxy objects for any library, that allow you to add hooks before or after\nmethods on a specific object.\n\n'
__version__ = '$Revision$'
__author__ = 'Martin Blais <blais@furius.ca>'
import types
from pprint import pformat
__all__ = ['HookProxy']
class ProxyMethodWrapper():
	__doc__ = '\n    Wrapper object for a method to be called.\n    '
	def __init__(self, obj, func, name):
		self.obj, self.func, self.name = obj, func, name

	def __call__(self, *args, **args):
		return self.obj._method_call(self.name, self.func, *args, **kwds)



class HookProxy(object):
	__doc__ = "\n    Proxy object that delegates methods and attributes that don't start with _.\n    You can derive from this and add appropriate hooks where needed.\n    Override _pre/_post to do something before/afer all method calls.\n    Override _pre_<name>/_post_<name> to hook before/after a specific call.\n    "
	def __init__(self, objname, obj):
		self._objname, self._obj = objname, obj

	def __getattribute__(self, name):
		if name.startswith('_'):
			return object.__getattribute__(self, name)
		else:
			att = getattr(self._obj, name)
			if type(att) is types.MethodType:
				return ProxyMethodWrapper(self, att, name)
			else:
				return att

	def __setitem__(self, key, value):
		name = '__setitem__'
		att = getattr(self._obj, name)
		pmeth = ProxyMethodWrapper(self, att, name)
		pmeth(key, value)

	def _call_str(self, name, *args, **args):
		pass

	def _method_call(self, name, func, *args, **args):
		pass



def test():
	import sys
	class Foo():
		def foo(self, bli):
			print '       (running foo -> %s)' % bli
			return 42



	class To():
		def hello(self, bibi):
			print 'Hello BOB'



	class BabblingFoo(HookProxy):
		__doc__ = 'Proxy for Foo.'
		def _pre(self, name, *args, **args):
			print >> sys.stderr, 'LOG :: %s' % self._call_str(name, *args, **kwds)

		def _post(self, name, *args, **args):
			print 'after all'

		def _pre_foo(self, *args, **args):
			print 'before foo...'

		def _post_foo(self, *args, **args):
			print 'after foo...'



	class EtTo(HookProxy):
		__doc__ = 'Proxy for To'
		def _pre(self, name, *args, **args):
			print >> sys.stderr, 'LOG :: %s' % self._call_str(name, *args, **kwds)



	f = BabblingFoo('f', Foo())
	t = EtTo('t', To())
	print 'rval = %s' % f.foo(17)
	t.hello(345)
	try:
		f.nonexisting()
		raise RuntimeError
	except AttributeError:
		pass

if __name__ == '__main__':
	test()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75c27ec>}
__doc__ = '\nProxy objects for any library, that allow you to add hooks before or after\nmethods on a specific object.\n\n'
__version__ = '$Revision$'
__author__ = 'Martin Blais <blais@furius.ca>'
import types
from pprint import pformat
__all__ = ['HookProxy']
class ProxyMethodWrapper():
	__doc__ = '\n    Wrapper object for a method to be called.\n    '
	def __init__(self, obj, func, name):
		self.obj, self.func, self.name = obj, func, name

	def __call__(self, *args, **args):
		return self.obj._method_call(self.name, self.func, *args, **kwds)



class HookProxy(object):
	__doc__ = "\n    Proxy object that delegates methods and attributes that don't start with _.\n    You can derive from this and add appropriate hooks where needed.\n    Override _pre/_post to do something before/afer all method calls.\n    Override _pre_<name>/_post_<name> to hook before/after a specific call.\n    "
	def __init__(self, objname, obj):
		self._objname, self._obj = objname, obj

	def __getattribute__(self, name):
		if name.startswith('_'):
			return object.__getattribute__(self, name)
		else:
			att = getattr(self._obj, name)
			if type(att) is types.MethodType:
				return ProxyMethodWrapper(self, att, name)
			else:
				return att

	def __setitem__(self, key, value):
		name = '__setitem__'
		att = getattr(self._obj, name)
		pmeth = ProxyMethodWrapper(self, att, name)
		pmeth(key, value)

	def _call_str(self, name, *args, **args):
		pass

	def _method_call(self, name, func, *args, **args):
		pass



def test():
	import sys
	class Foo():
		def foo(self, bli):
			print '       (running foo -> %s)' % bli
			return 42



	class To():
		def hello(self, bibi):
			print 'Hello BOB'



	class BabblingFoo(HookProxy):
		__doc__ = 'Proxy for Foo.'
		def _pre(self, name, *args, **args):
			print >> sys.stderr, 'LOG :: %s' % self._call_str(name, *args, **kwds)

		def _post(self, name, *args, **args):
			print 'after all'

		def _pre_foo(self, *args, **args):
			print 'before foo...'

		def _post_foo(self, *args, **args):
			print 'after foo...'



	class EtTo(HookProxy):
		__doc__ = 'Proxy for To'
		def _pre(self, name, *args, **args):
			print >> sys.stderr, 'LOG :: %s' % self._call_str(name, *args, **kwds)



	f = BabblingFoo('f', Foo())
	t = EtTo('t', To())
	print 'rval = %s' % f.foo(17)
	t.hello(345)
	try:
		f.nonexisting()
		raise RuntimeError
	except AttributeError:
		pass

if __name__ == '__main__':
	test()
