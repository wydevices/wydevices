# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 0
n 0(None)[self.min_available_time = 0
self.max_available_time = 0
self.current_time = 0
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75c4fcc>}
nname: 6
n 6(None)[def __init__(self):
	self.min_available_time = 0
	self.max_available_time = 0
	self.current_time = 0

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75c4a8c>}
nname: 0
n 0(None)[return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75c8eac>}
nname: 139
n 139(None)[]:
	i: 0(AL), 138()
	o: 

nname: 138
n 138(None)[]:
	i: 45(AF), 135()
	o: 139()

nname: 135
n 135(None)[]:
	i: 128(AE)
	o: 138()

nname: 128
n 128(None)[continue
]:
	i: 107(except), 111()
	o: 135(AE)

nname: 111
n 111(None)[callback(*args, **kw)
continue
]:
	i: 107(try)
	o: 128()

nname: 107
n 107(None)[]:
	i: 52(f), 90()
	o: 111(try), 128(except)

nname: 90
n 90(None)[log.error('Player did not change his status, may be because of signal lost')
continue
]:
	i: 52(t)
	o: 107()

nname: 52
n 52(limit < time())[for sig in signals:
self.wyplayer_signals[sig].wait(timeout)
]:
	i: 45(for)
	o: 90(t), 107(f)

nname: 45
n 45(None)[]:
	i: 0(loop)
	o: 52(for), 138(AF)

nname: 0
n 0(None)[log.info('player status : %s waiting for %s' % (self.wyplayer.status, signals))
limit = time() + timeout
]:
	i: 
	o: 45(loop), 139(AL)

nname: 139
n 139(None)[]:
	i: 0(AL), 45(AF), 111(AE)
	o: 

nname: 111
n 111(None)[try:
	callback(*args, **kw)
	continue
except:
	continue
]:
	i: 52(try)
	o: 139(AE)

nname: 52
n 52(None)[for sig in signals:
self.wyplayer_signals[sig].wait(timeout)
if limit < time():
	log.error('Player did not change his status, may be because of signal lost')
	continue
]:
	i: 45(for)
	o: 111(try)

nname: 45
n 45(None)[]:
	i: 0(loop)
	o: 52(for), 139(AF)

nname: 0
n 0(None)[log.info('player status : %s waiting for %s' % (self.wyplayer.status, signals))
limit = time() + timeout
]:
	i: 
	o: 45(loop), 139(AL)

nname: 139
n 139(None)[]:
	i: 0(AL), 45(AF), 52(AE)
	o: 

nname: 52
n 52(None)[for sig in signals:
self.wyplayer_signals[sig].wait(timeout)
if limit < time():
	log.error('Player did not change his status, may be because of signal lost')
	continue
try:
	callback(*args, **kw)
	continue
except:
	continue
]:
	i: 45(for)
	o: 139(AE)

nname: 45
n 45(None)[]:
	i: 0(loop)
	o: 52(for), 139(AF)

nname: 0
n 0(None)[log.info('player status : %s waiting for %s' % (self.wyplayer.status, signals))
limit = time() + timeout
]:
	i: 
	o: 45(loop), 139(AL)

nname: 139
n 139(None)[]:
	i: 52(AE)
	o: 

nname: 52
n 52(None)[for sig in signals:
	self.wyplayer_signals[sig].wait(timeout)
	if limit < time():
		log.error('Player did not change his status, may be because of signal lost')
		continue
	try:
		callback(*args, **kw)
		continue
	except:
		continue
]:
	i: 0(for)
	o: 139(AE)

nname: 0
n 0(None)[log.info('player status : %s waiting for %s' % (self.wyplayer.status, signals))
limit = time() + timeout
]:
	i: 
	o: 52(for)

nname: 139
n 139(None)[]:
	i: 0(AE)
	o: 

nname: 0
n 0(None)[log.info('player status : %s waiting for %s' % (self.wyplayer.status, signals))
limit = time() + timeout
for sig in signals:
	self.wyplayer_signals[sig].wait(timeout)
	if limit < time():
		log.error('Player did not change his status, may be because of signal lost')
		continue
	try:
		callback(*args, **kw)
		continue
	except:
		continue
]:
	i: 
	o: 139(AE)

self.nodes: {0: <unpyclib.structure.node instance at 0xb75cd76c>, 139: <unpyclib.structure.node instance at 0xb75cdb8c>}
nname: 0
n 0(None)[self.wyplayer = wyplayer
self.live = None
self.on_pause = False
self._first_pass = True
self._ExternalRenderer__renderer_time_info = RendererTimeInfo()
self.action = None
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75cd36c>}
nname: 192
n 192(None)[]:
	i: 187(), 191()
	o: 

nname: 191
n 191(None)[]:
	i: 159&171(f)
	o: 192()

nname: 187
n 187(None)[]:
	i: 159&171(t)
	o: 192()

nname: 159&171
n 159&171(status == 'loading' and self.action == 'play')[]:
	i: 98(), 158()
	o: 187(t), 191(f)

nname: 158
n 158(None)[]:
	i: 86(f)
	o: 159&171()

nname: 98
n 98(None)[self._select_lang()
Callbacks().start_playing.notify(self, self.live, recording=self.play_options.get('recording', False))
]:
	i: 86(t)
	o: 159&171()

nname: 86
n 86(status == 'playing')[]:
	i: 0(AL), 85()
	o: 98(t), 158(f)

nname: 85
n 85(None)[]:
	i: 20(AF), 71()
	o: 86()

nname: 71
n 71(None)[e_sig.clear()
]:
	i: 36(f), 57()
	o: 85()

nname: 57
n 57(None)[e_sig.set()
continue
]:
	i: 36(t)
	o: 71()

nname: 36
n 36(e_name == status)[for e_name, e_sig in self.wyplayer_signals.iteritems():
]:
	i: 20(for)
	o: 57(t), 71(f)

nname: 20
n 20(None)[]:
	i: 0(loop)
	o: 36(for), 85(AF)

nname: 0
n 0(None)[log.info('New player status : %s' % status)
]:
	i: 
	o: 20(loop), 86(AL)

nname: 192
n 192(None)[]:
	i: 86()
	o: 

nname: 86
n 86(None)[if status == 'playing':
	self._select_lang()
	Callbacks().start_playing.notify(self, self.live, recording=self.play_options.get('recording', False))
if status == 'loading' and self.action == 'play':
	pass
]:
	i: 0(AL), 20(AF), 36()
	o: 192()

nname: 36
n 36(None)[for e_name, e_sig in self.wyplayer_signals.iteritems():
if e_name == status:
	e_sig.set()
	continue
e_sig.clear()
]:
	i: 20(for)
	o: 86()

nname: 20
n 20(None)[]:
	i: 0(loop)
	o: 36(for), 86(AF)

nname: 0
n 0(None)[log.info('New player status : %s' % status)
]:
	i: 
	o: 20(loop), 86(AL)

nname: 192
n 192(None)[]:
	i: 36()
	o: 

nname: 36
n 36(None)[for e_name, e_sig in self.wyplayer_signals.iteritems():
	if e_name == status:
		e_sig.set()
		continue
	e_sig.clear()
if status == 'playing':
	self._select_lang()
	Callbacks().start_playing.notify(self, self.live, recording=self.play_options.get('recording', False))
if status == 'loading' and self.action == 'play':
	pass
]:
	i: 0(for)
	o: 192()

nname: 0
n 0(None)[log.info('New player status : %s' % status)
]:
	i: 
	o: 36(for)

nname: 192
n 192(None)[]:
	i: 0()
	o: 

nname: 0
n 0(None)[log.info('New player status : %s' % status)
for e_name, e_sig in self.wyplayer_signals.iteritems():
	if e_name == status:
		e_sig.set()
		continue
	e_sig.clear()
if status == 'playing':
	self._select_lang()
	Callbacks().start_playing.notify(self, self.live, recording=self.play_options.get('recording', False))
if status == 'loading' and self.action == 'play':
	pass
]:
	i: 
	o: 192()

nname: 0
n 0(None)[log.info('New player status : %s' % status)
for e_name, e_sig in self.wyplayer_signals.iteritems():
	if e_name == status:
		e_sig.set()
		continue
	e_sig.clear()
if status == 'playing':
	self._select_lang()
	Callbacks().start_playing.notify(self, self.live, recording=self.play_options.get('recording', False))
if status == 'loading' and self.action == 'play':
	pass
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75cd70c>}
nname: 74
n 74(None)[return None
]:
	i: 0(AL), 73()
	o: 

nname: 73
n 73(None)[]:
	i: 3(AF), 69()
	o: 74()

nname: 69
n 69(None)[]:
	i: 19(f), 46()
	o: 73()

nname: 46
n 46(None)[setattr(self.wyplayer, opt, val)
continue
]:
	i: 19(t)
	o: 69()

nname: 19
n 19(val)[for opt in ['aspect_ratio', 'spdif_surround', 'display_format']:
val = kw.get(opt, None)
]:
	i: 3(for)
	o: 46(t), 69(f)

nname: 3
n 3(None)[]:
	i: 0(loop)
	o: 19(for), 73(AF)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 74(AL)

nname: 74
n 74(None)[return None
]:
	i: 0(AL), 3(AF), 19()
	o: 

nname: 19
n 19(None)[for opt in ['aspect_ratio', 'spdif_surround', 'display_format']:
val = kw.get(opt, None)
if val:
	setattr(self.wyplayer, opt, val)
	continue
]:
	i: 3(for)
	o: 74()

nname: 3
n 3(None)[]:
	i: 0(loop)
	o: 19(for), 74(AF)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 74(AL)

nname: 19
n 19(None)[for opt in ['aspect_ratio', 'spdif_surround', 'display_format']:
	val = kw.get(opt, None)
	if val:
		setattr(self.wyplayer, opt, val)
		continue
return None
]:
	i: 0(for)
	o: 

nname: 0
n 0(None)[]:
	i: 
	o: 19(for)

nname: 0
n 0(None)[for opt in ['aspect_ratio', 'spdif_surround', 'display_format']:
	val = kw.get(opt, None)
	if val:
		setattr(self.wyplayer, opt, val)
		continue
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb755f0cc>}
nname: 530
n 530(None)[self._first_pass = False
]:
	i: 177(), 386()
	o: 

nname: 386
n 386(None)[to_play = os.path.basename(recorder.dbuspath)
dvb_service_id = live.serviceid & 65535
service_option = 'service=' + str(dvb_service_id)
log.debug('call play_rec on ' + to_play + ' opts = ' + service_option)
timestep('renderer_play_init')
opts = ('wyts=1', 'probe=0', 'norm_speed=1', 'live=1', service_option)
self.wyplayer.load(to_play, scheme='rec', properties=opts)
self.play_loaded()
]:
	i: 306(), 385()
	o: 530()

nname: 385
n 385(None)[]:
	i: 287(f)
	o: 386()

nname: 306
n 306(None)[self.wyplayer.watch_property('status', self.status_change_callback)
self.wyplayer.open()
def load_options():
	for opt in ['aspect_ratio', 'spdif_surround', 'display_format']:
		val = kw.get(opt, None)
		if val:
			setattr(self.wyplayer, opt, val)
			continue
	return None

self.wait_for_status(['idle'], callback=load_options)
]:
	i: 287(t)
	o: 386()

nname: 287
n 287(self.wyplayer.status == 'closed')[]:
	i: 171(t)
	o: 306(t), 385(f)

nname: 177
n 177(None)[log.error('trying to play a live that have not external recorder')
self.wyplayer.load_uri(live.source_uri, properties={'wyts': '1', 'probe': '0', 'norm_speed': '1', 'live': '1', 'service': str(live.serviceid & 65535)})
self.play_loaded()
]:
	i: 171(f)
	o: 530()

nname: 171
n 171(recorder)[]:
	i: 99(JA), 135(JA), 167(), 170()
	o: 177(f), 287(t)

nname: 170
n 170(None)[]:
	i: 54&63(f)
	o: 171()

nname: 167
n 167(None)[]:
	i: 165(AE)
	o: 171()

nname: 165
n 165(None)[]:
	i: 125(f)
	o: 167(AE)

nname: 135
n 135(None)[log.info('Player reinitialized : status %s , TV should work again' % self.wyplayer.status)
]:
	i: 125(t)
	o: 171(JA)

nname: 125
n 125(<dummy_ex3> EXC_MATCH OverflowError)[]:
	i: 82(except)
	o: 135(t), 165(f)

nname: 99
n 99(None)[self.wait_for_status(['closed'], timeout=1)
]:
	i: 82(try)
	o: 171(JA)

nname: 82
n 82(None)[self.wyplayer.close()
]:
	i: 54&63(t)
	o: 99(try), 125(except)

nname: 54&63
n 54&63(self._first_pass and self.wyplayer.status != 'closed')[]:
	i: 45(), 53()
	o: 82(t), 170(f)

nname: 53
n 53(None)[]:
	i: 0(t)
	o: 54&63()

nname: 45
n 45(None)[]:
	i: 0(f)
	o: 54&63()

nname: 0
n 0(self.wyplayer)[self.action = 'play'
self.live = live
recorder = live.external_recorder
self.play_options = kw
]:
	i: 
	o: 45(f), 53(t)

nname: 530
n 530(None)[self._first_pass = False
]:
	i: 177(), 287()
	o: 

nname: 287
n 287(None)[if self.wyplayer.status == 'closed':
	self.wyplayer.watch_property('status', self.status_change_callback)
	self.wyplayer.open()
	def load_options():
		for opt in ['aspect_ratio', 'spdif_surround', 'display_format']:
			val = kw.get(opt, None)
			if val:
				setattr(self.wyplayer, opt, val)
				continue
		return None

	self.wait_for_status(['idle'], callback=load_options)
to_play = os.path.basename(recorder.dbuspath)
dvb_service_id = live.serviceid & 65535
service_option = 'service=' + str(dvb_service_id)
log.debug('call play_rec on ' + to_play + ' opts = ' + service_option)
timestep('renderer_play_init')
opts = ('wyts=1', 'probe=0', 'norm_speed=1', 'live=1', service_option)
self.wyplayer.load(to_play, scheme='rec', properties=opts)
self.play_loaded()
]:
	i: 171(t)
	o: 530()

nname: 177
n 177(None)[log.error('trying to play a live that have not external recorder')
self.wyplayer.load_uri(live.source_uri, properties={'wyts': '1', 'probe': '0', 'norm_speed': '1', 'live': '1', 'service': str(live.serviceid & 65535)})
self.play_loaded()
]:
	i: 171(f)
	o: 530()

nname: 171
n 171(recorder)[]:
	i: 99(JA), 135(JA), 125(f), 165(AE), 0(f)
	o: 177(f), 287(t)

nname: 135
n 135(None)[log.info('Player reinitialized : status %s , TV should work again' % self.wyplayer.status)
]:
	i: 125(t)
	o: 171(JA)

nname: 125
n 125(<dummy_ex3> EXC_MATCH OverflowError)[]:
	i: 82(except)
	o: 135(t), 171(f)

nname: 99
n 99(None)[self.wait_for_status(['closed'], timeout=1)
]:
	i: 82(try)
	o: 171(JA)

nname: 82
n 82(None)[self.wyplayer.close()
]:
	i: 0(t)
	o: 99(try), 125(except)

nname: 0
n 0(self._first_pass and self.wyplayer.status != 'closed')[self.action = 'play'
self.live = live
recorder = live.external_recorder
self.play_options = kw
if not self.wyplayer:
	pass
]:
	i: 
	o: 82(t), 171(f)

nname: 171
n 171(None)[if not recorder:
	log.error('trying to play a live that have not external recorder')
	self.wyplayer.load_uri(live.source_uri, properties={'wyts': '1', 'probe': '0', 'norm_speed': '1', 'live': '1', 'service': str(live.serviceid & 65535)})
	self.play_loaded()
else:
	if self.wyplayer.status == 'closed':
		self.wyplayer.watch_property('status', self.status_change_callback)
		self.wyplayer.open()
		def load_options():
			for opt in ['aspect_ratio', 'spdif_surround', 'display_format']:
				val = kw.get(opt, None)
				if val:
					setattr(self.wyplayer, opt, val)
					continue
			return None

		self.wait_for_status(['idle'], callback=load_options)
	to_play = os.path.basename(recorder.dbuspath)
	dvb_service_id = live.serviceid & 65535
	service_option = 'service=' + str(dvb_service_id)
	log.debug('call play_rec on ' + to_play + ' opts = ' + service_option)
	timestep('renderer_play_init')
	opts = ('wyts=1', 'probe=0', 'norm_speed=1', 'live=1', service_option)
	self.wyplayer.load(to_play, scheme='rec', properties=opts)
	self.play_loaded()
self._first_pass = False
]:
	i: 125(f), 0(f)
	o: 

nname: 125
n 125(None)[except OverflowError:
	log.info('Player reinitialized : status %s , TV should work again' % self.wyplayer.status)
]:
	i: 82()
	o: 171(JA)

nname: 82
n 82(None)[self.wyplayer.close()
try:
	self.wait_for_status(['closed'], timeout=1)
]:
	i: 0(t)
	o: 125()

nname: 0
n 0(self._first_pass and self.wyplayer.status != 'closed')[self.action = 'play'
self.live = live
recorder = live.external_recorder
self.play_options = kw
if not self.wyplayer:
	pass
]:
	i: 
	o: 82(t), 171(f)

nname: 171
n 171(None)[if not recorder:
	log.error('trying to play a live that have not external recorder')
	self.wyplayer.load_uri(live.source_uri, properties={'wyts': '1', 'probe': '0', 'norm_speed': '1', 'live': '1', 'service': str(live.serviceid & 65535)})
	self.play_loaded()
else:
	if self.wyplayer.status == 'closed':
		self.wyplayer.watch_property('status', self.status_change_callback)
		self.wyplayer.open()
		def load_options():
			for opt in ['aspect_ratio', 'spdif_surround', 'display_format']:
				val = kw.get(opt, None)
				if val:
					setattr(self.wyplayer, opt, val)
					continue
			return None

		self.wait_for_status(['idle'], callback=load_options)
	to_play = os.path.basename(recorder.dbuspath)
	dvb_service_id = live.serviceid & 65535
	service_option = 'service=' + str(dvb_service_id)
	log.debug('call play_rec on ' + to_play + ' opts = ' + service_option)
	timestep('renderer_play_init')
	opts = ('wyts=1', 'probe=0', 'norm_speed=1', 'live=1', service_option)
	self.wyplayer.load(to_play, scheme='rec', properties=opts)
	self.play_loaded()
self._first_pass = False
]:
	i: 82(f), 0(f)
	o: 

nname: 82
n 82(None)[self.wyplayer.close()
try:
	self.wait_for_status(['closed'], timeout=1)
except OverflowError:
	log.info('Player reinitialized : status %s , TV should work again' % self.wyplayer.status)
]:
	i: 0(t)
	o: 171(JA)

nname: 0
n 0(self._first_pass and self.wyplayer.status != 'closed')[self.action = 'play'
self.live = live
recorder = live.external_recorder
self.play_options = kw
if not self.wyplayer:
	pass
]:
	i: 
	o: 82(t), 171(f)

nname: 0
n 0(None)[self.action = 'play'
self.live = live
recorder = live.external_recorder
self.play_options = kw
if not self.wyplayer:
	pass
if self._first_pass and self.wyplayer.status != 'closed':
	self.wyplayer.close()
	try:
		self.wait_for_status(['closed'], timeout=1)
	except OverflowError:
		log.info('Player reinitialized : status %s , TV should work again' % self.wyplayer.status)
if not recorder:
	log.error('trying to play a live that have not external recorder')
	self.wyplayer.load_uri(live.source_uri, properties={'wyts': '1', 'probe': '0', 'norm_speed': '1', 'live': '1', 'service': str(live.serviceid & 65535)})
	self.play_loaded()
else:
	if self.wyplayer.status == 'closed':
		self.wyplayer.watch_property('status', self.status_change_callback)
		self.wyplayer.open()
		def load_options():
			for opt in ['aspect_ratio', 'spdif_surround', 'display_format']:
				val = kw.get(opt, None)
				if val:
					setattr(self.wyplayer, opt, val)
					continue
			return None

		self.wait_for_status(['idle'], callback=load_options)
	to_play = os.path.basename(recorder.dbuspath)
	dvb_service_id = live.serviceid & 65535
	service_option = 'service=' + str(dvb_service_id)
	log.debug('call play_rec on ' + to_play + ' opts = ' + service_option)
	timestep('renderer_play_init')
	opts = ('wyts=1', 'probe=0', 'norm_speed=1', 'live=1', service_option)
	self.wyplayer.load(to_play, scheme='rec', properties=opts)
	self.play_loaded()
self._first_pass = False
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75cd62c>}
nname: 93
n 93(None)[]:
	i: 24(AL), 88(), 92()
	o: 

nname: 92
n 92(None)[]:
	i: 0(f)
	o: 93()

nname: 88
n 88(None)[]:
	i: 28(AF), 84()
	o: 93()

nname: 84
n 84(None)[]:
	i: 44(f), 63()
	o: 88()

nname: 63
n 63(None)[self.wyplayer.aid = asub['id']
break
continue
]:
	i: 44(t)
	o: 84()

nname: 44
n 44(asub['lang'] == lang)[for asub in self.wyplayer.alist():
]:
	i: 28(for)
	o: 63(t), 84(f)

nname: 28
n 28(None)[]:
	i: 24(loop)
	o: 44(for), 88(AF)

nname: 24
n 24(None)[]:
	i: 0(t)
	o: 28(loop), 93(AL)

nname: 0
n 0(lang)[lang = self.play_options.get('lang')
]:
	i: 
	o: 24(t), 92(f)

nname: 93
n 93(None)[]:
	i: 24(AL), 28(AF), 44(), 0(f)
	o: 

nname: 44
n 44(None)[for asub in self.wyplayer.alist():
if asub['lang'] == lang:
	self.wyplayer.aid = asub['id']
	break
	continue
]:
	i: 28(for)
	o: 93()

nname: 28
n 28(None)[]:
	i: 24(loop)
	o: 44(for), 93(AF)

nname: 24
n 24(None)[]:
	i: 0(t)
	o: 28(loop), 93(AL)

nname: 0
n 0(lang)[lang = self.play_options.get('lang')
]:
	i: 
	o: 24(t), 93(f)

nname: 93
n 93(None)[]:
	i: 44(), 0(f)
	o: 

nname: 44
n 44(None)[for asub in self.wyplayer.alist():
	if asub['lang'] == lang:
		self.wyplayer.aid = asub['id']
		break
		continue
]:
	i: 24(for)
	o: 93()

nname: 24
n 24(None)[]:
	i: 0(t)
	o: 44(for)

nname: 0
n 0(lang)[lang = self.play_options.get('lang')
]:
	i: 
	o: 24(t), 93(f)

nname: 93
n 93(None)[]:
	i: 24(), 0(f)
	o: 

nname: 24
n 24(None)[for asub in self.wyplayer.alist():
	if asub['lang'] == lang:
		self.wyplayer.aid = asub['id']
		break
		continue
]:
	i: 0(t)
	o: 93()

nname: 0
n 0(lang)[lang = self.play_options.get('lang')
]:
	i: 
	o: 24(t), 93(f)

nname: 0
n 0(None)[lang = self.play_options.get('lang')
if lang:
	for asub in self.wyplayer.alist():
		if asub['lang'] == lang:
			self.wyplayer.aid = asub['id']
			break
			continue
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb755172c>}
nname: 228
n 228(None)[timestep('callback_time')
return None
]:
	i: 45(), 182(), 227()
	o: 

nname: 227
n 227(None)[]:
	i: 104(f)
	o: 228()

nname: 182
n 182(None)[self.live.external_dvb_manager.startExternEIT(config.wyplayer_extern_eit_path, self.live.wyscan_recording_id)
timestep('renderer_play_extern_eit_time')
]:
	i: 104(t)
	o: 228()

nname: 104
n 104(self.play_options.get('start_extern_eit', False))[self.wyplayer.play_loaded(start_pos=float(pos), bytes=True)
self.live.saveReadOffset(0)
timestep('wyplayer: play')
]:
	i: 81(), 103()
	o: 182(t), 227(f)

nname: 103
n 103(None)[]:
	i: 62(f)
	o: 104()

nname: 81
n 81(None)[pos = self.live.chunk_info.getReadOffset()
]:
	i: 62(t)
	o: 104()

nname: 62
n 62(self.live.chunk_info)[pos = 0.0
]:
	i: 39(t)
	o: 81(t), 103(f)

nname: 45
n 45(None)[self.wyplayer.play_loaded()
]:
	i: 39(f)
	o: 228()

nname: 39
n 39(recorder)[]:
	i: 30(), 38()
	o: 45(f), 62(t)

nname: 38
n 38(None)[]:
	i: 0(t)
	o: 39()

nname: 30
n 30(None)[return None
]:
	i: 0(f)
	o: 39()

nname: 0
n 0(self.wyplayer)[self.action = None
recorder = self.live.external_recorder
]:
	i: 
	o: 30(f), 38(t)

nname: 228
n 228(None)[timestep('callback_time')
return None
]:
	i: 45(), 62()
	o: 

nname: 62
n 62(None)[pos = 0.0
if self.live.chunk_info:
	pos = self.live.chunk_info.getReadOffset()
self.wyplayer.play_loaded(start_pos=float(pos), bytes=True)
self.live.saveReadOffset(0)
timestep('wyplayer: play')
if self.play_options.get('start_extern_eit', False):
	self.live.external_dvb_manager.startExternEIT(config.wyplayer_extern_eit_path, self.live.wyscan_recording_id)
	timestep('renderer_play_extern_eit_time')
]:
	i: 0(t)
	o: 228()

nname: 45
n 45(None)[self.wyplayer.play_loaded()
]:
	i: 0(f)
	o: 228()

nname: 0
n 0(recorder)[self.action = None
recorder = self.live.external_recorder
if not self.wyplayer:
	return None
]:
	i: 
	o: 45(f), 62(t)

nname: 0
n 0(None)[self.action = None
recorder = self.live.external_recorder
if not self.wyplayer:
	return None
if not recorder:
	self.wyplayer.play_loaded()
else:
	pos = 0.0
	if self.live.chunk_info:
		pos = self.live.chunk_info.getReadOffset()
	self.wyplayer.play_loaded(start_pos=float(pos), bytes=True)
	self.live.saveReadOffset(0)
	timestep('wyplayer: play')
	if self.play_options.get('start_extern_eit', False):
		self.live.external_dvb_manager.startExternEIT(config.wyplayer_extern_eit_path, self.live.wyscan_recording_id)
		timestep('renderer_play_extern_eit_time')
timestep('callback_time')
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75cd26c>}
nname: 84
n 84(None)[return None
]:
	i: 56(), 83()
	o: 

nname: 83
n 83(None)[]:
	i: 0&37(f)
	o: 84()

nname: 56
n 56(None)[self.wyplayer.stop()
timestep('wyplayer: stop')
]:
	i: 0&37(t)
	o: 84()

nname: 0&37
n 0&37(self.wyplayer and self.wyplayer.status not in ('idle', 'closed'))[self.action = None
self.live = None
timestep('renderer_stop_init')
]:
	i: 
	o: 56(t), 83(f)

nname: 0&37
n 0&37(None)[self.action = None
self.live = None
timestep('renderer_stop_init')
if self.wyplayer and self.wyplayer.status not in ('idle', 'closed'):
	self.wyplayer.stop()
	timestep('wyplayer: stop')
return None
]:
	i: 
	o: 

self.nodes: {'0&37': <unpyclib.structure.node instance at 0xb75cddac>}
nname: 102
n 102(None)[return None
]:
	i: 79(), 101()
	o: 

nname: 101
n 101(None)[]:
	i: 0&9(f)
	o: 102()

nname: 79
n 79(None)[self.wyplayer.watch_property('status', None)
]:
	i: 58(), 78()
	o: 102()

nname: 78
n 78(None)[]:
	i: 28(f)
	o: 79()

nname: 58
n 58(None)[self.wait_for_status(['closed'])
]:
	i: 28(t)
	o: 79()

nname: 28
n 28(wait_player_closed)[timestep('wyplayer: close')
self.wyplayer.close()
]:
	i: 0&9(t)
	o: 58(t), 78(f)

nname: 0&9
n 0&9(self.wyplayer and self.wyplayer.status != 'closed')[]:
	i: 
	o: 28(t), 101(f)

nname: 102
n 102(None)[return None
]:
	i: 28(), 0&9(f)
	o: 

nname: 28
n 28(None)[timestep('wyplayer: close')
self.wyplayer.close()
if wait_player_closed:
	self.wait_for_status(['closed'])
self.wyplayer.watch_property('status', None)
]:
	i: 0&9(t)
	o: 102()

nname: 0&9
n 0&9(self.wyplayer and self.wyplayer.status != 'closed')[]:
	i: 
	o: 28(t), 102(f)

nname: 0&9
n 0&9(None)[if self.wyplayer and self.wyplayer.status != 'closed':
	timestep('wyplayer: close')
	self.wyplayer.close()
	if wait_player_closed:
		self.wait_for_status(['closed'])
	self.wyplayer.watch_property('status', None)
return None
]:
	i: 
	o: 

self.nodes: {'0&9': <unpyclib.structure.node instance at 0xb75cd7cc>}
nname: 0
n 0(None)[log.debug('external renderer called: isPlaying')
return self.wyplayer.status == 'playing'
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75c8fcc>}
nname: 0
n 0(None)[return self.live
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75c8eec>}
nname: 144
n 144(None)[return self._ExternalRenderer__renderer_time_info
]:
	i: 3(), 88(), 143(AE)
	o: 

nname: 88
n 88(None)[self._ExternalRenderer__renderer_time_info.current_time = 0
self._ExternalRenderer__renderer_time_info.max_available_time = 0
self._ExternalRenderer__renderer_time_info.min_available_time = 0
log.debug('failed to read chunkingo')
]:
	i: 0(except)
	o: 144()

nname: 3
n 3(None)[self._ExternalRenderer__renderer_time_info.current_time = self.live.chunk_info.getTimeFromOffset(self.bytesPos())
self._ExternalRenderer__renderer_time_info.min_available_time = self.live.chunk_info.getMinimumTimeshiftTime()
self._ExternalRenderer__renderer_time_info.max_available_time = self.live.chunk_info.getMaximumTimeshiftTime()
]:
	i: 0(try)
	o: 144()

nname: 0
n 0(None)[]:
	i: 
	o: 3(try), 88(except)

nname: 88
n 88(None)[except:
	self._ExternalRenderer__renderer_time_info.current_time = 0
	self._ExternalRenderer__renderer_time_info.max_available_time = 0
	self._ExternalRenderer__renderer_time_info.min_available_time = 0
	log.debug('failed to read chunkingo')
return self._ExternalRenderer__renderer_time_info
]:
	i: 0()
	o: 

nname: 0
n 0(None)[try:
	self._ExternalRenderer__renderer_time_info.current_time = self.live.chunk_info.getTimeFromOffset(self.bytesPos())
	self._ExternalRenderer__renderer_time_info.min_available_time = self.live.chunk_info.getMinimumTimeshiftTime()
	self._ExternalRenderer__renderer_time_info.max_available_time = self.live.chunk_info.getMaximumTimeshiftTime()
]:
	i: 
	o: 88()

nname: 0
n 0(None)[try:
	self._ExternalRenderer__renderer_time_info.current_time = self.live.chunk_info.getTimeFromOffset(self.bytesPos())
	self._ExternalRenderer__renderer_time_info.min_available_time = self.live.chunk_info.getMinimumTimeshiftTime()
	self._ExternalRenderer__renderer_time_info.max_available_time = self.live.chunk_info.getMaximumTimeshiftTime()
except:
	self._ExternalRenderer__renderer_time_info.current_time = 0
	self._ExternalRenderer__renderer_time_info.max_available_time = 0
	self._ExternalRenderer__renderer_time_info.min_available_time = 0
	log.debug('failed to read chunkingo')
return self._ExternalRenderer__renderer_time_info
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75cd20c>}
nname: 69
n 69(None)[]:
	i: 40(JA), 64(), 68()
	o: 

nname: 68
n 68(None)[]:
	i: 0(f)
	o: 69()

nname: 64
n 64(None)[]:
	i: 18(f)
	o: 69()

nname: 40
n 40(None)[self.live.saveReadOffset(pos['video'])
]:
	i: 18(t)
	o: 69(JA)

nname: 18
n 18(self.live)[pos = self.wyplayer.byte_pos
]:
	i: 0(t)
	o: 40(t), 64(f)

nname: 0
n 0(self.wyplayer)[self.on_pause = True
]:
	i: 
	o: 18(t), 68(f)

nname: 0
n 0(None)[self.on_pause = True
if self.wyplayer:
	pos = self.wyplayer.byte_pos
	if self.live:
		self.live.saveReadOffset(pos['video'])
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75cddac>}
nname: 39
n 39(None)[]:
	i: 18(), 38()
	o: 

nname: 38
n 38(None)[]:
	i: 0(f)
	o: 39()

nname: 18
n 18(None)[self.live.saveReadOffset(0)
]:
	i: 0(t)
	o: 39()

nname: 0
n 0(self.live)[self.on_pause = False
]:
	i: 
	o: 18(t), 38(f)

nname: 0
n 0(None)[self.on_pause = False
if self.live:
	self.live.saveReadOffset(0)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75c4bcc>}
nname: 77
n 77(None)[return ret
]:
	i: 62(JA), 72(), 76()
	o: 

nname: 76
n 76(None)[]:
	i: 0(f)
	o: 77()

nname: 72
n 72(None)[]:
	i: 18(f)
	o: 77()

nname: 62
n 62(None)[ret = False
]:
	i: 18(t)
	o: 77(JA)

nname: 18
n 18(abs(time_info.max_available_time - time_info.current_time) >= config.delta_time_for_playing)[time_info = self.getTimeInfo()
]:
	i: 0(t)
	o: 62(t), 72(f)

nname: 0
n 0(self.isPlaying())[ret = True
]:
	i: 
	o: 18(t), 76(f)

nname: 0
n 0(None)[ret = True
if self.isPlaying():
	time_info = self.getTimeInfo()
	if abs(time_info.max_available_time - time_info.current_time) >= config.delta_time_for_playing:
		ret = False
return ret
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75cd82c>}
nname: 49
n 49(None)[return bytes_pos
]:
	i: 15(), 48()
	o: 

nname: 48
n 48(None)[]:
	i: 0(f)
	o: 49()

nname: 15
n 15(None)[log.info("wyplayer.byte_pos['audio']")
bytes_pos = self.wyplayer.byte_pos['audio']
]:
	i: 0(t)
	o: 49()

nname: 0
n 0(self.wyplayer)[bytes_pos = 0
]:
	i: 
	o: 15(t), 48(f)

nname: 0
n 0(None)[bytes_pos = 0
if self.wyplayer:
	log.info("wyplayer.byte_pos['audio']")
	bytes_pos = self.wyplayer.byte_pos['audio']
return bytes_pos
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75c4e0c>}
nname: 6
n 6(None)[wyplayer_signals = dict(closed=Event(), idle=Event(), playing=Event(), loading=Event())
def wait_for_status(self, signals, timeout=4, callback=(lambda *args, **args: None), *args, **args):
	log.info('player status : %s waiting for %s' % (self.wyplayer.status, signals))
	limit = time() + timeout
	for sig in signals:
		self.wyplayer_signals[sig].wait(timeout)
		if limit < time():
			log.error('Player did not change his status, may be because of signal lost')
			continue
		try:
			callback(*args, **kw)
			continue
		except:
			continue

def __init__(self, wyplayer):
	self.wyplayer = wyplayer
	self.live = None
	self.on_pause = False
	self._first_pass = True
	self._ExternalRenderer__renderer_time_info = RendererTimeInfo()
	self.action = None
	return None

def status_change_callback(self, status):
	log.info('New player status : %s' % status)
	for e_name, e_sig in self.wyplayer_signals.iteritems():
		if e_name == status:
			e_sig.set()
			continue
		e_sig.clear()
	if status == 'playing':
		self._select_lang()
		Callbacks().start_playing.notify(self, self.live, recording=self.play_options.get('recording', False))
	if status == 'loading' and self.action == 'play':
		pass

def play(self, live, **kw):
	self.action = 'play'
	self.live = live
	recorder = live.external_recorder
	self.play_options = kw
	if not self.wyplayer:
		pass
	if self._first_pass and self.wyplayer.status != 'closed':
		self.wyplayer.close()
		try:
			self.wait_for_status(['closed'], timeout=1)
		except OverflowError:
			log.info('Player reinitialized : status %s , TV should work again' % self.wyplayer.status)
	if not recorder:
		log.error('trying to play a live that have not external recorder')
		self.wyplayer.load_uri(live.source_uri, properties={'wyts': '1', 'probe': '0', 'norm_speed': '1', 'live': '1', 'service': str(live.serviceid & 65535)})
		self.play_loaded()
	else:
		if self.wyplayer.status == 'closed':
			self.wyplayer.watch_property('status', self.status_change_callback)
			self.wyplayer.open()
			def load_options():
				for opt in ['aspect_ratio', 'spdif_surround', 'display_format']:
					val = kw.get(opt, None)
					if val:
						setattr(self.wyplayer, opt, val)
						continue
				return None

			self.wait_for_status(['idle'], callback=load_options)
		to_play = os.path.basename(recorder.dbuspath)
		dvb_service_id = live.serviceid & 65535
		service_option = 'service=' + str(dvb_service_id)
		log.debug('call play_rec on ' + to_play + ' opts = ' + service_option)
		timestep('renderer_play_init')
		opts = ('wyts=1', 'probe=0', 'norm_speed=1', 'live=1', service_option)
		self.wyplayer.load(to_play, scheme='rec', properties=opts)
		self.play_loaded()
	self._first_pass = False

def _select_lang(self):
	lang = self.play_options.get('lang')
	if lang:
		for asub in self.wyplayer.alist():
			if asub['lang'] == lang:
				self.wyplayer.aid = asub['id']
				break
				continue

def play_loaded(self):
	self.action = None
	recorder = self.live.external_recorder
	if not self.wyplayer:
		return None
	if not recorder:
		self.wyplayer.play_loaded()
	else:
		pos = 0.0
		if self.live.chunk_info:
			pos = self.live.chunk_info.getReadOffset()
		self.wyplayer.play_loaded(start_pos=float(pos), bytes=True)
		self.live.saveReadOffset(0)
		timestep('wyplayer: play')
		if self.play_options.get('start_extern_eit', False):
			self.live.external_dvb_manager.startExternEIT(config.wyplayer_extern_eit_path, self.live.wyscan_recording_id)
			timestep('renderer_play_extern_eit_time')
	timestep('callback_time')
	return None

def stop(self):
	self.action = None
	self.live = None
	timestep('renderer_stop_init')
	if self.wyplayer and self.wyplayer.status not in ('idle', 'closed'):
		self.wyplayer.stop()
		timestep('wyplayer: stop')
	return None

def close(self, wait_player_closed=True):
	if self.wyplayer and self.wyplayer.status != 'closed':
		timestep('wyplayer: close')
		self.wyplayer.close()
		if wait_player_closed:
			self.wait_for_status(['closed'])
		self.wyplayer.watch_property('status', None)
	return None

def isPlaying(self):
	log.debug('external renderer called: isPlaying')
	return self.wyplayer.status == 'playing'

def getLive(self):
	return self.live

def getTimeInfo(self):
	try:
		self._ExternalRenderer__renderer_time_info.current_time = self.live.chunk_info.getTimeFromOffset(self.bytesPos())
		self._ExternalRenderer__renderer_time_info.min_available_time = self.live.chunk_info.getMinimumTimeshiftTime()
		self._ExternalRenderer__renderer_time_info.max_available_time = self.live.chunk_info.getMaximumTimeshiftTime()
	except:
		self._ExternalRenderer__renderer_time_info.current_time = 0
		self._ExternalRenderer__renderer_time_info.max_available_time = 0
		self._ExternalRenderer__renderer_time_info.min_available_time = 0
		log.debug('failed to read chunkingo')
	return self._ExternalRenderer__renderer_time_info

def savePausePosition(self):
	self.on_pause = True
	if self.wyplayer:
		pos = self.wyplayer.byte_pos
		if self.live:
			self.live.saveReadOffset(pos['video'])

def resetPositionSaving(self):
	self.on_pause = False
	if self.live:
		self.live.saveReadOffset(0)

def isPlayingOnlive(self):
	ret = True
	if self.isPlaying():
		time_info = self.getTimeInfo()
		if abs(time_info.max_available_time - time_info.current_time) >= config.delta_time_for_playing:
			ret = False
	return ret

def bytesPos(self):
	bytes_pos = 0
	if self.wyplayer:
		log.info("wyplayer.byte_pos['audio']")
		bytes_pos = self.wyplayer.byte_pos['audio']
	return bytes_pos

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75c8acc>}
nname: 0
n 0(None)[from logger import log
from config import *
from peewee.analyse import Chrono
from peewee.analyse import timestep
from threading import Event
from callbacks import Callbacks
from time import time
import os
class RendererTimeInfo():
	def __init__(self):
		self.min_available_time = 0
		self.max_available_time = 0
		self.current_time = 0



class ExternalRenderer(object):
	wyplayer_signals = dict(closed=Event(), idle=Event(), playing=Event(), loading=Event())
	def wait_for_status(self, signals, timeout=4, callback=(lambda *args, **args: None), *args, **args):
		log.info('player status : %s waiting for %s' % (self.wyplayer.status, signals))
		limit = time() + timeout
		for sig in signals:
			self.wyplayer_signals[sig].wait(timeout)
			if limit < time():
				log.error('Player did not change his status, may be because of signal lost')
				continue
			try:
				callback(*args, **kw)
				continue
			except:
				continue

	def __init__(self, wyplayer):
		self.wyplayer = wyplayer
		self.live = None
		self.on_pause = False
		self._first_pass = True
		self._ExternalRenderer__renderer_time_info = RendererTimeInfo()
		self.action = None
		return None

	def status_change_callback(self, status):
		log.info('New player status : %s' % status)
		for e_name, e_sig in self.wyplayer_signals.iteritems():
			if e_name == status:
				e_sig.set()
				continue
			e_sig.clear()
		if status == 'playing':
			self._select_lang()
			Callbacks().start_playing.notify(self, self.live, recording=self.play_options.get('recording', False))
		if status == 'loading' and self.action == 'play':
			pass

	def play(self, live, **kw):
		self.action = 'play'
		self.live = live
		recorder = live.external_recorder
		self.play_options = kw
		if not self.wyplayer:
			pass
		if self._first_pass and self.wyplayer.status != 'closed':
			self.wyplayer.close()
			try:
				self.wait_for_status(['closed'], timeout=1)
			except OverflowError:
				log.info('Player reinitialized : status %s , TV should work again' % self.wyplayer.status)
		if not recorder:
			log.error('trying to play a live that have not external recorder')
			self.wyplayer.load_uri(live.source_uri, properties={'wyts': '1', 'probe': '0', 'norm_speed': '1', 'live': '1', 'service': str(live.serviceid & 65535)})
			self.play_loaded()
		else:
			if self.wyplayer.status == 'closed':
				self.wyplayer.watch_property('status', self.status_change_callback)
				self.wyplayer.open()
				def load_options():
					for opt in ['aspect_ratio', 'spdif_surround', 'display_format']:
						val = kw.get(opt, None)
						if val:
							setattr(self.wyplayer, opt, val)
							continue
					return None

				self.wait_for_status(['idle'], callback=load_options)
			to_play = os.path.basename(recorder.dbuspath)
			dvb_service_id = live.serviceid & 65535
			service_option = 'service=' + str(dvb_service_id)
			log.debug('call play_rec on ' + to_play + ' opts = ' + service_option)
			timestep('renderer_play_init')
			opts = ('wyts=1', 'probe=0', 'norm_speed=1', 'live=1', service_option)
			self.wyplayer.load(to_play, scheme='rec', properties=opts)
			self.play_loaded()
		self._first_pass = False

	def _select_lang(self):
		lang = self.play_options.get('lang')
		if lang:
			for asub in self.wyplayer.alist():
				if asub['lang'] == lang:
					self.wyplayer.aid = asub['id']
					break
					continue

	def play_loaded(self):
		self.action = None
		recorder = self.live.external_recorder
		if not self.wyplayer:
			return None
		if not recorder:
			self.wyplayer.play_loaded()
		else:
			pos = 0.0
			if self.live.chunk_info:
				pos = self.live.chunk_info.getReadOffset()
			self.wyplayer.play_loaded(start_pos=float(pos), bytes=True)
			self.live.saveReadOffset(0)
			timestep('wyplayer: play')
			if self.play_options.get('start_extern_eit', False):
				self.live.external_dvb_manager.startExternEIT(config.wyplayer_extern_eit_path, self.live.wyscan_recording_id)
				timestep('renderer_play_extern_eit_time')
		timestep('callback_time')
		return None

	def stop(self):
		self.action = None
		self.live = None
		timestep('renderer_stop_init')
		if self.wyplayer and self.wyplayer.status not in ('idle', 'closed'):
			self.wyplayer.stop()
			timestep('wyplayer: stop')
		return None

	def close(self, wait_player_closed=True):
		if self.wyplayer and self.wyplayer.status != 'closed':
			timestep('wyplayer: close')
			self.wyplayer.close()
			if wait_player_closed:
				self.wait_for_status(['closed'])
			self.wyplayer.watch_property('status', None)
		return None

	def isPlaying(self):
		log.debug('external renderer called: isPlaying')
		return self.wyplayer.status == 'playing'

	def getLive(self):
		return self.live

	def getTimeInfo(self):
		try:
			self._ExternalRenderer__renderer_time_info.current_time = self.live.chunk_info.getTimeFromOffset(self.bytesPos())
			self._ExternalRenderer__renderer_time_info.min_available_time = self.live.chunk_info.getMinimumTimeshiftTime()
			self._ExternalRenderer__renderer_time_info.max_available_time = self.live.chunk_info.getMaximumTimeshiftTime()
		except:
			self._ExternalRenderer__renderer_time_info.current_time = 0
			self._ExternalRenderer__renderer_time_info.max_available_time = 0
			self._ExternalRenderer__renderer_time_info.min_available_time = 0
			log.debug('failed to read chunkingo')
		return self._ExternalRenderer__renderer_time_info

	def savePausePosition(self):
		self.on_pause = True
		if self.wyplayer:
			pos = self.wyplayer.byte_pos
			if self.live:
				self.live.saveReadOffset(pos['video'])

	def resetPositionSaving(self):
		self.on_pause = False
		if self.live:
			self.live.saveReadOffset(0)

	def isPlayingOnlive(self):
		ret = True
		if self.isPlaying():
			time_info = self.getTimeInfo()
			if abs(time_info.max_available_time - time_info.current_time) >= config.delta_time_for_playing:
				ret = False
		return ret

	def bytesPos(self):
		bytes_pos = 0
		if self.wyplayer:
			log.info("wyplayer.byte_pos['audio']")
			bytes_pos = self.wyplayer.byte_pos['audio']
		return bytes_pos



]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75bbfcc>}
from logger import log
from config import *
from peewee.analyse import Chrono
from peewee.analyse import timestep
from threading import Event
from callbacks import Callbacks
from time import time
import os
class RendererTimeInfo():
	def __init__(self):
		self.min_available_time = 0
		self.max_available_time = 0
		self.current_time = 0



class ExternalRenderer(object):
	wyplayer_signals = dict(closed=Event(), idle=Event(), playing=Event(), loading=Event())
	def wait_for_status(self, signals, timeout=4, callback=(lambda *args, **args: None), *args, **args):
		log.info('player status : %s waiting for %s' % (self.wyplayer.status, signals))
		limit = time() + timeout
		for sig in signals:
			self.wyplayer_signals[sig].wait(timeout)
			if limit < time():
				log.error('Player did not change his status, may be because of signal lost')
				continue
			try:
				callback(*args, **kw)
				continue
			except:
				continue

	def __init__(self, wyplayer):
		self.wyplayer = wyplayer
		self.live = None
		self.on_pause = False
		self._first_pass = True
		self._ExternalRenderer__renderer_time_info = RendererTimeInfo()
		self.action = None
		return None

	def status_change_callback(self, status):
		log.info('New player status : %s' % status)
		for e_name, e_sig in self.wyplayer_signals.iteritems():
			if e_name == status:
				e_sig.set()
				continue
			e_sig.clear()
		if status == 'playing':
			self._select_lang()
			Callbacks().start_playing.notify(self, self.live, recording=self.play_options.get('recording', False))
		if status == 'loading' and self.action == 'play':
			pass

	def play(self, live, **kw):
		self.action = 'play'
		self.live = live
		recorder = live.external_recorder
		self.play_options = kw
		if not self.wyplayer:
			pass
		if self._first_pass and self.wyplayer.status != 'closed':
			self.wyplayer.close()
			try:
				self.wait_for_status(['closed'], timeout=1)
			except OverflowError:
				log.info('Player reinitialized : status %s , TV should work again' % self.wyplayer.status)
		if not recorder:
			log.error('trying to play a live that have not external recorder')
			self.wyplayer.load_uri(live.source_uri, properties={'wyts': '1', 'probe': '0', 'norm_speed': '1', 'live': '1', 'service': str(live.serviceid & 65535)})
			self.play_loaded()
		else:
			if self.wyplayer.status == 'closed':
				self.wyplayer.watch_property('status', self.status_change_callback)
				self.wyplayer.open()
				def load_options():
					for opt in ['aspect_ratio', 'spdif_surround', 'display_format']:
						val = kw.get(opt, None)
						if val:
							setattr(self.wyplayer, opt, val)
							continue
					return None

				self.wait_for_status(['idle'], callback=load_options)
			to_play = os.path.basename(recorder.dbuspath)
			dvb_service_id = live.serviceid & 65535
			service_option = 'service=' + str(dvb_service_id)
			log.debug('call play_rec on ' + to_play + ' opts = ' + service_option)
			timestep('renderer_play_init')
			opts = ('wyts=1', 'probe=0', 'norm_speed=1', 'live=1', service_option)
			self.wyplayer.load(to_play, scheme='rec', properties=opts)
			self.play_loaded()
		self._first_pass = False

	def _select_lang(self):
		lang = self.play_options.get('lang')
		if lang:
			for asub in self.wyplayer.alist():
				if asub['lang'] == lang:
					self.wyplayer.aid = asub['id']
					break
					continue

	def play_loaded(self):
		self.action = None
		recorder = self.live.external_recorder
		if not self.wyplayer:
			return None
		if not recorder:
			self.wyplayer.play_loaded()
		else:
			pos = 0.0
			if self.live.chunk_info:
				pos = self.live.chunk_info.getReadOffset()
			self.wyplayer.play_loaded(start_pos=float(pos), bytes=True)
			self.live.saveReadOffset(0)
			timestep('wyplayer: play')
			if self.play_options.get('start_extern_eit', False):
				self.live.external_dvb_manager.startExternEIT(config.wyplayer_extern_eit_path, self.live.wyscan_recording_id)
				timestep('renderer_play_extern_eit_time')
		timestep('callback_time')
		return None

	def stop(self):
		self.action = None
		self.live = None
		timestep('renderer_stop_init')
		if self.wyplayer and self.wyplayer.status not in ('idle', 'closed'):
			self.wyplayer.stop()
			timestep('wyplayer: stop')
		return None

	def close(self, wait_player_closed=True):
		if self.wyplayer and self.wyplayer.status != 'closed':
			timestep('wyplayer: close')
			self.wyplayer.close()
			if wait_player_closed:
				self.wait_for_status(['closed'])
			self.wyplayer.watch_property('status', None)
		return None

	def isPlaying(self):
		log.debug('external renderer called: isPlaying')
		return self.wyplayer.status == 'playing'

	def getLive(self):
		return self.live

	def getTimeInfo(self):
		try:
			self._ExternalRenderer__renderer_time_info.current_time = self.live.chunk_info.getTimeFromOffset(self.bytesPos())
			self._ExternalRenderer__renderer_time_info.min_available_time = self.live.chunk_info.getMinimumTimeshiftTime()
			self._ExternalRenderer__renderer_time_info.max_available_time = self.live.chunk_info.getMaximumTimeshiftTime()
		except:
			self._ExternalRenderer__renderer_time_info.current_time = 0
			self._ExternalRenderer__renderer_time_info.max_available_time = 0
			self._ExternalRenderer__renderer_time_info.min_available_time = 0
			log.debug('failed to read chunkingo')
		return self._ExternalRenderer__renderer_time_info

	def savePausePosition(self):
		self.on_pause = True
		if self.wyplayer:
			pos = self.wyplayer.byte_pos
			if self.live:
				self.live.saveReadOffset(pos['video'])

	def resetPositionSaving(self):
		self.on_pause = False
		if self.live:
			self.live.saveReadOffset(0)

	def isPlayingOnlive(self):
		ret = True
		if self.isPlaying():
			time_info = self.getTimeInfo()
			if abs(time_info.max_available_time - time_info.current_time) >= config.delta_time_for_playing:
				ret = False
		return ret

	def bytesPos(self):
		bytes_pos = 0
		if self.wyplayer:
			log.info("wyplayer.byte_pos['audio']")
			bytes_pos = self.wyplayer.byte_pos['audio']
		return bytes_pos



