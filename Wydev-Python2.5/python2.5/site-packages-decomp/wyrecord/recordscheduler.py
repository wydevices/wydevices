# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 397
n 397(None)[return {'status': error.WYRECORD_SUCCESS, 'record_infos': record_infos}
]:
	i: 138(AL), 396()
	o: 

nname: 396
n 396(None)[]:
	i: 162(AF), 393()
	o: 397()

nname: 393
n 393(None)[]:
	i: 384(JA), 392()
	o: 396()

nname: 392
n 392(None)[]:
	i: 317(f), 389()
	o: 393()

nname: 389
n 389(None)[continue
]:
	i: 367(JA), 388()
	o: 392()

nname: 388
n 388(None)[]:
	i: 329(f)
	o: 389()

nname: 384
n 384(None)[]:
	i: 354(f)
	o: 393(JA)

nname: 367
n 367(None)[record_infos.append(record_info)
]:
	i: 354(t)
	o: 389(JA)

nname: 354
n 354(record_info.IsValid())[]:
	i: 329(t)
	o: 367(t), 384(f)

nname: 329
n 329(record_info.LoadFromFile(info_file))[record_info = RecordInfo()
]:
	i: 317(t)
	o: 354(t), 388(f)

nname: 317
n 317(info_file != '')[]:
	i: 214(), 302(JA), 312(), 316()
	o: 329(t), 392(f)

nname: 316
n 316(None)[]:
	i: 224(f)
	o: 317()

nname: 312
n 312(None)[]:
	i: 243&283(t)
	o: 317()

nname: 302
n 302(None)[info_file = ''
]:
	i: 243&283(f)
	o: 317(JA)

nname: 243&283
n 243&283(os.path.isdir(file_path_name) and os.path.isfile(info_file))[info_file = os.path.join(file_path_name, RECORD_INFO_FILE_NAME_MULTIPLE_FILE_NAME)
]:
	i: 224(t)
	o: 302(f), 312(t)

nname: 224
n 224(os.path.isdir(file_path_name))[]:
	i: 169(f)
	o: 243&283(t), 316(f)

nname: 214
n 214(None)[info_file = file_path_name
]:
	i: 169(t)
	o: 317()

nname: 169
n 169(file.endswith(RECORD_INFO_FILE_NAME_SUFFIX))[for file in files:
info_file = ''
file_path_name = os.path.join(strRecordsFolder, file)
]:
	i: 162(for)
	o: 214(t), 224(f)

nname: 162
n 162(None)[]:
	i: 138(loop)
	o: 169(for), 396(AF)

nname: 138
n 138(None)[files = os.listdir(strRecordsFolder)
record_infos = []
]:
	i: 100(), 137()
	o: 162(loop), 397(AL)

nname: 137
n 137(None)[]:
	i: 82(t)
	o: 138()

nname: 100
n 100(None)[log.error("Record folder '%s' is not a folder !" % strRecordsFolder)
return {'status': error.WYRECORD_BAD_PATH}
]:
	i: 82(f)
	o: 138()

nname: 82
n 82(os.path.isdir(strRecordsFolder))[]:
	i: 44(), 81()
	o: 100(f), 137(t)

nname: 81
n 81(None)[]:
	i: 26(t)
	o: 82()

nname: 44
n 44(None)[log.error("Record folder '%s' does not exist !" % strRecordsFolder)
return {'status': error.WYRECORD_BAD_PATH}
]:
	i: 26(f)
	o: 82()

nname: 26
n 26(os.path.exists(strRecordsFolder))[]:
	i: 12(), 25()
	o: 44(f), 81(t)

nname: 25
n 25(None)[]:
	i: 0(f)
	o: 26()

nname: 12
n 12(None)[strRecordsFolder = config.records_folder
]:
	i: 0(t)
	o: 26()

nname: 0
n 0(strRecordsFolder == '')[]:
	i: 
	o: 12(t), 25(f)

nname: 397
n 397(None)[return {'status': error.WYRECORD_SUCCESS, 'record_infos': record_infos}
]:
	i: 82(AL), 162(AF), 354(f), 169(f), 389()
	o: 

nname: 389
n 389(None)[continue
]:
	i: 367(JA), 329(f)
	o: 397()

nname: 367
n 367(None)[record_infos.append(record_info)
]:
	i: 354(t)
	o: 389(JA)

nname: 354
n 354(record_info.IsValid())[]:
	i: 329(t)
	o: 367(t), 397(f)

nname: 329
n 329(record_info.LoadFromFile(info_file))[record_info = RecordInfo()
]:
	i: 169(t)
	o: 354(t), 389(f)

nname: 169
n 169(info_file != '')[for file in files:
info_file = ''
file_path_name = os.path.join(strRecordsFolder, file)
if file.endswith(RECORD_INFO_FILE_NAME_SUFFIX):
	info_file = file_path_name
else:
	if os.path.isdir(file_path_name):
		info_file = os.path.join(file_path_name, RECORD_INFO_FILE_NAME_MULTIPLE_FILE_NAME)
		if not(os.path.isdir(file_path_name) and os.path.isfile(info_file)):
			info_file = ''
]:
	i: 162(for)
	o: 329(t), 397(f)

nname: 162
n 162(None)[]:
	i: 82(loop)
	o: 169(for), 397(AF)

nname: 82
n 82(None)[if not os.path.isdir(strRecordsFolder):
	log.error("Record folder '%s' is not a folder !" % strRecordsFolder)
	return {'status': error.WYRECORD_BAD_PATH}
files = os.listdir(strRecordsFolder)
record_infos = []
]:
	i: 0()
	o: 162(loop), 397(AL)

nname: 0
n 0(None)[if strRecordsFolder == '':
	strRecordsFolder = config.records_folder
if not os.path.exists(strRecordsFolder):
	log.error("Record folder '%s' does not exist !" % strRecordsFolder)
	return {'status': error.WYRECORD_BAD_PATH}
]:
	i: 
	o: 82()

nname: 397
n 397(None)[return {'status': error.WYRECORD_SUCCESS, 'record_infos': record_infos}
]:
	i: 0(AL), 162(AF), 354(f), 169(f), 389()
	o: 

nname: 389
n 389(None)[continue
]:
	i: 367(JA), 329(f)
	o: 397()

nname: 367
n 367(None)[record_infos.append(record_info)
]:
	i: 354(t)
	o: 389(JA)

nname: 354
n 354(record_info.IsValid())[]:
	i: 329(t)
	o: 367(t), 397(f)

nname: 329
n 329(record_info.LoadFromFile(info_file))[record_info = RecordInfo()
]:
	i: 169(t)
	o: 354(t), 389(f)

nname: 169
n 169(info_file != '')[for file in files:
info_file = ''
file_path_name = os.path.join(strRecordsFolder, file)
if file.endswith(RECORD_INFO_FILE_NAME_SUFFIX):
	info_file = file_path_name
else:
	if os.path.isdir(file_path_name):
		info_file = os.path.join(file_path_name, RECORD_INFO_FILE_NAME_MULTIPLE_FILE_NAME)
		if not(os.path.isdir(file_path_name) and os.path.isfile(info_file)):
			info_file = ''
]:
	i: 162(for)
	o: 329(t), 397(f)

nname: 162
n 162(None)[]:
	i: 0(loop)
	o: 169(for), 397(AF)

nname: 0
n 0(None)[if strRecordsFolder == '':
	strRecordsFolder = config.records_folder
if not os.path.exists(strRecordsFolder):
	log.error("Record folder '%s' does not exist !" % strRecordsFolder)
	return {'status': error.WYRECORD_BAD_PATH}
if not os.path.isdir(strRecordsFolder):
	log.error("Record folder '%s' is not a folder !" % strRecordsFolder)
	return {'status': error.WYRECORD_BAD_PATH}
files = os.listdir(strRecordsFolder)
record_infos = []
]:
	i: 
	o: 162(loop), 397(AL)

self.nodes: {0: <unpyclib.structure.node instance at 0x8b7f60c>, 389: <unpyclib.structure.node instance at 0x8b7f48c>, 397: <unpyclib.structure.node instance at 0x8b7f68c>, 162: <unpyclib.structure.node instance at 0x8b7ed0c>, 169: <unpyclib.structure.node instance at 0x8b7f8ec>, 329: <unpyclib.structure.node instance at 0x8b7f20c>, 354: <unpyclib.structure.node instance at 0x8b7f28c>, 367: <unpyclib.structure.node instance at 0x8b7f30c>}
nname: 0
n 0(None)[self.ext_disk_space = ext_disk_space
self.dbus_api = dbus_signaler
self.ext_standby = ext_standby
self.ext_standby.scheduler = self
self.recording_launcher = recording_launcher
self.recording_builder = recording_builder
self.last_save_time = 0
self.server = recording_launcher.wyscan
self.recording_list = RecordingList(recording_builder, self.recording_launcher)
self.periodic_recording_list = PeriodicRecordingList()
self.timer_startrecording = WyrecordOnShotTimer(self.cbtimerStart)
self.timer_stoprecording = WyrecordOnShotTimer(self.cbtimerStop)
self.timer_pre_start_alert = WyrecordOnShotTimer(self.cbtimerPreStartAlert)
self.LoadRecordingList()
self.CheckRecordingStates()
self.recording_launcher.StopDeviceRecordings(0)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x8b8772c>}
nname: 0
n 0(None)[return self.recording_launcher.GetCurrentUTCTime()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x8c1842c>}
nname: 170
n 170(None)[self.recording_list.CleanUp()
]:
	i: 0(AL), 169()
	o: 

nname: 169
n 169(None)[]:
	i: 3(AF), 166()
	o: 170()

nname: 166
n 166(None)[]:
	i: 50(JA), 115(JA), 165()
	o: 169()

nname: 165
n 165(None)[]:
	i: 22(f), 162()
	o: 166()

nname: 162
n 162(None)[continue
]:
	i: 160(AE)
	o: 165()

nname: 160
n 160(None)[]:
	i: 105(f)
	o: 162(AE)

nname: 115
n 115(None)[#, e
log.critical('EXCEPTION ' + str(e))
log.critical('excpetion on record stop => record is lost')
]:
	i: 105(t)
	o: 166(JA)

nname: 105
n 105(<dummy_ex3> EXC_MATCH BaseException)[]:
	i: 46(except)
	o: 115(t), 160(f)

nname: 50
n 50(None)[log.warning('Recording : ' + str(recording))
recording.Stop(self.GetCurrentUTCTime(), dbus_api=self.dbus_api)
]:
	i: 46(try)
	o: 166(JA)

nname: 46
n 46(None)[]:
	i: 22(t)
	o: 50(try), 105(except)

nname: 22
n 22(recording.status == RECORDING_STATUS_RUNNING)[for id, recording in self.recording_list.recordings.items():
]:
	i: 3(for)
	o: 46(t), 165(f)

nname: 3
n 3(None)[]:
	i: 0(loop)
	o: 22(for), 169(AF)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 170(AL)

nname: 170
n 170(None)[self.recording_list.CleanUp()
]:
	i: 0(AL), 3(AF), 50(JA), 115(JA), 105(f), 22(f), 162()
	o: 

nname: 115
n 115(None)[#, e
log.critical('EXCEPTION ' + str(e))
log.critical('excpetion on record stop => record is lost')
]:
	i: 105(t)
	o: 170(JA)

nname: 105
n 105(<dummy_ex3> EXC_MATCH BaseException)[]:
	i: 46(except)
	o: 115(t), 170(f)

nname: 50
n 50(None)[log.warning('Recording : ' + str(recording))
recording.Stop(self.GetCurrentUTCTime(), dbus_api=self.dbus_api)
]:
	i: 46(try)
	o: 170(JA)

nname: 46
n 46(None)[]:
	i: 22(t)
	o: 50(try), 105(except)

nname: 22
n 22(recording.status == RECORDING_STATUS_RUNNING)[for id, recording in self.recording_list.recordings.items():
]:
	i: 3(for)
	o: 46(t), 170(f)

nname: 3
n 3(None)[]:
	i: 0(loop)
	o: 22(for), 170(AF)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 170(AL)

nname: 170
n 170(None)[self.recording_list.CleanUp()
]:
	i: 0(AL), 3(AF), 105(f), 22(f), 162()
	o: 

nname: 105
n 105(None)[except BaseException, e:
	log.critical('EXCEPTION ' + str(e))
	log.critical('excpetion on record stop => record is lost')
]:
	i: 46()
	o: 170(JA)

nname: 46
n 46(None)[try:
	log.warning('Recording : ' + str(recording))
	recording.Stop(self.GetCurrentUTCTime(), dbus_api=self.dbus_api)
]:
	i: 22(t)
	o: 105()

nname: 22
n 22(recording.status == RECORDING_STATUS_RUNNING)[for id, recording in self.recording_list.recordings.items():
]:
	i: 3(for)
	o: 46(t), 170(f)

nname: 3
n 3(None)[]:
	i: 0(loop)
	o: 22(for), 170(AF)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 170(AL)

nname: 170
n 170(None)[self.recording_list.CleanUp()
]:
	i: 0(AL), 3(AF), 46(f), 22(f), 162()
	o: 

nname: 46
n 46(None)[try:
	log.warning('Recording : ' + str(recording))
	recording.Stop(self.GetCurrentUTCTime(), dbus_api=self.dbus_api)
except BaseException, e:
	log.critical('EXCEPTION ' + str(e))
	log.critical('excpetion on record stop => record is lost')
]:
	i: 22(t)
	o: 170(JA)

nname: 22
n 22(recording.status == RECORDING_STATUS_RUNNING)[for id, recording in self.recording_list.recordings.items():
]:
	i: 3(for)
	o: 46(t), 170(f)

nname: 3
n 3(None)[]:
	i: 0(loop)
	o: 22(for), 170(AF)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 170(AL)

nname: 170
n 170(None)[self.recording_list.CleanUp()
]:
	i: 22(f), 162()
	o: 

nname: 22
n 22(None)[for id, recording in self.recording_list.recordings.items():
	if recording.status == RECORDING_STATUS_RUNNING:
		try:
			log.warning('Recording : ' + str(recording))
			recording.Stop(self.GetCurrentUTCTime(), dbus_api=self.dbus_api)
		except BaseException, e:
			log.critical('EXCEPTION ' + str(e))
			log.critical('excpetion on record stop => record is lost')
]:
	i: 0(for)
	o: 170(JA)

nname: 0
n 0(None)[]:
	i: 
	o: 22(for)

nname: 170
n 170(None)[self.recording_list.CleanUp()
]:
	i: 0(f), 162()
	o: 

nname: 0
n 0(None)[for id, recording in self.recording_list.recordings.items():
	if recording.status == RECORDING_STATUS_RUNNING:
		try:
			log.warning('Recording : ' + str(recording))
			recording.Stop(self.GetCurrentUTCTime(), dbus_api=self.dbus_api)
		except BaseException, e:
			log.critical('EXCEPTION ' + str(e))
			log.critical('excpetion on record stop => record is lost')
]:
	i: 
	o: 170(JA)

self.nodes: {0: <unpyclib.structure.node instance at 0x8b87e8c>, 160: <unpyclib.structure.node instance at 0x8b8722c>, 162: <unpyclib.structure.node instance at 0x8b871cc>, 170: <unpyclib.structure.node instance at 0x8b87e6c>}
nname: 261
n 261(None)[return recording_list
]:
	i: 0(AL), 260()
	o: 

nname: 260
n 260(None)[]:
	i: 9(AF), 256()
	o: 261()

nname: 256
n 256(None)[_POP_TOP pass
]:
	i: 65&77&88&104&115&131&142&158&169&185&196&212&223(f), 239()
	o: 260()

nname: 239
n 239(None)[recording_list.append(recording)
continue
]:
	i: 65&77&88&104&115&131&142&158&169&185&196&212&223(t)
	o: 256()

nname: 65&77&88&104&115&131&142&158&169&185&196&212&223
n 65&77&88&104&115&131&142&158&169&185&196&212&223(nFlags == RECORDING_FLAG_ALL or nFlags & RECORDING_FLAG_RUNNING and recording.status == RECORDING_STATUS_RUNNING or nFlags & RECORDING_FLAG_INCONFLICT and recording.status == RECORDING_STATUS_IN_CONFLICT or nFlags & RECORDING_FLAG_COMPLETED and recording.status == RECORDING_STATUS_COMPLETED or nFlags & RECORDING_FLAG_CANCELED and recording.status == RECORDING_STATUS_CANCELED or nFlags & RECORDING_FLAG_MISSED and recording.status == RECORDING_STATUS_MISSED or nFlags & RECORDING_FLAG_SCHEDULED and recording.status == RECORDING_STATUS_SCHEDULED)[]:
	i: 53(JA), 60(), 64()
	o: 239(t), 256(f)

nname: 64
n 64(None)[]:
	i: 28(f)
	o: 65&77&88&104&115&131&142&158&169&185&196&212&223()

nname: 60
n 60(None)[]:
	i: 37(f)
	o: 65&77&88&104&115&131&142&158&169&185&196&212&223()

nname: 53
n 53(None)[continue
]:
	i: 37(t)
	o: 65&77&88&104&115&131&142&158&169&185&196&212&223(JA)

nname: 37
n 37(recording.periodicity_rule_id != PERIODICITY_RULE_ID_NULL)[]:
	i: 28(t)
	o: 53(t), 60(f)

nname: 28
n 28(ignore_periodic)[for recording in self.recording_list.recordings.values():
]:
	i: 9(for)
	o: 37(t), 64(f)

nname: 9
n 9(None)[]:
	i: 0(loop)
	o: 28(for), 260(AF)

nname: 0
n 0(None)[recording_list = []
]:
	i: 
	o: 9(loop), 261(AL)

nname: 261
n 261(None)[return recording_list
]:
	i: 0(AL), 9(AF), 256()
	o: 

nname: 256
n 256(None)[_POP_TOP pass
]:
	i: 28(f)
	o: 261()

nname: 28
n 28(None)[for recording in self.recording_list.recordings.values():
if ignore_periodic:
	if recording.periodicity_rule_id != PERIODICITY_RULE_ID_NULL:
		continue
if nFlags == RECORDING_FLAG_ALL or nFlags & RECORDING_FLAG_RUNNING and recording.status == RECORDING_STATUS_RUNNING or nFlags & RECORDING_FLAG_INCONFLICT and recording.status == RECORDING_STATUS_IN_CONFLICT or nFlags & RECORDING_FLAG_COMPLETED and recording.status == RECORDING_STATUS_COMPLETED or nFlags & RECORDING_FLAG_CANCELED and recording.status == RECORDING_STATUS_CANCELED or nFlags & RECORDING_FLAG_MISSED and recording.status == RECORDING_STATUS_MISSED or nFlags & RECORDING_FLAG_SCHEDULED and recording.status == RECORDING_STATUS_SCHEDULED:
	recording_list.append(recording)
	continue
]:
	i: 9(for)
	o: 256()

nname: 9
n 9(None)[]:
	i: 0(loop)
	o: 28(for), 261(AF)

nname: 0
n 0(None)[recording_list = []
]:
	i: 
	o: 9(loop), 261(AL)

nname: 261
n 261(None)[return recording_list
]:
	i: 0(AL), 9(AF), 28()
	o: 

nname: 28
n 28(None)[for recording in self.recording_list.recordings.values():
if ignore_periodic:
	if recording.periodicity_rule_id != PERIODICITY_RULE_ID_NULL:
		continue
if nFlags == RECORDING_FLAG_ALL or nFlags & RECORDING_FLAG_RUNNING and recording.status == RECORDING_STATUS_RUNNING or nFlags & RECORDING_FLAG_INCONFLICT and recording.status == RECORDING_STATUS_IN_CONFLICT or nFlags & RECORDING_FLAG_COMPLETED and recording.status == RECORDING_STATUS_COMPLETED or nFlags & RECORDING_FLAG_CANCELED and recording.status == RECORDING_STATUS_CANCELED or nFlags & RECORDING_FLAG_MISSED and recording.status == RECORDING_STATUS_MISSED or nFlags & RECORDING_FLAG_SCHEDULED and recording.status == RECORDING_STATUS_SCHEDULED:
	recording_list.append(recording)
	continue
_POP_TOP pass
]:
	i: 9(for)
	o: 261()

nname: 9
n 9(None)[]:
	i: 0(loop)
	o: 28(for), 261(AF)

nname: 0
n 0(None)[recording_list = []
]:
	i: 
	o: 9(loop), 261(AL)

nname: 28
n 28(None)[for recording in self.recording_list.recordings.values():
	if ignore_periodic:
		if recording.periodicity_rule_id != PERIODICITY_RULE_ID_NULL:
			continue
	if nFlags == RECORDING_FLAG_ALL or nFlags & RECORDING_FLAG_RUNNING and recording.status == RECORDING_STATUS_RUNNING or nFlags & RECORDING_FLAG_INCONFLICT and recording.status == RECORDING_STATUS_IN_CONFLICT or nFlags & RECORDING_FLAG_COMPLETED and recording.status == RECORDING_STATUS_COMPLETED or nFlags & RECORDING_FLAG_CANCELED and recording.status == RECORDING_STATUS_CANCELED or nFlags & RECORDING_FLAG_MISSED and recording.status == RECORDING_STATUS_MISSED or nFlags & RECORDING_FLAG_SCHEDULED and recording.status == RECORDING_STATUS_SCHEDULED:
		recording_list.append(recording)
		continue
	_POP_TOP pass
return recording_list
]:
	i: 0(for)
	o: 

nname: 0
n 0(None)[recording_list = []
]:
	i: 
	o: 28(for)

nname: 0
n 0(None)[recording_list = []
for recording in self.recording_list.recordings.values():
	if ignore_periodic:
		if recording.periodicity_rule_id != PERIODICITY_RULE_ID_NULL:
			continue
	if nFlags == RECORDING_FLAG_ALL or nFlags & RECORDING_FLAG_RUNNING and recording.status == RECORDING_STATUS_RUNNING or nFlags & RECORDING_FLAG_INCONFLICT and recording.status == RECORDING_STATUS_IN_CONFLICT or nFlags & RECORDING_FLAG_COMPLETED and recording.status == RECORDING_STATUS_COMPLETED or nFlags & RECORDING_FLAG_CANCELED and recording.status == RECORDING_STATUS_CANCELED or nFlags & RECORDING_FLAG_MISSED and recording.status == RECORDING_STATUS_MISSED or nFlags & RECORDING_FLAG_SCHEDULED and recording.status == RECORDING_STATUS_SCHEDULED:
		recording_list.append(recording)
		continue
	_POP_TOP pass
return recording_list
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x8b8764c>}
nname: 0
n 0(None)[log.info('GetRecording(nRecordingID = %d)' % nRecordingID)
return self.recording_list.GetRecording(nRecordingID)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x8c184ec>}
nname: 379
n 379(None)[return ret1
]:
	i: 369(f), 375()
	o: 

nname: 375
n 375(None)[]:
	i: 369(t)
	o: 379()

nname: 369
n 369(ret1)[]:
	i: 152(), 269(), 367(AE)
	o: 375(t), 379(f)

nname: 367
n 367(None)[]:
	i: 259(f)
	o: 369(AE)

nname: 269
n 269(None)[#, e
self.recording_list = RecordingList(self.recording_builder, self.recording_launcher)
self.periodic_recording_list = PeriodicRecordingList()
log.critical("Can not parse xml file '%s'" % config.recordings_list_file)
log.critical('the file is deleted')
os.remove(config.recordings_list_file)
return False
]:
	i: 259(t)
	o: 369()

nname: 259
n 259(<dummy_ex3> EXC_MATCH Exception)[]:
	i: 149(except)
	o: 269(t), 367(f)

nname: 152
n 152(None)[node_general = node_root.find('general')
self.last_save_time = int(node_general.attrib['save_time'])
node_recordings = node_root.find('recordings')
ret1 = self.recording_list.LoadFromXML(node_recordings)
node_periodicity = node_root.find('periodicity')
ret2 = self.periodic_recording_list.LoadFromXML(node_periodicity)
]:
	i: 149(try)
	o: 369()

nname: 149
n 149(None)[]:
	i: 3(), 35(), 85(), 147(AE)
	o: 152(try), 259(except)

nname: 147
n 147(None)[]:
	i: 74(f)
	o: 149(AE)

nname: 85
n 85(None)[#, e
log.critical("Can not parse xml file '%s'" % config.recordings_list_file)
log.critical('the file is deleted')
os.remove(config.recordings_list_file)
return False
]:
	i: 74(t)
	o: 149()

nname: 74
n 74(<dummy_ex3> EXC_MATCH Exception)[]:
	i: 25(f)
	o: 85(t), 147(f)

nname: 35
n 35(None)[#, e
log.info(e)
log.info('the file will be created automaticly')
return False
]:
	i: 25(t)
	o: 149()

nname: 25
n 25(<dummy_ex3> EXC_MATCH EnvironmentError)[]:
	i: 0(except)
	o: 35(t), 74(f)

nname: 3
n 3(None)[node_root = ET.parse(config.recordings_list_file)
]:
	i: 0(try)
	o: 149()

nname: 0
n 0(None)[]:
	i: 
	o: 3(try), 25(except)

nname: 369
n 369(None)[if ret1:
	pass
return ret1
]:
	i: 152()
	o: 

nname: 152
n 152(None)[try:
	node_general = node_root.find('general')
	self.last_save_time = int(node_general.attrib['save_time'])
	node_recordings = node_root.find('recordings')
	ret1 = self.recording_list.LoadFromXML(node_recordings)
	node_periodicity = node_root.find('periodicity')
	ret2 = self.periodic_recording_list.LoadFromXML(node_periodicity)
except Exception, e:
	self.recording_list = RecordingList(self.recording_builder, self.recording_launcher)
	self.periodic_recording_list = PeriodicRecordingList()
	log.critical("Can not parse xml file '%s'" % config.recordings_list_file)
	log.critical('the file is deleted')
	os.remove(config.recordings_list_file)
	return False
]:
	i: 25(try)
	o: 369()

nname: 25
n 25(None)[except EnvironmentError, e:
	log.info(e)
	log.info('the file will be created automaticly')
	return False
except:
	except Exception, e:
		log.critical("Can not parse xml file '%s'" % config.recordings_list_file)
		log.critical('the file is deleted')
		os.remove(config.recordings_list_file)
		return False
]:
	i: 0()
	o: 152(try)

nname: 0
n 0(None)[try:
	node_root = ET.parse(config.recordings_list_file)
]:
	i: 
	o: 25()

nname: 152
n 152(None)[try:
	node_general = node_root.find('general')
	self.last_save_time = int(node_general.attrib['save_time'])
	node_recordings = node_root.find('recordings')
	ret1 = self.recording_list.LoadFromXML(node_recordings)
	node_periodicity = node_root.find('periodicity')
	ret2 = self.periodic_recording_list.LoadFromXML(node_periodicity)
except Exception, e:
	self.recording_list = RecordingList(self.recording_builder, self.recording_launcher)
	self.periodic_recording_list = PeriodicRecordingList()
	log.critical("Can not parse xml file '%s'" % config.recordings_list_file)
	log.critical('the file is deleted')
	os.remove(config.recordings_list_file)
	return False
if ret1:
	pass
return ret1
]:
	i: 0(try)
	o: 

nname: 0
n 0(None)[try:
	node_root = ET.parse(config.recordings_list_file)
except EnvironmentError, e:
	log.info(e)
	log.info('the file will be created automaticly')
	return False
except:
	except Exception, e:
		log.critical("Can not parse xml file '%s'" % config.recordings_list_file)
		log.critical('the file is deleted')
		os.remove(config.recordings_list_file)
		return False
]:
	i: 
	o: 152(try)

nname: 0
n 0(None)[try:
	node_root = ET.parse(config.recordings_list_file)
except EnvironmentError, e:
	log.info(e)
	log.info('the file will be created automaticly')
	return False
except:
	except Exception, e:
		log.critical("Can not parse xml file '%s'" % config.recordings_list_file)
		log.critical('the file is deleted')
		os.remove(config.recordings_list_file)
		return False
try:
	node_general = node_root.find('general')
	self.last_save_time = int(node_general.attrib['save_time'])
	node_recordings = node_root.find('recordings')
	ret1 = self.recording_list.LoadFromXML(node_recordings)
	node_periodicity = node_root.find('periodicity')
	ret2 = self.periodic_recording_list.LoadFromXML(node_periodicity)
except Exception, e:
	self.recording_list = RecordingList(self.recording_builder, self.recording_launcher)
	self.periodic_recording_list = PeriodicRecordingList()
	log.critical("Can not parse xml file '%s'" % config.recordings_list_file)
	log.critical('the file is deleted')
	os.remove(config.recordings_list_file)
	return False
if ret1:
	pass
return ret1
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x8c1fb8c>}
nname: 0
n 0(None)[AsynchronousAction().appendAction(ActionSaveRecordingList(self))
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x8c1884c>}
nname: 341
n 341(None)[timestep('SaveRecordingList end')
return True
]:
	i: 309(AE)
	o: 

nname: 309
n 309(None)[os.fsync(os.open(config.recordings_list_file, os.O_RDWR))
]:
	i: 0(finally), 305()
	o: 341(AE)

nname: 305
n 305(None)[]:
	i: 201(), 257(), 303(AE)
	o: 309()

nname: 303
n 303(None)[]:
	i: 247(f)
	o: 305(AE)

nname: 257
n 257(None)[#, e
log.critical('RecordScheduler.SaveRecordingList() : Error : ' + str(e))
timestep('SaveRecordingList end with exception')
return False
]:
	i: 247(t)
	o: 305()

nname: 247
n 247(<dummy_ex3> EXC_MATCH Exception)[]:
	i: 198(except)
	o: 257(t), 303(f)

nname: 201
n 201(None)[timestep('init_save_recording_list')
tree.write(config.recordings_list_file, encoding='utf-8')
timestep('SAVE RECORDING LIST TIME')
]:
	i: 198(try)
	o: 305()

nname: 198
n 198(None)[]:
	i: 0(ASF)
	o: 201(try), 247(except)

nname: 0
n 0(None)[timestep('SaveRecordingList begin')
self.last_save_time = self.recording_launcher.GetCurrentUTCTime()
root_node = ET.Element('RecordingList')
node_general = ET.Element('general', version='1.0', save_time=str(self.last_save_time))
root_node.append(node_general)
recordings_node = ET.Element('recordings')
self.recording_list.SaveToXMLNode(recordings_node)
root_node.append(recordings_node)
periodicity_node = ET.Element('periodicity')
self.periodic_recording_list.SaveToXMLNode(periodicity_node)
root_node.append(periodicity_node)
tree = ET.ElementTree(root_node)
]:
	i: 
	o: 198(ASF2), 309(finally)

nname: 341
n 341(None)[timestep('SaveRecordingList end')
return True
]:
	i: 309(AE)
	o: 

nname: 309
n 309(None)[os.fsync(os.open(config.recordings_list_file, os.O_RDWR))
]:
	i: 0(finally), 247()
	o: 341(AE)

nname: 247
n 247(None)[except Exception, e:
	log.critical('RecordScheduler.SaveRecordingList() : Error : ' + str(e))
	timestep('SaveRecordingList end with exception')
	return False
]:
	i: 198()
	o: 309()

nname: 198
n 198(None)[try:
	timestep('init_save_recording_list')
	tree.write(config.recordings_list_file, encoding='utf-8')
	timestep('SAVE RECORDING LIST TIME')
]:
	i: 0(ASF2)
	o: 247()

nname: 0
n 0(None)[timestep('SaveRecordingList begin')
self.last_save_time = self.recording_launcher.GetCurrentUTCTime()
root_node = ET.Element('RecordingList')
node_general = ET.Element('general', version='1.0', save_time=str(self.last_save_time))
root_node.append(node_general)
recordings_node = ET.Element('recordings')
self.recording_list.SaveToXMLNode(recordings_node)
root_node.append(recordings_node)
periodicity_node = ET.Element('periodicity')
self.periodic_recording_list.SaveToXMLNode(periodicity_node)
root_node.append(periodicity_node)
tree = ET.ElementTree(root_node)
]:
	i: 
	o: 198(ASF2), 309(finally)

nname: 341
n 341(None)[timestep('SaveRecordingList end')
return True
]:
	i: 309(AE)
	o: 

nname: 309
n 309(None)[os.fsync(os.open(config.recordings_list_file, os.O_RDWR))
]:
	i: 0(finally), 198()
	o: 341(AE)

nname: 198
n 198(None)[try:
	timestep('init_save_recording_list')
	tree.write(config.recordings_list_file, encoding='utf-8')
	timestep('SAVE RECORDING LIST TIME')
except Exception, e:
	log.critical('RecordScheduler.SaveRecordingList() : Error : ' + str(e))
	timestep('SaveRecordingList end with exception')
	return False
]:
	i: 0(ASF2)
	o: 309()

nname: 0
n 0(None)[timestep('SaveRecordingList begin')
self.last_save_time = self.recording_launcher.GetCurrentUTCTime()
root_node = ET.Element('RecordingList')
node_general = ET.Element('general', version='1.0', save_time=str(self.last_save_time))
root_node.append(node_general)
recordings_node = ET.Element('recordings')
self.recording_list.SaveToXMLNode(recordings_node)
root_node.append(recordings_node)
periodicity_node = ET.Element('periodicity')
self.periodic_recording_list.SaveToXMLNode(periodicity_node)
root_node.append(periodicity_node)
tree = ET.ElementTree(root_node)
]:
	i: 
	o: 198(ASF2), 309(finally)

nname: 309
n 309(None)[finally:
	os.fsync(os.open(config.recordings_list_file, os.O_RDWR))
timestep('SaveRecordingList end')
return True
]:
	i: 0()
	o: 

nname: 0
n 0(None)[timestep('SaveRecordingList begin')
self.last_save_time = self.recording_launcher.GetCurrentUTCTime()
root_node = ET.Element('RecordingList')
node_general = ET.Element('general', version='1.0', save_time=str(self.last_save_time))
root_node.append(node_general)
recordings_node = ET.Element('recordings')
self.recording_list.SaveToXMLNode(recordings_node)
root_node.append(recordings_node)
periodicity_node = ET.Element('periodicity')
self.periodic_recording_list.SaveToXMLNode(periodicity_node)
root_node.append(periodicity_node)
tree = ET.ElementTree(root_node)
try:
	timestep('init_save_recording_list')
	tree.write(config.recordings_list_file, encoding='utf-8')
	timestep('SAVE RECORDING LIST TIME')
except Exception, e:
	log.critical('RecordScheduler.SaveRecordingList() : Error : ' + str(e))
	timestep('SaveRecordingList end with exception')
	return False
]:
	i: 
	o: 309()

nname: 0
n 0(None)[timestep('SaveRecordingList begin')
self.last_save_time = self.recording_launcher.GetCurrentUTCTime()
root_node = ET.Element('RecordingList')
node_general = ET.Element('general', version='1.0', save_time=str(self.last_save_time))
root_node.append(node_general)
recordings_node = ET.Element('recordings')
self.recording_list.SaveToXMLNode(recordings_node)
root_node.append(recordings_node)
periodicity_node = ET.Element('periodicity')
self.periodic_recording_list.SaveToXMLNode(periodicity_node)
root_node.append(periodicity_node)
tree = ET.ElementTree(root_node)
try:
	timestep('init_save_recording_list')
	tree.write(config.recordings_list_file, encoding='utf-8')
	timestep('SAVE RECORDING LIST TIME')
except Exception, e:
	log.critical('RecordScheduler.SaveRecordingList() : Error : ' + str(e))
	timestep('SaveRecordingList end with exception')
	return False
finally:
	os.fsync(os.open(config.recordings_list_file, os.O_RDWR))
timestep('SaveRecordingList end')
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x8b8770c>}
nname: 0
n 0(None)[log.info('All timers stopped')
self.timer_stoprecording.stop()
self.timer_startrecording.stop()
self.timer_pre_start_alert.stop()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x8c1816c>}
nname: 90
n 90(None)[self.CheckSchedule()
]:
	i: 0(AL), 89()
	o: 

nname: 89
n 89(None)[]:
	i: 13(AF), 85()
	o: 90()

nname: 85
n 85(None)[]:
	i: 32(f), 50()
	o: 89()

nname: 50
n 50(None)[self.StopRecording(rec.id, stop_at_player_pos=False)
rec.status = RECORDING_STATUS_ABORTED
continue
]:
	i: 32(t)
	o: 85()

nname: 32
n 32(rec.status == RECORDING_STATUS_RUNNING)[for rec in self.recording_list.recordings.values():
]:
	i: 13(for)
	o: 50(t), 85(f)

nname: 13
n 13(None)[]:
	i: 0(loop)
	o: 32(for), 89(AF)

nname: 0
n 0(None)[self.StopAll()
]:
	i: 
	o: 13(loop), 90(AL)

nname: 90
n 90(None)[self.CheckSchedule()
]:
	i: 0(AL), 13(AF), 32()
	o: 

nname: 32
n 32(None)[for rec in self.recording_list.recordings.values():
if rec.status == RECORDING_STATUS_RUNNING:
	self.StopRecording(rec.id, stop_at_player_pos=False)
	rec.status = RECORDING_STATUS_ABORTED
	continue
]:
	i: 13(for)
	o: 90()

nname: 13
n 13(None)[]:
	i: 0(loop)
	o: 32(for), 90(AF)

nname: 0
n 0(None)[self.StopAll()
]:
	i: 
	o: 13(loop), 90(AL)

nname: 32
n 32(None)[for rec in self.recording_list.recordings.values():
	if rec.status == RECORDING_STATUS_RUNNING:
		self.StopRecording(rec.id, stop_at_player_pos=False)
		rec.status = RECORDING_STATUS_ABORTED
		continue
self.CheckSchedule()
]:
	i: 0(for)
	o: 

nname: 0
n 0(None)[self.StopAll()
]:
	i: 
	o: 32(for)

nname: 0
n 0(None)[self.StopAll()
for rec in self.recording_list.recordings.values():
	if rec.status == RECORDING_STATUS_RUNNING:
		self.StopRecording(rec.id, stop_at_player_pos=False)
		rec.status = RECORDING_STATUS_ABORTED
		continue
self.CheckSchedule()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x8c18eec>}
nname: 474
n 474(None)[timestep('CheckSchedule end')
return None
]:
	i: 379(JA), 419(), 435(), 473()
	o: 

nname: 473
n 473(None)[]:
	i: 422(f)
	o: 474()

nname: 435
n 435(None)[start_timer = self.getStartTimer(rec_to_start)
self._RecordScheduler__activeStartTimer(start_timer, rec_to_start.id)
]:
	i: 422(t)
	o: 474()

nname: 422
n 422(rec_to_start != None)[]:
	i: 261(f)
	o: 435(t), 473(f)

nname: 419
n 419(None)[]:
	i: 359(JA), 402()
	o: 474()

nname: 402
n 402(None)[self.timer_stoprecording.start(stop_timer)
]:
	i: 303(f)
	o: 419()

nname: 379
n 379(None)[self._RecordScheduler__activeStartTimer(start_timer, rec_to_start.id)
]:
	i: 331(f)
	o: 474(JA)

nname: 359
n 359(None)[self.timer_stoprecording.start(stop_timer)
]:
	i: 331(t)
	o: 419(JA)

nname: 331
n 331(stop_timer <= start_timer)[start_timer = self.getStartTimer(rec_to_start)
]:
	i: 303(t)
	o: 359(t), 379(f)

nname: 303
n 303(rec_to_start != None)[stop_timer = self.getStopTimer(rec_to_stop)
]:
	i: 261(t)
	o: 331(t), 402(f)

nname: 261
n 261(rec_to_stop != None)[rec_to_start = self.recording_list.GetFirstRecordingToStart()
rec_to_stop = self.recording_list.GetFirstRecordingToStop()
]:
	i: 246(), 260()
	o: 303(t), 422(f)

nname: 260
n 260(None)[]:
	i: 240(f)
	o: 261()

nname: 246
n 246(None)[self.SaveRecordingList()
]:
	i: 240(t)
	o: 261()

nname: 240
n 240(save_list)[]:
	i: 0(AL), 239()
	o: 246(t), 260(f)

nname: 239
n 239(None)[]:
	i: 70(AF), 235()
	o: 240()

nname: 235
n 235(None)[]:
	i: 175&190(f), 213()
	o: 239()

nname: 213
n 213(None)[recording.status = RECORDING_STATUS_MISSED
bNeedSave = True
continue
continue
]:
	i: 175&190(t)
	o: 235()

nname: 175&190
n 175&190(recording.start_time != 0 and recording.start_time + recording.max_start_delay < cur_time)[]:
	i: 152(), 174()
	o: 213(t), 235(f)

nname: 174
n 174(None)[]:
	i: 121&136(f)
	o: 175&190()

nname: 152
n 152(None)[recording.status = RECORDING_STATUS_MISSED
bNeedSave = True
continue
]:
	i: 121&136(t)
	o: 175&190()

nname: 121&136
n 121&136(recording.stop_time != 0 and recording.stop_time < cur_time)[]:
	i: 113(), 120()
	o: 152(t), 174(f)

nname: 120
n 120(None)[]:
	i: 89(f)
	o: 121&136()

nname: 113
n 113(None)[continue
]:
	i: 89(t)
	o: 121&136()

nname: 89
n 89(recording.status != RECORDING_STATUS_SCHEDULED)[for id, recording in self.recording_list.recordings.items():
]:
	i: 70(for)
	o: 113(t), 120(f)

nname: 70
n 70(None)[]:
	i: 0(loop)
	o: 89(for), 239(AF)

nname: 0
n 0(None)[timestep('CheckSchedule begin')
self.timer_stoprecording.stop()
self.timer_startrecording.stop()
self.timer_pre_start_alert.stop()
bNeedSave = False
cur_time = self.GetCurrentUTCTime()
]:
	i: 
	o: 70(loop), 240(AL)

nname: 474
n 474(None)[timestep('CheckSchedule end')
return None
]:
	i: 379(JA), 422(), 359(JA), 402()
	o: 

nname: 422
n 422(None)[if rec_to_start != None:
	start_timer = self.getStartTimer(rec_to_start)
	self._RecordScheduler__activeStartTimer(start_timer, rec_to_start.id)
]:
	i: 240(f)
	o: 474()

nname: 402
n 402(None)[self.timer_stoprecording.start(stop_timer)
]:
	i: 303(f)
	o: 474()

nname: 379
n 379(None)[self._RecordScheduler__activeStartTimer(start_timer, rec_to_start.id)
]:
	i: 331(f)
	o: 474(JA)

nname: 359
n 359(None)[self.timer_stoprecording.start(stop_timer)
]:
	i: 331(t)
	o: 474(JA)

nname: 331
n 331(stop_timer <= start_timer)[start_timer = self.getStartTimer(rec_to_start)
]:
	i: 303(t)
	o: 359(t), 379(f)

nname: 303
n 303(rec_to_start != None)[stop_timer = self.getStopTimer(rec_to_stop)
]:
	i: 240(t)
	o: 331(t), 402(f)

nname: 240
n 240(rec_to_stop != None)[if save_list:
	self.SaveRecordingList()
rec_to_start = self.recording_list.GetFirstRecordingToStart()
rec_to_stop = self.recording_list.GetFirstRecordingToStop()
]:
	i: 0(AL), 70(AF), 175&190(f)
	o: 303(t), 422(f)

nname: 175&190
n 175&190(None)[if recording.start_time != 0 and recording.start_time + recording.max_start_delay < cur_time:
	recording.status = RECORDING_STATUS_MISSED
	bNeedSave = True
	continue
	continue
]:
	i: 89()
	o: 240()

nname: 89
n 89(None)[for id, recording in self.recording_list.recordings.items():
if recording.status != RECORDING_STATUS_SCHEDULED:
	continue
if recording.stop_time != 0 and recording.stop_time < cur_time:
	recording.status = RECORDING_STATUS_MISSED
	bNeedSave = True
	continue
]:
	i: 70(for)
	o: 175&190()

nname: 70
n 70(None)[]:
	i: 0(loop)
	o: 89(for), 240(AF)

nname: 0
n 0(None)[timestep('CheckSchedule begin')
self.timer_stoprecording.stop()
self.timer_startrecording.stop()
self.timer_pre_start_alert.stop()
bNeedSave = False
cur_time = self.GetCurrentUTCTime()
]:
	i: 
	o: 70(loop), 240(AL)

nname: 240
n 240(None)[if save_list:
	self.SaveRecordingList()
rec_to_start = self.recording_list.GetFirstRecordingToStart()
rec_to_stop = self.recording_list.GetFirstRecordingToStop()
if rec_to_stop != None:
	stop_timer = self.getStopTimer(rec_to_stop)
	if rec_to_start != None:
		start_timer = self.getStartTimer(rec_to_start)
		if stop_timer <= start_timer:
			self.timer_stoprecording.start(stop_timer)
		else:
			self._RecordScheduler__activeStartTimer(start_timer, rec_to_start.id)
	else:
		self.timer_stoprecording.start(stop_timer)
else:
	if rec_to_start != None:
		start_timer = self.getStartTimer(rec_to_start)
		self._RecordScheduler__activeStartTimer(start_timer, rec_to_start.id)
timestep('CheckSchedule end')
return None
]:
	i: 0(AL), 70(AF), 89(f)
	o: 

nname: 89
n 89(None)[for id, recording in self.recording_list.recordings.items():
if recording.status != RECORDING_STATUS_SCHEDULED:
	continue
if recording.stop_time != 0 and recording.stop_time < cur_time:
	recording.status = RECORDING_STATUS_MISSED
	bNeedSave = True
	continue
if recording.start_time != 0 and recording.start_time + recording.max_start_delay < cur_time:
	recording.status = RECORDING_STATUS_MISSED
	bNeedSave = True
	continue
	continue
]:
	i: 70(for)
	o: 240()

nname: 70
n 70(None)[]:
	i: 0(loop)
	o: 89(for), 240(AF)

nname: 0
n 0(None)[timestep('CheckSchedule begin')
self.timer_stoprecording.stop()
self.timer_startrecording.stop()
self.timer_pre_start_alert.stop()
bNeedSave = False
cur_time = self.GetCurrentUTCTime()
]:
	i: 
	o: 70(loop), 240(AL)

nname: 89
n 89(None)[for id, recording in self.recording_list.recordings.items():
	if recording.status != RECORDING_STATUS_SCHEDULED:
		continue
	if recording.stop_time != 0 and recording.stop_time < cur_time:
		recording.status = RECORDING_STATUS_MISSED
		bNeedSave = True
		continue
	if recording.start_time != 0 and recording.start_time + recording.max_start_delay < cur_time:
		recording.status = RECORDING_STATUS_MISSED
		bNeedSave = True
		continue
		continue
if save_list:
	self.SaveRecordingList()
rec_to_start = self.recording_list.GetFirstRecordingToStart()
rec_to_stop = self.recording_list.GetFirstRecordingToStop()
if rec_to_stop != None:
	stop_timer = self.getStopTimer(rec_to_stop)
	if rec_to_start != None:
		start_timer = self.getStartTimer(rec_to_start)
		if stop_timer <= start_timer:
			self.timer_stoprecording.start(stop_timer)
		else:
			self._RecordScheduler__activeStartTimer(start_timer, rec_to_start.id)
	else:
		self.timer_stoprecording.start(stop_timer)
else:
	if rec_to_start != None:
		start_timer = self.getStartTimer(rec_to_start)
		self._RecordScheduler__activeStartTimer(start_timer, rec_to_start.id)
timestep('CheckSchedule end')
return None
]:
	i: 0(for)
	o: 

nname: 0
n 0(None)[timestep('CheckSchedule begin')
self.timer_stoprecording.stop()
self.timer_startrecording.stop()
self.timer_pre_start_alert.stop()
bNeedSave = False
cur_time = self.GetCurrentUTCTime()
]:
	i: 
	o: 89(for)

nname: 0
n 0(None)[timestep('CheckSchedule begin')
self.timer_stoprecording.stop()
self.timer_startrecording.stop()
self.timer_pre_start_alert.stop()
bNeedSave = False
cur_time = self.GetCurrentUTCTime()
for id, recording in self.recording_list.recordings.items():
	if recording.status != RECORDING_STATUS_SCHEDULED:
		continue
	if recording.stop_time != 0 and recording.stop_time < cur_time:
		recording.status = RECORDING_STATUS_MISSED
		bNeedSave = True
		continue
	if recording.start_time != 0 and recording.start_time + recording.max_start_delay < cur_time:
		recording.status = RECORDING_STATUS_MISSED
		bNeedSave = True
		continue
		continue
if save_list:
	self.SaveRecordingList()
rec_to_start = self.recording_list.GetFirstRecordingToStart()
rec_to_stop = self.recording_list.GetFirstRecordingToStop()
if rec_to_stop != None:
	stop_timer = self.getStopTimer(rec_to_stop)
	if rec_to_start != None:
		start_timer = self.getStartTimer(rec_to_start)
		if stop_timer <= start_timer:
			self.timer_stoprecording.start(stop_timer)
		else:
			self._RecordScheduler__activeStartTimer(start_timer, rec_to_start.id)
	else:
		self.timer_stoprecording.start(stop_timer)
else:
	if rec_to_start != None:
		start_timer = self.getStartTimer(rec_to_start)
		self._RecordScheduler__activeStartTimer(start_timer, rec_to_start.id)
timestep('CheckSchedule end')
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x8b87f2c>}
nname: 91
n 91(None)[]:
	i: 47(), 90()
	o: 

nname: 90
n 90(None)[]:
	i: 0(f)
	o: 91()

nname: 47
n 47(None)[self.timer_pre_start_alert.set_args(id)
self.timer_pre_start_alert.start(t - config.pre_start_alert_delay)
]:
	i: 0(t)
	o: 91()

nname: 0
n 0(t > config.pre_start_alert_delay)[self.timer_startrecording.set_args(id)
self.timer_startrecording.start(t)
]:
	i: 
	o: 47(t), 90(f)

nname: 0
n 0(None)[self.timer_startrecording.set_args(id)
self.timer_startrecording.start(t)
if t > config.pre_start_alert_delay:
	self.timer_pre_start_alert.set_args(id)
	self.timer_pre_start_alert.start(t - config.pre_start_alert_delay)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x8c1898c>}
nname: 273
n 273(None)[return start_timer
]:
	i: 262(), 272()
	o: 

nname: 272
n 272(None)[]:
	i: 250(f)
	o: 273()

nname: 262
n 262(None)[start_timer = 0
]:
	i: 250(t)
	o: 273()

nname: 250
n 250(start_timer < 0)[]:
	i: 165(), 229()
	o: 262(t), 272(f)

nname: 229
n 229(None)[log.info('Start rec id %d now !' % oRecording.id)
]:
	i: 21(f)
	o: 250()

nname: 165
n 165(None)[log.info('Start rec id %d in %d seconds' % (oRecording.id, oRecording.start_time - oRecording.start_padding - cur_time))
start_timer = oRecording.start_time - oRecording.start_padding - cur_time
]:
	i: 21(t)
	o: 250()

nname: 21
n 21(oRecording.start_time - oRecording.start_padding > cur_time)[start_timer = 0
self.timer_startrecording.set_args(oRecording.id)
log.info("Next recording to start : ID = %d, '%s' at '%s' => '%s'!" % (oRecording.id, oRecording.name, self.server.DateTime_UTC2Text(oRecording.start_time), self.server.DateTime_UTC2Text(oRecording.stop_time)))
cur_time = self.GetCurrentUTCTime()
log.info('start_padding = %d' % oRecording.start_padding)
]:
	i: 12(), 20()
	o: 165(t), 229(f)

nname: 20
n 20(None)[]:
	i: 0(f)
	o: 21()

nname: 12
n 12(None)[return None
]:
	i: 0(t)
	o: 21()

nname: 0
n 0(oRecording == None)[]:
	i: 
	o: 12(t), 20(f)

nname: 250
n 250(None)[if start_timer < 0:
	start_timer = 0
return start_timer
]:
	i: 0()
	o: 

nname: 0
n 0(None)[if oRecording == None:
	return None
start_timer = 0
self.timer_startrecording.set_args(oRecording.id)
log.info("Next recording to start : ID = %d, '%s' at '%s' => '%s'!" % (oRecording.id, oRecording.name, self.server.DateTime_UTC2Text(oRecording.start_time), self.server.DateTime_UTC2Text(oRecording.stop_time)))
cur_time = self.GetCurrentUTCTime()
log.info('start_padding = %d' % oRecording.start_padding)
if oRecording.start_time - oRecording.start_padding > cur_time:
	log.info('Start rec id %d in %d seconds' % (oRecording.id, oRecording.start_time - oRecording.start_padding - cur_time))
	start_timer = oRecording.start_time - oRecording.start_padding - cur_time
else:
	log.info('Start rec id %d now !' % oRecording.id)
]:
	i: 
	o: 250()

nname: 0
n 0(None)[if oRecording == None:
	return None
start_timer = 0
self.timer_startrecording.set_args(oRecording.id)
log.info("Next recording to start : ID = %d, '%s' at '%s' => '%s'!" % (oRecording.id, oRecording.name, self.server.DateTime_UTC2Text(oRecording.start_time), self.server.DateTime_UTC2Text(oRecording.stop_time)))
cur_time = self.GetCurrentUTCTime()
log.info('start_padding = %d' % oRecording.start_padding)
if oRecording.start_time - oRecording.start_padding > cur_time:
	log.info('Start rec id %d in %d seconds' % (oRecording.id, oRecording.start_time - oRecording.start_padding - cur_time))
	start_timer = oRecording.start_time - oRecording.start_padding - cur_time
else:
	log.info('Start rec id %d now !' % oRecording.id)
if start_timer < 0:
	start_timer = 0
return start_timer
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x8b7e94c>}
nname: 273
n 273(None)[return stop_timer
]:
	i: 262(), 272()
	o: 

nname: 272
n 272(None)[]:
	i: 250(f)
	o: 273()

nname: 262
n 262(None)[stop_timer = 0
]:
	i: 250(t)
	o: 273()

nname: 250
n 250(stop_timer < 0)[]:
	i: 165(), 229()
	o: 262(t), 272(f)

nname: 229
n 229(None)[log.info('Stop rec id %d now !' % oRecording.id)
]:
	i: 21(f)
	o: 250()

nname: 165
n 165(None)[log.info('Stop rec id %d in %d seconds' % (oRecording.id, oRecording.stop_time + oRecording.stop_padding - cur_time))
stop_timer = oRecording.stop_time + oRecording.stop_padding - cur_time
]:
	i: 21(t)
	o: 250()

nname: 21
n 21(oRecording.stop_time + oRecording.stop_padding > cur_time)[self.timer_stoprecording.set_args(oRecording.id)
stop_timer = 0
log.info("Next recording to stop : ID = %d '%s' at '%s' => '%s'!" % (oRecording.id, oRecording.name, self.server.DateTime_UTC2Text(oRecording.start_time), self.server.DateTime_UTC2Text(oRecording.stop_time)))
cur_time = self.GetCurrentUTCTime()
log.info('stop_padding = %d' % oRecording.stop_padding)
]:
	i: 12(), 20()
	o: 165(t), 229(f)

nname: 20
n 20(None)[]:
	i: 0(f)
	o: 21()

nname: 12
n 12(None)[return None
]:
	i: 0(t)
	o: 21()

nname: 0
n 0(oRecording == None)[]:
	i: 
	o: 12(t), 20(f)

nname: 250
n 250(None)[if stop_timer < 0:
	stop_timer = 0
return stop_timer
]:
	i: 0()
	o: 

nname: 0
n 0(None)[if oRecording == None:
	return None
self.timer_stoprecording.set_args(oRecording.id)
stop_timer = 0
log.info("Next recording to stop : ID = %d '%s' at '%s' => '%s'!" % (oRecording.id, oRecording.name, self.server.DateTime_UTC2Text(oRecording.start_time), self.server.DateTime_UTC2Text(oRecording.stop_time)))
cur_time = self.GetCurrentUTCTime()
log.info('stop_padding = %d' % oRecording.stop_padding)
if oRecording.stop_time + oRecording.stop_padding > cur_time:
	log.info('Stop rec id %d in %d seconds' % (oRecording.id, oRecording.stop_time + oRecording.stop_padding - cur_time))
	stop_timer = oRecording.stop_time + oRecording.stop_padding - cur_time
else:
	log.info('Stop rec id %d now !' % oRecording.id)
]:
	i: 
	o: 250()

nname: 0
n 0(None)[if oRecording == None:
	return None
self.timer_stoprecording.set_args(oRecording.id)
stop_timer = 0
log.info("Next recording to stop : ID = %d '%s' at '%s' => '%s'!" % (oRecording.id, oRecording.name, self.server.DateTime_UTC2Text(oRecording.start_time), self.server.DateTime_UTC2Text(oRecording.stop_time)))
cur_time = self.GetCurrentUTCTime()
log.info('stop_padding = %d' % oRecording.stop_padding)
if oRecording.stop_time + oRecording.stop_padding > cur_time:
	log.info('Stop rec id %d in %d seconds' % (oRecording.id, oRecording.stop_time + oRecording.stop_padding - cur_time))
	stop_timer = oRecording.stop_time + oRecording.stop_padding - cur_time
else:
	log.info('Stop rec id %d now !' % oRecording.id)
if stop_timer < 0:
	stop_timer = 0
return stop_timer
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x8b871cc>}
nname: 92
n 92(None)[]:
	i: 3(), 45(), 90(AE)
	o: 

nname: 90
n 90(None)[]:
	i: 35(f)
	o: 92(AE)

nname: 45
n 45(None)[#, e
log.critical('NotifyRecordingStatusChange FAILED => continue anyway')
log.critical('EXCEPTION ' + str(e))
]:
	i: 35(t)
	o: 92()

nname: 35
n 35(<dummy_ex3> EXC_MATCH BaseException)[]:
	i: 0(except)
	o: 45(t), 90(f)

nname: 3
n 3(None)[Callbacks().recording_event.notify(nEventType, oRecording, inconflict_recordings, live_to_stop_list)
]:
	i: 0(try)
	o: 92()

nname: 0
n 0(None)[]:
	i: 
	o: 3(try), 35(except)

nname: 35
n 35(None)[except BaseException, e:
	log.critical('NotifyRecordingStatusChange FAILED => continue anyway')
	log.critical('EXCEPTION ' + str(e))
]:
	i: 0()
	o: 

nname: 0
n 0(None)[try:
	Callbacks().recording_event.notify(nEventType, oRecording, inconflict_recordings, live_to_stop_list)
]:
	i: 
	o: 35()

nname: 0
n 0(None)[try:
	Callbacks().recording_event.notify(nEventType, oRecording, inconflict_recordings, live_to_stop_list)
except BaseException, e:
	log.critical('NotifyRecordingStatusChange FAILED => continue anyway')
	log.critical('EXCEPTION ' + str(e))
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x8c18fcc>}
nname: 209
n 209(None)[return bResult
]:
	i: 166(), 189()
	o: 

nname: 189
n 189(None)[self.NotifyRecordingStatusChange(RECORDING_EVENT_RECORD_STOPPED, recording, None)
]:
	i: 151(f)
	o: 209()

nname: 166
n 166(None)[self.NotifyRecordingStatusChange(RECORDING_EVENT_RECORD_MACROVISION_STOP_ERROR, recording, None)
]:
	i: 151(t)
	o: 209()

nname: 151
n 151(recording.status == RECORDING_STATUS_MACROVISION)[]:
	i: 111(), 137()
	o: 166(t), 189(f)

nname: 137
n 137(None)[log.debug('SetMaxPowerState APM_STATE_OFF not colald because some recordings are running')
]:
	i: 53(t)
	o: 151()

nname: 111
n 111(None)[self.ext_standby.SetMaxPowerState(config.wystandby_id, APM_STATE_OFF)
]:
	i: 53(f)
	o: 151()

nname: 53
n 53(self.IsSomeRecordingRunning())[cur_time = self.GetCurrentUTCTime()
bResult = recording.Stop(cur_time, stop_at_player_pos, self.dbus_api)
self.CheckSchedule()
]:
	i: 27(), 52()
	o: 111(f), 137(t)

nname: 52
n 52(None)[]:
	i: 0(f)
	o: 53()

nname: 27
n 27(None)[log.error('StopRecording: Recording %d not found !' % nRecordingID)
return False
]:
	i: 0(t)
	o: 53()

nname: 0
n 0(recording == None)[recording = self.GetRecording(nRecordingID)
]:
	i: 
	o: 27(t), 52(f)

nname: 151
n 151(None)[if recording.status == RECORDING_STATUS_MACROVISION:
	self.NotifyRecordingStatusChange(RECORDING_EVENT_RECORD_MACROVISION_STOP_ERROR, recording, None)
else:
	self.NotifyRecordingStatusChange(RECORDING_EVENT_RECORD_STOPPED, recording, None)
return bResult
]:
	i: 0()
	o: 

nname: 0
n 0(None)[recording = self.GetRecording(nRecordingID)
if recording == None:
	log.error('StopRecording: Recording %d not found !' % nRecordingID)
	return False
cur_time = self.GetCurrentUTCTime()
bResult = recording.Stop(cur_time, stop_at_player_pos, self.dbus_api)
self.CheckSchedule()
if not self.IsSomeRecordingRunning():
	self.ext_standby.SetMaxPowerState(config.wystandby_id, APM_STATE_OFF)
else:
	log.debug('SetMaxPowerState APM_STATE_OFF not colald because some recordings are running')
]:
	i: 
	o: 151()

nname: 0
n 0(None)[recording = self.GetRecording(nRecordingID)
if recording == None:
	log.error('StopRecording: Recording %d not found !' % nRecordingID)
	return False
cur_time = self.GetCurrentUTCTime()
bResult = recording.Stop(cur_time, stop_at_player_pos, self.dbus_api)
self.CheckSchedule()
if not self.IsSomeRecordingRunning():
	self.ext_standby.SetMaxPowerState(config.wystandby_id, APM_STATE_OFF)
else:
	log.debug('SetMaxPowerState APM_STATE_OFF not colald because some recordings are running')
if recording.status == RECORDING_STATUS_MACROVISION:
	self.NotifyRecordingStatusChange(RECORDING_EVENT_RECORD_MACROVISION_STOP_ERROR, recording, None)
else:
	self.NotifyRecordingStatusChange(RECORDING_EVENT_RECORD_STOPPED, recording, None)
return bResult
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x8b7ec2c>}
nname: 328
n 328(None)[newrecording.status = RECORDING_STATUS_SCHEDULED
self.CheckSchedule(False)
return {'status': error.WYRECORD_SUCCESS, 'recording_id': newrecording.id, 'stop_time': newrecording.stop_time, 'conflict': conflict}
]:
	i: 285(), 327()
	o: 

nname: 327
n 327(None)[]:
	i: 248(t)
	o: 328()

nname: 285
n 285(None)[log.error('Can not add recording in list')
return {'status': error.WYRECORD_UNKNOWN_ERROR, 'recording_id': RECORDING_ID_NULL}
]:
	i: 248(f)
	o: 328()

nname: 248
n 248(self.recording_list.AddRecording(newrecording))[newrecording.MarkAsInstantRecording()
newrecording.type = RECORDING_TYPE_NOT_SCHEDULED
]:
	i: 171(JA), 219(JA), 243(), 247()
	o: 285(f), 327(t)

nname: 247
n 247(None)[]:
	i: 100(f)
	o: 248()

nname: 243
n 243(None)[]:
	i: 209(f)
	o: 248()

nname: 219
n 219(None)[newrecording.stop_time = conflict.valid_start_stop_list[0][1]
]:
	i: 209(t)
	o: 248(JA)

nname: 209
n 209(config.auto_adjust_instant_record_stop_time)[]:
	i: 158(t)
	o: 219(t), 243(f)

nname: 171
n 171(None)[return {'status': error.WYRECORD_SCHEDULE_CONFLICT, 'recording_id': RECORDING_ID_NULL, 'conflict': conflict}
]:
	i: 158(f)
	o: 248(JA)

nname: 158
n 158(conflict.isStartTimeValid())[]:
	i: 100(t)
	o: 171(f), 209(t)

nname: 100
n 100(conflict)[newrecording = res['new_rec']
newrecording.start_padding = 0
newrecording.stop_padding = 0
conflict = self.recording_list.GetConflictForNotScheduledRecording(newrecording, include_instant_record=True)
]:
	i: 91(), 99()
	o: 158(t), 247(f)

nname: 99
n 99(None)[]:
	i: 45(f)
	o: 100()

nname: 91
n 91(None)[return res
]:
	i: 45(t)
	o: 100()

nname: 45
n 45(res['status'] != error.WYRECORD_SUCCESS)[res = self._initialyseNewRec(nServiceID, current_time, end_time, name, nForcedDeviceID)
]:
	i: 24(), 38()
	o: 91(t), 99(f)

nname: 38
n 38(None)[end_time = 0
]:
	i: 0(f)
	o: 45()

nname: 24
n 24(None)[end_time = current_time + duration
]:
	i: 0(t)
	o: 45()

nname: 0
n 0(duration != 0)[current_time = self.GetCurrentUTCTime()
]:
	i: 
	o: 24(t), 38(f)

nname: 328
n 328(None)[newrecording.status = RECORDING_STATUS_SCHEDULED
self.CheckSchedule(False)
return {'status': error.WYRECORD_SUCCESS, 'recording_id': newrecording.id, 'stop_time': newrecording.stop_time, 'conflict': conflict}
]:
	i: 100()
	o: 

nname: 100
n 100(None)[newrecording = res['new_rec']
newrecording.start_padding = 0
newrecording.stop_padding = 0
conflict = self.recording_list.GetConflictForNotScheduledRecording(newrecording, include_instant_record=True)
if conflict:
	if not conflict.isStartTimeValid():
		return {'status': error.WYRECORD_SCHEDULE_CONFLICT, 'recording_id': RECORDING_ID_NULL, 'conflict': conflict}
	else:
		if config.auto_adjust_instant_record_stop_time:
			newrecording.stop_time = conflict.valid_start_stop_list[0][1]
newrecording.MarkAsInstantRecording()
newrecording.type = RECORDING_TYPE_NOT_SCHEDULED
if not self.recording_list.AddRecording(newrecording):
	log.error('Can not add recording in list')
	return {'status': error.WYRECORD_UNKNOWN_ERROR, 'recording_id': RECORDING_ID_NULL}
]:
	i: 0()
	o: 328()

nname: 0
n 0(None)[current_time = self.GetCurrentUTCTime()
if duration != 0:
	end_time = current_time + duration
else:
	end_time = 0
res = self._initialyseNewRec(nServiceID, current_time, end_time, name, nForcedDeviceID)
if res['status'] != error.WYRECORD_SUCCESS:
	return res
]:
	i: 
	o: 100()

nname: 328
n 328(None)[newrecording.status = RECORDING_STATUS_SCHEDULED
self.CheckSchedule(False)
return {'status': error.WYRECORD_SUCCESS, 'recording_id': newrecording.id, 'stop_time': newrecording.stop_time, 'conflict': conflict}
]:
	i: 0()
	o: 

nname: 0
n 0(None)[current_time = self.GetCurrentUTCTime()
if duration != 0:
	end_time = current_time + duration
else:
	end_time = 0
res = self._initialyseNewRec(nServiceID, current_time, end_time, name, nForcedDeviceID)
if res['status'] != error.WYRECORD_SUCCESS:
	return res
newrecording = res['new_rec']
newrecording.start_padding = 0
newrecording.stop_padding = 0
conflict = self.recording_list.GetConflictForNotScheduledRecording(newrecording, include_instant_record=True)
if conflict:
	if not conflict.isStartTimeValid():
		return {'status': error.WYRECORD_SCHEDULE_CONFLICT, 'recording_id': RECORDING_ID_NULL, 'conflict': conflict}
	else:
		if config.auto_adjust_instant_record_stop_time:
			newrecording.stop_time = conflict.valid_start_stop_list[0][1]
newrecording.MarkAsInstantRecording()
newrecording.type = RECORDING_TYPE_NOT_SCHEDULED
if not self.recording_list.AddRecording(newrecording):
	log.error('Can not add recording in list')
	return {'status': error.WYRECORD_UNKNOWN_ERROR, 'recording_id': RECORDING_ID_NULL}
]:
	i: 
	o: 328()

nname: 0
n 0(None)[current_time = self.GetCurrentUTCTime()
if duration != 0:
	end_time = current_time + duration
else:
	end_time = 0
res = self._initialyseNewRec(nServiceID, current_time, end_time, name, nForcedDeviceID)
if res['status'] != error.WYRECORD_SUCCESS:
	return res
newrecording = res['new_rec']
newrecording.start_padding = 0
newrecording.stop_padding = 0
conflict = self.recording_list.GetConflictForNotScheduledRecording(newrecording, include_instant_record=True)
if conflict:
	if not conflict.isStartTimeValid():
		return {'status': error.WYRECORD_SCHEDULE_CONFLICT, 'recording_id': RECORDING_ID_NULL, 'conflict': conflict}
	else:
		if config.auto_adjust_instant_record_stop_time:
			newrecording.stop_time = conflict.valid_start_stop_list[0][1]
newrecording.MarkAsInstantRecording()
newrecording.type = RECORDING_TYPE_NOT_SCHEDULED
if not self.recording_list.AddRecording(newrecording):
	log.error('Can not add recording in list')
	return {'status': error.WYRECORD_UNKNOWN_ERROR, 'recording_id': RECORDING_ID_NULL}
newrecording.status = RECORDING_STATUS_SCHEDULED
self.CheckSchedule(False)
return {'status': error.WYRECORD_SUCCESS, 'recording_id': newrecording.id, 'stop_time': newrecording.stop_time, 'conflict': conflict}
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x8c1fe8c>}
nname: 466
n 466(None)[return newrecording
]:
	i: 449(), 465()
	o: 

nname: 465
n 465(None)[]:
	i: 443(f)
	o: 466()

nname: 449
n 449(None)[raise SchedulerConflictWithInstantRecordError(conflict)
]:
	i: 443(t)
	o: 466()

nname: 443
n 443(conflict)[]:
	i: 428(), 442()
	o: 449(t), 465(f)

nname: 442
n 442(None)[]:
	i: 422(f)
	o: 443()

nname: 428
n 428(None)[self.CheckSchedule()
]:
	i: 422(t)
	o: 443()

nname: 422
n 422(check_schedule)[]:
	i: 372(), 421()
	o: 428(t), 442(f)

nname: 421
n 421(None)[]:
	i: 347&362(f)
	o: 422()

nname: 372
n 372(None)[instant_rec_in_conflict.stop_time = newrecording.start_time
log.debug('### new instant record duration is: ' + str(instant_rec_in_conflict.stop_time - instant_rec_in_conflict.start_time))
]:
	i: 347&362(t)
	o: 422()

nname: 347&362
n 347&362(instant_rec_in_conflict and config.auto_adjust_instant_record_stop_time)[newrecording.status = RECORDING_STATUS_SCHEDULED
]:
	i: 333(), 346()
	o: 372(t), 421(f)

nname: 346
n 346(None)[]:
	i: 309(t)
	o: 347&362()

nname: 333
n 333(None)[raise SchedulerOtherError()
]:
	i: 309(f)
	o: 347&362()

nname: 309
n 309(self.recording_list.AddRecording(newrecording, program_id, favorite))[]:
	i: 243(AL), 304(), 308()
	o: 333(f), 346(t)

nname: 308
n 308(None)[]:
	i: 197(f)
	o: 309()

nname: 304
n 304(None)[]:
	i: 247(AF), 294()
	o: 309()

nname: 294
n 294(None)[instant_rec_in_conflict = rec
]:
	i: 260(f), 278()
	o: 304()

nname: 278
n 278(None)[raise SchedulerConflictError(conflict)
continue
]:
	i: 260(t)
	o: 294()

nname: 260
n 260(rec.type != RECORDING_TYPE_NOT_SCHEDULED)[for rec in conflict.getAllRecInConflict():
]:
	i: 247(for)
	o: 278(t), 294(f)

nname: 247
n 247(None)[]:
	i: 243(loop)
	o: 260(for), 304(AF)

nname: 243
n 243(None)[]:
	i: 197(t)
	o: 247(loop), 309(AL)

nname: 197
n 197(conflict)[newrecording = res['new_rec']
conflict = self.recording_list.GetConflictForNotScheduledRecording(newrecording, include_instant_record=True)
instant_rec_in_conflict = None
]:
	i: 100(JA), 132(JA), 164(JA), 183(), 196()
	o: 243(t), 308(f)

nname: 196
n 196(None)[]:
	i: 26(f)
	o: 197()

nname: 183
n 183(None)[raise SchedulerOtherError()
]:
	i: 148(f)
	o: 197()

nname: 164
n 164(None)[raise SchedulerForcedDeviceNotValidError(nServiceID, nForcedDeviceID)
]:
	i: 148(t)
	o: 197(JA)

nname: 148
n 148(status == error.WYRECORD_FORCED_DEVICE_INVALID)[]:
	i: 116(f)
	o: 164(t), 183(f)

nname: 132
n 132(None)[raise SchedulerNoDeviceForServiceError(nServiceID)
]:
	i: 116(t)
	o: 197(JA)

nname: 116
n 116(status == error.WYRECORD_NO_DEVICE_FOR_SERVICE)[]:
	i: 84(f)
	o: 132(t), 148(f)

nname: 100
n 100(None)[raise SchedulerBadServiceIdError(nServiceID)
]:
	i: 84(t)
	o: 197(JA)

nname: 84
n 84(status == error.WYRECORD_BAD_SERVICE_ID)[]:
	i: 26(t)
	o: 100(t), 116(f)

nname: 26
n 26(status != error.WYRECORD_SUCCESS)[res = self._initialyseNewRec(nServiceID, nStartTime, nStopTime, strRecordingName, nForcedDeviceID, start_padding, stop_padding)
status = res['status']
]:
	i: 12(), 25()
	o: 84(t), 196(f)

nname: 25
n 25(None)[]:
	i: 0(f)
	o: 26()

nname: 12
n 12(None)[raise SchedulerOtherError()
]:
	i: 0(t)
	o: 26()

nname: 0
n 0(nStartTime >= nStopTime)[]:
	i: 
	o: 12(t), 25(f)

nname: 466
n 466(None)[return newrecording
]:
	i: 422()
	o: 

nname: 422
n 422(None)[if check_schedule:
	self.CheckSchedule()
if conflict:
	raise SchedulerConflictWithInstantRecordError(conflict)
]:
	i: 309()
	o: 466()

nname: 309
n 309(None)[if not self.recording_list.AddRecording(newrecording, program_id, favorite):
	raise SchedulerOtherError()
newrecording.status = RECORDING_STATUS_SCHEDULED
if instant_rec_in_conflict and config.auto_adjust_instant_record_stop_time:
	instant_rec_in_conflict.stop_time = newrecording.start_time
	log.debug('### new instant record duration is: ' + str(instant_rec_in_conflict.stop_time - instant_rec_in_conflict.start_time))
]:
	i: 243(AL), 247(AF), 260(), 197(f)
	o: 422()

nname: 260
n 260(None)[for rec in conflict.getAllRecInConflict():
if rec.type != RECORDING_TYPE_NOT_SCHEDULED:
	raise SchedulerConflictError(conflict)
	continue
instant_rec_in_conflict = rec
]:
	i: 247(for)
	o: 309()

nname: 247
n 247(None)[]:
	i: 243(loop)
	o: 260(for), 309(AF)

nname: 243
n 243(None)[]:
	i: 197(t)
	o: 247(loop), 309(AL)

nname: 197
n 197(conflict)[newrecording = res['new_rec']
conflict = self.recording_list.GetConflictForNotScheduledRecording(newrecording, include_instant_record=True)
instant_rec_in_conflict = None
]:
	i: 0(JA)
	o: 243(t), 309(f)

nname: 0
n 0(None)[if nStartTime >= nStopTime:
	raise SchedulerOtherError()
res = self._initialyseNewRec(nServiceID, nStartTime, nStopTime, strRecordingName, nForcedDeviceID, start_padding, stop_padding)
status = res['status']
if status != error.WYRECORD_SUCCESS:
	if status == error.WYRECORD_BAD_SERVICE_ID:
		raise SchedulerBadServiceIdError(nServiceID)
	else:
		if status == error.WYRECORD_NO_DEVICE_FOR_SERVICE:
			raise SchedulerNoDeviceForServiceError(nServiceID)
		else:
			if status == error.WYRECORD_FORCED_DEVICE_INVALID:
				raise SchedulerForcedDeviceNotValidError(nServiceID, nForcedDeviceID)
			else:
				raise SchedulerOtherError()
]:
	i: 
	o: 197(JA)

nname: 466
n 466(None)[return newrecording
]:
	i: 309()
	o: 

nname: 309
n 309(None)[if not self.recording_list.AddRecording(newrecording, program_id, favorite):
	raise SchedulerOtherError()
newrecording.status = RECORDING_STATUS_SCHEDULED
if instant_rec_in_conflict and config.auto_adjust_instant_record_stop_time:
	instant_rec_in_conflict.stop_time = newrecording.start_time
	log.debug('### new instant record duration is: ' + str(instant_rec_in_conflict.stop_time - instant_rec_in_conflict.start_time))
if check_schedule:
	self.CheckSchedule()
if conflict:
	raise SchedulerConflictWithInstantRecordError(conflict)
]:
	i: 260(), 0(f)
	o: 466()

nname: 260
n 260(None)[for rec in conflict.getAllRecInConflict():
	if rec.type != RECORDING_TYPE_NOT_SCHEDULED:
		raise SchedulerConflictError(conflict)
		continue
	instant_rec_in_conflict = rec
]:
	i: 243(for)
	o: 309()

nname: 243
n 243(None)[]:
	i: 0(t)
	o: 260(for)

nname: 0
n 0(conflict)[if nStartTime >= nStopTime:
	raise SchedulerOtherError()
res = self._initialyseNewRec(nServiceID, nStartTime, nStopTime, strRecordingName, nForcedDeviceID, start_padding, stop_padding)
status = res['status']
if status != error.WYRECORD_SUCCESS:
	if status == error.WYRECORD_BAD_SERVICE_ID:
		raise SchedulerBadServiceIdError(nServiceID)
	else:
		if status == error.WYRECORD_NO_DEVICE_FOR_SERVICE:
			raise SchedulerNoDeviceForServiceError(nServiceID)
		else:
			if status == error.WYRECORD_FORCED_DEVICE_INVALID:
				raise SchedulerForcedDeviceNotValidError(nServiceID, nForcedDeviceID)
			else:
				raise SchedulerOtherError()
newrecording = res['new_rec']
conflict = self.recording_list.GetConflictForNotScheduledRecording(newrecording, include_instant_record=True)
instant_rec_in_conflict = None
]:
	i: 
	o: 243(t), 309(f)

nname: 309
n 309(None)[if not self.recording_list.AddRecording(newrecording, program_id, favorite):
	raise SchedulerOtherError()
newrecording.status = RECORDING_STATUS_SCHEDULED
if instant_rec_in_conflict and config.auto_adjust_instant_record_stop_time:
	instant_rec_in_conflict.stop_time = newrecording.start_time
	log.debug('### new instant record duration is: ' + str(instant_rec_in_conflict.stop_time - instant_rec_in_conflict.start_time))
if check_schedule:
	self.CheckSchedule()
if conflict:
	raise SchedulerConflictWithInstantRecordError(conflict)
return newrecording
]:
	i: 243(), 0(f)
	o: 

nname: 243
n 243(None)[for rec in conflict.getAllRecInConflict():
	if rec.type != RECORDING_TYPE_NOT_SCHEDULED:
		raise SchedulerConflictError(conflict)
		continue
	instant_rec_in_conflict = rec
]:
	i: 0(t)
	o: 309()

nname: 0
n 0(conflict)[if nStartTime >= nStopTime:
	raise SchedulerOtherError()
res = self._initialyseNewRec(nServiceID, nStartTime, nStopTime, strRecordingName, nForcedDeviceID, start_padding, stop_padding)
status = res['status']
if status != error.WYRECORD_SUCCESS:
	if status == error.WYRECORD_BAD_SERVICE_ID:
		raise SchedulerBadServiceIdError(nServiceID)
	else:
		if status == error.WYRECORD_NO_DEVICE_FOR_SERVICE:
			raise SchedulerNoDeviceForServiceError(nServiceID)
		else:
			if status == error.WYRECORD_FORCED_DEVICE_INVALID:
				raise SchedulerForcedDeviceNotValidError(nServiceID, nForcedDeviceID)
			else:
				raise SchedulerOtherError()
newrecording = res['new_rec']
conflict = self.recording_list.GetConflictForNotScheduledRecording(newrecording, include_instant_record=True)
instant_rec_in_conflict = None
]:
	i: 
	o: 243(t), 309(f)

nname: 0
n 0(None)[if nStartTime >= nStopTime:
	raise SchedulerOtherError()
res = self._initialyseNewRec(nServiceID, nStartTime, nStopTime, strRecordingName, nForcedDeviceID, start_padding, stop_padding)
status = res['status']
if status != error.WYRECORD_SUCCESS:
	if status == error.WYRECORD_BAD_SERVICE_ID:
		raise SchedulerBadServiceIdError(nServiceID)
	else:
		if status == error.WYRECORD_NO_DEVICE_FOR_SERVICE:
			raise SchedulerNoDeviceForServiceError(nServiceID)
		else:
			if status == error.WYRECORD_FORCED_DEVICE_INVALID:
				raise SchedulerForcedDeviceNotValidError(nServiceID, nForcedDeviceID)
			else:
				raise SchedulerOtherError()
newrecording = res['new_rec']
conflict = self.recording_list.GetConflictForNotScheduledRecording(newrecording, include_instant_record=True)
instant_rec_in_conflict = None
if conflict:
	for rec in conflict.getAllRecInConflict():
		if rec.type != RECORDING_TYPE_NOT_SCHEDULED:
			raise SchedulerConflictError(conflict)
			continue
		instant_rec_in_conflict = rec
if not self.recording_list.AddRecording(newrecording, program_id, favorite):
	raise SchedulerOtherError()
newrecording.status = RECORDING_STATUS_SCHEDULED
if instant_rec_in_conflict and config.auto_adjust_instant_record_stop_time:
	instant_rec_in_conflict.stop_time = newrecording.start_time
	log.debug('### new instant record duration is: ' + str(instant_rec_in_conflict.stop_time - instant_rec_in_conflict.start_time))
if check_schedule:
	self.CheckSchedule()
if conflict:
	raise SchedulerConflictWithInstantRecordError(conflict)
return newrecording
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x8c1f58c>}
nname: 357
n 357(None)[return {'status': error.WYRECORD_SUCCESS, 'new_rec': newrecording}
]:
	i: 343(), 356()
	o: 

nname: 356
n 356(None)[]:
	i: 331(f)
	o: 357()

nname: 343
n 343(None)[]:
	i: 331(t)
	o: 357()

nname: 331
n 331(nStartTime == 0)[]:
	i: 317(), 330()
	o: 343(t), 356(f)

nname: 330
n 330(None)[]:
	i: 305(f)
	o: 331()

nname: 317
n 317(None)[]:
	i: 305(t)
	o: 331()

nname: 305
n 305(stop_padding < 0)[]:
	i: 291(), 304()
	o: 317(t), 330(f)

nname: 304
n 304(None)[]:
	i: 256(f)
	o: 305()

nname: 291
n 291(None)[]:
	i: 256(t)
	o: 305()

nname: 256
n 256(start_padding < 0)[log.info('deviceids ' + str(deviceids))
]:
	i: 243(), 255()
	o: 291(t), 304(f)

nname: 255
n 255(None)[]:
	i: 165(f)
	o: 256()

nname: 243
n 243(None)[]:
	i: 196(), 242()
	o: 256()

nname: 242
n 242(None)[]:
	i: 183(f)
	o: 243()

nname: 196
n 196(None)[log.warning('ScheduleRecording : Wanted deviceid %d for recording not possible ath this moment !!' % nForcedDeviceID)
return {'status': error.WYRECORD_FORCED_DEVICE_INVALID, 'recording_id': RECORDING_ID_NULL}
]:
	i: 183(t)
	o: 243()

nname: 183
n 183(nForcedDeviceID not in deviceids)[]:
	i: 165(t)
	o: 196(t), 242(f)

nname: 165
n 165(nForcedDeviceID != 0)[del _[1]
for deviceids in devices:
]:
	i: 135(AF), 149()
	o: 183(t), 255(f)

nname: 149
n 149(None)[for device in devices:
]:
	i: 135(for)
	o: 165()

nname: 135
n 135(None)[]:
	i: 114(), 134()
	o: 149(for), 165(AF)

nname: 134
n 134(None)[]:
	i: 75(f)
	o: 135()

nname: 114
n 114(None)[return {'status': error.WYRECORD_NO_DEVICE_FOR_SERVICE}
]:
	i: 75(t)
	o: 135()

nname: 75
n 75(len(devices) == 0)[devices = self.recording_launcher.GetPlayableServiceDevices(service.id)
]:
	i: 54(), 74()
	o: 114(t), 134(f)

nname: 74
n 74(None)[]:
	i: 0(f)
	o: 75()

nname: 54
n 54(None)[return {'status': error.WYRECORD_BAD_SERVICE_ID}
]:
	i: 0(t)
	o: 75()

nname: 0
n 0(service == None)[nStartTime = int(nStartTime)
nStopTime = int(nStopTime)
service = self.recording_launcher.GetService(nServiceID)
]:
	i: 
	o: 54(t), 74(f)

nname: 331
n 331(None)[if nStartTime == 0:
	pass
return {'status': error.WYRECORD_SUCCESS, 'new_rec': newrecording}
]:
	i: 256()
	o: 

nname: 256
n 256(None)[log.info('deviceids ' + str(deviceids))
if start_padding < 0:
	pass
if stop_padding < 0:
	pass
]:
	i: 183(), 165(f)
	o: 331()

nname: 183
n 183(None)[if nForcedDeviceID not in deviceids:
	log.warning('ScheduleRecording : Wanted deviceid %d for recording not possible ath this moment !!' % nForcedDeviceID)
	return {'status': error.WYRECORD_FORCED_DEVICE_INVALID, 'recording_id': RECORDING_ID_NULL}
]:
	i: 165(t)
	o: 256()

nname: 165
n 165(nForcedDeviceID != 0)[del _[1]
for deviceids in devices:
]:
	i: 135(AF), 149()
	o: 183(t), 256(f)

nname: 149
n 149(None)[for device in devices:
]:
	i: 135(for)
	o: 165()

nname: 135
n 135(None)[]:
	i: 0()
	o: 149(for), 165(AF)

nname: 0
n 0(None)[nStartTime = int(nStartTime)
nStopTime = int(nStopTime)
service = self.recording_launcher.GetService(nServiceID)
if service == None:
	return {'status': error.WYRECORD_BAD_SERVICE_ID}
devices = self.recording_launcher.GetPlayableServiceDevices(service.id)
if len(devices) == 0:
	return {'status': error.WYRECORD_NO_DEVICE_FOR_SERVICE}
]:
	i: 
	o: 135()

nname: 331
n 331(None)[if nStartTime == 0:
	pass
return {'status': error.WYRECORD_SUCCESS, 'new_rec': newrecording}
]:
	i: 165()
	o: 

nname: 165
n 165(None)[del _[1]
for deviceids in devices:
if nForcedDeviceID != 0:
	if nForcedDeviceID not in deviceids:
		log.warning('ScheduleRecording : Wanted deviceid %d for recording not possible ath this moment !!' % nForcedDeviceID)
		return {'status': error.WYRECORD_FORCED_DEVICE_INVALID, 'recording_id': RECORDING_ID_NULL}
log.info('deviceids ' + str(deviceids))
if start_padding < 0:
	pass
if stop_padding < 0:
	pass
]:
	i: 0(AF), 149()
	o: 331()

nname: 149
n 149(None)[for device in devices:
]:
	i: 0(for)
	o: 165()

nname: 0
n 0(None)[nStartTime = int(nStartTime)
nStopTime = int(nStopTime)
service = self.recording_launcher.GetService(nServiceID)
if service == None:
	return {'status': error.WYRECORD_BAD_SERVICE_ID}
devices = self.recording_launcher.GetPlayableServiceDevices(service.id)
if len(devices) == 0:
	return {'status': error.WYRECORD_NO_DEVICE_FOR_SERVICE}
]:
	i: 
	o: 149(for), 165(AF)

nname: 165
n 165(None)[del _[1]
for deviceids in devices:
if nForcedDeviceID != 0:
	if nForcedDeviceID not in deviceids:
		log.warning('ScheduleRecording : Wanted deviceid %d for recording not possible ath this moment !!' % nForcedDeviceID)
		return {'status': error.WYRECORD_FORCED_DEVICE_INVALID, 'recording_id': RECORDING_ID_NULL}
log.info('deviceids ' + str(deviceids))
if start_padding < 0:
	pass
if stop_padding < 0:
	pass
if nStartTime == 0:
	pass
return {'status': error.WYRECORD_SUCCESS, 'new_rec': newrecording}
]:
	i: 0(AF), 149()
	o: 

nname: 149
n 149(None)[for device in devices:
]:
	i: 0(for)
	o: 165()

nname: 0
n 0(None)[nStartTime = int(nStartTime)
nStopTime = int(nStopTime)
service = self.recording_launcher.GetService(nServiceID)
if service == None:
	return {'status': error.WYRECORD_BAD_SERVICE_ID}
devices = self.recording_launcher.GetPlayableServiceDevices(service.id)
if len(devices) == 0:
	return {'status': error.WYRECORD_NO_DEVICE_FOR_SERVICE}
]:
	i: 
	o: 149(for), 165(AF)

self.nodes: {0: <unpyclib.structure.node instance at 0x8b87d6c>, 149: <unpyclib.structure.node instance at 0x8b8766c>, 165: <unpyclib.structure.node instance at 0x8b8736c>}
nname: 0
n 0(None)[return self.recording_list.RemoveRecording(nRecordingID, True)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x8c183cc>}
nname: 0
n 0(None)[return self.recording_list.RemoveRecord(oRecordInfo, True)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x8c1842c>}
nname: 165
n 165(None)[return {'status': error.WYRECORD_SUCCESS, 'max_stop_time': max_stop_time}
]:
	i: 107(JA), 128(), 164()
	o: 

nname: 164
n 164(None)[]:
	i: 64(f)
	o: 165()

nname: 128
n 128(None)[log.critical('recording list corrupted, Recording ID %d !', nRecordingID)
return {'status': error.WYRECORD_RECORDING_LIST_CORRUPTED}
]:
	i: 94(f)
	o: 165()

nname: 107
n 107(None)[max_stop_time = conflict.valid_start_stop_list[0][1]
]:
	i: 94(t)
	o: 165(JA)

nname: 94
n 94(conflict.isStartTimeValid())[]:
	i: 64(t)
	o: 107(t), 128(f)

nname: 64
n 64(conflict)[max_stop_time = 0
conflict = self.recording_list.GetConflictForMaxTime(recording)
]:
	i: 27(), 63()
	o: 94(t), 164(f)

nname: 63
n 63(None)[]:
	i: 0(f)
	o: 64()

nname: 27
n 27(None)[log.error('Bad Recording ID %d !', nRecordingID)
return {'status': error.WYRECORD_BAD_RECORDING_ID}
]:
	i: 0(t)
	o: 64()

nname: 0
n 0(recording == None)[recording = self.GetRecording(nRecordingID)
]:
	i: 
	o: 27(t), 63(f)

nname: 165
n 165(None)[return {'status': error.WYRECORD_SUCCESS, 'max_stop_time': max_stop_time}
]:
	i: 0(JA)
	o: 

nname: 0
n 0(None)[recording = self.GetRecording(nRecordingID)
if recording == None:
	log.error('Bad Recording ID %d !', nRecordingID)
	return {'status': error.WYRECORD_BAD_RECORDING_ID}
max_stop_time = 0
conflict = self.recording_list.GetConflictForMaxTime(recording)
if conflict:
	if conflict.isStartTimeValid():
		max_stop_time = conflict.valid_start_stop_list[0][1]
	else:
		log.critical('recording list corrupted, Recording ID %d !', nRecordingID)
		return {'status': error.WYRECORD_RECORDING_LIST_CORRUPTED}
]:
	i: 
	o: 165(JA)

nname: 0
n 0(None)[recording = self.GetRecording(nRecordingID)
if recording == None:
	log.error('Bad Recording ID %d !', nRecordingID)
	return {'status': error.WYRECORD_BAD_RECORDING_ID}
max_stop_time = 0
conflict = self.recording_list.GetConflictForMaxTime(recording)
if conflict:
	if conflict.isStartTimeValid():
		max_stop_time = conflict.valid_start_stop_list[0][1]
	else:
		log.critical('recording list corrupted, Recording ID %d !', nRecordingID)
		return {'status': error.WYRECORD_RECORDING_LIST_CORRUPTED}
return {'status': error.WYRECORD_SUCCESS, 'max_stop_time': max_stop_time}
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x8b7e8ac>}
nname: 64
n 64(None)[recording.name = new_name
self.SaveRecordingList()
return None
]:
	i: 27(), 63()
	o: 

nname: 63
n 63(None)[]:
	i: 0(f)
	o: 64()

nname: 27
n 27(None)[log.error('Bad Recording ID %d !', nRecordingID)
return {'status': error.WYRECORD_BAD_RECORDING_ID}
]:
	i: 0(t)
	o: 64()

nname: 0
n 0(recording == None)[recording = self.GetRecording(nRecordingID)
]:
	i: 
	o: 27(t), 63(f)

nname: 0
n 0(None)[recording = self.GetRecording(nRecordingID)
if recording == None:
	log.error('Bad Recording ID %d !', nRecordingID)
	return {'status': error.WYRECORD_BAD_RECORDING_ID}
recording.name = new_name
self.SaveRecordingList()
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x8c1894c>}
nname: 832
n 832(None)[recording.stop_padding = 0
recording.stop_time = nStopTime
self.CheckSchedule()
return {'status': error.WYRECORD_SUCCESS, 'final_duration': nChosenDuration, 'max_duration': nMaxDuration}
]:
	i: 789(), 805()
	o: 

nname: 805
n 805(None)[nChosenDuration = nStopTime - recording.start_time
nMaxDuration = nMaxStopTime - recording.start_time
]:
	i: 777(f)
	o: 832()

nname: 789
n 789(None)[nChosenDuration = 0
nMaxDuration = 0
]:
	i: 777(t)
	o: 832()

nname: 777
n 777(nStopTime == 0)[]:
	i: 646(JA), 656(), 679(), 709(JA), 719(), 770()
	o: 789(t), 805(f)

nname: 770
n 770(None)[nStopTime = nWantedStopTime
]:
	i: 689(f)
	o: 777()

nname: 719
n 719(None)[nMaxDuration = nMaxStopTime - recording.start_time
return {'status': error.WYRECORD_DURATION_TOO_BIG, 'max_duration': nMaxDuration, 'conflict': conflict}
]:
	i: 702(f)
	o: 777()

nname: 709
n 709(None)[nStopTime = nMaxStopTime
]:
	i: 702(t)
	o: 777(JA)

nname: 702
n 702(bComputeSuitableDuration)[]:
	i: 689(t)
	o: 709(t), 719(f)

nname: 689
n 689(nWantedStopTime > nMaxStopTime)[]:
	i: 666(f)
	o: 702(t), 770(f)

nname: 679
n 679(None)[nStopTime = nMaxStopTime
]:
	i: 666(t)
	o: 777()

nname: 666
n 666(nWantedStopTime == 0)[]:
	i: 621(f)
	o: 679(t), 689(f)

nname: 656
n 656(None)[nStopTime = nWantedStopTime
]:
	i: 633(f)
	o: 777()

nname: 646
n 646(None)[nStopTime = 0
]:
	i: 633(t)
	o: 777(JA)

nname: 633
n 633(nWantedStopTime == 0)[]:
	i: 621(t)
	o: 646(t), 656(f)

nname: 621
n 621(nMaxStopTime == 0)[]:
	i: 563(JA), 584(), 620()
	o: 633(t), 666(f)

nname: 620
n 620(None)[]:
	i: 520(f)
	o: 621()

nname: 584
n 584(None)[log.critical('recording list corrupted, Recording ID %d !', nRecordingID)
return {'status': error.WYRECORD_RECORDING_LIST_CORRUPTED}
]:
	i: 550(f)
	o: 621()

nname: 563
n 563(None)[nMaxStopTime = conflict.valid_start_stop_list[0][1]
]:
	i: 550(t)
	o: 621(JA)

nname: 550
n 550(conflict.isStartTimeValid())[]:
	i: 520(t)
	o: 563(t), 584(f)

nname: 520
n 520(conflict)[nMaxStopTime = 0
conflict = self.recording_list.GetConflictForMaxTime(recording)
]:
	i: 506(), 519()
	o: 550(t), 620(f)

nname: 519
n 519(None)[]:
	i: 449(f)
	o: 520()

nname: 506
n 506(None)[nWantedStopTime = start_time + nDuration
]:
	i: 492(), 505()
	o: 520()

nname: 505
n 505(None)[]:
	i: 467(f)
	o: 506()

nname: 492
n 492(None)[start_time = recording.start_time
]:
	i: 467(t)
	o: 506()

nname: 467
n 467(recording.status == RECORDING_STATUS_RUNNING)[start_time = recording.start_time
]:
	i: 449(t)
	o: 492(t), 505(f)

nname: 449
n 449(nDuration != 0)[nWantedStopTime = 0
]:
	i: 370(JA), 410(), 448()
	o: 467(t), 519(f)

nname: 448
n 448(None)[]:
	i: 249(f)
	o: 449()

nname: 410
n 410(None)[return {'status': error.WYRECORD_SUCCESS, 'final_duration': nDuration, 'max_duration': nDuration}
]:
	i: 301(f)
	o: 449()

nname: 370
n 370(None)[return {'status': error.WYRECORD_SCHEDULE_CONFLICT, 'recording_id': recording.id, 'conflict': conflict}
]:
	i: 345(), 369()
	o: 449(JA)

nname: 369
n 369(None)[]:
	i: 335(f)
	o: 370()

nname: 345
n 345(None)[recording.stop_time = conflict.valid_start_stop_list[0][1]
]:
	i: 335(t)
	o: 370()

nname: 335
n 335(config.auto_adjust_instant_record_stop_time)[]:
	i: 301(t)
	o: 345(t), 369(f)

nname: 301
n 301(conflict)[conflict = self.recording_list.GetConflict(recording)
self.CheckSchedule()
]:
	i: 271(), 291()
	o: 335(t), 410(f)

nname: 291
n 291(None)[recording.stop_time = 0
]:
	i: 264(f)
	o: 301()

nname: 271
n 271(None)[recording.stop_time = recording.start_time + nDuration
]:
	i: 264(t)
	o: 301()

nname: 264
n 264(nDuration)[]:
	i: 249(t)
	o: 271(t), 291(f)

nname: 249
n 249(recording.type == RECORDING_TYPE_NOT_SCHEDULED)[]:
	i: 203(JA), 244(), 248()
	o: 264(t), 448(f)

nname: 248
n 248(None)[]:
	i: 64(f)
	o: 249()

nname: 244
n 244(None)[]:
	i: 125(f)
	o: 249()

nname: 203
n 203(None)[return {'status': error.WYRECORD_NOT_ENOUGH_DISK_SPACE, 'needed_space': blind_free_space - free_space, 'available_space': blind_free_space}
]:
	i: 192(), 202()
	o: 249(JA)

nname: 202
n 202(None)[]:
	i: 161(f)
	o: 203()

nname: 192
n 192(None)[blind_free_space = 0
]:
	i: 161(t)
	o: 203()

nname: 161
n 161(self.ext_disk_space.blind_free_space < 0)[blind_free_space = self.ext_disk_space.blind_free_space
]:
	i: 125(t)
	o: 192(t), 202(f)

nname: 125
n 125(free_space < 0)[free_space = self.ext_disk_space.getAvailableDiskSpace()
recording.stop_time = old_stop_time
]:
	i: 95(), 115()
	o: 161(t), 244(f)

nname: 115
n 115(None)[recording.stop_time = 0
]:
	i: 79(f)
	o: 125()

nname: 95
n 95(None)[recording.stop_time = recording.start_time + nDuration
]:
	i: 79(t)
	o: 125()

nname: 79
n 79(nDuration)[old_stop_time = recording.stop_time
]:
	i: 64(t)
	o: 95(t), 115(f)

nname: 64
n 64(recording.status == RECORDING_STATUS_RUNNING)[]:
	i: 27(), 63()
	o: 79(t), 248(f)

nname: 63
n 63(None)[]:
	i: 0(f)
	o: 64()

nname: 27
n 27(None)[log.error('Bad Recording ID %d !', nRecordingID)
return {'status': error.WYRECORD_BAD_RECORDING_ID}
]:
	i: 0(t)
	o: 64()

nname: 0
n 0(recording == None)[recording = self.GetRecording(nRecordingID)
]:
	i: 
	o: 27(t), 63(f)

nname: 777
n 777(None)[if nStopTime == 0:
	nChosenDuration = 0
	nMaxDuration = 0
else:
	nChosenDuration = nStopTime - recording.start_time
	nMaxDuration = nMaxStopTime - recording.start_time
recording.stop_padding = 0
recording.stop_time = nStopTime
self.CheckSchedule()
return {'status': error.WYRECORD_SUCCESS, 'final_duration': nChosenDuration, 'max_duration': nMaxDuration}
]:
	i: 520(JA)
	o: 

nname: 520
n 520(None)[nMaxStopTime = 0
conflict = self.recording_list.GetConflictForMaxTime(recording)
if conflict:
	if conflict.isStartTimeValid():
		nMaxStopTime = conflict.valid_start_stop_list[0][1]
	else:
		log.critical('recording list corrupted, Recording ID %d !', nRecordingID)
		return {'status': error.WYRECORD_RECORDING_LIST_CORRUPTED}
if nMaxStopTime == 0:
	if nWantedStopTime == 0:
		nStopTime = 0
	else:
		nStopTime = nWantedStopTime
else:
	if nWantedStopTime == 0:
		nStopTime = nMaxStopTime
	else:
		if nWantedStopTime > nMaxStopTime:
			if bComputeSuitableDuration:
				nStopTime = nMaxStopTime
			else:
				nMaxDuration = nMaxStopTime - recording.start_time
				return {'status': error.WYRECORD_DURATION_TOO_BIG, 'max_duration': nMaxDuration, 'conflict': conflict}
		else:
			nStopTime = nWantedStopTime
]:
	i: 467(), 449(f)
	o: 777(JA)

nname: 467
n 467(None)[start_time = recording.start_time
if recording.status == RECORDING_STATUS_RUNNING:
	start_time = recording.start_time
nWantedStopTime = start_time + nDuration
]:
	i: 449(t)
	o: 520()

nname: 449
n 449(nDuration != 0)[nWantedStopTime = 0
]:
	i: 335(JA), 410(), 249(f)
	o: 467(t), 520(f)

nname: 410
n 410(None)[return {'status': error.WYRECORD_SUCCESS, 'final_duration': nDuration, 'max_duration': nDuration}
]:
	i: 264(f)
	o: 449()

nname: 335
n 335(None)[if config.auto_adjust_instant_record_stop_time:
	recording.stop_time = conflict.valid_start_stop_list[0][1]
return {'status': error.WYRECORD_SCHEDULE_CONFLICT, 'recording_id': recording.id, 'conflict': conflict}
]:
	i: 264(t)
	o: 449(JA)

nname: 264
n 264(conflict)[if nDuration:
	recording.stop_time = recording.start_time + nDuration
else:
	recording.stop_time = 0
conflict = self.recording_list.GetConflict(recording)
self.CheckSchedule()
]:
	i: 249(t)
	o: 335(t), 410(f)

nname: 249
n 249(recording.type == RECORDING_TYPE_NOT_SCHEDULED)[]:
	i: 161(JA), 79(f), 0(f)
	o: 264(t), 449(f)

nname: 161
n 161(None)[blind_free_space = self.ext_disk_space.blind_free_space
if self.ext_disk_space.blind_free_space < 0:
	blind_free_space = 0
return {'status': error.WYRECORD_NOT_ENOUGH_DISK_SPACE, 'needed_space': blind_free_space - free_space, 'available_space': blind_free_space}
]:
	i: 79(t)
	o: 249(JA)

nname: 79
n 79(free_space < 0)[old_stop_time = recording.stop_time
if nDuration:
	recording.stop_time = recording.start_time + nDuration
else:
	recording.stop_time = 0
free_space = self.ext_disk_space.getAvailableDiskSpace()
recording.stop_time = old_stop_time
]:
	i: 0(t)
	o: 161(t), 249(f)

nname: 0
n 0(recording.status == RECORDING_STATUS_RUNNING)[recording = self.GetRecording(nRecordingID)
if recording == None:
	log.error('Bad Recording ID %d !', nRecordingID)
	return {'status': error.WYRECORD_BAD_RECORDING_ID}
]:
	i: 
	o: 79(t), 249(f)

nname: 777
n 777(None)[if nStopTime == 0:
	nChosenDuration = 0
	nMaxDuration = 0
else:
	nChosenDuration = nStopTime - recording.start_time
	nMaxDuration = nMaxStopTime - recording.start_time
recording.stop_padding = 0
recording.stop_time = nStopTime
self.CheckSchedule()
return {'status': error.WYRECORD_SUCCESS, 'final_duration': nChosenDuration, 'max_duration': nMaxDuration}
]:
	i: 449(JA)
	o: 

nname: 449
n 449(None)[nWantedStopTime = 0
if nDuration != 0:
	start_time = recording.start_time
	if recording.status == RECORDING_STATUS_RUNNING:
		start_time = recording.start_time
	nWantedStopTime = start_time + nDuration
nMaxStopTime = 0
conflict = self.recording_list.GetConflictForMaxTime(recording)
if conflict:
	if conflict.isStartTimeValid():
		nMaxStopTime = conflict.valid_start_stop_list[0][1]
	else:
		log.critical('recording list corrupted, Recording ID %d !', nRecordingID)
		return {'status': error.WYRECORD_RECORDING_LIST_CORRUPTED}
if nMaxStopTime == 0:
	if nWantedStopTime == 0:
		nStopTime = 0
	else:
		nStopTime = nWantedStopTime
else:
	if nWantedStopTime == 0:
		nStopTime = nMaxStopTime
	else:
		if nWantedStopTime > nMaxStopTime:
			if bComputeSuitableDuration:
				nStopTime = nMaxStopTime
			else:
				nMaxDuration = nMaxStopTime - recording.start_time
				return {'status': error.WYRECORD_DURATION_TOO_BIG, 'max_duration': nMaxDuration, 'conflict': conflict}
		else:
			nStopTime = nWantedStopTime
]:
	i: 0(f)
	o: 777(JA)

nname: 0
n 0(None)[recording = self.GetRecording(nRecordingID)
if recording == None:
	log.error('Bad Recording ID %d !', nRecordingID)
	return {'status': error.WYRECORD_BAD_RECORDING_ID}
if recording.status == RECORDING_STATUS_RUNNING:
	old_stop_time = recording.stop_time
	if nDuration:
		recording.stop_time = recording.start_time + nDuration
	else:
		recording.stop_time = 0
	free_space = self.ext_disk_space.getAvailableDiskSpace()
	recording.stop_time = old_stop_time
	if free_space < 0:
		blind_free_space = self.ext_disk_space.blind_free_space
		if self.ext_disk_space.blind_free_space < 0:
			blind_free_space = 0
		return {'status': error.WYRECORD_NOT_ENOUGH_DISK_SPACE, 'needed_space': blind_free_space - free_space, 'available_space': blind_free_space}
if recording.type == RECORDING_TYPE_NOT_SCHEDULED:
	if nDuration:
		recording.stop_time = recording.start_time + nDuration
	else:
		recording.stop_time = 0
	conflict = self.recording_list.GetConflict(recording)
	self.CheckSchedule()
	if conflict:
		if config.auto_adjust_instant_record_stop_time:
			recording.stop_time = conflict.valid_start_stop_list[0][1]
		return {'status': error.WYRECORD_SCHEDULE_CONFLICT, 'recording_id': recording.id, 'conflict': conflict}
	else:
		return {'status': error.WYRECORD_SUCCESS, 'final_duration': nDuration, 'max_duration': nDuration}
]:
	i: 
	o: 449(JA)

nname: 777
n 777(None)[if nStopTime == 0:
	nChosenDuration = 0
	nMaxDuration = 0
else:
	nChosenDuration = nStopTime - recording.start_time
	nMaxDuration = nMaxStopTime - recording.start_time
recording.stop_padding = 0
recording.stop_time = nStopTime
self.CheckSchedule()
return {'status': error.WYRECORD_SUCCESS, 'final_duration': nChosenDuration, 'max_duration': nMaxDuration}
]:
	i: 0(JA)
	o: 

nname: 0
n 0(None)[recording = self.GetRecording(nRecordingID)
if recording == None:
	log.error('Bad Recording ID %d !', nRecordingID)
	return {'status': error.WYRECORD_BAD_RECORDING_ID}
if recording.status == RECORDING_STATUS_RUNNING:
	old_stop_time = recording.stop_time
	if nDuration:
		recording.stop_time = recording.start_time + nDuration
	else:
		recording.stop_time = 0
	free_space = self.ext_disk_space.getAvailableDiskSpace()
	recording.stop_time = old_stop_time
	if free_space < 0:
		blind_free_space = self.ext_disk_space.blind_free_space
		if self.ext_disk_space.blind_free_space < 0:
			blind_free_space = 0
		return {'status': error.WYRECORD_NOT_ENOUGH_DISK_SPACE, 'needed_space': blind_free_space - free_space, 'available_space': blind_free_space}
if recording.type == RECORDING_TYPE_NOT_SCHEDULED:
	if nDuration:
		recording.stop_time = recording.start_time + nDuration
	else:
		recording.stop_time = 0
	conflict = self.recording_list.GetConflict(recording)
	self.CheckSchedule()
	if conflict:
		if config.auto_adjust_instant_record_stop_time:
			recording.stop_time = conflict.valid_start_stop_list[0][1]
		return {'status': error.WYRECORD_SCHEDULE_CONFLICT, 'recording_id': recording.id, 'conflict': conflict}
	else:
		return {'status': error.WYRECORD_SUCCESS, 'final_duration': nDuration, 'max_duration': nDuration}
nWantedStopTime = 0
if nDuration != 0:
	start_time = recording.start_time
	if recording.status == RECORDING_STATUS_RUNNING:
		start_time = recording.start_time
	nWantedStopTime = start_time + nDuration
nMaxStopTime = 0
conflict = self.recording_list.GetConflictForMaxTime(recording)
if conflict:
	if conflict.isStartTimeValid():
		nMaxStopTime = conflict.valid_start_stop_list[0][1]
	else:
		log.critical('recording list corrupted, Recording ID %d !', nRecordingID)
		return {'status': error.WYRECORD_RECORDING_LIST_CORRUPTED}
if nMaxStopTime == 0:
	if nWantedStopTime == 0:
		nStopTime = 0
	else:
		nStopTime = nWantedStopTime
else:
	if nWantedStopTime == 0:
		nStopTime = nMaxStopTime
	else:
		if nWantedStopTime > nMaxStopTime:
			if bComputeSuitableDuration:
				nStopTime = nMaxStopTime
			else:
				nMaxDuration = nMaxStopTime - recording.start_time
				return {'status': error.WYRECORD_DURATION_TOO_BIG, 'max_duration': nMaxDuration, 'conflict': conflict}
		else:
			nStopTime = nWantedStopTime
]:
	i: 
	o: 777(JA)

nname: 0
n 0(None)[recording = self.GetRecording(nRecordingID)
if recording == None:
	log.error('Bad Recording ID %d !', nRecordingID)
	return {'status': error.WYRECORD_BAD_RECORDING_ID}
if recording.status == RECORDING_STATUS_RUNNING:
	old_stop_time = recording.stop_time
	if nDuration:
		recording.stop_time = recording.start_time + nDuration
	else:
		recording.stop_time = 0
	free_space = self.ext_disk_space.getAvailableDiskSpace()
	recording.stop_time = old_stop_time
	if free_space < 0:
		blind_free_space = self.ext_disk_space.blind_free_space
		if self.ext_disk_space.blind_free_space < 0:
			blind_free_space = 0
		return {'status': error.WYRECORD_NOT_ENOUGH_DISK_SPACE, 'needed_space': blind_free_space - free_space, 'available_space': blind_free_space}
if recording.type == RECORDING_TYPE_NOT_SCHEDULED:
	if nDuration:
		recording.stop_time = recording.start_time + nDuration
	else:
		recording.stop_time = 0
	conflict = self.recording_list.GetConflict(recording)
	self.CheckSchedule()
	if conflict:
		if config.auto_adjust_instant_record_stop_time:
			recording.stop_time = conflict.valid_start_stop_list[0][1]
		return {'status': error.WYRECORD_SCHEDULE_CONFLICT, 'recording_id': recording.id, 'conflict': conflict}
	else:
		return {'status': error.WYRECORD_SUCCESS, 'final_duration': nDuration, 'max_duration': nDuration}
nWantedStopTime = 0
if nDuration != 0:
	start_time = recording.start_time
	if recording.status == RECORDING_STATUS_RUNNING:
		start_time = recording.start_time
	nWantedStopTime = start_time + nDuration
nMaxStopTime = 0
conflict = self.recording_list.GetConflictForMaxTime(recording)
if conflict:
	if conflict.isStartTimeValid():
		nMaxStopTime = conflict.valid_start_stop_list[0][1]
	else:
		log.critical('recording list corrupted, Recording ID %d !', nRecordingID)
		return {'status': error.WYRECORD_RECORDING_LIST_CORRUPTED}
if nMaxStopTime == 0:
	if nWantedStopTime == 0:
		nStopTime = 0
	else:
		nStopTime = nWantedStopTime
else:
	if nWantedStopTime == 0:
		nStopTime = nMaxStopTime
	else:
		if nWantedStopTime > nMaxStopTime:
			if bComputeSuitableDuration:
				nStopTime = nMaxStopTime
			else:
				nMaxDuration = nMaxStopTime - recording.start_time
				return {'status': error.WYRECORD_DURATION_TOO_BIG, 'max_duration': nMaxDuration, 'conflict': conflict}
		else:
			nStopTime = nWantedStopTime
if nStopTime == 0:
	nChosenDuration = 0
	nMaxDuration = 0
else:
	nChosenDuration = nStopTime - recording.start_time
	nMaxDuration = nMaxStopTime - recording.start_time
recording.stop_padding = 0
recording.stop_time = nStopTime
self.CheckSchedule()
return {'status': error.WYRECORD_SUCCESS, 'final_duration': nChosenDuration, 'max_duration': nMaxDuration}
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x8c1f2ac>}
nname: 233
n 233(None)[instance.extern_rule_name = rule_name
return self.periodic_recording_list.AddPeriodicSchedulingRule(instance)
]:
	i: 18(), 44(), 70(), 102(), 137(), 169(), 201(), 220()
	o: 

nname: 220
n 220(None)[raise RuleTypeNotFoundError(rule_name)
]:
	i: 188(f)
	o: 233()

nname: 201
n 201(None)[instance = TimeDeltaListRule(*args, **kargs)
]:
	i: 188(t)
	o: 233()

nname: 188
n 188(rule_name == 'time_delta_list')[]:
	i: 156(f)
	o: 201(t), 220(f)

nname: 169
n 169(None)[instance = ConstantPeriodRule(*args, **kargs)
]:
	i: 156(t)
	o: 233()

nname: 156
n 156(rule_name == 'constant_period')[]:
	i: 124(f)
	o: 169(t), 188(f)

nname: 137
n 137(None)[instance = RelativeDayPosInMonthRule(*args, **kargs)
]:
	i: 124(t)
	o: 233()

nname: 124
n 124(rule_name == 'relative_day_pos_in_month')[]:
	i: 89(f)
	o: 137(t), 156(f)

nname: 102
n 102(None)[instance = DayListRule(range(5))
]:
	i: 89(t)
	o: 233()

nname: 89
n 89(rule_name == 'monday_to_friday')[]:
	i: 57(f)
	o: 102(t), 124(f)

nname: 70
n 70(None)[instance = DayListRule(*args, **kargs)
]:
	i: 57(t)
	o: 233()

nname: 57
n 57(rule_name == 'day_list')[]:
	i: 31(f)
	o: 70(t), 89(f)

nname: 44
n 44(None)[instance = DailyRule()
]:
	i: 31(t)
	o: 233()

nname: 31
n 31(rule_name == 'daily')[]:
	i: 0(f)
	o: 44(t), 57(f)

nname: 18
n 18(None)[instance = WeeklyRule()
]:
	i: 0(t)
	o: 233()

nname: 0
n 0(rule_name == 'weekly')[instance = None
]:
	i: 
	o: 18(t), 31(f)

nname: 0
n 0(None)[instance = None
if rule_name == 'weekly':
	instance = WeeklyRule()
else:
	if rule_name == 'daily':
		instance = DailyRule()
	else:
		if rule_name == 'day_list':
			instance = DayListRule(*args, **kargs)
		else:
			if rule_name == 'monday_to_friday':
				instance = DayListRule(range(5))
			else:
				if rule_name == 'relative_day_pos_in_month':
					instance = RelativeDayPosInMonthRule(*args, **kargs)
				else:
					if rule_name == 'constant_period':
						instance = ConstantPeriodRule(*args, **kargs)
					else:
						if rule_name == 'time_delta_list':
							instance = TimeDeltaListRule(*args, **kargs)
						else:
							raise RuleTypeNotFoundError(rule_name)
instance.extern_rule_name = rule_name
return self.periodic_recording_list.AddPeriodicSchedulingRule(instance)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x8b7ebcc>}
nname: 0
n 0(None)[rule = self.GetPeriodicRuleById(rule_id)
rule.is_active = True
return self.RefreshPeriodicRule(rule_id, new_stop_time)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x8c1892c>}
nname: 0
n 0(None)[rule = self.GetPeriodicRuleById(rule_id)
rule.is_active = False
self.RefreshPeriodicRule(rule_id)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x8c183ec>}
nname: 629
n 629(None)[return result_list
]:
	i: 605(JA), 624(), 628()
	o: 

nname: 628
n 628(None)[]:
	i: 83(f)
	o: 629()

nname: 624
n 624(None)[]:
	i: 599(f)
	o: 629()

nname: 605
n 605(None)[raise PeriodicRecordingGenerateError(result_list, failure_list)
]:
	i: 599(t)
	o: 629(JA)

nname: 599
n 599(failure_list)[]:
	i: 584(), 598()
	o: 605(t), 624(f)

nname: 598
n 598(None)[]:
	i: 578(f)
	o: 599()

nname: 584
n 584(None)[self.CheckSchedule()
]:
	i: 578(t)
	o: 599()

nname: 578
n 578(result_list)[]:
	i: 308(AL), 577()
	o: 584(t), 598(f)

nname: 577
n 577(None)[]:
	i: 348(AF), 574()
	o: 578()

nname: 574
n 574(None)[]:
	i: 572(AE)
	o: 577()

nname: 572
n 572(None)[]:
	i: 531(f), 541()
	o: 574(AE)

nname: 541
n 541(None)[#, e
failure_list.append((e, next_start_time, next_stop_time))
continue
]:
	i: 531(t)
	o: 572()

nname: 531
n 531(<dummy_ex3> EXC_MATCH SchedulerError)[]:
	i: 355(except), 527()
	o: 541(t), 572(f)

nname: 527
n 527(None)[continue
]:
	i: 492(), 526()
	o: 531()

nname: 526
n 526(None)[]:
	i: 381(f)
	o: 527()

nname: 492
n 492(None)[]:
	i: 381(t)
	o: 527()

nname: 381
n 381(first_rec_ok is None)[result_list.append(rec)
]:
	i: 355(try)
	o: 492(t), 526(f)

nname: 355
n 355(None)[for next_start_time in start_list:
index += 1
]:
	i: 348(for)
	o: 381(try), 531(except)

nname: 348
n 348(None)[]:
	i: 308(loop)
	o: 355(for), 577(AF)

nname: 308
n 308(None)[del _[1]
for start_list in start_list:
log.debug(str(start_list))
]:
	i: 233(AF), 274()
	o: 348(loop), 578(AL)

nname: 274
n 274(None)[for elem in start_list:
]:
	i: 233(for)
	o: 308()

nname: 233
n 233(None)[start_list = self.periodic_recording_list.GetTimeList(rule_id, datetime_start_time, stop_time, from_time)
]:
	i: 204(), 232()
	o: 274(for), 308(AF)

nname: 232
n 232(None)[]:
	i: 161(t)
	o: 233()

nname: 204
n 204(None)[_[1], first_rec_ok, index, next_stop_time, rec, rec.periodicity_rule_id, first_rec_ok, rule.recording_ref.start_time, rule.recording_ref.stop_time, from_time = [], None, 0, next_start_time + duration, self.ScheduleRecording(recording.service_id, next_start_time, next_stop_time, recording.name + '_' + str(index), start_padding=recording.start_padding, stop_padding=recording.stop_padding, check_schedule=False, favorite=recording.favorite), rule_id, rec, next_start_time, next_stop_time, datetime.datetime.fromtimestamp(self.GetCurrentUTCTime())
]:
	i: 161(f)
	o: 233()

nname: 161
n 161(from_time)[duration = recording.stop_time - recording.start_time
datetime_start_time = datetime.datetime.fromtimestamp(recording.start_time)
]:
	i: 152(), 160()
	o: 204(f), 232(t)

nname: 160
n 160(None)[]:
	i: 137(t)
	o: 161()

nname: 152
n 152(None)[return False
]:
	i: 137(f)
	o: 161()

nname: 137
n 137(recording)[recording = rule.recording_ref
]:
	i: 114(), 127()
	o: 152(f), 160(t)

nname: 127
n 127(None)[rule.last_time = stop_time
]:
	i: 107(t)
	o: 137()

nname: 114
n 114(None)[stop_time = rule.last_time
]:
	i: 107(f)
	o: 137()

nname: 107
n 107(stop_time)[]:
	i: 83(t)
	o: 114(f), 127(t)

nname: 83
n 83(rule.is_active)[rule = self.GetPeriodicRuleById(rule_id)
]:
	i: 0(AL), 82()
	o: 107(t), 628(f)

nname: 82
n 82(None)[]:
	i: 33(AF), 78()
	o: 83()

nname: 78
n 78(None)[]:
	i: 40(f), 58()
	o: 82()

nname: 58
n 58(None)[self.DeleteRecording(recording.id)
continue
]:
	i: 40(t)
	o: 78()

nname: 40
n 40(recording.status == RECORDING_STATUS_SCHEDULED)[for recording in to_remove_list:
]:
	i: 33(for)
	o: 58(t), 78(f)

nname: 33
n 33(None)[]:
	i: 0(loop)
	o: 40(for), 82(AF)

nname: 0
n 0(None)[result_list = []
failure_list = []
to_remove_list = self.recording_list.GetPeriodicRecordingListByRule(rule_id)
]:
	i: 
	o: 33(loop), 83(AL)

nname: 629
n 629(None)[return result_list
]:
	i: 578(JA), 83(f)
	o: 

nname: 578
n 578(None)[if result_list:
	self.CheckSchedule()
if failure_list:
	raise PeriodicRecordingGenerateError(result_list, failure_list)
]:
	i: 308(AL), 348(AF), 531(AE)
	o: 629(JA)

nname: 531
n 531(None)[except SchedulerError, e:
	failure_list.append((e, next_start_time, next_stop_time))
	continue
]:
	i: 527(), 355()
	o: 578(AE)

nname: 527
n 527(None)[continue
]:
	i: 355()
	o: 531()

nname: 355
n 355(None)[for next_start_time in start_list:
index += 1
try:
	result_list.append(rec)
	if first_rec_ok is None:
		pass
]:
	i: 348(for)
	o: 527(), 531()

nname: 348
n 348(None)[]:
	i: 308(loop)
	o: 355(for), 578(AF)

nname: 308
n 308(None)[del _[1]
for start_list in start_list:
log.debug(str(start_list))
]:
	i: 161(AF), 274()
	o: 348(loop), 578(AL)

nname: 274
n 274(None)[for elem in start_list:
]:
	i: 161(for)
	o: 308()

nname: 161
n 161(None)[duration = recording.stop_time - recording.start_time
datetime_start_time = datetime.datetime.fromtimestamp(recording.start_time)
if not from_time:
	_[1], first_rec_ok, index, next_stop_time, rec, rec.periodicity_rule_id, first_rec_ok, rule.recording_ref.start_time, rule.recording_ref.stop_time, from_time = [], None, 0, next_start_time + duration, self.ScheduleRecording(recording.service_id, next_start_time, next_stop_time, recording.name + '_' + str(index), start_padding=recording.start_padding, stop_padding=recording.stop_padding, check_schedule=False, favorite=recording.favorite), rule_id, rec, next_start_time, next_stop_time, datetime.datetime.fromtimestamp(self.GetCurrentUTCTime())
start_list = self.periodic_recording_list.GetTimeList(rule_id, datetime_start_time, stop_time, from_time)
]:
	i: 107()
	o: 274(for), 308(AF)

nname: 107
n 107(None)[if not stop_time:
	stop_time = rule.last_time
else:
	rule.last_time = stop_time
recording = rule.recording_ref
if not recording:
	return False
]:
	i: 83(t)
	o: 161()

nname: 83
n 83(rule.is_active)[rule = self.GetPeriodicRuleById(rule_id)
]:
	i: 0(AL), 33(AF), 40()
	o: 107(t), 629(f)

nname: 40
n 40(None)[for recording in to_remove_list:
if recording.status == RECORDING_STATUS_SCHEDULED:
	self.DeleteRecording(recording.id)
	continue
]:
	i: 33(for)
	o: 83()

nname: 33
n 33(None)[]:
	i: 0(loop)
	o: 40(for), 83(AF)

nname: 0
n 0(None)[result_list = []
failure_list = []
to_remove_list = self.recording_list.GetPeriodicRecordingListByRule(rule_id)
]:
	i: 
	o: 33(loop), 83(AL)

nname: 629
n 629(None)[return result_list
]:
	i: 578(JA), 40(f)
	o: 

nname: 578
n 578(None)[if result_list:
	self.CheckSchedule()
if failure_list:
	raise PeriodicRecordingGenerateError(result_list, failure_list)
]:
	i: 308(AL), 348(AF), 531(AE)
	o: 629(JA)

nname: 531
n 531(None)[except SchedulerError, e:
	failure_list.append((e, next_start_time, next_stop_time))
	continue
]:
	i: 527(), 355()
	o: 578(AE)

nname: 527
n 527(None)[continue
]:
	i: 355()
	o: 531()

nname: 355
n 355(None)[for next_start_time in start_list:
index += 1
try:
	result_list.append(rec)
	if first_rec_ok is None:
		pass
]:
	i: 348(for)
	o: 527(), 531()

nname: 348
n 348(None)[]:
	i: 308(loop)
	o: 355(for), 578(AF)

nname: 308
n 308(None)[del _[1]
for start_list in start_list:
log.debug(str(start_list))
]:
	i: 107(AF), 274()
	o: 348(loop), 578(AL)

nname: 274
n 274(None)[for elem in start_list:
]:
	i: 107(for)
	o: 308()

nname: 107
n 107(None)[if not stop_time:
	stop_time = rule.last_time
else:
	rule.last_time = stop_time
recording = rule.recording_ref
if not recording:
	return False
duration = recording.stop_time - recording.start_time
datetime_start_time = datetime.datetime.fromtimestamp(recording.start_time)
if not from_time:
	_[1], first_rec_ok, index, next_stop_time, rec, rec.periodicity_rule_id, first_rec_ok, rule.recording_ref.start_time, rule.recording_ref.stop_time, from_time = [], None, 0, next_start_time + duration, self.ScheduleRecording(recording.service_id, next_start_time, next_stop_time, recording.name + '_' + str(index), start_padding=recording.start_padding, stop_padding=recording.stop_padding, check_schedule=False, favorite=recording.favorite), rule_id, rec, next_start_time, next_stop_time, datetime.datetime.fromtimestamp(self.GetCurrentUTCTime())
start_list = self.periodic_recording_list.GetTimeList(rule_id, datetime_start_time, stop_time, from_time)
]:
	i: 40(t)
	o: 274(for), 308(AF)

nname: 40
n 40(rule.is_active)[for recording in to_remove_list:
	if recording.status == RECORDING_STATUS_SCHEDULED:
		self.DeleteRecording(recording.id)
		continue
rule = self.GetPeriodicRuleById(rule_id)
]:
	i: 0(for)
	o: 107(t), 629(f)

nname: 0
n 0(None)[result_list = []
failure_list = []
to_remove_list = self.recording_list.GetPeriodicRecordingListByRule(rule_id)
]:
	i: 
	o: 40(for)

nname: 629
n 629(None)[return result_list
]:
	i: 578(JA), 0(f)
	o: 

nname: 578
n 578(None)[if result_list:
	self.CheckSchedule()
if failure_list:
	raise PeriodicRecordingGenerateError(result_list, failure_list)
]:
	i: 308(AL), 348(AF), 531(AE)
	o: 629(JA)

nname: 531
n 531(None)[except SchedulerError, e:
	failure_list.append((e, next_start_time, next_stop_time))
	continue
]:
	i: 527(), 355()
	o: 578(AE)

nname: 527
n 527(None)[continue
]:
	i: 355()
	o: 531()

nname: 355
n 355(None)[for next_start_time in start_list:
index += 1
try:
	result_list.append(rec)
	if first_rec_ok is None:
		pass
]:
	i: 348(for)
	o: 527(), 531()

nname: 348
n 348(None)[]:
	i: 308(loop)
	o: 355(for), 578(AF)

nname: 308
n 308(None)[del _[1]
for start_list in start_list:
log.debug(str(start_list))
]:
	i: 107(AF), 274()
	o: 348(loop), 578(AL)

nname: 274
n 274(None)[for elem in start_list:
]:
	i: 107(for)
	o: 308()

nname: 107
n 107(None)[if not stop_time:
	stop_time = rule.last_time
else:
	rule.last_time = stop_time
recording = rule.recording_ref
if not recording:
	return False
duration = recording.stop_time - recording.start_time
datetime_start_time = datetime.datetime.fromtimestamp(recording.start_time)
if not from_time:
	_[1], first_rec_ok, index, next_stop_time, rec, rec.periodicity_rule_id, first_rec_ok, rule.recording_ref.start_time, rule.recording_ref.stop_time, from_time = [], None, 0, next_start_time + duration, self.ScheduleRecording(recording.service_id, next_start_time, next_stop_time, recording.name + '_' + str(index), start_padding=recording.start_padding, stop_padding=recording.stop_padding, check_schedule=False, favorite=recording.favorite), rule_id, rec, next_start_time, next_stop_time, datetime.datetime.fromtimestamp(self.GetCurrentUTCTime())
start_list = self.periodic_recording_list.GetTimeList(rule_id, datetime_start_time, stop_time, from_time)
]:
	i: 0(t)
	o: 274(for), 308(AF)

nname: 0
n 0(rule.is_active)[result_list = []
failure_list = []
to_remove_list = self.recording_list.GetPeriodicRecordingListByRule(rule_id)
for recording in to_remove_list:
	if recording.status == RECORDING_STATUS_SCHEDULED:
		self.DeleteRecording(recording.id)
		continue
rule = self.GetPeriodicRuleById(rule_id)
]:
	i: 
	o: 107(t), 629(f)

self.nodes: {0: <unpyclib.structure.node instance at 0x8c2288c>, 527: <unpyclib.structure.node instance at 0x8c41f0c>, 274: <unpyclib.structure.node instance at 0x8c41eac>, 531: <unpyclib.structure.node instance at 0x8c22dcc>, 308: <unpyclib.structure.node instance at 0x8c41dcc>, 578: <unpyclib.structure.node instance at 0x8c226ec>, 348: <unpyclib.structure.node instance at 0x8c4144c>, 355: <unpyclib.structure.node instance at 0x8c2276c>, 107: <unpyclib.structure.node instance at 0x8c22aac>, 629: <unpyclib.structure.node instance at 0x8c41a0c>}
nname: 75
n 75(None)[self.periodic_recording_list.RemoveRule(rule_id)
]:
	i: 19(AL), 70(), 74()
	o: 

nname: 74
n 74(None)[]:
	i: 0(f)
	o: 75()

nname: 70
n 70(None)[]:
	i: 41(AF), 48()
	o: 75()

nname: 48
n 48(None)[for recording in to_remove_list:
self.DeleteRecording(recording.id)
]:
	i: 41(for)
	o: 70()

nname: 41
n 41(None)[]:
	i: 19(loop)
	o: 48(for), 70(AF)

nname: 19
n 19(None)[to_remove_list = self.recording_list.GetPeriodicRecordingListByRule(rule_id)
]:
	i: 0(t)
	o: 41(loop), 75(AL)

nname: 0
n 0(delete_records)[self.DeactivatePeriodicityRule(rule_id)
]:
	i: 
	o: 19(t), 74(f)

nname: 75
n 75(None)[self.periodic_recording_list.RemoveRule(rule_id)
]:
	i: 48(), 0(f)
	o: 

nname: 48
n 48(None)[for recording in to_remove_list:
	self.DeleteRecording(recording.id)
]:
	i: 19(for)
	o: 75()

nname: 19
n 19(None)[to_remove_list = self.recording_list.GetPeriodicRecordingListByRule(rule_id)
]:
	i: 0(t)
	o: 48(for)

nname: 0
n 0(delete_records)[self.DeactivatePeriodicityRule(rule_id)
]:
	i: 
	o: 19(t), 75(f)

nname: 75
n 75(None)[self.periodic_recording_list.RemoveRule(rule_id)
]:
	i: 19(), 0(f)
	o: 

nname: 19
n 19(None)[to_remove_list = self.recording_list.GetPeriodicRecordingListByRule(rule_id)
for recording in to_remove_list:
	self.DeleteRecording(recording.id)
]:
	i: 0(t)
	o: 75()

nname: 0
n 0(delete_records)[self.DeactivatePeriodicityRule(rule_id)
]:
	i: 
	o: 19(t), 75(f)

nname: 0
n 0(None)[self.DeactivatePeriodicityRule(rule_id)
if delete_records:
	to_remove_list = self.recording_list.GetPeriodicRecordingListByRule(rule_id)
	for recording in to_remove_list:
		self.DeleteRecording(recording.id)
self.periodic_recording_list.RemoveRule(rule_id)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x8b7eecc>}
nname: 54
n 54(None)[recording.periodicity_rule_id = rule_id
rule.recording_ref = recording
rule.is_active = True
rule.last_time = stop_time
return self.RefreshPeriodicRule(rule_id)
]:
	i: 45(), 53()
	o: 

nname: 53
n 53(None)[]:
	i: 0&37(f)
	o: 54()

nname: 45
n 45(None)[return False
]:
	i: 0&37(t)
	o: 54()

nname: 0&37
n 0&37(not recording or not rule)[recording = self.GetRecording(rec_id)
rule = self.GetPeriodicRuleById(rule_id)
]:
	i: 
	o: 45(t), 53(f)

nname: 0&37
n 0&37(None)[recording = self.GetRecording(rec_id)
rule = self.GetPeriodicRuleById(rule_id)
if not recording or not rule:
	return False
recording.periodicity_rule_id = rule_id
rule.recording_ref = recording
rule.is_active = True
rule.last_time = stop_time
return self.RefreshPeriodicRule(rule_id)
]:
	i: 
	o: 

self.nodes: {'0&37': <unpyclib.structure.node instance at 0x8c183ec>}
nname: 0
n 0(None)[return self.periodic_recording_list._periodicRecordings[rule_id]
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x8b7eb2c>}
nname: 87
n 87(None)[return ret_list
]:
	i: 0(AL), 86()
	o: 

nname: 86
n 86(None)[]:
	i: 9(AF), 82()
	o: 87()

nname: 82
n 82(None)[]:
	i: 28&40&47&58(f), 65()
	o: 86()

nname: 65
n 65(None)[ret_list.append(rule)
continue
]:
	i: 28&40&47&58(t)
	o: 82()

nname: 28&40&47&58
n 28&40&47&58(rule.is_active and active or not rule.is_active and unactive)[for rule in self.periodic_recording_list._periodicRecordings.itervalues():
]:
	i: 9(for)
	o: 65(t), 82(f)

nname: 9
n 9(None)[]:
	i: 0(loop)
	o: 28&40&47&58(for), 86(AF)

nname: 0
n 0(None)[ret_list = []
]:
	i: 
	o: 9(loop), 87(AL)

nname: 87
n 87(None)[return ret_list
]:
	i: 0(AL), 9(AF), 28&40&47&58(f)
	o: 

nname: 28&40&47&58
n 28&40&47&58(None)[for rule in self.periodic_recording_list._periodicRecordings.itervalues():
if rule.is_active and active or not rule.is_active and unactive:
	ret_list.append(rule)
	continue
]:
	i: 9(for)
	o: 87()

nname: 9
n 9(None)[]:
	i: 0(loop)
	o: 28&40&47&58(for), 87(AF)

nname: 0
n 0(None)[ret_list = []
]:
	i: 
	o: 9(loop), 87(AL)

nname: 28&40&47&58
n 28&40&47&58(None)[for rule in self.periodic_recording_list._periodicRecordings.itervalues():
	if rule.is_active and active or not rule.is_active and unactive:
		ret_list.append(rule)
		continue
return ret_list
]:
	i: 0(for)
	o: 

nname: 0
n 0(None)[ret_list = []
]:
	i: 
	o: 28&40&47&58(for)

nname: 0
n 0(None)[ret_list = []
for rule in self.periodic_recording_list._periodicRecordings.itervalues():
	if rule.is_active and active or not rule.is_active and unactive:
		ret_list.append(rule)
		continue
return ret_list
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x8c189ec>}
nname: 119
n 119(None)[return {'status': error.WYRECORD_NO_RECORD_INFO_AVAILABLE, 'record_info': record_info}
]:
	i: 85(), 118()
	o: 

nname: 118
n 118(None)[]:
	i: 61(f)
	o: 119()

nname: 85
n 85(None)[log.error("Can not get Recording's record info : Maybe a bad recording's status !")
return {'status': error.WYRECORD_NO_RECORD_INFO_AVAILABLE}
]:
	i: 61(t)
	o: 119()

nname: 61
n 61(record_info == None)[record_info = recording.GetRecordInfo()
]:
	i: 27(), 60()
	o: 85(t), 118(f)

nname: 60
n 60(None)[]:
	i: 0(f)
	o: 61()

nname: 27
n 27(None)[log.error('Invalid Recording ID')
return {'status': error.WYRECORD_BAD_RECORDING_ID}
]:
	i: 0(t)
	o: 61()

nname: 0
n 0(recording == None)[recording = self.GetRecording(nRecordingID)
]:
	i: 
	o: 27(t), 60(f)

nname: 119
n 119(None)[return {'status': error.WYRECORD_NO_RECORD_INFO_AVAILABLE, 'record_info': record_info}
]:
	i: 0()
	o: 

nname: 0
n 0(None)[recording = self.GetRecording(nRecordingID)
if recording == None:
	log.error('Invalid Recording ID')
	return {'status': error.WYRECORD_BAD_RECORDING_ID}
record_info = recording.GetRecordInfo()
if record_info == None:
	log.error("Can not get Recording's record info : Maybe a bad recording's status !")
	return {'status': error.WYRECORD_NO_RECORD_INFO_AVAILABLE}
]:
	i: 
	o: 119()

nname: 0
n 0(None)[recording = self.GetRecording(nRecordingID)
if recording == None:
	log.error('Invalid Recording ID')
	return {'status': error.WYRECORD_BAD_RECORDING_ID}
record_info = recording.GetRecordInfo()
if record_info == None:
	log.error("Can not get Recording's record info : Maybe a bad recording's status !")
	return {'status': error.WYRECORD_NO_RECORD_INFO_AVAILABLE}
return {'status': error.WYRECORD_NO_RECORD_INFO_AVAILABLE, 'record_info': record_info}
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x8c1890c>}
nname: 0
n 0(None)[GetRecords(strRecordsFolder)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x8b7eb4c>}
nname: 0
n 0(None)[log.debug('AsynchronousCheckSchedule called')
WyrecordOnShotTimer(self.cbCheckSchedule).start(delay)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x8b7edac>}
nname: 0
n 0(None)[return self.recording_list.GetFirstRecordingToStart()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x8b7ec2c>}
nname: 0
n 0(None)[return len(self.GetRecordingList(RECORDING_FLAG_RUNNING)) > 0
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x8b7e92c>}
nname: 40
n 40(None)[return RECORDING_ID_NULL
]:
	i: 21(), 39()
	o: 

nname: 39
n 39(None)[]:
	i: 0(f)
	o: 40()

nname: 21
n 21(None)[return self.recording_list.rec_id_from_program_id[program_id]
]:
	i: 0(t)
	o: 40()

nname: 0
n 0(self.recording_list.rec_id_from_program_id.has_key(program_id))[]:
	i: 
	o: 21(t), 39(f)

nname: 0
n 0(None)[if self.recording_list.rec_id_from_program_id.has_key(program_id):
	return self.recording_list.rec_id_from_program_id[program_id]
return RECORDING_ID_NULL
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x8b7ef4c>}
nname: 6
n 6(None)[__doc__ = ' manage the scheduling of records.\n    even for instant record.\n    \n    Callbacks().recording_event => (RECORDING_EVENT_RECORD_GOING_TO_START, recording, AdjustTimeForRec_object)\n                                (RECORDING_EVENT_RECORD_START_ERROR, recording, None)\n                                (RECORDING_EVENT_RECORD_DISK_SPACE_START_ERROR, recording, None)\n                                (RECORDING_EVENT_RECORD_STARTED, recording, None)\n                                (RECORDING_EVENT_RECORD_STOPPED, recording, None)\n    '
def __init__(self, recording_builder, recording_launcher, dbus_signaler=None, ext_disk_space=None, ext_standby=None):
	self.ext_disk_space = ext_disk_space
	self.dbus_api = dbus_signaler
	self.ext_standby = ext_standby
	self.ext_standby.scheduler = self
	self.recording_launcher = recording_launcher
	self.recording_builder = recording_builder
	self.last_save_time = 0
	self.server = recording_launcher.wyscan
	self.recording_list = RecordingList(recording_builder, self.recording_launcher)
	self.periodic_recording_list = PeriodicRecordingList()
	self.timer_startrecording = WyrecordOnShotTimer(self.cbtimerStart)
	self.timer_stoprecording = WyrecordOnShotTimer(self.cbtimerStop)
	self.timer_pre_start_alert = WyrecordOnShotTimer(self.cbtimerPreStartAlert)
	self.LoadRecordingList()
	self.CheckRecordingStates()
	self.recording_launcher.StopDeviceRecordings(0)

def GetCurrentUTCTime(self):
	return self.recording_launcher.GetCurrentUTCTime()

def CheckRecordingStates(self):
	for id, recording in self.recording_list.recordings.items():
		if recording.status == RECORDING_STATUS_RUNNING:
			try:
				log.warning('Recording : ' + str(recording))
				recording.Stop(self.GetCurrentUTCTime(), dbus_api=self.dbus_api)
			except BaseException, e:
				log.critical('EXCEPTION ' + str(e))
				log.critical('excpetion on record stop => record is lost')

def GetRecordingList(self, nFlags=RECORDING_FLAG_ALL, nRecordingType=RECORDING_TYPE_NORMAL, ignore_periodic=False):
	recording_list = []
	for recording in self.recording_list.recordings.values():
		if ignore_periodic:
			if recording.periodicity_rule_id != PERIODICITY_RULE_ID_NULL:
				continue
		if nFlags == RECORDING_FLAG_ALL or nFlags & RECORDING_FLAG_RUNNING and recording.status == RECORDING_STATUS_RUNNING or nFlags & RECORDING_FLAG_INCONFLICT and recording.status == RECORDING_STATUS_IN_CONFLICT or nFlags & RECORDING_FLAG_COMPLETED and recording.status == RECORDING_STATUS_COMPLETED or nFlags & RECORDING_FLAG_CANCELED and recording.status == RECORDING_STATUS_CANCELED or nFlags & RECORDING_FLAG_MISSED and recording.status == RECORDING_STATUS_MISSED or nFlags & RECORDING_FLAG_SCHEDULED and recording.status == RECORDING_STATUS_SCHEDULED:
			recording_list.append(recording)
			continue
		_POP_TOP pass
	return recording_list

def GetRecording(self, nRecordingID):
	log.info('GetRecording(nRecordingID = %d)' % nRecordingID)
	return self.recording_list.GetRecording(nRecordingID)

def LoadRecordingList(self):
	try:
		node_root = ET.parse(config.recordings_list_file)
	except EnvironmentError, e:
		log.info(e)
		log.info('the file will be created automaticly')
		return False
	except:
		except Exception, e:
			log.critical("Can not parse xml file '%s'" % config.recordings_list_file)
			log.critical('the file is deleted')
			os.remove(config.recordings_list_file)
			return False
	try:
		node_general = node_root.find('general')
		self.last_save_time = int(node_general.attrib['save_time'])
		node_recordings = node_root.find('recordings')
		ret1 = self.recording_list.LoadFromXML(node_recordings)
		node_periodicity = node_root.find('periodicity')
		ret2 = self.periodic_recording_list.LoadFromXML(node_periodicity)
	except Exception, e:
		self.recording_list = RecordingList(self.recording_builder, self.recording_launcher)
		self.periodic_recording_list = PeriodicRecordingList()
		log.critical("Can not parse xml file '%s'" % config.recordings_list_file)
		log.critical('the file is deleted')
		os.remove(config.recordings_list_file)
		return False
	if ret1:
		pass
	return ret1

def SaveRecordingList(self):
	AsynchronousAction().appendAction(ActionSaveRecordingList(self))

def RealSaveRecordingList(self):
	timestep('SaveRecordingList begin')
	self.last_save_time = self.recording_launcher.GetCurrentUTCTime()
	root_node = ET.Element('RecordingList')
	node_general = ET.Element('general', version='1.0', save_time=str(self.last_save_time))
	root_node.append(node_general)
	recordings_node = ET.Element('recordings')
	self.recording_list.SaveToXMLNode(recordings_node)
	root_node.append(recordings_node)
	periodicity_node = ET.Element('periodicity')
	self.periodic_recording_list.SaveToXMLNode(periodicity_node)
	root_node.append(periodicity_node)
	tree = ET.ElementTree(root_node)
	try:
		timestep('init_save_recording_list')
		tree.write(config.recordings_list_file, encoding='utf-8')
		timestep('SAVE RECORDING LIST TIME')
	except Exception, e:
		log.critical('RecordScheduler.SaveRecordingList() : Error : ' + str(e))
		timestep('SaveRecordingList end with exception')
		return False
	finally:
		os.fsync(os.open(config.recordings_list_file, os.O_RDWR))
	timestep('SaveRecordingList end')
	return True

def StopAll(self):
	log.info('All timers stopped')
	self.timer_stoprecording.stop()
	self.timer_startrecording.stop()
	self.timer_pre_start_alert.stop()

def StopAllRunningRecord(self):
	self.StopAll()
	for rec in self.recording_list.recordings.values():
		if rec.status == RECORDING_STATUS_RUNNING:
			self.StopRecording(rec.id, stop_at_player_pos=False)
			rec.status = RECORDING_STATUS_ABORTED
			continue
	self.CheckSchedule()

cbCheckSchedule = GlobalLock()()
def CheckSchedule(self, save_list=True):
	timestep('CheckSchedule begin')
	self.timer_stoprecording.stop()
	self.timer_startrecording.stop()
	self.timer_pre_start_alert.stop()
	bNeedSave = False
	cur_time = self.GetCurrentUTCTime()
	for id, recording in self.recording_list.recordings.items():
		if recording.status != RECORDING_STATUS_SCHEDULED:
			continue
		if recording.stop_time != 0 and recording.stop_time < cur_time:
			recording.status = RECORDING_STATUS_MISSED
			bNeedSave = True
			continue
		if recording.start_time != 0 and recording.start_time + recording.max_start_delay < cur_time:
			recording.status = RECORDING_STATUS_MISSED
			bNeedSave = True
			continue
			continue
	if save_list:
		self.SaveRecordingList()
	rec_to_start = self.recording_list.GetFirstRecordingToStart()
	rec_to_stop = self.recording_list.GetFirstRecordingToStop()
	if rec_to_stop != None:
		stop_timer = self.getStopTimer(rec_to_stop)
		if rec_to_start != None:
			start_timer = self.getStartTimer(rec_to_start)
			if stop_timer <= start_timer:
				self.timer_stoprecording.start(stop_timer)
			else:
				self._RecordScheduler__activeStartTimer(start_timer, rec_to_start.id)
		else:
			self.timer_stoprecording.start(stop_timer)
	else:
		if rec_to_start != None:
			start_timer = self.getStartTimer(rec_to_start)
			self._RecordScheduler__activeStartTimer(start_timer, rec_to_start.id)
	timestep('CheckSchedule end')
	return None

def _RecordScheduler__activeStartTimer(self, t, id):
	self.timer_startrecording.set_args(id)
	self.timer_startrecording.start(t)
	if t > config.pre_start_alert_delay:
		self.timer_pre_start_alert.set_args(id)
		self.timer_pre_start_alert.start(t - config.pre_start_alert_delay)

def getStartTimer(self, oRecording):
	if oRecording == None:
		return None
	start_timer = 0
	self.timer_startrecording.set_args(oRecording.id)
	log.info("Next recording to start : ID = %d, '%s' at '%s' => '%s'!" % (oRecording.id, oRecording.name, self.server.DateTime_UTC2Text(oRecording.start_time), self.server.DateTime_UTC2Text(oRecording.stop_time)))
	cur_time = self.GetCurrentUTCTime()
	log.info('start_padding = %d' % oRecording.start_padding)
	if oRecording.start_time - oRecording.start_padding > cur_time:
		log.info('Start rec id %d in %d seconds' % (oRecording.id, oRecording.start_time - oRecording.start_padding - cur_time))
		start_timer = oRecording.start_time - oRecording.start_padding - cur_time
	else:
		log.info('Start rec id %d now !' % oRecording.id)
	if start_timer < 0:
		start_timer = 0
	return start_timer

def getStopTimer(self, oRecording):
	if oRecording == None:
		return None
	self.timer_stoprecording.set_args(oRecording.id)
	stop_timer = 0
	log.info("Next recording to stop : ID = %d '%s' at '%s' => '%s'!" % (oRecording.id, oRecording.name, self.server.DateTime_UTC2Text(oRecording.start_time), self.server.DateTime_UTC2Text(oRecording.stop_time)))
	cur_time = self.GetCurrentUTCTime()
	log.info('stop_padding = %d' % oRecording.stop_padding)
	if oRecording.stop_time + oRecording.stop_padding > cur_time:
		log.info('Stop rec id %d in %d seconds' % (oRecording.id, oRecording.stop_time + oRecording.stop_padding - cur_time))
		stop_timer = oRecording.stop_time + oRecording.stop_padding - cur_time
	else:
		log.info('Stop rec id %d now !' % oRecording.id)
	if stop_timer < 0:
		stop_timer = 0
	return stop_timer

def NotifyRecordingStatusChange(self, nEventType, oRecording, inconflict_recordings, live_to_stop_list=None):
	try:
		Callbacks().recording_event.notify(nEventType, oRecording, inconflict_recordings, live_to_stop_list)
	except BaseException, e:
		log.critical('NotifyRecordingStatusChange FAILED => continue anyway')
		log.critical('EXCEPTION ' + str(e))

cbtimerPreStartAlert = GlobalLock()()
cbtimerStart = Chrono(['wyrecord'])(GlobalLock()())
cbtimerStop = GlobalLock()()
def StopRecording(self, nRecordingID, stop_at_player_pos=False):
	recording = self.GetRecording(nRecordingID)
	if recording == None:
		log.error('StopRecording: Recording %d not found !' % nRecordingID)
		return False
	cur_time = self.GetCurrentUTCTime()
	bResult = recording.Stop(cur_time, stop_at_player_pos, self.dbus_api)
	self.CheckSchedule()
	if not self.IsSomeRecordingRunning():
		self.ext_standby.SetMaxPowerState(config.wystandby_id, APM_STATE_OFF)
	else:
		log.debug('SetMaxPowerState APM_STATE_OFF not colald because some recordings are running')
	if recording.status == RECORDING_STATUS_MACROVISION:
		self.NotifyRecordingStatusChange(RECORDING_EVENT_RECORD_MACROVISION_STOP_ERROR, recording, None)
	else:
		self.NotifyRecordingStatusChange(RECORDING_EVENT_RECORD_STOPPED, recording, None)
	return bResult

def StartLiveRecording(self, nServiceID, nForcedDeviceID=0, duration=0, name=''):
	current_time = self.GetCurrentUTCTime()
	if duration != 0:
		end_time = current_time + duration
	else:
		end_time = 0
	res = self._initialyseNewRec(nServiceID, current_time, end_time, name, nForcedDeviceID)
	if res['status'] != error.WYRECORD_SUCCESS:
		return res
	newrecording = res['new_rec']
	newrecording.start_padding = 0
	newrecording.stop_padding = 0
	conflict = self.recording_list.GetConflictForNotScheduledRecording(newrecording, include_instant_record=True)
	if conflict:
		if not conflict.isStartTimeValid():
			return {'status': error.WYRECORD_SCHEDULE_CONFLICT, 'recording_id': RECORDING_ID_NULL, 'conflict': conflict}
		else:
			if config.auto_adjust_instant_record_stop_time:
				newrecording.stop_time = conflict.valid_start_stop_list[0][1]
	newrecording.MarkAsInstantRecording()
	newrecording.type = RECORDING_TYPE_NOT_SCHEDULED
	if not self.recording_list.AddRecording(newrecording):
		log.error('Can not add recording in list')
		return {'status': error.WYRECORD_UNKNOWN_ERROR, 'recording_id': RECORDING_ID_NULL}
	newrecording.status = RECORDING_STATUS_SCHEDULED
	self.CheckSchedule(False)
	return {'status': error.WYRECORD_SUCCESS, 'recording_id': newrecording.id, 'stop_time': newrecording.stop_time, 'conflict': conflict}

def ScheduleRecording(self, nServiceID, nStartTime, nStopTime, strRecordingName='', nForcedDeviceID=0, start_padding=-1, stop_padding=-1, check_schedule=True, program_id='', favorite=''):
	if nStartTime >= nStopTime:
		raise SchedulerOtherError()
	res = self._initialyseNewRec(nServiceID, nStartTime, nStopTime, strRecordingName, nForcedDeviceID, start_padding, stop_padding)
	status = res['status']
	if status != error.WYRECORD_SUCCESS:
		if status == error.WYRECORD_BAD_SERVICE_ID:
			raise SchedulerBadServiceIdError(nServiceID)
		else:
			if status == error.WYRECORD_NO_DEVICE_FOR_SERVICE:
				raise SchedulerNoDeviceForServiceError(nServiceID)
			else:
				if status == error.WYRECORD_FORCED_DEVICE_INVALID:
					raise SchedulerForcedDeviceNotValidError(nServiceID, nForcedDeviceID)
				else:
					raise SchedulerOtherError()
	newrecording = res['new_rec']
	conflict = self.recording_list.GetConflictForNotScheduledRecording(newrecording, include_instant_record=True)
	instant_rec_in_conflict = None
	if conflict:
		for rec in conflict.getAllRecInConflict():
			if rec.type != RECORDING_TYPE_NOT_SCHEDULED:
				raise SchedulerConflictError(conflict)
				continue
			instant_rec_in_conflict = rec
	if not self.recording_list.AddRecording(newrecording, program_id, favorite):
		raise SchedulerOtherError()
	newrecording.status = RECORDING_STATUS_SCHEDULED
	if instant_rec_in_conflict and config.auto_adjust_instant_record_stop_time:
		instant_rec_in_conflict.stop_time = newrecording.start_time
		log.debug('### new instant record duration is: ' + str(instant_rec_in_conflict.stop_time - instant_rec_in_conflict.start_time))
	if check_schedule:
		self.CheckSchedule()
	if conflict:
		raise SchedulerConflictWithInstantRecordError(conflict)
	return newrecording

def _initialyseNewRec(self, nServiceID, nStartTime, nStopTime, strRecordingName='', nForcedDeviceID=0, start_padding=-1, stop_padding=-1):
	nStartTime = int(nStartTime)
	nStopTime = int(nStopTime)
	service = self.recording_launcher.GetService(nServiceID)
	if service == None:
		return {'status': error.WYRECORD_BAD_SERVICE_ID}
	devices = self.recording_launcher.GetPlayableServiceDevices(service.id)
	if len(devices) == 0:
		return {'status': error.WYRECORD_NO_DEVICE_FOR_SERVICE}

def DeleteRecording(self, nRecordingID):
	return self.recording_list.RemoveRecording(nRecordingID, True)

def DeleteRecord(self, oRecordInfo):
	return self.recording_list.RemoveRecord(oRecordInfo, True)

def GetRecordingPossibleMaxStopTime(self, nRecordingID):
	recording = self.GetRecording(nRecordingID)
	if recording == None:
		log.error('Bad Recording ID %d !', nRecordingID)
		return {'status': error.WYRECORD_BAD_RECORDING_ID}
	max_stop_time = 0
	conflict = self.recording_list.GetConflictForMaxTime(recording)
	if conflict:
		if conflict.isStartTimeValid():
			max_stop_time = conflict.valid_start_stop_list[0][1]
		else:
			log.critical('recording list corrupted, Recording ID %d !', nRecordingID)
			return {'status': error.WYRECORD_RECORDING_LIST_CORRUPTED}
	return {'status': error.WYRECORD_SUCCESS, 'max_stop_time': max_stop_time}

def UpdateRecordingName(self, nRecordingID, new_name):
	recording = self.GetRecording(nRecordingID)
	if recording == None:
		log.error('Bad Recording ID %d !', nRecordingID)
		return {'status': error.WYRECORD_BAD_RECORDING_ID}
	recording.name = new_name
	self.SaveRecordingList()
	return None

def SetRecordingDuration(self, nRecordingID, nDuration, bComputeSuitableDuration):
	recording = self.GetRecording(nRecordingID)
	if recording == None:
		log.error('Bad Recording ID %d !', nRecordingID)
		return {'status': error.WYRECORD_BAD_RECORDING_ID}
	if recording.status == RECORDING_STATUS_RUNNING:
		old_stop_time = recording.stop_time
		if nDuration:
			recording.stop_time = recording.start_time + nDuration
		else:
			recording.stop_time = 0
		free_space = self.ext_disk_space.getAvailableDiskSpace()
		recording.stop_time = old_stop_time
		if free_space < 0:
			blind_free_space = self.ext_disk_space.blind_free_space
			if self.ext_disk_space.blind_free_space < 0:
				blind_free_space = 0
			return {'status': error.WYRECORD_NOT_ENOUGH_DISK_SPACE, 'needed_space': blind_free_space - free_space, 'available_space': blind_free_space}
	if recording.type == RECORDING_TYPE_NOT_SCHEDULED:
		if nDuration:
			recording.stop_time = recording.start_time + nDuration
		else:
			recording.stop_time = 0
		conflict = self.recording_list.GetConflict(recording)
		self.CheckSchedule()
		if conflict:
			if config.auto_adjust_instant_record_stop_time:
				recording.stop_time = conflict.valid_start_stop_list[0][1]
			return {'status': error.WYRECORD_SCHEDULE_CONFLICT, 'recording_id': recording.id, 'conflict': conflict}
		else:
			return {'status': error.WYRECORD_SUCCESS, 'final_duration': nDuration, 'max_duration': nDuration}
	nWantedStopTime = 0
	if nDuration != 0:
		start_time = recording.start_time
		if recording.status == RECORDING_STATUS_RUNNING:
			start_time = recording.start_time
		nWantedStopTime = start_time + nDuration
	nMaxStopTime = 0
	conflict = self.recording_list.GetConflictForMaxTime(recording)
	if conflict:
		if conflict.isStartTimeValid():
			nMaxStopTime = conflict.valid_start_stop_list[0][1]
		else:
			log.critical('recording list corrupted, Recording ID %d !', nRecordingID)
			return {'status': error.WYRECORD_RECORDING_LIST_CORRUPTED}
	if nMaxStopTime == 0:
		if nWantedStopTime == 0:
			nStopTime = 0
		else:
			nStopTime = nWantedStopTime
	else:
		if nWantedStopTime == 0:
			nStopTime = nMaxStopTime
		else:
			if nWantedStopTime > nMaxStopTime:
				if bComputeSuitableDuration:
					nStopTime = nMaxStopTime
				else:
					nMaxDuration = nMaxStopTime - recording.start_time
					return {'status': error.WYRECORD_DURATION_TOO_BIG, 'max_duration': nMaxDuration, 'conflict': conflict}
			else:
				nStopTime = nWantedStopTime
	if nStopTime == 0:
		nChosenDuration = 0
		nMaxDuration = 0
	else:
		nChosenDuration = nStopTime - recording.start_time
		nMaxDuration = nMaxStopTime - recording.start_time
	recording.stop_padding = 0
	recording.stop_time = nStopTime
	self.CheckSchedule()
	return {'status': error.WYRECORD_SUCCESS, 'final_duration': nChosenDuration, 'max_duration': nMaxDuration}

def createPeriodicityRule(self, rule_name, *args, **args):
	instance = None
	if rule_name == 'weekly':
		instance = WeeklyRule()
	else:
		if rule_name == 'daily':
			instance = DailyRule()
		else:
			if rule_name == 'day_list':
				instance = DayListRule(*args, **kargs)
			else:
				if rule_name == 'monday_to_friday':
					instance = DayListRule(range(5))
				else:
					if rule_name == 'relative_day_pos_in_month':
						instance = RelativeDayPosInMonthRule(*args, **kargs)
					else:
						if rule_name == 'constant_period':
							instance = ConstantPeriodRule(*args, **kargs)
						else:
							if rule_name == 'time_delta_list':
								instance = TimeDeltaListRule(*args, **kargs)
							else:
								raise RuleTypeNotFoundError(rule_name)
	instance.extern_rule_name = rule_name
	return self.periodic_recording_list.AddPeriodicSchedulingRule(instance)

def ActivatePeriodicityRule(self, rule_id, new_stop_time=None):
	rule = self.GetPeriodicRuleById(rule_id)
	rule.is_active = True
	return self.RefreshPeriodicRule(rule_id, new_stop_time)

def DeactivatePeriodicityRule(self, rule_id):
	rule = self.GetPeriodicRuleById(rule_id)
	rule.is_active = False
	self.RefreshPeriodicRule(rule_id)

def RefreshPeriodicRule(self, rule_id, stop_time=None, from_time=None):
	result_list = []
	failure_list = []
	to_remove_list = self.recording_list.GetPeriodicRecordingListByRule(rule_id)
	for recording in to_remove_list:
		if recording.status == RECORDING_STATUS_SCHEDULED:
			self.DeleteRecording(recording.id)
			continue
	rule = self.GetPeriodicRuleById(rule_id)

def RemovePeriodicRecording(self, rule_id, delete_records=False):
	self.DeactivatePeriodicityRule(rule_id)
	if delete_records:
		to_remove_list = self.recording_list.GetPeriodicRecordingListByRule(rule_id)
		for recording in to_remove_list:
			self.DeleteRecording(recording.id)
	self.periodic_recording_list.RemoveRule(rule_id)

def GeneratePeriodicRecording(self, rec_id, rule_id, stop_time):
	recording = self.GetRecording(rec_id)
	rule = self.GetPeriodicRuleById(rule_id)
	if not recording or not rule:
		return False
	recording.periodicity_rule_id = rule_id
	rule.recording_ref = recording
	rule.is_active = True
	rule.last_time = stop_time
	return self.RefreshPeriodicRule(rule_id)

def GetPeriodicRuleById(self, rule_id):
	return self.periodic_recording_list._periodicRecordings[rule_id]

def GetPeriodicRecordingList(self, active=True, unactive=True):
	ret_list = []
	for rule in self.periodic_recording_list._periodicRecordings.itervalues():
		if rule.is_active and active or not rule.is_active and unactive:
			ret_list.append(rule)
			continue
	return ret_list

def GetRecordingInfo(self, nRecordingID):
	recording = self.GetRecording(nRecordingID)
	if recording == None:
		log.error('Invalid Recording ID')
		return {'status': error.WYRECORD_BAD_RECORDING_ID}
	record_info = recording.GetRecordInfo()
	if record_info == None:
		log.error("Can not get Recording's record info : Maybe a bad recording's status !")
		return {'status': error.WYRECORD_NO_RECORD_INFO_AVAILABLE}
	return {'status': error.WYRECORD_NO_RECORD_INFO_AVAILABLE, 'record_info': record_info}

def GetRecords(self, strRecordsFolder=''):
	GetRecords(strRecordsFolder)

def AsynchronousCheckSchedule(self, delay=0):
	log.debug('AsynchronousCheckSchedule called')
	WyrecordOnShotTimer(self.cbCheckSchedule).start(delay)

def GetFirstRecordingToStart(self):
	return self.recording_list.GetFirstRecordingToStart()

def IsSomeRecordingRunning(self):
	return len(self.GetRecordingList(RECORDING_FLAG_RUNNING)) > 0

def GetRecordingIdFromProgramId(self, program_id):
	if self.recording_list.rec_id_from_program_id.has_key(program_id):
		return self.recording_list.rec_id_from_program_id[program_id]
	return RECORDING_ID_NULL

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0x8b7e72c>}
nname: 0
n 0(None)[__doc__ = '\nImplementation of RecordScheduler class.\n\n'
import sys
import error
import WyScan
import datetime
import time
from config import *
from exceptions import *
import xml.etree.cElementTree as ET
from peewee.analyse import Chrono
from callbacks import Callbacks
from recording import Recording
from recordinglist import RecordingList
from periodicrecordinglist import PeriodicRecordingList
from tools import WyrecordOnShotTimer
from conflictresolution import AdjustTimeForRec
from conflictresolution import resolveFromAdjustTimeForRec
from recordinfo import RecordInfo
from peewee import notifier
from logger import log
import os
from peewee.analyse import timestep
from asynchronousaction import ActionSaveRecordingList
from asynchronousaction import AsynchronousAction
from periodicscheduling import WeeklyRule
from periodicscheduling import DailyRule
from periodicscheduling import DayListRule
from periodicscheduling import RelativeDayPosInMonthRule
from periodicscheduling import ConstantPeriodRule
from periodicscheduling import TimeDeltaListRule
from recording import RECORDING_ID_NULL
from recording import PERIODICITY_RULE_ID_NULL
from recording import RECORDING_TYPE_NORMAL
from recording import RECORDING_TYPE_FLASHBACK
from recording import RECORDING_TYPE_NOT_SCHEDULED
from recording import RECORDING_STATUS_UNKNOWN
from recording import RECORDING_STATUS_SCHEDULED
from recording import RECORDING_STATUS_RUNNING
from recording import RECORDING_STATUS_IN_CONFLICT
from recording import RECORDING_STATUS_COMPLETED
from recording import RECORDING_STATUS_CANCELED
from recording import RECORDING_STATUS_MISSED
from recording import RECORDING_STATUS_ABORTED
from recording import RECORDING_STATUS_MACROVISION
from recording import RECORDING_STATUS_DISK_SPACE_ERROR
from recording import RECORDING_STATUS_SYSTEM_FAILURE
from globallock import GlobalLock
RECORDING_FLAG_RUNNING = 1
RECORDING_FLAG_COMPLETED = 2
RECORDING_FLAG_INCONFLICT = 4
RECORDING_FLAG_SCHEDULED = 8
RECORDING_FLAG_CANCELED = 16
RECORDING_FLAG_MISSED = 16
RECORDING_FLAG_ALL = 255
RECORDING_EVENT_RECORD_STARTED = 1
RECORDING_EVENT_RECORD_STOPPED = 2
RECORDING_EVENT_RECORD_START_ERROR = 3
RECORDING_EVENT_RECORD_GOING_TO_START = 4
RECORDING_EVENT_RECORD_DISK_SPACE_START_ERROR = 5
RECORDING_EVENT_RECORD_MACROVISION_START_ERROR = 6
RECORDING_EVENT_RECORD_MACROVISION_STOP_ERROR = 7
def GetRecords(strRecordsFolder=''):
	if strRecordsFolder == '':
		strRecordsFolder = config.records_folder
	if not os.path.exists(strRecordsFolder):
		log.error("Record folder '%s' does not exist !" % strRecordsFolder)
		return {'status': error.WYRECORD_BAD_PATH}
	if not os.path.isdir(strRecordsFolder):
		log.error("Record folder '%s' is not a folder !" % strRecordsFolder)
		return {'status': error.WYRECORD_BAD_PATH}
	files = os.listdir(strRecordsFolder)
	record_infos = []

class RecordScheduler(object):
	__doc__ = ' manage the scheduling of records.\n    even for instant record.\n    \n    Callbacks().recording_event => (RECORDING_EVENT_RECORD_GOING_TO_START, recording, AdjustTimeForRec_object)\n                                (RECORDING_EVENT_RECORD_START_ERROR, recording, None)\n                                (RECORDING_EVENT_RECORD_DISK_SPACE_START_ERROR, recording, None)\n                                (RECORDING_EVENT_RECORD_STARTED, recording, None)\n                                (RECORDING_EVENT_RECORD_STOPPED, recording, None)\n    '
	def __init__(self, recording_builder, recording_launcher, dbus_signaler=None, ext_disk_space=None, ext_standby=None):
		self.ext_disk_space = ext_disk_space
		self.dbus_api = dbus_signaler
		self.ext_standby = ext_standby
		self.ext_standby.scheduler = self
		self.recording_launcher = recording_launcher
		self.recording_builder = recording_builder
		self.last_save_time = 0
		self.server = recording_launcher.wyscan
		self.recording_list = RecordingList(recording_builder, self.recording_launcher)
		self.periodic_recording_list = PeriodicRecordingList()
		self.timer_startrecording = WyrecordOnShotTimer(self.cbtimerStart)
		self.timer_stoprecording = WyrecordOnShotTimer(self.cbtimerStop)
		self.timer_pre_start_alert = WyrecordOnShotTimer(self.cbtimerPreStartAlert)
		self.LoadRecordingList()
		self.CheckRecordingStates()
		self.recording_launcher.StopDeviceRecordings(0)

	def GetCurrentUTCTime(self):
		return self.recording_launcher.GetCurrentUTCTime()

	def CheckRecordingStates(self):
		for id, recording in self.recording_list.recordings.items():
			if recording.status == RECORDING_STATUS_RUNNING:
				try:
					log.warning('Recording : ' + str(recording))
					recording.Stop(self.GetCurrentUTCTime(), dbus_api=self.dbus_api)
				except BaseException, e:
					log.critical('EXCEPTION ' + str(e))
					log.critical('excpetion on record stop => record is lost')

	def GetRecordingList(self, nFlags=RECORDING_FLAG_ALL, nRecordingType=RECORDING_TYPE_NORMAL, ignore_periodic=False):
		recording_list = []
		for recording in self.recording_list.recordings.values():
			if ignore_periodic:
				if recording.periodicity_rule_id != PERIODICITY_RULE_ID_NULL:
					continue
			if nFlags == RECORDING_FLAG_ALL or nFlags & RECORDING_FLAG_RUNNING and recording.status == RECORDING_STATUS_RUNNING or nFlags & RECORDING_FLAG_INCONFLICT and recording.status == RECORDING_STATUS_IN_CONFLICT or nFlags & RECORDING_FLAG_COMPLETED and recording.status == RECORDING_STATUS_COMPLETED or nFlags & RECORDING_FLAG_CANCELED and recording.status == RECORDING_STATUS_CANCELED or nFlags & RECORDING_FLAG_MISSED and recording.status == RECORDING_STATUS_MISSED or nFlags & RECORDING_FLAG_SCHEDULED and recording.status == RECORDING_STATUS_SCHEDULED:
				recording_list.append(recording)
				continue
			_POP_TOP pass
		return recording_list

	def GetRecording(self, nRecordingID):
		log.info('GetRecording(nRecordingID = %d)' % nRecordingID)
		return self.recording_list.GetRecording(nRecordingID)

	def LoadRecordingList(self):
		try:
			node_root = ET.parse(config.recordings_list_file)
		except EnvironmentError, e:
			log.info(e)
			log.info('the file will be created automaticly')
			return False
		except:
			except Exception, e:
				log.critical("Can not parse xml file '%s'" % config.recordings_list_file)
				log.critical('the file is deleted')
				os.remove(config.recordings_list_file)
				return False
		try:
			node_general = node_root.find('general')
			self.last_save_time = int(node_general.attrib['save_time'])
			node_recordings = node_root.find('recordings')
			ret1 = self.recording_list.LoadFromXML(node_recordings)
			node_periodicity = node_root.find('periodicity')
			ret2 = self.periodic_recording_list.LoadFromXML(node_periodicity)
		except Exception, e:
			self.recording_list = RecordingList(self.recording_builder, self.recording_launcher)
			self.periodic_recording_list = PeriodicRecordingList()
			log.critical("Can not parse xml file '%s'" % config.recordings_list_file)
			log.critical('the file is deleted')
			os.remove(config.recordings_list_file)
			return False
		if ret1:
			pass
		return ret1

	def SaveRecordingList(self):
		AsynchronousAction().appendAction(ActionSaveRecordingList(self))

	def RealSaveRecordingList(self):
		timestep('SaveRecordingList begin')
		self.last_save_time = self.recording_launcher.GetCurrentUTCTime()
		root_node = ET.Element('RecordingList')
		node_general = ET.Element('general', version='1.0', save_time=str(self.last_save_time))
		root_node.append(node_general)
		recordings_node = ET.Element('recordings')
		self.recording_list.SaveToXMLNode(recordings_node)
		root_node.append(recordings_node)
		periodicity_node = ET.Element('periodicity')
		self.periodic_recording_list.SaveToXMLNode(periodicity_node)
		root_node.append(periodicity_node)
		tree = ET.ElementTree(root_node)
		try:
			timestep('init_save_recording_list')
			tree.write(config.recordings_list_file, encoding='utf-8')
			timestep('SAVE RECORDING LIST TIME')
		except Exception, e:
			log.critical('RecordScheduler.SaveRecordingList() : Error : ' + str(e))
			timestep('SaveRecordingList end with exception')
			return False
		finally:
			os.fsync(os.open(config.recordings_list_file, os.O_RDWR))
		timestep('SaveRecordingList end')
		return True

	def StopAll(self):
		log.info('All timers stopped')
		self.timer_stoprecording.stop()
		self.timer_startrecording.stop()
		self.timer_pre_start_alert.stop()

	def StopAllRunningRecord(self):
		self.StopAll()
		for rec in self.recording_list.recordings.values():
			if rec.status == RECORDING_STATUS_RUNNING:
				self.StopRecording(rec.id, stop_at_player_pos=False)
				rec.status = RECORDING_STATUS_ABORTED
				continue
		self.CheckSchedule()

	cbCheckSchedule = GlobalLock()()
	def CheckSchedule(self, save_list=True):
		timestep('CheckSchedule begin')
		self.timer_stoprecording.stop()
		self.timer_startrecording.stop()
		self.timer_pre_start_alert.stop()
		bNeedSave = False
		cur_time = self.GetCurrentUTCTime()
		for id, recording in self.recording_list.recordings.items():
			if recording.status != RECORDING_STATUS_SCHEDULED:
				continue
			if recording.stop_time != 0 and recording.stop_time < cur_time:
				recording.status = RECORDING_STATUS_MISSED
				bNeedSave = True
				continue
			if recording.start_time != 0 and recording.start_time + recording.max_start_delay < cur_time:
				recording.status = RECORDING_STATUS_MISSED
				bNeedSave = True
				continue
				continue
		if save_list:
			self.SaveRecordingList()
		rec_to_start = self.recording_list.GetFirstRecordingToStart()
		rec_to_stop = self.recording_list.GetFirstRecordingToStop()
		if rec_to_stop != None:
			stop_timer = self.getStopTimer(rec_to_stop)
			if rec_to_start != None:
				start_timer = self.getStartTimer(rec_to_start)
				if stop_timer <= start_timer:
					self.timer_stoprecording.start(stop_timer)
				else:
					self._RecordScheduler__activeStartTimer(start_timer, rec_to_start.id)
			else:
				self.timer_stoprecording.start(stop_timer)
		else:
			if rec_to_start != None:
				start_timer = self.getStartTimer(rec_to_start)
				self._RecordScheduler__activeStartTimer(start_timer, rec_to_start.id)
		timestep('CheckSchedule end')
		return None

	def _RecordScheduler__activeStartTimer(self, t, id):
		self.timer_startrecording.set_args(id)
		self.timer_startrecording.start(t)
		if t > config.pre_start_alert_delay:
			self.timer_pre_start_alert.set_args(id)
			self.timer_pre_start_alert.start(t - config.pre_start_alert_delay)

	def getStartTimer(self, oRecording):
		if oRecording == None:
			return None
		start_timer = 0
		self.timer_startrecording.set_args(oRecording.id)
		log.info("Next recording to start : ID = %d, '%s' at '%s' => '%s'!" % (oRecording.id, oRecording.name, self.server.DateTime_UTC2Text(oRecording.start_time), self.server.DateTime_UTC2Text(oRecording.stop_time)))
		cur_time = self.GetCurrentUTCTime()
		log.info('start_padding = %d' % oRecording.start_padding)
		if oRecording.start_time - oRecording.start_padding > cur_time:
			log.info('Start rec id %d in %d seconds' % (oRecording.id, oRecording.start_time - oRecording.start_padding - cur_time))
			start_timer = oRecording.start_time - oRecording.start_padding - cur_time
		else:
			log.info('Start rec id %d now !' % oRecording.id)
		if start_timer < 0:
			start_timer = 0
		return start_timer

	def getStopTimer(self, oRecording):
		if oRecording == None:
			return None
		self.timer_stoprecording.set_args(oRecording.id)
		stop_timer = 0
		log.info("Next recording to stop : ID = %d '%s' at '%s' => '%s'!" % (oRecording.id, oRecording.name, self.server.DateTime_UTC2Text(oRecording.start_time), self.server.DateTime_UTC2Text(oRecording.stop_time)))
		cur_time = self.GetCurrentUTCTime()
		log.info('stop_padding = %d' % oRecording.stop_padding)
		if oRecording.stop_time + oRecording.stop_padding > cur_time:
			log.info('Stop rec id %d in %d seconds' % (oRecording.id, oRecording.stop_time + oRecording.stop_padding - cur_time))
			stop_timer = oRecording.stop_time + oRecording.stop_padding - cur_time
		else:
			log.info('Stop rec id %d now !' % oRecording.id)
		if stop_timer < 0:
			stop_timer = 0
		return stop_timer

	def NotifyRecordingStatusChange(self, nEventType, oRecording, inconflict_recordings, live_to_stop_list=None):
		try:
			Callbacks().recording_event.notify(nEventType, oRecording, inconflict_recordings, live_to_stop_list)
		except BaseException, e:
			log.critical('NotifyRecordingStatusChange FAILED => continue anyway')
			log.critical('EXCEPTION ' + str(e))

	cbtimerPreStartAlert = GlobalLock()()
	cbtimerStart = Chrono(['wyrecord'])(GlobalLock()())
	cbtimerStop = GlobalLock()()
	def StopRecording(self, nRecordingID, stop_at_player_pos=False):
		recording = self.GetRecording(nRecordingID)
		if recording == None:
			log.error('StopRecording: Recording %d not found !' % nRecordingID)
			return False
		cur_time = self.GetCurrentUTCTime()
		bResult = recording.Stop(cur_time, stop_at_player_pos, self.dbus_api)
		self.CheckSchedule()
		if not self.IsSomeRecordingRunning():
			self.ext_standby.SetMaxPowerState(config.wystandby_id, APM_STATE_OFF)
		else:
			log.debug('SetMaxPowerState APM_STATE_OFF not colald because some recordings are running')
		if recording.status == RECORDING_STATUS_MACROVISION:
			self.NotifyRecordingStatusChange(RECORDING_EVENT_RECORD_MACROVISION_STOP_ERROR, recording, None)
		else:
			self.NotifyRecordingStatusChange(RECORDING_EVENT_RECORD_STOPPED, recording, None)
		return bResult

	def StartLiveRecording(self, nServiceID, nForcedDeviceID=0, duration=0, name=''):
		current_time = self.GetCurrentUTCTime()
		if duration != 0:
			end_time = current_time + duration
		else:
			end_time = 0
		res = self._initialyseNewRec(nServiceID, current_time, end_time, name, nForcedDeviceID)
		if res['status'] != error.WYRECORD_SUCCESS:
			return res
		newrecording = res['new_rec']
		newrecording.start_padding = 0
		newrecording.stop_padding = 0
		conflict = self.recording_list.GetConflictForNotScheduledRecording(newrecording, include_instant_record=True)
		if conflict:
			if not conflict.isStartTimeValid():
				return {'status': error.WYRECORD_SCHEDULE_CONFLICT, 'recording_id': RECORDING_ID_NULL, 'conflict': conflict}
			else:
				if config.auto_adjust_instant_record_stop_time:
					newrecording.stop_time = conflict.valid_start_stop_list[0][1]
		newrecording.MarkAsInstantRecording()
		newrecording.type = RECORDING_TYPE_NOT_SCHEDULED
		if not self.recording_list.AddRecording(newrecording):
			log.error('Can not add recording in list')
			return {'status': error.WYRECORD_UNKNOWN_ERROR, 'recording_id': RECORDING_ID_NULL}
		newrecording.status = RECORDING_STATUS_SCHEDULED
		self.CheckSchedule(False)
		return {'status': error.WYRECORD_SUCCESS, 'recording_id': newrecording.id, 'stop_time': newrecording.stop_time, 'conflict': conflict}

	def ScheduleRecording(self, nServiceID, nStartTime, nStopTime, strRecordingName='', nForcedDeviceID=0, start_padding=-1, stop_padding=-1, check_schedule=True, program_id='', favorite=''):
		if nStartTime >= nStopTime:
			raise SchedulerOtherError()
		res = self._initialyseNewRec(nServiceID, nStartTime, nStopTime, strRecordingName, nForcedDeviceID, start_padding, stop_padding)
		status = res['status']
		if status != error.WYRECORD_SUCCESS:
			if status == error.WYRECORD_BAD_SERVICE_ID:
				raise SchedulerBadServiceIdError(nServiceID)
			else:
				if status == error.WYRECORD_NO_DEVICE_FOR_SERVICE:
					raise SchedulerNoDeviceForServiceError(nServiceID)
				else:
					if status == error.WYRECORD_FORCED_DEVICE_INVALID:
						raise SchedulerForcedDeviceNotValidError(nServiceID, nForcedDeviceID)
					else:
						raise SchedulerOtherError()
		newrecording = res['new_rec']
		conflict = self.recording_list.GetConflictForNotScheduledRecording(newrecording, include_instant_record=True)
		instant_rec_in_conflict = None
		if conflict:
			for rec in conflict.getAllRecInConflict():
				if rec.type != RECORDING_TYPE_NOT_SCHEDULED:
					raise SchedulerConflictError(conflict)
					continue
				instant_rec_in_conflict = rec
		if not self.recording_list.AddRecording(newrecording, program_id, favorite):
			raise SchedulerOtherError()
		newrecording.status = RECORDING_STATUS_SCHEDULED
		if instant_rec_in_conflict and config.auto_adjust_instant_record_stop_time:
			instant_rec_in_conflict.stop_time = newrecording.start_time
			log.debug('### new instant record duration is: ' + str(instant_rec_in_conflict.stop_time - instant_rec_in_conflict.start_time))
		if check_schedule:
			self.CheckSchedule()
		if conflict:
			raise SchedulerConflictWithInstantRecordError(conflict)
		return newrecording

	def _initialyseNewRec(self, nServiceID, nStartTime, nStopTime, strRecordingName='', nForcedDeviceID=0, start_padding=-1, stop_padding=-1):
		nStartTime = int(nStartTime)
		nStopTime = int(nStopTime)
		service = self.recording_launcher.GetService(nServiceID)
		if service == None:
			return {'status': error.WYRECORD_BAD_SERVICE_ID}
		devices = self.recording_launcher.GetPlayableServiceDevices(service.id)
		if len(devices) == 0:
			return {'status': error.WYRECORD_NO_DEVICE_FOR_SERVICE}

	def DeleteRecording(self, nRecordingID):
		return self.recording_list.RemoveRecording(nRecordingID, True)

	def DeleteRecord(self, oRecordInfo):
		return self.recording_list.RemoveRecord(oRecordInfo, True)

	def GetRecordingPossibleMaxStopTime(self, nRecordingID):
		recording = self.GetRecording(nRecordingID)
		if recording == None:
			log.error('Bad Recording ID %d !', nRecordingID)
			return {'status': error.WYRECORD_BAD_RECORDING_ID}
		max_stop_time = 0
		conflict = self.recording_list.GetConflictForMaxTime(recording)
		if conflict:
			if conflict.isStartTimeValid():
				max_stop_time = conflict.valid_start_stop_list[0][1]
			else:
				log.critical('recording list corrupted, Recording ID %d !', nRecordingID)
				return {'status': error.WYRECORD_RECORDING_LIST_CORRUPTED}
		return {'status': error.WYRECORD_SUCCESS, 'max_stop_time': max_stop_time}

	def UpdateRecordingName(self, nRecordingID, new_name):
		recording = self.GetRecording(nRecordingID)
		if recording == None:
			log.error('Bad Recording ID %d !', nRecordingID)
			return {'status': error.WYRECORD_BAD_RECORDING_ID}
		recording.name = new_name
		self.SaveRecordingList()
		return None

	def SetRecordingDuration(self, nRecordingID, nDuration, bComputeSuitableDuration):
		recording = self.GetRecording(nRecordingID)
		if recording == None:
			log.error('Bad Recording ID %d !', nRecordingID)
			return {'status': error.WYRECORD_BAD_RECORDING_ID}
		if recording.status == RECORDING_STATUS_RUNNING:
			old_stop_time = recording.stop_time
			if nDuration:
				recording.stop_time = recording.start_time + nDuration
			else:
				recording.stop_time = 0
			free_space = self.ext_disk_space.getAvailableDiskSpace()
			recording.stop_time = old_stop_time
			if free_space < 0:
				blind_free_space = self.ext_disk_space.blind_free_space
				if self.ext_disk_space.blind_free_space < 0:
					blind_free_space = 0
				return {'status': error.WYRECORD_NOT_ENOUGH_DISK_SPACE, 'needed_space': blind_free_space - free_space, 'available_space': blind_free_space}
		if recording.type == RECORDING_TYPE_NOT_SCHEDULED:
			if nDuration:
				recording.stop_time = recording.start_time + nDuration
			else:
				recording.stop_time = 0
			conflict = self.recording_list.GetConflict(recording)
			self.CheckSchedule()
			if conflict:
				if config.auto_adjust_instant_record_stop_time:
					recording.stop_time = conflict.valid_start_stop_list[0][1]
				return {'status': error.WYRECORD_SCHEDULE_CONFLICT, 'recording_id': recording.id, 'conflict': conflict}
			else:
				return {'status': error.WYRECORD_SUCCESS, 'final_duration': nDuration, 'max_duration': nDuration}
		nWantedStopTime = 0
		if nDuration != 0:
			start_time = recording.start_time
			if recording.status == RECORDING_STATUS_RUNNING:
				start_time = recording.start_time
			nWantedStopTime = start_time + nDuration
		nMaxStopTime = 0
		conflict = self.recording_list.GetConflictForMaxTime(recording)
		if conflict:
			if conflict.isStartTimeValid():
				nMaxStopTime = conflict.valid_start_stop_list[0][1]
			else:
				log.critical('recording list corrupted, Recording ID %d !', nRecordingID)
				return {'status': error.WYRECORD_RECORDING_LIST_CORRUPTED}
		if nMaxStopTime == 0:
			if nWantedStopTime == 0:
				nStopTime = 0
			else:
				nStopTime = nWantedStopTime
		else:
			if nWantedStopTime == 0:
				nStopTime = nMaxStopTime
			else:
				if nWantedStopTime > nMaxStopTime:
					if bComputeSuitableDuration:
						nStopTime = nMaxStopTime
					else:
						nMaxDuration = nMaxStopTime - recording.start_time
						return {'status': error.WYRECORD_DURATION_TOO_BIG, 'max_duration': nMaxDuration, 'conflict': conflict}
				else:
					nStopTime = nWantedStopTime
		if nStopTime == 0:
			nChosenDuration = 0
			nMaxDuration = 0
		else:
			nChosenDuration = nStopTime - recording.start_time
			nMaxDuration = nMaxStopTime - recording.start_time
		recording.stop_padding = 0
		recording.stop_time = nStopTime
		self.CheckSchedule()
		return {'status': error.WYRECORD_SUCCESS, 'final_duration': nChosenDuration, 'max_duration': nMaxDuration}

	def createPeriodicityRule(self, rule_name, *args, **args):
		instance = None
		if rule_name == 'weekly':
			instance = WeeklyRule()
		else:
			if rule_name == 'daily':
				instance = DailyRule()
			else:
				if rule_name == 'day_list':
					instance = DayListRule(*args, **kargs)
				else:
					if rule_name == 'monday_to_friday':
						instance = DayListRule(range(5))
					else:
						if rule_name == 'relative_day_pos_in_month':
							instance = RelativeDayPosInMonthRule(*args, **kargs)
						else:
							if rule_name == 'constant_period':
								instance = ConstantPeriodRule(*args, **kargs)
							else:
								if rule_name == 'time_delta_list':
									instance = TimeDeltaListRule(*args, **kargs)
								else:
									raise RuleTypeNotFoundError(rule_name)
		instance.extern_rule_name = rule_name
		return self.periodic_recording_list.AddPeriodicSchedulingRule(instance)

	def ActivatePeriodicityRule(self, rule_id, new_stop_time=None):
		rule = self.GetPeriodicRuleById(rule_id)
		rule.is_active = True
		return self.RefreshPeriodicRule(rule_id, new_stop_time)

	def DeactivatePeriodicityRule(self, rule_id):
		rule = self.GetPeriodicRuleById(rule_id)
		rule.is_active = False
		self.RefreshPeriodicRule(rule_id)

	def RefreshPeriodicRule(self, rule_id, stop_time=None, from_time=None):
		result_list = []
		failure_list = []
		to_remove_list = self.recording_list.GetPeriodicRecordingListByRule(rule_id)
		for recording in to_remove_list:
			if recording.status == RECORDING_STATUS_SCHEDULED:
				self.DeleteRecording(recording.id)
				continue
		rule = self.GetPeriodicRuleById(rule_id)

	def RemovePeriodicRecording(self, rule_id, delete_records=False):
		self.DeactivatePeriodicityRule(rule_id)
		if delete_records:
			to_remove_list = self.recording_list.GetPeriodicRecordingListByRule(rule_id)
			for recording in to_remove_list:
				self.DeleteRecording(recording.id)
		self.periodic_recording_list.RemoveRule(rule_id)

	def GeneratePeriodicRecording(self, rec_id, rule_id, stop_time):
		recording = self.GetRecording(rec_id)
		rule = self.GetPeriodicRuleById(rule_id)
		if not recording or not rule:
			return False
		recording.periodicity_rule_id = rule_id
		rule.recording_ref = recording
		rule.is_active = True
		rule.last_time = stop_time
		return self.RefreshPeriodicRule(rule_id)

	def GetPeriodicRuleById(self, rule_id):
		return self.periodic_recording_list._periodicRecordings[rule_id]

	def GetPeriodicRecordingList(self, active=True, unactive=True):
		ret_list = []
		for rule in self.periodic_recording_list._periodicRecordings.itervalues():
			if rule.is_active and active or not rule.is_active and unactive:
				ret_list.append(rule)
				continue
		return ret_list

	def GetRecordingInfo(self, nRecordingID):
		recording = self.GetRecording(nRecordingID)
		if recording == None:
			log.error('Invalid Recording ID')
			return {'status': error.WYRECORD_BAD_RECORDING_ID}
		record_info = recording.GetRecordInfo()
		if record_info == None:
			log.error("Can not get Recording's record info : Maybe a bad recording's status !")
			return {'status': error.WYRECORD_NO_RECORD_INFO_AVAILABLE}
		return {'status': error.WYRECORD_NO_RECORD_INFO_AVAILABLE, 'record_info': record_info}

	def GetRecords(self, strRecordsFolder=''):
		GetRecords(strRecordsFolder)

	def AsynchronousCheckSchedule(self, delay=0):
		log.debug('AsynchronousCheckSchedule called')
		WyrecordOnShotTimer(self.cbCheckSchedule).start(delay)

	def GetFirstRecordingToStart(self):
		return self.recording_list.GetFirstRecordingToStart()

	def IsSomeRecordingRunning(self):
		return len(self.GetRecordingList(RECORDING_FLAG_RUNNING)) > 0

	def GetRecordingIdFromProgramId(self, program_id):
		if self.recording_list.rec_id_from_program_id.has_key(program_id):
			return self.recording_list.rec_id_from_program_id[program_id]
		return RECORDING_ID_NULL



]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x8b634ec>}
__doc__ = '\nImplementation of RecordScheduler class.\n\n'
import sys
import error
import WyScan
import datetime
import time
from config import *
from exceptions import *
import xml.etree.cElementTree as ET
from peewee.analyse import Chrono
from callbacks import Callbacks
from recording import Recording
from recordinglist import RecordingList
from periodicrecordinglist import PeriodicRecordingList
from tools import WyrecordOnShotTimer
from conflictresolution import AdjustTimeForRec
from conflictresolution import resolveFromAdjustTimeForRec
from recordinfo import RecordInfo
from peewee import notifier
from logger import log
import os
from peewee.analyse import timestep
from asynchronousaction import ActionSaveRecordingList
from asynchronousaction import AsynchronousAction
from periodicscheduling import WeeklyRule
from periodicscheduling import DailyRule
from periodicscheduling import DayListRule
from periodicscheduling import RelativeDayPosInMonthRule
from periodicscheduling import ConstantPeriodRule
from periodicscheduling import TimeDeltaListRule
from recording import RECORDING_ID_NULL
from recording import PERIODICITY_RULE_ID_NULL
from recording import RECORDING_TYPE_NORMAL
from recording import RECORDING_TYPE_FLASHBACK
from recording import RECORDING_TYPE_NOT_SCHEDULED
from recording import RECORDING_STATUS_UNKNOWN
from recording import RECORDING_STATUS_SCHEDULED
from recording import RECORDING_STATUS_RUNNING
from recording import RECORDING_STATUS_IN_CONFLICT
from recording import RECORDING_STATUS_COMPLETED
from recording import RECORDING_STATUS_CANCELED
from recording import RECORDING_STATUS_MISSED
from recording import RECORDING_STATUS_ABORTED
from recording import RECORDING_STATUS_MACROVISION
from recording import RECORDING_STATUS_DISK_SPACE_ERROR
from recording import RECORDING_STATUS_SYSTEM_FAILURE
from globallock import GlobalLock
RECORDING_FLAG_RUNNING = 1
RECORDING_FLAG_COMPLETED = 2
RECORDING_FLAG_INCONFLICT = 4
RECORDING_FLAG_SCHEDULED = 8
RECORDING_FLAG_CANCELED = 16
RECORDING_FLAG_MISSED = 16
RECORDING_FLAG_ALL = 255
RECORDING_EVENT_RECORD_STARTED = 1
RECORDING_EVENT_RECORD_STOPPED = 2
RECORDING_EVENT_RECORD_START_ERROR = 3
RECORDING_EVENT_RECORD_GOING_TO_START = 4
RECORDING_EVENT_RECORD_DISK_SPACE_START_ERROR = 5
RECORDING_EVENT_RECORD_MACROVISION_START_ERROR = 6
RECORDING_EVENT_RECORD_MACROVISION_STOP_ERROR = 7
def GetRecords(strRecordsFolder=''):
	if strRecordsFolder == '':
		strRecordsFolder = config.records_folder
	if not os.path.exists(strRecordsFolder):
		log.error("Record folder '%s' does not exist !" % strRecordsFolder)
		return {'status': error.WYRECORD_BAD_PATH}
	if not os.path.isdir(strRecordsFolder):
		log.error("Record folder '%s' is not a folder !" % strRecordsFolder)
		return {'status': error.WYRECORD_BAD_PATH}
	files = os.listdir(strRecordsFolder)
	record_infos = []

class RecordScheduler(object):
	__doc__ = ' manage the scheduling of records.\n    even for instant record.\n    \n    Callbacks().recording_event => (RECORDING_EVENT_RECORD_GOING_TO_START, recording, AdjustTimeForRec_object)\n                                (RECORDING_EVENT_RECORD_START_ERROR, recording, None)\n                                (RECORDING_EVENT_RECORD_DISK_SPACE_START_ERROR, recording, None)\n                                (RECORDING_EVENT_RECORD_STARTED, recording, None)\n                                (RECORDING_EVENT_RECORD_STOPPED, recording, None)\n    '
	def __init__(self, recording_builder, recording_launcher, dbus_signaler=None, ext_disk_space=None, ext_standby=None):
		self.ext_disk_space = ext_disk_space
		self.dbus_api = dbus_signaler
		self.ext_standby = ext_standby
		self.ext_standby.scheduler = self
		self.recording_launcher = recording_launcher
		self.recording_builder = recording_builder
		self.last_save_time = 0
		self.server = recording_launcher.wyscan
		self.recording_list = RecordingList(recording_builder, self.recording_launcher)
		self.periodic_recording_list = PeriodicRecordingList()
		self.timer_startrecording = WyrecordOnShotTimer(self.cbtimerStart)
		self.timer_stoprecording = WyrecordOnShotTimer(self.cbtimerStop)
		self.timer_pre_start_alert = WyrecordOnShotTimer(self.cbtimerPreStartAlert)
		self.LoadRecordingList()
		self.CheckRecordingStates()
		self.recording_launcher.StopDeviceRecordings(0)

	def GetCurrentUTCTime(self):
		return self.recording_launcher.GetCurrentUTCTime()

	def CheckRecordingStates(self):
		for id, recording in self.recording_list.recordings.items():
			if recording.status == RECORDING_STATUS_RUNNING:
				try:
					log.warning('Recording : ' + str(recording))
					recording.Stop(self.GetCurrentUTCTime(), dbus_api=self.dbus_api)
				except BaseException, e:
					log.critical('EXCEPTION ' + str(e))
					log.critical('excpetion on record stop => record is lost')

	def GetRecordingList(self, nFlags=RECORDING_FLAG_ALL, nRecordingType=RECORDING_TYPE_NORMAL, ignore_periodic=False):
		recording_list = []
		for recording in self.recording_list.recordings.values():
			if ignore_periodic:
				if recording.periodicity_rule_id != PERIODICITY_RULE_ID_NULL:
					continue
			if nFlags == RECORDING_FLAG_ALL or nFlags & RECORDING_FLAG_RUNNING and recording.status == RECORDING_STATUS_RUNNING or nFlags & RECORDING_FLAG_INCONFLICT and recording.status == RECORDING_STATUS_IN_CONFLICT or nFlags & RECORDING_FLAG_COMPLETED and recording.status == RECORDING_STATUS_COMPLETED or nFlags & RECORDING_FLAG_CANCELED and recording.status == RECORDING_STATUS_CANCELED or nFlags & RECORDING_FLAG_MISSED and recording.status == RECORDING_STATUS_MISSED or nFlags & RECORDING_FLAG_SCHEDULED and recording.status == RECORDING_STATUS_SCHEDULED:
				recording_list.append(recording)
				continue
			_POP_TOP pass
		return recording_list

	def GetRecording(self, nRecordingID):
		log.info('GetRecording(nRecordingID = %d)' % nRecordingID)
		return self.recording_list.GetRecording(nRecordingID)

	def LoadRecordingList(self):
		try:
			node_root = ET.parse(config.recordings_list_file)
		except EnvironmentError, e:
			log.info(e)
			log.info('the file will be created automaticly')
			return False
		except:
			except Exception, e:
				log.critical("Can not parse xml file '%s'" % config.recordings_list_file)
				log.critical('the file is deleted')
				os.remove(config.recordings_list_file)
				return False
		try:
			node_general = node_root.find('general')
			self.last_save_time = int(node_general.attrib['save_time'])
			node_recordings = node_root.find('recordings')
			ret1 = self.recording_list.LoadFromXML(node_recordings)
			node_periodicity = node_root.find('periodicity')
			ret2 = self.periodic_recording_list.LoadFromXML(node_periodicity)
		except Exception, e:
			self.recording_list = RecordingList(self.recording_builder, self.recording_launcher)
			self.periodic_recording_list = PeriodicRecordingList()
			log.critical("Can not parse xml file '%s'" % config.recordings_list_file)
			log.critical('the file is deleted')
			os.remove(config.recordings_list_file)
			return False
		if ret1:
			pass
		return ret1

	def SaveRecordingList(self):
		AsynchronousAction().appendAction(ActionSaveRecordingList(self))

	def RealSaveRecordingList(self):
		timestep('SaveRecordingList begin')
		self.last_save_time = self.recording_launcher.GetCurrentUTCTime()
		root_node = ET.Element('RecordingList')
		node_general = ET.Element('general', version='1.0', save_time=str(self.last_save_time))
		root_node.append(node_general)
		recordings_node = ET.Element('recordings')
		self.recording_list.SaveToXMLNode(recordings_node)
		root_node.append(recordings_node)
		periodicity_node = ET.Element('periodicity')
		self.periodic_recording_list.SaveToXMLNode(periodicity_node)
		root_node.append(periodicity_node)
		tree = ET.ElementTree(root_node)
		try:
			timestep('init_save_recording_list')
			tree.write(config.recordings_list_file, encoding='utf-8')
			timestep('SAVE RECORDING LIST TIME')
		except Exception, e:
			log.critical('RecordScheduler.SaveRecordingList() : Error : ' + str(e))
			timestep('SaveRecordingList end with exception')
			return False
		finally:
			os.fsync(os.open(config.recordings_list_file, os.O_RDWR))
		timestep('SaveRecordingList end')
		return True

	def StopAll(self):
		log.info('All timers stopped')
		self.timer_stoprecording.stop()
		self.timer_startrecording.stop()
		self.timer_pre_start_alert.stop()

	def StopAllRunningRecord(self):
		self.StopAll()
		for rec in self.recording_list.recordings.values():
			if rec.status == RECORDING_STATUS_RUNNING:
				self.StopRecording(rec.id, stop_at_player_pos=False)
				rec.status = RECORDING_STATUS_ABORTED
				continue
		self.CheckSchedule()

	cbCheckSchedule = GlobalLock()()
	def CheckSchedule(self, save_list=True):
		timestep('CheckSchedule begin')
		self.timer_stoprecording.stop()
		self.timer_startrecording.stop()
		self.timer_pre_start_alert.stop()
		bNeedSave = False
		cur_time = self.GetCurrentUTCTime()
		for id, recording in self.recording_list.recordings.items():
			if recording.status != RECORDING_STATUS_SCHEDULED:
				continue
			if recording.stop_time != 0 and recording.stop_time < cur_time:
				recording.status = RECORDING_STATUS_MISSED
				bNeedSave = True
				continue
			if recording.start_time != 0 and recording.start_time + recording.max_start_delay < cur_time:
				recording.status = RECORDING_STATUS_MISSED
				bNeedSave = True
				continue
				continue
		if save_list:
			self.SaveRecordingList()
		rec_to_start = self.recording_list.GetFirstRecordingToStart()
		rec_to_stop = self.recording_list.GetFirstRecordingToStop()
		if rec_to_stop != None:
			stop_timer = self.getStopTimer(rec_to_stop)
			if rec_to_start != None:
				start_timer = self.getStartTimer(rec_to_start)
				if stop_timer <= start_timer:
					self.timer_stoprecording.start(stop_timer)
				else:
					self._RecordScheduler__activeStartTimer(start_timer, rec_to_start.id)
			else:
				self.timer_stoprecording.start(stop_timer)
		else:
			if rec_to_start != None:
				start_timer = self.getStartTimer(rec_to_start)
				self._RecordScheduler__activeStartTimer(start_timer, rec_to_start.id)
		timestep('CheckSchedule end')
		return None

	def _RecordScheduler__activeStartTimer(self, t, id):
		self.timer_startrecording.set_args(id)
		self.timer_startrecording.start(t)
		if t > config.pre_start_alert_delay:
			self.timer_pre_start_alert.set_args(id)
			self.timer_pre_start_alert.start(t - config.pre_start_alert_delay)

	def getStartTimer(self, oRecording):
		if oRecording == None:
			return None
		start_timer = 0
		self.timer_startrecording.set_args(oRecording.id)
		log.info("Next recording to start : ID = %d, '%s' at '%s' => '%s'!" % (oRecording.id, oRecording.name, self.server.DateTime_UTC2Text(oRecording.start_time), self.server.DateTime_UTC2Text(oRecording.stop_time)))
		cur_time = self.GetCurrentUTCTime()
		log.info('start_padding = %d' % oRecording.start_padding)
		if oRecording.start_time - oRecording.start_padding > cur_time:
			log.info('Start rec id %d in %d seconds' % (oRecording.id, oRecording.start_time - oRecording.start_padding - cur_time))
			start_timer = oRecording.start_time - oRecording.start_padding - cur_time
		else:
			log.info('Start rec id %d now !' % oRecording.id)
		if start_timer < 0:
			start_timer = 0
		return start_timer

	def getStopTimer(self, oRecording):
		if oRecording == None:
			return None
		self.timer_stoprecording.set_args(oRecording.id)
		stop_timer = 0
		log.info("Next recording to stop : ID = %d '%s' at '%s' => '%s'!" % (oRecording.id, oRecording.name, self.server.DateTime_UTC2Text(oRecording.start_time), self.server.DateTime_UTC2Text(oRecording.stop_time)))
		cur_time = self.GetCurrentUTCTime()
		log.info('stop_padding = %d' % oRecording.stop_padding)
		if oRecording.stop_time + oRecording.stop_padding > cur_time:
			log.info('Stop rec id %d in %d seconds' % (oRecording.id, oRecording.stop_time + oRecording.stop_padding - cur_time))
			stop_timer = oRecording.stop_time + oRecording.stop_padding - cur_time
		else:
			log.info('Stop rec id %d now !' % oRecording.id)
		if stop_timer < 0:
			stop_timer = 0
		return stop_timer

	def NotifyRecordingStatusChange(self, nEventType, oRecording, inconflict_recordings, live_to_stop_list=None):
		try:
			Callbacks().recording_event.notify(nEventType, oRecording, inconflict_recordings, live_to_stop_list)
		except BaseException, e:
			log.critical('NotifyRecordingStatusChange FAILED => continue anyway')
			log.critical('EXCEPTION ' + str(e))

	cbtimerPreStartAlert = GlobalLock()()
	cbtimerStart = Chrono(['wyrecord'])(GlobalLock()())
	cbtimerStop = GlobalLock()()
	def StopRecording(self, nRecordingID, stop_at_player_pos=False):
		recording = self.GetRecording(nRecordingID)
		if recording == None:
			log.error('StopRecording: Recording %d not found !' % nRecordingID)
			return False
		cur_time = self.GetCurrentUTCTime()
		bResult = recording.Stop(cur_time, stop_at_player_pos, self.dbus_api)
		self.CheckSchedule()
		if not self.IsSomeRecordingRunning():
			self.ext_standby.SetMaxPowerState(config.wystandby_id, APM_STATE_OFF)
		else:
			log.debug('SetMaxPowerState APM_STATE_OFF not colald because some recordings are running')
		if recording.status == RECORDING_STATUS_MACROVISION:
			self.NotifyRecordingStatusChange(RECORDING_EVENT_RECORD_MACROVISION_STOP_ERROR, recording, None)
		else:
			self.NotifyRecordingStatusChange(RECORDING_EVENT_RECORD_STOPPED, recording, None)
		return bResult

	def StartLiveRecording(self, nServiceID, nForcedDeviceID=0, duration=0, name=''):
		current_time = self.GetCurrentUTCTime()
		if duration != 0:
			end_time = current_time + duration
		else:
			end_time = 0
		res = self._initialyseNewRec(nServiceID, current_time, end_time, name, nForcedDeviceID)
		if res['status'] != error.WYRECORD_SUCCESS:
			return res
		newrecording = res['new_rec']
		newrecording.start_padding = 0
		newrecording.stop_padding = 0
		conflict = self.recording_list.GetConflictForNotScheduledRecording(newrecording, include_instant_record=True)
		if conflict:
			if not conflict.isStartTimeValid():
				return {'status': error.WYRECORD_SCHEDULE_CONFLICT, 'recording_id': RECORDING_ID_NULL, 'conflict': conflict}
			else:
				if config.auto_adjust_instant_record_stop_time:
					newrecording.stop_time = conflict.valid_start_stop_list[0][1]
		newrecording.MarkAsInstantRecording()
		newrecording.type = RECORDING_TYPE_NOT_SCHEDULED
		if not self.recording_list.AddRecording(newrecording):
			log.error('Can not add recording in list')
			return {'status': error.WYRECORD_UNKNOWN_ERROR, 'recording_id': RECORDING_ID_NULL}
		newrecording.status = RECORDING_STATUS_SCHEDULED
		self.CheckSchedule(False)
		return {'status': error.WYRECORD_SUCCESS, 'recording_id': newrecording.id, 'stop_time': newrecording.stop_time, 'conflict': conflict}

	def ScheduleRecording(self, nServiceID, nStartTime, nStopTime, strRecordingName='', nForcedDeviceID=0, start_padding=-1, stop_padding=-1, check_schedule=True, program_id='', favorite=''):
		if nStartTime >= nStopTime:
			raise SchedulerOtherError()
		res = self._initialyseNewRec(nServiceID, nStartTime, nStopTime, strRecordingName, nForcedDeviceID, start_padding, stop_padding)
		status = res['status']
		if status != error.WYRECORD_SUCCESS:
			if status == error.WYRECORD_BAD_SERVICE_ID:
				raise SchedulerBadServiceIdError(nServiceID)
			else:
				if status == error.WYRECORD_NO_DEVICE_FOR_SERVICE:
					raise SchedulerNoDeviceForServiceError(nServiceID)
				else:
					if status == error.WYRECORD_FORCED_DEVICE_INVALID:
						raise SchedulerForcedDeviceNotValidError(nServiceID, nForcedDeviceID)
					else:
						raise SchedulerOtherError()
		newrecording = res['new_rec']
		conflict = self.recording_list.GetConflictForNotScheduledRecording(newrecording, include_instant_record=True)
		instant_rec_in_conflict = None
		if conflict:
			for rec in conflict.getAllRecInConflict():
				if rec.type != RECORDING_TYPE_NOT_SCHEDULED:
					raise SchedulerConflictError(conflict)
					continue
				instant_rec_in_conflict = rec
		if not self.recording_list.AddRecording(newrecording, program_id, favorite):
			raise SchedulerOtherError()
		newrecording.status = RECORDING_STATUS_SCHEDULED
		if instant_rec_in_conflict and config.auto_adjust_instant_record_stop_time:
			instant_rec_in_conflict.stop_time = newrecording.start_time
			log.debug('### new instant record duration is: ' + str(instant_rec_in_conflict.stop_time - instant_rec_in_conflict.start_time))
		if check_schedule:
			self.CheckSchedule()
		if conflict:
			raise SchedulerConflictWithInstantRecordError(conflict)
		return newrecording

	def _initialyseNewRec(self, nServiceID, nStartTime, nStopTime, strRecordingName='', nForcedDeviceID=0, start_padding=-1, stop_padding=-1):
		nStartTime = int(nStartTime)
		nStopTime = int(nStopTime)
		service = self.recording_launcher.GetService(nServiceID)
		if service == None:
			return {'status': error.WYRECORD_BAD_SERVICE_ID}
		devices = self.recording_launcher.GetPlayableServiceDevices(service.id)
		if len(devices) == 0:
			return {'status': error.WYRECORD_NO_DEVICE_FOR_SERVICE}

	def DeleteRecording(self, nRecordingID):
		return self.recording_list.RemoveRecording(nRecordingID, True)

	def DeleteRecord(self, oRecordInfo):
		return self.recording_list.RemoveRecord(oRecordInfo, True)

	def GetRecordingPossibleMaxStopTime(self, nRecordingID):
		recording = self.GetRecording(nRecordingID)
		if recording == None:
			log.error('Bad Recording ID %d !', nRecordingID)
			return {'status': error.WYRECORD_BAD_RECORDING_ID}
		max_stop_time = 0
		conflict = self.recording_list.GetConflictForMaxTime(recording)
		if conflict:
			if conflict.isStartTimeValid():
				max_stop_time = conflict.valid_start_stop_list[0][1]
			else:
				log.critical('recording list corrupted, Recording ID %d !', nRecordingID)
				return {'status': error.WYRECORD_RECORDING_LIST_CORRUPTED}
		return {'status': error.WYRECORD_SUCCESS, 'max_stop_time': max_stop_time}

	def UpdateRecordingName(self, nRecordingID, new_name):
		recording = self.GetRecording(nRecordingID)
		if recording == None:
			log.error('Bad Recording ID %d !', nRecordingID)
			return {'status': error.WYRECORD_BAD_RECORDING_ID}
		recording.name = new_name
		self.SaveRecordingList()
		return None

	def SetRecordingDuration(self, nRecordingID, nDuration, bComputeSuitableDuration):
		recording = self.GetRecording(nRecordingID)
		if recording == None:
			log.error('Bad Recording ID %d !', nRecordingID)
			return {'status': error.WYRECORD_BAD_RECORDING_ID}
		if recording.status == RECORDING_STATUS_RUNNING:
			old_stop_time = recording.stop_time
			if nDuration:
				recording.stop_time = recording.start_time + nDuration
			else:
				recording.stop_time = 0
			free_space = self.ext_disk_space.getAvailableDiskSpace()
			recording.stop_time = old_stop_time
			if free_space < 0:
				blind_free_space = self.ext_disk_space.blind_free_space
				if self.ext_disk_space.blind_free_space < 0:
					blind_free_space = 0
				return {'status': error.WYRECORD_NOT_ENOUGH_DISK_SPACE, 'needed_space': blind_free_space - free_space, 'available_space': blind_free_space}
		if recording.type == RECORDING_TYPE_NOT_SCHEDULED:
			if nDuration:
				recording.stop_time = recording.start_time + nDuration
			else:
				recording.stop_time = 0
			conflict = self.recording_list.GetConflict(recording)
			self.CheckSchedule()
			if conflict:
				if config.auto_adjust_instant_record_stop_time:
					recording.stop_time = conflict.valid_start_stop_list[0][1]
				return {'status': error.WYRECORD_SCHEDULE_CONFLICT, 'recording_id': recording.id, 'conflict': conflict}
			else:
				return {'status': error.WYRECORD_SUCCESS, 'final_duration': nDuration, 'max_duration': nDuration}
		nWantedStopTime = 0
		if nDuration != 0:
			start_time = recording.start_time
			if recording.status == RECORDING_STATUS_RUNNING:
				start_time = recording.start_time
			nWantedStopTime = start_time + nDuration
		nMaxStopTime = 0
		conflict = self.recording_list.GetConflictForMaxTime(recording)
		if conflict:
			if conflict.isStartTimeValid():
				nMaxStopTime = conflict.valid_start_stop_list[0][1]
			else:
				log.critical('recording list corrupted, Recording ID %d !', nRecordingID)
				return {'status': error.WYRECORD_RECORDING_LIST_CORRUPTED}
		if nMaxStopTime == 0:
			if nWantedStopTime == 0:
				nStopTime = 0
			else:
				nStopTime = nWantedStopTime
		else:
			if nWantedStopTime == 0:
				nStopTime = nMaxStopTime
			else:
				if nWantedStopTime > nMaxStopTime:
					if bComputeSuitableDuration:
						nStopTime = nMaxStopTime
					else:
						nMaxDuration = nMaxStopTime - recording.start_time
						return {'status': error.WYRECORD_DURATION_TOO_BIG, 'max_duration': nMaxDuration, 'conflict': conflict}
				else:
					nStopTime = nWantedStopTime
		if nStopTime == 0:
			nChosenDuration = 0
			nMaxDuration = 0
		else:
			nChosenDuration = nStopTime - recording.start_time
			nMaxDuration = nMaxStopTime - recording.start_time
		recording.stop_padding = 0
		recording.stop_time = nStopTime
		self.CheckSchedule()
		return {'status': error.WYRECORD_SUCCESS, 'final_duration': nChosenDuration, 'max_duration': nMaxDuration}

	def createPeriodicityRule(self, rule_name, *args, **args):
		instance = None
		if rule_name == 'weekly':
			instance = WeeklyRule()
		else:
			if rule_name == 'daily':
				instance = DailyRule()
			else:
				if rule_name == 'day_list':
					instance = DayListRule(*args, **kargs)
				else:
					if rule_name == 'monday_to_friday':
						instance = DayListRule(range(5))
					else:
						if rule_name == 'relative_day_pos_in_month':
							instance = RelativeDayPosInMonthRule(*args, **kargs)
						else:
							if rule_name == 'constant_period':
								instance = ConstantPeriodRule(*args, **kargs)
							else:
								if rule_name == 'time_delta_list':
									instance = TimeDeltaListRule(*args, **kargs)
								else:
									raise RuleTypeNotFoundError(rule_name)
		instance.extern_rule_name = rule_name
		return self.periodic_recording_list.AddPeriodicSchedulingRule(instance)

	def ActivatePeriodicityRule(self, rule_id, new_stop_time=None):
		rule = self.GetPeriodicRuleById(rule_id)
		rule.is_active = True
		return self.RefreshPeriodicRule(rule_id, new_stop_time)

	def DeactivatePeriodicityRule(self, rule_id):
		rule = self.GetPeriodicRuleById(rule_id)
		rule.is_active = False
		self.RefreshPeriodicRule(rule_id)

	def RefreshPeriodicRule(self, rule_id, stop_time=None, from_time=None):
		result_list = []
		failure_list = []
		to_remove_list = self.recording_list.GetPeriodicRecordingListByRule(rule_id)
		for recording in to_remove_list:
			if recording.status == RECORDING_STATUS_SCHEDULED:
				self.DeleteRecording(recording.id)
				continue
		rule = self.GetPeriodicRuleById(rule_id)

	def RemovePeriodicRecording(self, rule_id, delete_records=False):
		self.DeactivatePeriodicityRule(rule_id)
		if delete_records:
			to_remove_list = self.recording_list.GetPeriodicRecordingListByRule(rule_id)
			for recording in to_remove_list:
				self.DeleteRecording(recording.id)
		self.periodic_recording_list.RemoveRule(rule_id)

	def GeneratePeriodicRecording(self, rec_id, rule_id, stop_time):
		recording = self.GetRecording(rec_id)
		rule = self.GetPeriodicRuleById(rule_id)
		if not recording or not rule:
			return False
		recording.periodicity_rule_id = rule_id
		rule.recording_ref = recording
		rule.is_active = True
		rule.last_time = stop_time
		return self.RefreshPeriodicRule(rule_id)

	def GetPeriodicRuleById(self, rule_id):
		return self.periodic_recording_list._periodicRecordings[rule_id]

	def GetPeriodicRecordingList(self, active=True, unactive=True):
		ret_list = []
		for rule in self.periodic_recording_list._periodicRecordings.itervalues():
			if rule.is_active and active or not rule.is_active and unactive:
				ret_list.append(rule)
				continue
		return ret_list

	def GetRecordingInfo(self, nRecordingID):
		recording = self.GetRecording(nRecordingID)
		if recording == None:
			log.error('Invalid Recording ID')
			return {'status': error.WYRECORD_BAD_RECORDING_ID}
		record_info = recording.GetRecordInfo()
		if record_info == None:
			log.error("Can not get Recording's record info : Maybe a bad recording's status !")
			return {'status': error.WYRECORD_NO_RECORD_INFO_AVAILABLE}
		return {'status': error.WYRECORD_NO_RECORD_INFO_AVAILABLE, 'record_info': record_info}

	def GetRecords(self, strRecordsFolder=''):
		GetRecords(strRecordsFolder)

	def AsynchronousCheckSchedule(self, delay=0):
		log.debug('AsynchronousCheckSchedule called')
		WyrecordOnShotTimer(self.cbCheckSchedule).start(delay)

	def GetFirstRecordingToStart(self):
		return self.recording_list.GetFirstRecordingToStart()

	def IsSomeRecordingRunning(self):
		return len(self.GetRecordingList(RECORDING_FLAG_RUNNING)) > 0

	def GetRecordingIdFromProgramId(self, program_id):
		if self.recording_list.rec_id_from_program_id.has_key(program_id):
			return self.recording_list.rec_id_from_program_id[program_id]
		return RECORDING_ID_NULL



