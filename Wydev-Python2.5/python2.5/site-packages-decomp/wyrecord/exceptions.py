# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 6
n 6(None)[__doc__ = 'Base class for exceptions in this module.'
]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75be90c>}
nname: 6
n 6(None)[__doc__ = 'Base class for exceptions in this module.'
]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75beaac>}
nname: 6
n 6(None)[__doc__ = 'Base class for exceptions in this module.'
]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75bea8c>}
nname: 0
n 0(None)[self.service_id = service_id
self.conflict_live_list = conflict_live_list
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75bef2c>}
nname: 6
n 6(None)[__doc__ = 'raise when action not possible due to current running live.\n        example : trying to zap a service but devices are buzy\n    '
def __init__(self, service_id, conflict_live_list):
	self.service_id = service_id
	self.conflict_live_list = conflict_live_list

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75bebac>}
nname: 0
n 0(None)[self.service_id = service_id
self.device_id = device_id
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75bee6c>}
nname: 6
n 6(None)[__doc__ = 'Used for not common cases.'
def __init__(self, device_id=None, service_id=None):
	self.service_id = service_id
	self.device_id = device_id

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75bec6c>}
nname: 0
n 0(None)[self.service_id = service_id
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75bedac>}
nname: 6
n 6(None)[__doc__ = 'Exception raised if no live is available.\n    to reslove this => a live should be stop\n\n    Attributes:\n        service_id -- the service required for the live\n    '
def __init__(self, service_id):
	self.service_id = service_id

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75bebec>}
nname: 0
n 0(None)[self.service_id = service_id
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75bef8c>}
nname: 6
n 6(None)[__doc__ = 'Exception raised if starting live failed.\n\n    Attributes:\n        service_id -- the service required for the live\n    '
def __init__(self, service_id):
	self.service_id = service_id

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75beacc>}
nname: 0
n 0(None)[self.service_id = service_id
self.live_id = live_id
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75bef2c>}
nname: 6
n 6(None)[__doc__ = 'Exception raised when palying a live failed.\n\n    Attributes:\n        service_id -- the service required for the live\n        live_id -- id of the live\n    '
def __init__(self, service_id, live_id):
	self.service_id = service_id
	self.live_id = live_id

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75beccc>}
nname: 0
n 0(None)[self.live_id = live_id
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75befac>}
nname: 6
n 6(None)[__doc__ = 'Exception raised when stopping live playing.\n\n    Attributes:\n        live_id -- id of the live\n    '
def __init__(self, live_id):
	self.live_id = live_id

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75beb2c>}
nname: 0
n 0(None)[self.live_id = live_id
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75befec>}
nname: 6
n 6(None)[__doc__ = 'Exception raised when stopping live.\n\n    Attributes:\n        live_id -- id of the live\n    '
def __init__(self, live_id):
	self.live_id = live_id

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75be8ac>}
nname: 6
n 6(None)[__doc__ = 'Exception raised when an action require a live.\n\n    Attributes:\n        \n    '
]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75bef8c>}
nname: 0
n 0(None)[self.live_id = live_id
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75becec>}
nname: 6
n 6(None)[__doc__ = 'Exception raised when trying an action cannot be executed because a recording is running.\n\n    Attributes:\n        live_id -- id of the live\n    '
def __init__(self, live_id):
	self.live_id = live_id

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75bed4c>}
nname: 0
n 0(None)[self.live_id = live_id
self.service_id = service_id
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75bed2c>}
nname: 6
n 6(None)[__doc__ = 'Exception raised when service id is wrong.\n\n    Attributes:\n        live_id -- id of the live\n        service_id -- the service id of the live\n    '
def __init__(self, live_id, service_id):
	self.live_id = live_id
	self.service_id = service_id

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75be7cc>}
nname: 0
n 0(None)[self.live_id = live_id
self.service_id = service_id
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75beeec>}
nname: 6
n 6(None)[__doc__ = 'Exception raised when no device has been found.\n\n    Attributes:\n        live_id -- id of the live\n        service_id -- the service id of the live\n    '
def __init__(self, live_id, service_id):
	self.live_id = live_id
	self.service_id = service_id

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75be74c>}
nname: 0
n 0(None)[self.live_id = live_id
self.service_id = service_id
self.conflict = conflict
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75bee2c>}
nname: 6
n 6(None)[__doc__ = 'Exception raised when their is scheduling conflict.\n\n    Attributes:\n        live_id -- id of the live\n        service_id -- the service id of the live\n        conflict -- InConflictRecording object that contains description of the conflict\n    '
def __init__(self, live_id, service_id, conflict):
	self.live_id = live_id
	self.service_id = service_id
	self.conflict = conflict

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75beaac>}
nname: 0
n 0(None)[self.live_id = live_id
self.service_id = service_id
self.conflict = conflict
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75bed2c>}
nname: 6
n 6(None)[__doc__ = 'Exception raised when their is scheduling conflict.\n\n    Attributes:\n        live_id -- id of the live\n        service_id -- the service id of the live\n        conflict -- InConflictRecording object that contains description of the conflict\n    '
def __init__(self, live_id, service_id, conflict):
	self.live_id = live_id
	self.service_id = service_id
	self.conflict = conflict

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75beccc>}
nname: 0
n 0(None)[self.space_needed = space_needed
self.space_available = space_available
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75befec>}
nname: 6
n 6(None)[__doc__ = ' Exception raised when not enough space is available on record schedule.\n    \n    Attributes:\n        space_needed -- amount in bytes of space needed\n        space_available -- amount in bytes of space available\n    '
def __init__(self, space_needed, space_available):
	self.space_needed = space_needed
	self.space_available = space_available

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75beacc>}
nname: 0
n 0(None)[self.service_id = service_id
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75bee2c>}
nname: 6
n 6(None)[__doc__ = 'Exception raised when no device has been found.\n\n    Attributes:\n        service_id -- the service id of the live\n    '
def __init__(self, service_id):
	self.service_id = service_id

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75bec8c>}
nname: 0
n 0(None)[self.conflict = conflict
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75bed6c>}
nname: 6
n 6(None)[__doc__ = ' conflict error.\n    \n    see InConflictRecording pydoc.\n    '
def __init__(self, conflict):
	self.conflict = conflict

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75bed4c>}
nname: 0
n 0(None)[self.conflict = conflict
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75beb6c>}
nname: 6
n 6(None)[__doc__ = ' conflict error.\n    \n    see InConflictRecording pydoc.\n    '
def __init__(self, conflict):
	self.conflict = conflict

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75be7cc>}
nname: 0
n 0(None)[self.service_id = service_id
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75bec6c>}
nname: 6
n 6(None)[__doc__ = ' unknown service id. from where do you get it?\n    '
def __init__(self, service_id):
	self.service_id = service_id

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75be74c>}
nname: 0
n 0(None)[self.service_id = service_id
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75bee2c>}
nname: 6
n 6(None)[__doc__ = '  no device available for this service.\n    '
def __init__(self, service_id):
	self.service_id = service_id

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75beaac>}
nname: 0
n 0(None)[self.service_id = service_id
self.forced_device_id = forced_device_id
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75bed6c>}
nname: 6
n 6(None)[__doc__ = ' the forced device can not be used for this service id.\n    '
def __init__(self, service_id, forced_device_id):
	self.service_id = service_id
	self.forced_device_id = forced_device_id

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75beccc>}
nname: 0
n 0(None)[]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75be6ac>}
nname: 6
n 6(None)[__doc__ = ' should not happen!\n    '
def __init__(self):
	pass

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75beacc>}
nname: 0
n 0(None)[]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75bef6c>}
nname: 6
n 6(None)[__doc__ = ' should not happen!\n    '
def __init__(self):
	pass

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75bec8c>}
nname: 0
n 0(None)[self.succeed_rec_list = succeed_rec_list
self.failure_list = failure_list
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75bed0c>}
nname: 6
n 6(None)[__doc__ = " raised when some of the recording task have not been scheduled.\n    \n    succeed_rec_list contains the list of recording that have beeen added\n    failure_list is a list of '(SchedulerError, start_time, stop_time)'\n    "
def __init__(self, succeed_rec_list, failure_list):
	self.succeed_rec_list = succeed_rec_list
	self.failure_list = failure_list

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75bed4c>}
nname: 0
n 0(None)[self.rule_type = rule_type
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75bedac>}
nname: 6
n 6(None)[__doc__ = ' a requested rule was not found.\n    '
def __init__(self, rule_type):
	self.rule_type = rule_type

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75be7cc>}
nname: 0
n 0(None)[__doc__ = ' exceptions used by all wyrecord modules.\n'
class WYRecordError(Exception):
	__doc__ = 'Base class for exceptions in this module.'


class LiveControllerError(WYRecordError):
	__doc__ = 'Base class for exceptions in this module.'


class SchedulerError(WYRecordError):
	__doc__ = 'Base class for exceptions in this module.'


class LiveInConflictError(LiveControllerError):
	__doc__ = 'raise when action not possible due to current running live.\n        example : trying to zap a service but devices are buzy\n    '
	def __init__(self, service_id, conflict_live_list):
		self.service_id = service_id
		self.conflict_live_list = conflict_live_list



class DefaultLiveControllerError(LiveControllerError):
	__doc__ = 'Used for not common cases.'
	def __init__(self, device_id=None, service_id=None):
		self.service_id = service_id
		self.device_id = device_id



class NoLiveAvailableError(LiveControllerError):
	__doc__ = 'Exception raised if no live is available.\n    to reslove this => a live should be stop\n\n    Attributes:\n        service_id -- the service required for the live\n    '
	def __init__(self, service_id):
		self.service_id = service_id



class StartingLiveErrors(LiveControllerError):
	__doc__ = 'Exception raised if starting live failed.\n\n    Attributes:\n        service_id -- the service required for the live\n    '
	def __init__(self, service_id):
		self.service_id = service_id



class StartLivePlayingErrors(LiveControllerError):
	__doc__ = 'Exception raised when palying a live failed.\n\n    Attributes:\n        service_id -- the service required for the live\n        live_id -- id of the live\n    '
	def __init__(self, service_id, live_id):
		self.service_id = service_id
		self.live_id = live_id



class StopLivePlayingErrors(LiveControllerError):
	__doc__ = 'Exception raised when stopping live playing.\n\n    Attributes:\n        live_id -- id of the live\n    '
	def __init__(self, live_id):
		self.live_id = live_id



class StopLiveErrors(LiveControllerError):
	__doc__ = 'Exception raised when stopping live.\n\n    Attributes:\n        live_id -- id of the live\n    '
	def __init__(self, live_id):
		self.live_id = live_id



class NoLiveStartedErrors(LiveControllerError):
	__doc__ = 'Exception raised when an action require a live.\n\n    Attributes:\n        \n    '


class LiveIsRecordingErrors(LiveControllerError):
	__doc__ = 'Exception raised when trying an action cannot be executed because a recording is running.\n\n    Attributes:\n        live_id -- id of the live\n    '
	def __init__(self, live_id):
		self.live_id = live_id



class BadServiceIdErrors(LiveControllerError):
	__doc__ = 'Exception raised when service id is wrong.\n\n    Attributes:\n        live_id -- id of the live\n        service_id -- the service id of the live\n    '
	def __init__(self, live_id, service_id):
		self.live_id = live_id
		self.service_id = service_id



class NoDeviceForServiceErrors(LiveControllerError):
	__doc__ = 'Exception raised when no device has been found.\n\n    Attributes:\n        live_id -- id of the live\n        service_id -- the service id of the live\n    '
	def __init__(self, live_id, service_id):
		self.live_id = live_id
		self.service_id = service_id



class SchedulingDoneWithConflictErrors(LiveControllerError):
	__doc__ = 'Exception raised when their is scheduling conflict.\n\n    Attributes:\n        live_id -- id of the live\n        service_id -- the service id of the live\n        conflict -- InConflictRecording object that contains description of the conflict\n    '
	def __init__(self, live_id, service_id, conflict):
		self.live_id = live_id
		self.service_id = service_id
		self.conflict = conflict



class SchedulingFailedOnConflictErrors(LiveControllerError):
	__doc__ = 'Exception raised when their is scheduling conflict.\n\n    Attributes:\n        live_id -- id of the live\n        service_id -- the service id of the live\n        conflict -- InConflictRecording object that contains description of the conflict\n    '
	def __init__(self, live_id, service_id, conflict):
		self.live_id = live_id
		self.service_id = service_id
		self.conflict = conflict



class SchedulingFailedOnDiskSpaceErrors(LiveControllerError):
	__doc__ = ' Exception raised when not enough space is available on record schedule.\n    \n    Attributes:\n        space_needed -- amount in bytes of space needed\n        space_available -- amount in bytes of space available\n    '
	def __init__(self, space_needed, space_available):
		self.space_needed = space_needed
		self.space_available = space_available



class NoDeviceAvailableForServiceErrors(LiveControllerError):
	__doc__ = 'Exception raised when no device has been found.\n\n    Attributes:\n        service_id -- the service id of the live\n    '
	def __init__(self, service_id):
		self.service_id = service_id



class SchedulerConflictError(SchedulerError):
	__doc__ = ' conflict error.\n    \n    see InConflictRecording pydoc.\n    '
	def __init__(self, conflict):
		self.conflict = conflict



class SchedulerConflictWithInstantRecordError(SchedulerError):
	__doc__ = ' conflict error.\n    \n    see InConflictRecording pydoc.\n    '
	def __init__(self, conflict):
		self.conflict = conflict



class SchedulerBadServiceIdError(SchedulerError):
	__doc__ = ' unknown service id. from where do you get it?\n    '
	def __init__(self, service_id):
		self.service_id = service_id



class SchedulerNoDeviceForServiceError(SchedulerError):
	__doc__ = '  no device available for this service.\n    '
	def __init__(self, service_id):
		self.service_id = service_id



class SchedulerForcedDeviceNotValidError(SchedulerError):
	__doc__ = ' the forced device can not be used for this service id.\n    '
	def __init__(self, service_id, forced_device_id):
		self.service_id = service_id
		self.forced_device_id = forced_device_id



class SchedulerRecordingRunningError(SchedulerError):
	__doc__ = ' should not happen!\n    '
	def __init__(self):
		pass



class SchedulerOtherError(SchedulerError):
	__doc__ = ' should not happen!\n    '
	def __init__(self):
		pass



class PeriodicRecordingGenerateError(SchedulerError):
	__doc__ = " raised when some of the recording task have not been scheduled.\n    \n    succeed_rec_list contains the list of recording that have beeen added\n    failure_list is a list of '(SchedulerError, start_time, stop_time)'\n    "
	def __init__(self, succeed_rec_list, failure_list):
		self.succeed_rec_list = succeed_rec_list
		self.failure_list = failure_list



class RuleTypeNotFoundError(SchedulerError):
	__doc__ = ' a requested rule was not found.\n    '
	def __init__(self, rule_type):
		self.rule_type = rule_type



]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75a8a4c>}
__doc__ = ' exceptions used by all wyrecord modules.\n'
class WYRecordError(Exception):
	__doc__ = 'Base class for exceptions in this module.'


class LiveControllerError(WYRecordError):
	__doc__ = 'Base class for exceptions in this module.'


class SchedulerError(WYRecordError):
	__doc__ = 'Base class for exceptions in this module.'


class LiveInConflictError(LiveControllerError):
	__doc__ = 'raise when action not possible due to current running live.\n        example : trying to zap a service but devices are buzy\n    '
	def __init__(self, service_id, conflict_live_list):
		self.service_id = service_id
		self.conflict_live_list = conflict_live_list



class DefaultLiveControllerError(LiveControllerError):
	__doc__ = 'Used for not common cases.'
	def __init__(self, device_id=None, service_id=None):
		self.service_id = service_id
		self.device_id = device_id



class NoLiveAvailableError(LiveControllerError):
	__doc__ = 'Exception raised if no live is available.\n    to reslove this => a live should be stop\n\n    Attributes:\n        service_id -- the service required for the live\n    '
	def __init__(self, service_id):
		self.service_id = service_id



class StartingLiveErrors(LiveControllerError):
	__doc__ = 'Exception raised if starting live failed.\n\n    Attributes:\n        service_id -- the service required for the live\n    '
	def __init__(self, service_id):
		self.service_id = service_id



class StartLivePlayingErrors(LiveControllerError):
	__doc__ = 'Exception raised when palying a live failed.\n\n    Attributes:\n        service_id -- the service required for the live\n        live_id -- id of the live\n    '
	def __init__(self, service_id, live_id):
		self.service_id = service_id
		self.live_id = live_id



class StopLivePlayingErrors(LiveControllerError):
	__doc__ = 'Exception raised when stopping live playing.\n\n    Attributes:\n        live_id -- id of the live\n    '
	def __init__(self, live_id):
		self.live_id = live_id



class StopLiveErrors(LiveControllerError):
	__doc__ = 'Exception raised when stopping live.\n\n    Attributes:\n        live_id -- id of the live\n    '
	def __init__(self, live_id):
		self.live_id = live_id



class NoLiveStartedErrors(LiveControllerError):
	__doc__ = 'Exception raised when an action require a live.\n\n    Attributes:\n        \n    '


class LiveIsRecordingErrors(LiveControllerError):
	__doc__ = 'Exception raised when trying an action cannot be executed because a recording is running.\n\n    Attributes:\n        live_id -- id of the live\n    '
	def __init__(self, live_id):
		self.live_id = live_id



class BadServiceIdErrors(LiveControllerError):
	__doc__ = 'Exception raised when service id is wrong.\n\n    Attributes:\n        live_id -- id of the live\n        service_id -- the service id of the live\n    '
	def __init__(self, live_id, service_id):
		self.live_id = live_id
		self.service_id = service_id



class NoDeviceForServiceErrors(LiveControllerError):
	__doc__ = 'Exception raised when no device has been found.\n\n    Attributes:\n        live_id -- id of the live\n        service_id -- the service id of the live\n    '
	def __init__(self, live_id, service_id):
		self.live_id = live_id
		self.service_id = service_id



class SchedulingDoneWithConflictErrors(LiveControllerError):
	__doc__ = 'Exception raised when their is scheduling conflict.\n\n    Attributes:\n        live_id -- id of the live\n        service_id -- the service id of the live\n        conflict -- InConflictRecording object that contains description of the conflict\n    '
	def __init__(self, live_id, service_id, conflict):
		self.live_id = live_id
		self.service_id = service_id
		self.conflict = conflict



class SchedulingFailedOnConflictErrors(LiveControllerError):
	__doc__ = 'Exception raised when their is scheduling conflict.\n\n    Attributes:\n        live_id -- id of the live\n        service_id -- the service id of the live\n        conflict -- InConflictRecording object that contains description of the conflict\n    '
	def __init__(self, live_id, service_id, conflict):
		self.live_id = live_id
		self.service_id = service_id
		self.conflict = conflict



class SchedulingFailedOnDiskSpaceErrors(LiveControllerError):
	__doc__ = ' Exception raised when not enough space is available on record schedule.\n    \n    Attributes:\n        space_needed -- amount in bytes of space needed\n        space_available -- amount in bytes of space available\n    '
	def __init__(self, space_needed, space_available):
		self.space_needed = space_needed
		self.space_available = space_available



class NoDeviceAvailableForServiceErrors(LiveControllerError):
	__doc__ = 'Exception raised when no device has been found.\n\n    Attributes:\n        service_id -- the service id of the live\n    '
	def __init__(self, service_id):
		self.service_id = service_id



class SchedulerConflictError(SchedulerError):
	__doc__ = ' conflict error.\n    \n    see InConflictRecording pydoc.\n    '
	def __init__(self, conflict):
		self.conflict = conflict



class SchedulerConflictWithInstantRecordError(SchedulerError):
	__doc__ = ' conflict error.\n    \n    see InConflictRecording pydoc.\n    '
	def __init__(self, conflict):
		self.conflict = conflict



class SchedulerBadServiceIdError(SchedulerError):
	__doc__ = ' unknown service id. from where do you get it?\n    '
	def __init__(self, service_id):
		self.service_id = service_id



class SchedulerNoDeviceForServiceError(SchedulerError):
	__doc__ = '  no device available for this service.\n    '
	def __init__(self, service_id):
		self.service_id = service_id



class SchedulerForcedDeviceNotValidError(SchedulerError):
	__doc__ = ' the forced device can not be used for this service id.\n    '
	def __init__(self, service_id, forced_device_id):
		self.service_id = service_id
		self.forced_device_id = forced_device_id



class SchedulerRecordingRunningError(SchedulerError):
	__doc__ = ' should not happen!\n    '
	def __init__(self):
		pass



class SchedulerOtherError(SchedulerError):
	__doc__ = ' should not happen!\n    '
	def __init__(self):
		pass



class PeriodicRecordingGenerateError(SchedulerError):
	__doc__ = " raised when some of the recording task have not been scheduled.\n    \n    succeed_rec_list contains the list of recording that have beeen added\n    failure_list is a list of '(SchedulerError, start_time, stop_time)'\n    "
	def __init__(self, succeed_rec_list, failure_list):
		self.succeed_rec_list = succeed_rec_list
		self.failure_list = failure_list



class RuleTypeNotFoundError(SchedulerError):
	__doc__ = ' a requested rule was not found.\n    '
	def __init__(self, rule_type):
		self.rule_type = rule_type



