# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 0
n 0(None)[self.wyscan = wyscan
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7769fac>}
nname: 0
n 0(None)[return {'status': error.WYRECORD_UNKNOWN_ERROR}
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76f028c>}
nname: 0
n 0(None)[return error.WYRECORD_SUCCESS
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7769f2c>}
nname: 0
n 0(None)[return ret
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7769e2c>}
nname: 0
n 0(None)[log.info('call Record_AreServicesCompatible')
ret = False
return ret
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76f01cc>}
nname: 0
n 0(None)[ret = None
return ret
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7769f2c>}
nname: 0
n 0(None)[]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7769e2c>}
nname: 0
n 0(None)[]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7769fac>}
nname: 0
n 0(None)[ret = False
return ret
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7769dec>}
nname: 0
n 0(None)[return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7769dec>}
nname: 0
n 0(None)[return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7769f2c>}
nname: 0
n 0(None)[return []
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7769e2c>}
nname: 6
n 6(None)[def __init__(self, wyscan):
	self.wyscan = wyscan

def startService(self, service, device, uri, service_to_stop=WYSCAN_RECORDING_ID_NULL):
	return {'status': error.WYRECORD_UNKNOWN_ERROR}

def stopService(self, wyscan_recording_id):
	return error.WYRECORD_SUCCESS

GetCurrentUTCTime = Chrono(['wyrecord'])()
GetDeviceCurrentUTCTime = Chrono(['wyrecord'])()
def GetPlayableServiceDevices(self, nServiceID):
	return ret

def AreServicesPlayable(self, nDeviceID1, nServiceID1, nDeviceID2, nServiceID2):
	log.info('call Record_AreServicesCompatible')
	ret = False
	return ret

def EPGFromProgramId(self, program_id):
	ret = None
	return ret

def startExternEIT(self, path, serviceid):
	pass

def stopExternEIT(self):
	pass

def StopDeviceRecordings(self, nDeviceID=0):
	ret = False
	return ret

def GetService(self, nServiceID):
	return None

def GetServiceByName(self, service_name):
	return None

def GetDevices(self, nDeviceID=-1, nDeviceType=-1):
	return []

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb77698ac>}
nname: 0
n 0(None)[self.wyscan = wyscan
self.lock = Lock()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76f020c>}
nname: 332
n 332(None)[recording_id = result[1]
device_id = result[2]
return {'status': error.WYRECORD_SUCCESS, 'wyscan_recording_id': recording_id, 'deviceid': device_id}
]:
	i: 284(), 331()
	o: 

nname: 331
n 331(None)[]:
	i: 268(f)
	o: 332()

nname: 284
n 284(None)[log.error("Can not start recording '%s' (Error %d)" % (service, result[0]))
return {'status': error.WYRECORD_UNKNOWN_ERROR}
]:
	i: 268(t)
	o: 332()

nname: 268
n 268(result[0] != 0)[]:
	i: 182(), 209(), 266(AE)
	o: 284(t), 331(f)

nname: 266
n 266(None)[]:
	i: 199(f)
	o: 268(AE)

nname: 209
n 209(None)[#, e
self.lock.release()
log.debug(str(e))
return {'status': error.WYRECORD_UNKNOWN_ERROR}
]:
	i: 199(t)
	o: 268()

nname: 199
n 199(<dummy_ex3> EXC_MATCH BaseException)[]:
	i: 36(except)
	o: 209(t), 266(f)

nname: 182
n 182(None)[self.lock.release()
]:
	i: 94(), 138()
	o: 268()

nname: 138
n 138(None)[result = self.wyscan.Record_ZapEx(service_to_stop, device, service, 'NormalLive', parameters, 2)
timestep('wyscan.Record_ZapEx')
]:
	i: 78(t)
	o: 182()

nname: 94
n 94(None)[result = self.wyscan.Record_StartRecordingEx(device, service, 'NormalLive', parameters, 2)
timestep('wyscan.Record_StartRecordingEx')
]:
	i: 78(f)
	o: 182()

nname: 78
n 78(service_to_stop)[timestep('dvb_start_service_init')
]:
	i: 36(try)
	o: 94(f), 138(t)

nname: 36
n 36(None)[unix_socket_path = uri[len(URL_PREFIX_UNIX_SOCKET):]
parameters = "unix_socket_path='%s'" % unix_socket_path
self.lock.acquire()
]:
	i: 15(), 35()
	o: 78(try), 199(except)

nname: 35
n 35(None)[]:
	i: 0(t)
	o: 36()

nname: 15
n 15(None)[return {'status': error.WYRECORD_UNKNOWN_ERROR}
]:
	i: 0(f)
	o: 36()

nname: 0
n 0(uri.startswith(URL_PREFIX_UNIX_SOCKET))[]:
	i: 
	o: 15(f), 35(t)

nname: 268
n 268(None)[if result[0] != 0:
	log.error("Can not start recording '%s' (Error %d)" % (service, result[0]))
	return {'status': error.WYRECORD_UNKNOWN_ERROR}
recording_id = result[1]
device_id = result[2]
return {'status': error.WYRECORD_SUCCESS, 'wyscan_recording_id': recording_id, 'deviceid': device_id}
]:
	i: 182(), 199()
	o: 

nname: 199
n 199(None)[except BaseException, e:
	self.lock.release()
	log.debug(str(e))
	return {'status': error.WYRECORD_UNKNOWN_ERROR}
]:
	i: 78()
	o: 268()

nname: 182
n 182(None)[self.lock.release()
]:
	i: 78()
	o: 268()

nname: 78
n 78(None)[try:
	timestep('dvb_start_service_init')
	if not service_to_stop:
		result = self.wyscan.Record_StartRecordingEx(device, service, 'NormalLive', parameters, 2)
		timestep('wyscan.Record_StartRecordingEx')
	else:
		result = self.wyscan.Record_ZapEx(service_to_stop, device, service, 'NormalLive', parameters, 2)
		timestep('wyscan.Record_ZapEx')
]:
	i: 0(try)
	o: 182(), 199()

nname: 0
n 0(None)[if not uri.startswith(URL_PREFIX_UNIX_SOCKET):
	return {'status': error.WYRECORD_UNKNOWN_ERROR}
unix_socket_path = uri[len(URL_PREFIX_UNIX_SOCKET):]
parameters = "unix_socket_path='%s'" % unix_socket_path
self.lock.acquire()
]:
	i: 
	o: 78(try)

nname: 268
n 268(None)[if result[0] != 0:
	log.error("Can not start recording '%s' (Error %d)" % (service, result[0]))
	return {'status': error.WYRECORD_UNKNOWN_ERROR}
recording_id = result[1]
device_id = result[2]
return {'status': error.WYRECORD_SUCCESS, 'wyscan_recording_id': recording_id, 'deviceid': device_id}
]:
	i: 182(), 199()
	o: 

nname: 199
n 199(None)[except BaseException, e:
	self.lock.release()
	log.debug(str(e))
	return {'status': error.WYRECORD_UNKNOWN_ERROR}
]:
	i: 0()
	o: 268()

nname: 182
n 182(None)[self.lock.release()
]:
	i: 0()
	o: 268()

nname: 0
n 0(None)[if not uri.startswith(URL_PREFIX_UNIX_SOCKET):
	return {'status': error.WYRECORD_UNKNOWN_ERROR}
unix_socket_path = uri[len(URL_PREFIX_UNIX_SOCKET):]
parameters = "unix_socket_path='%s'" % unix_socket_path
self.lock.acquire()
try:
	timestep('dvb_start_service_init')
	if not service_to_stop:
		result = self.wyscan.Record_StartRecordingEx(device, service, 'NormalLive', parameters, 2)
		timestep('wyscan.Record_StartRecordingEx')
	else:
		result = self.wyscan.Record_ZapEx(service_to_stop, device, service, 'NormalLive', parameters, 2)
		timestep('wyscan.Record_ZapEx')
]:
	i: 
	o: 182(), 199()

self.nodes: {0: <unpyclib.structure.node instance at 0xb76fd68c>, 199: <unpyclib.structure.node instance at 0xb76fd7ac>, 268: <unpyclib.structure.node instance at 0xb76fd9ec>, 182: <unpyclib.structure.node instance at 0xb76f490c>}
nname: 172
n 172(None)[return error.WYRECORD_SUCCESS
]:
	i: 143(), 171()
	o: 

nname: 171
n 171(None)[]:
	i: 108(f)
	o: 172()

nname: 143
n 143(None)[log.error('Can not stop recording %d' % wyscan_recording_id)
return error.WYRECORD_BAD_RECORDING_ID
]:
	i: 108(t)
	o: 172()

nname: 108
n 108(result != 0)[self.lock.release()
timestep('dvb_stop_service_wyscan_time')
]:
	i: 26(), 58(), 106(AE)
	o: 143(t), 171(f)

nname: 106
n 106(None)[]:
	i: 48(f)
	o: 108(AE)

nname: 58
n 58(None)[#, e
self.lock.release()
log.debug(str(e))
return error.WYRECORD_UNKNOWN_ERROR
]:
	i: 48(t)
	o: 108()

nname: 48
n 48(<dummy_ex3> EXC_MATCH BaseException)[]:
	i: 0(except)
	o: 58(t), 106(f)

nname: 26
n 26(None)[result = self.wyscan.Record_StopRecording(wyscan_recording_id)
]:
	i: 0(try)
	o: 108()

nname: 0
n 0(None)[timestep('dvb_stop_service_init')
self.lock.acquire()
]:
	i: 
	o: 26(try), 48(except)

nname: 172
n 172(None)[return error.WYRECORD_SUCCESS
]:
	i: 48()
	o: 

nname: 48
n 48(None)[except BaseException, e:
	self.lock.release()
	log.debug(str(e))
	return error.WYRECORD_UNKNOWN_ERROR
self.lock.release()
timestep('dvb_stop_service_wyscan_time')
if result != 0:
	log.error('Can not stop recording %d' % wyscan_recording_id)
	return error.WYRECORD_BAD_RECORDING_ID
]:
	i: 0()
	o: 172()

nname: 0
n 0(None)[timestep('dvb_stop_service_init')
self.lock.acquire()
try:
	result = self.wyscan.Record_StopRecording(wyscan_recording_id)
]:
	i: 
	o: 48()

nname: 172
n 172(None)[return error.WYRECORD_SUCCESS
]:
	i: 0()
	o: 

nname: 0
n 0(None)[timestep('dvb_stop_service_init')
self.lock.acquire()
try:
	result = self.wyscan.Record_StopRecording(wyscan_recording_id)
except BaseException, e:
	self.lock.release()
	log.debug(str(e))
	return error.WYRECORD_UNKNOWN_ERROR
self.lock.release()
timestep('dvb_stop_service_wyscan_time')
if result != 0:
	log.error('Can not stop recording %d' % wyscan_recording_id)
	return error.WYRECORD_BAD_RECORDING_ID
]:
	i: 
	o: 172()

nname: 0
n 0(None)[timestep('dvb_stop_service_init')
self.lock.acquire()
try:
	result = self.wyscan.Record_StopRecording(wyscan_recording_id)
except BaseException, e:
	self.lock.release()
	log.debug(str(e))
	return error.WYRECORD_UNKNOWN_ERROR
self.lock.release()
timestep('dvb_stop_service_wyscan_time')
if result != 0:
	log.error('Can not stop recording %d' % wyscan_recording_id)
	return error.WYRECORD_BAD_RECORDING_ID
return error.WYRECORD_SUCCESS
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76fd3ac>}
nname: 120
n 120(None)[self.lock.release()
return ret
]:
	i: 70(), 90(), 118(AE)
	o: 

nname: 118
n 118(None)[]:
	i: 80(f)
	o: 120(AE)

nname: 90
n 90(None)[#, e
log.debug(str(e))
]:
	i: 80(t)
	o: 120()

nname: 80
n 80(<dummy_ex3> EXC_MATCH BaseException)[]:
	i: 0(except)
	o: 90(t), 118(f)

nname: 70
n 70(None)[del _[1]
for ret in self.wyscan.GetServiceDevices(nServiceID):
]:
	i: 22(AF), 48()
	o: 120()

nname: 48
n 48(None)[for dev in self.wyscan.GetServiceDevices(nServiceID):
]:
	i: 22(for)
	o: 70()

nname: 22
n 22(None)[]:
	i: 0(try)
	o: 48(for), 70(AF)

nname: 0
n 0(None)[ret = []
self.lock.acquire()
]:
	i: 
	o: 22(try), 80(except)

nname: 120
n 120(None)[self.lock.release()
return ret
]:
	i: 70(), 80()
	o: 

nname: 80
n 80(None)[except BaseException, e:
	log.debug(str(e))
]:
	i: 0()
	o: 120()

nname: 70
n 70(None)[del _[1]
for ret in self.wyscan.GetServiceDevices(nServiceID):
]:
	i: 0(AF), 48()
	o: 120()

nname: 48
n 48(None)[for dev in self.wyscan.GetServiceDevices(nServiceID):
]:
	i: 0(for)
	o: 70()

nname: 0
n 0(None)[ret = []
self.lock.acquire()
try:
	pass
]:
	i: 
	o: 48(for), 70(AF), 80()

self.nodes: {0: <unpyclib.structure.node instance at 0xb76fdd8c>, 80: <unpyclib.structure.node instance at 0xb76fde6c>, 70: <unpyclib.structure.node instance at 0xb76fd5ec>, 48: <unpyclib.structure.node instance at 0xb76fdeac>, 120: <unpyclib.structure.node instance at 0xb76fdd6c>}
nname: 123
n 123(None)[self.lock.release()
return ret
]:
	i: 79(), 93(), 121(AE)
	o: 

nname: 121
n 121(None)[]:
	i: 83(f)
	o: 123(AE)

nname: 93
n 93(None)[#, e
log.debug(str(e))
]:
	i: 83(t)
	o: 123()

nname: 83
n 83(<dummy_ex3> EXC_MATCH BaseException)[]:
	i: 0(except)
	o: 93(t), 121(f)

nname: 79
n 79(None)[]:
	i: 68(), 78()
	o: 123()

nname: 78
n 78(None)[]:
	i: 35(f)
	o: 79()

nname: 68
n 68(None)[ret = True
]:
	i: 35(t)
	o: 79()

nname: 35
n 35(self.wyscan.Record_AreServicesCompatible(nDeviceID1, nServiceID1, nDeviceID2, nServiceID2) == 0)[]:
	i: 0(try)
	o: 68(t), 78(f)

nname: 0
n 0(None)[log.info('call Record_AreServicesCompatible')
self.lock.acquire()
ret = False
]:
	i: 
	o: 35(try), 83(except)

nname: 123
n 123(None)[self.lock.release()
return ret
]:
	i: 83(), 0()
	o: 

nname: 83
n 83(None)[except BaseException, e:
	log.debug(str(e))
]:
	i: 0()
	o: 123()

nname: 123
n 123(None)[self.lock.release()
return ret
]:
	i: 83(), 0()
	o: 

nname: 0
n 0(None)[log.info('call Record_AreServicesCompatible')
self.lock.acquire()
ret = False
try:
	if self.wyscan.Record_AreServicesCompatible(nDeviceID1, nServiceID1, nDeviceID2, nServiceID2) == 0:
		ret = True
]:
	i: 
	o: 123(), 83()

self.nodes: {0: <unpyclib.structure.node instance at 0xb76fdb6c>, 83: <unpyclib.structure.node instance at 0xb76fd5cc>, 123: <unpyclib.structure.node instance at 0xb76fdf0c>}
nname: 84
n 84(None)[self.lock.release()
return ret
]:
	i: 22(), 54(), 82(AE)
	o: 

nname: 82
n 82(None)[]:
	i: 44(f)
	o: 84(AE)

nname: 54
n 54(None)[#, e
log.debug(str(e))
]:
	i: 44(t)
	o: 84()

nname: 44
n 44(<dummy_ex3> EXC_MATCH BaseException)[]:
	i: 0(except)
	o: 54(t), 82(f)

nname: 22
n 22(None)[ret = self.wyscan.EPGFromProgramId(program_id)
]:
	i: 0(try)
	o: 84()

nname: 0
n 0(None)[self.lock.acquire()
ret = None
]:
	i: 
	o: 22(try), 44(except)

nname: 44
n 44(None)[except BaseException, e:
	log.debug(str(e))
self.lock.release()
return ret
]:
	i: 0()
	o: 

nname: 0
n 0(None)[self.lock.acquire()
ret = None
try:
	ret = self.wyscan.EPGFromProgramId(program_id)
]:
	i: 
	o: 44()

nname: 0
n 0(None)[self.lock.acquire()
ret = None
try:
	ret = self.wyscan.EPGFromProgramId(program_id)
except BaseException, e:
	log.debug(str(e))
self.lock.release()
return ret
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76fddac>}
nname: 79
n 79(None)[self.lock.release()
]:
	i: 16(), 49(), 77(AE)
	o: 

nname: 77
n 77(None)[]:
	i: 39(f)
	o: 79(AE)

nname: 49
n 49(None)[#, e
log.debug(str(e))
]:
	i: 39(t)
	o: 79()

nname: 39
n 39(<dummy_ex3> EXC_MATCH BaseException)[]:
	i: 0(except)
	o: 49(t), 77(f)

nname: 16
n 16(None)[self.wyscan.startExternEIT(path, serviceid)
]:
	i: 0(try)
	o: 79()

nname: 0
n 0(None)[self.lock.acquire()
]:
	i: 
	o: 16(try), 39(except)

nname: 39
n 39(None)[except BaseException, e:
	log.debug(str(e))
self.lock.release()
]:
	i: 0()
	o: 

nname: 0
n 0(None)[self.lock.acquire()
try:
	self.wyscan.startExternEIT(path, serviceid)
]:
	i: 
	o: 39()

nname: 0
n 0(None)[self.lock.acquire()
try:
	self.wyscan.startExternEIT(path, serviceid)
except BaseException, e:
	log.debug(str(e))
self.lock.release()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76fde6c>}
nname: 76
n 76(None)[self.lock.release()
]:
	i: 16(), 46(), 74(AE)
	o: 

nname: 74
n 74(None)[]:
	i: 36(f)
	o: 76(AE)

nname: 46
n 46(None)[#, e
log.debug(str(e))
]:
	i: 36(t)
	o: 76()

nname: 36
n 36(<dummy_ex3> EXC_MATCH BaseException)[]:
	i: 0(except)
	o: 46(t), 74(f)

nname: 16
n 16(None)[self.wyscan.stopExternEIT(0)
]:
	i: 0(try)
	o: 76()

nname: 0
n 0(None)[self.lock.acquire()
]:
	i: 
	o: 16(try), 36(except)

nname: 36
n 36(None)[except BaseException, e:
	log.debug(str(e))
self.lock.release()
]:
	i: 0()
	o: 

nname: 0
n 0(None)[self.lock.acquire()
try:
	self.wyscan.stopExternEIT(0)
]:
	i: 
	o: 36()

nname: 0
n 0(None)[self.lock.acquire()
try:
	self.wyscan.stopExternEIT(0)
except BaseException, e:
	log.debug(str(e))
self.lock.release()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76fdb6c>}
nname: 101
n 101(None)[self.lock.release()
return ret
]:
	i: 57(), 71(), 99(AE)
	o: 

nname: 99
n 99(None)[]:
	i: 61(f)
	o: 101(AE)

nname: 71
n 71(None)[#, e
log.debug(str(e))
]:
	i: 61(t)
	o: 101()

nname: 61
n 61(<dummy_ex3> EXC_MATCH BaseException)[]:
	i: 0(except)
	o: 71(t), 99(f)

nname: 57
n 57(None)[]:
	i: 46(), 56()
	o: 101()

nname: 56
n 56(None)[]:
	i: 22(f)
	o: 57()

nname: 46
n 46(None)[ret = True
]:
	i: 22(t)
	o: 57()

nname: 22
n 22(self.wyscan.Record_StopDeviceRecordings(nDeviceID) == 0)[]:
	i: 0(try)
	o: 46(t), 56(f)

nname: 0
n 0(None)[self.lock.acquire()
ret = False
]:
	i: 
	o: 22(try), 61(except)

nname: 101
n 101(None)[self.lock.release()
return ret
]:
	i: 61(), 0()
	o: 

nname: 61
n 61(None)[except BaseException, e:
	log.debug(str(e))
]:
	i: 0()
	o: 101()

nname: 101
n 101(None)[self.lock.release()
return ret
]:
	i: 61(), 0()
	o: 

nname: 0
n 0(None)[self.lock.acquire()
ret = False
try:
	if self.wyscan.Record_StopDeviceRecordings(nDeviceID) == 0:
		ret = True
]:
	i: 
	o: 101(), 61()

self.nodes: {0: <unpyclib.structure.node instance at 0xb76fda0c>, 101: <unpyclib.structure.node instance at 0xb76fdb2c>, 61: <unpyclib.structure.node instance at 0xb76fd84c>}
nname: 170
n 170(None)[return WyScan.Service(result[1][0], 2)
]:
	i: 161(), 169()
	o: 

nname: 169
n 169(None)[]:
	i: 139(f)
	o: 170()

nname: 161
n 161(None)[return None
]:
	i: 139(t)
	o: 170()

nname: 139
n 139(len(result[1]) == 0)[]:
	i: 130(), 138()
	o: 161(t), 169(f)

nname: 138
n 138(None)[]:
	i: 114(f)
	o: 139()

nname: 130
n 130(None)[return None
]:
	i: 114(t)
	o: 139()

nname: 114
n 114(result[0] != 0)[]:
	i: 3(), 67(), 112(AE)
	o: 130(t), 138(f)

nname: 112
n 112(None)[]:
	i: 57(f)
	o: 114(AE)

nname: 67
n 67(None)[#, e
log.debug(str(e))
self.lock.release()
return None
]:
	i: 57(t)
	o: 114()

nname: 57
n 57(<dummy_ex3> EXC_MATCH BaseException)[]:
	i: 0(except)
	o: 67(t), 112(f)

nname: 3
n 3(None)[self.lock.acquire()
result = self.wyscan.GetService(nServiceID, nFormat=2)
self.lock.release()
]:
	i: 0(try)
	o: 114()

nname: 0
n 0(None)[]:
	i: 
	o: 3(try), 57(except)

nname: 139
n 139(None)[if len(result[1]) == 0:
	return None
return WyScan.Service(result[1][0], 2)
]:
	i: 57()
	o: 

nname: 57
n 57(None)[except BaseException, e:
	log.debug(str(e))
	self.lock.release()
	return None
if result[0] != 0:
	return None
]:
	i: 0()
	o: 139()

nname: 0
n 0(None)[try:
	self.lock.acquire()
	result = self.wyscan.GetService(nServiceID, nFormat=2)
	self.lock.release()
]:
	i: 
	o: 57()

nname: 139
n 139(None)[if len(result[1]) == 0:
	return None
return WyScan.Service(result[1][0], 2)
]:
	i: 0()
	o: 

nname: 0
n 0(None)[try:
	self.lock.acquire()
	result = self.wyscan.GetService(nServiceID, nFormat=2)
	self.lock.release()
except BaseException, e:
	log.debug(str(e))
	self.lock.release()
	return None
if result[0] != 0:
	return None
]:
	i: 
	o: 139()

nname: 0
n 0(None)[try:
	self.lock.acquire()
	result = self.wyscan.GetService(nServiceID, nFormat=2)
	self.lock.release()
except BaseException, e:
	log.debug(str(e))
	self.lock.release()
	return None
if result[0] != 0:
	return None
if len(result[1]) == 0:
	return None
return WyScan.Service(result[1][0], 2)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76fd58c>}
nname: 133
n 133(None)[return Service(result[1][0], 0)
]:
	i: 124(), 132()
	o: 

nname: 132
n 132(None)[]:
	i: 95(f)
	o: 133()

nname: 124
n 124(None)[return None
]:
	i: 95(t)
	o: 133()

nname: 95
n 95(result[0] != 0)[self.lock.release()
]:
	i: 16(), 48(), 93(AE)
	o: 124(t), 132(f)

nname: 93
n 93(None)[]:
	i: 38(f)
	o: 95(AE)

nname: 48
n 48(None)[#, e
log.debug(str(e))
self.lock.release()
return None
]:
	i: 38(t)
	o: 95()

nname: 38
n 38(<dummy_ex3> EXC_MATCH BaseException)[]:
	i: 0(except)
	o: 48(t), 93(f)

nname: 16
n 16(None)[result = self.wyscan.GetServicesByName(service_name)
]:
	i: 0(try)
	o: 95()

nname: 0
n 0(None)[self.lock.acquire()
]:
	i: 
	o: 16(try), 38(except)

nname: 133
n 133(None)[return Service(result[1][0], 0)
]:
	i: 38()
	o: 

nname: 38
n 38(None)[except BaseException, e:
	log.debug(str(e))
	self.lock.release()
	return None
self.lock.release()
if result[0] != 0:
	return None
]:
	i: 0()
	o: 133()

nname: 0
n 0(None)[self.lock.acquire()
try:
	result = self.wyscan.GetServicesByName(service_name)
]:
	i: 
	o: 38()

nname: 133
n 133(None)[return Service(result[1][0], 0)
]:
	i: 0()
	o: 

nname: 0
n 0(None)[self.lock.acquire()
try:
	result = self.wyscan.GetServicesByName(service_name)
except BaseException, e:
	log.debug(str(e))
	self.lock.release()
	return None
self.lock.release()
if result[0] != 0:
	return None
]:
	i: 
	o: 133()

nname: 0
n 0(None)[self.lock.acquire()
try:
	result = self.wyscan.GetServicesByName(service_name)
except BaseException, e:
	log.debug(str(e))
	self.lock.release()
	return None
self.lock.release()
if result[0] != 0:
	return None
return Service(result[1][0], 0)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76fd70c>}
nname: 98
n 98(None)[self.lock.release()
return result
]:
	i: 16(), 51(), 96(AE)
	o: 

nname: 96
n 96(None)[]:
	i: 41(f)
	o: 98(AE)

nname: 51
n 51(None)[#, e
log.debug(str(e))
self.lock.release()
return []
]:
	i: 41(t)
	o: 98()

nname: 41
n 41(<dummy_ex3> EXC_MATCH BaseException)[]:
	i: 0(except)
	o: 51(t), 96(f)

nname: 16
n 16(None)[result = self.wyscan.GetDevices(nDeviceID, nDeviceType)
]:
	i: 0(try)
	o: 98()

nname: 0
n 0(None)[self.lock.acquire()
]:
	i: 
	o: 16(try), 41(except)

nname: 41
n 41(None)[except BaseException, e:
	log.debug(str(e))
	self.lock.release()
	return []
self.lock.release()
return result
]:
	i: 0()
	o: 

nname: 0
n 0(None)[self.lock.acquire()
try:
	result = self.wyscan.GetDevices(nDeviceID, nDeviceType)
]:
	i: 
	o: 41()

nname: 0
n 0(None)[self.lock.acquire()
try:
	result = self.wyscan.GetDevices(nDeviceID, nDeviceType)
except BaseException, e:
	log.debug(str(e))
	self.lock.release()
	return []
self.lock.release()
return result
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76fd52c>}
nname: 6
n 6(None)[def __init__(self, wyscan):
	self.wyscan = wyscan
	self.lock = Lock()

def startService(self, service, device, uri, service_to_stop=WYSCAN_RECORDING_ID_NULL):
	if not uri.startswith(URL_PREFIX_UNIX_SOCKET):
		return {'status': error.WYRECORD_UNKNOWN_ERROR}
	unix_socket_path = uri[len(URL_PREFIX_UNIX_SOCKET):]
	parameters = "unix_socket_path='%s'" % unix_socket_path
	self.lock.acquire()
	try:
		timestep('dvb_start_service_init')
		if not service_to_stop:
			result = self.wyscan.Record_StartRecordingEx(device, service, 'NormalLive', parameters, 2)
			timestep('wyscan.Record_StartRecordingEx')
		else:
			result = self.wyscan.Record_ZapEx(service_to_stop, device, service, 'NormalLive', parameters, 2)
			timestep('wyscan.Record_ZapEx')

def stopService(self, wyscan_recording_id):
	timestep('dvb_stop_service_init')
	self.lock.acquire()
	try:
		result = self.wyscan.Record_StopRecording(wyscan_recording_id)
	except BaseException, e:
		self.lock.release()
		log.debug(str(e))
		return error.WYRECORD_UNKNOWN_ERROR
	self.lock.release()
	timestep('dvb_stop_service_wyscan_time')
	if result != 0:
		log.error('Can not stop recording %d' % wyscan_recording_id)
		return error.WYRECORD_BAD_RECORDING_ID
	return error.WYRECORD_SUCCESS

GetCurrentUTCTime = Chrono(['wyrecord'])()
GetDeviceCurrentUTCTime = Chrono(['wyrecord'])()
def GetPlayableServiceDevices(self, nServiceID):
	ret = []
	self.lock.acquire()
	try:
		pass

def AreServicesPlayable(self, nDeviceID1, nServiceID1, nDeviceID2, nServiceID2):
	log.info('call Record_AreServicesCompatible')
	self.lock.acquire()
	ret = False
	try:
		if self.wyscan.Record_AreServicesCompatible(nDeviceID1, nServiceID1, nDeviceID2, nServiceID2) == 0:
			ret = True

def EPGFromProgramId(self, program_id):
	self.lock.acquire()
	ret = None
	try:
		ret = self.wyscan.EPGFromProgramId(program_id)
	except BaseException, e:
		log.debug(str(e))
	self.lock.release()
	return ret

def startExternEIT(self, path, serviceid):
	self.lock.acquire()
	try:
		self.wyscan.startExternEIT(path, serviceid)
	except BaseException, e:
		log.debug(str(e))
	self.lock.release()

def stopExternEIT(self):
	self.lock.acquire()
	try:
		self.wyscan.stopExternEIT(0)
	except BaseException, e:
		log.debug(str(e))
	self.lock.release()

def StopDeviceRecordings(self, nDeviceID=0):
	self.lock.acquire()
	ret = False
	try:
		if self.wyscan.Record_StopDeviceRecordings(nDeviceID) == 0:
			ret = True

def GetService(self, nServiceID):
	try:
		self.lock.acquire()
		result = self.wyscan.GetService(nServiceID, nFormat=2)
		self.lock.release()
	except BaseException, e:
		log.debug(str(e))
		self.lock.release()
		return None
	if result[0] != 0:
		return None
	if len(result[1]) == 0:
		return None
	return WyScan.Service(result[1][0], 2)

def GetServiceByName(self, service_name):
	self.lock.acquire()
	try:
		result = self.wyscan.GetServicesByName(service_name)
	except BaseException, e:
		log.debug(str(e))
		self.lock.release()
		return None
	self.lock.release()
	if result[0] != 0:
		return None
	return Service(result[1][0], 0)

def GetDevices(self, nDeviceID=-1, nDeviceType=-1):
	self.lock.acquire()
	try:
		result = self.wyscan.GetDevices(nDeviceID, nDeviceType)
	except BaseException, e:
		log.debug(str(e))
		self.lock.release()
		return []
	self.lock.release()
	return result

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb776984c>}
nname: 0
n 0(None)[from logger import log
import time
import error
from peewee.analyse import Chrono
from peewee.analyse import timestep
from config import URL_PREFIX_UNIX_SOCKET
import WyScan
from WyScan import Service
from WyScan import Device
from threading import Lock
WYSCAN_RECORDING_ID_NULL = 0
class ExternalDVBManagerInterface(object):
	def __init__(self, wyscan):
		self.wyscan = wyscan

	def startService(self, service, device, uri, service_to_stop=WYSCAN_RECORDING_ID_NULL):
		return {'status': error.WYRECORD_UNKNOWN_ERROR}

	def stopService(self, wyscan_recording_id):
		return error.WYRECORD_SUCCESS

	GetCurrentUTCTime = Chrono(['wyrecord'])()
	GetDeviceCurrentUTCTime = Chrono(['wyrecord'])()
	def GetPlayableServiceDevices(self, nServiceID):
		return ret

	def AreServicesPlayable(self, nDeviceID1, nServiceID1, nDeviceID2, nServiceID2):
		log.info('call Record_AreServicesCompatible')
		ret = False
		return ret

	def EPGFromProgramId(self, program_id):
		ret = None
		return ret

	def startExternEIT(self, path, serviceid):
		pass

	def stopExternEIT(self):
		pass

	def StopDeviceRecordings(self, nDeviceID=0):
		ret = False
		return ret

	def GetService(self, nServiceID):
		return None

	def GetServiceByName(self, service_name):
		return None

	def GetDevices(self, nDeviceID=-1, nDeviceType=-1):
		return []



class ExternalDVBManager(ExternalDVBManagerInterface):
	def __init__(self, wyscan):
		self.wyscan = wyscan
		self.lock = Lock()

	def startService(self, service, device, uri, service_to_stop=WYSCAN_RECORDING_ID_NULL):
		if not uri.startswith(URL_PREFIX_UNIX_SOCKET):
			return {'status': error.WYRECORD_UNKNOWN_ERROR}
		unix_socket_path = uri[len(URL_PREFIX_UNIX_SOCKET):]
		parameters = "unix_socket_path='%s'" % unix_socket_path
		self.lock.acquire()
		try:
			timestep('dvb_start_service_init')
			if not service_to_stop:
				result = self.wyscan.Record_StartRecordingEx(device, service, 'NormalLive', parameters, 2)
				timestep('wyscan.Record_StartRecordingEx')
			else:
				result = self.wyscan.Record_ZapEx(service_to_stop, device, service, 'NormalLive', parameters, 2)
				timestep('wyscan.Record_ZapEx')

	def stopService(self, wyscan_recording_id):
		timestep('dvb_stop_service_init')
		self.lock.acquire()
		try:
			result = self.wyscan.Record_StopRecording(wyscan_recording_id)
		except BaseException, e:
			self.lock.release()
			log.debug(str(e))
			return error.WYRECORD_UNKNOWN_ERROR
		self.lock.release()
		timestep('dvb_stop_service_wyscan_time')
		if result != 0:
			log.error('Can not stop recording %d' % wyscan_recording_id)
			return error.WYRECORD_BAD_RECORDING_ID
		return error.WYRECORD_SUCCESS

	GetCurrentUTCTime = Chrono(['wyrecord'])()
	GetDeviceCurrentUTCTime = Chrono(['wyrecord'])()
	def GetPlayableServiceDevices(self, nServiceID):
		ret = []
		self.lock.acquire()
		try:
			pass

	def AreServicesPlayable(self, nDeviceID1, nServiceID1, nDeviceID2, nServiceID2):
		log.info('call Record_AreServicesCompatible')
		self.lock.acquire()
		ret = False
		try:
			if self.wyscan.Record_AreServicesCompatible(nDeviceID1, nServiceID1, nDeviceID2, nServiceID2) == 0:
				ret = True

	def EPGFromProgramId(self, program_id):
		self.lock.acquire()
		ret = None
		try:
			ret = self.wyscan.EPGFromProgramId(program_id)
		except BaseException, e:
			log.debug(str(e))
		self.lock.release()
		return ret

	def startExternEIT(self, path, serviceid):
		self.lock.acquire()
		try:
			self.wyscan.startExternEIT(path, serviceid)
		except BaseException, e:
			log.debug(str(e))
		self.lock.release()

	def stopExternEIT(self):
		self.lock.acquire()
		try:
			self.wyscan.stopExternEIT(0)
		except BaseException, e:
			log.debug(str(e))
		self.lock.release()

	def StopDeviceRecordings(self, nDeviceID=0):
		self.lock.acquire()
		ret = False
		try:
			if self.wyscan.Record_StopDeviceRecordings(nDeviceID) == 0:
				ret = True

	def GetService(self, nServiceID):
		try:
			self.lock.acquire()
			result = self.wyscan.GetService(nServiceID, nFormat=2)
			self.lock.release()
		except BaseException, e:
			log.debug(str(e))
			self.lock.release()
			return None
		if result[0] != 0:
			return None
		if len(result[1]) == 0:
			return None
		return WyScan.Service(result[1][0], 2)

	def GetServiceByName(self, service_name):
		self.lock.acquire()
		try:
			result = self.wyscan.GetServicesByName(service_name)
		except BaseException, e:
			log.debug(str(e))
			self.lock.release()
			return None
		self.lock.release()
		if result[0] != 0:
			return None
		return Service(result[1][0], 0)

	def GetDevices(self, nDeviceID=-1, nDeviceType=-1):
		self.lock.acquire()
		try:
			result = self.wyscan.GetDevices(nDeviceID, nDeviceType)
		except BaseException, e:
			log.debug(str(e))
			self.lock.release()
			return []
		self.lock.release()
		return result



]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb775df2c>}
from logger import log
import time
import error
from peewee.analyse import Chrono
from peewee.analyse import timestep
from config import URL_PREFIX_UNIX_SOCKET
import WyScan
from WyScan import Service
from WyScan import Device
from threading import Lock
WYSCAN_RECORDING_ID_NULL = 0
class ExternalDVBManagerInterface(object):
	def __init__(self, wyscan):
		self.wyscan = wyscan

	def startService(self, service, device, uri, service_to_stop=WYSCAN_RECORDING_ID_NULL):
		return {'status': error.WYRECORD_UNKNOWN_ERROR}

	def stopService(self, wyscan_recording_id):
		return error.WYRECORD_SUCCESS

	GetCurrentUTCTime = Chrono(['wyrecord'])()
	GetDeviceCurrentUTCTime = Chrono(['wyrecord'])()
	def GetPlayableServiceDevices(self, nServiceID):
		return ret

	def AreServicesPlayable(self, nDeviceID1, nServiceID1, nDeviceID2, nServiceID2):
		log.info('call Record_AreServicesCompatible')
		ret = False
		return ret

	def EPGFromProgramId(self, program_id):
		ret = None
		return ret

	def startExternEIT(self, path, serviceid):
		pass

	def stopExternEIT(self):
		pass

	def StopDeviceRecordings(self, nDeviceID=0):
		ret = False
		return ret

	def GetService(self, nServiceID):
		return None

	def GetServiceByName(self, service_name):
		return None

	def GetDevices(self, nDeviceID=-1, nDeviceType=-1):
		return []



class ExternalDVBManager(ExternalDVBManagerInterface):
	def __init__(self, wyscan):
		self.wyscan = wyscan
		self.lock = Lock()

	def startService(self, service, device, uri, service_to_stop=WYSCAN_RECORDING_ID_NULL):
		if not uri.startswith(URL_PREFIX_UNIX_SOCKET):
			return {'status': error.WYRECORD_UNKNOWN_ERROR}
		unix_socket_path = uri[len(URL_PREFIX_UNIX_SOCKET):]
		parameters = "unix_socket_path='%s'" % unix_socket_path
		self.lock.acquire()
		try:
			timestep('dvb_start_service_init')
			if not service_to_stop:
				result = self.wyscan.Record_StartRecordingEx(device, service, 'NormalLive', parameters, 2)
				timestep('wyscan.Record_StartRecordingEx')
			else:
				result = self.wyscan.Record_ZapEx(service_to_stop, device, service, 'NormalLive', parameters, 2)
				timestep('wyscan.Record_ZapEx')

	def stopService(self, wyscan_recording_id):
		timestep('dvb_stop_service_init')
		self.lock.acquire()
		try:
			result = self.wyscan.Record_StopRecording(wyscan_recording_id)
		except BaseException, e:
			self.lock.release()
			log.debug(str(e))
			return error.WYRECORD_UNKNOWN_ERROR
		self.lock.release()
		timestep('dvb_stop_service_wyscan_time')
		if result != 0:
			log.error('Can not stop recording %d' % wyscan_recording_id)
			return error.WYRECORD_BAD_RECORDING_ID
		return error.WYRECORD_SUCCESS

	GetCurrentUTCTime = Chrono(['wyrecord'])()
	GetDeviceCurrentUTCTime = Chrono(['wyrecord'])()
	def GetPlayableServiceDevices(self, nServiceID):
		ret = []
		self.lock.acquire()
		try:
			pass

	def AreServicesPlayable(self, nDeviceID1, nServiceID1, nDeviceID2, nServiceID2):
		log.info('call Record_AreServicesCompatible')
		self.lock.acquire()
		ret = False
		try:
			if self.wyscan.Record_AreServicesCompatible(nDeviceID1, nServiceID1, nDeviceID2, nServiceID2) == 0:
				ret = True

	def EPGFromProgramId(self, program_id):
		self.lock.acquire()
		ret = None
		try:
			ret = self.wyscan.EPGFromProgramId(program_id)
		except BaseException, e:
			log.debug(str(e))
		self.lock.release()
		return ret

	def startExternEIT(self, path, serviceid):
		self.lock.acquire()
		try:
			self.wyscan.startExternEIT(path, serviceid)
		except BaseException, e:
			log.debug(str(e))
		self.lock.release()

	def stopExternEIT(self):
		self.lock.acquire()
		try:
			self.wyscan.stopExternEIT(0)
		except BaseException, e:
			log.debug(str(e))
		self.lock.release()

	def StopDeviceRecordings(self, nDeviceID=0):
		self.lock.acquire()
		ret = False
		try:
			if self.wyscan.Record_StopDeviceRecordings(nDeviceID) == 0:
				ret = True

	def GetService(self, nServiceID):
		try:
			self.lock.acquire()
			result = self.wyscan.GetService(nServiceID, nFormat=2)
			self.lock.release()
		except BaseException, e:
			log.debug(str(e))
			self.lock.release()
			return None
		if result[0] != 0:
			return None
		if len(result[1]) == 0:
			return None
		return WyScan.Service(result[1][0], 2)

	def GetServiceByName(self, service_name):
		self.lock.acquire()
		try:
			result = self.wyscan.GetServicesByName(service_name)
		except BaseException, e:
			log.debug(str(e))
			self.lock.release()
			return None
		self.lock.release()
		if result[0] != 0:
			return None
		return Service(result[1][0], 0)

	def GetDevices(self, nDeviceID=-1, nDeviceType=-1):
		self.lock.acquire()
		try:
			result = self.wyscan.GetDevices(nDeviceID, nDeviceType)
		except BaseException, e:
			log.debug(str(e))
			self.lock.release()
			return []
		self.lock.release()
		return result



