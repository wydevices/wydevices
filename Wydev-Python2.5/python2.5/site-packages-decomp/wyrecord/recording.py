# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 0
n 0(None)[self.live_manager = live_manager
self.external_dvb_manager = external_dvb_manager
self.renderer_manager = renderer_manager
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76f88ac>}
nname: 0
n 0(None)[return Recording(self.renderer_manager, self.live_manager, self.external_dvb_manager, strName, oService, possible_deviceids, nStartTime, nStopTime, nStartPadding, nStopPadding, nMaxStartDelay, nType, nAskRecordlauncherToStop)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76f8d2c>}
nname: 6
n 6(None)[__doc__ = '\n    live_manager and recording_launcher are needed to build a recording\n    RecordingBuilder should be use to make instance of Recording where \n    there shoud be no dependency of live_manager or  recording_launcher\n    '
def __init__(self, live_manager, external_dvb_manager, renderer_manager):
	self.live_manager = live_manager
	self.external_dvb_manager = external_dvb_manager
	self.renderer_manager = renderer_manager

def buildNewRecording(self, strName='', oService=None, possible_deviceids=None, nStartTime=0, nStopTime=0, nStartPadding=0, nStopPadding=0, nMaxStartDelay=0, nType=RECORDING_TYPE_NORMAL, nAskRecordlauncherToStop=True):
	return Recording(self.renderer_manager, self.live_manager, self.external_dvb_manager, strName, oService, possible_deviceids, nStartTime, nStopTime, nStartPadding, nStopPadding, nMaxStartDelay, nType, nAskRecordlauncherToStop)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb76f836c>}
nname: 38
n 38(None)[self.service_id = service_id
self.start_time = nStartTime
self.stop_time = nStopTime
self.start_padding = start_padding
self.stop_padding = stop_padding
self.id = id
self.live = live
self.type = RECORDING_TYPE_IS_LIVE
]:
	i: 15(), 28()
	o: 

nname: 28
n 28(None)[self.possible_deviceids = possible_deviceids
]:
	i: 0(t)
	o: 38()

nname: 15
n 15(None)[self.possible_deviceids = []
]:
	i: 0(f)
	o: 38()

nname: 0
n 0(possible_deviceids)[self.deviceid = 0
]:
	i: 
	o: 15(f), 28(t)

nname: 0
n 0(None)[self.deviceid = 0
if not possible_deviceids:
	self.possible_deviceids = []
else:
	self.possible_deviceids = possible_deviceids
self.service_id = service_id
self.start_time = nStartTime
self.stop_time = nStopTime
self.start_padding = start_padding
self.stop_padding = stop_padding
self.id = id
self.live = live
self.type = RECORDING_TYPE_IS_LIVE
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76f8d0c>}
nname: 6
n 6(None)[__doc__ = ' this class contains all the conflict manager should know about a Recording.\n    '
def __init__(self, deviceid=0, possible_deviceids=None, service_id=0, nStartTime=0, nStopTime=0, start_padding=0, stop_padding=0, id=RECORDING_ID_NULL, live=None):
	self.deviceid = 0
	if not possible_deviceids:
		self.possible_deviceids = []
	else:
		self.possible_deviceids = possible_deviceids
	self.service_id = service_id
	self.start_time = nStartTime
	self.stop_time = nStopTime
	self.start_padding = start_padding
	self.stop_padding = stop_padding
	self.id = id
	self.live = live
	self.type = RECORDING_TYPE_IS_LIVE

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb7700f8c>}
nname: 259
n 259(None)[self.record_info = RecordInfo()
self.urls = []
self.instant_recording = config.recording_use_live
self.live_id = 0
self.first_chunk = ''
self.last_chunk = ''
self.live_uri = ''
self.program_id = ''
self.favorite = ''
return None
]:
	i: 230(), 258()
	o: 

nname: 258
n 258(None)[]:
	i: 146(f)
	o: 259()

nname: 230
n 230(None)[self.service_id = oService.id
self.service_name = oService.name
]:
	i: 146(t)
	o: 259()

nname: 146
n 146(oService != None)[self.deviceid = 0
self.launcher_recordingid = 0
self.max_start_delay = nMaxStartDelay
self.internal_recordingid = 0
self.real_start_time = 0
self.real_stop_time = 0
self.service_id = 0
self.service_name = ''
]:
	i: 123(), 136()
	o: 230(t), 258(f)

nname: 136
n 136(None)[self.possible_deviceids = possible_deviceids
]:
	i: 0(t)
	o: 146()

nname: 123
n 123(None)[self.possible_deviceids = []
]:
	i: 0(f)
	o: 146()

nname: 0
n 0(possible_deviceids)[self.renderer_manager = renderer_manager
self.external_dvb_manager = external_dvb_manager
self.live_manager = live_manager
self.id = RECORDING_ID_NULL
self.periodicity_rule_id = PERIODICITY_RULE_ID_NULL
self.status = RECORDING_STATUS_UNKNOWN
self.type = nType
self.name = strName
self.start_time = nStartTime
self.stop_time = nStopTime
self.start_padding = nStartPadding
self.stop_padding = nStopPadding
self.service_id = 0
]:
	i: 
	o: 123(f), 136(t)

nname: 259
n 259(None)[self.record_info = RecordInfo()
self.urls = []
self.instant_recording = config.recording_use_live
self.live_id = 0
self.first_chunk = ''
self.last_chunk = ''
self.live_uri = ''
self.program_id = ''
self.favorite = ''
return None
]:
	i: 0()
	o: 

nname: 0
n 0(None)[self.renderer_manager = renderer_manager
self.external_dvb_manager = external_dvb_manager
self.live_manager = live_manager
self.id = RECORDING_ID_NULL
self.periodicity_rule_id = PERIODICITY_RULE_ID_NULL
self.status = RECORDING_STATUS_UNKNOWN
self.type = nType
self.name = strName
self.start_time = nStartTime
self.stop_time = nStopTime
self.start_padding = nStartPadding
self.stop_padding = nStopPadding
self.service_id = 0
if not possible_deviceids:
	self.possible_deviceids = []
else:
	self.possible_deviceids = possible_deviceids
self.deviceid = 0
self.launcher_recordingid = 0
self.max_start_delay = nMaxStartDelay
self.internal_recordingid = 0
self.real_start_time = 0
self.real_stop_time = 0
self.service_id = 0
self.service_name = ''
if oService != None:
	self.service_id = oService.id
	self.service_name = oService.name
]:
	i: 
	o: 259()

nname: 0
n 0(None)[self.renderer_manager = renderer_manager
self.external_dvb_manager = external_dvb_manager
self.live_manager = live_manager
self.id = RECORDING_ID_NULL
self.periodicity_rule_id = PERIODICITY_RULE_ID_NULL
self.status = RECORDING_STATUS_UNKNOWN
self.type = nType
self.name = strName
self.start_time = nStartTime
self.stop_time = nStopTime
self.start_padding = nStartPadding
self.stop_padding = nStopPadding
self.service_id = 0
if not possible_deviceids:
	self.possible_deviceids = []
else:
	self.possible_deviceids = possible_deviceids
self.deviceid = 0
self.launcher_recordingid = 0
self.max_start_delay = nMaxStartDelay
self.internal_recordingid = 0
self.real_start_time = 0
self.real_stop_time = 0
self.service_id = 0
self.service_name = ''
if oService != None:
	self.service_id = oService.id
	self.service_name = oService.name
self.record_info = RecordInfo()
self.urls = []
self.instant_recording = config.recording_use_live
self.live_id = 0
self.first_chunk = ''
self.last_chunk = ''
self.live_uri = ''
self.program_id = ''
self.favorite = ''
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7706cec>}
nname: 33
n 33(None)[return ret
]:
	i: 15(), 32()
	o: 

nname: 32
n 32(None)[]:
	i: 0(f)
	o: 33()

nname: 15
n 15(None)[ret -= self.start_padding
]:
	i: 0(t)
	o: 33()

nname: 0
n 0(ret)[ret = self.start_time
]:
	i: 
	o: 15(t), 32(f)

nname: 0
n 0(None)[ret = self.start_time
if ret:
	ret -= self.start_padding
return ret
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7705cec>}
nname: 33
n 33(None)[return ret
]:
	i: 15(), 32()
	o: 

nname: 32
n 32(None)[]:
	i: 0(f)
	o: 33()

nname: 15
n 15(None)[ret += self.stop_padding
]:
	i: 0(t)
	o: 33()

nname: 0
n 0(ret)[ret = self.stop_time
]:
	i: 
	o: 15(t), 32(f)

nname: 0
n 0(None)[ret = self.stop_time
if ret:
	ret += self.stop_padding
return ret
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7705dac>}
nname: 346
n 346(None)[return True
]:
	i: 228(AL), 345()
	o: 

nname: 345
n 345(None)[]:
	i: 295(AF), 305()
	o: 346()

nname: 305
n 305(None)[for deviceid in self.possible_deviceids:
node_possible_devices.append(ET.Element('device', id=str(deviceid)))
]:
	i: 295(for)
	o: 345()

nname: 295
n 295(None)[]:
	i: 228(loop)
	o: 305(for), 345(AF)

nname: 228
n 228(None)[oXMLNode.append(ET.Element('service', id=str(self.service_id), name=self.service_name))
node_possible_devices = ET.SubElement(oXMLNode, 'possible_devices')
]:
	i: 189(), 227()
	o: 295(loop), 346(AL)

nname: 227
n 227(None)[]:
	i: 171(f)
	o: 228()

nname: 189
n 189(None)[oXMLNode.append(ET.Element('file_info', file=self.record_info.info_file_path_name))
]:
	i: 171(t)
	o: 228()

nname: 171
n 171(self.record_info.info_file_path_name != '')[]:
	i: 86(AL), 170()
	o: 189(t), 227(f)

nname: 170
n 170(None)[]:
	i: 117(AF), 127()
	o: 171()

nname: 127
n 127(None)[for url in self.urls:
node_url = ET.Element('url')
node_url.text = url
node_urls.append(node_url)
]:
	i: 117(for)
	o: 170()

nname: 117
n 117(None)[]:
	i: 86(loop)
	o: 127(for), 170(AF)

nname: 86
n 86(None)[node_urls = ET.Element('urls')
oXMLNode.append(node_urls)
]:
	i: 21(AL), 85()
	o: 117(loop), 171(AL)

nname: 85
n 85(None)[]:
	i: 24(AF), 81()
	o: 86()

nname: 81
n 81(None)[]:
	i: 31(f), 49()
	o: 85()

nname: 49
n 49(None)[oXMLNode.attrib[attribute] = str(getattr(self, attribute))
continue
]:
	i: 31(t)
	o: 81()

nname: 31
n 31(hasattr(self, attribute))[for attribute in ('id', 'program_id', 'favorite', 'periodicity_rule_id', 'status', 'type', 'start_time', 'stop_time', 'start_padding', 'stop_padding', 'name', 'stop_time', 'deviceid', 'launcher_recordingid', 'max_start_delay', 'real_start_time', 'real_stop_time', 'url', 'live_uri'):
]:
	i: 24(for)
	o: 49(t), 81(f)

nname: 24
n 24(None)[]:
	i: 21(loop)
	o: 31(for), 85(AF)

nname: 21
n 21(None)[]:
	i: 12(), 20()
	o: 24(loop), 86(AL)

nname: 20
n 20(None)[]:
	i: 0(f)
	o: 21()

nname: 12
n 12(None)[return False
]:
	i: 0(t)
	o: 21()

nname: 0
n 0(oXMLNode == None)[]:
	i: 
	o: 12(t), 20(f)

nname: 345
n 345(None)[return True
]:
	i: 295()
	o: 

nname: 295
n 295(None)[for deviceid in self.possible_deviceids:
	node_possible_devices.append(ET.Element('device', id=str(deviceid)))
]:
	i: 171(loop)
	o: 345()

nname: 171
n 171(None)[if self.record_info.info_file_path_name != '':
	oXMLNode.append(ET.Element('file_info', file=self.record_info.info_file_path_name))
oXMLNode.append(ET.Element('service', id=str(self.service_id), name=self.service_name))
node_possible_devices = ET.SubElement(oXMLNode, 'possible_devices')
]:
	i: 127()
	o: 295(loop)

nname: 127
n 127(None)[for url in self.urls:
	node_url = ET.Element('url')
	node_url.text = url
	node_urls.append(node_url)
]:
	i: 86(for)
	o: 171()

nname: 86
n 86(None)[node_urls = ET.Element('urls')
oXMLNode.append(node_urls)
]:
	i: 0(AL), 24(AF), 31()
	o: 127(for)

nname: 31
n 31(None)[for attribute in ('id', 'program_id', 'favorite', 'periodicity_rule_id', 'status', 'type', 'start_time', 'stop_time', 'start_padding', 'stop_padding', 'name', 'stop_time', 'deviceid', 'launcher_recordingid', 'max_start_delay', 'real_start_time', 'real_stop_time', 'url', 'live_uri'):
if hasattr(self, attribute):
	oXMLNode.attrib[attribute] = str(getattr(self, attribute))
	continue
]:
	i: 24(for)
	o: 86()

nname: 24
n 24(None)[]:
	i: 0(loop)
	o: 31(for), 86(AF)

nname: 0
n 0(None)[if oXMLNode == None:
	return False
]:
	i: 
	o: 24(loop), 86(AL)

nname: 345
n 345(None)[return True
]:
	i: 171()
	o: 

nname: 171
n 171(None)[if self.record_info.info_file_path_name != '':
	oXMLNode.append(ET.Element('file_info', file=self.record_info.info_file_path_name))
oXMLNode.append(ET.Element('service', id=str(self.service_id), name=self.service_name))
node_possible_devices = ET.SubElement(oXMLNode, 'possible_devices')
for deviceid in self.possible_deviceids:
	node_possible_devices.append(ET.Element('device', id=str(deviceid)))
]:
	i: 86()
	o: 345()

nname: 86
n 86(None)[node_urls = ET.Element('urls')
oXMLNode.append(node_urls)
for url in self.urls:
	node_url = ET.Element('url')
	node_url.text = url
	node_urls.append(node_url)
]:
	i: 0(AL), 24(AF), 31()
	o: 171()

nname: 31
n 31(None)[for attribute in ('id', 'program_id', 'favorite', 'periodicity_rule_id', 'status', 'type', 'start_time', 'stop_time', 'start_padding', 'stop_padding', 'name', 'stop_time', 'deviceid', 'launcher_recordingid', 'max_start_delay', 'real_start_time', 'real_stop_time', 'url', 'live_uri'):
if hasattr(self, attribute):
	oXMLNode.attrib[attribute] = str(getattr(self, attribute))
	continue
]:
	i: 24(for)
	o: 86()

nname: 24
n 24(None)[]:
	i: 0(loop)
	o: 31(for), 86(AF)

nname: 0
n 0(None)[if oXMLNode == None:
	return False
]:
	i: 
	o: 24(loop), 86(AL)

nname: 345
n 345(None)[return True
]:
	i: 86()
	o: 

nname: 86
n 86(None)[node_urls = ET.Element('urls')
oXMLNode.append(node_urls)
for url in self.urls:
	node_url = ET.Element('url')
	node_url.text = url
	node_urls.append(node_url)
if self.record_info.info_file_path_name != '':
	oXMLNode.append(ET.Element('file_info', file=self.record_info.info_file_path_name))
oXMLNode.append(ET.Element('service', id=str(self.service_id), name=self.service_name))
node_possible_devices = ET.SubElement(oXMLNode, 'possible_devices')
for deviceid in self.possible_deviceids:
	node_possible_devices.append(ET.Element('device', id=str(deviceid)))
]:
	i: 0(AL), 24(AF), 31()
	o: 345()

nname: 31
n 31(None)[for attribute in ('id', 'program_id', 'favorite', 'periodicity_rule_id', 'status', 'type', 'start_time', 'stop_time', 'start_padding', 'stop_padding', 'name', 'stop_time', 'deviceid', 'launcher_recordingid', 'max_start_delay', 'real_start_time', 'real_stop_time', 'url', 'live_uri'):
if hasattr(self, attribute):
	oXMLNode.attrib[attribute] = str(getattr(self, attribute))
	continue
]:
	i: 24(for)
	o: 86()

nname: 24
n 24(None)[]:
	i: 0(loop)
	o: 31(for), 86(AF)

nname: 0
n 0(None)[if oXMLNode == None:
	return False
]:
	i: 
	o: 24(loop), 86(AL)

nname: 86
n 86(None)[node_urls = ET.Element('urls')
oXMLNode.append(node_urls)
for url in self.urls:
	node_url = ET.Element('url')
	node_url.text = url
	node_urls.append(node_url)
if self.record_info.info_file_path_name != '':
	oXMLNode.append(ET.Element('file_info', file=self.record_info.info_file_path_name))
oXMLNode.append(ET.Element('service', id=str(self.service_id), name=self.service_name))
node_possible_devices = ET.SubElement(oXMLNode, 'possible_devices')
for deviceid in self.possible_deviceids:
	node_possible_devices.append(ET.Element('device', id=str(deviceid)))
return True
]:
	i: 0(AL), 24(AF), 31()
	o: 

nname: 31
n 31(None)[for attribute in ('id', 'program_id', 'favorite', 'periodicity_rule_id', 'status', 'type', 'start_time', 'stop_time', 'start_padding', 'stop_padding', 'name', 'stop_time', 'deviceid', 'launcher_recordingid', 'max_start_delay', 'real_start_time', 'real_stop_time', 'url', 'live_uri'):
if hasattr(self, attribute):
	oXMLNode.attrib[attribute] = str(getattr(self, attribute))
	continue
]:
	i: 24(for)
	o: 86()

nname: 24
n 24(None)[]:
	i: 0(loop)
	o: 31(for), 86(AF)

nname: 0
n 0(None)[if oXMLNode == None:
	return False
]:
	i: 
	o: 24(loop), 86(AL)

self.nodes: {0: <unpyclib.structure.node instance at 0xb770f98c>, 86: <unpyclib.structure.node instance at 0xb770f1ac>, 24: <unpyclib.structure.node instance at 0xb7706cac>, 31: <unpyclib.structure.node instance at 0xb770f72c>}
nname: 526
n 526(None)[return True
]:
	i: 483(), 525()
	o: 

nname: 525
n 525(None)[]:
	i: 432(f)
	o: 526()

nname: 483
n 483(None)[self.service_id = int(node_service.attrib['id'])
self.service_name = node_service.attrib['name']
]:
	i: 432(t)
	o: 526()

nname: 432
n 432(node_service != None)[service = None
self.service_id = 0
self.service_name = ''
node_service = oXMLNode.find('service')
]:
	i: 366(AL), 427(), 431()
	o: 483(t), 525(f)

nname: 431
n 431(None)[]:
	i: 330(f)
	o: 432()

nname: 427
n 427(None)[]:
	i: 385(AF), 392()
	o: 432()

nname: 392
n 392(None)[for node_device in nodes_devices:
self.possible_deviceids.append(int(node_device.attrib['id']))
]:
	i: 385(for)
	o: 427()

nname: 385
n 385(None)[]:
	i: 366(loop)
	o: 392(for), 427(AF)

nname: 366
n 366(None)[nodes_devices = node_possible_devices.getiterator('device')
]:
	i: 330(t)
	o: 385(loop), 432(AL)

nname: 330
n 330(node_possible_devices != None)[self.possible_deviceids = []
node_possible_devices = oXMLNode.find('possible_devices')
]:
	i: 284(), 329()
	o: 366(t), 431(f)

nname: 329
n 329(None)[]:
	i: 245(f)
	o: 330()

nname: 284
n 284(None)[self.record_info.info_file_path_name = node_file_info.attrib['file']
self.record_info.LoadFromFile(self.record_info.info_file_path_name)
]:
	i: 245(t)
	o: 330()

nname: 245
n 245(node_file_info != None)[self.record_info.info_file_path_name = ''
node_file_info = oXMLNode.find('file_info')
]:
	i: 189(AL), 240(), 244()
	o: 284(t), 329(f)

nname: 244
n 244(None)[]:
	i: 153(f)
	o: 245()

nname: 240
n 240(None)[]:
	i: 208(AF), 215()
	o: 245()

nname: 215
n 215(None)[for node_url in nodes_url:
self.urls.append(node_url.text)
]:
	i: 208(for)
	o: 240()

nname: 208
n 208(None)[]:
	i: 189(loop)
	o: 215(for), 240(AF)

nname: 189
n 189(None)[nodes_url = node_urls.getiterator('url')
]:
	i: 153(t)
	o: 208(loop), 245(AL)

nname: 153
n 153(node_urls != None)[self.urls = []
node_urls = oXMLNode.find('urls')
]:
	i: 87(AL), 152()
	o: 189(t), 244(f)

nname: 152
n 152(None)[]:
	i: 90(AF), 148()
	o: 153()

nname: 148
n 148(None)[]:
	i: 97(f), 115()
	o: 152()

nname: 115
n 115(None)[setattr(self, attribute, str(oXMLNode.attrib[attribute]))
continue
]:
	i: 97(t)
	o: 148()

nname: 97
n 97(hasattr(self, attribute))[for attribute in ('name', 'favorite', 'program_id', 'url', 'live_uri'):
]:
	i: 90(for)
	o: 115(t), 148(f)

nname: 90
n 90(None)[]:
	i: 87(loop)
	o: 97(for), 152(AF)

nname: 87
n 87(None)[]:
	i: 21(AL), 86()
	o: 90(loop), 153(AL)

nname: 86
n 86(None)[]:
	i: 24(AF), 82()
	o: 87()

nname: 82
n 82(None)[]:
	i: 31(f), 49()
	o: 86()

nname: 49
n 49(None)[setattr(self, attribute, int(oXMLNode.attrib[attribute]))
continue
]:
	i: 31(t)
	o: 82()

nname: 31
n 31(hasattr(self, attribute))[for attribute in ('id', 'periodicity_rule_id', 'status', 'type', 'start_time', 'stop_time', 'start_padding', 'stop_padding', 'stop_time', 'deviceid', 'launcher_recordingid', 'max_start_delay', 'real_start_time', 'real_stop_time'):
]:
	i: 24(for)
	o: 49(t), 82(f)

nname: 24
n 24(None)[]:
	i: 21(loop)
	o: 31(for), 86(AF)

nname: 21
n 21(None)[]:
	i: 12(), 20()
	o: 24(loop), 87(AL)

nname: 20
n 20(None)[]:
	i: 0(f)
	o: 21()

nname: 12
n 12(None)[return False
]:
	i: 0(t)
	o: 21()

nname: 0
n 0(oXMLNode == None)[]:
	i: 
	o: 12(t), 20(f)

nname: 432
n 432(None)[service = None
self.service_id = 0
self.service_name = ''
node_service = oXMLNode.find('service')
if node_service != None:
	self.service_id = int(node_service.attrib['id'])
	self.service_name = node_service.attrib['name']
return True
]:
	i: 392(), 245(f)
	o: 

nname: 392
n 392(None)[for node_device in nodes_devices:
	self.possible_deviceids.append(int(node_device.attrib['id']))
]:
	i: 366(for)
	o: 432()

nname: 366
n 366(None)[nodes_devices = node_possible_devices.getiterator('device')
]:
	i: 245(t)
	o: 392(for)

nname: 245
n 245(node_possible_devices != None)[self.record_info.info_file_path_name = ''
node_file_info = oXMLNode.find('file_info')
if node_file_info != None:
	self.record_info.info_file_path_name = node_file_info.attrib['file']
	self.record_info.LoadFromFile(self.record_info.info_file_path_name)
self.possible_deviceids = []
node_possible_devices = oXMLNode.find('possible_devices')
]:
	i: 215(), 153(f)
	o: 366(t), 432(f)

nname: 215
n 215(None)[for node_url in nodes_url:
	self.urls.append(node_url.text)
]:
	i: 189(for)
	o: 245()

nname: 189
n 189(None)[nodes_url = node_urls.getiterator('url')
]:
	i: 153(t)
	o: 215(for)

nname: 153
n 153(node_urls != None)[self.urls = []
node_urls = oXMLNode.find('urls')
]:
	i: 87(AL), 90(AF), 97()
	o: 189(t), 245(f)

nname: 97
n 97(None)[for attribute in ('name', 'favorite', 'program_id', 'url', 'live_uri'):
if hasattr(self, attribute):
	setattr(self, attribute, str(oXMLNode.attrib[attribute]))
	continue
]:
	i: 90(for)
	o: 153()

nname: 90
n 90(None)[]:
	i: 87(loop)
	o: 97(for), 153(AF)

nname: 87
n 87(None)[]:
	i: 0(AL), 24(AF), 31()
	o: 90(loop), 153(AL)

nname: 31
n 31(None)[for attribute in ('id', 'periodicity_rule_id', 'status', 'type', 'start_time', 'stop_time', 'start_padding', 'stop_padding', 'stop_time', 'deviceid', 'launcher_recordingid', 'max_start_delay', 'real_start_time', 'real_stop_time'):
if hasattr(self, attribute):
	setattr(self, attribute, int(oXMLNode.attrib[attribute]))
	continue
]:
	i: 24(for)
	o: 87()

nname: 24
n 24(None)[]:
	i: 0(loop)
	o: 31(for), 87(AF)

nname: 0
n 0(None)[if oXMLNode == None:
	return False
]:
	i: 
	o: 24(loop), 87(AL)

nname: 432
n 432(None)[service = None
self.service_id = 0
self.service_name = ''
node_service = oXMLNode.find('service')
if node_service != None:
	self.service_id = int(node_service.attrib['id'])
	self.service_name = node_service.attrib['name']
return True
]:
	i: 366(), 245(f)
	o: 

nname: 366
n 366(None)[nodes_devices = node_possible_devices.getiterator('device')
for node_device in nodes_devices:
	self.possible_deviceids.append(int(node_device.attrib['id']))
]:
	i: 245(t)
	o: 432()

nname: 245
n 245(node_possible_devices != None)[self.record_info.info_file_path_name = ''
node_file_info = oXMLNode.find('file_info')
if node_file_info != None:
	self.record_info.info_file_path_name = node_file_info.attrib['file']
	self.record_info.LoadFromFile(self.record_info.info_file_path_name)
self.possible_deviceids = []
node_possible_devices = oXMLNode.find('possible_devices')
]:
	i: 189(), 97(f)
	o: 366(t), 432(f)

nname: 189
n 189(None)[nodes_url = node_urls.getiterator('url')
for node_url in nodes_url:
	self.urls.append(node_url.text)
]:
	i: 97(t)
	o: 245()

nname: 97
n 97(node_urls != None)[for attribute in ('name', 'favorite', 'program_id', 'url', 'live_uri'):
	if hasattr(self, attribute):
		setattr(self, attribute, str(oXMLNode.attrib[attribute]))
		continue
self.urls = []
node_urls = oXMLNode.find('urls')
]:
	i: 87(for)
	o: 189(t), 245(f)

nname: 87
n 87(None)[]:
	i: 0(AL), 24(AF), 31()
	o: 97(for)

nname: 31
n 31(None)[for attribute in ('id', 'periodicity_rule_id', 'status', 'type', 'start_time', 'stop_time', 'start_padding', 'stop_padding', 'stop_time', 'deviceid', 'launcher_recordingid', 'max_start_delay', 'real_start_time', 'real_stop_time'):
if hasattr(self, attribute):
	setattr(self, attribute, int(oXMLNode.attrib[attribute]))
	continue
]:
	i: 24(for)
	o: 87()

nname: 24
n 24(None)[]:
	i: 0(loop)
	o: 31(for), 87(AF)

nname: 0
n 0(None)[if oXMLNode == None:
	return False
]:
	i: 
	o: 24(loop), 87(AL)

nname: 245
n 245(None)[self.record_info.info_file_path_name = ''
node_file_info = oXMLNode.find('file_info')
if node_file_info != None:
	self.record_info.info_file_path_name = node_file_info.attrib['file']
	self.record_info.LoadFromFile(self.record_info.info_file_path_name)
self.possible_deviceids = []
node_possible_devices = oXMLNode.find('possible_devices')
if node_possible_devices != None:
	nodes_devices = node_possible_devices.getiterator('device')
	for node_device in nodes_devices:
		self.possible_deviceids.append(int(node_device.attrib['id']))
service = None
self.service_id = 0
self.service_name = ''
node_service = oXMLNode.find('service')
if node_service != None:
	self.service_id = int(node_service.attrib['id'])
	self.service_name = node_service.attrib['name']
return True
]:
	i: 87(f)
	o: 

nname: 87
n 87(None)[for attribute in ('name', 'favorite', 'program_id', 'url', 'live_uri'):
	if hasattr(self, attribute):
		setattr(self, attribute, str(oXMLNode.attrib[attribute]))
		continue
self.urls = []
node_urls = oXMLNode.find('urls')
if node_urls != None:
	nodes_url = node_urls.getiterator('url')
	for node_url in nodes_url:
		self.urls.append(node_url.text)
]:
	i: 0(AL), 24(AF), 31()
	o: 245()

nname: 31
n 31(None)[for attribute in ('id', 'periodicity_rule_id', 'status', 'type', 'start_time', 'stop_time', 'start_padding', 'stop_padding', 'stop_time', 'deviceid', 'launcher_recordingid', 'max_start_delay', 'real_start_time', 'real_stop_time'):
if hasattr(self, attribute):
	setattr(self, attribute, int(oXMLNode.attrib[attribute]))
	continue
]:
	i: 24(for)
	o: 87()

nname: 24
n 24(None)[]:
	i: 0(loop)
	o: 31(for), 87(AF)

nname: 0
n 0(None)[if oXMLNode == None:
	return False
]:
	i: 
	o: 24(loop), 87(AL)

nname: 87
n 87(None)[for attribute in ('name', 'favorite', 'program_id', 'url', 'live_uri'):
	if hasattr(self, attribute):
		setattr(self, attribute, str(oXMLNode.attrib[attribute]))
		continue
self.urls = []
node_urls = oXMLNode.find('urls')
if node_urls != None:
	nodes_url = node_urls.getiterator('url')
	for node_url in nodes_url:
		self.urls.append(node_url.text)
self.record_info.info_file_path_name = ''
node_file_info = oXMLNode.find('file_info')
if node_file_info != None:
	self.record_info.info_file_path_name = node_file_info.attrib['file']
	self.record_info.LoadFromFile(self.record_info.info_file_path_name)
self.possible_deviceids = []
node_possible_devices = oXMLNode.find('possible_devices')
if node_possible_devices != None:
	nodes_devices = node_possible_devices.getiterator('device')
	for node_device in nodes_devices:
		self.possible_deviceids.append(int(node_device.attrib['id']))
service = None
self.service_id = 0
self.service_name = ''
node_service = oXMLNode.find('service')
if node_service != None:
	self.service_id = int(node_service.attrib['id'])
	self.service_name = node_service.attrib['name']
return True
]:
	i: 0(AL), 24(AF), 31()
	o: 

nname: 31
n 31(None)[for attribute in ('id', 'periodicity_rule_id', 'status', 'type', 'start_time', 'stop_time', 'start_padding', 'stop_padding', 'stop_time', 'deviceid', 'launcher_recordingid', 'max_start_delay', 'real_start_time', 'real_stop_time'):
if hasattr(self, attribute):
	setattr(self, attribute, int(oXMLNode.attrib[attribute]))
	continue
]:
	i: 24(for)
	o: 87()

nname: 24
n 24(None)[]:
	i: 0(loop)
	o: 31(for), 87(AF)

nname: 0
n 0(None)[if oXMLNode == None:
	return False
]:
	i: 
	o: 24(loop), 87(AL)

self.nodes: {0: <unpyclib.structure.node instance at 0xb770664c>, 87: <unpyclib.structure.node instance at 0xb7706dec>, 24: <unpyclib.structure.node instance at 0xb771268c>, 31: <unpyclib.structure.node instance at 0xb7706cec>}
nname: 214
n 214(None)[return 'Recording : id = %d, status = %s, name = %s, type = %d, start_time = %d, stop_time = %d, start_padding = %d, stop_padding = %d, service = %s (%s), device = %d, possible_devices = %s, real_start_time = %d, real_stop_time = %d' % (self.id, status, self.name, self.type, self.start_time, self.stop_time, self.start_padding, self.stop_padding, self.service_id, self.service_name, self.deviceid, self.possible_deviceids, self.real_start_time, self.real_stop_time)
]:
	i: 21(), 47(), 73(), 99(), 125(), 151(), 177(), 203(), 213()
	o: 

nname: 213
n 213(None)[]:
	i: 187(f)
	o: 214()

nname: 203
n 203(None)[status = 'UNKNOWN'
]:
	i: 187(t)
	o: 214()

nname: 187
n 187(self.status == RECORDING_STATUS_UNKNOWN)[]:
	i: 161(f)
	o: 203(t), 213(f)

nname: 177
n 177(None)[status = 'ABORTED'
]:
	i: 161(t)
	o: 214()

nname: 161
n 161(self.status == RECORDING_STATUS_ABORTED)[]:
	i: 135(f)
	o: 177(t), 187(f)

nname: 151
n 151(None)[status = 'SCHEDULED'
]:
	i: 135(t)
	o: 214()

nname: 135
n 135(self.status == RECORDING_STATUS_SCHEDULED)[]:
	i: 109(f)
	o: 151(t), 161(f)

nname: 125
n 125(None)[status = 'RUNNING'
]:
	i: 109(t)
	o: 214()

nname: 109
n 109(self.status == RECORDING_STATUS_RUNNING)[]:
	i: 83(f)
	o: 125(t), 135(f)

nname: 99
n 99(None)[status = 'MISSED'
]:
	i: 83(t)
	o: 214()

nname: 83
n 83(self.status == RECORDING_STATUS_MISSED)[]:
	i: 57(f)
	o: 99(t), 109(f)

nname: 73
n 73(None)[status = 'IN_CONFLICT'
]:
	i: 57(t)
	o: 214()

nname: 57
n 57(self.status == RECORDING_STATUS_IN_CONFLICT)[]:
	i: 31(f)
	o: 73(t), 83(f)

nname: 47
n 47(None)[status = 'COMPLETED'
]:
	i: 31(t)
	o: 214()

nname: 31
n 31(self.status == RECORDING_STATUS_COMPLETED)[]:
	i: 0(f)
	o: 47(t), 57(f)

nname: 21
n 21(None)[status = 'CANCELED'
]:
	i: 0(t)
	o: 214()

nname: 0
n 0(self.status == RECORDING_STATUS_CANCELED)[status = 'Unknown'
]:
	i: 
	o: 21(t), 31(f)

nname: 0
n 0(None)[status = 'Unknown'
if self.status == RECORDING_STATUS_CANCELED:
	status = 'CANCELED'
else:
	if self.status == RECORDING_STATUS_COMPLETED:
		status = 'COMPLETED'
	else:
		if self.status == RECORDING_STATUS_IN_CONFLICT:
			status = 'IN_CONFLICT'
		else:
			if self.status == RECORDING_STATUS_MISSED:
				status = 'MISSED'
			else:
				if self.status == RECORDING_STATUS_RUNNING:
					status = 'RUNNING'
				else:
					if self.status == RECORDING_STATUS_SCHEDULED:
						status = 'SCHEDULED'
					else:
						if self.status == RECORDING_STATUS_ABORTED:
							status = 'ABORTED'
						else:
							if self.status == RECORDING_STATUS_UNKNOWN:
								status = 'UNKNOWN'
return 'Recording : id = %d, status = %s, name = %s, type = %d, start_time = %d, stop_time = %d, start_padding = %d, stop_padding = %d, service = %s (%s), device = %d, possible_devices = %s, real_start_time = %d, real_stop_time = %d' % (self.id, status, self.name, self.type, self.start_time, self.stop_time, self.start_padding, self.stop_padding, self.service_id, self.service_name, self.deviceid, self.possible_deviceids, self.real_start_time, self.real_stop_time)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7706cec>}
nname: 101
n 101(None)[strValidName = '_' + str(live_count)
strBaseName = RECORDING_NAME_PREFIX + strStartTime + '_' + str(self.deviceid) + '_' + str(self.service_id) + '_' + strValidServiceName + strValidName
return strBaseName.replace('/', '_')
]:
	i: 83(), 100()
	o: 

nname: 100
n 100(None)[]:
	i: 56(f)
	o: 101()

nname: 83
n 83(None)[strValidServiceName = strValidServiceName[0:20]
]:
	i: 56(t)
	o: 101()

nname: 56
n 56(len(strValidServiceName) > 20)[strValidServiceName = self.service_name
]:
	i: 21(), 55()
	o: 83(t), 100(f)

nname: 55
n 55(None)[]:
	i: 0(f)
	o: 56()

nname: 21
n 21(None)[strStartTime = datetime.datetime.fromtimestamp(self.real_start_time).strftime(RECORDING_DATE_STRING_FORMAT)
]:
	i: 0(t)
	o: 56()

nname: 0
n 0(self.real_start_time != 0)[strStartTime = ''
]:
	i: 
	o: 21(t), 55(f)

nname: 101
n 101(None)[strValidName = '_' + str(live_count)
strBaseName = RECORDING_NAME_PREFIX + strStartTime + '_' + str(self.deviceid) + '_' + str(self.service_id) + '_' + strValidServiceName + strValidName
return strBaseName.replace('/', '_')
]:
	i: 0()
	o: 

nname: 0
n 0(None)[strStartTime = ''
if self.real_start_time != 0:
	strStartTime = datetime.datetime.fromtimestamp(self.real_start_time).strftime(RECORDING_DATE_STRING_FORMAT)
strValidServiceName = self.service_name
if len(strValidServiceName) > 20:
	strValidServiceName = strValidServiceName[0:20]
]:
	i: 
	o: 101()

nname: 0
n 0(None)[strStartTime = ''
if self.real_start_time != 0:
	strStartTime = datetime.datetime.fromtimestamp(self.real_start_time).strftime(RECORDING_DATE_STRING_FORMAT)
strValidServiceName = self.service_name
if len(strValidServiceName) > 20:
	strValidServiceName = strValidServiceName[0:20]
strValidName = '_' + str(live_count)
strBaseName = RECORDING_NAME_PREFIX + strStartTime + '_' + str(self.deviceid) + '_' + str(self.service_id) + '_' + strValidServiceName + strValidName
return strBaseName.replace('/', '_')
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb77064ec>}
nname: 636
n 636(None)[return True
]:
	i: 615(), 635()
	o: 

nname: 635
n 635(None)[]:
	i: 599(f)
	o: 636()

nname: 615
n 615(None)[dbus_api.emitNewRecordInfo(self.record_info)
]:
	i: 599(t)
	o: 636()

nname: 599
n 599(dbus_api)[self._CreateRecordInfo()
]:
	i: 477(JA), 548(JA), 562(JA), 586(), 589()
	o: 615(t), 635(f)

nname: 589
n 589(None)[self.status = RECORDING_STATUS_CANCELED
]:
	i: 118(f)
	o: 599()

nname: 562
n 562(None)[log.critical('buildRecord Failed => probably already done')
return False
]:
	i: 481(except)
	o: 599(JA)

nname: 548
n 548(None)[self.buildRecord()
]:
	i: 481(try)
	o: 599(JA)

nname: 481
n 481(None)[log.debug('trying to stop a recording but live not running')
log.debug('continue anyway => trying to recover')
self.name = self.name + config.recover_string
self.live_id = 0
self.status = RECORDING_STATUS_ABORTED
]:
	i: 133(f)
	o: 548(try), 562(except)

nname: 477
n 477(None)[]:
	i: 448(t)
	o: 599(JA)

nname: 586
n 586(None)[]:
	i: 454(JA), 585(AE)
	o: 599()

nname: 454
n 454(None)[self.live_manager.StopLive(live.id)
]:
	i: 448(f)
	o: 586(JA)

nname: 448
n 448(renderer)[]:
	i: 348(), 440(), 447(AE)
	o: 454(f), 477(t)

nname: 440
n 440(None)[return False
]:
	i: 416(), 439()
	o: 448()

nname: 439
n 439(None)[]:
	i: 378(t)
	o: 440()

nname: 416
n 416(None)[self.live_manager.StopLive(live.id)
]:
	i: 378(f)
	o: 440()

nname: 378
n 378(renderer)[log.critical('buildRecord Failed => probably already done')
live.recording_task_runner.endRec(self)
]:
	i: 327(except)
	o: 416(f), 439(t)

nname: 348
n 348(None)[self.buildRecord()
live.recording_task_runner.endRec(self)
]:
	i: 327(try)
	o: 448()

nname: 327
n 327(None)[self.live_id = 0
self.status = RECORDING_STATUS_COMPLETED
]:
	i: 303(), 307(), 326(AE)
	o: 348(try), 378(except)

nname: 307
n 307(None)[log.critical('failed to stop finalize record')
]:
	i: 227(except)
	o: 327()

nname: 303
n 303(None)[]:
	i: 267(JA), 298(), 302()
	o: 327()

nname: 302
n 302(None)[]:
	i: 236(f)
	o: 303()

nname: 298
n 298(None)[]:
	i: 260(f)
	o: 303()

nname: 267
n 267(None)[self.last_chunk = live.chunk_info.getChunkFromOffset(renderer.bytesPos())
]:
	i: 260(t)
	o: 303(JA)

nname: 260
n 260(renderer)[]:
	i: 236(t)
	o: 267(t), 298(f)

nname: 236
n 236(stop_at_player_pos)[renderer = self.renderer_manager.getRenderer(live)
]:
	i: 227(try)
	o: 260(t), 302(f)

nname: 227
n 227(None)[renderer = None
]:
	i: 171(), 226()
	o: 236(try), 307(except)

nname: 226
n 226(None)[]:
	i: 161(f)
	o: 227()

nname: 171
n 171(None)[self.status = RECORDING_STATUS_MACROVISION
self.live_id = 0
live.recording_task_runner.endRec(self)
log.debug('MACROVISION: not possible to keep record')
return False
]:
	i: 161(t)
	o: 227()

nname: 161
n 161(live.has_macrovision)[]:
	i: 133(t)
	o: 171(t), 226(f)

nname: 133
n 133(live)[live = self.live_manager._GetLiveFromLiveID(self.live_id)
]:
	i: 118(t)
	o: 161(t), 481(f)

nname: 118
n 118(self.status == RECORDING_STATUS_RUNNING)[]:
	i: 95(), 108()
	o: 133(t), 589(f)

nname: 108
n 108(None)[self.real_stop_time = 0
]:
	i: 80(f)
	o: 118()

nname: 95
n 95(None)[self.real_stop_time = stop_time
]:
	i: 80(t)
	o: 118()

nname: 80
n 80(self.real_start_time != 0)[]:
	i: 51(), 79()
	o: 95(t), 108(f)

nname: 79
n 79(None)[]:
	i: 0&35(f)
	o: 80()

nname: 51
n 51(None)[log.error('Recording.Stop() : Recording %d was not running neither scheduled !' % self.id)
return False
]:
	i: 0&35(t)
	o: 80()

nname: 0&35
n 0&35(self.status != RECORDING_STATUS_RUNNING and self.status != RECORDING_STATUS_SCHEDULED)[log.info("Stop Recording '%s'" % self.name)
]:
	i: 
	o: 51(t), 79(f)

nname: 599
n 599(None)[self._CreateRecordInfo()
if dbus_api:
	dbus_api.emitNewRecordInfo(self.record_info)
return True
]:
	i: 562(JA), 589(), 448(t), 454(JA), 585(AE)
	o: 

nname: 589
n 589(None)[self.status = RECORDING_STATUS_CANCELED
]:
	i: 0&35(f)
	o: 599()

nname: 562
n 562(None)[except:
	log.critical('buildRecord Failed => probably already done')
	return False
]:
	i: 481()
	o: 599(JA)

nname: 481
n 481(None)[log.debug('trying to stop a recording but live not running')
log.debug('continue anyway => trying to recover')
self.name = self.name + config.recover_string
self.live_id = 0
self.status = RECORDING_STATUS_ABORTED
try:
	self.buildRecord()
]:
	i: 133(f)
	o: 562()

nname: 454
n 454(None)[self.live_manager.StopLive(live.id)
]:
	i: 448(f)
	o: 599(JA)

nname: 448
n 448(renderer)[]:
	i: 348(), 378(), 447(AE)
	o: 454(f), 599(t)

nname: 378
n 378(None)[except:
	log.critical('buildRecord Failed => probably already done')
	live.recording_task_runner.endRec(self)
	if not renderer:
		self.live_manager.StopLive(live.id)
return False
]:
	i: 327(except)
	o: 448()

nname: 348
n 348(None)[self.buildRecord()
live.recording_task_runner.endRec(self)
]:
	i: 327(try)
	o: 448()

nname: 327
n 327(None)[self.live_id = 0
self.status = RECORDING_STATUS_COMPLETED
]:
	i: 303(), 326(AE)
	o: 348(try), 378(except)

nname: 303
n 303(None)[else:
	pass
]:
	i: 236()
	o: 327()

nname: 236
n 236(None)[try:
	renderer = self.renderer_manager.getRenderer(live)
	if stop_at_player_pos:
		if renderer:
			self.last_chunk = live.chunk_info.getChunkFromOffset(renderer.bytesPos())
except:
	log.critical('failed to stop finalize record')
]:
	i: 161(try)
	o: 303()

nname: 161
n 161(None)[if live.has_macrovision:
	self.status = RECORDING_STATUS_MACROVISION
	self.live_id = 0
	live.recording_task_runner.endRec(self)
	log.debug('MACROVISION: not possible to keep record')
	return False
renderer = None
]:
	i: 133(t)
	o: 236(try)

nname: 133
n 133(live)[live = self.live_manager._GetLiveFromLiveID(self.live_id)
]:
	i: 0&35(t)
	o: 161(t), 481(f)

nname: 0&35
n 0&35(self.status == RECORDING_STATUS_RUNNING)[log.info("Stop Recording '%s'" % self.name)
if self.status != RECORDING_STATUS_RUNNING and self.status != RECORDING_STATUS_SCHEDULED:
	log.error('Recording.Stop() : Recording %d was not running neither scheduled !' % self.id)
	return False
if self.real_start_time != 0:
	self.real_stop_time = stop_time
else:
	self.real_stop_time = 0
]:
	i: 
	o: 133(t), 589(f)

nname: 599
n 599(None)[self._CreateRecordInfo()
if dbus_api:
	dbus_api.emitNewRecordInfo(self.record_info)
return True
]:
	i: 481(JA), 589(), 378(t), 585(AE)
	o: 

nname: 589
n 589(None)[self.status = RECORDING_STATUS_CANCELED
]:
	i: 0&35(f)
	o: 599()

nname: 481
n 481(None)[log.debug('trying to stop a recording but live not running')
log.debug('continue anyway => trying to recover')
self.name = self.name + config.recover_string
self.live_id = 0
self.status = RECORDING_STATUS_ABORTED
try:
	self.buildRecord()
except:
	log.critical('buildRecord Failed => probably already done')
	return False
]:
	i: 133(f)
	o: 599(JA)

nname: 378
n 378(None)[except:
	log.critical('buildRecord Failed => probably already done')
	live.recording_task_runner.endRec(self)
	if not renderer:
		self.live_manager.StopLive(live.id)
return False
if not renderer:
	self.live_manager.StopLive(live.id)
]:
	i: 327()
	o: 599(JA)

nname: 327
n 327(None)[self.live_id = 0
self.status = RECORDING_STATUS_COMPLETED
try:
	self.buildRecord()
	live.recording_task_runner.endRec(self)
]:
	i: 303(), 326(AE)
	o: 378()

nname: 303
n 303(None)[else:
	pass
]:
	i: 161()
	o: 327()

nname: 161
n 161(None)[if live.has_macrovision:
	self.status = RECORDING_STATUS_MACROVISION
	self.live_id = 0
	live.recording_task_runner.endRec(self)
	log.debug('MACROVISION: not possible to keep record')
	return False
renderer = None
try:
	renderer = self.renderer_manager.getRenderer(live)
	if stop_at_player_pos:
		if renderer:
			self.last_chunk = live.chunk_info.getChunkFromOffset(renderer.bytesPos())
except:
	log.critical('failed to stop finalize record')
]:
	i: 133(t)
	o: 303()

nname: 133
n 133(live)[live = self.live_manager._GetLiveFromLiveID(self.live_id)
]:
	i: 0&35(t)
	o: 161(t), 481(f)

nname: 0&35
n 0&35(self.status == RECORDING_STATUS_RUNNING)[log.info("Stop Recording '%s'" % self.name)
if self.status != RECORDING_STATUS_RUNNING and self.status != RECORDING_STATUS_SCHEDULED:
	log.error('Recording.Stop() : Recording %d was not running neither scheduled !' % self.id)
	return False
if self.real_start_time != 0:
	self.real_stop_time = stop_time
else:
	self.real_stop_time = 0
]:
	i: 
	o: 133(t), 589(f)

nname: 599
n 599(None)[self._CreateRecordInfo()
if dbus_api:
	dbus_api.emitNewRecordInfo(self.record_info)
return True
]:
	i: 481(JA), 589(), 327(t), 585(AE)
	o: 

nname: 589
n 589(None)[self.status = RECORDING_STATUS_CANCELED
]:
	i: 0&35(f)
	o: 599()

nname: 481
n 481(None)[log.debug('trying to stop a recording but live not running')
log.debug('continue anyway => trying to recover')
self.name = self.name + config.recover_string
self.live_id = 0
self.status = RECORDING_STATUS_ABORTED
try:
	self.buildRecord()
except:
	log.critical('buildRecord Failed => probably already done')
	return False
]:
	i: 133(f)
	o: 599(JA)

nname: 327
n 327(None)[self.live_id = 0
self.status = RECORDING_STATUS_COMPLETED
try:
	self.buildRecord()
	live.recording_task_runner.endRec(self)
except:
	log.critical('buildRecord Failed => probably already done')
	live.recording_task_runner.endRec(self)
	if not renderer:
		self.live_manager.StopLive(live.id)
return False
if not renderer:
	self.live_manager.StopLive(live.id)
]:
	i: 161(), 326(AE)
	o: 599(JA)

nname: 161
n 161(None)[if live.has_macrovision:
	self.status = RECORDING_STATUS_MACROVISION
	self.live_id = 0
	live.recording_task_runner.endRec(self)
	log.debug('MACROVISION: not possible to keep record')
	return False
renderer = None
try:
	renderer = self.renderer_manager.getRenderer(live)
	if stop_at_player_pos:
		if renderer:
			self.last_chunk = live.chunk_info.getChunkFromOffset(renderer.bytesPos())
except:
	log.critical('failed to stop finalize record')
else:
	pass
]:
	i: 133(t)
	o: 327()

nname: 133
n 133(live)[live = self.live_manager._GetLiveFromLiveID(self.live_id)
]:
	i: 0&35(t)
	o: 161(t), 481(f)

nname: 0&35
n 0&35(self.status == RECORDING_STATUS_RUNNING)[log.info("Stop Recording '%s'" % self.name)
if self.status != RECORDING_STATUS_RUNNING and self.status != RECORDING_STATUS_SCHEDULED:
	log.error('Recording.Stop() : Recording %d was not running neither scheduled !' % self.id)
	return False
if self.real_start_time != 0:
	self.real_stop_time = stop_time
else:
	self.real_stop_time = 0
]:
	i: 
	o: 133(t), 589(f)

self.nodes: {133: <unpyclib.structure.node instance at 0xb771204c>, 161: <unpyclib.structure.node instance at 0xb770f22c>, '0&35': <unpyclib.structure.node instance at 0xb770fa8c>, 326: <unpyclib.structure.node instance at 0xb77126cc>, 327: <unpyclib.structure.node instance at 0xb770ff0c>, 585: <unpyclib.structure.node instance at 0xb769f50c>, 589: <unpyclib.structure.node instance at 0xb769f46c>, 599: <unpyclib.structure.node instance at 0xb770f50c>, 481: <unpyclib.structure.node instance at 0xb770f58c>}
nname: 363
n 363(None)[]:
	i: 0(AL), 362()
	o: 

nname: 362
n 362(None)[]:
	i: 168(AF), 358()
	o: 363()

nname: 358
n 358(None)[]:
	i: 338(f), 353()
	o: 362()

nname: 353
n 353(None)[break
continue
]:
	i: 338(t)
	o: 358()

nname: 338
n 338(f == self.last_chunk)[]:
	i: 269(), 310(), 337(AE)
	o: 353(t), 358(f)

nname: 310
n 310(None)[log.error('link to' + dest + ' FAILURE')
]:
	i: 229(except)
	o: 338()

nname: 269
n 269(None)[os.link(f, dest)
log.debug('link to' + dest + ' ok')
]:
	i: 229(try)
	o: 338()

nname: 229
n 229(None)[dest = os.path.join(dest_dir, os.path.split(f)[1])
]:
	i: 211(JA), 221(), 228()
	o: 269(try), 310(except)

nname: 228
n 228(None)[]:
	i: 175(t)
	o: 229()

nname: 221
n 221(None)[continue
]:
	i: 184&200(f)
	o: 229()

nname: 211
n 211(None)[started = True
]:
	i: 184&200(t)
	o: 229(JA)

nname: 184&200
n 184&200(f >= self.first_chunk or not self.first_chunk)[]:
	i: 175(f)
	o: 211(t), 221(f)

nname: 175
n 175(started)[for f in sorted_file_list:
]:
	i: 168(for)
	o: 184&200(f), 228(t)

nname: 168
n 168(None)[]:
	i: 0(loop)
	o: 175(for), 362(AF)

nname: 0
n 0(None)[log.debug('buildRecord first_chunk ' + self.first_chunk)
log.debug('buildRecord last_chunk ' + self.last_chunk)
dest_dir = os.path.split(self.urls[0][len(URL_PREFIX_TIMESHIFT):])[0]
log.debug('dest_dir record ' + dest_dir)
os.makedirs(dest_dir)
sorted_file_list = ChunkInfo(UriChunkToPath(self.live_uri))._getSortedFilelist()
log.debug('buildrecord chunk list: ' + str(sorted_file_list))
started = False
]:
	i: 
	o: 168(loop), 363(AL)

nname: 363
n 363(None)[]:
	i: 0(AL), 168(AF), 338()
	o: 

nname: 338
n 338(None)[if f == self.last_chunk:
	break
	continue
]:
	i: 269()
	o: 363()

nname: 269
n 269(None)[try:
	os.link(f, dest)
	log.debug('link to' + dest + ' ok')
except:
	log.error('link to' + dest + ' FAILURE')
]:
	i: 175(try)
	o: 338()

nname: 175
n 175(None)[for f in sorted_file_list:
if not started:
	if f >= self.first_chunk or not self.first_chunk:
		started = True
	else:
		continue
dest = os.path.join(dest_dir, os.path.split(f)[1])
]:
	i: 168(for)
	o: 269(try)

nname: 168
n 168(None)[]:
	i: 0(loop)
	o: 175(for), 363(AF)

nname: 0
n 0(None)[log.debug('buildRecord first_chunk ' + self.first_chunk)
log.debug('buildRecord last_chunk ' + self.last_chunk)
dest_dir = os.path.split(self.urls[0][len(URL_PREFIX_TIMESHIFT):])[0]
log.debug('dest_dir record ' + dest_dir)
os.makedirs(dest_dir)
sorted_file_list = ChunkInfo(UriChunkToPath(self.live_uri))._getSortedFilelist()
log.debug('buildrecord chunk list: ' + str(sorted_file_list))
started = False
]:
	i: 
	o: 168(loop), 363(AL)

nname: 363
n 363(None)[]:
	i: 0(AL), 168(AF), 338()
	o: 

nname: 338
n 338(None)[if f == self.last_chunk:
	break
	continue
]:
	i: 175()
	o: 363()

nname: 175
n 175(None)[for f in sorted_file_list:
if not started:
	if f >= self.first_chunk or not self.first_chunk:
		started = True
	else:
		continue
dest = os.path.join(dest_dir, os.path.split(f)[1])
try:
	os.link(f, dest)
	log.debug('link to' + dest + ' ok')
except:
	log.error('link to' + dest + ' FAILURE')
]:
	i: 168(for)
	o: 338()

nname: 168
n 168(None)[]:
	i: 0(loop)
	o: 175(for), 363(AF)

nname: 0
n 0(None)[log.debug('buildRecord first_chunk ' + self.first_chunk)
log.debug('buildRecord last_chunk ' + self.last_chunk)
dest_dir = os.path.split(self.urls[0][len(URL_PREFIX_TIMESHIFT):])[0]
log.debug('dest_dir record ' + dest_dir)
os.makedirs(dest_dir)
sorted_file_list = ChunkInfo(UriChunkToPath(self.live_uri))._getSortedFilelist()
log.debug('buildrecord chunk list: ' + str(sorted_file_list))
started = False
]:
	i: 
	o: 168(loop), 363(AL)

nname: 363
n 363(None)[]:
	i: 0(AL), 168(AF), 175()
	o: 

nname: 175
n 175(None)[for f in sorted_file_list:
if not started:
	if f >= self.first_chunk or not self.first_chunk:
		started = True
	else:
		continue
dest = os.path.join(dest_dir, os.path.split(f)[1])
try:
	os.link(f, dest)
	log.debug('link to' + dest + ' ok')
except:
	log.error('link to' + dest + ' FAILURE')
if f == self.last_chunk:
	break
	continue
]:
	i: 168(for)
	o: 363()

nname: 168
n 168(None)[]:
	i: 0(loop)
	o: 175(for), 363(AF)

nname: 0
n 0(None)[log.debug('buildRecord first_chunk ' + self.first_chunk)
log.debug('buildRecord last_chunk ' + self.last_chunk)
dest_dir = os.path.split(self.urls[0][len(URL_PREFIX_TIMESHIFT):])[0]
log.debug('dest_dir record ' + dest_dir)
os.makedirs(dest_dir)
sorted_file_list = ChunkInfo(UriChunkToPath(self.live_uri))._getSortedFilelist()
log.debug('buildrecord chunk list: ' + str(sorted_file_list))
started = False
]:
	i: 
	o: 168(loop), 363(AL)

nname: 175
n 175(None)[for f in sorted_file_list:
	if not started:
		if f >= self.first_chunk or not self.first_chunk:
			started = True
		else:
			continue
	dest = os.path.join(dest_dir, os.path.split(f)[1])
	try:
		os.link(f, dest)
		log.debug('link to' + dest + ' ok')
	except:
		log.error('link to' + dest + ' FAILURE')
	if f == self.last_chunk:
		break
		continue
]:
	i: 0(for)
	o: 

nname: 0
n 0(None)[log.debug('buildRecord first_chunk ' + self.first_chunk)
log.debug('buildRecord last_chunk ' + self.last_chunk)
dest_dir = os.path.split(self.urls[0][len(URL_PREFIX_TIMESHIFT):])[0]
log.debug('dest_dir record ' + dest_dir)
os.makedirs(dest_dir)
sorted_file_list = ChunkInfo(UriChunkToPath(self.live_uri))._getSortedFilelist()
log.debug('buildrecord chunk list: ' + str(sorted_file_list))
started = False
]:
	i: 
	o: 175(for)

nname: 0
n 0(None)[log.debug('buildRecord first_chunk ' + self.first_chunk)
log.debug('buildRecord last_chunk ' + self.last_chunk)
dest_dir = os.path.split(self.urls[0][len(URL_PREFIX_TIMESHIFT):])[0]
log.debug('dest_dir record ' + dest_dir)
os.makedirs(dest_dir)
sorted_file_list = ChunkInfo(UriChunkToPath(self.live_uri))._getSortedFilelist()
log.debug('buildrecord chunk list: ' + str(sorted_file_list))
started = False
for f in sorted_file_list:
	if not started:
		if f >= self.first_chunk or not self.first_chunk:
			started = True
		else:
			continue
	dest = os.path.join(dest_dir, os.path.split(f)[1])
	try:
		os.link(f, dest)
		log.debug('link to' + dest + ' ok')
	except:
		log.error('link to' + dest + ' FAILURE')
	if f == self.last_chunk:
		break
		continue
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76f882c>}
nname: 0
n 0(None)[self.instant_recording = True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7705cec>}
nname: 131
n 131(None)[self.record_info.name = self.name
self.record_info.service_name = self.service_name
self.record_info.start_time = self.real_start_time
self.record_info.stop_time = self.real_stop_time
dvb_service_id = self.service_id & 65535
return self.record_info.Save(url, dvb_service_id)
]:
	i: 102(), 130()
	o: 

nname: 130
n 130(None)[]:
	i: 90(f)
	o: 131()

nname: 102
n 102(None)[log.error('ERROR : Can not create Recording File Info for recording %d !' % self.id)
return False
]:
	i: 90(t)
	o: 131()

nname: 90
n 90(url == '')[]:
	i: 0(AL), 89()
	o: 102(t), 130(f)

nname: 89
n 89(None)[]:
	i: 29(AF), 68()
	o: 90()

nname: 68
n 68(None)[log.critical("ERROR : BUG TO FIX : BAD URL Prefix for a recording ! : url='%s'" % url)
]:
	i: 39(f), 57()
	o: 89()

nname: 57
n 57(None)[url = _url
break
continue
]:
	i: 39(t)
	o: 68()

nname: 39
n 39(_url.startswith(URL_PREFIX_TIMESHIFT))[for _url in self.urls:
]:
	i: 29(for)
	o: 57(t), 68(f)

nname: 29
n 29(None)[]:
	i: 0(loop)
	o: 39(for), 89(AF)

nname: 0
n 0(None)[log.info('Create info file for recording %d' % self.id)
url = ''
]:
	i: 
	o: 29(loop), 90(AL)

nname: 90
n 90(None)[if url == '':
	log.error('ERROR : Can not create Recording File Info for recording %d !' % self.id)
	return False
self.record_info.name = self.name
self.record_info.service_name = self.service_name
self.record_info.start_time = self.real_start_time
self.record_info.stop_time = self.real_stop_time
dvb_service_id = self.service_id & 65535
return self.record_info.Save(url, dvb_service_id)
]:
	i: 0(AL), 29(AF), 39()
	o: 

nname: 39
n 39(None)[for _url in self.urls:
if _url.startswith(URL_PREFIX_TIMESHIFT):
	url = _url
	break
	continue
log.critical("ERROR : BUG TO FIX : BAD URL Prefix for a recording ! : url='%s'" % url)
]:
	i: 29(for)
	o: 90()

nname: 29
n 29(None)[]:
	i: 0(loop)
	o: 39(for), 90(AF)

nname: 0
n 0(None)[log.info('Create info file for recording %d' % self.id)
url = ''
]:
	i: 
	o: 29(loop), 90(AL)

nname: 39
n 39(None)[for _url in self.urls:
	if _url.startswith(URL_PREFIX_TIMESHIFT):
		url = _url
		break
		continue
	log.critical("ERROR : BUG TO FIX : BAD URL Prefix for a recording ! : url='%s'" % url)
if url == '':
	log.error('ERROR : Can not create Recording File Info for recording %d !' % self.id)
	return False
self.record_info.name = self.name
self.record_info.service_name = self.service_name
self.record_info.start_time = self.real_start_time
self.record_info.stop_time = self.real_stop_time
dvb_service_id = self.service_id & 65535
return self.record_info.Save(url, dvb_service_id)
]:
	i: 0(for)
	o: 

nname: 0
n 0(None)[log.info('Create info file for recording %d' % self.id)
url = ''
]:
	i: 
	o: 39(for)

nname: 0
n 0(None)[log.info('Create info file for recording %d' % self.id)
url = ''
for _url in self.urls:
	if _url.startswith(URL_PREFIX_TIMESHIFT):
		url = _url
		break
		continue
	log.critical("ERROR : BUG TO FIX : BAD URL Prefix for a recording ! : url='%s'" % url)
if url == '':
	log.error('ERROR : Can not create Recording File Info for recording %d !' % self.id)
	return False
self.record_info.name = self.name
self.record_info.service_name = self.service_name
self.record_info.start_time = self.real_start_time
self.record_info.stop_time = self.real_stop_time
dvb_service_id = self.service_id & 65535
return self.record_info.Save(url, dvb_service_id)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb770fbcc>}
nname: 40
n 40(None)[return self.record_info
]:
	i: 31(), 39()
	o: 

nname: 39
n 39(None)[]:
	i: 0&15(f)
	o: 40()

nname: 31
n 31(None)[return None
]:
	i: 0&15(t)
	o: 40()

nname: 0&15
n 0&15(self.status != RECORDING_STATUS_COMPLETED and self.status != RECORDING_STATUS_ABORTED)[]:
	i: 
	o: 31(t), 39(f)

nname: 0&15
n 0&15(None)[if self.status != RECORDING_STATUS_COMPLETED and self.status != RECORDING_STATUS_ABORTED:
	return None
return self.record_info
]:
	i: 
	o: 

self.nodes: {'0&15': <unpyclib.structure.node instance at 0xb76f870c>}
nname: 0
n 0(None)[return self.record_info.IsValid()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76f8e2c>}
nname: 0
n 0(None)[self.record_info.Delete()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76f8ecc>}
nname: 0
n 0(None)[return self.live_manager.GetLivesInConflictWithService(self.service_id)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76f84ac>}
nname: 268
n 268(None)[return (rec_to_stop, live_to_stop)
]:
	i: 157(AL), 267()
	o: 

nname: 267
n 267(None)[]:
	i: 197(AF), 263()
	o: 268()

nname: 263
n 263(None)[]:
	i: 228(f), 243()
	o: 267()

nname: 243
n 243(None)[rec_to_stop.append(live.current_recordingid)
continue
]:
	i: 228(t)
	o: 263()

nname: 228
n 228(live.current_recordingid not in rec_to_stop)[]:
	i: 222(), 227()
	o: 243(t), 263(f)

nname: 227
n 227(None)[]:
	i: 204(f)
	o: 228()

nname: 222
n 222(None)[break
]:
	i: 204(t)
	o: 228()

nname: 204
n 204(rec_nb < config.max_simultaneous_rec)[for live in recording_live:
]:
	i: 197(for)
	o: 222(t), 227(f)

nname: 197
n 197(None)[]:
	i: 157(loop)
	o: 204(for), 267(AF)

nname: 157
n 157(None)[recording_live = self.live_manager.GetRecordingLiveList()
rec_nb = len(recording_live) - len(rec_to_stop)
]:
	i: 104(AL), 156()
	o: 197(loop), 268(AL)

nname: 156
n 156(None)[]:
	i: 107(AF), 152()
	o: 157()

nname: 152
n 152(None)[]:
	i: 114(f), 132()
	o: 156()

nname: 132
n 132(None)[rec_to_stop.append(live.current_recordingid)
continue
]:
	i: 114(t)
	o: 152()

nname: 114
n 114(live.current_recordingid != 0)[for live in live_list:
]:
	i: 107(for)
	o: 132(t), 152(f)

nname: 107
n 107(None)[]:
	i: 104(loop)
	o: 114(for), 156(AF)

nname: 104
n 104(None)[]:
	i: 55(JA), 72(), 76()
	o: 107(loop), 157(AL)

nname: 76
n 76(None)[live_list = self.live_manager.GetLivesInConflictWithService(self.service_id)
live_to_stop = live_list
]:
	i: 0(f)
	o: 104()

nname: 72
n 72(None)[]:
	i: 45(f)
	o: 104()

nname: 55
n 55(None)[live_list.append(live)
]:
	i: 45(t)
	o: 104(JA)

nname: 45
n 45(self.instant_recording)[]:
	i: 0(t)
	o: 55(t), 72(f)

nname: 0
n 0(live)[rec_to_stop = []
live_list = []
live_to_stop = []
live = self.live_manager._GetLiveFromServiceID(self.service_id)
]:
	i: 
	o: 45(t), 76(f)

nname: 268
n 268(None)[return (rec_to_stop, live_to_stop)
]:
	i: 157(AL), 197(AF), 204(f)
	o: 

nname: 204
n 204(None)[for live in recording_live:
if rec_nb < config.max_simultaneous_rec:
	break
if live.current_recordingid not in rec_to_stop:
	rec_to_stop.append(live.current_recordingid)
	continue
]:
	i: 197(for)
	o: 268()

nname: 197
n 197(None)[]:
	i: 157(loop)
	o: 204(for), 268(AF)

nname: 157
n 157(None)[recording_live = self.live_manager.GetRecordingLiveList()
rec_nb = len(recording_live) - len(rec_to_stop)
]:
	i: 0(AL), 107(AF), 114()
	o: 197(loop), 268(AL)

nname: 114
n 114(None)[for live in live_list:
if live.current_recordingid != 0:
	rec_to_stop.append(live.current_recordingid)
	continue
]:
	i: 107(for)
	o: 157()

nname: 107
n 107(None)[]:
	i: 0(loop)
	o: 114(for), 157(AF)

nname: 0
n 0(None)[rec_to_stop = []
live_list = []
live_to_stop = []
live = self.live_manager._GetLiveFromServiceID(self.service_id)
if live:
	if self.instant_recording:
		live_list.append(live)
else:
	live_list = self.live_manager.GetLivesInConflictWithService(self.service_id)
	live_to_stop = live_list
]:
	i: 
	o: 107(loop), 157(AL)

nname: 204
n 204(None)[for live in recording_live:
	if rec_nb < config.max_simultaneous_rec:
		break
	if live.current_recordingid not in rec_to_stop:
		rec_to_stop.append(live.current_recordingid)
		continue
return (rec_to_stop, live_to_stop)
]:
	i: 157(for)
	o: 

nname: 157
n 157(None)[recording_live = self.live_manager.GetRecordingLiveList()
rec_nb = len(recording_live) - len(rec_to_stop)
]:
	i: 0(AL), 107(AF), 114()
	o: 204(for)

nname: 114
n 114(None)[for live in live_list:
if live.current_recordingid != 0:
	rec_to_stop.append(live.current_recordingid)
	continue
]:
	i: 107(for)
	o: 157()

nname: 107
n 107(None)[]:
	i: 0(loop)
	o: 114(for), 157(AF)

nname: 0
n 0(None)[rec_to_stop = []
live_list = []
live_to_stop = []
live = self.live_manager._GetLiveFromServiceID(self.service_id)
if live:
	if self.instant_recording:
		live_list.append(live)
else:
	live_list = self.live_manager.GetLivesInConflictWithService(self.service_id)
	live_to_stop = live_list
]:
	i: 
	o: 107(loop), 157(AL)

nname: 157
n 157(None)[recording_live = self.live_manager.GetRecordingLiveList()
rec_nb = len(recording_live) - len(rec_to_stop)
for live in recording_live:
	if rec_nb < config.max_simultaneous_rec:
		break
	if live.current_recordingid not in rec_to_stop:
		rec_to_stop.append(live.current_recordingid)
		continue
return (rec_to_stop, live_to_stop)
]:
	i: 0(AL), 107(AF), 114()
	o: 

nname: 114
n 114(None)[for live in live_list:
if live.current_recordingid != 0:
	rec_to_stop.append(live.current_recordingid)
	continue
]:
	i: 107(for)
	o: 157()

nname: 107
n 107(None)[]:
	i: 0(loop)
	o: 114(for), 157(AF)

nname: 0
n 0(None)[rec_to_stop = []
live_list = []
live_to_stop = []
live = self.live_manager._GetLiveFromServiceID(self.service_id)
if live:
	if self.instant_recording:
		live_list.append(live)
else:
	live_list = self.live_manager.GetLivesInConflictWithService(self.service_id)
	live_to_stop = live_list
]:
	i: 
	o: 107(loop), 157(AL)

self.nodes: {0: <unpyclib.structure.node instance at 0xb770f42c>, 107: <unpyclib.structure.node instance at 0xb770f04c>, 114: <unpyclib.structure.node instance at 0xb770facc>, 157: <unpyclib.structure.node instance at 0xb770f32c>}
nname: 48
n 48(None)[]:
	i: 9(), 29()
	o: 

nname: 29
n 29(None)[self.stop_padding = 0
self.stop_time = new_stop_time
]:
	i: 0(f)
	o: 48()

nname: 9
n 9(None)[self.stop_time = new_stop_time - self.stop_padding
]:
	i: 0(t)
	o: 48()

nname: 0
n 0(self.stop_time)[]:
	i: 
	o: 9(t), 29(f)

nname: 0
n 0(None)[if self.stop_time:
	self.stop_time = new_stop_time - self.stop_padding
else:
	self.stop_padding = 0
	self.stop_time = new_stop_time
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7705a4c>}
nname: 48
n 48(None)[]:
	i: 9(), 29()
	o: 

nname: 29
n 29(None)[self.start_padding = 0
self.start_time = new_start_time
]:
	i: 0(f)
	o: 48()

nname: 9
n 9(None)[self.start_time = new_start_time + self.start_padding
]:
	i: 0(t)
	o: 48()

nname: 0
n 0(self.start_time)[]:
	i: 
	o: 9(t), 29(f)

nname: 0
n 0(None)[if self.start_time:
	self.start_time = new_start_time + self.start_padding
else:
	self.start_padding = 0
	self.start_time = new_start_time
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7705c4c>}
nname: 6
n 6(None)[__doc__ = ' manage a recording.\n    recording can be timeshift recording or standard recording.\n    this class is used even for instant recording\n    '
def __init__(self, renderer_manager, live_manager, external_dvb_manager, strName='', oService=None, possible_deviceids=None, nStartTime=0, nStopTime=0, nStartPadding=0, nStopPadding=0, nMaxStartDelay=0, nType=RECORDING_TYPE_NORMAL, nAskRecordlauncherToStop=True):
	self.renderer_manager = renderer_manager
	self.external_dvb_manager = external_dvb_manager
	self.live_manager = live_manager
	self.id = RECORDING_ID_NULL
	self.periodicity_rule_id = PERIODICITY_RULE_ID_NULL
	self.status = RECORDING_STATUS_UNKNOWN
	self.type = nType
	self.name = strName
	self.start_time = nStartTime
	self.stop_time = nStopTime
	self.start_padding = nStartPadding
	self.stop_padding = nStopPadding
	self.service_id = 0
	if not possible_deviceids:
		self.possible_deviceids = []
	else:
		self.possible_deviceids = possible_deviceids
	self.deviceid = 0
	self.launcher_recordingid = 0
	self.max_start_delay = nMaxStartDelay
	self.internal_recordingid = 0
	self.real_start_time = 0
	self.real_stop_time = 0
	self.service_id = 0
	self.service_name = ''
	if oService != None:
		self.service_id = oService.id
		self.service_name = oService.name
	self.record_info = RecordInfo()
	self.urls = []
	self.instant_recording = config.recording_use_live
	self.live_id = 0
	self.first_chunk = ''
	self.last_chunk = ''
	self.live_uri = ''
	self.program_id = ''
	self.favorite = ''
	return None

def GetScheduledStartTime(self):
	ret = self.start_time
	if ret:
		ret -= self.start_padding
	return ret

def GetScheduledStopTime(self):
	ret = self.stop_time
	if ret:
		ret += self.stop_padding
	return ret

def SaveToXMLNode(self, oXMLNode):
	if oXMLNode == None:
		return False

def LoadFromXML(self, oXMLNode):
	if oXMLNode == None:
		return False

def __str__(self):
	status = 'Unknown'
	if self.status == RECORDING_STATUS_CANCELED:
		status = 'CANCELED'
	else:
		if self.status == RECORDING_STATUS_COMPLETED:
			status = 'COMPLETED'
		else:
			if self.status == RECORDING_STATUS_IN_CONFLICT:
				status = 'IN_CONFLICT'
			else:
				if self.status == RECORDING_STATUS_MISSED:
					status = 'MISSED'
				else:
					if self.status == RECORDING_STATUS_RUNNING:
						status = 'RUNNING'
					else:
						if self.status == RECORDING_STATUS_SCHEDULED:
							status = 'SCHEDULED'
						else:
							if self.status == RECORDING_STATUS_ABORTED:
								status = 'ABORTED'
							else:
								if self.status == RECORDING_STATUS_UNKNOWN:
									status = 'UNKNOWN'
	return 'Recording : id = %d, status = %s, name = %s, type = %d, start_time = %d, stop_time = %d, start_padding = %d, stop_padding = %d, service = %s (%s), device = %d, possible_devices = %s, real_start_time = %d, real_stop_time = %d' % (self.id, status, self.name, self.type, self.start_time, self.stop_time, self.start_padding, self.stop_padding, self.service_id, self.service_name, self.deviceid, self.possible_deviceids, self.real_start_time, self.real_stop_time)

def _GetBaseName(self, live_count):
	strStartTime = ''
	if self.real_start_time != 0:
		strStartTime = datetime.datetime.fromtimestamp(self.real_start_time).strftime(RECORDING_DATE_STRING_FORMAT)
	strValidServiceName = self.service_name
	if len(strValidServiceName) > 20:
		strValidServiceName = strValidServiceName[0:20]
	strValidName = '_' + str(live_count)
	strBaseName = RECORDING_NAME_PREFIX + strStartTime + '_' + str(self.deviceid) + '_' + str(self.service_id) + '_' + strValidServiceName + strValidName
	return strBaseName.replace('/', '_')

_Recording__StartTimeshiftRecord = Chrono(['wyrecord'])()
Start = Chrono(['wyrecord'])()
def Stop(self, stop_time, stop_at_player_pos=False, dbus_api=None):
	log.info("Stop Recording '%s'" % self.name)
	if self.status != RECORDING_STATUS_RUNNING and self.status != RECORDING_STATUS_SCHEDULED:
		log.error('Recording.Stop() : Recording %d was not running neither scheduled !' % self.id)
		return False
	if self.real_start_time != 0:
		self.real_stop_time = stop_time
	else:
		self.real_stop_time = 0

def buildRecord(self):
	log.debug('buildRecord first_chunk ' + self.first_chunk)
	log.debug('buildRecord last_chunk ' + self.last_chunk)
	dest_dir = os.path.split(self.urls[0][len(URL_PREFIX_TIMESHIFT):])[0]
	log.debug('dest_dir record ' + dest_dir)
	os.makedirs(dest_dir)
	sorted_file_list = ChunkInfo(UriChunkToPath(self.live_uri))._getSortedFilelist()
	log.debug('buildrecord chunk list: ' + str(sorted_file_list))
	started = False
	for f in sorted_file_list:
		if not started:
			if f >= self.first_chunk or not self.first_chunk:
				started = True
			else:
				continue
		dest = os.path.join(dest_dir, os.path.split(f)[1])
		try:
			os.link(f, dest)
			log.debug('link to' + dest + ' ok')
		except:
			log.error('link to' + dest + ' FAILURE')
		if f == self.last_chunk:
			break
			continue

def MarkAsInstantRecording(self):
	self.instant_recording = True

def _CreateRecordInfo(self):
	log.info('Create info file for recording %d' % self.id)
	url = ''
	for _url in self.urls:
		if _url.startswith(URL_PREFIX_TIMESHIFT):
			url = _url
			break
			continue
		log.critical("ERROR : BUG TO FIX : BAD URL Prefix for a recording ! : url='%s'" % url)
	if url == '':
		log.error('ERROR : Can not create Recording File Info for recording %d !' % self.id)
		return False
	self.record_info.name = self.name
	self.record_info.service_name = self.service_name
	self.record_info.start_time = self.real_start_time
	self.record_info.stop_time = self.real_stop_time
	dvb_service_id = self.service_id & 65535
	return self.record_info.Save(url, dvb_service_id)

def GetRecordInfo(self):
	if self.status != RECORDING_STATUS_COMPLETED and self.status != RECORDING_STATUS_ABORTED:
		return None
	return self.record_info

def IsValid(self):
	return self.record_info.IsValid()

def Delete(self):
	self.record_info.Delete()

def GetLivesInConflict(self):
	return self.live_manager.GetLivesInConflictWithService(self.service_id)

def GetRecLiveToStop(self):
	rec_to_stop = []
	live_list = []
	live_to_stop = []
	live = self.live_manager._GetLiveFromServiceID(self.service_id)
	if live:
		if self.instant_recording:
			live_list.append(live)
	else:
		live_list = self.live_manager.GetLivesInConflictWithService(self.service_id)
		live_to_stop = live_list

def updateStopTime(self, new_stop_time):
	if self.stop_time:
		self.stop_time = new_stop_time - self.stop_padding
	else:
		self.stop_padding = 0
		self.stop_time = new_stop_time

def updateStartTime(self, new_start_time):
	if self.start_time:
		self.start_time = new_start_time + self.start_padding
	else:
		self.start_padding = 0
		self.start_time = new_start_time

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb76f8dcc>}
nname: 0
n 0(None)[__doc__ = '\nRecording class implementation\n'
import xml.etree.cElementTree as ET
from peewee.analyse import Chrono
import datetime
import error
from chunkinfo import UriChunkToPath
from chunkinfo import ChunkInfo
from recordinfo import RecordInfo
from exceptions import *
from logger import log
import os
from config import *
RECORDING_ID_NULL = 0
PERIODICITY_RULE_ID_NULL = 0
RECORDING_TYPE_NORMAL = 0
RECORDING_TYPE_FLASHBACK = 1
RECORDING_TYPE_NOT_SCHEDULED = 2
RECORDING_TYPE_IS_LIVE = 3
RECORDING_STATUS_UNKNOWN = 0
RECORDING_STATUS_SCHEDULED = 1
RECORDING_STATUS_RUNNING = 2
RECORDING_STATUS_IN_CONFLICT = 3
RECORDING_STATUS_COMPLETED = 4
RECORDING_STATUS_CANCELED = 5
RECORDING_STATUS_MISSED = 6
RECORDING_STATUS_ABORTED = 7
RECORDING_STATUS_MACROVISION = 8
RECORDING_STATUS_DISK_SPACE_ERROR = 9
RECORDING_STATUS_SYSTEM_FAILURE = 10
RECORDING_DATE_STRING_FORMAT = '%Y%m%d_%H%M%S'
RECORDING_NAME_PREFIX = 'REC_'
class RecordingBuilder(object):
	__doc__ = '\n    live_manager and recording_launcher are needed to build a recording\n    RecordingBuilder should be use to make instance of Recording where \n    there shoud be no dependency of live_manager or  recording_launcher\n    '
	def __init__(self, live_manager, external_dvb_manager, renderer_manager):
		self.live_manager = live_manager
		self.external_dvb_manager = external_dvb_manager
		self.renderer_manager = renderer_manager

	def buildNewRecording(self, strName='', oService=None, possible_deviceids=None, nStartTime=0, nStopTime=0, nStartPadding=0, nStopPadding=0, nMaxStartDelay=0, nType=RECORDING_TYPE_NORMAL, nAskRecordlauncherToStop=True):
		return Recording(self.renderer_manager, self.live_manager, self.external_dvb_manager, strName, oService, possible_deviceids, nStartTime, nStopTime, nStartPadding, nStopPadding, nMaxStartDelay, nType, nAskRecordlauncherToStop)



class VirtualRecording(object):
	__doc__ = ' this class contains all the conflict manager should know about a Recording.\n    '
	def __init__(self, deviceid=0, possible_deviceids=None, service_id=0, nStartTime=0, nStopTime=0, start_padding=0, stop_padding=0, id=RECORDING_ID_NULL, live=None):
		self.deviceid = 0
		if not possible_deviceids:
			self.possible_deviceids = []
		else:
			self.possible_deviceids = possible_deviceids
		self.service_id = service_id
		self.start_time = nStartTime
		self.stop_time = nStopTime
		self.start_padding = start_padding
		self.stop_padding = stop_padding
		self.id = id
		self.live = live
		self.type = RECORDING_TYPE_IS_LIVE



class Recording(object):
	__doc__ = ' manage a recording.\n    recording can be timeshift recording or standard recording.\n    this class is used even for instant recording\n    '
	def __init__(self, renderer_manager, live_manager, external_dvb_manager, strName='', oService=None, possible_deviceids=None, nStartTime=0, nStopTime=0, nStartPadding=0, nStopPadding=0, nMaxStartDelay=0, nType=RECORDING_TYPE_NORMAL, nAskRecordlauncherToStop=True):
		self.renderer_manager = renderer_manager
		self.external_dvb_manager = external_dvb_manager
		self.live_manager = live_manager
		self.id = RECORDING_ID_NULL
		self.periodicity_rule_id = PERIODICITY_RULE_ID_NULL
		self.status = RECORDING_STATUS_UNKNOWN
		self.type = nType
		self.name = strName
		self.start_time = nStartTime
		self.stop_time = nStopTime
		self.start_padding = nStartPadding
		self.stop_padding = nStopPadding
		self.service_id = 0
		if not possible_deviceids:
			self.possible_deviceids = []
		else:
			self.possible_deviceids = possible_deviceids
		self.deviceid = 0
		self.launcher_recordingid = 0
		self.max_start_delay = nMaxStartDelay
		self.internal_recordingid = 0
		self.real_start_time = 0
		self.real_stop_time = 0
		self.service_id = 0
		self.service_name = ''
		if oService != None:
			self.service_id = oService.id
			self.service_name = oService.name
		self.record_info = RecordInfo()
		self.urls = []
		self.instant_recording = config.recording_use_live
		self.live_id = 0
		self.first_chunk = ''
		self.last_chunk = ''
		self.live_uri = ''
		self.program_id = ''
		self.favorite = ''
		return None

	def GetScheduledStartTime(self):
		ret = self.start_time
		if ret:
			ret -= self.start_padding
		return ret

	def GetScheduledStopTime(self):
		ret = self.stop_time
		if ret:
			ret += self.stop_padding
		return ret

	def SaveToXMLNode(self, oXMLNode):
		if oXMLNode == None:
			return False

	def LoadFromXML(self, oXMLNode):
		if oXMLNode == None:
			return False

	def __str__(self):
		status = 'Unknown'
		if self.status == RECORDING_STATUS_CANCELED:
			status = 'CANCELED'
		else:
			if self.status == RECORDING_STATUS_COMPLETED:
				status = 'COMPLETED'
			else:
				if self.status == RECORDING_STATUS_IN_CONFLICT:
					status = 'IN_CONFLICT'
				else:
					if self.status == RECORDING_STATUS_MISSED:
						status = 'MISSED'
					else:
						if self.status == RECORDING_STATUS_RUNNING:
							status = 'RUNNING'
						else:
							if self.status == RECORDING_STATUS_SCHEDULED:
								status = 'SCHEDULED'
							else:
								if self.status == RECORDING_STATUS_ABORTED:
									status = 'ABORTED'
								else:
									if self.status == RECORDING_STATUS_UNKNOWN:
										status = 'UNKNOWN'
		return 'Recording : id = %d, status = %s, name = %s, type = %d, start_time = %d, stop_time = %d, start_padding = %d, stop_padding = %d, service = %s (%s), device = %d, possible_devices = %s, real_start_time = %d, real_stop_time = %d' % (self.id, status, self.name, self.type, self.start_time, self.stop_time, self.start_padding, self.stop_padding, self.service_id, self.service_name, self.deviceid, self.possible_deviceids, self.real_start_time, self.real_stop_time)

	def _GetBaseName(self, live_count):
		strStartTime = ''
		if self.real_start_time != 0:
			strStartTime = datetime.datetime.fromtimestamp(self.real_start_time).strftime(RECORDING_DATE_STRING_FORMAT)
		strValidServiceName = self.service_name
		if len(strValidServiceName) > 20:
			strValidServiceName = strValidServiceName[0:20]
		strValidName = '_' + str(live_count)
		strBaseName = RECORDING_NAME_PREFIX + strStartTime + '_' + str(self.deviceid) + '_' + str(self.service_id) + '_' + strValidServiceName + strValidName
		return strBaseName.replace('/', '_')

	_Recording__StartTimeshiftRecord = Chrono(['wyrecord'])()
	Start = Chrono(['wyrecord'])()
	def Stop(self, stop_time, stop_at_player_pos=False, dbus_api=None):
		log.info("Stop Recording '%s'" % self.name)
		if self.status != RECORDING_STATUS_RUNNING and self.status != RECORDING_STATUS_SCHEDULED:
			log.error('Recording.Stop() : Recording %d was not running neither scheduled !' % self.id)
			return False
		if self.real_start_time != 0:
			self.real_stop_time = stop_time
		else:
			self.real_stop_time = 0

	def buildRecord(self):
		log.debug('buildRecord first_chunk ' + self.first_chunk)
		log.debug('buildRecord last_chunk ' + self.last_chunk)
		dest_dir = os.path.split(self.urls[0][len(URL_PREFIX_TIMESHIFT):])[0]
		log.debug('dest_dir record ' + dest_dir)
		os.makedirs(dest_dir)
		sorted_file_list = ChunkInfo(UriChunkToPath(self.live_uri))._getSortedFilelist()
		log.debug('buildrecord chunk list: ' + str(sorted_file_list))
		started = False
		for f in sorted_file_list:
			if not started:
				if f >= self.first_chunk or not self.first_chunk:
					started = True
				else:
					continue
			dest = os.path.join(dest_dir, os.path.split(f)[1])
			try:
				os.link(f, dest)
				log.debug('link to' + dest + ' ok')
			except:
				log.error('link to' + dest + ' FAILURE')
			if f == self.last_chunk:
				break
				continue

	def MarkAsInstantRecording(self):
		self.instant_recording = True

	def _CreateRecordInfo(self):
		log.info('Create info file for recording %d' % self.id)
		url = ''
		for _url in self.urls:
			if _url.startswith(URL_PREFIX_TIMESHIFT):
				url = _url
				break
				continue
			log.critical("ERROR : BUG TO FIX : BAD URL Prefix for a recording ! : url='%s'" % url)
		if url == '':
			log.error('ERROR : Can not create Recording File Info for recording %d !' % self.id)
			return False
		self.record_info.name = self.name
		self.record_info.service_name = self.service_name
		self.record_info.start_time = self.real_start_time
		self.record_info.stop_time = self.real_stop_time
		dvb_service_id = self.service_id & 65535
		return self.record_info.Save(url, dvb_service_id)

	def GetRecordInfo(self):
		if self.status != RECORDING_STATUS_COMPLETED and self.status != RECORDING_STATUS_ABORTED:
			return None
		return self.record_info

	def IsValid(self):
		return self.record_info.IsValid()

	def Delete(self):
		self.record_info.Delete()

	def GetLivesInConflict(self):
		return self.live_manager.GetLivesInConflictWithService(self.service_id)

	def GetRecLiveToStop(self):
		rec_to_stop = []
		live_list = []
		live_to_stop = []
		live = self.live_manager._GetLiveFromServiceID(self.service_id)
		if live:
			if self.instant_recording:
				live_list.append(live)
		else:
			live_list = self.live_manager.GetLivesInConflictWithService(self.service_id)
			live_to_stop = live_list

	def updateStopTime(self, new_stop_time):
		if self.stop_time:
			self.stop_time = new_stop_time - self.stop_padding
		else:
			self.stop_padding = 0
			self.stop_time = new_stop_time

	def updateStartTime(self, new_start_time):
		if self.start_time:
			self.start_time = new_start_time + self.start_padding
		else:
			self.start_padding = 0
			self.start_time = new_start_time



]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76f3a6c>}
__doc__ = '\nRecording class implementation\n'
import xml.etree.cElementTree as ET
from peewee.analyse import Chrono
import datetime
import error
from chunkinfo import UriChunkToPath
from chunkinfo import ChunkInfo
from recordinfo import RecordInfo
from exceptions import *
from logger import log
import os
from config import *
RECORDING_ID_NULL = 0
PERIODICITY_RULE_ID_NULL = 0
RECORDING_TYPE_NORMAL = 0
RECORDING_TYPE_FLASHBACK = 1
RECORDING_TYPE_NOT_SCHEDULED = 2
RECORDING_TYPE_IS_LIVE = 3
RECORDING_STATUS_UNKNOWN = 0
RECORDING_STATUS_SCHEDULED = 1
RECORDING_STATUS_RUNNING = 2
RECORDING_STATUS_IN_CONFLICT = 3
RECORDING_STATUS_COMPLETED = 4
RECORDING_STATUS_CANCELED = 5
RECORDING_STATUS_MISSED = 6
RECORDING_STATUS_ABORTED = 7
RECORDING_STATUS_MACROVISION = 8
RECORDING_STATUS_DISK_SPACE_ERROR = 9
RECORDING_STATUS_SYSTEM_FAILURE = 10
RECORDING_DATE_STRING_FORMAT = '%Y%m%d_%H%M%S'
RECORDING_NAME_PREFIX = 'REC_'
class RecordingBuilder(object):
	__doc__ = '\n    live_manager and recording_launcher are needed to build a recording\n    RecordingBuilder should be use to make instance of Recording where \n    there shoud be no dependency of live_manager or  recording_launcher\n    '
	def __init__(self, live_manager, external_dvb_manager, renderer_manager):
		self.live_manager = live_manager
		self.external_dvb_manager = external_dvb_manager
		self.renderer_manager = renderer_manager

	def buildNewRecording(self, strName='', oService=None, possible_deviceids=None, nStartTime=0, nStopTime=0, nStartPadding=0, nStopPadding=0, nMaxStartDelay=0, nType=RECORDING_TYPE_NORMAL, nAskRecordlauncherToStop=True):
		return Recording(self.renderer_manager, self.live_manager, self.external_dvb_manager, strName, oService, possible_deviceids, nStartTime, nStopTime, nStartPadding, nStopPadding, nMaxStartDelay, nType, nAskRecordlauncherToStop)



class VirtualRecording(object):
	__doc__ = ' this class contains all the conflict manager should know about a Recording.\n    '
	def __init__(self, deviceid=0, possible_deviceids=None, service_id=0, nStartTime=0, nStopTime=0, start_padding=0, stop_padding=0, id=RECORDING_ID_NULL, live=None):
		self.deviceid = 0
		if not possible_deviceids:
			self.possible_deviceids = []
		else:
			self.possible_deviceids = possible_deviceids
		self.service_id = service_id
		self.start_time = nStartTime
		self.stop_time = nStopTime
		self.start_padding = start_padding
		self.stop_padding = stop_padding
		self.id = id
		self.live = live
		self.type = RECORDING_TYPE_IS_LIVE



class Recording(object):
	__doc__ = ' manage a recording.\n    recording can be timeshift recording or standard recording.\n    this class is used even for instant recording\n    '
	def __init__(self, renderer_manager, live_manager, external_dvb_manager, strName='', oService=None, possible_deviceids=None, nStartTime=0, nStopTime=0, nStartPadding=0, nStopPadding=0, nMaxStartDelay=0, nType=RECORDING_TYPE_NORMAL, nAskRecordlauncherToStop=True):
		self.renderer_manager = renderer_manager
		self.external_dvb_manager = external_dvb_manager
		self.live_manager = live_manager
		self.id = RECORDING_ID_NULL
		self.periodicity_rule_id = PERIODICITY_RULE_ID_NULL
		self.status = RECORDING_STATUS_UNKNOWN
		self.type = nType
		self.name = strName
		self.start_time = nStartTime
		self.stop_time = nStopTime
		self.start_padding = nStartPadding
		self.stop_padding = nStopPadding
		self.service_id = 0
		if not possible_deviceids:
			self.possible_deviceids = []
		else:
			self.possible_deviceids = possible_deviceids
		self.deviceid = 0
		self.launcher_recordingid = 0
		self.max_start_delay = nMaxStartDelay
		self.internal_recordingid = 0
		self.real_start_time = 0
		self.real_stop_time = 0
		self.service_id = 0
		self.service_name = ''
		if oService != None:
			self.service_id = oService.id
			self.service_name = oService.name
		self.record_info = RecordInfo()
		self.urls = []
		self.instant_recording = config.recording_use_live
		self.live_id = 0
		self.first_chunk = ''
		self.last_chunk = ''
		self.live_uri = ''
		self.program_id = ''
		self.favorite = ''
		return None

	def GetScheduledStartTime(self):
		ret = self.start_time
		if ret:
			ret -= self.start_padding
		return ret

	def GetScheduledStopTime(self):
		ret = self.stop_time
		if ret:
			ret += self.stop_padding
		return ret

	def SaveToXMLNode(self, oXMLNode):
		if oXMLNode == None:
			return False

	def LoadFromXML(self, oXMLNode):
		if oXMLNode == None:
			return False

	def __str__(self):
		status = 'Unknown'
		if self.status == RECORDING_STATUS_CANCELED:
			status = 'CANCELED'
		else:
			if self.status == RECORDING_STATUS_COMPLETED:
				status = 'COMPLETED'
			else:
				if self.status == RECORDING_STATUS_IN_CONFLICT:
					status = 'IN_CONFLICT'
				else:
					if self.status == RECORDING_STATUS_MISSED:
						status = 'MISSED'
					else:
						if self.status == RECORDING_STATUS_RUNNING:
							status = 'RUNNING'
						else:
							if self.status == RECORDING_STATUS_SCHEDULED:
								status = 'SCHEDULED'
							else:
								if self.status == RECORDING_STATUS_ABORTED:
									status = 'ABORTED'
								else:
									if self.status == RECORDING_STATUS_UNKNOWN:
										status = 'UNKNOWN'
		return 'Recording : id = %d, status = %s, name = %s, type = %d, start_time = %d, stop_time = %d, start_padding = %d, stop_padding = %d, service = %s (%s), device = %d, possible_devices = %s, real_start_time = %d, real_stop_time = %d' % (self.id, status, self.name, self.type, self.start_time, self.stop_time, self.start_padding, self.stop_padding, self.service_id, self.service_name, self.deviceid, self.possible_deviceids, self.real_start_time, self.real_stop_time)

	def _GetBaseName(self, live_count):
		strStartTime = ''
		if self.real_start_time != 0:
			strStartTime = datetime.datetime.fromtimestamp(self.real_start_time).strftime(RECORDING_DATE_STRING_FORMAT)
		strValidServiceName = self.service_name
		if len(strValidServiceName) > 20:
			strValidServiceName = strValidServiceName[0:20]
		strValidName = '_' + str(live_count)
		strBaseName = RECORDING_NAME_PREFIX + strStartTime + '_' + str(self.deviceid) + '_' + str(self.service_id) + '_' + strValidServiceName + strValidName
		return strBaseName.replace('/', '_')

	_Recording__StartTimeshiftRecord = Chrono(['wyrecord'])()
	Start = Chrono(['wyrecord'])()
	def Stop(self, stop_time, stop_at_player_pos=False, dbus_api=None):
		log.info("Stop Recording '%s'" % self.name)
		if self.status != RECORDING_STATUS_RUNNING and self.status != RECORDING_STATUS_SCHEDULED:
			log.error('Recording.Stop() : Recording %d was not running neither scheduled !' % self.id)
			return False
		if self.real_start_time != 0:
			self.real_stop_time = stop_time
		else:
			self.real_stop_time = 0

	def buildRecord(self):
		log.debug('buildRecord first_chunk ' + self.first_chunk)
		log.debug('buildRecord last_chunk ' + self.last_chunk)
		dest_dir = os.path.split(self.urls[0][len(URL_PREFIX_TIMESHIFT):])[0]
		log.debug('dest_dir record ' + dest_dir)
		os.makedirs(dest_dir)
		sorted_file_list = ChunkInfo(UriChunkToPath(self.live_uri))._getSortedFilelist()
		log.debug('buildrecord chunk list: ' + str(sorted_file_list))
		started = False
		for f in sorted_file_list:
			if not started:
				if f >= self.first_chunk or not self.first_chunk:
					started = True
				else:
					continue
			dest = os.path.join(dest_dir, os.path.split(f)[1])
			try:
				os.link(f, dest)
				log.debug('link to' + dest + ' ok')
			except:
				log.error('link to' + dest + ' FAILURE')
			if f == self.last_chunk:
				break
				continue

	def MarkAsInstantRecording(self):
		self.instant_recording = True

	def _CreateRecordInfo(self):
		log.info('Create info file for recording %d' % self.id)
		url = ''
		for _url in self.urls:
			if _url.startswith(URL_PREFIX_TIMESHIFT):
				url = _url
				break
				continue
			log.critical("ERROR : BUG TO FIX : BAD URL Prefix for a recording ! : url='%s'" % url)
		if url == '':
			log.error('ERROR : Can not create Recording File Info for recording %d !' % self.id)
			return False
		self.record_info.name = self.name
		self.record_info.service_name = self.service_name
		self.record_info.start_time = self.real_start_time
		self.record_info.stop_time = self.real_stop_time
		dvb_service_id = self.service_id & 65535
		return self.record_info.Save(url, dvb_service_id)

	def GetRecordInfo(self):
		if self.status != RECORDING_STATUS_COMPLETED and self.status != RECORDING_STATUS_ABORTED:
			return None
		return self.record_info

	def IsValid(self):
		return self.record_info.IsValid()

	def Delete(self):
		self.record_info.Delete()

	def GetLivesInConflict(self):
		return self.live_manager.GetLivesInConflictWithService(self.service_id)

	def GetRecLiveToStop(self):
		rec_to_stop = []
		live_list = []
		live_to_stop = []
		live = self.live_manager._GetLiveFromServiceID(self.service_id)
		if live:
			if self.instant_recording:
				live_list.append(live)
		else:
			live_list = self.live_manager.GetLivesInConflictWithService(self.service_id)
			live_to_stop = live_list

	def updateStopTime(self, new_stop_time):
		if self.stop_time:
			self.stop_time = new_stop_time - self.stop_padding
		else:
			self.stop_padding = 0
			self.stop_time = new_stop_time

	def updateStartTime(self, new_start_time):
		if self.start_time:
			self.start_time = new_start_time + self.start_padding
		else:
			self.start_padding = 0
			self.start_time = new_start_time



