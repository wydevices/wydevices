# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 218
n 218(None)[return None
]:
	i: 191(), 217()
	o: 

nname: 217
n 217(None)[]:
	i: 0(f)
	o: 218()

nname: 191
n 191(None)[ext_disk_space.ReserveSpace(self.timeshift_folder, config.max_size_for_timeshift)
]:
	i: 0(t)
	o: 218()

nname: 0
n 0(ext_disk_space)[self.id = id
self.serviceid = 0
self.deviceid = 0
self.wyscan_recording_id = WYSCAN_RECORDING_ID_NULL
self.source_uri = None
self.dest_uri = None
self.dest_rec_uri = None
self.chunk_info = None
self.has_macrovision = False
self.recording_task_runner = RecordingTaskRunner(self, ext_disk_space)
self.external_dvb_manager = external_dvb_manager
self.external_recorder_factory = external_recorder_factory
self.external_recorder = None
self.bytes_per_sec = config.bytes_per_sec
self.timeshift_folder = os.path.join(config.timeshift_base_folder_path, config.timeshift_live_name + '_' + str(self.id))
]:
	i: 
	o: 191(t), 217(f)

nname: 0
n 0(None)[self.id = id
self.serviceid = 0
self.deviceid = 0
self.wyscan_recording_id = WYSCAN_RECORDING_ID_NULL
self.source_uri = None
self.dest_uri = None
self.dest_rec_uri = None
self.chunk_info = None
self.has_macrovision = False
self.recording_task_runner = RecordingTaskRunner(self, ext_disk_space)
self.external_dvb_manager = external_dvb_manager
self.external_recorder_factory = external_recorder_factory
self.external_recorder = None
self.bytes_per_sec = config.bytes_per_sec
self.timeshift_folder = os.path.join(config.timeshift_base_folder_path, config.timeshift_live_name + '_' + str(self.id))
if ext_disk_space:
	ext_disk_space.ReserveSpace(self.timeshift_folder, config.max_size_for_timeshift)
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75714ac>}
nname: 0
n 0(None)[return self.wyscan_recording_id != WYSCAN_RECORDING_ID_NULL
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75759cc>}
nname: 0
n 0(None)[return self.recording_task_runner.getTaskList() != []
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75759ec>}
nname: 0
n 0(None)[self.resetRecorder()
self.source_uri, self.dest_uri, self.dest_rec_uri = self._Live__generateSourceAndDestUris(service, device_to_use)
self.external_recorder = self.external_recorder_factory.getNewExternalRecorder(self.dest_rec_uri)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7575f4c>}
nname: 0
n 0(None)[return self.start(service, device_id, self.wyscan_recording_id, use_post_zap)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7575b2c>}
nname: 0
n 0(None)[self.onTimeShiftStart()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7575b0c>}
nname: 251
n 251(None)[return True
]:
	i: 236(), 250()
	o: 

nname: 250
n 250(None)[]:
	i: 230(t)
	o: 251()

nname: 236
n 236(None)[self.onTimeShiftStart()
]:
	i: 230(f)
	o: 251()

nname: 230
n 230(use_post_zap)[]:
	i: 189(), 212()
	o: 236(f), 250(t)

nname: 212
n 212(None)[log.critical('failed to build a recporder instance')
return False
]:
	i: 145(f)
	o: 230()

nname: 189
n 189(None)[self.external_recorder.startRec(self.source_uri)
]:
	i: 145(t)
	o: 230()

nname: 145
n 145(self.external_recorder)[self.serviceid = service
self.deviceid = result['deviceid']
self.wyscan_recording_id = result['wyscan_recording_id']
]:
	i: 117(), 144()
	o: 189(t), 212(f)

nname: 144
n 144(None)[]:
	i: 68(f)
	o: 145()

nname: 117
n 117(None)[self.resetRecorder()
self.source_uri = None
return False
]:
	i: 68(t)
	o: 145()

nname: 68
n 68(result['status'] != error.WYRECORD_SUCCESS)[result = self.external_dvb_manager.startService(service, device_to_use, self.source_uri, service_to_stop)
]:
	i: 9(), 67()
	o: 117(t), 144(f)

nname: 67
n 67(None)[]:
	i: 0(t)
	o: 68()

nname: 9
n 9(None)[self.source_uri, self.dest_uri, self.dest_rec_uri = self._Live__generateSourceAndDestUris(service, device_to_use)
self.dest_uri = None
self.dest_rec_uri = None
]:
	i: 0(f)
	o: 68()

nname: 0
n 0(self.external_recorder)[]:
	i: 
	o: 9(f), 67(t)

nname: 251
n 251(None)[return True
]:
	i: 145()
	o: 

nname: 145
n 145(None)[self.serviceid = service
self.deviceid = result['deviceid']
self.wyscan_recording_id = result['wyscan_recording_id']
if self.external_recorder:
	self.external_recorder.startRec(self.source_uri)
else:
	log.critical('failed to build a recporder instance')
	return False
if not use_post_zap:
	self.onTimeShiftStart()
]:
	i: 0()
	o: 251()

nname: 0
n 0(None)[if not self.external_recorder:
	self.source_uri, self.dest_uri, self.dest_rec_uri = self._Live__generateSourceAndDestUris(service, device_to_use)
	self.dest_uri = None
	self.dest_rec_uri = None
result = self.external_dvb_manager.startService(service, device_to_use, self.source_uri, service_to_stop)
if result['status'] != error.WYRECORD_SUCCESS:
	self.resetRecorder()
	self.source_uri = None
	return False
]:
	i: 
	o: 145()

nname: 251
n 251(None)[return True
]:
	i: 0()
	o: 

nname: 0
n 0(None)[if not self.external_recorder:
	self.source_uri, self.dest_uri, self.dest_rec_uri = self._Live__generateSourceAndDestUris(service, device_to_use)
	self.dest_uri = None
	self.dest_rec_uri = None
result = self.external_dvb_manager.startService(service, device_to_use, self.source_uri, service_to_stop)
if result['status'] != error.WYRECORD_SUCCESS:
	self.resetRecorder()
	self.source_uri = None
	return False
self.serviceid = service
self.deviceid = result['deviceid']
self.wyscan_recording_id = result['wyscan_recording_id']
if self.external_recorder:
	self.external_recorder.startRec(self.source_uri)
else:
	log.critical('failed to build a recporder instance')
	return False
if not use_post_zap:
	self.onTimeShiftStart()
]:
	i: 
	o: 251()

nname: 0
n 0(None)[if not self.external_recorder:
	self.source_uri, self.dest_uri, self.dest_rec_uri = self._Live__generateSourceAndDestUris(service, device_to_use)
	self.dest_uri = None
	self.dest_rec_uri = None
result = self.external_dvb_manager.startService(service, device_to_use, self.source_uri, service_to_stop)
if result['status'] != error.WYRECORD_SUCCESS:
	self.resetRecorder()
	self.source_uri = None
	return False
self.serviceid = service
self.deviceid = result['deviceid']
self.wyscan_recording_id = result['wyscan_recording_id']
if self.external_recorder:
	self.external_recorder.startRec(self.source_uri)
else:
	log.critical('failed to build a recporder instance')
	return False
if not use_post_zap:
	self.onTimeShiftStart()
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb757e5cc>}
nname: 190
n 190(None)[self.resetRecorder()
self.serviceid = 0
self.deviceid = 0
self.wyscan_recording_id = WYSCAN_RECORDING_ID_NULL
self.source_uri = None
self.dest_uri = None
self.external_recorder = None
log.debug('stop live end')
return ret
]:
	i: 166(), 170(), 189(AE)
	o: 

nname: 170
n 170(None)[log.critical('failed to stop dvb source')
]:
	i: 77(except)
	o: 190()

nname: 166
n 166(None)[]:
	i: 129(), 165()
	o: 190()

nname: 165
n 165(None)[]:
	i: 93(f)
	o: 166()

nname: 129
n 129(None)[log.error('StopRecording(%d) FAILED (error %d) !' % (self.internal_recordingid, status))
ret = False
]:
	i: 93(t)
	o: 166()

nname: 93
n 93(status != error.WYRECORD_SUCCESS)[status = self.external_dvb_manager.stopService(self.wyscan_recording_id)
]:
	i: 77(try)
	o: 129(t), 165(f)

nname: 77
n 77(None)[log.debug('self.external_dvb_manager.stopService(self.wyscan_recording_id)')
]:
	i: 55(), 76()
	o: 93(try), 170(except)

nname: 76
n 76(None)[]:
	i: 43(f)
	o: 77()

nname: 55
n 55(None)[log.error('Trying to stop a live that is recording')
return False
]:
	i: 43(t)
	o: 77()

nname: 43
n 43(self.isRecording())[]:
	i: 21(), 42()
	o: 55(t), 76(f)

nname: 42
n 42(None)[]:
	i: 0(f)
	o: 43()

nname: 21
n 21(None)[log.error('Trying to stop a live not started')
return False
]:
	i: 0(t)
	o: 43()

nname: 0
n 0(self.wyscan_recording_id == WYSCAN_RECORDING_ID_NULL)[ret = True
]:
	i: 
	o: 21(t), 42(f)

nname: 190
n 190(None)[self.resetRecorder()
self.serviceid = 0
self.deviceid = 0
self.wyscan_recording_id = WYSCAN_RECORDING_ID_NULL
self.source_uri = None
self.dest_uri = None
self.external_recorder = None
log.debug('stop live end')
return ret
]:
	i: 170(), 77()
	o: 

nname: 170
n 170(None)[except:
	log.critical('failed to stop dvb source')
]:
	i: 77()
	o: 190()

nname: 190
n 190(None)[self.resetRecorder()
self.serviceid = 0
self.deviceid = 0
self.wyscan_recording_id = WYSCAN_RECORDING_ID_NULL
self.source_uri = None
self.dest_uri = None
self.external_recorder = None
log.debug('stop live end')
return ret
]:
	i: 170(), 77()
	o: 

nname: 77
n 77(None)[log.debug('self.external_dvb_manager.stopService(self.wyscan_recording_id)')
try:
	status = self.external_dvb_manager.stopService(self.wyscan_recording_id)
	if status != error.WYRECORD_SUCCESS:
		log.error('StopRecording(%d) FAILED (error %d) !' % (self.internal_recordingid, status))
		ret = False
]:
	i: 0()
	o: 190(), 170()

nname: 0
n 0(None)[ret = True
if self.wyscan_recording_id == WYSCAN_RECORDING_ID_NULL:
	log.error('Trying to stop a live not started')
	return False
if self.isRecording():
	log.error('Trying to stop a live that is recording')
	return False
]:
	i: 
	o: 77()

nname: 190
n 190(None)[self.resetRecorder()
self.serviceid = 0
self.deviceid = 0
self.wyscan_recording_id = WYSCAN_RECORDING_ID_NULL
self.source_uri = None
self.dest_uri = None
self.external_recorder = None
log.debug('stop live end')
return ret
]:
	i: 170(), 0()
	o: 

nname: 170
n 170(None)[except:
	log.critical('failed to stop dvb source')
]:
	i: 0()
	o: 190()

nname: 190
n 190(None)[self.resetRecorder()
self.serviceid = 0
self.deviceid = 0
self.wyscan_recording_id = WYSCAN_RECORDING_ID_NULL
self.source_uri = None
self.dest_uri = None
self.external_recorder = None
log.debug('stop live end')
return ret
]:
	i: 170(), 0()
	o: 

nname: 0
n 0(None)[ret = True
if self.wyscan_recording_id == WYSCAN_RECORDING_ID_NULL:
	log.error('Trying to stop a live not started')
	return False
if self.isRecording():
	log.error('Trying to stop a live that is recording')
	return False
log.debug('self.external_dvb_manager.stopService(self.wyscan_recording_id)')
try:
	status = self.external_dvb_manager.stopService(self.wyscan_recording_id)
	if status != error.WYRECORD_SUCCESS:
		log.error('StopRecording(%d) FAILED (error %d) !' % (self.internal_recordingid, status))
		ret = False
]:
	i: 
	o: 190(), 170()

self.nodes: {0: <unpyclib.structure.node instance at 0xb757ea6c>, 170: <unpyclib.structure.node instance at 0xb757edcc>, 190: <unpyclib.structure.node instance at 0xb757ee4c>}
nname: 52
n 52(None)[]:
	i: 31(JA), 39(), 47()
	o: 

nname: 47
n 47(None)[return 3
]:
	i: 0(f)
	o: 52()

nname: 39
n 39(None)[return 0
]:
	i: 15(f)
	o: 52()

nname: 31
n 31(None)[return 1
]:
	i: 15(t)
	o: 52(JA)

nname: 15
n 15(self.recording_task_runner.containsSchedule())[]:
	i: 0(t)
	o: 31(t), 39(f)

nname: 0
n 0(self.recording_task_runner.getTaskList())[]:
	i: 
	o: 15(t), 47(f)

nname: 0
n 0(None)[if self.recording_task_runner.getTaskList():
	if self.recording_task_runner.containsSchedule():
		return 1
	else:
		return 0
else:
	return 3
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7575cec>}
nname: 43
n 43(None)[self.dest_uri = None
self.dest_rec_uri = None
self.external_recorder = None
self.has_macrovision = False
self.onTimeShiftStop()
return None
]:
	i: 9(), 42()
	o: 

nname: 42
n 42(None)[]:
	i: 0(f)
	o: 43()

nname: 9
n 9(None)[self.external_recorder.stopRec()
self.deleteRecorder(self.external_recorder)
]:
	i: 0(t)
	o: 43()

nname: 0
n 0(self.external_recorder)[]:
	i: 
	o: 9(t), 42(f)

nname: 0
n 0(None)[if self.external_recorder:
	self.external_recorder.stopRec()
	self.deleteRecorder(self.external_recorder)
self.dest_uri = None
self.dest_rec_uri = None
self.external_recorder = None
self.has_macrovision = False
self.onTimeShiftStop()
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7575e4c>}
nname: 0
n 0(None)[ret = self.external_recorder
self.external_recorder = None
return ret
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7575a8c>}
nname: 0
n 0(None)[self.external_recorder_factory.appendRecorderToDelete(recorder)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7575b2c>}
nname: 0
n 0(None)[Live.LIVE_COUNT += 1
extension = '%d_%d_%d' % (device_id, service_id, Live.LIVE_COUNT)
unix_socket_path = os.path.join(config.unix_socket_folder_path, 'sock_' + extension)
source_uri = URL_PREFIX_UNIX_SOCKET + unix_socket_path
timeshift_folder = os.path.join(self.timeshift_folder, 'ts_' + extension)
timeshift_folder = os.path.join(timeshift_folder, config.timeshift_chunk_file_name_format)
dest_uri = URL_PREFIX_TIMESHIFT + timeshift_folder
dest_rec_uri = URL_PREFIX_REC_TIMESHIFT + timeshift_folder
return [source_uri, dest_uri, dest_rec_uri]
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb757e70c>}
nname: 30
n 30(None)[]:
	i: 9(), 29()
	o: 

nname: 29
n 29(None)[]:
	i: 0(f)
	o: 30()

nname: 9
n 9(None)[self.chunk_info.saveReadOffset(offset)
]:
	i: 0(t)
	o: 30()

nname: 0
n 0(self.chunk_info)[]:
	i: 
	o: 9(t), 29(f)

nname: 0
n 0(None)[if self.chunk_info:
	self.chunk_info.saveReadOffset(offset)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb757590c>}
nname: 133
n 133(None)[return False
]:
	i: 71(), 132()
	o: 

nname: 132
n 132(None)[]:
	i: 18(f)
	o: 133()

nname: 71
n 71(None)[log.info('updateTimeshiftSize timeshift_size=' + str(timeshift_size) + ' total=' + str(total_size))
self.external_recorder.setMaxRecSize(total_size)
return True
]:
	i: 18(t)
	o: 133()

nname: 18
n 18(abs(total_size - self.external_recorder.last_size) > config.size_error_before_allocation)[recording_size = self.getRecordingSize()
total_size = timeshift_size + recording_size
]:
	i: 9(), 17()
	o: 71(t), 132(f)

nname: 17
n 17(None)[]:
	i: 0(t)
	o: 18()

nname: 9
n 9(None)[return False
]:
	i: 0(f)
	o: 18()

nname: 0
n 0(self.external_recorder)[]:
	i: 
	o: 9(f), 17(t)

nname: 133
n 133(None)[return False
]:
	i: 0()
	o: 

nname: 0
n 0(None)[if not self.external_recorder:
	return False
recording_size = self.getRecordingSize()
total_size = timeshift_size + recording_size
if abs(total_size - self.external_recorder.last_size) > config.size_error_before_allocation:
	log.info('updateTimeshiftSize timeshift_size=' + str(timeshift_size) + ' total=' + str(total_size))
	self.external_recorder.setMaxRecSize(total_size)
	return True
]:
	i: 
	o: 133()

nname: 0
n 0(None)[if not self.external_recorder:
	return False
recording_size = self.getRecordingSize()
total_size = timeshift_size + recording_size
if abs(total_size - self.external_recorder.last_size) > config.size_error_before_allocation:
	log.info('updateTimeshiftSize timeshift_size=' + str(timeshift_size) + ' total=' + str(total_size))
	self.external_recorder.setMaxRecSize(total_size)
	return True
return False
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7575cac>}
nname: 71
n 71(None)[self.chunk_info = ChunkInfo(UriChunkToPath(self.dest_uri))
self.chunk_info.synchronyseStartTime(self.external_dvb_manager.GetCurrentUTCTime())
return True
]:
	i: 49(), 70()
	o: 

nname: 70
n 70(None)[]:
	i: 31(t)
	o: 71()

nname: 49
n 49(None)[log.critical('WYRECORD ERROR - onTimeShiftStart : no timeshift url ')
return False
]:
	i: 31(f)
	o: 71()

nname: 31
n 31(self.dest_uri.startswith(URL_PREFIX_TIMESHIFT))[]:
	i: 9(), 30()
	o: 49(f), 70(t)

nname: 30
n 30(None)[]:
	i: 0(t)
	o: 31()

nname: 9
n 9(None)[log.critical('no destination uri')
return False
]:
	i: 0(f)
	o: 31()

nname: 0
n 0(self.dest_uri)[]:
	i: 
	o: 9(f), 30(t)

nname: 71
n 71(None)[self.chunk_info = ChunkInfo(UriChunkToPath(self.dest_uri))
self.chunk_info.synchronyseStartTime(self.external_dvb_manager.GetCurrentUTCTime())
return True
]:
	i: 0()
	o: 

nname: 0
n 0(None)[if not self.dest_uri:
	log.critical('no destination uri')
	return False
if not self.dest_uri.startswith(URL_PREFIX_TIMESHIFT):
	log.critical('WYRECORD ERROR - onTimeShiftStart : no timeshift url ')
	return False
]:
	i: 
	o: 71()

nname: 0
n 0(None)[if not self.dest_uri:
	log.critical('no destination uri')
	return False
if not self.dest_uri.startswith(URL_PREFIX_TIMESHIFT):
	log.critical('WYRECORD ERROR - onTimeShiftStart : no timeshift url ')
	return False
self.chunk_info = ChunkInfo(UriChunkToPath(self.dest_uri))
self.chunk_info.synchronyseStartTime(self.external_dvb_manager.GetCurrentUTCTime())
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7575ecc>}
nname: 0
n 0(None)[self.chunk_info = None
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb757588c>}
nname: 59
n 59(None)[recording_size = (self.recording_task_runner.global_stop_time - self.recording_task_runner.global_start_time) * bytes_per_sec
recording_size += 2 * config.size_error_before_allocation
return recording_size
]:
	i: 45(), 58()
	o: 

nname: 58
n 58(None)[]:
	i: 24(t)
	o: 59()

nname: 45
n 45(None)[bytes_per_sec = self.bytes_per_sec
]:
	i: 24(f)
	o: 59()

nname: 24
n 24(bytes_per_sec)[bytes_per_sec = self.chunk_info.getBytesPerSec()
]:
	i: 15(), 23()
	o: 45(f), 58(t)

nname: 23
n 23(None)[]:
	i: 0(t)
	o: 24()

nname: 15
n 15(None)[return 0
]:
	i: 0(f)
	o: 24()

nname: 0
n 0(self.chunk_info)[recording_size = 0
]:
	i: 
	o: 15(f), 23(t)

nname: 59
n 59(None)[recording_size = (self.recording_task_runner.global_stop_time - self.recording_task_runner.global_start_time) * bytes_per_sec
recording_size += 2 * config.size_error_before_allocation
return recording_size
]:
	i: 0()
	o: 

nname: 0
n 0(None)[recording_size = 0
if not self.chunk_info:
	return 0
bytes_per_sec = self.chunk_info.getBytesPerSec()
if not bytes_per_sec:
	bytes_per_sec = self.bytes_per_sec
]:
	i: 
	o: 59()

nname: 0
n 0(None)[recording_size = 0
if not self.chunk_info:
	return 0
bytes_per_sec = self.chunk_info.getBytesPerSec()
if not bytes_per_sec:
	bytes_per_sec = self.bytes_per_sec
recording_size = (self.recording_task_runner.global_stop_time - self.recording_task_runner.global_start_time) * bytes_per_sec
recording_size += 2 * config.size_error_before_allocation
return recording_size
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7575e0c>}
nname: 31
n 31(None)[]:
	i: 9(), 17()
	o: 

nname: 17
n 17(None)[return self.chunk_info.getChunkTotalSize()
]:
	i: 0(t)
	o: 31()

nname: 9
n 9(None)[return 0
]:
	i: 0(f)
	o: 31()

nname: 0
n 0(self.chunk_info)[]:
	i: 
	o: 9(f), 17(t)

nname: 0
n 0(None)[if not self.chunk_info:
	return 0
else:
	return self.chunk_info.getChunkTotalSize()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7575b4c>}
nname: 38
n 38(None)[return None
]:
	i: 21(), 33()
	o: 

nname: 33
n 33(None)[return None
]:
	i: 0(f)
	o: 38()

nname: 21
n 21(None)[return task_list[0]
]:
	i: 0(t)
	o: 38()

nname: 0
n 0(task_list)[task_list = self.recording_task_runner.getTaskList()
]:
	i: 
	o: 21(t), 33(f)

nname: 0
n 0(None)[task_list = self.recording_task_runner.getTaskList()
if task_list:
	return task_list[0]
else:
	return None
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7575dec>}
nname: 41
n 41(None)[]:
	i: 21(), 36()
	o: 

nname: 36
n 36(None)[return 0
]:
	i: 0(f)
	o: 41()

nname: 21
n 21(None)[return task_list[0].id
]:
	i: 0(t)
	o: 41()

nname: 0
n 0(task_list)[task_list = self.recording_task_runner.getTaskList()
]:
	i: 
	o: 21(t), 36(f)

nname: 0
n 0(None)[task_list = self.recording_task_runner.getTaskList()
if task_list:
	return task_list[0].id
else:
	return 0
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7575cec>}
nname: 0
n 0(None)[return self.isRecording()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7575d2c>}
nname: 0
n 0(None)[return False
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7575a2c>}
nname: 6
n 6(None)[__doc__ = ' Live object is responsible of getting stopping live stream source.\n    live object is responsible of recording the stream (timeshift or record feature)\n    \n    recording needs are abstracted via RecordingTaskRunner object.\n    \n    currently, only DVB stream from wyscan is supported\n    \n    '
LIVE_COUNT = 0
def __init__(self, id, external_dvb_manager, external_recorder_factory, ext_disk_space):
	self.id = id
	self.serviceid = 0
	self.deviceid = 0
	self.wyscan_recording_id = WYSCAN_RECORDING_ID_NULL
	self.source_uri = None
	self.dest_uri = None
	self.dest_rec_uri = None
	self.chunk_info = None
	self.has_macrovision = False
	self.recording_task_runner = RecordingTaskRunner(self, ext_disk_space)
	self.external_dvb_manager = external_dvb_manager
	self.external_recorder_factory = external_recorder_factory
	self.external_recorder = None
	self.bytes_per_sec = config.bytes_per_sec
	self.timeshift_folder = os.path.join(config.timeshift_base_folder_path, config.timeshift_live_name + '_' + str(self.id))
	if ext_disk_space:
		ext_disk_space.ReserveSpace(self.timeshift_folder, config.max_size_for_timeshift)
	return None

def isRunning(self):
	return self.wyscan_recording_id != WYSCAN_RECORDING_ID_NULL

def isRecording(self):
	return self.recording_task_runner.getTaskList() != []

def prepareRecorder(self, service, device_to_use=0):
	self.resetRecorder()
	self.source_uri, self.dest_uri, self.dest_rec_uri = self._Live__generateSourceAndDestUris(service, device_to_use)
	self.external_recorder = self.external_recorder_factory.getNewExternalRecorder(self.dest_rec_uri)

def zap(self, service, device_id, use_post_zap=False):
	return self.start(service, device_id, self.wyscan_recording_id, use_post_zap)

def postZap(self):
	self.onTimeShiftStart()

def start(self, service, device_to_use=0, service_to_stop=None, use_post_zap=False):
	if not self.external_recorder:
		self.source_uri, self.dest_uri, self.dest_rec_uri = self._Live__generateSourceAndDestUris(service, device_to_use)
		self.dest_uri = None
		self.dest_rec_uri = None
	result = self.external_dvb_manager.startService(service, device_to_use, self.source_uri, service_to_stop)
	if result['status'] != error.WYRECORD_SUCCESS:
		self.resetRecorder()
		self.source_uri = None
		return False
	self.serviceid = service
	self.deviceid = result['deviceid']
	self.wyscan_recording_id = result['wyscan_recording_id']
	if self.external_recorder:
		self.external_recorder.startRec(self.source_uri)
	else:
		log.critical('failed to build a recporder instance')
		return False
	if not use_post_zap:
		self.onTimeShiftStart()
	return True

def stop(self):
	ret = True
	if self.wyscan_recording_id == WYSCAN_RECORDING_ID_NULL:
		log.error('Trying to stop a live not started')
		return False
	if self.isRecording():
		log.error('Trying to stop a live that is recording')
		return False
	log.debug('self.external_dvb_manager.stopService(self.wyscan_recording_id)')
	try:
		status = self.external_dvb_manager.stopService(self.wyscan_recording_id)
		if status != error.WYRECORD_SUCCESS:
			log.error('StopRecording(%d) FAILED (error %d) !' % (self.internal_recordingid, status))
			ret = False

def getPriority(self):
	if self.recording_task_runner.getTaskList():
		if self.recording_task_runner.containsSchedule():
			return 1
		else:
			return 0
	else:
		return 3

def resetRecorder(self):
	if self.external_recorder:
		self.external_recorder.stopRec()
		self.deleteRecorder(self.external_recorder)
	self.dest_uri = None
	self.dest_rec_uri = None
	self.external_recorder = None
	self.has_macrovision = False
	self.onTimeShiftStop()
	return None

def getRecorderForPostReset(self):
	ret = self.external_recorder
	self.external_recorder = None
	return ret

def deleteRecorder(self, recorder):
	self.external_recorder_factory.appendRecorderToDelete(recorder)

def _Live__generateSourceAndDestUris(self, service_id, device_id):
	Live.LIVE_COUNT += 1
	extension = '%d_%d_%d' % (device_id, service_id, Live.LIVE_COUNT)
	unix_socket_path = os.path.join(config.unix_socket_folder_path, 'sock_' + extension)
	source_uri = URL_PREFIX_UNIX_SOCKET + unix_socket_path
	timeshift_folder = os.path.join(self.timeshift_folder, 'ts_' + extension)
	timeshift_folder = os.path.join(timeshift_folder, config.timeshift_chunk_file_name_format)
	dest_uri = URL_PREFIX_TIMESHIFT + timeshift_folder
	dest_rec_uri = URL_PREFIX_REC_TIMESHIFT + timeshift_folder
	return [source_uri, dest_uri, dest_rec_uri]

def saveReadOffset(self, offset):
	if self.chunk_info:
		self.chunk_info.saveReadOffset(offset)

def updateTimeshiftSize(self, timeshift_size):
	if not self.external_recorder:
		return False
	recording_size = self.getRecordingSize()
	total_size = timeshift_size + recording_size
	if abs(total_size - self.external_recorder.last_size) > config.size_error_before_allocation:
		log.info('updateTimeshiftSize timeshift_size=' + str(timeshift_size) + ' total=' + str(total_size))
		self.external_recorder.setMaxRecSize(total_size)
		return True
	return False

def onTimeShiftStart(self):
	if not self.dest_uri:
		log.critical('no destination uri')
		return False
	if not self.dest_uri.startswith(URL_PREFIX_TIMESHIFT):
		log.critical('WYRECORD ERROR - onTimeShiftStart : no timeshift url ')
		return False
	self.chunk_info = ChunkInfo(UriChunkToPath(self.dest_uri))
	self.chunk_info.synchronyseStartTime(self.external_dvb_manager.GetCurrentUTCTime())
	return True

def onTimeShiftStop(self):
	self.chunk_info = None
	return None

def getRecordingSize(self):
	recording_size = 0
	if not self.chunk_info:
		return 0
	bytes_per_sec = self.chunk_info.getBytesPerSec()
	if not bytes_per_sec:
		bytes_per_sec = self.bytes_per_sec
	recording_size = (self.recording_task_runner.global_stop_time - self.recording_task_runner.global_start_time) * bytes_per_sec
	recording_size += 2 * config.size_error_before_allocation
	return recording_size

def getUsedSpace(self):
	if not self.chunk_info:
		return 0
	else:
		return self.chunk_info.getChunkTotalSize()

def _Live__get_current_rec(self):
	task_list = self.recording_task_runner.getTaskList()
	if task_list:
		return task_list[0]
	else:
		return None
	return None

current_rec = property(fget=_Live__get_current_rec)
def _Live__get_current_recordingid(self):
	task_list = self.recording_task_runner.getTaskList()
	if task_list:
		return task_list[0].id
	else:
		return 0

current_recordingid = property(fget=_Live__get_current_recordingid)
def IsRecording(self):
	return self.isRecording()

def IsPlayingOnlive(self):
	return False

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75ebb4c>}
nname: 0
n 0(None)[__doc__ = '\nLive class implementation\n'
LIVE_ID_NULL = 0
import os
import error
from config import *
from logger import log
from chunkinfo import ChunkInfo
from chunkinfo import UriChunkToPath
from peewee.analyse import Chrono
from recordingtaskrunner import RecordingTaskRunner
from externaldvbmanager import WYSCAN_RECORDING_ID_NULL
from callbacks import Callbacks
class Live(object):
	__doc__ = ' Live object is responsible of getting stopping live stream source.\n    live object is responsible of recording the stream (timeshift or record feature)\n    \n    recording needs are abstracted via RecordingTaskRunner object.\n    \n    currently, only DVB stream from wyscan is supported\n    \n    '
	LIVE_COUNT = 0
	def __init__(self, id, external_dvb_manager, external_recorder_factory, ext_disk_space):
		self.id = id
		self.serviceid = 0
		self.deviceid = 0
		self.wyscan_recording_id = WYSCAN_RECORDING_ID_NULL
		self.source_uri = None
		self.dest_uri = None
		self.dest_rec_uri = None
		self.chunk_info = None
		self.has_macrovision = False
		self.recording_task_runner = RecordingTaskRunner(self, ext_disk_space)
		self.external_dvb_manager = external_dvb_manager
		self.external_recorder_factory = external_recorder_factory
		self.external_recorder = None
		self.bytes_per_sec = config.bytes_per_sec
		self.timeshift_folder = os.path.join(config.timeshift_base_folder_path, config.timeshift_live_name + '_' + str(self.id))
		if ext_disk_space:
			ext_disk_space.ReserveSpace(self.timeshift_folder, config.max_size_for_timeshift)
		return None

	def isRunning(self):
		return self.wyscan_recording_id != WYSCAN_RECORDING_ID_NULL

	def isRecording(self):
		return self.recording_task_runner.getTaskList() != []

	def prepareRecorder(self, service, device_to_use=0):
		self.resetRecorder()
		self.source_uri, self.dest_uri, self.dest_rec_uri = self._Live__generateSourceAndDestUris(service, device_to_use)
		self.external_recorder = self.external_recorder_factory.getNewExternalRecorder(self.dest_rec_uri)

	def zap(self, service, device_id, use_post_zap=False):
		return self.start(service, device_id, self.wyscan_recording_id, use_post_zap)

	def postZap(self):
		self.onTimeShiftStart()

	def start(self, service, device_to_use=0, service_to_stop=None, use_post_zap=False):
		if not self.external_recorder:
			self.source_uri, self.dest_uri, self.dest_rec_uri = self._Live__generateSourceAndDestUris(service, device_to_use)
			self.dest_uri = None
			self.dest_rec_uri = None
		result = self.external_dvb_manager.startService(service, device_to_use, self.source_uri, service_to_stop)
		if result['status'] != error.WYRECORD_SUCCESS:
			self.resetRecorder()
			self.source_uri = None
			return False
		self.serviceid = service
		self.deviceid = result['deviceid']
		self.wyscan_recording_id = result['wyscan_recording_id']
		if self.external_recorder:
			self.external_recorder.startRec(self.source_uri)
		else:
			log.critical('failed to build a recporder instance')
			return False
		if not use_post_zap:
			self.onTimeShiftStart()
		return True

	def stop(self):
		ret = True
		if self.wyscan_recording_id == WYSCAN_RECORDING_ID_NULL:
			log.error('Trying to stop a live not started')
			return False
		if self.isRecording():
			log.error('Trying to stop a live that is recording')
			return False
		log.debug('self.external_dvb_manager.stopService(self.wyscan_recording_id)')
		try:
			status = self.external_dvb_manager.stopService(self.wyscan_recording_id)
			if status != error.WYRECORD_SUCCESS:
				log.error('StopRecording(%d) FAILED (error %d) !' % (self.internal_recordingid, status))
				ret = False

	def getPriority(self):
		if self.recording_task_runner.getTaskList():
			if self.recording_task_runner.containsSchedule():
				return 1
			else:
				return 0
		else:
			return 3

	def resetRecorder(self):
		if self.external_recorder:
			self.external_recorder.stopRec()
			self.deleteRecorder(self.external_recorder)
		self.dest_uri = None
		self.dest_rec_uri = None
		self.external_recorder = None
		self.has_macrovision = False
		self.onTimeShiftStop()
		return None

	def getRecorderForPostReset(self):
		ret = self.external_recorder
		self.external_recorder = None
		return ret

	def deleteRecorder(self, recorder):
		self.external_recorder_factory.appendRecorderToDelete(recorder)

	def _Live__generateSourceAndDestUris(self, service_id, device_id):
		Live.LIVE_COUNT += 1
		extension = '%d_%d_%d' % (device_id, service_id, Live.LIVE_COUNT)
		unix_socket_path = os.path.join(config.unix_socket_folder_path, 'sock_' + extension)
		source_uri = URL_PREFIX_UNIX_SOCKET + unix_socket_path
		timeshift_folder = os.path.join(self.timeshift_folder, 'ts_' + extension)
		timeshift_folder = os.path.join(timeshift_folder, config.timeshift_chunk_file_name_format)
		dest_uri = URL_PREFIX_TIMESHIFT + timeshift_folder
		dest_rec_uri = URL_PREFIX_REC_TIMESHIFT + timeshift_folder
		return [source_uri, dest_uri, dest_rec_uri]

	def saveReadOffset(self, offset):
		if self.chunk_info:
			self.chunk_info.saveReadOffset(offset)

	def updateTimeshiftSize(self, timeshift_size):
		if not self.external_recorder:
			return False
		recording_size = self.getRecordingSize()
		total_size = timeshift_size + recording_size
		if abs(total_size - self.external_recorder.last_size) > config.size_error_before_allocation:
			log.info('updateTimeshiftSize timeshift_size=' + str(timeshift_size) + ' total=' + str(total_size))
			self.external_recorder.setMaxRecSize(total_size)
			return True
		return False

	def onTimeShiftStart(self):
		if not self.dest_uri:
			log.critical('no destination uri')
			return False
		if not self.dest_uri.startswith(URL_PREFIX_TIMESHIFT):
			log.critical('WYRECORD ERROR - onTimeShiftStart : no timeshift url ')
			return False
		self.chunk_info = ChunkInfo(UriChunkToPath(self.dest_uri))
		self.chunk_info.synchronyseStartTime(self.external_dvb_manager.GetCurrentUTCTime())
		return True

	def onTimeShiftStop(self):
		self.chunk_info = None
		return None

	def getRecordingSize(self):
		recording_size = 0
		if not self.chunk_info:
			return 0
		bytes_per_sec = self.chunk_info.getBytesPerSec()
		if not bytes_per_sec:
			bytes_per_sec = self.bytes_per_sec
		recording_size = (self.recording_task_runner.global_stop_time - self.recording_task_runner.global_start_time) * bytes_per_sec
		recording_size += 2 * config.size_error_before_allocation
		return recording_size

	def getUsedSpace(self):
		if not self.chunk_info:
			return 0
		else:
			return self.chunk_info.getChunkTotalSize()

	def _Live__get_current_rec(self):
		task_list = self.recording_task_runner.getTaskList()
		if task_list:
			return task_list[0]
		else:
			return None
		return None

	current_rec = property(fget=_Live__get_current_rec)
	def _Live__get_current_recordingid(self):
		task_list = self.recording_task_runner.getTaskList()
		if task_list:
			return task_list[0].id
		else:
			return 0

	current_recordingid = property(fget=_Live__get_current_recordingid)
	def IsRecording(self):
		return self.isRecording()

	def IsPlayingOnlive(self):
		return False



]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75e37ec>}
__doc__ = '\nLive class implementation\n'
LIVE_ID_NULL = 0
import os
import error
from config import *
from logger import log
from chunkinfo import ChunkInfo
from chunkinfo import UriChunkToPath
from peewee.analyse import Chrono
from recordingtaskrunner import RecordingTaskRunner
from externaldvbmanager import WYSCAN_RECORDING_ID_NULL
from callbacks import Callbacks
class Live(object):
	__doc__ = ' Live object is responsible of getting stopping live stream source.\n    live object is responsible of recording the stream (timeshift or record feature)\n    \n    recording needs are abstracted via RecordingTaskRunner object.\n    \n    currently, only DVB stream from wyscan is supported\n    \n    '
	LIVE_COUNT = 0
	def __init__(self, id, external_dvb_manager, external_recorder_factory, ext_disk_space):
		self.id = id
		self.serviceid = 0
		self.deviceid = 0
		self.wyscan_recording_id = WYSCAN_RECORDING_ID_NULL
		self.source_uri = None
		self.dest_uri = None
		self.dest_rec_uri = None
		self.chunk_info = None
		self.has_macrovision = False
		self.recording_task_runner = RecordingTaskRunner(self, ext_disk_space)
		self.external_dvb_manager = external_dvb_manager
		self.external_recorder_factory = external_recorder_factory
		self.external_recorder = None
		self.bytes_per_sec = config.bytes_per_sec
		self.timeshift_folder = os.path.join(config.timeshift_base_folder_path, config.timeshift_live_name + '_' + str(self.id))
		if ext_disk_space:
			ext_disk_space.ReserveSpace(self.timeshift_folder, config.max_size_for_timeshift)
		return None

	def isRunning(self):
		return self.wyscan_recording_id != WYSCAN_RECORDING_ID_NULL

	def isRecording(self):
		return self.recording_task_runner.getTaskList() != []

	def prepareRecorder(self, service, device_to_use=0):
		self.resetRecorder()
		self.source_uri, self.dest_uri, self.dest_rec_uri = self._Live__generateSourceAndDestUris(service, device_to_use)
		self.external_recorder = self.external_recorder_factory.getNewExternalRecorder(self.dest_rec_uri)

	def zap(self, service, device_id, use_post_zap=False):
		return self.start(service, device_id, self.wyscan_recording_id, use_post_zap)

	def postZap(self):
		self.onTimeShiftStart()

	def start(self, service, device_to_use=0, service_to_stop=None, use_post_zap=False):
		if not self.external_recorder:
			self.source_uri, self.dest_uri, self.dest_rec_uri = self._Live__generateSourceAndDestUris(service, device_to_use)
			self.dest_uri = None
			self.dest_rec_uri = None
		result = self.external_dvb_manager.startService(service, device_to_use, self.source_uri, service_to_stop)
		if result['status'] != error.WYRECORD_SUCCESS:
			self.resetRecorder()
			self.source_uri = None
			return False
		self.serviceid = service
		self.deviceid = result['deviceid']
		self.wyscan_recording_id = result['wyscan_recording_id']
		if self.external_recorder:
			self.external_recorder.startRec(self.source_uri)
		else:
			log.critical('failed to build a recporder instance')
			return False
		if not use_post_zap:
			self.onTimeShiftStart()
		return True

	def stop(self):
		ret = True
		if self.wyscan_recording_id == WYSCAN_RECORDING_ID_NULL:
			log.error('Trying to stop a live not started')
			return False
		if self.isRecording():
			log.error('Trying to stop a live that is recording')
			return False
		log.debug('self.external_dvb_manager.stopService(self.wyscan_recording_id)')
		try:
			status = self.external_dvb_manager.stopService(self.wyscan_recording_id)
			if status != error.WYRECORD_SUCCESS:
				log.error('StopRecording(%d) FAILED (error %d) !' % (self.internal_recordingid, status))
				ret = False

	def getPriority(self):
		if self.recording_task_runner.getTaskList():
			if self.recording_task_runner.containsSchedule():
				return 1
			else:
				return 0
		else:
			return 3

	def resetRecorder(self):
		if self.external_recorder:
			self.external_recorder.stopRec()
			self.deleteRecorder(self.external_recorder)
		self.dest_uri = None
		self.dest_rec_uri = None
		self.external_recorder = None
		self.has_macrovision = False
		self.onTimeShiftStop()
		return None

	def getRecorderForPostReset(self):
		ret = self.external_recorder
		self.external_recorder = None
		return ret

	def deleteRecorder(self, recorder):
		self.external_recorder_factory.appendRecorderToDelete(recorder)

	def _Live__generateSourceAndDestUris(self, service_id, device_id):
		Live.LIVE_COUNT += 1
		extension = '%d_%d_%d' % (device_id, service_id, Live.LIVE_COUNT)
		unix_socket_path = os.path.join(config.unix_socket_folder_path, 'sock_' + extension)
		source_uri = URL_PREFIX_UNIX_SOCKET + unix_socket_path
		timeshift_folder = os.path.join(self.timeshift_folder, 'ts_' + extension)
		timeshift_folder = os.path.join(timeshift_folder, config.timeshift_chunk_file_name_format)
		dest_uri = URL_PREFIX_TIMESHIFT + timeshift_folder
		dest_rec_uri = URL_PREFIX_REC_TIMESHIFT + timeshift_folder
		return [source_uri, dest_uri, dest_rec_uri]

	def saveReadOffset(self, offset):
		if self.chunk_info:
			self.chunk_info.saveReadOffset(offset)

	def updateTimeshiftSize(self, timeshift_size):
		if not self.external_recorder:
			return False
		recording_size = self.getRecordingSize()
		total_size = timeshift_size + recording_size
		if abs(total_size - self.external_recorder.last_size) > config.size_error_before_allocation:
			log.info('updateTimeshiftSize timeshift_size=' + str(timeshift_size) + ' total=' + str(total_size))
			self.external_recorder.setMaxRecSize(total_size)
			return True
		return False

	def onTimeShiftStart(self):
		if not self.dest_uri:
			log.critical('no destination uri')
			return False
		if not self.dest_uri.startswith(URL_PREFIX_TIMESHIFT):
			log.critical('WYRECORD ERROR - onTimeShiftStart : no timeshift url ')
			return False
		self.chunk_info = ChunkInfo(UriChunkToPath(self.dest_uri))
		self.chunk_info.synchronyseStartTime(self.external_dvb_manager.GetCurrentUTCTime())
		return True

	def onTimeShiftStop(self):
		self.chunk_info = None
		return None

	def getRecordingSize(self):
		recording_size = 0
		if not self.chunk_info:
			return 0
		bytes_per_sec = self.chunk_info.getBytesPerSec()
		if not bytes_per_sec:
			bytes_per_sec = self.bytes_per_sec
		recording_size = (self.recording_task_runner.global_stop_time - self.recording_task_runner.global_start_time) * bytes_per_sec
		recording_size += 2 * config.size_error_before_allocation
		return recording_size

	def getUsedSpace(self):
		if not self.chunk_info:
			return 0
		else:
			return self.chunk_info.getChunkTotalSize()

	def _Live__get_current_rec(self):
		task_list = self.recording_task_runner.getTaskList()
		if task_list:
			return task_list[0]
		else:
			return None
		return None

	current_rec = property(fget=_Live__get_current_rec)
	def _Live__get_current_recordingid(self):
		task_list = self.recording_task_runner.getTaskList()
		if task_list:
			return task_list[0].id
		else:
			return 0

	current_recordingid = property(fget=_Live__get_current_recordingid)
	def IsRecording(self):
		return self.isRecording()

	def IsPlayingOnlive(self):
		return False



