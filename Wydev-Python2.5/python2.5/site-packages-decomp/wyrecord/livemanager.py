# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 121
n 121(None)[]:
	i: 30(AL), 120()
	o: 

nname: 120
n 120(None)[]:
	i: 63(AF), 86()
	o: 121()

nname: 86
n 86(None)[for i in range(1, config.live_count_max + 1):
self.lives[i] = Live(i, external_dvb_manager, external_recorder_factory, ext_disk_space)
]:
	i: 63(for)
	o: 120()

nname: 63
n 63(None)[]:
	i: 30(loop)
	o: 86(for), 120(AF)

nname: 30
n 30(None)[self.external_dvb_manager = external_dvb_manager
self.last_timeshift_size = config.max_size_for_timeshift
self.lives = {}
]:
	i: 3(), 23(), 29(AE)
	o: 63(loop), 121(AL)

nname: 23
n 23(None)[]:
	i: 0(except)
	o: 30()

nname: 3
n 3(None)[os.makedirs(config.unix_socket_folder_path)
]:
	i: 0(try)
	o: 30()

nname: 0
n 0(None)[]:
	i: 
	o: 3(try), 23(except)

nname: 120
n 120(None)[]:
	i: 63()
	o: 

nname: 63
n 63(None)[for i in range(1, config.live_count_max + 1):
	self.lives[i] = Live(i, external_dvb_manager, external_recorder_factory, ext_disk_space)
]:
	i: 23(loop)
	o: 120()

nname: 23
n 23(None)[except:
	pass
self.external_dvb_manager = external_dvb_manager
self.last_timeshift_size = config.max_size_for_timeshift
self.lives = {}
]:
	i: 0()
	o: 63(loop)

nname: 0
n 0(None)[try:
	os.makedirs(config.unix_socket_folder_path)
]:
	i: 
	o: 23()

nname: 63
n 63(None)[for i in range(1, config.live_count_max + 1):
	self.lives[i] = Live(i, external_dvb_manager, external_recorder_factory, ext_disk_space)
]:
	i: 0(loop)
	o: 

nname: 0
n 0(None)[try:
	os.makedirs(config.unix_socket_folder_path)
except:
	pass
self.external_dvb_manager = external_dvb_manager
self.last_timeshift_size = config.max_size_for_timeshift
self.lives = {}
]:
	i: 
	o: 63(loop)

nname: 0
n 0(None)[try:
	os.makedirs(config.unix_socket_folder_path)
except:
	pass
self.external_dvb_manager = external_dvb_manager
self.last_timeshift_size = config.max_size_for_timeshift
self.lives = {}
for i in range(1, config.live_count_max + 1):
	self.lives[i] = Live(i, external_dvb_manager, external_recorder_factory, ext_disk_space)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76d43ec>}
nname: 44
n 44(None)[return self.lives[nLiveID]
]:
	i: 18(), 43()
	o: 

nname: 43
n 43(None)[]:
	i: 0(t)
	o: 44()

nname: 18
n 18(None)[log.error('Bad Live ID %d !' % nLiveID)
return None
]:
	i: 0(f)
	o: 44()

nname: 0
n 0(self.lives.has_key(nLiveID))[]:
	i: 
	o: 18(f), 43(t)

nname: 0
n 0(None)[if not self.lives.has_key(nLiveID):
	log.error('Bad Live ID %d !' % nLiveID)
	return None
return self.lives[nLiveID]
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76cdecc>}
nname: 63
n 63(None)[return None
]:
	i: 0(AL), 62()
	o: 

nname: 62
n 62(None)[]:
	i: 3(AF), 58()
	o: 63()

nname: 58
n 58(None)[]:
	i: 19&34(f), 50()
	o: 62()

nname: 50
n 50(None)[return live
continue
]:
	i: 19&34(t)
	o: 58()

nname: 19&34
n 19&34(live.isRunning() and live.serviceid == nServiceID)[for live in self.lives.itervalues():
]:
	i: 3(for)
	o: 50(t), 58(f)

nname: 3
n 3(None)[]:
	i: 0(loop)
	o: 19&34(for), 62(AF)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 63(AL)

nname: 63
n 63(None)[return None
]:
	i: 0(AL), 3(AF), 19&34(f)
	o: 

nname: 19&34
n 19&34(None)[for live in self.lives.itervalues():
if live.isRunning() and live.serviceid == nServiceID:
	return live
	continue
]:
	i: 3(for)
	o: 63()

nname: 3
n 3(None)[]:
	i: 0(loop)
	o: 19&34(for), 63(AF)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 63(AL)

nname: 19&34
n 19&34(None)[for live in self.lives.itervalues():
	if live.isRunning() and live.serviceid == nServiceID:
		return live
		continue
return None
]:
	i: 0(for)
	o: 

nname: 0
n 0(None)[]:
	i: 
	o: 19&34(for)

nname: 0
n 0(None)[for live in self.lives.itervalues():
	if live.isRunning() and live.serviceid == nServiceID:
		return live
		continue
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76cdf8c>}
nname: 182
n 182(None)[return {'status': error.WYRECORD_SUCCESS, 'live_id': live.id}
]:
	i: 161(), 181()
	o: 

nname: 181
n 181(None)[]:
	i: 127(t)
	o: 182()

nname: 161
n 161(None)[return {'status': error.WYRECORD_CAN_NOT_START_LIVE}
]:
	i: 127(f)
	o: 182()

nname: 127
n 127(live.start(nServiceID, device_to_use))[live.prepareRecorder(nServiceID, device_to_use)
]:
	i: 54(AL), 97()
	o: 161(f), 181(t)

nname: 97
n 97(None)[log.warning('No available live ! => Stop an existing live before !')
return {'status': error.WYRECORD_LIVE_ALREADY_USED}
]:
	i: 57(AF), 93()
	o: 127()

nname: 93
n 93(None)[]:
	i: 73(t), 88()
	o: 97()

nname: 88
n 88(None)[break
continue
]:
	i: 73(f)
	o: 93()

nname: 73
n 73(live.isRunning())[for live in self.lives.values():
]:
	i: 57(for)
	o: 88(f), 93(t)

nname: 57
n 57(None)[]:
	i: 54(loop)
	o: 73(for), 97(AF)

nname: 54
n 54(None)[]:
	i: 21(), 53()
	o: 57(loop), 127(AL)

nname: 53
n 53(None)[]:
	i: 0(f)
	o: 54()

nname: 21
n 21(None)[return {'status': error.WYRECORD_SUCCESS, 'live_id': live.id}
]:
	i: 0(t)
	o: 54()

nname: 0
n 0(live)[live = self._GetLiveFromServiceID(nServiceID)
]:
	i: 
	o: 21(t), 53(f)

nname: 127
n 127(None)[live.prepareRecorder(nServiceID, device_to_use)
if not live.start(nServiceID, device_to_use):
	return {'status': error.WYRECORD_CAN_NOT_START_LIVE}
return {'status': error.WYRECORD_SUCCESS, 'live_id': live.id}
]:
	i: 0(AL), 97()
	o: 

nname: 97
n 97(None)[log.warning('No available live ! => Stop an existing live before !')
return {'status': error.WYRECORD_LIVE_ALREADY_USED}
]:
	i: 57(AF), 73()
	o: 127()

nname: 73
n 73(None)[for live in self.lives.values():
if not live.isRunning():
	break
	continue
]:
	i: 57(for)
	o: 97()

nname: 57
n 57(None)[]:
	i: 0(loop)
	o: 73(for), 97(AF)

nname: 0
n 0(None)[live = self._GetLiveFromServiceID(nServiceID)
if live:
	return {'status': error.WYRECORD_SUCCESS, 'live_id': live.id}
]:
	i: 
	o: 57(loop), 127(AL)

self.nodes: {0: <unpyclib.structure.node instance at 0xb76d42ec>, 97: <unpyclib.structure.node instance at 0xb76d45cc>, 73: <unpyclib.structure.node instance at 0xb76d47cc>, 57: <unpyclib.structure.node instance at 0xb76d4cac>, 127: <unpyclib.structure.node instance at 0xb76d4e0c>}
nname: 181
n 181(None)[return {'status': error.WYRECORD_SUCCESS}
]:
	i: 160(), 180()
	o: 

nname: 180
n 180(None)[]:
	i: 148(t)
	o: 181()

nname: 160
n 160(None)[return {'status': error.WYRECORD_CAN_NOT_STOP_LIVE}
]:
	i: 148(f)
	o: 181()

nname: 148
n 148(live.stop())[]:
	i: 127(), 147()
	o: 160(f), 180(t)

nname: 147
n 147(None)[]:
	i: 115(f)
	o: 148()

nname: 127
n 127(None)[return {'status': error.WYRECORD_LIVE_IS_RECORDING}
]:
	i: 115(t)
	o: 148()

nname: 115
n 115(live.isRecording())[]:
	i: 77(), 114()
	o: 127(t), 147(f)

nname: 114
n 114(None)[]:
	i: 65(t)
	o: 115()

nname: 77
n 77(None)[log.error('Live ID %d not started !' % nLiveID)
return {'status': error.WYRECORD_LIVE_NOT_STARTED}
]:
	i: 65(f)
	o: 115()

nname: 65
n 65(live.isRunning())[]:
	i: 27(), 64()
	o: 77(f), 114(t)

nname: 64
n 64(None)[]:
	i: 0(f)
	o: 65()

nname: 27
n 27(None)[log.error('Bad Live ID %d !' % nLiveID)
return {'status': error.WYRECORD_BAD_LIVE_ID}
]:
	i: 0(t)
	o: 65()

nname: 0
n 0(live == None)[live = self._GetLiveFromLiveID(nLiveID)
]:
	i: 
	o: 27(t), 64(f)

nname: 181
n 181(None)[return {'status': error.WYRECORD_SUCCESS}
]:
	i: 115()
	o: 

nname: 115
n 115(None)[if live.isRecording():
	return {'status': error.WYRECORD_LIVE_IS_RECORDING}
if not live.stop():
	return {'status': error.WYRECORD_CAN_NOT_STOP_LIVE}
]:
	i: 0()
	o: 181()

nname: 0
n 0(None)[live = self._GetLiveFromLiveID(nLiveID)
if live == None:
	log.error('Bad Live ID %d !' % nLiveID)
	return {'status': error.WYRECORD_BAD_LIVE_ID}
if not live.isRunning():
	log.error('Live ID %d not started !' % nLiveID)
	return {'status': error.WYRECORD_LIVE_NOT_STARTED}
]:
	i: 
	o: 115()

nname: 181
n 181(None)[return {'status': error.WYRECORD_SUCCESS}
]:
	i: 0()
	o: 

nname: 0
n 0(None)[live = self._GetLiveFromLiveID(nLiveID)
if live == None:
	log.error('Bad Live ID %d !' % nLiveID)
	return {'status': error.WYRECORD_BAD_LIVE_ID}
if not live.isRunning():
	log.error('Live ID %d not started !' % nLiveID)
	return {'status': error.WYRECORD_LIVE_NOT_STARTED}
if live.isRecording():
	return {'status': error.WYRECORD_LIVE_IS_RECORDING}
if not live.stop():
	return {'status': error.WYRECORD_CAN_NOT_STOP_LIVE}
]:
	i: 
	o: 181()

nname: 0
n 0(None)[live = self._GetLiveFromLiveID(nLiveID)
if live == None:
	log.error('Bad Live ID %d !' % nLiveID)
	return {'status': error.WYRECORD_BAD_LIVE_ID}
if not live.isRunning():
	log.error('Live ID %d not started !' % nLiveID)
	return {'status': error.WYRECORD_LIVE_NOT_STARTED}
if live.isRecording():
	return {'status': error.WYRECORD_LIVE_IS_RECORDING}
if not live.stop():
	return {'status': error.WYRECORD_CAN_NOT_STOP_LIVE}
return {'status': error.WYRECORD_SUCCESS}
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76dac6c>}
nname: 62
n 62(None)[return running_live_list
]:
	i: 0(AL), 61()
	o: 

nname: 61
n 61(None)[]:
	i: 9(AF), 57()
	o: 62()

nname: 57
n 57(None)[]:
	i: 25(f), 40()
	o: 61()

nname: 40
n 40(None)[running_live_list.append(live)
continue
]:
	i: 25(t)
	o: 57()

nname: 25
n 25(live.isRunning())[for live in self.lives.itervalues():
]:
	i: 9(for)
	o: 40(t), 57(f)

nname: 9
n 9(None)[]:
	i: 0(loop)
	o: 25(for), 61(AF)

nname: 0
n 0(None)[running_live_list = []
]:
	i: 
	o: 9(loop), 62(AL)

nname: 62
n 62(None)[return running_live_list
]:
	i: 0(AL), 9(AF), 25()
	o: 

nname: 25
n 25(None)[for live in self.lives.itervalues():
if live.isRunning():
	running_live_list.append(live)
	continue
]:
	i: 9(for)
	o: 62()

nname: 9
n 9(None)[]:
	i: 0(loop)
	o: 25(for), 62(AF)

nname: 0
n 0(None)[running_live_list = []
]:
	i: 
	o: 9(loop), 62(AL)

nname: 25
n 25(None)[for live in self.lives.itervalues():
	if live.isRunning():
		running_live_list.append(live)
		continue
return running_live_list
]:
	i: 0(for)
	o: 

nname: 0
n 0(None)[running_live_list = []
]:
	i: 
	o: 25(for)

nname: 0
n 0(None)[running_live_list = []
for live in self.lives.itervalues():
	if live.isRunning():
		running_live_list.append(live)
		continue
return running_live_list
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76cdf8c>}
nname: 75
n 75(None)[return recording_live_list
]:
	i: 0(AL), 74()
	o: 

nname: 74
n 74(None)[]:
	i: 9(AF), 70()
	o: 75()

nname: 70
n 70(None)[]:
	i: 25&40(f), 53()
	o: 74()

nname: 53
n 53(None)[recording_live_list.append(live)
continue
]:
	i: 25&40(t)
	o: 70()

nname: 25&40
n 25&40(live.isRunning() and live.isRecording())[for live in self.lives.itervalues():
]:
	i: 9(for)
	o: 53(t), 70(f)

nname: 9
n 9(None)[]:
	i: 0(loop)
	o: 25&40(for), 74(AF)

nname: 0
n 0(None)[recording_live_list = []
]:
	i: 
	o: 9(loop), 75(AL)

nname: 75
n 75(None)[return recording_live_list
]:
	i: 0(AL), 9(AF), 25&40(f)
	o: 

nname: 25&40
n 25&40(None)[for live in self.lives.itervalues():
if live.isRunning() and live.isRecording():
	recording_live_list.append(live)
	continue
]:
	i: 9(for)
	o: 75()

nname: 9
n 9(None)[]:
	i: 0(loop)
	o: 25&40(for), 75(AF)

nname: 0
n 0(None)[recording_live_list = []
]:
	i: 
	o: 9(loop), 75(AL)

nname: 25&40
n 25&40(None)[for live in self.lives.itervalues():
	if live.isRunning() and live.isRecording():
		recording_live_list.append(live)
		continue
return recording_live_list
]:
	i: 0(for)
	o: 

nname: 0
n 0(None)[recording_live_list = []
]:
	i: 
	o: 25&40(for)

nname: 0
n 0(None)[recording_live_list = []
for live in self.lives.itervalues():
	if live.isRunning() and live.isRecording():
		recording_live_list.append(live)
		continue
return recording_live_list
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76cdeac>}
nname: 0
n 0(None)[log.debug('AsynchronousUpdateLiveTime called')
WyrecordOnShotTimer(self.cbUpdateLiveTime, delta).start(0)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76cdf6c>}
nname: 56
n 56(None)[]:
	i: 0(AL), 55()
	o: 

nname: 55
n 55(None)[]:
	i: 15(AF), 51()
	o: 56()

nname: 51
n 51(None)[]:
	i: 22(t), 37()
	o: 55()

nname: 37
n 37(None)[live.stop()
continue
]:
	i: 22(f)
	o: 51()

nname: 22
n 22(live.isRecording())[for live in running_live_list:
]:
	i: 15(for)
	o: 37(f), 51(t)

nname: 15
n 15(None)[]:
	i: 0(loop)
	o: 22(for), 55(AF)

nname: 0
n 0(None)[running_live_list = self.GetRunningLiveList()
]:
	i: 
	o: 15(loop), 56(AL)

nname: 56
n 56(None)[]:
	i: 0(AL), 15(AF), 22()
	o: 

nname: 22
n 22(None)[for live in running_live_list:
if not live.isRecording():
	live.stop()
	continue
]:
	i: 15(for)
	o: 56()

nname: 15
n 15(None)[]:
	i: 0(loop)
	o: 22(for), 56(AF)

nname: 0
n 0(None)[running_live_list = self.GetRunningLiveList()
]:
	i: 
	o: 15(loop), 56(AL)

nname: 22
n 22(None)[for live in running_live_list:
	if not live.isRecording():
		live.stop()
		continue
]:
	i: 0(for)
	o: 

nname: 0
n 0(None)[running_live_list = self.GetRunningLiveList()
]:
	i: 
	o: 22(for)

nname: 0
n 0(None)[running_live_list = self.GetRunningLiveList()
for live in running_live_list:
	if not live.isRecording():
		live.stop()
		continue
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76cddac>}
nname: 71
n 71(None)[return []
]:
	i: 3(), 33(), 60(), 69(AE)
	o: 

nname: 69
n 69(None)[]:
	i: 49(f)
	o: 71(AE)

nname: 60
n 60(None)[#, e
]:
	i: 49(t)
	o: 71()

nname: 49
n 49(<dummy_ex3> EXC_MATCH NoDeviceAvailableForServiceErrors)[]:
	i: 23(f)
	o: 60(t), 69(f)

nname: 33
n 33(None)[#, e
return e.conflict_live_list
]:
	i: 23(t)
	o: 71()

nname: 23
n 23(<dummy_ex3> EXC_MATCH LiveInConflictError)[]:
	i: 0(except)
	o: 33(t), 49(f)

nname: 3
n 3(None)[self.GetDeviceForNewService(service_id, live_to_ignore)
]:
	i: 0(try)
	o: 71()

nname: 0
n 0(None)[]:
	i: 
	o: 3(try), 23(except)

nname: 23
n 23(None)[except LiveInConflictError, e:
	return e.conflict_live_list
except:
	except NoDeviceAvailableForServiceErrors, e:
return []
]:
	i: 0()
	o: 

nname: 0
n 0(None)[try:
	self.GetDeviceForNewService(service_id, live_to_ignore)
]:
	i: 
	o: 23()

nname: 0
n 0(None)[try:
	self.GetDeviceForNewService(service_id, live_to_ignore)
except LiveInConflictError, e:
	return e.conflict_live_list
except:
	except NoDeviceAvailableForServiceErrors, e:
return []
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76dadec>}
nname: 166
n 166(None)[return 0
]:
	i: 36(), 57(), 116(JA), 149(JA), 157(), 165()
	o: 

nname: 165
n 165(None)[]:
	i: 65&78(f)
	o: 166()

nname: 157
n 157(None)[return 0
]:
	i: 124(f)
	o: 166()

nname: 149
n 149(None)[return 1
]:
	i: 124(t)
	o: 166(JA)

nname: 124
n 124(live1.recording_task_runner.global_start_time > live2.recording_task_runner.global_start_time)[]:
	i: 91(f)
	o: 149(t), 157(f)

nname: 116
n 116(None)[return -1
]:
	i: 91(t)
	o: 166(JA)

nname: 91
n 91(live1.recording_task_runner.global_start_time < live2.recording_task_runner.global_start_time)[]:
	i: 65&78(t)
	o: 116(t), 124(f)

nname: 65&78
n 65&78(live1.isRecording() and live2.isRecording())[]:
	i: 44(f)
	o: 91(t), 165(f)

nname: 57
n 57(None)[return 1
]:
	i: 44(t)
	o: 166()

nname: 44
n 44(p1 > p2)[]:
	i: 0(f)
	o: 57(t), 65&78(f)

nname: 36
n 36(None)[return -1
]:
	i: 0(t)
	o: 166()

nname: 0
n 0(p1 < p2)[p1 = live1.getPriority()
p2 = live2.getPriority()
]:
	i: 
	o: 36(t), 44(f)

nname: 0
n 0(None)[p1 = live1.getPriority()
p2 = live2.getPriority()
if p1 < p2:
	return -1
else:
	if p1 > p2:
		return 1
	else:
		if live1.isRecording() and live2.isRecording():
			if live1.recording_task_runner.global_start_time < live2.recording_task_runner.global_start_time:
				return -1
			else:
				if live1.recording_task_runner.global_start_time > live2.recording_task_runner.global_start_time:
					return 1
				else:
					return 0
return 0
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76d476c>}
nname: 522
n 522(None)[del _[3]
for invalid_live_list in invalid:
return [invalid_live_list, dummy_rec_list]
]:
	i: 447(AF), 506()
	o: 

nname: 506
n 506(None)[for rec in invalid:
]:
	i: 447(for)
	o: 522()

nname: 447
n 447(None)[]:
	i: 429(), 446()
	o: 506(for), 522(AF)

nname: 446
n 446(None)[]:
	i: 423(f)
	o: 447()

nname: 429
n 429(None)[dummy_rec_list.append(new_rec)
]:
	i: 423(t)
	o: 447()

nname: 423
n 423(real)[]:
	i: 199(AL), 422()
	o: 429(t), 446(f)

nname: 422
n 422(None)[]:
	i: 202(AF), 418()
	o: 423()

nname: 418
n 418(None)[]:
	i: 224&245(f), 333()
	o: 422()

nname: 333
n 333(None)[dummy_rec_list.append(rec)
continue
]:
	i: 265(), 327()
	o: 418()

nname: 327
n 327(None)[del _[2]
for devices_id in self.external_dvb_manager.GetPlayableServiceDevices(live.serviceid):
]:
	i: 281(AF), 311()
	o: 333()

nname: 311
n 311(None)[for device in self.external_dvb_manager.GetPlayableServiceDevices(live.serviceid):
]:
	i: 281(for)
	o: 327()

nname: 281
n 281(None)[]:
	i: 258(f)
	o: 311(for), 327(AF)

nname: 265
n 265(None)[]:
	i: 258(t)
	o: 333()

nname: 258
n 258(real)[]:
	i: 224&245(t)
	o: 265(t), 281(f)

nname: 224&245
n 224&245(live.isRunning() and live != live_to_ignore)[]:
	i: 202(for)
	o: 258(t), 418(f)

nname: 202
n 202(None)[]:
	i: 199(loop)
	o: 224&245(for), 422(AF)

nname: 199
n 199(None)[]:
	i: 181(), 198()
	o: 202(loop), 423(AL)

nname: 198
n 198(None)[]:
	i: 106(t)
	o: 199()

nname: 181
n 181(None)[dummy_rec_list.append(new_rec)
]:
	i: 106(f)
	o: 199()

nname: 106
n 106(real)[]:
	i: 89(), 105()
	o: 181(f), 198(t)

nname: 105
n 105(None)[]:
	i: 42(f)
	o: 106()

nname: 89
n 89(None)[raise NoDeviceAvailableForServiceErrors(service_id)
]:
	i: 42(t)
	o: 106()

nname: 42
n 42(len(devices) == 0)[del _[1]
for devices in self.external_dvb_manager.GetPlayableServiceDevices(service_id):
log.debug('devices id for new service =' + str(devices))
]:
	i: 0(AF), 26()
	o: 89(t), 105(f)

nname: 26
n 26(None)[for device in self.external_dvb_manager.GetPlayableServiceDevices(service_id):
]:
	i: 0(for)
	o: 42()

nname: 0
n 0(None)[]:
	i: 
	o: 26(for), 42(AF)

nname: 522
n 522(None)[del _[3]
for invalid_live_list in invalid:
return [invalid_live_list, dummy_rec_list]
]:
	i: 423(AF), 506()
	o: 

nname: 506
n 506(None)[for rec in invalid:
]:
	i: 423(for)
	o: 522()

nname: 423
n 423(None)[if real:
	dummy_rec_list.append(new_rec)
]:
	i: 199(AL), 202(AF), 224&245(f), 333()
	o: 506(for), 522(AF)

nname: 333
n 333(None)[dummy_rec_list.append(rec)
continue
]:
	i: 327(), 258(t)
	o: 423()

nname: 327
n 327(None)[del _[2]
for devices_id in self.external_dvb_manager.GetPlayableServiceDevices(live.serviceid):
]:
	i: 281(AF), 311()
	o: 333()

nname: 311
n 311(None)[for device in self.external_dvb_manager.GetPlayableServiceDevices(live.serviceid):
]:
	i: 281(for)
	o: 327()

nname: 281
n 281(None)[]:
	i: 258(f)
	o: 311(for), 327(AF)

nname: 333
n 333(None)[dummy_rec_list.append(rec)
continue
]:
	i: 327(), 258(t)
	o: 423()

nname: 258
n 258(real)[]:
	i: 224&245(t)
	o: 333(t), 281(f)

nname: 224&245
n 224&245(live.isRunning() and live != live_to_ignore)[]:
	i: 202(for)
	o: 258(t), 423(f)

nname: 202
n 202(None)[]:
	i: 199(loop)
	o: 224&245(for), 423(AF)

nname: 199
n 199(None)[]:
	i: 42()
	o: 202(loop), 423(AL)

nname: 42
n 42(None)[del _[1]
for devices in self.external_dvb_manager.GetPlayableServiceDevices(service_id):
log.debug('devices id for new service =' + str(devices))
if len(devices) == 0:
	raise NoDeviceAvailableForServiceErrors(service_id)
if not real:
	dummy_rec_list.append(new_rec)
]:
	i: 0(AF), 26()
	o: 199()

nname: 26
n 26(None)[for device in self.external_dvb_manager.GetPlayableServiceDevices(service_id):
]:
	i: 0(for)
	o: 42()

nname: 0
n 0(None)[]:
	i: 
	o: 26(for), 42(AF)

nname: 522
n 522(None)[del _[3]
for invalid_live_list in invalid:
return [invalid_live_list, dummy_rec_list]
]:
	i: 423(AF), 506()
	o: 

nname: 506
n 506(None)[for rec in invalid:
]:
	i: 423(for)
	o: 522()

nname: 423
n 423(None)[if real:
	dummy_rec_list.append(new_rec)
]:
	i: 42(AL), 202(AF), 224&245(f), 333()
	o: 506(for), 522(AF)

nname: 333
n 333(None)[dummy_rec_list.append(rec)
continue
]:
	i: 327(), 258(t)
	o: 423()

nname: 327
n 327(None)[del _[2]
for devices_id in self.external_dvb_manager.GetPlayableServiceDevices(live.serviceid):
]:
	i: 281(AF), 311()
	o: 333()

nname: 311
n 311(None)[for device in self.external_dvb_manager.GetPlayableServiceDevices(live.serviceid):
]:
	i: 281(for)
	o: 327()

nname: 281
n 281(None)[]:
	i: 258(f)
	o: 311(for), 327(AF)

nname: 333
n 333(None)[dummy_rec_list.append(rec)
continue
]:
	i: 327(), 258(t)
	o: 423()

nname: 258
n 258(real)[]:
	i: 224&245(t)
	o: 333(t), 281(f)

nname: 224&245
n 224&245(live.isRunning() and live != live_to_ignore)[]:
	i: 202(for)
	o: 258(t), 423(f)

nname: 202
n 202(None)[]:
	i: 42(loop)
	o: 224&245(for), 423(AF)

nname: 42
n 42(None)[del _[1]
for devices in self.external_dvb_manager.GetPlayableServiceDevices(service_id):
log.debug('devices id for new service =' + str(devices))
if len(devices) == 0:
	raise NoDeviceAvailableForServiceErrors(service_id)
if not real:
	dummy_rec_list.append(new_rec)
]:
	i: 0(AF), 26()
	o: 202(loop), 423(AL)

nname: 26
n 26(None)[for device in self.external_dvb_manager.GetPlayableServiceDevices(service_id):
]:
	i: 0(for)
	o: 42()

nname: 0
n 0(None)[]:
	i: 
	o: 26(for), 42(AF)

self.nodes: {0: <unpyclib.structure.node instance at 0xb76d90cc>, 258: <unpyclib.structure.node instance at 0xb76d924c>, 522: <unpyclib.structure.node instance at 0xb76d96cc>, 281: <unpyclib.structure.node instance at 0xb76d91cc>, 26: <unpyclib.structure.node instance at 0xb76d93cc>, 423: <unpyclib.structure.node instance at 0xb76da16c>, 42: <unpyclib.structure.node instance at 0xb76d9e4c>, 327: <unpyclib.structure.node instance at 0xb76d914c>, 311: <unpyclib.structure.node instance at 0xb76d98ec>, 202: <unpyclib.structure.node instance at 0xb76d988c>, 333: <unpyclib.structure.node instance at 0xb76d99cc>, '224&245': <unpyclib.structure.node instance at 0xb76d904c>, 506: <unpyclib.structure.node instance at 0xb76d95cc>}
nname: 6
n 6(None)[__doc__ = ' api used to manages live and timeshift.\n    \n    deprecated for many of its method. (see livecontroller)\n    '
def __init__(self, external_dvb_manager, external_recorder_factory, ext_disk_space):
	try:
		os.makedirs(config.unix_socket_folder_path)
	except:
		pass
	self.external_dvb_manager = external_dvb_manager
	self.last_timeshift_size = config.max_size_for_timeshift
	self.lives = {}
	for i in range(1, config.live_count_max + 1):
		self.lives[i] = Live(i, external_dvb_manager, external_recorder_factory, ext_disk_space)

def _GetLiveFromLiveID(self, nLiveID):
	if not self.lives.has_key(nLiveID):
		log.error('Bad Live ID %d !' % nLiveID)
		return None
	return self.lives[nLiveID]

def _GetLiveFromServiceID(self, nServiceID):
	for live in self.lives.itervalues():
		if live.isRunning() and live.serviceid == nServiceID:
			return live
			continue
	return None

def StartLive(self, nServiceID, device_to_use=0):
	live = self._GetLiveFromServiceID(nServiceID)
	if live:
		return {'status': error.WYRECORD_SUCCESS, 'live_id': live.id}

def StopLive(self, nLiveID):
	live = self._GetLiveFromLiveID(nLiveID)
	if live == None:
		log.error('Bad Live ID %d !' % nLiveID)
		return {'status': error.WYRECORD_BAD_LIVE_ID}
	if not live.isRunning():
		log.error('Live ID %d not started !' % nLiveID)
		return {'status': error.WYRECORD_LIVE_NOT_STARTED}
	if live.isRecording():
		return {'status': error.WYRECORD_LIVE_IS_RECORDING}
	if not live.stop():
		return {'status': error.WYRECORD_CAN_NOT_STOP_LIVE}
	return {'status': error.WYRECORD_SUCCESS}

def GetRunningLiveList(self):
	running_live_list = []
	for live in self.lives.itervalues():
		if live.isRunning():
			running_live_list.append(live)
			continue
	return running_live_list

def GetRecordingLiveList(self):
	recording_live_list = []
	for live in self.lives.itervalues():
		if live.isRunning() and live.isRecording():
			recording_live_list.append(live)
			continue
	return recording_live_list

cbUpdateLiveTime = GlobalLock()()
def AsynchronousUpdateLiveTime(self, delta):
	log.debug('AsynchronousUpdateLiveTime called')
	WyrecordOnShotTimer(self.cbUpdateLiveTime, delta).start(0)

def StopAllLiveNotRecording(self):
	running_live_list = self.GetRunningLiveList()
	for live in running_live_list:
		if not live.isRecording():
			live.stop()
			continue

def GetLivesInConflictWithService(self, service_id, live_to_ignore=None):
	try:
		self.GetDeviceForNewService(service_id, live_to_ignore)
	except LiveInConflictError, e:
		return e.conflict_live_list
	except:
		except NoDeviceAvailableForServiceErrors, e:
	return []

def CompareLive(self, live1, live2):
	p1 = live1.getPriority()
	p2 = live2.getPriority()
	if p1 < p2:
		return -1
	else:
		if p1 > p2:
			return 1
		else:
			if live1.isRecording() and live2.isRecording():
				if live1.recording_task_runner.global_start_time < live2.recording_task_runner.global_start_time:
					return -1
				else:
					if live1.recording_task_runner.global_start_time > live2.recording_task_runner.global_start_time:
						return 1
					else:
						return 0
	return 0

GetDeviceForNewService = Chrono(['wyrecord'])()
def _LiveManager__getInvalidLiveListForService(self, service_id, real=True, live_to_ignore=None):
	pass

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb76cd62c>}
nname: 0
n 0(None)[__doc__ = '\nLiveManager class implementation\n'
from logger import log
from recording import VirtualRecording
from conflictmanager import ChronologicalElement
from config import *
from exceptions import *
from live import Live
import error
import os
from tools import WyrecordOnShotTimer
from peewee.analyse import Chrono
from globallock import GlobalLock
class LiveManager(object):
	__doc__ = ' api used to manages live and timeshift.\n    \n    deprecated for many of its method. (see livecontroller)\n    '
	def __init__(self, external_dvb_manager, external_recorder_factory, ext_disk_space):
		try:
			os.makedirs(config.unix_socket_folder_path)
		except:
			pass
		self.external_dvb_manager = external_dvb_manager
		self.last_timeshift_size = config.max_size_for_timeshift
		self.lives = {}
		for i in range(1, config.live_count_max + 1):
			self.lives[i] = Live(i, external_dvb_manager, external_recorder_factory, ext_disk_space)

	def _GetLiveFromLiveID(self, nLiveID):
		if not self.lives.has_key(nLiveID):
			log.error('Bad Live ID %d !' % nLiveID)
			return None
		return self.lives[nLiveID]

	def _GetLiveFromServiceID(self, nServiceID):
		for live in self.lives.itervalues():
			if live.isRunning() and live.serviceid == nServiceID:
				return live
				continue
		return None

	def StartLive(self, nServiceID, device_to_use=0):
		live = self._GetLiveFromServiceID(nServiceID)
		if live:
			return {'status': error.WYRECORD_SUCCESS, 'live_id': live.id}

	def StopLive(self, nLiveID):
		live = self._GetLiveFromLiveID(nLiveID)
		if live == None:
			log.error('Bad Live ID %d !' % nLiveID)
			return {'status': error.WYRECORD_BAD_LIVE_ID}
		if not live.isRunning():
			log.error('Live ID %d not started !' % nLiveID)
			return {'status': error.WYRECORD_LIVE_NOT_STARTED}
		if live.isRecording():
			return {'status': error.WYRECORD_LIVE_IS_RECORDING}
		if not live.stop():
			return {'status': error.WYRECORD_CAN_NOT_STOP_LIVE}
		return {'status': error.WYRECORD_SUCCESS}

	def GetRunningLiveList(self):
		running_live_list = []
		for live in self.lives.itervalues():
			if live.isRunning():
				running_live_list.append(live)
				continue
		return running_live_list

	def GetRecordingLiveList(self):
		recording_live_list = []
		for live in self.lives.itervalues():
			if live.isRunning() and live.isRecording():
				recording_live_list.append(live)
				continue
		return recording_live_list

	cbUpdateLiveTime = GlobalLock()()
	def AsynchronousUpdateLiveTime(self, delta):
		log.debug('AsynchronousUpdateLiveTime called')
		WyrecordOnShotTimer(self.cbUpdateLiveTime, delta).start(0)

	def StopAllLiveNotRecording(self):
		running_live_list = self.GetRunningLiveList()
		for live in running_live_list:
			if not live.isRecording():
				live.stop()
				continue

	def GetLivesInConflictWithService(self, service_id, live_to_ignore=None):
		try:
			self.GetDeviceForNewService(service_id, live_to_ignore)
		except LiveInConflictError, e:
			return e.conflict_live_list
		except:
			except NoDeviceAvailableForServiceErrors, e:
		return []

	def CompareLive(self, live1, live2):
		p1 = live1.getPriority()
		p2 = live2.getPriority()
		if p1 < p2:
			return -1
		else:
			if p1 > p2:
				return 1
			else:
				if live1.isRecording() and live2.isRecording():
					if live1.recording_task_runner.global_start_time < live2.recording_task_runner.global_start_time:
						return -1
					else:
						if live1.recording_task_runner.global_start_time > live2.recording_task_runner.global_start_time:
							return 1
						else:
							return 0
		return 0

	GetDeviceForNewService = Chrono(['wyrecord'])()
	def _LiveManager__getInvalidLiveListForService(self, service_id, real=True, live_to_ignore=None):
		pass



]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76c1cac>}
__doc__ = '\nLiveManager class implementation\n'
from logger import log
from recording import VirtualRecording
from conflictmanager import ChronologicalElement
from config import *
from exceptions import *
from live import Live
import error
import os
from tools import WyrecordOnShotTimer
from peewee.analyse import Chrono
from globallock import GlobalLock
class LiveManager(object):
	__doc__ = ' api used to manages live and timeshift.\n    \n    deprecated for many of its method. (see livecontroller)\n    '
	def __init__(self, external_dvb_manager, external_recorder_factory, ext_disk_space):
		try:
			os.makedirs(config.unix_socket_folder_path)
		except:
			pass
		self.external_dvb_manager = external_dvb_manager
		self.last_timeshift_size = config.max_size_for_timeshift
		self.lives = {}
		for i in range(1, config.live_count_max + 1):
			self.lives[i] = Live(i, external_dvb_manager, external_recorder_factory, ext_disk_space)

	def _GetLiveFromLiveID(self, nLiveID):
		if not self.lives.has_key(nLiveID):
			log.error('Bad Live ID %d !' % nLiveID)
			return None
		return self.lives[nLiveID]

	def _GetLiveFromServiceID(self, nServiceID):
		for live in self.lives.itervalues():
			if live.isRunning() and live.serviceid == nServiceID:
				return live
				continue
		return None

	def StartLive(self, nServiceID, device_to_use=0):
		live = self._GetLiveFromServiceID(nServiceID)
		if live:
			return {'status': error.WYRECORD_SUCCESS, 'live_id': live.id}

	def StopLive(self, nLiveID):
		live = self._GetLiveFromLiveID(nLiveID)
		if live == None:
			log.error('Bad Live ID %d !' % nLiveID)
			return {'status': error.WYRECORD_BAD_LIVE_ID}
		if not live.isRunning():
			log.error('Live ID %d not started !' % nLiveID)
			return {'status': error.WYRECORD_LIVE_NOT_STARTED}
		if live.isRecording():
			return {'status': error.WYRECORD_LIVE_IS_RECORDING}
		if not live.stop():
			return {'status': error.WYRECORD_CAN_NOT_STOP_LIVE}
		return {'status': error.WYRECORD_SUCCESS}

	def GetRunningLiveList(self):
		running_live_list = []
		for live in self.lives.itervalues():
			if live.isRunning():
				running_live_list.append(live)
				continue
		return running_live_list

	def GetRecordingLiveList(self):
		recording_live_list = []
		for live in self.lives.itervalues():
			if live.isRunning() and live.isRecording():
				recording_live_list.append(live)
				continue
		return recording_live_list

	cbUpdateLiveTime = GlobalLock()()
	def AsynchronousUpdateLiveTime(self, delta):
		log.debug('AsynchronousUpdateLiveTime called')
		WyrecordOnShotTimer(self.cbUpdateLiveTime, delta).start(0)

	def StopAllLiveNotRecording(self):
		running_live_list = self.GetRunningLiveList()
		for live in running_live_list:
			if not live.isRecording():
				live.stop()
				continue

	def GetLivesInConflictWithService(self, service_id, live_to_ignore=None):
		try:
			self.GetDeviceForNewService(service_id, live_to_ignore)
		except LiveInConflictError, e:
			return e.conflict_live_list
		except:
			except NoDeviceAvailableForServiceErrors, e:
		return []

	def CompareLive(self, live1, live2):
		p1 = live1.getPriority()
		p2 = live2.getPriority()
		if p1 < p2:
			return -1
		else:
			if p1 > p2:
				return 1
			else:
				if live1.isRecording() and live2.isRecording():
					if live1.recording_task_runner.global_start_time < live2.recording_task_runner.global_start_time:
						return -1
					else:
						if live1.recording_task_runner.global_start_time > live2.recording_task_runner.global_start_time:
							return 1
						else:
							return 0
		return 0

	GetDeviceForNewService = Chrono(['wyrecord'])()
	def _LiveManager__getInvalidLiveListForService(self, service_id, real=True, live_to_ignore=None):
		pass



