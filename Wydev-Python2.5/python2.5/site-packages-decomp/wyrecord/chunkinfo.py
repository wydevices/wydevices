# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 0
n 0(None)[return os.path.split(uri[len(URL_PREFIX_TIMESHIFT):])[0]
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb771ee8c>}
nname: 0
n 0(None)[]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb77244ac>}
nname: 0
n 0(None)[self_chunk_info.checkDataValidity()
f_result = f(self_chunk_info, *args, **kwds)
return f_result
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7724bac>}
nname: 0
n 0(None)[def manage_wyrecord_lock(self_chunk_info, *args, **args):
	self_chunk_info.checkDataValidity()
	f_result = f(self_chunk_info, *args, **kwds)
	return f_result

return manage_wyrecord_lock
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb77246ec>}
nname: 6
n 6(None)[__doc__ = ' Decorator which \n    '
def __init__(self):
	pass

def __call__(self, f):
	def manage_wyrecord_lock(self_chunk_info, *args, **args):
		self_chunk_info.checkDataValidity()
		f_result = f(self_chunk_info, *args, **kwds)
		return f_result

	return manage_wyrecord_lock

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb771efcc>}
nname: 0
n 0(None)[self.timeshift_folder = timeshift_folder
self.chunk_file_name_format = chunk_file_name_format
self.first_time = 0
self.offset_at_first_time = 0
self._ChunkInfo__validity = 0
self._ChunkInfo__chunk_file_list = None
self.offset_to_play = 0
self._ChunkInfo__deleted_bytes = 0
self._ChunkInfo__live_offset = 0
self._ChunkInfo__bytes_per_sec = config.bytes_per_sec
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb772cd4c>}
nname: 0
n 0(None)[self.first_time -= delta_t
self._ChunkInfo__validity = 0
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb772c78c>}
nname: 0
n 0(None)[self.offset_to_play = offset
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb772c5ac>}
nname: 92
n 92(None)[]:
	i: 74(), 91()
	o: 

nname: 91
n 91(None)[]:
	i: 0&31&51(f)
	o: 92()

nname: 74
n 74(None)[self._ChunkInfo__computeData(current_time)
]:
	i: 0&31&51(t)
	o: 92()

nname: 0&31&51
n 0&31&51(current_time - self._ChunkInfo__validity > 10 or current_time - self._ChunkInfo__validity > 1 and self._ChunkInfo__validity - self.first_time < 15)[current_time = time.time()
]:
	i: 
	o: 74(t), 91(f)

nname: 0&31&51
n 0&31&51(None)[current_time = time.time()
if current_time - self._ChunkInfo__validity > 10 or current_time - self._ChunkInfo__validity > 1 and self._ChunkInfo__validity - self.first_time < 15:
	self._ChunkInfo__computeData(current_time)
]:
	i: 
	o: 

self.nodes: {'0&31&51': <unpyclib.structure.node instance at 0xb772caac>}
nname: 0
n 0(None)[self.offset_at_first_time = 0
self.first_time = wyrecord_start_time
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb772c62c>}
nname: 92
n 92(None)[self._ChunkInfo__validity = current_time
fisrt_chunk_file = os.path.split(chunk_file_list[0])[1]
index = int(fisrt_chunk_file[len(config.timeshift_chunk_file_base_name):-len(config.timeshift_chunk_file_extention)])
self._ChunkInfo__deleted_bytes = index * config.timeshift_chunk_max_size
tmp_offset = self._ChunkInfo__deleted_bytes
tmp_offset += config.timeshift_chunk_max_size * (len(chunk_file_list) - 1)
tmp_offset += os.path.getsize(chunk_file_list[-1])
self._ChunkInfo__live_offset = tmp_offset
last_file_time = current_time
first_file_time = self.first_time
self._ChunkInfo__bytes_per_sec = (self._ChunkInfo__live_offset - self.offset_at_first_time) / (last_file_time - first_file_time)
]:
	i: 40(), 91()
	o: 

nname: 91
n 91(None)[]:
	i: 0(t)
	o: 92()

nname: 40
n 40(None)[self._ChunkInfo__deleted_bytes = 0
self._ChunkInfo__live_offset = 0
self._ChunkInfo__bytes_per_sec = config.bytes_per_sec
log.debug('__computeData: NO chunk file')
]:
	i: 0(f)
	o: 92()

nname: 0
n 0(chunk_file_list)[log.debug('__computeData')
chunk_file_list = self._getSortedFilelist()
self._ChunkInfo__chunk_file_list = chunk_file_list
]:
	i: 
	o: 40(f), 91(t)

nname: 0
n 0(None)[log.debug('__computeData')
chunk_file_list = self._getSortedFilelist()
self._ChunkInfo__chunk_file_list = chunk_file_list
if not chunk_file_list:
	self._ChunkInfo__deleted_bytes = 0
	self._ChunkInfo__live_offset = 0
	self._ChunkInfo__bytes_per_sec = config.bytes_per_sec
	log.debug('__computeData: NO chunk file')
self._ChunkInfo__validity = current_time
fisrt_chunk_file = os.path.split(chunk_file_list[0])[1]
index = int(fisrt_chunk_file[len(config.timeshift_chunk_file_base_name):-len(config.timeshift_chunk_file_extention)])
self._ChunkInfo__deleted_bytes = index * config.timeshift_chunk_max_size
tmp_offset = self._ChunkInfo__deleted_bytes
tmp_offset += config.timeshift_chunk_max_size * (len(chunk_file_list) - 1)
tmp_offset += os.path.getsize(chunk_file_list[-1])
self._ChunkInfo__live_offset = tmp_offset
last_file_time = current_time
first_file_time = self.first_time
self._ChunkInfo__bytes_per_sec = (self._ChunkInfo__live_offset - self.offset_at_first_time) / (last_file_time - first_file_time)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb773132c>}
nname: 0
n 0(None)[return self._ChunkInfo__live_offset + (time.time() - self._ChunkInfo__validity) * self._ChunkInfo__bytes_per_sec
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb772c64c>}
nname: 0
n 0(None)[return self.getTimeFromOffset(self._ChunkInfo__deleted_bytes)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb772c64c>}
nname: 0
n 0(None)[return time.time()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb772c8ac>}
nname: 0
n 0(None)[chunk_file_list = glob.glob(os.path.join(self.timeshift_folder, self.chunk_file_name_format) + '*')
chunk_file_list.sort()
return chunk_file_list
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb772ca2c>}
nname: 129
n 129(None)[return f
]:
	i: 0(AL), 87()
	o: 

nname: 87
n 87(None)[log.error('no chunk found tmp= ' + str(tmp_offset) + ' offset' + str(offset))
return ''
]:
	i: 31(AF), 83()
	o: 129()

nname: 83
n 83(None)[]:
	i: 41(f), 78()
	o: 87()

nname: 78
n 78(None)[break
continue
]:
	i: 41(t)
	o: 83()

nname: 41
n 41(tmp_offset >= offset)[for f in self._ChunkInfo__chunk_file_list:
tmp_offset += os.path.getsize(f)
]:
	i: 31(for)
	o: 78(t), 83(f)

nname: 31
n 31(None)[]:
	i: 0(loop)
	o: 41(for), 87(AF)

nname: 0
n 0(None)[self._ChunkInfo__computeData(time.time())
tmp_offset = self._ChunkInfo__deleted_bytes
]:
	i: 
	o: 31(loop), 129(AL)

nname: 129
n 129(None)[return f
]:
	i: 0(AL), 87()
	o: 

nname: 87
n 87(None)[log.error('no chunk found tmp= ' + str(tmp_offset) + ' offset' + str(offset))
return ''
]:
	i: 31(AF), 41()
	o: 129()

nname: 41
n 41(None)[for f in self._ChunkInfo__chunk_file_list:
tmp_offset += os.path.getsize(f)
if tmp_offset >= offset:
	break
	continue
]:
	i: 31(for)
	o: 87()

nname: 31
n 31(None)[]:
	i: 0(loop)
	o: 41(for), 87(AF)

nname: 0
n 0(None)[self._ChunkInfo__computeData(time.time())
tmp_offset = self._ChunkInfo__deleted_bytes
]:
	i: 
	o: 31(loop), 129(AL)

nname: 129
n 129(None)[return f
]:
	i: 41()
	o: 

nname: 41
n 41(None)[for f in self._ChunkInfo__chunk_file_list:
	tmp_offset += os.path.getsize(f)
	if tmp_offset >= offset:
		break
		continue
else:
	log.error('no chunk found tmp= ' + str(tmp_offset) + ' offset' + str(offset))
	return ''
]:
	i: 0(for)
	o: 129()

nname: 0
n 0(None)[self._ChunkInfo__computeData(time.time())
tmp_offset = self._ChunkInfo__deleted_bytes
]:
	i: 
	o: 41(for)

nname: 129
n 129(None)[return f
]:
	i: 0()
	o: 

nname: 0
n 0(None)[self._ChunkInfo__computeData(time.time())
tmp_offset = self._ChunkInfo__deleted_bytes
for f in self._ChunkInfo__chunk_file_list:
	tmp_offset += os.path.getsize(f)
	if tmp_offset >= offset:
		break
		continue
else:
	log.error('no chunk found tmp= ' + str(tmp_offset) + ' offset' + str(offset))
	return ''
]:
	i: 
	o: 129()

nname: 0
n 0(None)[self._ChunkInfo__computeData(time.time())
tmp_offset = self._ChunkInfo__deleted_bytes
for f in self._ChunkInfo__chunk_file_list:
	tmp_offset += os.path.getsize(f)
	if tmp_offset >= offset:
		break
		continue
else:
	log.error('no chunk found tmp= ' + str(tmp_offset) + ' offset' + str(offset))
	return ''
return f
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb772cccc>}
nname: 6
n 6(None)[__doc__ = ' analyse chuncks into a directory.\n    give a chunk file from an offset (global)\n    give a time from an offset\n    \n    '
def __init__(self, timeshift_folder, chunk_file_name_format=config.timeshift_chunk_file_base_name):
	self.timeshift_folder = timeshift_folder
	self.chunk_file_name_format = chunk_file_name_format
	self.first_time = 0
	self.offset_at_first_time = 0
	self._ChunkInfo__validity = 0
	self._ChunkInfo__chunk_file_list = None
	self.offset_to_play = 0
	self._ChunkInfo__deleted_bytes = 0
	self._ChunkInfo__live_offset = 0
	self._ChunkInfo__bytes_per_sec = config.bytes_per_sec
	return None

def refTimeUpdated(self, delta_t):
	self.first_time -= delta_t
	self._ChunkInfo__validity = 0

def saveReadOffset(self, offset):
	self.offset_to_play = offset

def checkDataValidity(self):
	current_time = time.time()
	if current_time - self._ChunkInfo__validity > 10 or current_time - self._ChunkInfo__validity > 1 and self._ChunkInfo__validity - self.first_time < 15:
		self._ChunkInfo__computeData(current_time)

getReadOffset = ValidityCheck()()
def synchronyseStartTime(self, wyrecord_start_time):
	self.offset_at_first_time = 0
	self.first_time = wyrecord_start_time

def _ChunkInfo__computeData(self, current_time):
	log.debug('__computeData')
	chunk_file_list = self._getSortedFilelist()
	self._ChunkInfo__chunk_file_list = chunk_file_list
	if not chunk_file_list:
		self._ChunkInfo__deleted_bytes = 0
		self._ChunkInfo__live_offset = 0
		self._ChunkInfo__bytes_per_sec = config.bytes_per_sec
		log.debug('__computeData: NO chunk file')
	self._ChunkInfo__validity = current_time
	fisrt_chunk_file = os.path.split(chunk_file_list[0])[1]
	index = int(fisrt_chunk_file[len(config.timeshift_chunk_file_base_name):-len(config.timeshift_chunk_file_extention)])
	self._ChunkInfo__deleted_bytes = index * config.timeshift_chunk_max_size
	tmp_offset = self._ChunkInfo__deleted_bytes
	tmp_offset += config.timeshift_chunk_max_size * (len(chunk_file_list) - 1)
	tmp_offset += os.path.getsize(chunk_file_list[-1])
	self._ChunkInfo__live_offset = tmp_offset
	last_file_time = current_time
	first_file_time = self.first_time
	self._ChunkInfo__bytes_per_sec = (self._ChunkInfo__live_offset - self.offset_at_first_time) / (last_file_time - first_file_time)

def _ChunkInfo__getLiveOffset(self):
	return self._ChunkInfo__live_offset + (time.time() - self._ChunkInfo__validity) * self._ChunkInfo__bytes_per_sec

getBytesPerSec = ValidityCheck()()
getChunkTotalSize = ValidityCheck()()
def getMinimumTimeshiftTime(self):
	return self.getTimeFromOffset(self._ChunkInfo__deleted_bytes)

def getMaximumTimeshiftTime(self):
	return time.time()

getTimeFromOffset = ValidityCheck()()
def _getSortedFilelist(self):
	chunk_file_list = glob.glob(os.path.join(self.timeshift_folder, self.chunk_file_name_format) + '*')
	chunk_file_list.sort()
	return chunk_file_list

def getChunkFromOffset(self, offset):
	self._ChunkInfo__computeData(time.time())
	tmp_offset = self._ChunkInfo__deleted_bytes
	for f in self._ChunkInfo__chunk_file_list:
		tmp_offset += os.path.getsize(f)
		if tmp_offset >= offset:
			break
			continue
	else:
		log.error('no chunk found tmp= ' + str(tmp_offset) + ' offset' + str(offset))
		return ''
	return f

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb7724b6c>}
nname: 0
n 0(None)[import os
import glob
import time
from config import *
from logger import log
def UriChunkToPath(uri):
	return os.path.split(uri[len(URL_PREFIX_TIMESHIFT):])[0]

class ValidityCheck(object):
	__doc__ = ' Decorator which \n    '
	def __init__(self):
		pass

	def __call__(self, f):
		def manage_wyrecord_lock(self_chunk_info, *args, **args):
			self_chunk_info.checkDataValidity()
			f_result = f(self_chunk_info, *args, **kwds)
			return f_result

		return manage_wyrecord_lock



class ChunkInfo(object):
	__doc__ = ' analyse chuncks into a directory.\n    give a chunk file from an offset (global)\n    give a time from an offset\n    \n    '
	def __init__(self, timeshift_folder, chunk_file_name_format=config.timeshift_chunk_file_base_name):
		self.timeshift_folder = timeshift_folder
		self.chunk_file_name_format = chunk_file_name_format
		self.first_time = 0
		self.offset_at_first_time = 0
		self._ChunkInfo__validity = 0
		self._ChunkInfo__chunk_file_list = None
		self.offset_to_play = 0
		self._ChunkInfo__deleted_bytes = 0
		self._ChunkInfo__live_offset = 0
		self._ChunkInfo__bytes_per_sec = config.bytes_per_sec
		return None

	def refTimeUpdated(self, delta_t):
		self.first_time -= delta_t
		self._ChunkInfo__validity = 0

	def saveReadOffset(self, offset):
		self.offset_to_play = offset

	def checkDataValidity(self):
		current_time = time.time()
		if current_time - self._ChunkInfo__validity > 10 or current_time - self._ChunkInfo__validity > 1 and self._ChunkInfo__validity - self.first_time < 15:
			self._ChunkInfo__computeData(current_time)

	getReadOffset = ValidityCheck()()
	def synchronyseStartTime(self, wyrecord_start_time):
		self.offset_at_first_time = 0
		self.first_time = wyrecord_start_time

	def _ChunkInfo__computeData(self, current_time):
		log.debug('__computeData')
		chunk_file_list = self._getSortedFilelist()
		self._ChunkInfo__chunk_file_list = chunk_file_list
		if not chunk_file_list:
			self._ChunkInfo__deleted_bytes = 0
			self._ChunkInfo__live_offset = 0
			self._ChunkInfo__bytes_per_sec = config.bytes_per_sec
			log.debug('__computeData: NO chunk file')
		self._ChunkInfo__validity = current_time
		fisrt_chunk_file = os.path.split(chunk_file_list[0])[1]
		index = int(fisrt_chunk_file[len(config.timeshift_chunk_file_base_name):-len(config.timeshift_chunk_file_extention)])
		self._ChunkInfo__deleted_bytes = index * config.timeshift_chunk_max_size
		tmp_offset = self._ChunkInfo__deleted_bytes
		tmp_offset += config.timeshift_chunk_max_size * (len(chunk_file_list) - 1)
		tmp_offset += os.path.getsize(chunk_file_list[-1])
		self._ChunkInfo__live_offset = tmp_offset
		last_file_time = current_time
		first_file_time = self.first_time
		self._ChunkInfo__bytes_per_sec = (self._ChunkInfo__live_offset - self.offset_at_first_time) / (last_file_time - first_file_time)

	def _ChunkInfo__getLiveOffset(self):
		return self._ChunkInfo__live_offset + (time.time() - self._ChunkInfo__validity) * self._ChunkInfo__bytes_per_sec

	getBytesPerSec = ValidityCheck()()
	getChunkTotalSize = ValidityCheck()()
	def getMinimumTimeshiftTime(self):
		return self.getTimeFromOffset(self._ChunkInfo__deleted_bytes)

	def getMaximumTimeshiftTime(self):
		return time.time()

	getTimeFromOffset = ValidityCheck()()
	def _getSortedFilelist(self):
		chunk_file_list = glob.glob(os.path.join(self.timeshift_folder, self.chunk_file_name_format) + '*')
		chunk_file_list.sort()
		return chunk_file_list

	def getChunkFromOffset(self, offset):
		self._ChunkInfo__computeData(time.time())
		tmp_offset = self._ChunkInfo__deleted_bytes
		for f in self._ChunkInfo__chunk_file_list:
			tmp_offset += os.path.getsize(f)
			if tmp_offset >= offset:
				break
				continue
		else:
			log.error('no chunk found tmp= ' + str(tmp_offset) + ' offset' + str(offset))
			return ''
		return f



]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb771ea4c>}
import os
import glob
import time
from config import *
from logger import log
def UriChunkToPath(uri):
	return os.path.split(uri[len(URL_PREFIX_TIMESHIFT):])[0]

class ValidityCheck(object):
	__doc__ = ' Decorator which \n    '
	def __init__(self):
		pass

	def __call__(self, f):
		def manage_wyrecord_lock(self_chunk_info, *args, **args):
			self_chunk_info.checkDataValidity()
			f_result = f(self_chunk_info, *args, **kwds)
			return f_result

		return manage_wyrecord_lock



class ChunkInfo(object):
	__doc__ = ' analyse chuncks into a directory.\n    give a chunk file from an offset (global)\n    give a time from an offset\n    \n    '
	def __init__(self, timeshift_folder, chunk_file_name_format=config.timeshift_chunk_file_base_name):
		self.timeshift_folder = timeshift_folder
		self.chunk_file_name_format = chunk_file_name_format
		self.first_time = 0
		self.offset_at_first_time = 0
		self._ChunkInfo__validity = 0
		self._ChunkInfo__chunk_file_list = None
		self.offset_to_play = 0
		self._ChunkInfo__deleted_bytes = 0
		self._ChunkInfo__live_offset = 0
		self._ChunkInfo__bytes_per_sec = config.bytes_per_sec
		return None

	def refTimeUpdated(self, delta_t):
		self.first_time -= delta_t
		self._ChunkInfo__validity = 0

	def saveReadOffset(self, offset):
		self.offset_to_play = offset

	def checkDataValidity(self):
		current_time = time.time()
		if current_time - self._ChunkInfo__validity > 10 or current_time - self._ChunkInfo__validity > 1 and self._ChunkInfo__validity - self.first_time < 15:
			self._ChunkInfo__computeData(current_time)

	getReadOffset = ValidityCheck()()
	def synchronyseStartTime(self, wyrecord_start_time):
		self.offset_at_first_time = 0
		self.first_time = wyrecord_start_time

	def _ChunkInfo__computeData(self, current_time):
		log.debug('__computeData')
		chunk_file_list = self._getSortedFilelist()
		self._ChunkInfo__chunk_file_list = chunk_file_list
		if not chunk_file_list:
			self._ChunkInfo__deleted_bytes = 0
			self._ChunkInfo__live_offset = 0
			self._ChunkInfo__bytes_per_sec = config.bytes_per_sec
			log.debug('__computeData: NO chunk file')
		self._ChunkInfo__validity = current_time
		fisrt_chunk_file = os.path.split(chunk_file_list[0])[1]
		index = int(fisrt_chunk_file[len(config.timeshift_chunk_file_base_name):-len(config.timeshift_chunk_file_extention)])
		self._ChunkInfo__deleted_bytes = index * config.timeshift_chunk_max_size
		tmp_offset = self._ChunkInfo__deleted_bytes
		tmp_offset += config.timeshift_chunk_max_size * (len(chunk_file_list) - 1)
		tmp_offset += os.path.getsize(chunk_file_list[-1])
		self._ChunkInfo__live_offset = tmp_offset
		last_file_time = current_time
		first_file_time = self.first_time
		self._ChunkInfo__bytes_per_sec = (self._ChunkInfo__live_offset - self.offset_at_first_time) / (last_file_time - first_file_time)

	def _ChunkInfo__getLiveOffset(self):
		return self._ChunkInfo__live_offset + (time.time() - self._ChunkInfo__validity) * self._ChunkInfo__bytes_per_sec

	getBytesPerSec = ValidityCheck()()
	getChunkTotalSize = ValidityCheck()()
	def getMinimumTimeshiftTime(self):
		return self.getTimeFromOffset(self._ChunkInfo__deleted_bytes)

	def getMaximumTimeshiftTime(self):
		return time.time()

	getTimeFromOffset = ValidityCheck()()
	def _getSortedFilelist(self):
		chunk_file_list = glob.glob(os.path.join(self.timeshift_folder, self.chunk_file_name_format) + '*')
		chunk_file_list.sort()
		return chunk_file_list

	def getChunkFromOffset(self, offset):
		self._ChunkInfo__computeData(time.time())
		tmp_offset = self._ChunkInfo__deleted_bytes
		for f in self._ChunkInfo__chunk_file_list:
			tmp_offset += os.path.getsize(f)
			if tmp_offset >= offset:
				break
				continue
		else:
			log.error('no chunk found tmp= ' + str(tmp_offset) + ' offset' + str(offset))
			return ''
		return f



