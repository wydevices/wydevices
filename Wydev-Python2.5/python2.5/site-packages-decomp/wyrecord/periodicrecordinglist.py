# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 0
n 0(None)[self._periodicRecordings = {}
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb762ac4c>}
nname: 78
n 78(None)[return rec_id
]:
	i: 64(), 77()
	o: 

nname: 77
n 77(None)[]:
	i: 0(f)
	o: 78()

nname: 64
n 64(None)[del _[1]
]:
	i: 27(AF), 51()
	o: 78()

nname: 51
n 51(None)[for recording in self._periodicRecordings:
]:
	i: 27(for)
	o: 64()

nname: 27
n 27(None)[]:
	i: 0(t)
	o: 51(for), 64(AF)

nname: 0
n 0(len(self._periodicRecordings) != 0)[rec_id = 1
]:
	i: 
	o: 27(t), 77(f)

nname: 78
n 78(None)[return rec_id
]:
	i: 64(), 0(f)
	o: 

nname: 64
n 64(None)[del _[1]
]:
	i: 27(AF), 51()
	o: 78()

nname: 51
n 51(None)[for recording in self._periodicRecordings:
]:
	i: 27(for)
	o: 64()

nname: 27
n 27(None)[]:
	i: 0(t)
	o: 51(for), 64(AF)

nname: 0
n 0(len(self._periodicRecordings) != 0)[rec_id = 1
]:
	i: 
	o: 27(t), 78(f)

self.nodes: {0: <unpyclib.structure.node instance at 0xb76304ec>, 64: <unpyclib.structure.node instance at 0xb763022c>, 78: <unpyclib.structure.node instance at 0xb763032c>, 51: <unpyclib.structure.node instance at 0xb76301ac>, 27: <unpyclib.structure.node instance at 0xb763012c>}
nname: 0
n 0(None)[new_rule_id = self._computeIdentifier()
rule.id = new_rule_id
self._periodicRecordings[new_rule_id] = rule
return new_rule_id
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb762af2c>}
nname: 248
n 248(None)[return time_list
]:
	i: 225(), 239(), 246(AE)
	o: 

nname: 246
n 246(None)[]:
	i: 229(f)
	o: 248(AE)

nname: 239
n 239(None)[]:
	i: 229(t)
	o: 248()

nname: 229
n 229(<dummy_ex3> EXC_MATCH PeriodicSchedulingException)[]:
	i: 101(except)
	o: 239(t), 246(f)

nname: 225
n 225(None)[]:
	i: 152(AL), 223()
	o: 248()

nname: 223
n 223(None)[]:
	i: 155(f), 207()
	o: 225()

nname: 207
n 207(None)[time_list.append(t_ref)
]:
	i: 201(), 206()
	o: 223()

nname: 206
n 206(None)[]:
	i: 161(f)
	o: 207()

nname: 201
n 201(None)[break
]:
	i: 161(t)
	o: 207()

nname: 161
n 161(t_ref > stopTime)[t_ref = rule.GetNextTime(t_min, t_ref, True)
t_min = t_ref
]:
	i: 155(t)
	o: 201(t), 206(f)

nname: 155
n 155(True)[]:
	i: 152(loop)
	o: 161(t), 223(f)

nname: 152
n 152(None)[]:
	i: 135(), 145()
	o: 155(loop), 225(AL)

nname: 145
n 145(None)[t_min = startTime
]:
	i: 123(f)
	o: 152()

nname: 135
n 135(None)[t_min = minStartTime
]:
	i: 123(t)
	o: 152()

nname: 123
n 123(minStartTime)[t_ref = startTime
]:
	i: 101(try)
	o: 135(t), 145(f)

nname: 101
n 101(None)[rule = self._periodicRecordings[id]
time_list = []
]:
	i: 92(), 100()
	o: 123(try), 229(except)

nname: 100
n 100(None)[]:
	i: 0(f)
	o: 101()

nname: 92
n 92(None)[return []
]:
	i: 0(t)
	o: 101()

nname: 0
n 0(id not in self._periodicRecordings)[log.debug('id ' + str(id) + ' startTime ' + str(startTime) + ' stopTime ' + str(stopTime))
log.debug('self._periodicRecordings ' + str(self._periodicRecordings))
]:
	i: 
	o: 92(t), 100(f)

nname: 248
n 248(None)[return time_list
]:
	i: 229(), 152(AL), 155(f), 161()
	o: 

nname: 229
n 229(None)[except PeriodicSchedulingException:
	pass
]:
	i: 123()
	o: 248()

nname: 161
n 161(None)[t_ref = rule.GetNextTime(t_min, t_ref, True)
t_min = t_ref
if t_ref > stopTime:
	break
time_list.append(t_ref)
]:
	i: 155(t)
	o: 248()

nname: 155
n 155(True)[]:
	i: 152(loop)
	o: 161(t), 248(f)

nname: 152
n 152(None)[]:
	i: 123()
	o: 155(loop), 248(AL)

nname: 123
n 123(None)[try:
	t_ref = startTime
	if minStartTime:
		t_min = minStartTime
	else:
		t_min = startTime
]:
	i: 0(try)
	o: 152(), 229()

nname: 0
n 0(None)[log.debug('id ' + str(id) + ' startTime ' + str(startTime) + ' stopTime ' + str(stopTime))
log.debug('self._periodicRecordings ' + str(self._periodicRecordings))
if id not in self._periodicRecordings:
	return []
rule = self._periodicRecordings[id]
time_list = []
]:
	i: 
	o: 123(try)

nname: 248
n 248(None)[return time_list
]:
	i: 229(), 161()
	o: 

nname: 229
n 229(None)[except PeriodicSchedulingException:
	pass
]:
	i: 0()
	o: 248()

nname: 161
n 161(None)[	t_ref = rule.GetNextTime(t_min, t_ref, True)
	t_min = t_ref
	if t_ref > stopTime:
		break
	time_list.append(t_ref)
]:
	i: 152(t)
	o: 248()

nname: 152
n 152(True)[while True:
]:
	i: 0()
	o: 161(t)

nname: 0
n 0(None)[log.debug('id ' + str(id) + ' startTime ' + str(startTime) + ' stopTime ' + str(stopTime))
log.debug('self._periodicRecordings ' + str(self._periodicRecordings))
if id not in self._periodicRecordings:
	return []
rule = self._periodicRecordings[id]
time_list = []
try:
	t_ref = startTime
	if minStartTime:
		t_min = minStartTime
	else:
		t_min = startTime
]:
	i: 
	o: 152(), 229()

nname: 248
n 248(None)[return time_list
]:
	i: 229(), 152()
	o: 

nname: 229
n 229(None)[except PeriodicSchedulingException:
	pass
]:
	i: 0()
	o: 248()

nname: 152
n 152(None)[while True:
	t_ref = rule.GetNextTime(t_min, t_ref, True)
	t_min = t_ref
	if t_ref > stopTime:
		break
	time_list.append(t_ref)
]:
	i: 0()
	o: 248()

nname: 0
n 0(None)[log.debug('id ' + str(id) + ' startTime ' + str(startTime) + ' stopTime ' + str(stopTime))
log.debug('self._periodicRecordings ' + str(self._periodicRecordings))
if id not in self._periodicRecordings:
	return []
rule = self._periodicRecordings[id]
time_list = []
try:
	t_ref = startTime
	if minStartTime:
		t_min = minStartTime
	else:
		t_min = startTime
]:
	i: 
	o: 152(), 229()

self.nodes: {0: <unpyclib.structure.node instance at 0xb7630fcc>, 229: <unpyclib.structure.node instance at 0xb7630f0c>, 152: <unpyclib.structure.node instance at 0xb7630e6c>, 248: <unpyclib.structure.node instance at 0xb76354cc>}
nname: 153
n 153(None)[return True
]:
	i: 43(AL), 152()
	o: 

nname: 152
n 152(None)[]:
	i: 59(AF), 148()
	o: 153()

nname: 148
n 148(None)[]:
	i: 66(f), 103()
	o: 152()

nname: 103
n 103(None)[rule_id = int(node_rule.attrib['id'])
rule.id = rule_id
self._periodicRecordings[rule_id] = rule
continue
]:
	i: 66(t)
	o: 148()

nname: 66
n 66(rule.LoadFromXML(node_rule))[for node_rule in nodes_rule:
rule = GetPeriodicSchedulingInstanceFactory(node_rule.attrib['type'])
]:
	i: 59(for)
	o: 103(t), 148(f)

nname: 59
n 59(None)[]:
	i: 43(loop)
	o: 66(for), 152(AF)

nname: 43
n 43(None)[self._periodicRecordings.clear()
]:
	i: 21(), 42()
	o: 59(loop), 153(AL)

nname: 42
n 42(None)[]:
	i: 0(t)
	o: 43()

nname: 21
n 21(None)[log.warning('wyrecord error: no node rule found')
return False
]:
	i: 0(f)
	o: 43()

nname: 0
n 0(nodes_rule)[nodes_rule = oXMLNode.getiterator('rule')
]:
	i: 
	o: 21(f), 42(t)

nname: 153
n 153(None)[return True
]:
	i: 0(AL), 59(AF), 66()
	o: 

nname: 66
n 66(None)[for node_rule in nodes_rule:
rule = GetPeriodicSchedulingInstanceFactory(node_rule.attrib['type'])
if rule.LoadFromXML(node_rule):
	rule_id = int(node_rule.attrib['id'])
	rule.id = rule_id
	self._periodicRecordings[rule_id] = rule
	continue
]:
	i: 59(for)
	o: 153()

nname: 59
n 59(None)[]:
	i: 0(loop)
	o: 66(for), 153(AF)

nname: 0
n 0(None)[nodes_rule = oXMLNode.getiterator('rule')
if not nodes_rule:
	log.warning('wyrecord error: no node rule found')
	return False
self._periodicRecordings.clear()
]:
	i: 
	o: 59(loop), 153(AL)

self.nodes: {0: <unpyclib.structure.node instance at 0xb763050c>, 66: <unpyclib.structure.node instance at 0xb7630c8c>, 153: <unpyclib.structure.node instance at 0xb763010c>, 59: <unpyclib.structure.node instance at 0xb76305ec>}
nname: 113
n 113(None)[return True
]:
	i: 21(AL), 112()
	o: 

nname: 112
n 112(None)[]:
	i: 24(AF), 40()
	o: 113()

nname: 40
n 40(None)[for id, rule in self._periodicRecordings.items():
node_rule = ET.Element('rule')
node_rule.attrib['id'] = str(id)
rule.SaveToXMLNode(node_rule)
oXMLNode.append(node_rule)
]:
	i: 24(for)
	o: 112()

nname: 24
n 24(None)[]:
	i: 21(loop)
	o: 40(for), 112(AF)

nname: 21
n 21(None)[]:
	i: 12(), 20()
	o: 24(loop), 113(AL)

nname: 20
n 20(None)[]:
	i: 0(f)
	o: 21()

nname: 12
n 12(None)[return False
]:
	i: 0(t)
	o: 21()

nname: 0
n 0(oXMLNode == None)[]:
	i: 
	o: 12(t), 20(f)

nname: 112
n 112(None)[return True
]:
	i: 24()
	o: 

nname: 24
n 24(None)[for id, rule in self._periodicRecordings.items():
	node_rule = ET.Element('rule')
	node_rule.attrib['id'] = str(id)
	rule.SaveToXMLNode(node_rule)
	oXMLNode.append(node_rule)
]:
	i: 0(loop)
	o: 112()

nname: 0
n 0(None)[if oXMLNode == None:
	return False
]:
	i: 
	o: 24(loop)

nname: 112
n 112(None)[return True
]:
	i: 0()
	o: 

nname: 0
n 0(None)[if oXMLNode == None:
	return False
for id, rule in self._periodicRecordings.items():
	node_rule = ET.Element('rule')
	node_rule.attrib['id'] = str(id)
	rule.SaveToXMLNode(node_rule)
	oXMLNode.append(node_rule)
]:
	i: 
	o: 112()

nname: 0
n 0(None)[if oXMLNode == None:
	return False
for id, rule in self._periodicRecordings.items():
	node_rule = ET.Element('rule')
	node_rule.attrib['id'] = str(id)
	rule.SaveToXMLNode(node_rule)
	oXMLNode.append(node_rule)
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7630f4c>}
nname: 0
n 0(None)[del self._periodicRecordings[rule_id]
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb762ad4c>}
nname: 6
n 6(None)[__doc__ = ' keep the list of periodicity rule.\n    \n    used to generate a list of start time when scheduling periodic recording\n    a rule can be reused for new periodic recording.\n    '
def __init__(self):
	self._periodicRecordings = {}

def _computeIdentifier(self):
	rec_id = 1

def AddPeriodicSchedulingRule(self, rule):
	new_rule_id = self._computeIdentifier()
	rule.id = new_rule_id
	self._periodicRecordings[new_rule_id] = rule
	return new_rule_id

def GetTimeList(self, id, startTime, stopTime, minStartTime=None):
	log.debug('id ' + str(id) + ' startTime ' + str(startTime) + ' stopTime ' + str(stopTime))
	log.debug('self._periodicRecordings ' + str(self._periodicRecordings))
	if id not in self._periodicRecordings:
		return []
	rule = self._periodicRecordings[id]
	time_list = []
	try:
		t_ref = startTime
		if minStartTime:
			t_min = minStartTime
		else:
			t_min = startTime

def LoadFromXML(self, oXMLNode):
	nodes_rule = oXMLNode.getiterator('rule')
	if not nodes_rule:
		log.warning('wyrecord error: no node rule found')
		return False
	self._periodicRecordings.clear()

def SaveToXMLNode(self, oXMLNode):
	if oXMLNode == None:
		return False
	for id, rule in self._periodicRecordings.items():
		node_rule = ET.Element('rule')
		node_rule.attrib['id'] = str(id)
		rule.SaveToXMLNode(node_rule)
		oXMLNode.append(node_rule)
	return True

def RemoveRule(self, rule_id):
	del self._periodicRecordings[rule_id]

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb762a8ac>}
nname: 0
n 0(None)[import xml.etree.cElementTree as ET
from periodicscheduling import PeriodicScheduling
from periodicscheduling import GetPeriodicSchedulingInstanceFactory
from logger import log
from peewee.analyse import Chrono
class PeriodicRecordingList(object):
	__doc__ = ' keep the list of periodicity rule.\n    \n    used to generate a list of start time when scheduling periodic recording\n    a rule can be reused for new periodic recording.\n    '
	def __init__(self):
		self._periodicRecordings = {}

	def _computeIdentifier(self):
		rec_id = 1

	def AddPeriodicSchedulingRule(self, rule):
		new_rule_id = self._computeIdentifier()
		rule.id = new_rule_id
		self._periodicRecordings[new_rule_id] = rule
		return new_rule_id

	def GetTimeList(self, id, startTime, stopTime, minStartTime=None):
		log.debug('id ' + str(id) + ' startTime ' + str(startTime) + ' stopTime ' + str(stopTime))
		log.debug('self._periodicRecordings ' + str(self._periodicRecordings))
		if id not in self._periodicRecordings:
			return []
		rule = self._periodicRecordings[id]
		time_list = []
		try:
			t_ref = startTime
			if minStartTime:
				t_min = minStartTime
			else:
				t_min = startTime

	def LoadFromXML(self, oXMLNode):
		nodes_rule = oXMLNode.getiterator('rule')
		if not nodes_rule:
			log.warning('wyrecord error: no node rule found')
			return False
		self._periodicRecordings.clear()

	def SaveToXMLNode(self, oXMLNode):
		if oXMLNode == None:
			return False
		for id, rule in self._periodicRecordings.items():
			node_rule = ET.Element('rule')
			node_rule.attrib['id'] = str(id)
			rule.SaveToXMLNode(node_rule)
			oXMLNode.append(node_rule)
		return True

	def RemoveRule(self, rule_id):
		del self._periodicRecordings[rule_id]



]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7623d8c>}
import xml.etree.cElementTree as ET
from periodicscheduling import PeriodicScheduling
from periodicscheduling import GetPeriodicSchedulingInstanceFactory
from logger import log
from peewee.analyse import Chrono
class PeriodicRecordingList(object):
	__doc__ = ' keep the list of periodicity rule.\n    \n    used to generate a list of start time when scheduling periodic recording\n    a rule can be reused for new periodic recording.\n    '
	def __init__(self):
		self._periodicRecordings = {}

	def _computeIdentifier(self):
		rec_id = 1

	def AddPeriodicSchedulingRule(self, rule):
		new_rule_id = self._computeIdentifier()
		rule.id = new_rule_id
		self._periodicRecordings[new_rule_id] = rule
		return new_rule_id

	def GetTimeList(self, id, startTime, stopTime, minStartTime=None):
		log.debug('id ' + str(id) + ' startTime ' + str(startTime) + ' stopTime ' + str(stopTime))
		log.debug('self._periodicRecordings ' + str(self._periodicRecordings))
		if id not in self._periodicRecordings:
			return []
		rule = self._periodicRecordings[id]
		time_list = []
		try:
			t_ref = startTime
			if minStartTime:
				t_min = minStartTime
			else:
				t_min = startTime

	def LoadFromXML(self, oXMLNode):
		nodes_rule = oXMLNode.getiterator('rule')
		if not nodes_rule:
			log.warning('wyrecord error: no node rule found')
			return False
		self._periodicRecordings.clear()

	def SaveToXMLNode(self, oXMLNode):
		if oXMLNode == None:
			return False
		for id, rule in self._periodicRecordings.items():
			node_rule = ET.Element('rule')
			node_rule.attrib['id'] = str(id)
			rule.SaveToXMLNode(node_rule)
			oXMLNode.append(node_rule)
		return True

	def RemoveRule(self, rule_id):
		del self._periodicRecordings[rule_id]



