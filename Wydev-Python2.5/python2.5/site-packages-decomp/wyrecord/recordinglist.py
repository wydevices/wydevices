# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 0
n 0(None)[self.recordings = {}
self.rec_id_from_program_id = {}
self.recording_launcher = oRecordingManager
self.recording_builder = recording_builder
self.chrono = conflictmanager.ChronologicalRecordingList(self.recording_launcher)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76ece2c>}
nname: 194
n 194(None)[oRecording.favorite = favorite
log.info('Recording added : ' + str(oRecording))
return True
]:
	i: 164(), 193()
	o: 

nname: 193
n 193(None)[]:
	i: 121(f)
	o: 194()

nname: 164
n 164(None)[self.rec_id_from_program_id[program_id] = oRecording.id
oRecording.program_id = program_id
]:
	i: 121(t)
	o: 194()

nname: 121
n 121(program_id)[oRecording.id = rec_id
self.recordings[oRecording.id] = oRecording
program_id = str(program_id)
]:
	i: 107(), 120()
	o: 164(t), 193(f)

nname: 120
n 120(None)[]:
	i: 43(f)
	o: 121()

nname: 107
n 107(None)[del _[1]
]:
	i: 70(AF), 94()
	o: 121()

nname: 94
n 94(None)[for recording in self.recordings:
]:
	i: 70(for)
	o: 107()

nname: 70
n 70(None)[]:
	i: 43(t)
	o: 94(for), 107(AF)

nname: 43
n 43(len(self.recordings) != 0)[rec_id = 1
]:
	i: 21(), 42()
	o: 70(t), 120(f)

nname: 42
n 42(None)[]:
	i: 0(f)
	o: 43()

nname: 21
n 21(None)[log.error('Recording ID already used !')
return False
]:
	i: 0(t)
	o: 43()

nname: 0
n 0(self.recordings.has_key(oRecording.id))[]:
	i: 
	o: 21(t), 42(f)

nname: 121
n 121(None)[oRecording.id = rec_id
self.recordings[oRecording.id] = oRecording
program_id = str(program_id)
if program_id:
	self.rec_id_from_program_id[program_id] = oRecording.id
	oRecording.program_id = program_id
oRecording.favorite = favorite
log.info('Recording added : ' + str(oRecording))
return True
]:
	i: 107(), 0(f)
	o: 

nname: 107
n 107(None)[del _[1]
]:
	i: 70(AF), 94()
	o: 121()

nname: 94
n 94(None)[for recording in self.recordings:
]:
	i: 70(for)
	o: 107()

nname: 70
n 70(None)[]:
	i: 0(t)
	o: 94(for), 107(AF)

nname: 0
n 0(len(self.recordings) != 0)[if self.recordings.has_key(oRecording.id):
	log.error('Recording ID already used !')
	return False
rec_id = 1
]:
	i: 
	o: 70(t), 121(f)

self.nodes: {0: <unpyclib.structure.node instance at 0xb76f072c>, 107: <unpyclib.structure.node instance at 0xb76f092c>, 70: <unpyclib.structure.node instance at 0xb76f082c>, 121: <unpyclib.structure.node instance at 0xb76f09ac>, 94: <unpyclib.structure.node instance at 0xb76f08ac>}
nname: 40
n 40(None)[return self.recordings[nRecordingID]
]:
	i: 18(), 39()
	o: 

nname: 39
n 39(None)[]:
	i: 0(t)
	o: 40()

nname: 18
n 18(None)[log.error('Recording ID is not valid !')
return None
]:
	i: 0(f)
	o: 40()

nname: 0
n 0(self.recordings.has_key(nRecordingID))[]:
	i: 
	o: 18(f), 39(t)

nname: 0
n 0(None)[if not self.recordings.has_key(nRecordingID):
	log.error('Recording ID is not valid !')
	return None
return self.recordings[nRecordingID]
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76ecd0c>}
nname: 212
n 212(None)[log.info('record to START = ' + str(cur_recording))
return cur_recording
]:
	i: 30(AL), 211()
	o: 

nname: 211
n 211(None)[]:
	i: 45(AF), 207()
	o: 212()

nname: 207
n 207(None)[]:
	i: 158(f), 181()
	o: 211()

nname: 181
n 181(None)[cur_recording = recording
cur_start_time = recording.start_time - recording.start_padding
continue
]:
	i: 158(t)
	o: 207()

nname: 158
n 158(recording.start_time - recording.start_padding < cur_start_time)[]:
	i: 131(f), 147()
	o: 181(t), 207(f)

nname: 147
n 147(None)[cur_recording = recording
break
continue
]:
	i: 131(t)
	o: 158()

nname: 131
n 131(recording.start_time == 0)[]:
	i: 93(f), 105()
	o: 147(t), 158(f)

nname: 105
n 105(None)[cur_recording = recording
cur_start_time = recording.start_time - recording.start_padding
continue
]:
	i: 93(t)
	o: 131()

nname: 93
n 93(cur_recording == None)[]:
	i: 85(), 92()
	o: 105(t), 131(f)

nname: 92
n 92(None)[]:
	i: 61(f)
	o: 93()

nname: 85
n 85(None)[continue
]:
	i: 61(t)
	o: 93()

nname: 61
n 61(recording.status != RECORDING_STATUS_SCHEDULED)[for id, recording in self.recordings.items():
]:
	i: 45(for)
	o: 85(t), 92(f)

nname: 45
n 45(None)[]:
	i: 30(loop)
	o: 61(for), 211(AF)

nname: 30
n 30(None)[cur_start_time = 0
cur_recording = None
]:
	i: 21(), 29()
	o: 45(loop), 212(AL)

nname: 29
n 29(None)[]:
	i: 0(f)
	o: 30()

nname: 21
n 21(None)[return None
]:
	i: 0(t)
	o: 30()

nname: 0
n 0(len(self.recordings) == 0)[]:
	i: 
	o: 21(t), 29(f)

nname: 212
n 212(None)[log.info('record to START = ' + str(cur_recording))
return cur_recording
]:
	i: 0(AL), 45(AF), 131(f)
	o: 

nname: 131
n 131(None)[if recording.start_time == 0:
	cur_recording = recording
	break
	continue
if recording.start_time - recording.start_padding < cur_start_time:
	cur_recording = recording
	cur_start_time = recording.start_time - recording.start_padding
	continue
]:
	i: 61(f)
	o: 212()

nname: 61
n 61(None)[for id, recording in self.recordings.items():
if recording.status != RECORDING_STATUS_SCHEDULED:
	continue
if cur_recording == None:
	cur_recording = recording
	cur_start_time = recording.start_time - recording.start_padding
	continue
]:
	i: 45(for)
	o: 131()

nname: 45
n 45(None)[]:
	i: 0(loop)
	o: 61(for), 212(AF)

nname: 0
n 0(None)[if len(self.recordings) == 0:
	return None
cur_start_time = 0
cur_recording = None
]:
	i: 
	o: 45(loop), 212(AL)

nname: 212
n 212(None)[log.info('record to START = ' + str(cur_recording))
return cur_recording
]:
	i: 0(AL), 45(AF), 61(f)
	o: 

nname: 61
n 61(None)[for id, recording in self.recordings.items():
if recording.status != RECORDING_STATUS_SCHEDULED:
	continue
if cur_recording == None:
	cur_recording = recording
	cur_start_time = recording.start_time - recording.start_padding
	continue
if recording.start_time == 0:
	cur_recording = recording
	break
	continue
if recording.start_time - recording.start_padding < cur_start_time:
	cur_recording = recording
	cur_start_time = recording.start_time - recording.start_padding
	continue
]:
	i: 45(for)
	o: 212()

nname: 45
n 45(None)[]:
	i: 0(loop)
	o: 61(for), 212(AF)

nname: 0
n 0(None)[if len(self.recordings) == 0:
	return None
cur_start_time = 0
cur_recording = None
]:
	i: 
	o: 45(loop), 212(AL)

self.nodes: {0: <unpyclib.structure.node instance at 0xb76f082c>, 45: <unpyclib.structure.node instance at 0xb76f092c>, 212: <unpyclib.structure.node instance at 0xb76f0c4c>, 61: <unpyclib.structure.node instance at 0xb76f0bec>}
nname: 208
n 208(None)[log.info('record to STOP = ' + str(cur_recording))
return cur_recording
]:
	i: 30(AL), 207()
	o: 

nname: 207
n 207(None)[]:
	i: 45(AF), 203()
	o: 208()

nname: 203
n 203(None)[]:
	i: 154(f), 177()
	o: 207()

nname: 177
n 177(None)[cur_recording = recording
cur_stop_time = recording.stop_time + recording.stop_padding
continue
]:
	i: 154(t)
	o: 203()

nname: 154
n 154(recording.stop_time + recording.stop_padding < cur_stop_time)[]:
	i: 116(f), 128()
	o: 177(t), 203(f)

nname: 128
n 128(None)[cur_recording = recording
cur_stop_time = recording.stop_time + recording.stop_padding
continue
]:
	i: 116(t)
	o: 154()

nname: 116
n 116(cur_recording == None)[]:
	i: 108(), 115()
	o: 128(t), 154(f)

nname: 115
n 115(None)[]:
	i: 93(f)
	o: 116()

nname: 108
n 108(None)[continue
]:
	i: 93(t)
	o: 116()

nname: 93
n 93(recording.stop_time == 0)[]:
	i: 85(), 92()
	o: 108(t), 115(f)

nname: 92
n 92(None)[]:
	i: 61(f)
	o: 93()

nname: 85
n 85(None)[continue
]:
	i: 61(t)
	o: 93()

nname: 61
n 61(recording.status != RECORDING_STATUS_RUNNING)[for id, recording in self.recordings.items():
]:
	i: 45(for)
	o: 85(t), 92(f)

nname: 45
n 45(None)[]:
	i: 30(loop)
	o: 61(for), 207(AF)

nname: 30
n 30(None)[cur_stop_time = 0
cur_recording = None
]:
	i: 21(), 29()
	o: 45(loop), 208(AL)

nname: 29
n 29(None)[]:
	i: 0(f)
	o: 30()

nname: 21
n 21(None)[return None
]:
	i: 0(t)
	o: 30()

nname: 0
n 0(len(self.recordings) == 0)[]:
	i: 
	o: 21(t), 29(f)

nname: 208
n 208(None)[log.info('record to STOP = ' + str(cur_recording))
return cur_recording
]:
	i: 0(AL), 45(AF), 116(f)
	o: 

nname: 116
n 116(None)[if cur_recording == None:
	cur_recording = recording
	cur_stop_time = recording.stop_time + recording.stop_padding
	continue
if recording.stop_time + recording.stop_padding < cur_stop_time:
	cur_recording = recording
	cur_stop_time = recording.stop_time + recording.stop_padding
	continue
]:
	i: 61()
	o: 208()

nname: 61
n 61(None)[for id, recording in self.recordings.items():
if recording.status != RECORDING_STATUS_RUNNING:
	continue
if recording.stop_time == 0:
	continue
]:
	i: 45(for)
	o: 116()

nname: 45
n 45(None)[]:
	i: 0(loop)
	o: 61(for), 208(AF)

nname: 0
n 0(None)[if len(self.recordings) == 0:
	return None
cur_stop_time = 0
cur_recording = None
]:
	i: 
	o: 45(loop), 208(AL)

nname: 208
n 208(None)[log.info('record to STOP = ' + str(cur_recording))
return cur_recording
]:
	i: 0(AL), 45(AF), 61(f)
	o: 

nname: 61
n 61(None)[for id, recording in self.recordings.items():
if recording.status != RECORDING_STATUS_RUNNING:
	continue
if recording.stop_time == 0:
	continue
if cur_recording == None:
	cur_recording = recording
	cur_stop_time = recording.stop_time + recording.stop_padding
	continue
if recording.stop_time + recording.stop_padding < cur_stop_time:
	cur_recording = recording
	cur_stop_time = recording.stop_time + recording.stop_padding
	continue
]:
	i: 45(for)
	o: 208()

nname: 45
n 45(None)[]:
	i: 0(loop)
	o: 61(for), 208(AF)

nname: 0
n 0(None)[if len(self.recordings) == 0:
	return None
cur_stop_time = 0
cur_recording = None
]:
	i: 
	o: 45(loop), 208(AL)

self.nodes: {0: <unpyclib.structure.node instance at 0xb76f0a8c>, 45: <unpyclib.structure.node instance at 0xb76f0c4c>, 208: <unpyclib.structure.node instance at 0xb76f0bcc>, 61: <unpyclib.structure.node instance at 0xb76f0eec>}
nname: 129
n 129(None)[return True
]:
	i: 0(AL), 128()
	o: 

nname: 128
n 128(None)[]:
	i: 31(AF), 125()
	o: 129()

nname: 125
n 125(None)[]:
	i: 97(JA), 124()
	o: 128()

nname: 124
n 124(None)[]:
	i: 38(f), 120()
	o: 125()

nname: 120
n 120(None)[continue
]:
	i: 71(f)
	o: 124()

nname: 97
n 97(None)[self.rec_id_from_program_id[recording.program_id] = recording.id
]:
	i: 71(t)
	o: 125(JA)

nname: 71
n 71(recording.program_id)[self.recordings[recording.id] = recording
]:
	i: 38(t)
	o: 97(t), 120(f)

nname: 38
n 38(recording.LoadFromXML(node_recording))[for node_recording in nodes_recording:
recording = self.recording_builder.buildNewRecording()
]:
	i: 31(for)
	o: 71(t), 124(f)

nname: 31
n 31(None)[]:
	i: 0(loop)
	o: 38(for), 128(AF)

nname: 0
n 0(None)[nodes_recording = oXMLNode.getiterator('recording')
self.recordings.clear()
]:
	i: 
	o: 31(loop), 129(AL)

nname: 129
n 129(None)[return True
]:
	i: 0(AL), 31(AF), 97(JA), 38(f), 120()
	o: 

nname: 120
n 120(None)[continue
]:
	i: 71(f)
	o: 129()

nname: 97
n 97(None)[self.rec_id_from_program_id[recording.program_id] = recording.id
]:
	i: 71(t)
	o: 129(JA)

nname: 71
n 71(recording.program_id)[self.recordings[recording.id] = recording
]:
	i: 38(t)
	o: 97(t), 120(f)

nname: 38
n 38(recording.LoadFromXML(node_recording))[for node_recording in nodes_recording:
recording = self.recording_builder.buildNewRecording()
]:
	i: 31(for)
	o: 71(t), 129(f)

nname: 31
n 31(None)[]:
	i: 0(loop)
	o: 38(for), 129(AF)

nname: 0
n 0(None)[nodes_recording = oXMLNode.getiterator('recording')
self.recordings.clear()
]:
	i: 
	o: 31(loop), 129(AL)

nname: 38
n 38(None)[for node_recording in nodes_recording:
	recording = self.recording_builder.buildNewRecording()
	if recording.LoadFromXML(node_recording):
		self.recordings[recording.id] = recording
		if recording.program_id:
			self.rec_id_from_program_id[recording.program_id] = recording.id
		else:
			continue
return True
]:
	i: 0(for)
	o: 

nname: 0
n 0(None)[nodes_recording = oXMLNode.getiterator('recording')
self.recordings.clear()
]:
	i: 
	o: 38(for)

nname: 0
n 0(None)[nodes_recording = oXMLNode.getiterator('recording')
self.recordings.clear()
for node_recording in nodes_recording:
	recording = self.recording_builder.buildNewRecording()
	if recording.LoadFromXML(node_recording):
		self.recordings[recording.id] = recording
		if recording.program_id:
			self.rec_id_from_program_id[recording.program_id] = recording.id
		else:
			continue
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76ecbcc>}
nname: 126
n 126(None)[return True
]:
	i: 21(AL), 125()
	o: 

nname: 125
n 125(None)[]:
	i: 56(AF), 72()
	o: 126()

nname: 72
n 72(None)[for id, recording in self.recordings.items():
node_recording = ET.Element('recording')
recording.SaveToXMLNode(node_recording)
oXMLNode.append(node_recording)
]:
	i: 56(for)
	o: 125()

nname: 56
n 56(None)[]:
	i: 21(loop)
	o: 72(for), 125(AF)

nname: 21
n 21(None)[log.debug('number of record in list: ' + str(len(self.recordings)))
]:
	i: 12(), 20()
	o: 56(loop), 126(AL)

nname: 20
n 20(None)[]:
	i: 0(f)
	o: 21()

nname: 12
n 12(None)[return False
]:
	i: 0(t)
	o: 21()

nname: 0
n 0(oXMLNode == None)[]:
	i: 
	o: 12(t), 20(f)

nname: 125
n 125(None)[return True
]:
	i: 56()
	o: 

nname: 56
n 56(None)[for id, recording in self.recordings.items():
	node_recording = ET.Element('recording')
	recording.SaveToXMLNode(node_recording)
	oXMLNode.append(node_recording)
]:
	i: 0(loop)
	o: 125()

nname: 0
n 0(None)[if oXMLNode == None:
	return False
log.debug('number of record in list: ' + str(len(self.recordings)))
]:
	i: 
	o: 56(loop)

nname: 125
n 125(None)[return True
]:
	i: 0()
	o: 

nname: 0
n 0(None)[if oXMLNode == None:
	return False
log.debug('number of record in list: ' + str(len(self.recordings)))
for id, recording in self.recordings.items():
	node_recording = ET.Element('recording')
	recording.SaveToXMLNode(node_recording)
	oXMLNode.append(node_recording)
]:
	i: 
	o: 125()

nname: 0
n 0(None)[if oXMLNode == None:
	return False
log.debug('number of record in list: ' + str(len(self.recordings)))
for id, recording in self.recordings.items():
	node_recording = ET.Element('recording')
	recording.SaveToXMLNode(node_recording)
	oXMLNode.append(node_recording)
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76ecbcc>}
nname: 28
n 28(None)[return rec.status == RECORDING_STATUS_RUNNING
]:
	i: 0(t), 15()
	o: 

nname: 15
n 15(None)[]:
	i: 0(f)
	o: 28()

nname: 0
n 0(rec.status == RECORDING_STATUS_RUNNING)[]:
	i: 
	o: 15(f), 28(t)

nname: 0
n 0(None)[if not rec.status == RECORDING_STATUS_RUNNING:
	pass
return rec.status == RECORDING_STATUS_RUNNING
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76f010c>}
nname: 28
n 28(None)[return rec.status == RECORDING_STATUS_RUNNING
]:
	i: 0(t), 15()
	o: 

nname: 15
n 15(None)[]:
	i: 0(f)
	o: 28()

nname: 0
n 0(rec.status == RECORDING_STATUS_RUNNING)[]:
	i: 
	o: 15(f), 28(t)

nname: 0
n 0(None)[if not rec.status == RECORDING_STATUS_RUNNING:
	pass
return rec.status == RECORDING_STATUS_RUNNING
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76f068c>}
nname: 44
n 44(None)[return rec.type != RECORDING_TYPE_NOT_SCHEDULED
]:
	i: 0&15(f), 31()
	o: 

nname: 31
n 31(None)[]:
	i: 0&15(t)
	o: 44()

nname: 0&15
n 0&15(rec.status == RECORDING_STATUS_RUNNING or rec.status == RECORDING_STATUS_SCHEDULED)[]:
	i: 
	o: 31(t), 44(f)

nname: 0&15
n 0&15(None)[if rec.status == RECORDING_STATUS_RUNNING or rec.status == RECORDING_STATUS_SCHEDULED:
	pass
return rec.type != RECORDING_TYPE_NOT_SCHEDULED
]:
	i: 
	o: 

self.nodes: {'0&15': <unpyclib.structure.node instance at 0xb76f0f0c>}
nname: 44
n 44(None)[return rec.type != RECORDING_TYPE_NOT_SCHEDULED
]:
	i: 0&15(f), 31()
	o: 

nname: 31
n 31(None)[]:
	i: 0&15(t)
	o: 44()

nname: 0&15
n 0&15(rec.status == RECORDING_STATUS_RUNNING or rec.status == RECORDING_STATUS_SCHEDULED)[]:
	i: 
	o: 31(t), 44(f)

nname: 0&15
n 0&15(None)[if rec.status == RECORDING_STATUS_RUNNING or rec.status == RECORDING_STATUS_SCHEDULED:
	pass
return rec.type != RECORDING_TYPE_NOT_SCHEDULED
]:
	i: 
	o: 

self.nodes: {'0&15': <unpyclib.structure.node instance at 0xb76f036c>}
nname: 65
n 65(None)[self.chrono.orderRecording(schedule_or_running)
return self.chrono.getConflict(oRecording)
]:
	i: 6(), 37()
	o: 

nname: 37
n 37(None)[schedule_or_running = filter((lambda rec: rec.status == RECORDING_STATUS_RUNNING:
	pass
return rec.status == RECORDING_STATUS_RUNNING), self.recordings.values())
]:
	i: 0(f)
	o: 65()

nname: 6
n 6(None)[schedule_or_running = filter((lambda rec: status == RECORDING_STATUS_RUNNING or rec.status == RECORDING_STATUS_SCHEDULED:
	pass
return rec.type != RECORDING_TYPE_NOT_SCHEDULED), self.recordings.values())
]:
	i: 0(t)
	o: 65()

nname: 0
n 0(ignore_not_scheduled)[]:
	i: 
	o: 6(t), 37(f)

nname: 0
n 0(None)[if ignore_not_scheduled:
	schedule_or_running = filter((lambda rec: status == RECORDING_STATUS_RUNNING or rec.status == RECORDING_STATUS_SCHEDULED:
		pass
	return rec.type != RECORDING_TYPE_NOT_SCHEDULED), self.recordings.values())
else:
	schedule_or_running = filter((lambda rec: rec.status == RECORDING_STATUS_RUNNING:
		pass
	return rec.status == RECORDING_STATUS_RUNNING), self.recordings.values())
self.chrono.orderRecording(schedule_or_running)
return self.chrono.getConflict(oRecording)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76ecc0c>}
nname: 44
n 44(None)[return rec.type != RECORDING_TYPE_NOT_SCHEDULED
]:
	i: 0&15(f), 31()
	o: 

nname: 31
n 31(None)[]:
	i: 0&15(t)
	o: 44()

nname: 0&15
n 0&15(rec.status == RECORDING_STATUS_RUNNING or rec.status == RECORDING_STATUS_SCHEDULED)[]:
	i: 
	o: 31(t), 44(f)

nname: 0&15
n 0&15(None)[if rec.status == RECORDING_STATUS_RUNNING or rec.status == RECORDING_STATUS_SCHEDULED:
	pass
return rec.type != RECORDING_TYPE_NOT_SCHEDULED
]:
	i: 
	o: 

self.nodes: {'0&15': <unpyclib.structure.node instance at 0xb76f054c>}
nname: 44
n 44(None)[return rec.type != RECORDING_TYPE_NOT_SCHEDULED
]:
	i: 0&15(f), 31()
	o: 

nname: 31
n 31(None)[]:
	i: 0&15(t)
	o: 44()

nname: 0&15
n 0&15(rec.status == RECORDING_STATUS_RUNNING or rec.status == RECORDING_STATUS_SCHEDULED)[]:
	i: 
	o: 31(t), 44(f)

nname: 0&15
n 0&15(None)[if rec.status == RECORDING_STATUS_RUNNING or rec.status == RECORDING_STATUS_SCHEDULED:
	pass
return rec.type != RECORDING_TYPE_NOT_SCHEDULED
]:
	i: 
	o: 

self.nodes: {'0&15': <unpyclib.structure.node instance at 0xb76f0ecc>}
nname: 0
n 0(None)[stop_time_temp = oRecording.stop_time
oRecording.stop_time = 0
schedule_or_running = filter((lambda rec: status == RECORDING_STATUS_RUNNING or rec.status == RECORDING_STATUS_SCHEDULED:
	pass
return rec.type != RECORDING_TYPE_NOT_SCHEDULED), self.recordings.values())
self.chrono.orderRecording(schedule_or_running)
conflict = self.chrono.getConflict(oRecording)
oRecording.stop_time = stop_time_temp
return conflict
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76ecfec>}
nname: 44
n 44(None)[return rec.type != RECORDING_TYPE_NOT_SCHEDULED
]:
	i: 0&15(f), 31()
	o: 

nname: 31
n 31(None)[]:
	i: 0&15(t)
	o: 44()

nname: 0&15
n 0&15(rec.status == RECORDING_STATUS_RUNNING or rec.status == RECORDING_STATUS_SCHEDULED)[]:
	i: 
	o: 31(t), 44(f)

nname: 0&15
n 0&15(None)[if rec.status == RECORDING_STATUS_RUNNING or rec.status == RECORDING_STATUS_SCHEDULED:
	pass
return rec.type != RECORDING_TYPE_NOT_SCHEDULED
]:
	i: 
	o: 

self.nodes: {'0&15': <unpyclib.structure.node instance at 0xb76f090c>}
nname: 44
n 44(None)[return rec.type != RECORDING_TYPE_NOT_SCHEDULED
]:
	i: 0&15(f), 31()
	o: 

nname: 31
n 31(None)[]:
	i: 0&15(t)
	o: 44()

nname: 0&15
n 0&15(rec.status == RECORDING_STATUS_RUNNING or rec.status == RECORDING_STATUS_SCHEDULED)[]:
	i: 
	o: 31(t), 44(f)

nname: 0&15
n 0&15(None)[if rec.status == RECORDING_STATUS_RUNNING or rec.status == RECORDING_STATUS_SCHEDULED:
	pass
return rec.type != RECORDING_TYPE_NOT_SCHEDULED
]:
	i: 
	o: 

self.nodes: {'0&15': <unpyclib.structure.node instance at 0xb76f07ac>}
nname: 28
n 28(None)[return rec.status == RECORDING_STATUS_RUNNING
]:
	i: 0(t), 15()
	o: 

nname: 15
n 15(None)[]:
	i: 0(f)
	o: 28()

nname: 0
n 0(rec.status == RECORDING_STATUS_RUNNING)[]:
	i: 
	o: 15(f), 28(t)

nname: 0
n 0(None)[if not rec.status == RECORDING_STATUS_RUNNING:
	pass
return rec.status == RECORDING_STATUS_RUNNING
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76f006c>}
nname: 28
n 28(None)[return rec.status == RECORDING_STATUS_RUNNING
]:
	i: 0(t), 15()
	o: 

nname: 15
n 15(None)[]:
	i: 0(f)
	o: 28()

nname: 0
n 0(rec.status == RECORDING_STATUS_RUNNING)[]:
	i: 
	o: 15(f), 28(t)

nname: 0
n 0(None)[if not rec.status == RECORDING_STATUS_RUNNING:
	pass
return rec.status == RECORDING_STATUS_RUNNING
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76f01ac>}
nname: 65
n 65(None)[self.chrono.orderRecording(schedule_or_running)
self.chrono.insertRecording(oRecording)
conflict = self.chrono.getConflict(oRecording)
return conflict
]:
	i: 6(), 37()
	o: 

nname: 37
n 37(None)[schedule_or_running = filter((lambda rec: status == RECORDING_STATUS_RUNNING or rec.status == RECORDING_STATUS_SCHEDULED:
	pass
return rec.type != RECORDING_TYPE_NOT_SCHEDULED), self.recordings.values())
]:
	i: 0(f)
	o: 65()

nname: 6
n 6(None)[schedule_or_running = filter((lambda rec: rec.status == RECORDING_STATUS_RUNNING:
	pass
return rec.status == RECORDING_STATUS_RUNNING), self.recordings.values())
]:
	i: 0(t)
	o: 65()

nname: 0
n 0(include_instant_record)[]:
	i: 
	o: 6(t), 37(f)

nname: 0
n 0(None)[if include_instant_record:
	schedule_or_running = filter((lambda rec: rec.status == RECORDING_STATUS_RUNNING:
		pass
	return rec.status == RECORDING_STATUS_RUNNING), self.recordings.values())
else:
	schedule_or_running = filter((lambda rec: status == RECORDING_STATUS_RUNNING or rec.status == RECORDING_STATUS_SCHEDULED:
		pass
	return rec.type != RECORDING_TYPE_NOT_SCHEDULED), self.recordings.values())
self.chrono.orderRecording(schedule_or_running)
self.chrono.insertRecording(oRecording)
conflict = self.chrono.getConflict(oRecording)
return conflict
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76ece8c>}
nname: 117
n 117(None)[return True
]:
	i: 81(AL), 116()
	o: 

nname: 116
n 116(None)[]:
	i: 84(AF), 91()
	o: 117()

nname: 91
n 91(None)[for recording in recording_to_remove:
self.recordings.pop(recording.id)
]:
	i: 84(for)
	o: 116()

nname: 84
n 84(None)[]:
	i: 81(loop)
	o: 91(for), 116(AF)

nname: 81
n 81(None)[]:
	i: 0(AL), 80()
	o: 84(loop), 117(AL)

nname: 80
n 80(None)[]:
	i: 22(AF), 76()
	o: 81()

nname: 76
n 76(None)[]:
	i: 38(t), 59()
	o: 80()

nname: 59
n 59(None)[recording_to_remove.append(recording)
continue
]:
	i: 38(f)
	o: 76()

nname: 38
n 38(recording.IsValid())[for id, recording in self.recordings.items():
]:
	i: 22(for)
	o: 59(f), 76(t)

nname: 22
n 22(None)[]:
	i: 0(loop)
	o: 38(for), 80(AF)

nname: 0
n 0(None)[log.info('CleanUp RecordingList')
recording_to_remove = []
]:
	i: 
	o: 22(loop), 81(AL)

nname: 117
n 117(None)[return True
]:
	i: 91()
	o: 

nname: 91
n 91(None)[for recording in recording_to_remove:
	self.recordings.pop(recording.id)
]:
	i: 81(for)
	o: 117()

nname: 81
n 81(None)[]:
	i: 0(AL), 22(AF), 38()
	o: 91(for)

nname: 38
n 38(None)[for id, recording in self.recordings.items():
if not recording.IsValid():
	recording_to_remove.append(recording)
	continue
]:
	i: 22(for)
	o: 81()

nname: 22
n 22(None)[]:
	i: 0(loop)
	o: 38(for), 81(AF)

nname: 0
n 0(None)[log.info('CleanUp RecordingList')
recording_to_remove = []
]:
	i: 
	o: 22(loop), 81(AL)

nname: 91
n 91(None)[for recording in recording_to_remove:
	self.recordings.pop(recording.id)
return True
]:
	i: 38(for)
	o: 

nname: 38
n 38(None)[for id, recording in self.recordings.items():
	if not recording.IsValid():
		recording_to_remove.append(recording)
		continue
]:
	i: 0(for)
	o: 91(for)

nname: 0
n 0(None)[log.info('CleanUp RecordingList')
recording_to_remove = []
]:
	i: 
	o: 38(for)

nname: 91
n 91(None)[for recording in recording_to_remove:
	self.recordings.pop(recording.id)
return True
]:
	i: 0(for)
	o: 

nname: 0
n 0(None)[log.info('CleanUp RecordingList')
recording_to_remove = []
for id, recording in self.recordings.items():
	if not recording.IsValid():
		recording_to_remove.append(recording)
		continue
]:
	i: 
	o: 91(for)

nname: 0
n 0(None)[log.info('CleanUp RecordingList')
recording_to_remove = []
for id, recording in self.recordings.items():
	if not recording.IsValid():
		recording_to_remove.append(recording)
		continue
for recording in recording_to_remove:
	self.recordings.pop(recording.id)
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76ecfac>}
nname: 157
n 157(None)[self.recordings.pop(nRecordingID)
return True
]:
	i: 133(), 156()
	o: 

nname: 156
n 156(None)[]:
	i: 112(f)
	o: 157()

nname: 133
n 133(None)[self.rec_id_from_program_id.pop(recording.program_id)
]:
	i: 112(t)
	o: 157()

nname: 112
n 112(self.rec_id_from_program_id.has_key(recording.program_id))[]:
	i: 94(), 111()
	o: 133(t), 156(f)

nname: 111
n 111(None)[]:
	i: 88(f)
	o: 112()

nname: 94
n 94(None)[recording.record_info.Delete()
]:
	i: 88(t)
	o: 112()

nname: 88
n 88(bDelete)[]:
	i: 74(), 87()
	o: 94(t), 111(f)

nname: 87
n 87(None)[]:
	i: 59(f)
	o: 88()

nname: 74
n 74(None)[raise SchedulerRecordingRunningError()
]:
	i: 59(t)
	o: 88()

nname: 59
n 59(RECORDING_STATUS_RUNNING == recording.status)[]:
	i: 27(), 58()
	o: 74(t), 87(f)

nname: 58
n 58(None)[]:
	i: 0(f)
	o: 59()

nname: 27
n 27(None)[log.error('Bad Recording ID %d !' + str(nRecordingID))
return False
]:
	i: 0(t)
	o: 59()

nname: 0
n 0(recording == None)[recording = self.GetRecording(nRecordingID)
]:
	i: 
	o: 27(t), 58(f)

nname: 157
n 157(None)[self.recordings.pop(nRecordingID)
return True
]:
	i: 88()
	o: 

nname: 88
n 88(None)[if bDelete:
	recording.record_info.Delete()
if self.rec_id_from_program_id.has_key(recording.program_id):
	self.rec_id_from_program_id.pop(recording.program_id)
]:
	i: 0()
	o: 157()

nname: 0
n 0(None)[recording = self.GetRecording(nRecordingID)
if recording == None:
	log.error('Bad Recording ID %d !' + str(nRecordingID))
	return False
if RECORDING_STATUS_RUNNING == recording.status:
	raise SchedulerRecordingRunningError()
]:
	i: 
	o: 88()

nname: 157
n 157(None)[self.recordings.pop(nRecordingID)
return True
]:
	i: 0()
	o: 

nname: 0
n 0(None)[recording = self.GetRecording(nRecordingID)
if recording == None:
	log.error('Bad Recording ID %d !' + str(nRecordingID))
	return False
if RECORDING_STATUS_RUNNING == recording.status:
	raise SchedulerRecordingRunningError()
if bDelete:
	recording.record_info.Delete()
if self.rec_id_from_program_id.has_key(recording.program_id):
	self.rec_id_from_program_id.pop(recording.program_id)
]:
	i: 
	o: 157()

nname: 0
n 0(None)[recording = self.GetRecording(nRecordingID)
if recording == None:
	log.error('Bad Recording ID %d !' + str(nRecordingID))
	return False
if RECORDING_STATUS_RUNNING == recording.status:
	raise SchedulerRecordingRunningError()
if bDelete:
	recording.record_info.Delete()
if self.rec_id_from_program_id.has_key(recording.program_id):
	self.rec_id_from_program_id.pop(recording.program_id)
self.recordings.pop(nRecordingID)
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76f09cc>}
nname: 107
n 107(None)[return True
]:
	i: 0(AL), 106()
	o: 

nname: 106
n 106(None)[]:
	i: 20(AF), 102()
	o: 107()

nname: 102
n 102(None)[]:
	i: 36(f), 66()
	o: 106()

nname: 66
n 66(None)[log.info('RecordInfo found !!!!!')
return self.RemoveRecording(recording.id, bDelete)
continue
]:
	i: 36(t)
	o: 102()

nname: 36
n 36(recording.record_info.info_file_path_name == oRecordInfo.info_file_path_name)[for id, recording in self.recordings.items():
]:
	i: 20(for)
	o: 66(t), 102(f)

nname: 20
n 20(None)[]:
	i: 0(loop)
	o: 36(for), 106(AF)

nname: 0
n 0(None)[log.info('DeleteRecord(): %s ' % oRecordInfo)
]:
	i: 
	o: 20(loop), 107(AL)

nname: 107
n 107(None)[return True
]:
	i: 0(AL), 20(AF), 36()
	o: 

nname: 36
n 36(None)[for id, recording in self.recordings.items():
if recording.record_info.info_file_path_name == oRecordInfo.info_file_path_name:
	log.info('RecordInfo found !!!!!')
	return self.RemoveRecording(recording.id, bDelete)
	continue
]:
	i: 20(for)
	o: 107()

nname: 20
n 20(None)[]:
	i: 0(loop)
	o: 36(for), 107(AF)

nname: 0
n 0(None)[log.info('DeleteRecord(): %s ' % oRecordInfo)
]:
	i: 
	o: 20(loop), 107(AL)

nname: 36
n 36(None)[for id, recording in self.recordings.items():
	if recording.record_info.info_file_path_name == oRecordInfo.info_file_path_name:
		log.info('RecordInfo found !!!!!')
		return self.RemoveRecording(recording.id, bDelete)
		continue
return True
]:
	i: 0(for)
	o: 

nname: 0
n 0(None)[log.info('DeleteRecord(): %s ' % oRecordInfo)
]:
	i: 
	o: 36(for)

nname: 0
n 0(None)[log.info('DeleteRecord(): %s ' % oRecordInfo)
for id, recording in self.recordings.items():
	if recording.record_info.info_file_path_name == oRecordInfo.info_file_path_name:
		log.info('RecordInfo found !!!!!')
		return self.RemoveRecording(recording.id, bDelete)
		continue
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76ece8c>}
nname: 0
n 0(None)[return x.start_time
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76f01ac>}
nname: 86
n 86(None)[list.sort(key=(lambda x: x.start_time))
return list
]:
	i: 21(AL), 85()
	o: 

nname: 85
n 85(None)[]:
	i: 30(AF), 81()
	o: 86()

nname: 81
n 81(None)[]:
	i: 46(f), 64()
	o: 85()

nname: 64
n 64(None)[list.append(recording)
continue
]:
	i: 46(t)
	o: 81()

nname: 46
n 46(recording.periodicity_rule_id == rule_id)[for recording in self.recordings.itervalues():
]:
	i: 30(for)
	o: 64(t), 81(f)

nname: 30
n 30(None)[]:
	i: 21(loop)
	o: 46(for), 85(AF)

nname: 21
n 21(None)[list = []
]:
	i: 12(), 20()
	o: 30(loop), 86(AL)

nname: 20
n 20(None)[]:
	i: 0(f)
	o: 21()

nname: 12
n 12(None)[return []
]:
	i: 0(t)
	o: 21()

nname: 0
n 0(rule_id == 0)[]:
	i: 
	o: 12(t), 20(f)

nname: 86
n 86(None)[list.sort(key=(lambda x: x.start_time))
return list
]:
	i: 0(AL), 30(AF), 46()
	o: 

nname: 46
n 46(None)[for recording in self.recordings.itervalues():
if recording.periodicity_rule_id == rule_id:
	list.append(recording)
	continue
]:
	i: 30(for)
	o: 86()

nname: 30
n 30(None)[]:
	i: 0(loop)
	o: 46(for), 86(AF)

nname: 0
n 0(None)[if rule_id == 0:
	return []
list = []
]:
	i: 
	o: 30(loop), 86(AL)

self.nodes: {0: <unpyclib.structure.node instance at 0xb76eccac>, 46: <unpyclib.structure.node instance at 0xb76ecd4c>, 86: <unpyclib.structure.node instance at 0xb76f040c>, 30: <unpyclib.structure.node instance at 0xb76ecc0c>}
nname: 6
n 6(None)[__doc__ = ' used to keep the list of recording.\n    '
def __init__(self, recording_builder, oRecordingManager):
	self.recordings = {}
	self.rec_id_from_program_id = {}
	self.recording_launcher = oRecordingManager
	self.recording_builder = recording_builder
	self.chrono = conflictmanager.ChronologicalRecordingList(self.recording_launcher)

def AddRecording(self, oRecording, program_id='', favorite=''):
	if self.recordings.has_key(oRecording.id):
		log.error('Recording ID already used !')
		return False
	rec_id = 1

def GetRecording(self, nRecordingID):
	if not self.recordings.has_key(nRecordingID):
		log.error('Recording ID is not valid !')
		return None
	return self.recordings[nRecordingID]

def GetFirstRecordingToStart(self):
	if len(self.recordings) == 0:
		return None
	cur_start_time = 0
	cur_recording = None

def GetFirstRecordingToStop(self):
	if len(self.recordings) == 0:
		return None
	cur_stop_time = 0
	cur_recording = None

def LoadFromXML(self, oXMLNode):
	nodes_recording = oXMLNode.getiterator('recording')
	self.recordings.clear()
	for node_recording in nodes_recording:
		recording = self.recording_builder.buildNewRecording()
		if recording.LoadFromXML(node_recording):
			self.recordings[recording.id] = recording
			if recording.program_id:
				self.rec_id_from_program_id[recording.program_id] = recording.id
			else:
				continue
	return True

def SaveToXMLNode(self, oXMLNode):
	if oXMLNode == None:
		return False
	log.debug('number of record in list: ' + str(len(self.recordings)))
	for id, recording in self.recordings.items():
		node_recording = ET.Element('recording')
		recording.SaveToXMLNode(node_recording)
		oXMLNode.append(node_recording)
	return True

def GetConflict(self, oRecording, ignore_not_scheduled=False):
	if ignore_not_scheduled:
		schedule_or_running = filter((lambda rec: status == RECORDING_STATUS_RUNNING or rec.status == RECORDING_STATUS_SCHEDULED:
			pass
		return rec.type != RECORDING_TYPE_NOT_SCHEDULED), self.recordings.values())
	else:
		schedule_or_running = filter((lambda rec: rec.status == RECORDING_STATUS_RUNNING:
			pass
		return rec.status == RECORDING_STATUS_RUNNING), self.recordings.values())
	self.chrono.orderRecording(schedule_or_running)
	return self.chrono.getConflict(oRecording)

def GetConflictForMaxTime(self, oRecording):
	stop_time_temp = oRecording.stop_time
	oRecording.stop_time = 0
	schedule_or_running = filter((lambda rec: status == RECORDING_STATUS_RUNNING or rec.status == RECORDING_STATUS_SCHEDULED:
		pass
	return rec.type != RECORDING_TYPE_NOT_SCHEDULED), self.recordings.values())
	self.chrono.orderRecording(schedule_or_running)
	conflict = self.chrono.getConflict(oRecording)
	oRecording.stop_time = stop_time_temp
	return conflict

def GetConflictForNotScheduledRecording(self, oRecording, include_instant_record=False):
	if include_instant_record:
		schedule_or_running = filter((lambda rec: rec.status == RECORDING_STATUS_RUNNING:
			pass
		return rec.status == RECORDING_STATUS_RUNNING), self.recordings.values())
	else:
		schedule_or_running = filter((lambda rec: status == RECORDING_STATUS_RUNNING or rec.status == RECORDING_STATUS_SCHEDULED:
			pass
		return rec.type != RECORDING_TYPE_NOT_SCHEDULED), self.recordings.values())
	self.chrono.orderRecording(schedule_or_running)
	self.chrono.insertRecording(oRecording)
	conflict = self.chrono.getConflict(oRecording)
	return conflict

def CleanUp(self):
	log.info('CleanUp RecordingList')
	recording_to_remove = []
	for id, recording in self.recordings.items():
		if not recording.IsValid():
			recording_to_remove.append(recording)
			continue
	for recording in recording_to_remove:
		self.recordings.pop(recording.id)
	return True

def RemoveRecording(self, nRecordingID, bDelete=False):
	recording = self.GetRecording(nRecordingID)
	if recording == None:
		log.error('Bad Recording ID %d !' + str(nRecordingID))
		return False
	if RECORDING_STATUS_RUNNING == recording.status:
		raise SchedulerRecordingRunningError()
	if bDelete:
		recording.record_info.Delete()
	if self.rec_id_from_program_id.has_key(recording.program_id):
		self.rec_id_from_program_id.pop(recording.program_id)
	self.recordings.pop(nRecordingID)
	return True

def RemoveRecord(self, oRecordInfo, bDelete=False):
	log.info('DeleteRecord(): %s ' % oRecordInfo)
	for id, recording in self.recordings.items():
		if recording.record_info.info_file_path_name == oRecordInfo.info_file_path_name:
			log.info('RecordInfo found !!!!!')
			return self.RemoveRecording(recording.id, bDelete)
			continue
	return True

def GetPeriodicRecordingListByRule(self, rule_id=0):
	if rule_id == 0:
		return []
	list = []

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb776afcc>}
nname: 0
n 0(None)[__doc__ = '\nImplementation of RecordingList class.\n\n'
import sys
import error
from exceptions import *
from recording import Recording
import conflictmanager
import xml.etree.cElementTree as ET
from logger import log
from peewee.analyse import Chrono
from recording import RECORDING_STATUS_UNKNOWN
from recording import RECORDING_STATUS_SCHEDULED
from recording import RECORDING_STATUS_RUNNING
from recording import RECORDING_STATUS_IN_CONFLICT
from recording import RECORDING_STATUS_COMPLETED
from recording import RECORDING_STATUS_CANCELED
from recording import RECORDING_STATUS_MISSED
from recording import RECORDING_STATUS_ABORTED
from recording import RECORDING_TYPE_NORMAL
from recording import RECORDING_TYPE_FLASHBACK
from recording import RECORDING_TYPE_NOT_SCHEDULED
class RecordingList(object):
	__doc__ = ' used to keep the list of recording.\n    '
	def __init__(self, recording_builder, oRecordingManager):
		self.recordings = {}
		self.rec_id_from_program_id = {}
		self.recording_launcher = oRecordingManager
		self.recording_builder = recording_builder
		self.chrono = conflictmanager.ChronologicalRecordingList(self.recording_launcher)

	def AddRecording(self, oRecording, program_id='', favorite=''):
		if self.recordings.has_key(oRecording.id):
			log.error('Recording ID already used !')
			return False
		rec_id = 1

	def GetRecording(self, nRecordingID):
		if not self.recordings.has_key(nRecordingID):
			log.error('Recording ID is not valid !')
			return None
		return self.recordings[nRecordingID]

	def GetFirstRecordingToStart(self):
		if len(self.recordings) == 0:
			return None
		cur_start_time = 0
		cur_recording = None

	def GetFirstRecordingToStop(self):
		if len(self.recordings) == 0:
			return None
		cur_stop_time = 0
		cur_recording = None

	def LoadFromXML(self, oXMLNode):
		nodes_recording = oXMLNode.getiterator('recording')
		self.recordings.clear()
		for node_recording in nodes_recording:
			recording = self.recording_builder.buildNewRecording()
			if recording.LoadFromXML(node_recording):
				self.recordings[recording.id] = recording
				if recording.program_id:
					self.rec_id_from_program_id[recording.program_id] = recording.id
				else:
					continue
		return True

	def SaveToXMLNode(self, oXMLNode):
		if oXMLNode == None:
			return False
		log.debug('number of record in list: ' + str(len(self.recordings)))
		for id, recording in self.recordings.items():
			node_recording = ET.Element('recording')
			recording.SaveToXMLNode(node_recording)
			oXMLNode.append(node_recording)
		return True

	def GetConflict(self, oRecording, ignore_not_scheduled=False):
		if ignore_not_scheduled:
			schedule_or_running = filter((lambda rec: status == RECORDING_STATUS_RUNNING or rec.status == RECORDING_STATUS_SCHEDULED:
				pass
			return rec.type != RECORDING_TYPE_NOT_SCHEDULED), self.recordings.values())
		else:
			schedule_or_running = filter((lambda rec: rec.status == RECORDING_STATUS_RUNNING:
				pass
			return rec.status == RECORDING_STATUS_RUNNING), self.recordings.values())
		self.chrono.orderRecording(schedule_or_running)
		return self.chrono.getConflict(oRecording)

	def GetConflictForMaxTime(self, oRecording):
		stop_time_temp = oRecording.stop_time
		oRecording.stop_time = 0
		schedule_or_running = filter((lambda rec: status == RECORDING_STATUS_RUNNING or rec.status == RECORDING_STATUS_SCHEDULED:
			pass
		return rec.type != RECORDING_TYPE_NOT_SCHEDULED), self.recordings.values())
		self.chrono.orderRecording(schedule_or_running)
		conflict = self.chrono.getConflict(oRecording)
		oRecording.stop_time = stop_time_temp
		return conflict

	def GetConflictForNotScheduledRecording(self, oRecording, include_instant_record=False):
		if include_instant_record:
			schedule_or_running = filter((lambda rec: rec.status == RECORDING_STATUS_RUNNING:
				pass
			return rec.status == RECORDING_STATUS_RUNNING), self.recordings.values())
		else:
			schedule_or_running = filter((lambda rec: status == RECORDING_STATUS_RUNNING or rec.status == RECORDING_STATUS_SCHEDULED:
				pass
			return rec.type != RECORDING_TYPE_NOT_SCHEDULED), self.recordings.values())
		self.chrono.orderRecording(schedule_or_running)
		self.chrono.insertRecording(oRecording)
		conflict = self.chrono.getConflict(oRecording)
		return conflict

	def CleanUp(self):
		log.info('CleanUp RecordingList')
		recording_to_remove = []
		for id, recording in self.recordings.items():
			if not recording.IsValid():
				recording_to_remove.append(recording)
				continue
		for recording in recording_to_remove:
			self.recordings.pop(recording.id)
		return True

	def RemoveRecording(self, nRecordingID, bDelete=False):
		recording = self.GetRecording(nRecordingID)
		if recording == None:
			log.error('Bad Recording ID %d !' + str(nRecordingID))
			return False
		if RECORDING_STATUS_RUNNING == recording.status:
			raise SchedulerRecordingRunningError()
		if bDelete:
			recording.record_info.Delete()
		if self.rec_id_from_program_id.has_key(recording.program_id):
			self.rec_id_from_program_id.pop(recording.program_id)
		self.recordings.pop(nRecordingID)
		return True

	def RemoveRecord(self, oRecordInfo, bDelete=False):
		log.info('DeleteRecord(): %s ' % oRecordInfo)
		for id, recording in self.recordings.items():
			if recording.record_info.info_file_path_name == oRecordInfo.info_file_path_name:
				log.info('RecordInfo found !!!!!')
				return self.RemoveRecording(recording.id, bDelete)
				continue
		return True

	def GetPeriodicRecordingListByRule(self, rule_id=0):
		if rule_id == 0:
			return []
		list = []



]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb775e4cc>}
__doc__ = '\nImplementation of RecordingList class.\n\n'
import sys
import error
from exceptions import *
from recording import Recording
import conflictmanager
import xml.etree.cElementTree as ET
from logger import log
from peewee.analyse import Chrono
from recording import RECORDING_STATUS_UNKNOWN
from recording import RECORDING_STATUS_SCHEDULED
from recording import RECORDING_STATUS_RUNNING
from recording import RECORDING_STATUS_IN_CONFLICT
from recording import RECORDING_STATUS_COMPLETED
from recording import RECORDING_STATUS_CANCELED
from recording import RECORDING_STATUS_MISSED
from recording import RECORDING_STATUS_ABORTED
from recording import RECORDING_TYPE_NORMAL
from recording import RECORDING_TYPE_FLASHBACK
from recording import RECORDING_TYPE_NOT_SCHEDULED
class RecordingList(object):
	__doc__ = ' used to keep the list of recording.\n    '
	def __init__(self, recording_builder, oRecordingManager):
		self.recordings = {}
		self.rec_id_from_program_id = {}
		self.recording_launcher = oRecordingManager
		self.recording_builder = recording_builder
		self.chrono = conflictmanager.ChronologicalRecordingList(self.recording_launcher)

	def AddRecording(self, oRecording, program_id='', favorite=''):
		if self.recordings.has_key(oRecording.id):
			log.error('Recording ID already used !')
			return False
		rec_id = 1

	def GetRecording(self, nRecordingID):
		if not self.recordings.has_key(nRecordingID):
			log.error('Recording ID is not valid !')
			return None
		return self.recordings[nRecordingID]

	def GetFirstRecordingToStart(self):
		if len(self.recordings) == 0:
			return None
		cur_start_time = 0
		cur_recording = None

	def GetFirstRecordingToStop(self):
		if len(self.recordings) == 0:
			return None
		cur_stop_time = 0
		cur_recording = None

	def LoadFromXML(self, oXMLNode):
		nodes_recording = oXMLNode.getiterator('recording')
		self.recordings.clear()
		for node_recording in nodes_recording:
			recording = self.recording_builder.buildNewRecording()
			if recording.LoadFromXML(node_recording):
				self.recordings[recording.id] = recording
				if recording.program_id:
					self.rec_id_from_program_id[recording.program_id] = recording.id
				else:
					continue
		return True

	def SaveToXMLNode(self, oXMLNode):
		if oXMLNode == None:
			return False
		log.debug('number of record in list: ' + str(len(self.recordings)))
		for id, recording in self.recordings.items():
			node_recording = ET.Element('recording')
			recording.SaveToXMLNode(node_recording)
			oXMLNode.append(node_recording)
		return True

	def GetConflict(self, oRecording, ignore_not_scheduled=False):
		if ignore_not_scheduled:
			schedule_or_running = filter((lambda rec: status == RECORDING_STATUS_RUNNING or rec.status == RECORDING_STATUS_SCHEDULED:
				pass
			return rec.type != RECORDING_TYPE_NOT_SCHEDULED), self.recordings.values())
		else:
			schedule_or_running = filter((lambda rec: rec.status == RECORDING_STATUS_RUNNING:
				pass
			return rec.status == RECORDING_STATUS_RUNNING), self.recordings.values())
		self.chrono.orderRecording(schedule_or_running)
		return self.chrono.getConflict(oRecording)

	def GetConflictForMaxTime(self, oRecording):
		stop_time_temp = oRecording.stop_time
		oRecording.stop_time = 0
		schedule_or_running = filter((lambda rec: status == RECORDING_STATUS_RUNNING or rec.status == RECORDING_STATUS_SCHEDULED:
			pass
		return rec.type != RECORDING_TYPE_NOT_SCHEDULED), self.recordings.values())
		self.chrono.orderRecording(schedule_or_running)
		conflict = self.chrono.getConflict(oRecording)
		oRecording.stop_time = stop_time_temp
		return conflict

	def GetConflictForNotScheduledRecording(self, oRecording, include_instant_record=False):
		if include_instant_record:
			schedule_or_running = filter((lambda rec: rec.status == RECORDING_STATUS_RUNNING:
				pass
			return rec.status == RECORDING_STATUS_RUNNING), self.recordings.values())
		else:
			schedule_or_running = filter((lambda rec: status == RECORDING_STATUS_RUNNING or rec.status == RECORDING_STATUS_SCHEDULED:
				pass
			return rec.type != RECORDING_TYPE_NOT_SCHEDULED), self.recordings.values())
		self.chrono.orderRecording(schedule_or_running)
		self.chrono.insertRecording(oRecording)
		conflict = self.chrono.getConflict(oRecording)
		return conflict

	def CleanUp(self):
		log.info('CleanUp RecordingList')
		recording_to_remove = []
		for id, recording in self.recordings.items():
			if not recording.IsValid():
				recording_to_remove.append(recording)
				continue
		for recording in recording_to_remove:
			self.recordings.pop(recording.id)
		return True

	def RemoveRecording(self, nRecordingID, bDelete=False):
		recording = self.GetRecording(nRecordingID)
		if recording == None:
			log.error('Bad Recording ID %d !' + str(nRecordingID))
			return False
		if RECORDING_STATUS_RUNNING == recording.status:
			raise SchedulerRecordingRunningError()
		if bDelete:
			recording.record_info.Delete()
		if self.rec_id_from_program_id.has_key(recording.program_id):
			self.rec_id_from_program_id.pop(recording.program_id)
		self.recordings.pop(nRecordingID)
		return True

	def RemoveRecord(self, oRecordInfo, bDelete=False):
		log.info('DeleteRecord(): %s ' % oRecordInfo)
		for id, recording in self.recordings.items():
			if recording.record_info.info_file_path_name == oRecordInfo.info_file_path_name:
				log.info('RecordInfo found !!!!!')
				return self.RemoveRecording(recording.id, bDelete)
				continue
		return True

	def GetPeriodicRecordingListByRule(self, rule_id=0):
		if rule_id == 0:
			return []
		list = []



