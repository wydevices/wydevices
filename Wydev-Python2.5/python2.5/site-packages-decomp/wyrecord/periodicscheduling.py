# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 0
n 0(None)[self.id = 0
self.limit = limit
self.child = None
self.extern_rule_name = ''
self.is_active = False
self.last_time = None
self.recording_ref = None
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb757150c>}
nname: 0
n 0(None)[return self.extern_rule_name
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb756ef6c>}
nname: 0
n 0(None)[]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb756efac>}
nname: 0
n 0(None)[]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb756ef2c>}
nname: 65
n 65(None)[return True
]:
	i: 52(JA), 61(), 64()
	o: 

nname: 64
n 64(None)[]:
	i: 0(f)
	o: 65()

nname: 61
n 61(None)[]:
	i: 36(JA), 60()
	o: 65()

nname: 60
n 60(None)[]:
	i: 9(f)
	o: 61()

nname: 52
n 52(None)[return False
]:
	i: 29(f)
	o: 65(JA)

nname: 36
n 36(None)[raise PeriodicSchedulingException('over limit')
]:
	i: 29(t)
	o: 61(JA)

nname: 29
n 29(raiseException)[]:
	i: 9(t)
	o: 36(t), 52(f)

nname: 9
n 9(timeToCheck - timeRef >= self.limit)[]:
	i: 0(t)
	o: 29(t), 60(f)

nname: 0
n 0(self.limit)[]:
	i: 
	o: 9(t), 64(f)

nname: 65
n 65(None)[return True
]:
	i: 52(JA), 36(JA), 9(f), 0(f)
	o: 

nname: 52
n 52(None)[return False
]:
	i: 29(f)
	o: 65(JA)

nname: 36
n 36(None)[raise PeriodicSchedulingException('over limit')
]:
	i: 29(t)
	o: 65(JA)

nname: 29
n 29(raiseException)[]:
	i: 9(t)
	o: 36(t), 52(f)

nname: 9
n 9(timeToCheck - timeRef >= self.limit)[]:
	i: 0(t)
	o: 29(t), 65(f)

nname: 0
n 0(self.limit)[]:
	i: 
	o: 9(t), 65(f)

nname: 0
n 0(None)[if self.limit:
	if timeToCheck - timeRef >= self.limit:
		if raiseException:
			raise PeriodicSchedulingException('over limit')
		else:
			return False
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7571b2c>}
nname: 267
n 267(None)[return ret
]:
	i: 60(JA), 82(), 220(), 266()
	o: 

nname: 266
n 266(None)[]:
	i: 181&187&200&213(f)
	o: 267()

nname: 220
n 220(None)[ret = self._NextAfterTarget(minToGo, current)
ret = self.child.GetNextTime(minToGo, ret, forceTrue)
]:
	i: 181&187&200&213(t)
	o: 267()

nname: 181&187&200&213
n 181&187&200&213(exception or ret < minToGo or ret == minToGo and forceTrue)[]:
	i: 124(JA), 162(JA), 177(), 180()
	o: 220(t), 266(f)

nname: 180
n 180(None)[]:
	i: 86(f)
	o: 181&187&200&213()

nname: 177
n 177(None)[]:
	i: 175(AE)
	o: 181&187&200&213()

nname: 175
n 175(None)[]:
	i: 152(f)
	o: 177(AE)

nname: 162
n 162(None)[exception = True
]:
	i: 152(t)
	o: 181&187&200&213(JA)

nname: 152
n 152(<dummy_ex3> EXC_MATCH PeriodicSchedulingException)[]:
	i: 120(except)
	o: 162(t), 175(f)

nname: 124
n 124(None)[ret = self.child.GetNextTime(minToGo, ret, forceTrue)
]:
	i: 120(try)
	o: 181&187&200&213(JA)

nname: 120
n 120(None)[]:
	i: 86(t)
	o: 124(try), 152(except)

nname: 86
n 86(self.child)[ret = self._NextBeforeOrEqualTarget(minToGo, current)
exception = False
]:
	i: 0(t)
	o: 120(t), 180(f)

nname: 82
n 82(None)[]:
	i: 9&40&53(f)
	o: 267()

nname: 60
n 60(None)[ret = self._NextAfterTarget(minToGo, current)
]:
	i: 9&40&53(t)
	o: 267(JA)

nname: 9&40&53
n 9&40&53(ret < minToGo or ret == minToGo and forceTrue)[ret = self._NextBeforeOrEqualTarget(minToGo, current)
]:
	i: 0(f)
	o: 60(t), 82(f)

nname: 0
n 0(self.child)[]:
	i: 
	o: 9&40&53(f), 86(t)

nname: 267
n 267(None)[return ret
]:
	i: 9&40&53(JA), 181&187&200&213()
	o: 

nname: 181&187&200&213
n 181&187&200&213(None)[if exception or ret < minToGo or ret == minToGo and forceTrue:
	ret = self._NextAfterTarget(minToGo, current)
	ret = self.child.GetNextTime(minToGo, ret, forceTrue)
]:
	i: 124(JA), 162(JA), 152(f), 175(AE), 86(f)
	o: 267()

nname: 162
n 162(None)[exception = True
]:
	i: 152(t)
	o: 181&187&200&213(JA)

nname: 152
n 152(<dummy_ex3> EXC_MATCH PeriodicSchedulingException)[]:
	i: 120(except)
	o: 162(t), 181&187&200&213(f)

nname: 124
n 124(None)[ret = self.child.GetNextTime(minToGo, ret, forceTrue)
]:
	i: 120(try)
	o: 181&187&200&213(JA)

nname: 120
n 120(None)[]:
	i: 86(t)
	o: 124(try), 152(except)

nname: 86
n 86(self.child)[ret = self._NextBeforeOrEqualTarget(minToGo, current)
exception = False
]:
	i: 0(t)
	o: 120(t), 181&187&200&213(f)

nname: 9&40&53
n 9&40&53(None)[ret = self._NextBeforeOrEqualTarget(minToGo, current)
if ret < minToGo or ret == minToGo and forceTrue:
	ret = self._NextAfterTarget(minToGo, current)
]:
	i: 0(f)
	o: 267(JA)

nname: 0
n 0(self.child)[]:
	i: 
	o: 9&40&53(f), 86(t)

nname: 267
n 267(None)[return ret
]:
	i: 9&40&53(JA), 181&187&200&213()
	o: 

nname: 181&187&200&213
n 181&187&200&213(None)[if exception or ret < minToGo or ret == minToGo and forceTrue:
	ret = self._NextAfterTarget(minToGo, current)
	ret = self.child.GetNextTime(minToGo, ret, forceTrue)
]:
	i: 152(f), 86(f)
	o: 267()

nname: 152
n 152(None)[except PeriodicSchedulingException:
	exception = True
]:
	i: 120()
	o: 181&187&200&213(JA)

nname: 120
n 120(None)[try:
	ret = self.child.GetNextTime(minToGo, ret, forceTrue)
]:
	i: 86(t)
	o: 152()

nname: 86
n 86(self.child)[ret = self._NextBeforeOrEqualTarget(minToGo, current)
exception = False
]:
	i: 0(t)
	o: 120(t), 181&187&200&213(f)

nname: 9&40&53
n 9&40&53(None)[ret = self._NextBeforeOrEqualTarget(minToGo, current)
if ret < minToGo or ret == minToGo and forceTrue:
	ret = self._NextAfterTarget(minToGo, current)
]:
	i: 0(f)
	o: 267(JA)

nname: 0
n 0(self.child)[]:
	i: 
	o: 9&40&53(f), 86(t)

nname: 267
n 267(None)[return ret
]:
	i: 9&40&53(JA), 181&187&200&213()
	o: 

nname: 181&187&200&213
n 181&187&200&213(None)[if exception or ret < minToGo or ret == minToGo and forceTrue:
	ret = self._NextAfterTarget(minToGo, current)
	ret = self.child.GetNextTime(minToGo, ret, forceTrue)
]:
	i: 120(f), 86(f)
	o: 267()

nname: 120
n 120(None)[try:
	ret = self.child.GetNextTime(minToGo, ret, forceTrue)
except PeriodicSchedulingException:
	exception = True
]:
	i: 86(t)
	o: 181&187&200&213(JA)

nname: 86
n 86(self.child)[ret = self._NextBeforeOrEqualTarget(minToGo, current)
exception = False
]:
	i: 0(t)
	o: 120(t), 181&187&200&213(f)

nname: 9&40&53
n 9&40&53(None)[ret = self._NextBeforeOrEqualTarget(minToGo, current)
if ret < minToGo or ret == minToGo and forceTrue:
	ret = self._NextAfterTarget(minToGo, current)
]:
	i: 0(f)
	o: 267(JA)

nname: 0
n 0(self.child)[]:
	i: 
	o: 9&40&53(f), 86(t)

nname: 267
n 267(None)[return ret
]:
	i: 9&40&53(JA), 86()
	o: 

nname: 86
n 86(None)[ret = self._NextBeforeOrEqualTarget(minToGo, current)
exception = False
if self.child:
	try:
		ret = self.child.GetNextTime(minToGo, ret, forceTrue)
	except PeriodicSchedulingException:
		exception = True
if exception or ret < minToGo or ret == minToGo and forceTrue:
	ret = self._NextAfterTarget(minToGo, current)
	ret = self.child.GetNextTime(minToGo, ret, forceTrue)
]:
	i: 0(t)
	o: 267()

nname: 9&40&53
n 9&40&53(None)[ret = self._NextBeforeOrEqualTarget(minToGo, current)
if ret < minToGo or ret == minToGo and forceTrue:
	ret = self._NextAfterTarget(minToGo, current)
]:
	i: 0(f)
	o: 267(JA)

nname: 0
n 0(self.child)[]:
	i: 
	o: 9&40&53(f), 86(t)

nname: 0
n 0(None)[if not self.child:
	ret = self._NextBeforeOrEqualTarget(minToGo, current)
	if ret < minToGo or ret == minToGo and forceTrue:
		ret = self._NextAfterTarget(minToGo, current)
else:
	ret = self._NextBeforeOrEqualTarget(minToGo, current)
	exception = False
	if self.child:
		try:
			ret = self.child.GetNextTime(minToGo, ret, forceTrue)
		except PeriodicSchedulingException:
			exception = True
	if exception or ret < minToGo or ret == minToGo and forceTrue:
		ret = self._NextAfterTarget(minToGo, current)
		ret = self.child.GetNextTime(minToGo, ret, forceTrue)
return ret
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb757844c>}
nname: 365
n 365(None)[return True
]:
	i: 316(), 364()
	o: 

nname: 364
n 364(None)[]:
	i: 301(f)
	o: 365()

nname: 316
n 316(None)[node_child = ET.Element('child')
self.child.SaveToXMLNode(node_child)
oXMLNode.append(node_child)
]:
	i: 301(t)
	o: 365()

nname: 301
n 301(self.child != None)[]:
	i: 252(), 300()
	o: 316(t), 364(f)

nname: 300
n 300(None)[]:
	i: 237(f)
	o: 301()

nname: 252
n 252(None)[node_limit = ET.Element('limit')
TimeDeltaToXml(node_limit, self.limit)
oXMLNode.append(node_limit)
]:
	i: 237(t)
	o: 301()

nname: 237
n 237(self.limit != None)[]:
	i: 188(), 236()
	o: 252(t), 300(f)

nname: 236
n 236(None)[]:
	i: 179(f)
	o: 237()

nname: 188
n 188(None)[node_recording_ref = ET.Element('recording_ref')
self.recording_ref.SaveToXMLNode(node_recording_ref)
oXMLNode.append(node_recording_ref)
]:
	i: 179(t)
	o: 237()

nname: 179
n 179(self.recording_ref)[]:
	i: 130(), 178()
	o: 188(t), 236(f)

nname: 178
n 178(None)[]:
	i: 108(f)
	o: 179()

nname: 130
n 130(None)[node_last_time = ET.Element('last_time')
DateTimeToXml(node_last_time, self.last_time)
oXMLNode.append(node_last_time)
]:
	i: 108(t)
	o: 179()

nname: 108
n 108(self.last_time)[oXMLNode.append(node_is_active)
]:
	i: 85(), 98()
	o: 130(t), 178(f)

nname: 98
n 98(None)[node_is_active.text = 'false'
]:
	i: 21(f)
	o: 108()

nname: 85
n 85(None)[node_is_active.text = 'true'
]:
	i: 21(t)
	o: 108()

nname: 21
n 21(self.is_active)[node_ext_name = ET.Element('extern_name')
node_ext_name.text = self.extern_rule_name
oXMLNode.append(node_ext_name)
node_is_active = ET.Element('is_active')
]:
	i: 12(), 20()
	o: 85(t), 98(f)

nname: 20
n 20(None)[]:
	i: 0(f)
	o: 21()

nname: 12
n 12(None)[return False
]:
	i: 0(t)
	o: 21()

nname: 0
n 0(oXMLNode == None)[]:
	i: 
	o: 12(t), 20(f)

nname: 365
n 365(None)[return True
]:
	i: 237()
	o: 

nname: 237
n 237(None)[if self.limit != None:
	node_limit = ET.Element('limit')
	TimeDeltaToXml(node_limit, self.limit)
	oXMLNode.append(node_limit)
if self.child != None:
	node_child = ET.Element('child')
	self.child.SaveToXMLNode(node_child)
	oXMLNode.append(node_child)
]:
	i: 108()
	o: 365()

nname: 108
n 108(None)[oXMLNode.append(node_is_active)
if self.last_time:
	node_last_time = ET.Element('last_time')
	DateTimeToXml(node_last_time, self.last_time)
	oXMLNode.append(node_last_time)
if self.recording_ref:
	node_recording_ref = ET.Element('recording_ref')
	self.recording_ref.SaveToXMLNode(node_recording_ref)
	oXMLNode.append(node_recording_ref)
]:
	i: 0()
	o: 237()

nname: 0
n 0(None)[if oXMLNode == None:
	return False
node_ext_name = ET.Element('extern_name')
node_ext_name.text = self.extern_rule_name
oXMLNode.append(node_ext_name)
node_is_active = ET.Element('is_active')
if self.is_active:
	node_is_active.text = 'true'
else:
	node_is_active.text = 'false'
]:
	i: 
	o: 108()

nname: 237
n 237(None)[if self.limit != None:
	node_limit = ET.Element('limit')
	TimeDeltaToXml(node_limit, self.limit)
	oXMLNode.append(node_limit)
if self.child != None:
	node_child = ET.Element('child')
	self.child.SaveToXMLNode(node_child)
	oXMLNode.append(node_child)
return True
]:
	i: 0()
	o: 

nname: 0
n 0(None)[if oXMLNode == None:
	return False
node_ext_name = ET.Element('extern_name')
node_ext_name.text = self.extern_rule_name
oXMLNode.append(node_ext_name)
node_is_active = ET.Element('is_active')
if self.is_active:
	node_is_active.text = 'true'
else:
	node_is_active.text = 'false'
oXMLNode.append(node_is_active)
if self.last_time:
	node_last_time = ET.Element('last_time')
	DateTimeToXml(node_last_time, self.last_time)
	oXMLNode.append(node_last_time)
if self.recording_ref:
	node_recording_ref = ET.Element('recording_ref')
	self.recording_ref.SaveToXMLNode(node_recording_ref)
	oXMLNode.append(node_recording_ref)
]:
	i: 
	o: 237()

nname: 0
n 0(None)[if oXMLNode == None:
	return False
node_ext_name = ET.Element('extern_name')
node_ext_name.text = self.extern_rule_name
oXMLNode.append(node_ext_name)
node_is_active = ET.Element('is_active')
if self.is_active:
	node_is_active.text = 'true'
else:
	node_is_active.text = 'false'
oXMLNode.append(node_is_active)
if self.last_time:
	node_last_time = ET.Element('last_time')
	DateTimeToXml(node_last_time, self.last_time)
	oXMLNode.append(node_last_time)
if self.recording_ref:
	node_recording_ref = ET.Element('recording_ref')
	self.recording_ref.SaveToXMLNode(node_recording_ref)
	oXMLNode.append(node_recording_ref)
if self.limit != None:
	node_limit = ET.Element('limit')
	TimeDeltaToXml(node_limit, self.limit)
	oXMLNode.append(node_limit)
if self.child != None:
	node_child = ET.Element('child')
	self.child.SaveToXMLNode(node_child)
	oXMLNode.append(node_child)
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0x8686f2c>}
nname: 398
n 398(None)[return True
]:
	i: 352(), 397()
	o: 

nname: 397
n 397(None)[]:
	i: 325(f)
	o: 398()

nname: 352
n 352(None)[rule = GetPeriodicSchedulingInstanceFactory(node_child.attrib['type'])
rule.LoadFromXML(node_child)
self.child = rule
]:
	i: 325(t)
	o: 398()

nname: 325
n 325(node_child != None)[node_child = oXMLNode.find('child')
]:
	i: 305(), 324()
	o: 352(t), 397(f)

nname: 324
n 324(None)[]:
	i: 269(f)
	o: 325()

nname: 305
n 305(None)[self.limit = GetTimeDeltaFromXmlNode(node_limit)
]:
	i: 269(t)
	o: 325()

nname: 269
n 269(node_limit != None)[self.limit = None
node_limit = oXMLNode.find('limit')
]:
	i: 224(), 268()
	o: 305(t), 324(f)

nname: 268
n 268(None)[]:
	i: 194(f)
	o: 269()

nname: 224
n 224(None)[rec = Recording(None, None, None)
rec.LoadFromXML(node_recording_ref)
self.recording_ref = rec
]:
	i: 194(t)
	o: 269()

nname: 194
n 194(node_recording_ref)[self.recording_ref = None
node_recording_ref = oXMLNode.find('recording_ref')
]:
	i: 174(), 193()
	o: 224(t), 268(f)

nname: 193
n 193(None)[]:
	i: 144(f)
	o: 194()

nname: 174
n 174(None)[self.last_time = GetDateTimeFromXmlNode(node_last_time)
]:
	i: 144(t)
	o: 194()

nname: 144
n 144(node_last_time)[self.last_time = None
node_last_time = oXMLNode.find('last_time')
]:
	i: 126(JA), 139(), 143()
	o: 174(t), 193(f)

nname: 143
n 143(None)[]:
	i: 74(f)
	o: 144()

nname: 139
n 139(None)[]:
	i: 110(f)
	o: 144()

nname: 126
n 126(None)[self.is_active = True
]:
	i: 110(t)
	o: 144(JA)

nname: 110
n 110(node_is_active.text == 'true')[]:
	i: 74(t)
	o: 126(t), 139(f)

nname: 74
n 74(node_is_active != None)[self.is_active = False
node_is_active = oXMLNode.find('is_active')
]:
	i: 57(), 73()
	o: 110(t), 143(f)

nname: 73
n 73(None)[]:
	i: 21(f)
	o: 74()

nname: 57
n 57(None)[self.extern_rule_name = node_ext_name.text
]:
	i: 21(t)
	o: 74()

nname: 21
n 21(node_ext_name != None)[self.extern_rule_name = ''
node_ext_name = oXMLNode.find('extern_name')
]:
	i: 12(), 20()
	o: 57(t), 73(f)

nname: 20
n 20(None)[]:
	i: 0(f)
	o: 21()

nname: 12
n 12(None)[return False
]:
	i: 0(t)
	o: 21()

nname: 0
n 0(oXMLNode == None)[]:
	i: 
	o: 12(t), 20(f)

nname: 325
n 325(None)[node_child = oXMLNode.find('child')
if node_child != None:
	rule = GetPeriodicSchedulingInstanceFactory(node_child.attrib['type'])
	rule.LoadFromXML(node_child)
	self.child = rule
return True
]:
	i: 194()
	o: 

nname: 194
n 194(None)[self.recording_ref = None
node_recording_ref = oXMLNode.find('recording_ref')
if node_recording_ref:
	rec = Recording(None, None, None)
	rec.LoadFromXML(node_recording_ref)
	self.recording_ref = rec
self.limit = None
node_limit = oXMLNode.find('limit')
if node_limit != None:
	self.limit = GetTimeDeltaFromXmlNode(node_limit)
]:
	i: 74()
	o: 325()

nname: 74
n 74(None)[self.is_active = False
node_is_active = oXMLNode.find('is_active')
if node_is_active != None:
	if node_is_active.text == 'true':
		self.is_active = True
self.last_time = None
node_last_time = oXMLNode.find('last_time')
if node_last_time:
	self.last_time = GetDateTimeFromXmlNode(node_last_time)
]:
	i: 0()
	o: 194()

nname: 0
n 0(None)[if oXMLNode == None:
	return False
self.extern_rule_name = ''
node_ext_name = oXMLNode.find('extern_name')
if node_ext_name != None:
	self.extern_rule_name = node_ext_name.text
]:
	i: 
	o: 74()

nname: 194
n 194(None)[self.recording_ref = None
node_recording_ref = oXMLNode.find('recording_ref')
if node_recording_ref:
	rec = Recording(None, None, None)
	rec.LoadFromXML(node_recording_ref)
	self.recording_ref = rec
self.limit = None
node_limit = oXMLNode.find('limit')
if node_limit != None:
	self.limit = GetTimeDeltaFromXmlNode(node_limit)
node_child = oXMLNode.find('child')
if node_child != None:
	rule = GetPeriodicSchedulingInstanceFactory(node_child.attrib['type'])
	rule.LoadFromXML(node_child)
	self.child = rule
return True
]:
	i: 0()
	o: 

nname: 0
n 0(None)[if oXMLNode == None:
	return False
self.extern_rule_name = ''
node_ext_name = oXMLNode.find('extern_name')
if node_ext_name != None:
	self.extern_rule_name = node_ext_name.text
self.is_active = False
node_is_active = oXMLNode.find('is_active')
if node_is_active != None:
	if node_is_active.text == 'true':
		self.is_active = True
self.last_time = None
node_last_time = oXMLNode.find('last_time')
if node_last_time:
	self.last_time = GetDateTimeFromXmlNode(node_last_time)
]:
	i: 
	o: 194()

nname: 0
n 0(None)[if oXMLNode == None:
	return False
self.extern_rule_name = ''
node_ext_name = oXMLNode.find('extern_name')
if node_ext_name != None:
	self.extern_rule_name = node_ext_name.text
self.is_active = False
node_is_active = oXMLNode.find('is_active')
if node_is_active != None:
	if node_is_active.text == 'true':
		self.is_active = True
self.last_time = None
node_last_time = oXMLNode.find('last_time')
if node_last_time:
	self.last_time = GetDateTimeFromXmlNode(node_last_time)
self.recording_ref = None
node_recording_ref = oXMLNode.find('recording_ref')
if node_recording_ref:
	rec = Recording(None, None, None)
	rec.LoadFromXML(node_recording_ref)
	self.recording_ref = rec
self.limit = None
node_limit = oXMLNode.find('limit')
if node_limit != None:
	self.limit = GetTimeDeltaFromXmlNode(node_limit)
node_child = oXMLNode.find('child')
if node_child != None:
	rule = GetPeriodicSchedulingInstanceFactory(node_child.attrib['type'])
	rule.LoadFromXML(node_child)
	self.child = rule
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb757734c>}
nname: 6
n 6(None)[__doc__ = ' main class\n    \n    manage the GetNextTime algorithm\n    manage the generic limit time check\n    manage reccursive child mecanism\n    \n    A PeriodicScheduling is used do define a rule of repetition for an event.\n    the rule is applied using the only exported interface : GetNextTime\n    \n    the optional attribute limit defines the maximum delta time allowed for the rule\n    it means that return value of GetNextTime is always less than the "current + self.limit" (where current is a param of GetNextTime) \n    '
def __init__(self, limit=None):
	self.id = 0
	self.limit = limit
	self.child = None
	self.extern_rule_name = ''
	self.is_active = False
	self.last_time = None
	self.recording_ref = None
	return None

def GetExternName(self):
	return self.extern_rule_name

def _NextBeforeOrEqualTarget(self, minToGo, current):
	pass

def _NextAfterTarget(self, minToGo, current):
	pass

def _CheckTimeLimitIsOK(self, timeToCheck, timeRef, raiseException=True):
	if self.limit:
		if timeToCheck - timeRef >= self.limit:
			if raiseException:
				raise PeriodicSchedulingException('over limit')
			else:
				return False
	return True

def GetNextTime(self, minToGo, current, forceTrue=False):
	if not self.child:
		ret = self._NextBeforeOrEqualTarget(minToGo, current)
		if ret < minToGo or ret == minToGo and forceTrue:
			ret = self._NextAfterTarget(minToGo, current)
	else:
		ret = self._NextBeforeOrEqualTarget(minToGo, current)
		exception = False
		if self.child:
			try:
				ret = self.child.GetNextTime(minToGo, ret, forceTrue)
			except PeriodicSchedulingException:
				exception = True
		if exception or ret < minToGo or ret == minToGo and forceTrue:
			ret = self._NextAfterTarget(minToGo, current)
			ret = self.child.GetNextTime(minToGo, ret, forceTrue)
	return ret

def SaveToXMLNode(self, oXMLNode):
	if oXMLNode == None:
		return False
	node_ext_name = ET.Element('extern_name')
	node_ext_name.text = self.extern_rule_name
	oXMLNode.append(node_ext_name)
	node_is_active = ET.Element('is_active')
	if self.is_active:
		node_is_active.text = 'true'
	else:
		node_is_active.text = 'false'
	oXMLNode.append(node_is_active)
	if self.last_time:
		node_last_time = ET.Element('last_time')
		DateTimeToXml(node_last_time, self.last_time)
		oXMLNode.append(node_last_time)
	if self.recording_ref:
		node_recording_ref = ET.Element('recording_ref')
		self.recording_ref.SaveToXMLNode(node_recording_ref)
		oXMLNode.append(node_recording_ref)
	if self.limit != None:
		node_limit = ET.Element('limit')
		TimeDeltaToXml(node_limit, self.limit)
		oXMLNode.append(node_limit)
	if self.child != None:
		node_child = ET.Element('child')
		self.child.SaveToXMLNode(node_child)
		oXMLNode.append(node_child)
	return True

def LoadFromXML(self, oXMLNode):
	if oXMLNode == None:
		return False
	self.extern_rule_name = ''
	node_ext_name = oXMLNode.find('extern_name')
	if node_ext_name != None:
		self.extern_rule_name = node_ext_name.text
	self.is_active = False
	node_is_active = oXMLNode.find('is_active')
	if node_is_active != None:
		if node_is_active.text == 'true':
			self.is_active = True
	self.last_time = None
	node_last_time = oXMLNode.find('last_time')
	if node_last_time:
		self.last_time = GetDateTimeFromXmlNode(node_last_time)
	self.recording_ref = None
	node_recording_ref = oXMLNode.find('recording_ref')
	if node_recording_ref:
		rec = Recording(None, None, None)
		rec.LoadFromXML(node_recording_ref)
		self.recording_ref = rec
	self.limit = None
	node_limit = oXMLNode.find('limit')
	if node_limit != None:
		self.limit = GetTimeDeltaFromXmlNode(node_limit)
	node_child = oXMLNode.find('child')
	if node_child != None:
		rule = GetPeriodicSchedulingInstanceFactory(node_child.attrib['type'])
		rule.LoadFromXML(node_child)
		self.child = rule
	return True

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb756ec8c>}
nname: 75
n 75(None)[]:
	i: 60(), 74()
	o: 

nname: 74
n 74(None)[]:
	i: 54(f)
	o: 75()

nname: 60
n 60(None)[deltaList.sort()
]:
	i: 54(t)
	o: 75()

nname: 54
n 54(deltaList)[]:
	i: 19(), 32()
	o: 60(t), 74(f)

nname: 32
n 32(None)[self.deltalist = [datetime.timedelta(0)]
]:
	i: 0(f)
	o: 54()

nname: 19
n 19(None)[self.deltaList = deltaList
]:
	i: 0(t)
	o: 54()

nname: 0
n 0(deltaList)[PeriodicScheduling.__init__(self)
]:
	i: 
	o: 19(t), 32(f)

nname: 75
n 75(None)[]:
	i: 0()
	o: 

nname: 0
n 0(None)[PeriodicScheduling.__init__(self)
if deltaList:
	self.deltaList = deltaList
else:
	self.deltalist = [datetime.timedelta(0)]
if deltaList:
	deltaList.sort()
]:
	i: 
	o: 75()

nname: 0
n 0(None)[PeriodicScheduling.__init__(self)
if deltaList:
	self.deltaList = deltaList
else:
	self.deltalist = [datetime.timedelta(0)]
if deltaList:
	deltaList.sort()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb756e94c>}
nname: 75
n 75(None)[return last
]:
	i: 0(AL), 74()
	o: 

nname: 74
n 74(None)[]:
	i: 24(AF), 70()
	o: 75()

nname: 70
n 70(None)[]:
	i: 34(f), 65()
	o: 74()

nname: 65
n 65(None)[break
continue
]:
	i: 34(t)
	o: 70()

nname: 34
n 34(ret > minToGo)[for i in self.deltaList:
last = ret
ret = current + i
]:
	i: 24(for)
	o: 65(t), 70(f)

nname: 24
n 24(None)[]:
	i: 0(loop)
	o: 34(for), 74(AF)

nname: 0
n 0(None)[ret, last = current + self.deltaList[0], current + self.deltaList[0]
]:
	i: 
	o: 24(loop), 75(AL)

nname: 75
n 75(None)[return last
]:
	i: 0(AL), 24(AF), 34()
	o: 

nname: 34
n 34(None)[for i in self.deltaList:
last = ret
ret = current + i
if ret > minToGo:
	break
	continue
]:
	i: 24(for)
	o: 75()

nname: 24
n 24(None)[]:
	i: 0(loop)
	o: 34(for), 75(AF)

nname: 0
n 0(None)[ret, last = current + self.deltaList[0], current + self.deltaList[0]
]:
	i: 
	o: 24(loop), 75(AL)

nname: 34
n 34(None)[for i in self.deltaList:
	last = ret
	ret = current + i
	if ret > minToGo:
		break
		continue
return last
]:
	i: 0(for)
	o: 

nname: 0
n 0(None)[ret, last = current + self.deltaList[0], current + self.deltaList[0]
]:
	i: 
	o: 34(for)

nname: 0
n 0(None)[ret, last = current + self.deltaList[0], current + self.deltaList[0]
for i in self.deltaList:
	last = ret
	ret = current + i
	if ret > minToGo:
		break
		continue
return last
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb756edac>}
nname: 77
n 77(None)[return ret
]:
	i: 0(AL), 64()
	o: 

nname: 64
n 64(None)[raise PeriodicSchedulingException('higher failed')
]:
	i: 20(AF), 60()
	o: 77()

nname: 60
n 60(None)[]:
	i: 30(f), 55()
	o: 64()

nname: 55
n 55(None)[break
continue
]:
	i: 30(t)
	o: 60()

nname: 30
n 30(ret > minToGo)[for i in self.deltaList:
ret = current + i
]:
	i: 20(for)
	o: 55(t), 60(f)

nname: 20
n 20(None)[]:
	i: 0(loop)
	o: 30(for), 64(AF)

nname: 0
n 0(None)[ret = current + self.deltaList[0]
]:
	i: 
	o: 20(loop), 77(AL)

nname: 77
n 77(None)[return ret
]:
	i: 0(AL), 64()
	o: 

nname: 64
n 64(None)[raise PeriodicSchedulingException('higher failed')
]:
	i: 20(AF), 30()
	o: 77()

nname: 30
n 30(None)[for i in self.deltaList:
ret = current + i
if ret > minToGo:
	break
	continue
]:
	i: 20(for)
	o: 64()

nname: 20
n 20(None)[]:
	i: 0(loop)
	o: 30(for), 64(AF)

nname: 0
n 0(None)[ret = current + self.deltaList[0]
]:
	i: 
	o: 20(loop), 77(AL)

nname: 77
n 77(None)[return ret
]:
	i: 30()
	o: 

nname: 30
n 30(None)[for i in self.deltaList:
	ret = current + i
	if ret > minToGo:
		break
		continue
else:
	raise PeriodicSchedulingException('higher failed')
]:
	i: 0(for)
	o: 77()

nname: 0
n 0(None)[ret = current + self.deltaList[0]
]:
	i: 
	o: 30(for)

nname: 77
n 77(None)[return ret
]:
	i: 0()
	o: 

nname: 0
n 0(None)[ret = current + self.deltaList[0]
for i in self.deltaList:
	ret = current + i
	if ret > minToGo:
		break
		continue
else:
	raise PeriodicSchedulingException('higher failed')
]:
	i: 
	o: 77()

nname: 0
n 0(None)[ret = current + self.deltaList[0]
for i in self.deltaList:
	ret = current + i
	if ret > minToGo:
		break
		continue
else:
	raise PeriodicSchedulingException('higher failed')
return ret
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb756e90c>}
nname: 82
n 82(None)[oXMLNode.append(node_time_delta_list)
PeriodicScheduling.SaveToXMLNode(self, oXMLNode)
return True
]:
	i: 21(AL), 81()
	o: 

nname: 81
n 81(None)[]:
	i: 52(AF), 62()
	o: 82()

nname: 62
n 62(None)[for d in self.deltaList:
TimeDeltaToXml(node_time_delta_list, d)
]:
	i: 52(for)
	o: 81()

nname: 52
n 52(None)[]:
	i: 21(loop)
	o: 62(for), 81(AF)

nname: 21
n 21(None)[oXMLNode.attrib['type'] = 'time_delta'
node_time_delta_list = ET.Element('time_delta_list')
]:
	i: 12(), 20()
	o: 52(loop), 82(AL)

nname: 20
n 20(None)[]:
	i: 0(f)
	o: 21()

nname: 12
n 12(None)[return False
]:
	i: 0(t)
	o: 21()

nname: 0
n 0(oXMLNode == None)[]:
	i: 
	o: 12(t), 20(f)

nname: 81
n 81(None)[oXMLNode.append(node_time_delta_list)
PeriodicScheduling.SaveToXMLNode(self, oXMLNode)
return True
]:
	i: 52()
	o: 

nname: 52
n 52(None)[for d in self.deltaList:
	TimeDeltaToXml(node_time_delta_list, d)
]:
	i: 0(loop)
	o: 81()

nname: 0
n 0(None)[if oXMLNode == None:
	return False
oXMLNode.attrib['type'] = 'time_delta'
node_time_delta_list = ET.Element('time_delta_list')
]:
	i: 
	o: 52(loop)

nname: 81
n 81(None)[oXMLNode.append(node_time_delta_list)
PeriodicScheduling.SaveToXMLNode(self, oXMLNode)
return True
]:
	i: 0()
	o: 

nname: 0
n 0(None)[if oXMLNode == None:
	return False
oXMLNode.attrib['type'] = 'time_delta'
node_time_delta_list = ET.Element('time_delta_list')
for d in self.deltaList:
	TimeDeltaToXml(node_time_delta_list, d)
]:
	i: 
	o: 81()

nname: 0
n 0(None)[if oXMLNode == None:
	return False
oXMLNode.attrib['type'] = 'time_delta'
node_time_delta_list = ET.Element('time_delta_list')
for d in self.deltaList:
	TimeDeltaToXml(node_time_delta_list, d)
oXMLNode.append(node_time_delta_list)
PeriodicScheduling.SaveToXMLNode(self, oXMLNode)
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb756ee6c>}
nname: 163
n 163(None)[return True
]:
	i: 101(AL), 158(), 162()
	o: 

nname: 162
n 162(None)[]:
	i: 49(f)
	o: 163()

nname: 158
n 158(None)[]:
	i: 120(AF), 127()
	o: 163()

nname: 127
n 127(None)[for node_d in nodes_d:
self.deltaList.append(GetTimeDeltaFromXmlNode(node_d, False))
]:
	i: 120(for)
	o: 158()

nname: 120
n 120(None)[]:
	i: 101(loop)
	o: 127(for), 158(AF)

nname: 101
n 101(None)[nodes_d = node_time_delta_list.getiterator('time_delta')
]:
	i: 49(t)
	o: 120(loop), 163(AL)

nname: 49
n 49(node_time_delta_list != None)[PeriodicScheduling.LoadFromXML(self, oXMLNode)
self.deltaList = []
node_time_delta_list = oXMLNode.find('time_delta_list')
]:
	i: 40(), 48()
	o: 101(t), 162(f)

nname: 48
n 48(None)[]:
	i: 21(f)
	o: 49()

nname: 40
n 40(None)[return False
]:
	i: 21(t)
	o: 49()

nname: 21
n 21(oXMLNode.attrib['type'] != 'time_delta')[]:
	i: 12(), 20()
	o: 40(t), 48(f)

nname: 20
n 20(None)[]:
	i: 0(f)
	o: 21()

nname: 12
n 12(None)[return False
]:
	i: 0(t)
	o: 21()

nname: 0
n 0(oXMLNode == None)[]:
	i: 
	o: 12(t), 20(f)

nname: 163
n 163(None)[return True
]:
	i: 127(), 49(f)
	o: 

nname: 127
n 127(None)[for node_d in nodes_d:
	self.deltaList.append(GetTimeDeltaFromXmlNode(node_d, False))
]:
	i: 101(for)
	o: 163()

nname: 101
n 101(None)[nodes_d = node_time_delta_list.getiterator('time_delta')
]:
	i: 49(t)
	o: 127(for)

nname: 49
n 49(node_time_delta_list != None)[PeriodicScheduling.LoadFromXML(self, oXMLNode)
self.deltaList = []
node_time_delta_list = oXMLNode.find('time_delta_list')
]:
	i: 0()
	o: 101(t), 163(f)

nname: 0
n 0(None)[if oXMLNode == None:
	return False
if oXMLNode.attrib['type'] != 'time_delta':
	return False
]:
	i: 
	o: 49()

nname: 163
n 163(None)[return True
]:
	i: 101(), 0(f)
	o: 

nname: 101
n 101(None)[nodes_d = node_time_delta_list.getiterator('time_delta')
for node_d in nodes_d:
	self.deltaList.append(GetTimeDeltaFromXmlNode(node_d, False))
]:
	i: 0(t)
	o: 163()

nname: 0
n 0(node_time_delta_list != None)[if oXMLNode == None:
	return False
if oXMLNode.attrib['type'] != 'time_delta':
	return False
PeriodicScheduling.LoadFromXML(self, oXMLNode)
self.deltaList = []
node_time_delta_list = oXMLNode.find('time_delta_list')
]:
	i: 
	o: 101(t), 163(f)

nname: 0
n 0(None)[if oXMLNode == None:
	return False
if oXMLNode.attrib['type'] != 'time_delta':
	return False
PeriodicScheduling.LoadFromXML(self, oXMLNode)
self.deltaList = []
node_time_delta_list = oXMLNode.find('time_delta_list')
if node_time_delta_list != None:
	nodes_d = node_time_delta_list.getiterator('time_delta')
	for node_d in nodes_d:
		self.deltaList.append(GetTimeDeltaFromXmlNode(node_d, False))
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7571b4c>}
nname: 6
n 6(None)[__doc__ = '\n        the rule is a list of datetime.timeldelta\n    '
def __init__(self, deltaList=None):
	PeriodicScheduling.__init__(self)
	if deltaList:
		self.deltaList = deltaList
	else:
		self.deltalist = [datetime.timedelta(0)]
	if deltaList:
		deltaList.sort()

def _NextBeforeOrEqualTarget(self, minToGo, current):
	ret, last = current + self.deltaList[0], current + self.deltaList[0]
	for i in self.deltaList:
		last = ret
		ret = current + i
		if ret > minToGo:
			break
			continue
	return last

def _NextAfterTarget(self, minToGo, current):
	ret = current + self.deltaList[0]
	for i in self.deltaList:
		ret = current + i
		if ret > minToGo:
			break
			continue
	else:
		raise PeriodicSchedulingException('higher failed')
	return ret

def SaveToXMLNode(self, oXMLNode):
	if oXMLNode == None:
		return False
	oXMLNode.attrib['type'] = 'time_delta'
	node_time_delta_list = ET.Element('time_delta_list')
	for d in self.deltaList:
		TimeDeltaToXml(node_time_delta_list, d)
	oXMLNode.append(node_time_delta_list)
	PeriodicScheduling.SaveToXMLNode(self, oXMLNode)
	return True

def LoadFromXML(self, oXMLNode):
	if oXMLNode == None:
		return False
	if oXMLNode.attrib['type'] != 'time_delta':
		return False
	PeriodicScheduling.LoadFromXML(self, oXMLNode)
	self.deltaList = []
	node_time_delta_list = oXMLNode.find('time_delta_list')
	if node_time_delta_list != None:
		nodes_d = node_time_delta_list.getiterator('time_delta')
		for node_d in nodes_d:
			self.deltaList.append(GetTimeDeltaFromXmlNode(node_d, False))
	return True

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb756e82c>}
nname: 54
n 54(None)[]:
	i: 22(), 35()
	o: 

nname: 35
n 35(None)[self.period = datetime.timedelta(0)
]:
	i: 0(f)
	o: 54()

nname: 22
n 22(None)[self.period = period
]:
	i: 0(t)
	o: 54()

nname: 0
n 0(period)[PeriodicScheduling.__init__(self, limit)
]:
	i: 
	o: 22(t), 35(f)

nname: 0
n 0(None)[PeriodicScheduling.__init__(self, limit)
if period:
	self.period = period
else:
	self.period = datetime.timedelta(0)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb756ecec>}
nname: 98
n 98(None)[return last
]:
	i: 26(AL), 96()
	o: 

nname: 96
n 96(None)[]:
	i: 39&51(f), 73()
	o: 98()

nname: 73
n 73(None)[last = ret
ret += self.period
]:
	i: 39&51(t)
	o: 96()

nname: 39&51
n 39&51(ret <= minToGo and self._CheckTimeLimitIsOK(ret, current, False))[]:
	i: 26(loop)
	o: 73(t), 96(f)

nname: 26
n 26(None)[ret, last = current, current
]:
	i: 9(), 25()
	o: 39&51(loop), 98(AL)

nname: 25
n 25(None)[]:
	i: 0(t)
	o: 26()

nname: 9
n 9(None)[raise PeriodicSchedulingException('period null')
]:
	i: 0(f)
	o: 26()

nname: 0
n 0(self.period)[]:
	i: 
	o: 9(f), 25(t)

nname: 98
n 98(None)[return last
]:
	i: 39&51()
	o: 

nname: 39&51
n 39&51(None)[while ret <= minToGo and self._CheckTimeLimitIsOK(ret, current, False):
	last = ret
	ret += self.period
]:
	i: 0(loop)
	o: 98()

nname: 0
n 0(None)[if not self.period:
	raise PeriodicSchedulingException('period null')
ret, last = current, current
]:
	i: 
	o: 39&51(loop)

nname: 98
n 98(None)[return last
]:
	i: 0()
	o: 

nname: 0
n 0(None)[if not self.period:
	raise PeriodicSchedulingException('period null')
ret, last = current, current
while ret <= minToGo and self._CheckTimeLimitIsOK(ret, current, False):
	last = ret
	ret += self.period
]:
	i: 
	o: 98()

nname: 0
n 0(None)[if not self.period:
	raise PeriodicSchedulingException('period null')
ret, last = current, current
while ret <= minToGo and self._CheckTimeLimitIsOK(ret, current, False):
	last = ret
	ret += self.period
return last
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb756ef2c>}
nname: 66
n 66(None)[self._CheckTimeLimitIsOK(ret, current)
return ret
]:
	i: 26(AL), 64()
	o: 

nname: 64
n 64(None)[]:
	i: 35(f), 47()
	o: 66()

nname: 47
n 47(None)[ret += self.period
]:
	i: 35(t)
	o: 64()

nname: 35
n 35(ret <= minToGo)[]:
	i: 26(loop)
	o: 47(t), 64(f)

nname: 26
n 26(None)[ret = current
]:
	i: 9(), 25()
	o: 35(loop), 66(AL)

nname: 25
n 25(None)[]:
	i: 0(t)
	o: 26()

nname: 9
n 9(None)[raise PeriodicSchedulingException('period null')
]:
	i: 0(f)
	o: 26()

nname: 0
n 0(self.period)[]:
	i: 
	o: 9(f), 25(t)

nname: 64
n 64(None)[self._CheckTimeLimitIsOK(ret, current)
return ret
]:
	i: 35()
	o: 

nname: 35
n 35(None)[while ret <= minToGo:
	ret += self.period
]:
	i: 0(loop)
	o: 64()

nname: 0
n 0(None)[if not self.period:
	raise PeriodicSchedulingException('period null')
ret = current
]:
	i: 
	o: 35(loop)

nname: 64
n 64(None)[self._CheckTimeLimitIsOK(ret, current)
return ret
]:
	i: 0()
	o: 

nname: 0
n 0(None)[if not self.period:
	raise PeriodicSchedulingException('period null')
ret = current
while ret <= minToGo:
	ret += self.period
]:
	i: 
	o: 64()

nname: 0
n 0(None)[if not self.period:
	raise PeriodicSchedulingException('period null')
ret = current
while ret <= minToGo:
	ret += self.period
self._CheckTimeLimitIsOK(ret, current)
return ret
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb756edcc>}
nname: 21
n 21(None)[oXMLNode.attrib['type'] = 'constant_period'
node_period = ET.Element('period')
TimeDeltaToXml(node_period, self.period)
oXMLNode.append(node_period)
PeriodicScheduling.SaveToXMLNode(self, oXMLNode)
return True
]:
	i: 12(), 20()
	o: 

nname: 20
n 20(None)[]:
	i: 0(f)
	o: 21()

nname: 12
n 12(None)[return False
]:
	i: 0(t)
	o: 21()

nname: 0
n 0(oXMLNode == None)[]:
	i: 
	o: 12(t), 20(f)

nname: 0
n 0(None)[if oXMLNode == None:
	return False
oXMLNode.attrib['type'] = 'constant_period'
node_period = ET.Element('period')
TimeDeltaToXml(node_period, self.period)
oXMLNode.append(node_period)
PeriodicScheduling.SaveToXMLNode(self, oXMLNode)
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb756edac>}
nname: 121
n 121(None)[return True
]:
	i: 101(), 120()
	o: 

nname: 120
n 120(None)[]:
	i: 49(f)
	o: 121()

nname: 101
n 101(None)[self.period = GetTimeDeltaFromXmlNode(node_period)
]:
	i: 49(t)
	o: 121()

nname: 49
n 49(node_period != None)[PeriodicScheduling.LoadFromXML(self, oXMLNode)
self.pos = 0
node_period = oXMLNode.find('period')
]:
	i: 40(), 48()
	o: 101(t), 120(f)

nname: 48
n 48(None)[]:
	i: 21(f)
	o: 49()

nname: 40
n 40(None)[return False
]:
	i: 21(t)
	o: 49()

nname: 21
n 21(oXMLNode.attrib['type'] != 'constant_period')[]:
	i: 12(), 20()
	o: 40(t), 48(f)

nname: 20
n 20(None)[]:
	i: 0(f)
	o: 21()

nname: 12
n 12(None)[return False
]:
	i: 0(t)
	o: 21()

nname: 0
n 0(oXMLNode == None)[]:
	i: 
	o: 12(t), 20(f)

nname: 49
n 49(None)[PeriodicScheduling.LoadFromXML(self, oXMLNode)
self.pos = 0
node_period = oXMLNode.find('period')
if node_period != None:
	self.period = GetTimeDeltaFromXmlNode(node_period)
return True
]:
	i: 0()
	o: 

nname: 0
n 0(None)[if oXMLNode == None:
	return False
if oXMLNode.attrib['type'] != 'constant_period':
	return False
]:
	i: 
	o: 49()

nname: 0
n 0(None)[if oXMLNode == None:
	return False
if oXMLNode.attrib['type'] != 'constant_period':
	return False
PeriodicScheduling.LoadFromXML(self, oXMLNode)
self.pos = 0
node_period = oXMLNode.find('period')
if node_period != None:
	self.period = GetTimeDeltaFromXmlNode(node_period)
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb757152c>}
nname: 6
n 6(None)[__doc__ = '\n    the rule is a constant period in datetime.timedelta\n    '
def __init__(self, period=None, limit=None):
	PeriodicScheduling.__init__(self, limit)
	if period:
		self.period = period
	else:
		self.period = datetime.timedelta(0)

def _NextBeforeOrEqualTarget(self, minToGo, current):
	if not self.period:
		raise PeriodicSchedulingException('period null')
	ret, last = current, current
	while ret <= minToGo and self._CheckTimeLimitIsOK(ret, current, False):
		last = ret
		ret += self.period
	return last

def _NextAfterTarget(self, minToGo, current):
	if not self.period:
		raise PeriodicSchedulingException('period null')
	ret = current
	while ret <= minToGo:
		ret += self.period
	self._CheckTimeLimitIsOK(ret, current)
	return ret

def SaveToXMLNode(self, oXMLNode):
	if oXMLNode == None:
		return False
	oXMLNode.attrib['type'] = 'constant_period'
	node_period = ET.Element('period')
	TimeDeltaToXml(node_period, self.period)
	oXMLNode.append(node_period)
	PeriodicScheduling.SaveToXMLNode(self, oXMLNode)
	return True

def LoadFromXML(self, oXMLNode):
	if oXMLNode == None:
		return False
	if oXMLNode.attrib['type'] != 'constant_period':
		return False
	PeriodicScheduling.LoadFromXML(self, oXMLNode)
	self.pos = 0
	node_period = oXMLNode.find('period')
	if node_period != None:
		self.period = GetTimeDeltaFromXmlNode(node_period)
	return True

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb756eeec>}
nname: 0
n 0(None)[PeriodicScheduling.__init__(self, limit)
self.pos = pos
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb756efcc>}
nname: 72
n 72(None)[]:
	i: 15(), 48()
	o: 

nname: 48
n 48(None)[return time.replace(month=time.month + 1)
]:
	i: 0(f)
	o: 72()

nname: 15
n 15(None)[return time.replace(year=time.year + 1, month=1)
]:
	i: 0(t)
	o: 72()

nname: 0
n 0(time.month == 12)[]:
	i: 
	o: 15(t), 48(f)

nname: 0
n 0(None)[if time.month == 12:
	return time.replace(year=time.year + 1, month=1)
else:
	return time.replace(month=time.month + 1)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb756ee6c>}
nname: 130
n 130(None)[return last
]:
	i: 0(AL), 128()
	o: 

nname: 128
n 128(None)[]:
	i: 47&59(f), 81()
	o: 130()

nname: 81
n 81(None)[last = ret
tmp = self._increaseMonth(tmp)
ret = tmp + datetime.timedelta(self.pos)
]:
	i: 47&59(t)
	o: 128()

nname: 47&59
n 47&59(ret <= minToGo and self._CheckTimeLimitIsOK(ret, current, False))[]:
	i: 0(loop)
	o: 81(t), 128(f)

nname: 0
n 0(None)[tmp = current.replace(day=1)
ret, last = tmp + datetime.timedelta(self.pos), tmp + datetime.timedelta(self.pos)
]:
	i: 
	o: 47&59(loop), 130(AL)

nname: 130
n 130(None)[return last
]:
	i: 81()
	o: 

nname: 81
n 81(None)[	last = ret
	tmp = self._increaseMonth(tmp)
	ret = tmp + datetime.timedelta(self.pos)
]:
	i: 0(t)
	o: 130()

nname: 0
n 0(ret <= minToGo and self._CheckTimeLimitIsOK(ret, current, False))[tmp = current.replace(day=1)
ret, last = tmp + datetime.timedelta(self.pos), tmp + datetime.timedelta(self.pos)
while ret <= minToGo and self._CheckTimeLimitIsOK(ret, current, False):
]:
	i: 
	o: 81(t)

nname: 130
n 130(None)[return last
]:
	i: 0()
	o: 

nname: 0
n 0(None)[tmp = current.replace(day=1)
ret, last = tmp + datetime.timedelta(self.pos), tmp + datetime.timedelta(self.pos)
while ret <= minToGo and self._CheckTimeLimitIsOK(ret, current, False):
	last = ret
	tmp = self._increaseMonth(tmp)
	ret = tmp + datetime.timedelta(self.pos)
]:
	i: 
	o: 130()

nname: 0
n 0(None)[tmp = current.replace(day=1)
ret, last = tmp + datetime.timedelta(self.pos), tmp + datetime.timedelta(self.pos)
while ret <= minToGo and self._CheckTimeLimitIsOK(ret, current, False):
	last = ret
	tmp = self._increaseMonth(tmp)
	ret = tmp + datetime.timedelta(self.pos)
return last
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb757118c>}
nname: 98
n 98(None)[self._CheckTimeLimitIsOK(ret, current)
return ret
]:
	i: 0(AL), 96()
	o: 

nname: 96
n 96(None)[]:
	i: 43(f), 55()
	o: 98()

nname: 55
n 55(None)[tmp = self._increaseMonth(tmp)
ret = tmp + datetime.timedelta(self.pos)
]:
	i: 43(t)
	o: 96()

nname: 43
n 43(ret <= minToGo)[]:
	i: 0(loop)
	o: 55(t), 96(f)

nname: 0
n 0(None)[tmp = current.replace(day=1)
ret = tmp + datetime.timedelta(self.pos)
]:
	i: 
	o: 43(loop), 98(AL)

nname: 98
n 98(None)[self._CheckTimeLimitIsOK(ret, current)
return ret
]:
	i: 55()
	o: 

nname: 55
n 55(None)[	tmp = self._increaseMonth(tmp)
	ret = tmp + datetime.timedelta(self.pos)
]:
	i: 0(t)
	o: 98()

nname: 0
n 0(ret <= minToGo)[tmp = current.replace(day=1)
ret = tmp + datetime.timedelta(self.pos)
while ret <= minToGo:
]:
	i: 
	o: 55(t)

nname: 98
n 98(None)[self._CheckTimeLimitIsOK(ret, current)
return ret
]:
	i: 0()
	o: 

nname: 0
n 0(None)[tmp = current.replace(day=1)
ret = tmp + datetime.timedelta(self.pos)
while ret <= minToGo:
	tmp = self._increaseMonth(tmp)
	ret = tmp + datetime.timedelta(self.pos)
]:
	i: 
	o: 98()

nname: 0
n 0(None)[tmp = current.replace(day=1)
ret = tmp + datetime.timedelta(self.pos)
while ret <= minToGo:
	tmp = self._increaseMonth(tmp)
	ret = tmp + datetime.timedelta(self.pos)
self._CheckTimeLimitIsOK(ret, current)
return ret
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7571c2c>}
nname: 21
n 21(None)[oXMLNode.attrib['type'] = 'relative_day_pos_in_month'
node_pos = ET.Element('pos')
node_pos.text = str(self.pos)
oXMLNode.append(node_pos)
PeriodicScheduling.SaveToXMLNode(self, oXMLNode)
return True
]:
	i: 12(), 20()
	o: 

nname: 20
n 20(None)[]:
	i: 0(f)
	o: 21()

nname: 12
n 12(None)[return False
]:
	i: 0(t)
	o: 21()

nname: 0
n 0(oXMLNode == None)[]:
	i: 
	o: 12(t), 20(f)

nname: 0
n 0(None)[if oXMLNode == None:
	return False
oXMLNode.attrib['type'] = 'relative_day_pos_in_month'
node_pos = ET.Element('pos')
node_pos.text = str(self.pos)
oXMLNode.append(node_pos)
PeriodicScheduling.SaveToXMLNode(self, oXMLNode)
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb756eccc>}
nname: 124
n 124(None)[return True
]:
	i: 101(), 123()
	o: 

nname: 123
n 123(None)[]:
	i: 49(f)
	o: 124()

nname: 101
n 101(None)[self.pos = int(node_pos.text)
]:
	i: 49(t)
	o: 124()

nname: 49
n 49(node_pos != None)[PeriodicScheduling.LoadFromXML(self, oXMLNode)
self.pos = 0
node_pos = oXMLNode.find('pos')
]:
	i: 40(), 48()
	o: 101(t), 123(f)

nname: 48
n 48(None)[]:
	i: 21(f)
	o: 49()

nname: 40
n 40(None)[return False
]:
	i: 21(t)
	o: 49()

nname: 21
n 21(oXMLNode.attrib['type'] != 'relative_day_pos_in_month')[]:
	i: 12(), 20()
	o: 40(t), 48(f)

nname: 20
n 20(None)[]:
	i: 0(f)
	o: 21()

nname: 12
n 12(None)[return False
]:
	i: 0(t)
	o: 21()

nname: 0
n 0(oXMLNode == None)[]:
	i: 
	o: 12(t), 20(f)

nname: 49
n 49(None)[PeriodicScheduling.LoadFromXML(self, oXMLNode)
self.pos = 0
node_pos = oXMLNode.find('pos')
if node_pos != None:
	self.pos = int(node_pos.text)
return True
]:
	i: 0()
	o: 

nname: 0
n 0(None)[if oXMLNode == None:
	return False
if oXMLNode.attrib['type'] != 'relative_day_pos_in_month':
	return False
]:
	i: 
	o: 49()

nname: 0
n 0(None)[if oXMLNode == None:
	return False
if oXMLNode.attrib['type'] != 'relative_day_pos_in_month':
	return False
PeriodicScheduling.LoadFromXML(self, oXMLNode)
self.pos = 0
node_pos = oXMLNode.find('pos')
if node_pos != None:
	self.pos = int(node_pos.text)
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75710cc>}
nname: 6
n 6(None)[__doc__ = '\n    the rule is a day offset in month\n    \n    0 means the first day of the month\n    -1 means the last day of the month\n    '
def __init__(self, pos=0, limit=None):
	PeriodicScheduling.__init__(self, limit)
	self.pos = pos

def _increaseMonth(self, time):
	if time.month == 12:
		return time.replace(year=time.year + 1, month=1)
	else:
		return time.replace(month=time.month + 1)

def _NextBeforeOrEqualTarget(self, minToGo, current):
	tmp = current.replace(day=1)
	ret, last = tmp + datetime.timedelta(self.pos), tmp + datetime.timedelta(self.pos)
	while ret <= minToGo and self._CheckTimeLimitIsOK(ret, current, False):
		last = ret
		tmp = self._increaseMonth(tmp)
		ret = tmp + datetime.timedelta(self.pos)
	return last

def _NextAfterTarget(self, minToGo, current):
	tmp = current.replace(day=1)
	ret = tmp + datetime.timedelta(self.pos)
	while ret <= minToGo:
		tmp = self._increaseMonth(tmp)
		ret = tmp + datetime.timedelta(self.pos)
	self._CheckTimeLimitIsOK(ret, current)
	return ret

def SaveToXMLNode(self, oXMLNode):
	if oXMLNode == None:
		return False
	oXMLNode.attrib['type'] = 'relative_day_pos_in_month'
	node_pos = ET.Element('pos')
	node_pos.text = str(self.pos)
	oXMLNode.append(node_pos)
	PeriodicScheduling.SaveToXMLNode(self, oXMLNode)
	return True

def LoadFromXML(self, oXMLNode):
	if oXMLNode == None:
		return False
	if oXMLNode.attrib['type'] != 'relative_day_pos_in_month':
		return False
	PeriodicScheduling.LoadFromXML(self, oXMLNode)
	self.pos = 0
	node_pos = oXMLNode.find('pos')
	if node_pos != None:
		self.pos = int(node_pos.text)
	return True

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb756e30c>}
nname: 52
n 52(None)[]:
	i: 22(), 35()
	o: 

nname: 35
n 35(None)[self.dayList, dayList = [0], [0]
]:
	i: 0(f)
	o: 52()

nname: 22
n 22(None)[self.dayList = dayList
]:
	i: 0(t)
	o: 52()

nname: 0
n 0(dayList)[PeriodicScheduling.__init__(self, limit)
]:
	i: 
	o: 22(t), 35(f)

nname: 0
n 0(None)[PeriodicScheduling.__init__(self, limit)
if dayList:
	self.dayList = dayList
else:
	self.dayList, dayList = [0], [0]
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb756edcc>}
nname: 60
n 60(None)[return time + datetime.timedelta(deltaDay)
]:
	i: 45(JA), 55(), 59()
	o: 

nname: 59
n 59(None)[]:
	i: 0(f)
	o: 60()

nname: 55
n 55(None)[]:
	i: 38(t)
	o: 60()

nname: 45
n 45(None)[deltaDay = 7
]:
	i: 38(f)
	o: 60(JA)

nname: 38
n 38(acceptFirstDay)[]:
	i: 0(t)
	o: 45(f), 55(t)

nname: 0
n 0(deltaDay == 0)[today = time.weekday()
deltaDay = (day - today) % 7
]:
	i: 
	o: 38(t), 59(f)

nname: 0
n 0(None)[today = time.weekday()
deltaDay = (day - today) % 7
if deltaDay == 0:
	if not acceptFirstDay:
		deltaDay = 7
return time + datetime.timedelta(deltaDay)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb756ecac>}
nname: 135
n 135(None)[return last
]:
	i: 0(AL), 133()
	o: 

nname: 133
n 133(None)[]:
	i: 41&53(f), 75()
	o: 135()

nname: 75
n 75(None)[last = ret
ret = self._findNextDay(ret, self.dayList[i % len(self.dayList)])
i += 1
]:
	i: 41&53(t)
	o: 133()

nname: 41&53
n 41&53(ret <= minToGo and self._CheckTimeLimitIsOK(ret, current, False))[]:
	i: 0(loop)
	o: 75(t), 133(f)

nname: 0
n 0(None)[ret, last = self._findNextDay(current, self.dayList[0], True), self._findNextDay(current, self.dayList[0], True)
i = 1
]:
	i: 
	o: 41&53(loop), 135(AL)

nname: 135
n 135(None)[return last
]:
	i: 75()
	o: 

nname: 75
n 75(None)[	last = ret
	ret = self._findNextDay(ret, self.dayList[i % len(self.dayList)])
	i += 1
]:
	i: 0(t)
	o: 135()

nname: 0
n 0(ret <= minToGo and self._CheckTimeLimitIsOK(ret, current, False))[ret, last = self._findNextDay(current, self.dayList[0], True), self._findNextDay(current, self.dayList[0], True)
i = 1
while ret <= minToGo and self._CheckTimeLimitIsOK(ret, current, False):
]:
	i: 
	o: 75(t)

nname: 135
n 135(None)[return last
]:
	i: 0()
	o: 

nname: 0
n 0(None)[ret, last = self._findNextDay(current, self.dayList[0], True), self._findNextDay(current, self.dayList[0], True)
i = 1
while ret <= minToGo and self._CheckTimeLimitIsOK(ret, current, False):
	last = ret
	ret = self._findNextDay(ret, self.dayList[i % len(self.dayList)])
	i += 1
]:
	i: 
	o: 135()

nname: 0
n 0(None)[ret, last = self._findNextDay(current, self.dayList[0], True), self._findNextDay(current, self.dayList[0], True)
i = 1
while ret <= minToGo and self._CheckTimeLimitIsOK(ret, current, False):
	last = ret
	ret = self._findNextDay(ret, self.dayList[i % len(self.dayList)])
	i += 1
return last
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb757118c>}
nname: 103
n 103(None)[self._CheckTimeLimitIsOK(ret, current)
return ret
]:
	i: 0(AL), 101()
	o: 

nname: 101
n 101(None)[]:
	i: 37(f), 49()
	o: 103()

nname: 49
n 49(None)[ret = self._findNextDay(ret, self.dayList[i % len(self.dayList)])
i += 1
]:
	i: 37(t)
	o: 101()

nname: 37
n 37(ret <= minToGo)[]:
	i: 0(loop)
	o: 49(t), 101(f)

nname: 0
n 0(None)[ret = self._findNextDay(current, self.dayList[0], True)
i = 1
]:
	i: 
	o: 37(loop), 103(AL)

nname: 103
n 103(None)[self._CheckTimeLimitIsOK(ret, current)
return ret
]:
	i: 49()
	o: 

nname: 49
n 49(None)[	ret = self._findNextDay(ret, self.dayList[i % len(self.dayList)])
	i += 1
]:
	i: 0(t)
	o: 103()

nname: 0
n 0(ret <= minToGo)[ret = self._findNextDay(current, self.dayList[0], True)
i = 1
while ret <= minToGo:
]:
	i: 
	o: 49(t)

nname: 103
n 103(None)[self._CheckTimeLimitIsOK(ret, current)
return ret
]:
	i: 0()
	o: 

nname: 0
n 0(None)[ret = self._findNextDay(current, self.dayList[0], True)
i = 1
while ret <= minToGo:
	ret = self._findNextDay(ret, self.dayList[i % len(self.dayList)])
	i += 1
]:
	i: 
	o: 103()

nname: 0
n 0(None)[ret = self._findNextDay(current, self.dayList[0], True)
i = 1
while ret <= minToGo:
	ret = self._findNextDay(ret, self.dayList[i % len(self.dayList)])
	i += 1
self._CheckTimeLimitIsOK(ret, current)
return ret
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb757192c>}
nname: 112
n 112(None)[oXMLNode.append(node_days)
PeriodicScheduling.SaveToXMLNode(self, oXMLNode)
return True
]:
	i: 21(AL), 111()
	o: 

nname: 111
n 111(None)[]:
	i: 52(AF), 62()
	o: 112()

nname: 62
n 62(None)[for day in self.dayList:
node_day = ET.Element('day')
node_day.text = str(day)
node_days.append(node_day)
]:
	i: 52(for)
	o: 111()

nname: 52
n 52(None)[]:
	i: 21(loop)
	o: 62(for), 111(AF)

nname: 21
n 21(None)[oXMLNode.attrib['type'] = 'day_list'
node_days = ET.Element('days')
]:
	i: 12(), 20()
	o: 52(loop), 112(AL)

nname: 20
n 20(None)[]:
	i: 0(f)
	o: 21()

nname: 12
n 12(None)[return False
]:
	i: 0(t)
	o: 21()

nname: 0
n 0(oXMLNode == None)[]:
	i: 
	o: 12(t), 20(f)

nname: 111
n 111(None)[oXMLNode.append(node_days)
PeriodicScheduling.SaveToXMLNode(self, oXMLNode)
return True
]:
	i: 52()
	o: 

nname: 52
n 52(None)[for day in self.dayList:
	node_day = ET.Element('day')
	node_day.text = str(day)
	node_days.append(node_day)
]:
	i: 0(loop)
	o: 111()

nname: 0
n 0(None)[if oXMLNode == None:
	return False
oXMLNode.attrib['type'] = 'day_list'
node_days = ET.Element('days')
]:
	i: 
	o: 52(loop)

nname: 111
n 111(None)[oXMLNode.append(node_days)
PeriodicScheduling.SaveToXMLNode(self, oXMLNode)
return True
]:
	i: 0()
	o: 

nname: 0
n 0(None)[if oXMLNode == None:
	return False
oXMLNode.attrib['type'] = 'day_list'
node_days = ET.Element('days')
for day in self.dayList:
	node_day = ET.Element('day')
	node_day.text = str(day)
	node_days.append(node_day)
]:
	i: 
	o: 111()

nname: 0
n 0(None)[if oXMLNode == None:
	return False
oXMLNode.attrib['type'] = 'day_list'
node_days = ET.Element('days')
for day in self.dayList:
	node_day = ET.Element('day')
	node_day.text = str(day)
	node_days.append(node_day)
oXMLNode.append(node_days)
PeriodicScheduling.SaveToXMLNode(self, oXMLNode)
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7571a4c>}
nname: 163
n 163(None)[return True
]:
	i: 101(AL), 158(), 162()
	o: 

nname: 162
n 162(None)[]:
	i: 49(f)
	o: 163()

nname: 158
n 158(None)[]:
	i: 120(AF), 127()
	o: 163()

nname: 127
n 127(None)[for node_day in nodes_day:
self.dayList.append(int(node_day.text))
]:
	i: 120(for)
	o: 158()

nname: 120
n 120(None)[]:
	i: 101(loop)
	o: 127(for), 158(AF)

nname: 101
n 101(None)[nodes_day = node_days.getiterator('day')
]:
	i: 49(t)
	o: 120(loop), 163(AL)

nname: 49
n 49(node_days != None)[PeriodicScheduling.LoadFromXML(self, oXMLNode)
self.dayList = []
node_days = oXMLNode.find('days')
]:
	i: 40(), 48()
	o: 101(t), 162(f)

nname: 48
n 48(None)[]:
	i: 21(f)
	o: 49()

nname: 40
n 40(None)[return False
]:
	i: 21(t)
	o: 49()

nname: 21
n 21(oXMLNode.attrib['type'] != 'day_list')[]:
	i: 12(), 20()
	o: 40(t), 48(f)

nname: 20
n 20(None)[]:
	i: 0(f)
	o: 21()

nname: 12
n 12(None)[return False
]:
	i: 0(t)
	o: 21()

nname: 0
n 0(oXMLNode == None)[]:
	i: 
	o: 12(t), 20(f)

nname: 163
n 163(None)[return True
]:
	i: 127(), 49(f)
	o: 

nname: 127
n 127(None)[for node_day in nodes_day:
	self.dayList.append(int(node_day.text))
]:
	i: 101(for)
	o: 163()

nname: 101
n 101(None)[nodes_day = node_days.getiterator('day')
]:
	i: 49(t)
	o: 127(for)

nname: 49
n 49(node_days != None)[PeriodicScheduling.LoadFromXML(self, oXMLNode)
self.dayList = []
node_days = oXMLNode.find('days')
]:
	i: 0()
	o: 101(t), 163(f)

nname: 0
n 0(None)[if oXMLNode == None:
	return False
if oXMLNode.attrib['type'] != 'day_list':
	return False
]:
	i: 
	o: 49()

nname: 163
n 163(None)[return True
]:
	i: 101(), 0(f)
	o: 

nname: 101
n 101(None)[nodes_day = node_days.getiterator('day')
for node_day in nodes_day:
	self.dayList.append(int(node_day.text))
]:
	i: 0(t)
	o: 163()

nname: 0
n 0(node_days != None)[if oXMLNode == None:
	return False
if oXMLNode.attrib['type'] != 'day_list':
	return False
PeriodicScheduling.LoadFromXML(self, oXMLNode)
self.dayList = []
node_days = oXMLNode.find('days')
]:
	i: 
	o: 101(t), 163(f)

nname: 0
n 0(None)[if oXMLNode == None:
	return False
if oXMLNode.attrib['type'] != 'day_list':
	return False
PeriodicScheduling.LoadFromXML(self, oXMLNode)
self.dayList = []
node_days = oXMLNode.find('days')
if node_days != None:
	nodes_day = node_days.getiterator('day')
	for node_day in nodes_day:
		self.dayList.append(int(node_day.text))
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7571c0c>}
nname: 6
n 6(None)[__doc__ = '\n    the rule is a list of days\n    0 for monday\n    6 for sunday\n    '
def __init__(self, dayList=None, limit=None):
	PeriodicScheduling.__init__(self, limit)
	if dayList:
		self.dayList = dayList
	else:
		self.dayList, dayList = [0], [0]

def _findNextDay(self, time, day, acceptFirstDay=False):
	today = time.weekday()
	deltaDay = (day - today) % 7
	if deltaDay == 0:
		if not acceptFirstDay:
			deltaDay = 7
	return time + datetime.timedelta(deltaDay)

def _NextBeforeOrEqualTarget(self, minToGo, current):
	ret, last = self._findNextDay(current, self.dayList[0], True), self._findNextDay(current, self.dayList[0], True)
	i = 1
	while ret <= minToGo and self._CheckTimeLimitIsOK(ret, current, False):
		last = ret
		ret = self._findNextDay(ret, self.dayList[i % len(self.dayList)])
		i += 1
	return last

def _NextAfterTarget(self, minToGo, current):
	ret = self._findNextDay(current, self.dayList[0], True)
	i = 1
	while ret <= minToGo:
		ret = self._findNextDay(ret, self.dayList[i % len(self.dayList)])
		i += 1
	self._CheckTimeLimitIsOK(ret, current)
	return ret

def SaveToXMLNode(self, oXMLNode):
	if oXMLNode == None:
		return False
	oXMLNode.attrib['type'] = 'day_list'
	node_days = ET.Element('days')
	for day in self.dayList:
		node_day = ET.Element('day')
		node_day.text = str(day)
		node_days.append(node_day)
	oXMLNode.append(node_days)
	PeriodicScheduling.SaveToXMLNode(self, oXMLNode)
	return True

def LoadFromXML(self, oXMLNode):
	if oXMLNode == None:
		return False
	if oXMLNode.attrib['type'] != 'day_list':
		return False
	PeriodicScheduling.LoadFromXML(self, oXMLNode)
	self.dayList = []
	node_days = oXMLNode.find('days')
	if node_days != None:
		nodes_day = node_days.getiterator('day')
		for node_day in nodes_day:
			self.dayList.append(int(node_day.text))
	return True

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb756eeac>}
nname: 0
n 0(None)[ConstantPeriodRule.__init__(self, datetime.timedelta(1), oLimit)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb756e8ac>}
nname: 21
n 21(None)[PeriodicScheduling.SaveToXMLNode(self, oXMLNode)
oXMLNode.attrib['type'] = 'daily'
return True
]:
	i: 12(), 20()
	o: 

nname: 20
n 20(None)[]:
	i: 0(f)
	o: 21()

nname: 12
n 12(None)[return False
]:
	i: 0(t)
	o: 21()

nname: 0
n 0(oXMLNode == None)[]:
	i: 
	o: 12(t), 20(f)

nname: 0
n 0(None)[if oXMLNode == None:
	return False
PeriodicScheduling.SaveToXMLNode(self, oXMLNode)
oXMLNode.attrib['type'] = 'daily'
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb756e64c>}
nname: 49
n 49(None)[PeriodicScheduling.LoadFromXML(self, oXMLNode)
return True
]:
	i: 40(), 48()
	o: 

nname: 48
n 48(None)[]:
	i: 21(f)
	o: 49()

nname: 40
n 40(None)[return False
]:
	i: 21(t)
	o: 49()

nname: 21
n 21(oXMLNode.attrib['type'] != 'daily')[]:
	i: 12(), 20()
	o: 40(t), 48(f)

nname: 20
n 20(None)[]:
	i: 0(f)
	o: 21()

nname: 12
n 12(None)[return False
]:
	i: 0(t)
	o: 21()

nname: 0
n 0(oXMLNode == None)[]:
	i: 
	o: 12(t), 20(f)

nname: 49
n 49(None)[PeriodicScheduling.LoadFromXML(self, oXMLNode)
return True
]:
	i: 0()
	o: 

nname: 0
n 0(None)[if oXMLNode == None:
	return False
if oXMLNode.attrib['type'] != 'daily':
	return False
]:
	i: 
	o: 49()

nname: 0
n 0(None)[if oXMLNode == None:
	return False
if oXMLNode.attrib['type'] != 'daily':
	return False
PeriodicScheduling.LoadFromXML(self, oXMLNode)
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb756edec>}
nname: 6
n 6(None)[__doc__ = '\n    particular case of ConstantPeriodRule\n    '
def __init__(self, oLimit=None):
	ConstantPeriodRule.__init__(self, datetime.timedelta(1), oLimit)

def SaveToXMLNode(self, oXMLNode):
	if oXMLNode == None:
		return False
	PeriodicScheduling.SaveToXMLNode(self, oXMLNode)
	oXMLNode.attrib['type'] = 'daily'
	return True

def LoadFromXML(self, oXMLNode):
	if oXMLNode == None:
		return False
	if oXMLNode.attrib['type'] != 'daily':
		return False
	PeriodicScheduling.LoadFromXML(self, oXMLNode)
	return True

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb756ed6c>}
nname: 0
n 0(None)[ConstantPeriodRule.__init__(self, datetime.timedelta(7), oLimit)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb756e96c>}
nname: 21
n 21(None)[PeriodicScheduling.SaveToXMLNode(self, oXMLNode)
oXMLNode.attrib['type'] = 'weekly'
return True
]:
	i: 12(), 20()
	o: 

nname: 20
n 20(None)[]:
	i: 0(f)
	o: 21()

nname: 12
n 12(None)[return False
]:
	i: 0(t)
	o: 21()

nname: 0
n 0(oXMLNode == None)[]:
	i: 
	o: 12(t), 20(f)

nname: 0
n 0(None)[if oXMLNode == None:
	return False
PeriodicScheduling.SaveToXMLNode(self, oXMLNode)
oXMLNode.attrib['type'] = 'weekly'
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb756e5cc>}
nname: 49
n 49(None)[PeriodicScheduling.LoadFromXML(self, oXMLNode)
return True
]:
	i: 40(), 48()
	o: 

nname: 48
n 48(None)[]:
	i: 21(f)
	o: 49()

nname: 40
n 40(None)[return False
]:
	i: 21(t)
	o: 49()

nname: 21
n 21(oXMLNode.attrib['type'] != 'weekly')[]:
	i: 12(), 20()
	o: 40(t), 48(f)

nname: 20
n 20(None)[]:
	i: 0(f)
	o: 21()

nname: 12
n 12(None)[return False
]:
	i: 0(t)
	o: 21()

nname: 0
n 0(oXMLNode == None)[]:
	i: 
	o: 12(t), 20(f)

nname: 49
n 49(None)[PeriodicScheduling.LoadFromXML(self, oXMLNode)
return True
]:
	i: 0()
	o: 

nname: 0
n 0(None)[if oXMLNode == None:
	return False
if oXMLNode.attrib['type'] != 'weekly':
	return False
]:
	i: 
	o: 49()

nname: 0
n 0(None)[if oXMLNode == None:
	return False
if oXMLNode.attrib['type'] != 'weekly':
	return False
PeriodicScheduling.LoadFromXML(self, oXMLNode)
return True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb756eecc>}
nname: 6
n 6(None)[__doc__ = '\n    particular case of ConstantPeriodRule\n    '
def __init__(self, oLimit=None):
	ConstantPeriodRule.__init__(self, datetime.timedelta(7), oLimit)

def SaveToXMLNode(self, oXMLNode):
	if oXMLNode == None:
		return False
	PeriodicScheduling.SaveToXMLNode(self, oXMLNode)
	oXMLNode.attrib['type'] = 'weekly'
	return True

def LoadFromXML(self, oXMLNode):
	if oXMLNode == None:
		return False
	if oXMLNode.attrib['type'] != 'weekly':
		return False
	PeriodicScheduling.LoadFromXML(self, oXMLNode)
	return True

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb756e72c>}
nname: 0
n 0(None)[self.value = value
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb756e30c>}
nname: 0
n 0(None)[return repr(self.value)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb756e58c>}
nname: 6
n 6(None)[__doc__ = ' exception raised by PeriodicScheduling objects\n    '
def __init__(self, value):
	self.value = value

def __str__(self):
	return repr(self.value)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb756e3cc>}
nname: 162
n 162(None)[return instance
]:
	i: 12(), 38(), 64(), 90(), 116(), 142(), 155()
	o: 

nname: 155
n 155(None)[instance = None
]:
	i: 129(f)
	o: 162()

nname: 142
n 142(None)[instance = TimeDeltaListRule()
]:
	i: 129(t)
	o: 162()

nname: 129
n 129(rule_type == 'time_delta')[]:
	i: 103(f)
	o: 142(t), 155(f)

nname: 116
n 116(None)[instance = ConstantPeriodRule()
]:
	i: 103(t)
	o: 162()

nname: 103
n 103(rule_type == 'constant_period')[]:
	i: 77(f)
	o: 116(t), 129(f)

nname: 90
n 90(None)[instance = RelativeDayPosInMonthRule()
]:
	i: 77(t)
	o: 162()

nname: 77
n 77(rule_type == 'relative_day_pos_in_month')[]:
	i: 51(f)
	o: 90(t), 103(f)

nname: 64
n 64(None)[instance = DayListRule()
]:
	i: 51(t)
	o: 162()

nname: 51
n 51(rule_type == 'day_list')[]:
	i: 25(f)
	o: 64(t), 77(f)

nname: 38
n 38(None)[instance = DailyRule()
]:
	i: 25(t)
	o: 162()

nname: 25
n 25(rule_type == 'daily')[]:
	i: 0(f)
	o: 38(t), 51(f)

nname: 12
n 12(None)[instance = WeeklyRule()
]:
	i: 0(t)
	o: 162()

nname: 0
n 0(rule_type == 'weekly')[]:
	i: 
	o: 12(t), 25(f)

nname: 0
n 0(None)[if rule_type == 'weekly':
	instance = WeeklyRule()
else:
	if rule_type == 'daily':
		instance = DailyRule()
	else:
		if rule_type == 'day_list':
			instance = DayListRule()
		else:
			if rule_type == 'relative_day_pos_in_month':
				instance = RelativeDayPosInMonthRule()
			else:
				if rule_type == 'constant_period':
					instance = ConstantPeriodRule()
				else:
					if rule_type == 'time_delta':
						instance = TimeDeltaListRule()
					else:
						instance = None
return instance
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7571d0c>}
nname: 0
n 0(None)[oXMLNode.append(ET.Element('date_time', year=str(oDateTime.year), month=str(oDateTime.month), day=str(oDateTime.day), hour=str(oDateTime.hour), minute=str(oDateTime.minute), second=str(oDateTime.second)))
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7571bec>}
nname: 138
n 138(None)[return None
]:
	i: 27(), 137()
	o: 

nname: 137
n 137(None)[]:
	i: 0(f)
	o: 138()

nname: 27
n 27(None)[return datetime.datetime(int(node_date_time.attrib['year']), int(node_date_time.attrib['month']), int(node_date_time.attrib['day']), int(node_date_time.attrib['hour']), int(node_date_time.attrib['minute']), int(node_date_time.attrib['second']))
]:
	i: 0(t)
	o: 138()

nname: 0
n 0(node_date_time != None)[node_date_time = oXMLNode.find('date_time')
]:
	i: 
	o: 27(t), 137(f)

nname: 0
n 0(None)[node_date_time = oXMLNode.find('date_time')
if node_date_time != None:
	return datetime.datetime(int(node_date_time.attrib['year']), int(node_date_time.attrib['month']), int(node_date_time.attrib['day']), int(node_date_time.attrib['hour']), int(node_date_time.attrib['minute']), int(node_date_time.attrib['second']))
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb757112c>}
nname: 0
n 0(None)[oXMLNode.append(ET.Element('time_delta', days=str(oTimeDelta.days), seconds=str(oTimeDelta.seconds)))
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75715cc>}
nname: 91
n 91(None)[return None
]:
	i: 44(), 90()
	o: 

nname: 90
n 90(None)[]:
	i: 32(f)
	o: 91()

nname: 44
n 44(None)[return datetime.timedelta(int(node_time_delta.attrib['days']), int(node_time_delta.attrib['seconds']))
]:
	i: 32(t)
	o: 91()

nname: 32
n 32(node_time_delta != None)[]:
	i: 6(), 25()
	o: 44(t), 90(f)

nname: 25
n 25(None)[node_time_delta = oXMLNode
]:
	i: 0(f)
	o: 32()

nname: 6
n 6(None)[node_time_delta = oXMLNode.find('time_delta')
]:
	i: 0(t)
	o: 32()

nname: 0
n 0(look_for_time_delta)[]:
	i: 
	o: 6(t), 25(f)

nname: 91
n 91(None)[return None
]:
	i: 0()
	o: 

nname: 0
n 0(None)[if look_for_time_delta:
	node_time_delta = oXMLNode.find('time_delta')
else:
	node_time_delta = oXMLNode
if node_time_delta != None:
	return datetime.timedelta(int(node_time_delta.attrib['days']), int(node_time_delta.attrib['seconds']))
]:
	i: 
	o: 91()

nname: 0
n 0(None)[if look_for_time_delta:
	node_time_delta = oXMLNode.find('time_delta')
else:
	node_time_delta = oXMLNode
if node_time_delta != None:
	return datetime.timedelta(int(node_time_delta.attrib['days']), int(node_time_delta.attrib['seconds']))
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7571b0c>}
nname: 0
n 0(None)[__doc__ = ' This module gives a set of class useful to schedule a periodic event\n    \n    usage : call GetNextTime method in order to get next occurence\n        => return an Except\n    \n    UseCase sample :\n    \n    1) dayly repeat datetime = t1 => \n        repetitionRule = DailyRule()\n        repetitionRule.GetNext(t2,t1,True) => return the first datetime after t2 \n        that match t1 reference  and the repetition  rule\n    \n    2) same for weekly => repetitionRule = WeeklyRepetition\n        repetitionRule = WeeklyRule()\n    \n    3) monday to friday\n        repetitionRule = DayListRule(range(5))\n        \n    5) tuesday, saturday, sunday\n        repetitionRule = DayListRule([1,5,6])\n        \n    6) first day of the month\n        repetitionRule = RelativeDayPosInMonthRule(0)\n        \n    7) last day of the month \n        repetitionRule = RelativeDayPosInMonthRule(-1)\n\n    7) last saturday of the month\n        repetitionRule = RelativeDayPosInMonthRule(-7)                    => 7 day before the end of the month\n        repetitionRule.child = DayListRule([5], datetime.timedelta(7))    => every saturday during 7 days (means first saturday)\n    \n    8) first saturday of the month\n        repetitionRule = RelativeDayPosInMonthRule(0)                        => first day of the month\n        repetitionRule.child = DayListRule([5], datetime.timedelta(7))       => every saturday during 7 days (means first saturday)\n\n'
import datetime
import time
import xml.etree.cElementTree as ET
from recording import Recording
from logger import log
class PeriodicScheduling(object):
	__doc__ = ' main class\n    \n    manage the GetNextTime algorithm\n    manage the generic limit time check\n    manage reccursive child mecanism\n    \n    A PeriodicScheduling is used do define a rule of repetition for an event.\n    the rule is applied using the only exported interface : GetNextTime\n    \n    the optional attribute limit defines the maximum delta time allowed for the rule\n    it means that return value of GetNextTime is always less than the "current + self.limit" (where current is a param of GetNextTime) \n    '
	def __init__(self, limit=None):
		self.id = 0
		self.limit = limit
		self.child = None
		self.extern_rule_name = ''
		self.is_active = False
		self.last_time = None
		self.recording_ref = None
		return None

	def GetExternName(self):
		return self.extern_rule_name

	def _NextBeforeOrEqualTarget(self, minToGo, current):
		pass

	def _NextAfterTarget(self, minToGo, current):
		pass

	def _CheckTimeLimitIsOK(self, timeToCheck, timeRef, raiseException=True):
		if self.limit:
			if timeToCheck - timeRef >= self.limit:
				if raiseException:
					raise PeriodicSchedulingException('over limit')
				else:
					return False
		return True

	def GetNextTime(self, minToGo, current, forceTrue=False):
		if not self.child:
			ret = self._NextBeforeOrEqualTarget(minToGo, current)
			if ret < minToGo or ret == minToGo and forceTrue:
				ret = self._NextAfterTarget(minToGo, current)
		else:
			ret = self._NextBeforeOrEqualTarget(minToGo, current)
			exception = False
			if self.child:
				try:
					ret = self.child.GetNextTime(minToGo, ret, forceTrue)
				except PeriodicSchedulingException:
					exception = True
			if exception or ret < minToGo or ret == minToGo and forceTrue:
				ret = self._NextAfterTarget(minToGo, current)
				ret = self.child.GetNextTime(minToGo, ret, forceTrue)
		return ret

	def SaveToXMLNode(self, oXMLNode):
		if oXMLNode == None:
			return False
		node_ext_name = ET.Element('extern_name')
		node_ext_name.text = self.extern_rule_name
		oXMLNode.append(node_ext_name)
		node_is_active = ET.Element('is_active')
		if self.is_active:
			node_is_active.text = 'true'
		else:
			node_is_active.text = 'false'
		oXMLNode.append(node_is_active)
		if self.last_time:
			node_last_time = ET.Element('last_time')
			DateTimeToXml(node_last_time, self.last_time)
			oXMLNode.append(node_last_time)
		if self.recording_ref:
			node_recording_ref = ET.Element('recording_ref')
			self.recording_ref.SaveToXMLNode(node_recording_ref)
			oXMLNode.append(node_recording_ref)
		if self.limit != None:
			node_limit = ET.Element('limit')
			TimeDeltaToXml(node_limit, self.limit)
			oXMLNode.append(node_limit)
		if self.child != None:
			node_child = ET.Element('child')
			self.child.SaveToXMLNode(node_child)
			oXMLNode.append(node_child)
		return True

	def LoadFromXML(self, oXMLNode):
		if oXMLNode == None:
			return False
		self.extern_rule_name = ''
		node_ext_name = oXMLNode.find('extern_name')
		if node_ext_name != None:
			self.extern_rule_name = node_ext_name.text
		self.is_active = False
		node_is_active = oXMLNode.find('is_active')
		if node_is_active != None:
			if node_is_active.text == 'true':
				self.is_active = True
		self.last_time = None
		node_last_time = oXMLNode.find('last_time')
		if node_last_time:
			self.last_time = GetDateTimeFromXmlNode(node_last_time)
		self.recording_ref = None
		node_recording_ref = oXMLNode.find('recording_ref')
		if node_recording_ref:
			rec = Recording(None, None, None)
			rec.LoadFromXML(node_recording_ref)
			self.recording_ref = rec
		self.limit = None
		node_limit = oXMLNode.find('limit')
		if node_limit != None:
			self.limit = GetTimeDeltaFromXmlNode(node_limit)
		node_child = oXMLNode.find('child')
		if node_child != None:
			rule = GetPeriodicSchedulingInstanceFactory(node_child.attrib['type'])
			rule.LoadFromXML(node_child)
			self.child = rule
		return True



class TimeDeltaListRule(PeriodicScheduling):
	__doc__ = '\n        the rule is a list of datetime.timeldelta\n    '
	def __init__(self, deltaList=None):
		PeriodicScheduling.__init__(self)
		if deltaList:
			self.deltaList = deltaList
		else:
			self.deltalist = [datetime.timedelta(0)]
		if deltaList:
			deltaList.sort()

	def _NextBeforeOrEqualTarget(self, minToGo, current):
		ret, last = current + self.deltaList[0], current + self.deltaList[0]
		for i in self.deltaList:
			last = ret
			ret = current + i
			if ret > minToGo:
				break
				continue
		return last

	def _NextAfterTarget(self, minToGo, current):
		ret = current + self.deltaList[0]
		for i in self.deltaList:
			ret = current + i
			if ret > minToGo:
				break
				continue
		else:
			raise PeriodicSchedulingException('higher failed')
		return ret

	def SaveToXMLNode(self, oXMLNode):
		if oXMLNode == None:
			return False
		oXMLNode.attrib['type'] = 'time_delta'
		node_time_delta_list = ET.Element('time_delta_list')
		for d in self.deltaList:
			TimeDeltaToXml(node_time_delta_list, d)
		oXMLNode.append(node_time_delta_list)
		PeriodicScheduling.SaveToXMLNode(self, oXMLNode)
		return True

	def LoadFromXML(self, oXMLNode):
		if oXMLNode == None:
			return False
		if oXMLNode.attrib['type'] != 'time_delta':
			return False
		PeriodicScheduling.LoadFromXML(self, oXMLNode)
		self.deltaList = []
		node_time_delta_list = oXMLNode.find('time_delta_list')
		if node_time_delta_list != None:
			nodes_d = node_time_delta_list.getiterator('time_delta')
			for node_d in nodes_d:
				self.deltaList.append(GetTimeDeltaFromXmlNode(node_d, False))
		return True



class ConstantPeriodRule(PeriodicScheduling):
	__doc__ = '\n    the rule is a constant period in datetime.timedelta\n    '
	def __init__(self, period=None, limit=None):
		PeriodicScheduling.__init__(self, limit)
		if period:
			self.period = period
		else:
			self.period = datetime.timedelta(0)

	def _NextBeforeOrEqualTarget(self, minToGo, current):
		if not self.period:
			raise PeriodicSchedulingException('period null')
		ret, last = current, current
		while ret <= minToGo and self._CheckTimeLimitIsOK(ret, current, False):
			last = ret
			ret += self.period
		return last

	def _NextAfterTarget(self, minToGo, current):
		if not self.period:
			raise PeriodicSchedulingException('period null')
		ret = current
		while ret <= minToGo:
			ret += self.period
		self._CheckTimeLimitIsOK(ret, current)
		return ret

	def SaveToXMLNode(self, oXMLNode):
		if oXMLNode == None:
			return False
		oXMLNode.attrib['type'] = 'constant_period'
		node_period = ET.Element('period')
		TimeDeltaToXml(node_period, self.period)
		oXMLNode.append(node_period)
		PeriodicScheduling.SaveToXMLNode(self, oXMLNode)
		return True

	def LoadFromXML(self, oXMLNode):
		if oXMLNode == None:
			return False
		if oXMLNode.attrib['type'] != 'constant_period':
			return False
		PeriodicScheduling.LoadFromXML(self, oXMLNode)
		self.pos = 0
		node_period = oXMLNode.find('period')
		if node_period != None:
			self.period = GetTimeDeltaFromXmlNode(node_period)
		return True



class RelativeDayPosInMonthRule(PeriodicScheduling):
	__doc__ = '\n    the rule is a day offset in month\n    \n    0 means the first day of the month\n    -1 means the last day of the month\n    '
	def __init__(self, pos=0, limit=None):
		PeriodicScheduling.__init__(self, limit)
		self.pos = pos

	def _increaseMonth(self, time):
		if time.month == 12:
			return time.replace(year=time.year + 1, month=1)
		else:
			return time.replace(month=time.month + 1)

	def _NextBeforeOrEqualTarget(self, minToGo, current):
		tmp = current.replace(day=1)
		ret, last = tmp + datetime.timedelta(self.pos), tmp + datetime.timedelta(self.pos)
		while ret <= minToGo and self._CheckTimeLimitIsOK(ret, current, False):
			last = ret
			tmp = self._increaseMonth(tmp)
			ret = tmp + datetime.timedelta(self.pos)
		return last

	def _NextAfterTarget(self, minToGo, current):
		tmp = current.replace(day=1)
		ret = tmp + datetime.timedelta(self.pos)
		while ret <= minToGo:
			tmp = self._increaseMonth(tmp)
			ret = tmp + datetime.timedelta(self.pos)
		self._CheckTimeLimitIsOK(ret, current)
		return ret

	def SaveToXMLNode(self, oXMLNode):
		if oXMLNode == None:
			return False
		oXMLNode.attrib['type'] = 'relative_day_pos_in_month'
		node_pos = ET.Element('pos')
		node_pos.text = str(self.pos)
		oXMLNode.append(node_pos)
		PeriodicScheduling.SaveToXMLNode(self, oXMLNode)
		return True

	def LoadFromXML(self, oXMLNode):
		if oXMLNode == None:
			return False
		if oXMLNode.attrib['type'] != 'relative_day_pos_in_month':
			return False
		PeriodicScheduling.LoadFromXML(self, oXMLNode)
		self.pos = 0
		node_pos = oXMLNode.find('pos')
		if node_pos != None:
			self.pos = int(node_pos.text)
		return True



class DayListRule(PeriodicScheduling):
	__doc__ = '\n    the rule is a list of days\n    0 for monday\n    6 for sunday\n    '
	def __init__(self, dayList=None, limit=None):
		PeriodicScheduling.__init__(self, limit)
		if dayList:
			self.dayList = dayList
		else:
			self.dayList, dayList = [0], [0]

	def _findNextDay(self, time, day, acceptFirstDay=False):
		today = time.weekday()
		deltaDay = (day - today) % 7
		if deltaDay == 0:
			if not acceptFirstDay:
				deltaDay = 7
		return time + datetime.timedelta(deltaDay)

	def _NextBeforeOrEqualTarget(self, minToGo, current):
		ret, last = self._findNextDay(current, self.dayList[0], True), self._findNextDay(current, self.dayList[0], True)
		i = 1
		while ret <= minToGo and self._CheckTimeLimitIsOK(ret, current, False):
			last = ret
			ret = self._findNextDay(ret, self.dayList[i % len(self.dayList)])
			i += 1
		return last

	def _NextAfterTarget(self, minToGo, current):
		ret = self._findNextDay(current, self.dayList[0], True)
		i = 1
		while ret <= minToGo:
			ret = self._findNextDay(ret, self.dayList[i % len(self.dayList)])
			i += 1
		self._CheckTimeLimitIsOK(ret, current)
		return ret

	def SaveToXMLNode(self, oXMLNode):
		if oXMLNode == None:
			return False
		oXMLNode.attrib['type'] = 'day_list'
		node_days = ET.Element('days')
		for day in self.dayList:
			node_day = ET.Element('day')
			node_day.text = str(day)
			node_days.append(node_day)
		oXMLNode.append(node_days)
		PeriodicScheduling.SaveToXMLNode(self, oXMLNode)
		return True

	def LoadFromXML(self, oXMLNode):
		if oXMLNode == None:
			return False
		if oXMLNode.attrib['type'] != 'day_list':
			return False
		PeriodicScheduling.LoadFromXML(self, oXMLNode)
		self.dayList = []
		node_days = oXMLNode.find('days')
		if node_days != None:
			nodes_day = node_days.getiterator('day')
			for node_day in nodes_day:
				self.dayList.append(int(node_day.text))
		return True



class DailyRule(ConstantPeriodRule):
	__doc__ = '\n    particular case of ConstantPeriodRule\n    '
	def __init__(self, oLimit=None):
		ConstantPeriodRule.__init__(self, datetime.timedelta(1), oLimit)

	def SaveToXMLNode(self, oXMLNode):
		if oXMLNode == None:
			return False
		PeriodicScheduling.SaveToXMLNode(self, oXMLNode)
		oXMLNode.attrib['type'] = 'daily'
		return True

	def LoadFromXML(self, oXMLNode):
		if oXMLNode == None:
			return False
		if oXMLNode.attrib['type'] != 'daily':
			return False
		PeriodicScheduling.LoadFromXML(self, oXMLNode)
		return True



class WeeklyRule(ConstantPeriodRule):
	__doc__ = '\n    particular case of ConstantPeriodRule\n    '
	def __init__(self, oLimit=None):
		ConstantPeriodRule.__init__(self, datetime.timedelta(7), oLimit)

	def SaveToXMLNode(self, oXMLNode):
		if oXMLNode == None:
			return False
		PeriodicScheduling.SaveToXMLNode(self, oXMLNode)
		oXMLNode.attrib['type'] = 'weekly'
		return True

	def LoadFromXML(self, oXMLNode):
		if oXMLNode == None:
			return False
		if oXMLNode.attrib['type'] != 'weekly':
			return False
		PeriodicScheduling.LoadFromXML(self, oXMLNode)
		return True



class PeriodicSchedulingException(Exception):
	__doc__ = ' exception raised by PeriodicScheduling objects\n    '
	def __init__(self, value):
		self.value = value

	def __str__(self):
		return repr(self.value)



def GetPeriodicSchedulingInstanceFactory(rule_type):
	if rule_type == 'weekly':
		instance = WeeklyRule()
	else:
		if rule_type == 'daily':
			instance = DailyRule()
		else:
			if rule_type == 'day_list':
				instance = DayListRule()
			else:
				if rule_type == 'relative_day_pos_in_month':
					instance = RelativeDayPosInMonthRule()
				else:
					if rule_type == 'constant_period':
						instance = ConstantPeriodRule()
					else:
						if rule_type == 'time_delta':
							instance = TimeDeltaListRule()
						else:
							instance = None
	return instance

def DateTimeToXml(oXMLNode, oDateTime):
	oXMLNode.append(ET.Element('date_time', year=str(oDateTime.year), month=str(oDateTime.month), day=str(oDateTime.day), hour=str(oDateTime.hour), minute=str(oDateTime.minute), second=str(oDateTime.second)))

def GetDateTimeFromXmlNode(oXMLNode):
	node_date_time = oXMLNode.find('date_time')
	if node_date_time != None:
		return datetime.datetime(int(node_date_time.attrib['year']), int(node_date_time.attrib['month']), int(node_date_time.attrib['day']), int(node_date_time.attrib['hour']), int(node_date_time.attrib['minute']), int(node_date_time.attrib['second']))
	return None

def TimeDeltaToXml(oXMLNode, oTimeDelta):
	oXMLNode.append(ET.Element('time_delta', days=str(oTimeDelta.days), seconds=str(oTimeDelta.seconds)))

def GetTimeDeltaFromXmlNode(oXMLNode, look_for_time_delta=True):
	if look_for_time_delta:
		node_time_delta = oXMLNode.find('time_delta')
	else:
		node_time_delta = oXMLNode
	if node_time_delta != None:
		return datetime.timedelta(int(node_time_delta.attrib['days']), int(node_time_delta.attrib['seconds']))
	return None

]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75642ac>}
__doc__ = ' This module gives a set of class useful to schedule a periodic event\n    \n    usage : call GetNextTime method in order to get next occurence\n        => return an Except\n    \n    UseCase sample :\n    \n    1) dayly repeat datetime = t1 => \n        repetitionRule = DailyRule()\n        repetitionRule.GetNext(t2,t1,True) => return the first datetime after t2 \n        that match t1 reference  and the repetition  rule\n    \n    2) same for weekly => repetitionRule = WeeklyRepetition\n        repetitionRule = WeeklyRule()\n    \n    3) monday to friday\n        repetitionRule = DayListRule(range(5))\n        \n    5) tuesday, saturday, sunday\n        repetitionRule = DayListRule([1,5,6])\n        \n    6) first day of the month\n        repetitionRule = RelativeDayPosInMonthRule(0)\n        \n    7) last day of the month \n        repetitionRule = RelativeDayPosInMonthRule(-1)\n\n    7) last saturday of the month\n        repetitionRule = RelativeDayPosInMonthRule(-7)                    => 7 day before the end of the month\n        repetitionRule.child = DayListRule([5], datetime.timedelta(7))    => every saturday during 7 days (means first saturday)\n    \n    8) first saturday of the month\n        repetitionRule = RelativeDayPosInMonthRule(0)                        => first day of the month\n        repetitionRule.child = DayListRule([5], datetime.timedelta(7))       => every saturday during 7 days (means first saturday)\n\n'
import datetime
import time
import xml.etree.cElementTree as ET
from recording import Recording
from logger import log
class PeriodicScheduling(object):
	__doc__ = ' main class\n    \n    manage the GetNextTime algorithm\n    manage the generic limit time check\n    manage reccursive child mecanism\n    \n    A PeriodicScheduling is used do define a rule of repetition for an event.\n    the rule is applied using the only exported interface : GetNextTime\n    \n    the optional attribute limit defines the maximum delta time allowed for the rule\n    it means that return value of GetNextTime is always less than the "current + self.limit" (where current is a param of GetNextTime) \n    '
	def __init__(self, limit=None):
		self.id = 0
		self.limit = limit
		self.child = None
		self.extern_rule_name = ''
		self.is_active = False
		self.last_time = None
		self.recording_ref = None
		return None

	def GetExternName(self):
		return self.extern_rule_name

	def _NextBeforeOrEqualTarget(self, minToGo, current):
		pass

	def _NextAfterTarget(self, minToGo, current):
		pass

	def _CheckTimeLimitIsOK(self, timeToCheck, timeRef, raiseException=True):
		if self.limit:
			if timeToCheck - timeRef >= self.limit:
				if raiseException:
					raise PeriodicSchedulingException('over limit')
				else:
					return False
		return True

	def GetNextTime(self, minToGo, current, forceTrue=False):
		if not self.child:
			ret = self._NextBeforeOrEqualTarget(minToGo, current)
			if ret < minToGo or ret == minToGo and forceTrue:
				ret = self._NextAfterTarget(minToGo, current)
		else:
			ret = self._NextBeforeOrEqualTarget(minToGo, current)
			exception = False
			if self.child:
				try:
					ret = self.child.GetNextTime(minToGo, ret, forceTrue)
				except PeriodicSchedulingException:
					exception = True
			if exception or ret < minToGo or ret == minToGo and forceTrue:
				ret = self._NextAfterTarget(minToGo, current)
				ret = self.child.GetNextTime(minToGo, ret, forceTrue)
		return ret

	def SaveToXMLNode(self, oXMLNode):
		if oXMLNode == None:
			return False
		node_ext_name = ET.Element('extern_name')
		node_ext_name.text = self.extern_rule_name
		oXMLNode.append(node_ext_name)
		node_is_active = ET.Element('is_active')
		if self.is_active:
			node_is_active.text = 'true'
		else:
			node_is_active.text = 'false'
		oXMLNode.append(node_is_active)
		if self.last_time:
			node_last_time = ET.Element('last_time')
			DateTimeToXml(node_last_time, self.last_time)
			oXMLNode.append(node_last_time)
		if self.recording_ref:
			node_recording_ref = ET.Element('recording_ref')
			self.recording_ref.SaveToXMLNode(node_recording_ref)
			oXMLNode.append(node_recording_ref)
		if self.limit != None:
			node_limit = ET.Element('limit')
			TimeDeltaToXml(node_limit, self.limit)
			oXMLNode.append(node_limit)
		if self.child != None:
			node_child = ET.Element('child')
			self.child.SaveToXMLNode(node_child)
			oXMLNode.append(node_child)
		return True

	def LoadFromXML(self, oXMLNode):
		if oXMLNode == None:
			return False
		self.extern_rule_name = ''
		node_ext_name = oXMLNode.find('extern_name')
		if node_ext_name != None:
			self.extern_rule_name = node_ext_name.text
		self.is_active = False
		node_is_active = oXMLNode.find('is_active')
		if node_is_active != None:
			if node_is_active.text == 'true':
				self.is_active = True
		self.last_time = None
		node_last_time = oXMLNode.find('last_time')
		if node_last_time:
			self.last_time = GetDateTimeFromXmlNode(node_last_time)
		self.recording_ref = None
		node_recording_ref = oXMLNode.find('recording_ref')
		if node_recording_ref:
			rec = Recording(None, None, None)
			rec.LoadFromXML(node_recording_ref)
			self.recording_ref = rec
		self.limit = None
		node_limit = oXMLNode.find('limit')
		if node_limit != None:
			self.limit = GetTimeDeltaFromXmlNode(node_limit)
		node_child = oXMLNode.find('child')
		if node_child != None:
			rule = GetPeriodicSchedulingInstanceFactory(node_child.attrib['type'])
			rule.LoadFromXML(node_child)
			self.child = rule
		return True



class TimeDeltaListRule(PeriodicScheduling):
	__doc__ = '\n        the rule is a list of datetime.timeldelta\n    '
	def __init__(self, deltaList=None):
		PeriodicScheduling.__init__(self)
		if deltaList:
			self.deltaList = deltaList
		else:
			self.deltalist = [datetime.timedelta(0)]
		if deltaList:
			deltaList.sort()

	def _NextBeforeOrEqualTarget(self, minToGo, current):
		ret, last = current + self.deltaList[0], current + self.deltaList[0]
		for i in self.deltaList:
			last = ret
			ret = current + i
			if ret > minToGo:
				break
				continue
		return last

	def _NextAfterTarget(self, minToGo, current):
		ret = current + self.deltaList[0]
		for i in self.deltaList:
			ret = current + i
			if ret > minToGo:
				break
				continue
		else:
			raise PeriodicSchedulingException('higher failed')
		return ret

	def SaveToXMLNode(self, oXMLNode):
		if oXMLNode == None:
			return False
		oXMLNode.attrib['type'] = 'time_delta'
		node_time_delta_list = ET.Element('time_delta_list')
		for d in self.deltaList:
			TimeDeltaToXml(node_time_delta_list, d)
		oXMLNode.append(node_time_delta_list)
		PeriodicScheduling.SaveToXMLNode(self, oXMLNode)
		return True

	def LoadFromXML(self, oXMLNode):
		if oXMLNode == None:
			return False
		if oXMLNode.attrib['type'] != 'time_delta':
			return False
		PeriodicScheduling.LoadFromXML(self, oXMLNode)
		self.deltaList = []
		node_time_delta_list = oXMLNode.find('time_delta_list')
		if node_time_delta_list != None:
			nodes_d = node_time_delta_list.getiterator('time_delta')
			for node_d in nodes_d:
				self.deltaList.append(GetTimeDeltaFromXmlNode(node_d, False))
		return True



class ConstantPeriodRule(PeriodicScheduling):
	__doc__ = '\n    the rule is a constant period in datetime.timedelta\n    '
	def __init__(self, period=None, limit=None):
		PeriodicScheduling.__init__(self, limit)
		if period:
			self.period = period
		else:
			self.period = datetime.timedelta(0)

	def _NextBeforeOrEqualTarget(self, minToGo, current):
		if not self.period:
			raise PeriodicSchedulingException('period null')
		ret, last = current, current
		while ret <= minToGo and self._CheckTimeLimitIsOK(ret, current, False):
			last = ret
			ret += self.period
		return last

	def _NextAfterTarget(self, minToGo, current):
		if not self.period:
			raise PeriodicSchedulingException('period null')
		ret = current
		while ret <= minToGo:
			ret += self.period
		self._CheckTimeLimitIsOK(ret, current)
		return ret

	def SaveToXMLNode(self, oXMLNode):
		if oXMLNode == None:
			return False
		oXMLNode.attrib['type'] = 'constant_period'
		node_period = ET.Element('period')
		TimeDeltaToXml(node_period, self.period)
		oXMLNode.append(node_period)
		PeriodicScheduling.SaveToXMLNode(self, oXMLNode)
		return True

	def LoadFromXML(self, oXMLNode):
		if oXMLNode == None:
			return False
		if oXMLNode.attrib['type'] != 'constant_period':
			return False
		PeriodicScheduling.LoadFromXML(self, oXMLNode)
		self.pos = 0
		node_period = oXMLNode.find('period')
		if node_period != None:
			self.period = GetTimeDeltaFromXmlNode(node_period)
		return True



class RelativeDayPosInMonthRule(PeriodicScheduling):
	__doc__ = '\n    the rule is a day offset in month\n    \n    0 means the first day of the month\n    -1 means the last day of the month\n    '
	def __init__(self, pos=0, limit=None):
		PeriodicScheduling.__init__(self, limit)
		self.pos = pos

	def _increaseMonth(self, time):
		if time.month == 12:
			return time.replace(year=time.year + 1, month=1)
		else:
			return time.replace(month=time.month + 1)

	def _NextBeforeOrEqualTarget(self, minToGo, current):
		tmp = current.replace(day=1)
		ret, last = tmp + datetime.timedelta(self.pos), tmp + datetime.timedelta(self.pos)
		while ret <= minToGo and self._CheckTimeLimitIsOK(ret, current, False):
			last = ret
			tmp = self._increaseMonth(tmp)
			ret = tmp + datetime.timedelta(self.pos)
		return last

	def _NextAfterTarget(self, minToGo, current):
		tmp = current.replace(day=1)
		ret = tmp + datetime.timedelta(self.pos)
		while ret <= minToGo:
			tmp = self._increaseMonth(tmp)
			ret = tmp + datetime.timedelta(self.pos)
		self._CheckTimeLimitIsOK(ret, current)
		return ret

	def SaveToXMLNode(self, oXMLNode):
		if oXMLNode == None:
			return False
		oXMLNode.attrib['type'] = 'relative_day_pos_in_month'
		node_pos = ET.Element('pos')
		node_pos.text = str(self.pos)
		oXMLNode.append(node_pos)
		PeriodicScheduling.SaveToXMLNode(self, oXMLNode)
		return True

	def LoadFromXML(self, oXMLNode):
		if oXMLNode == None:
			return False
		if oXMLNode.attrib['type'] != 'relative_day_pos_in_month':
			return False
		PeriodicScheduling.LoadFromXML(self, oXMLNode)
		self.pos = 0
		node_pos = oXMLNode.find('pos')
		if node_pos != None:
			self.pos = int(node_pos.text)
		return True



class DayListRule(PeriodicScheduling):
	__doc__ = '\n    the rule is a list of days\n    0 for monday\n    6 for sunday\n    '
	def __init__(self, dayList=None, limit=None):
		PeriodicScheduling.__init__(self, limit)
		if dayList:
			self.dayList = dayList
		else:
			self.dayList, dayList = [0], [0]

	def _findNextDay(self, time, day, acceptFirstDay=False):
		today = time.weekday()
		deltaDay = (day - today) % 7
		if deltaDay == 0:
			if not acceptFirstDay:
				deltaDay = 7
		return time + datetime.timedelta(deltaDay)

	def _NextBeforeOrEqualTarget(self, minToGo, current):
		ret, last = self._findNextDay(current, self.dayList[0], True), self._findNextDay(current, self.dayList[0], True)
		i = 1
		while ret <= minToGo and self._CheckTimeLimitIsOK(ret, current, False):
			last = ret
			ret = self._findNextDay(ret, self.dayList[i % len(self.dayList)])
			i += 1
		return last

	def _NextAfterTarget(self, minToGo, current):
		ret = self._findNextDay(current, self.dayList[0], True)
		i = 1
		while ret <= minToGo:
			ret = self._findNextDay(ret, self.dayList[i % len(self.dayList)])
			i += 1
		self._CheckTimeLimitIsOK(ret, current)
		return ret

	def SaveToXMLNode(self, oXMLNode):
		if oXMLNode == None:
			return False
		oXMLNode.attrib['type'] = 'day_list'
		node_days = ET.Element('days')
		for day in self.dayList:
			node_day = ET.Element('day')
			node_day.text = str(day)
			node_days.append(node_day)
		oXMLNode.append(node_days)
		PeriodicScheduling.SaveToXMLNode(self, oXMLNode)
		return True

	def LoadFromXML(self, oXMLNode):
		if oXMLNode == None:
			return False
		if oXMLNode.attrib['type'] != 'day_list':
			return False
		PeriodicScheduling.LoadFromXML(self, oXMLNode)
		self.dayList = []
		node_days = oXMLNode.find('days')
		if node_days != None:
			nodes_day = node_days.getiterator('day')
			for node_day in nodes_day:
				self.dayList.append(int(node_day.text))
		return True



class DailyRule(ConstantPeriodRule):
	__doc__ = '\n    particular case of ConstantPeriodRule\n    '
	def __init__(self, oLimit=None):
		ConstantPeriodRule.__init__(self, datetime.timedelta(1), oLimit)

	def SaveToXMLNode(self, oXMLNode):
		if oXMLNode == None:
			return False
		PeriodicScheduling.SaveToXMLNode(self, oXMLNode)
		oXMLNode.attrib['type'] = 'daily'
		return True

	def LoadFromXML(self, oXMLNode):
		if oXMLNode == None:
			return False
		if oXMLNode.attrib['type'] != 'daily':
			return False
		PeriodicScheduling.LoadFromXML(self, oXMLNode)
		return True



class WeeklyRule(ConstantPeriodRule):
	__doc__ = '\n    particular case of ConstantPeriodRule\n    '
	def __init__(self, oLimit=None):
		ConstantPeriodRule.__init__(self, datetime.timedelta(7), oLimit)

	def SaveToXMLNode(self, oXMLNode):
		if oXMLNode == None:
			return False
		PeriodicScheduling.SaveToXMLNode(self, oXMLNode)
		oXMLNode.attrib['type'] = 'weekly'
		return True

	def LoadFromXML(self, oXMLNode):
		if oXMLNode == None:
			return False
		if oXMLNode.attrib['type'] != 'weekly':
			return False
		PeriodicScheduling.LoadFromXML(self, oXMLNode)
		return True



class PeriodicSchedulingException(Exception):
	__doc__ = ' exception raised by PeriodicScheduling objects\n    '
	def __init__(self, value):
		self.value = value

	def __str__(self):
		return repr(self.value)



def GetPeriodicSchedulingInstanceFactory(rule_type):
	if rule_type == 'weekly':
		instance = WeeklyRule()
	else:
		if rule_type == 'daily':
			instance = DailyRule()
		else:
			if rule_type == 'day_list':
				instance = DayListRule()
			else:
				if rule_type == 'relative_day_pos_in_month':
					instance = RelativeDayPosInMonthRule()
				else:
					if rule_type == 'constant_period':
						instance = ConstantPeriodRule()
					else:
						if rule_type == 'time_delta':
							instance = TimeDeltaListRule()
						else:
							instance = None
	return instance

def DateTimeToXml(oXMLNode, oDateTime):
	oXMLNode.append(ET.Element('date_time', year=str(oDateTime.year), month=str(oDateTime.month), day=str(oDateTime.day), hour=str(oDateTime.hour), minute=str(oDateTime.minute), second=str(oDateTime.second)))

def GetDateTimeFromXmlNode(oXMLNode):
	node_date_time = oXMLNode.find('date_time')
	if node_date_time != None:
		return datetime.datetime(int(node_date_time.attrib['year']), int(node_date_time.attrib['month']), int(node_date_time.attrib['day']), int(node_date_time.attrib['hour']), int(node_date_time.attrib['minute']), int(node_date_time.attrib['second']))
	return None

def TimeDeltaToXml(oXMLNode, oTimeDelta):
	oXMLNode.append(ET.Element('time_delta', days=str(oTimeDelta.days), seconds=str(oTimeDelta.seconds)))

def GetTimeDeltaFromXmlNode(oXMLNode, look_for_time_delta=True):
	if look_for_time_delta:
		node_time_delta = oXMLNode.find('time_delta')
	else:
		node_time_delta = oXMLNode
	if node_time_delta != None:
		return datetime.timedelta(int(node_time_delta.attrib['days']), int(node_time_delta.attrib['seconds']))
	return None

