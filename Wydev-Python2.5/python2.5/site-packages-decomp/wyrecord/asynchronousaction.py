# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 0
n 0(None)[]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb777b3ec>}
nname: 0
n 0(None)[]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb777b54c>}
nname: 6
n 6(None)[__doc__ = ' an action is an object with an execute method.\n    '
def __init__(self):
	pass

def execute(self):
	pass

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb7772fac>}
nname: 0
n 0(None)[Thread.__init__(self)
self.action_list = []
self.quit = False
self.on_pause = False
self.protec_list = Lock()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb777bd4c>}
nname: 0
n 0(None)[self.protec_list.acquire()
self.action_list.append(action)
self.protec_list.release()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb777bbac>}
nname: 0
n 0(None)[self.on_pause = True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb777b98c>}
nname: 0
n 0(None)[self.on_pause = False
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb777b9cc>}
nname: 0
n 0(None)[self.quit = True
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb777b96c>}
nname: 213
n 213(None)[]:
	i: 0(AL), 211()
	o: 

nname: 211
n 211(None)[]:
	i: 3(t), 208()
	o: 213()

nname: 208
n 208(None)[]:
	i: 85(AL), 207()
	o: 211()

nname: 207
n 207(None)[]:
	i: 127(AF), 152()
	o: 208()

nname: 152
n 152(None)[action.execute()
self.protec_list.acquire()
self.action_list.remove(action)
self.protec_list.release()
]:
	i: 146(), 151()
	o: 207()

nname: 151
n 151(None)[]:
	i: 134(f)
	o: 152()

nname: 146
n 146(None)[break
]:
	i: 134(t)
	o: 152()

nname: 134
n 134(self.on_pause)[for action in loop_list:
]:
	i: 127(for)
	o: 146(t), 151(f)

nname: 127
n 127(None)[]:
	i: 85(loop)
	o: 134(for), 207(AF)

nname: 85
n 85(None)[self.protec_list.acquire()
loop_list = [] + self.action_list
self.protec_list.release()
]:
	i: 77(), 84()
	o: 127(loop), 208(AL)

nname: 84
n 84(None)[]:
	i: 55(f)
	o: 85()

nname: 77
n 77(None)[continue
]:
	i: 55(t)
	o: 85()

nname: 55
n 55(self.on_pause)[time.sleep(0.80000000000000004)
]:
	i: 12(AL), 53()
	o: 77(t), 84(f)

nname: 53
n 53(None)[_POP_TOP pass
]:
	i: 16&26(f), 36()
	o: 55()

nname: 36
n 36(None)[time.sleep(0.80000000000000004)
]:
	i: 16&26(t)
	o: 53()

nname: 16&26
n 16&26(not self.action_list or self.on_pause)[]:
	i: 12(loop)
	o: 36(t), 53(f)

nname: 12
n 12(None)[]:
	i: 3(f)
	o: 16&26(loop), 55(AL)

nname: 3
n 3(self.quit)[]:
	i: 0(loop)
	o: 12(f), 211(t)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 213(AL)

nname: 213
n 213(None)[]:
	i: 0(AL), 3(t), 55(AL), 127(AF), 134()
	o: 

nname: 134
n 134(None)[for action in loop_list:
if self.on_pause:
	break
action.execute()
self.protec_list.acquire()
self.action_list.remove(action)
self.protec_list.release()
]:
	i: 127(for)
	o: 213()

nname: 127
n 127(None)[]:
	i: 55(loop)
	o: 134(for), 213(AF)

nname: 55
n 55(None)[time.sleep(0.80000000000000004)
if self.on_pause:
	continue
self.protec_list.acquire()
loop_list = [] + self.action_list
self.protec_list.release()
]:
	i: 36()
	o: 127(loop), 213(AL)

nname: 36
n 36(None)[	time.sleep(0.80000000000000004)
else:
	_POP_TOP pass
]:
	i: 12(t)
	o: 55()

nname: 12
n 12(not self.action_list or self.on_pause)[while not self.action_list or self.on_pause:
]:
	i: 3(f)
	o: 36(t)

nname: 3
n 3(self.quit)[]:
	i: 0(loop)
	o: 12(f), 213(t)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 213(AL)

nname: 213
n 213(None)[]:
	i: 0(AL), 3(t), 55(AL), 127(AF), 134()
	o: 

nname: 134
n 134(None)[for action in loop_list:
if self.on_pause:
	break
action.execute()
self.protec_list.acquire()
self.action_list.remove(action)
self.protec_list.release()
]:
	i: 127(for)
	o: 213()

nname: 127
n 127(None)[]:
	i: 55(loop)
	o: 134(for), 213(AF)

nname: 55
n 55(None)[time.sleep(0.80000000000000004)
if self.on_pause:
	continue
self.protec_list.acquire()
loop_list = [] + self.action_list
self.protec_list.release()
]:
	i: 12()
	o: 127(loop), 213(AL)

nname: 12
n 12(None)[while not self.action_list or self.on_pause:
	time.sleep(0.80000000000000004)
else:
	_POP_TOP pass
]:
	i: 3(f)
	o: 55()

nname: 3
n 3(self.quit)[]:
	i: 0(loop)
	o: 12(f), 213(t)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 213(AL)

nname: 213
n 213(None)[]:
	i: 0(AL), 3(t), 12(AL), 127(AF), 134()
	o: 

nname: 134
n 134(None)[for action in loop_list:
if self.on_pause:
	break
action.execute()
self.protec_list.acquire()
self.action_list.remove(action)
self.protec_list.release()
]:
	i: 127(for)
	o: 213()

nname: 127
n 127(None)[]:
	i: 12(loop)
	o: 134(for), 213(AF)

nname: 12
n 12(None)[while not self.action_list or self.on_pause:
	time.sleep(0.80000000000000004)
else:
	_POP_TOP pass
time.sleep(0.80000000000000004)
if self.on_pause:
	continue
self.protec_list.acquire()
loop_list = [] + self.action_list
self.protec_list.release()
]:
	i: 3(f)
	o: 127(loop), 213(AL)

nname: 3
n 3(self.quit)[]:
	i: 0(loop)
	o: 12(f), 213(t)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 213(AL)

self.nodes: {0: <unpyclib.structure.node instance at 0xb7780f8c>, 213: <unpyclib.structure.node instance at 0xb7780dac>, 3: <unpyclib.structure.node instance at 0xb77804ac>, 134: <unpyclib.structure.node instance at 0xb778544c>, 12: <unpyclib.structure.node instance at 0xb778586c>, 127: <unpyclib.structure.node instance at 0xb77809ac>}
nname: 6
n 6(None)[__doc__ = ' this thread is used by wyrecord in order to do action in another thread.\n    '
__metaclass__ = MetaSingleton
def __init__(self):
	Thread.__init__(self)
	self.action_list = []
	self.quit = False
	self.on_pause = False
	self.protec_list = Lock()

def appendAction(self, action):
	self.protec_list.acquire()
	self.action_list.append(action)
	self.protec_list.release()

def pause(self):
	self.on_pause = True

def resume(self):
	self.on_pause = False

def exit(self):
	self.quit = True

def run(self):
	pass

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb777b7ec>}
nname: 0
n 0(None)[Thread.__init__(self)
self.service = None
self.live_controller = live_controller
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb777b76c>}
nname: 0
n 0(None)[self.service = service
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb777b68c>}
nname: 72
n 72(None)[return None
]:
	i: 0(AL), 70()
	o: 

nname: 70
n 70(None)[]:
	i: 3(f), 66()
	o: 72()

nname: 66
n 66(None)[]:
	i: 12(f), 53()
	o: 70()

nname: 53
n 53(None)[self.service = None
continue
]:
	i: 12(t)
	o: 66()

nname: 12
n 12(self.service == current_zap)[current_zap = self.service
self.live_controller.real_zap(current_zap)
]:
	i: 3(t)
	o: 53(t), 66(f)

nname: 3
n 3(self.service)[]:
	i: 0(loop)
	o: 12(t), 70(f)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 72(AL)

nname: 72
n 72(None)[return None
]:
	i: 0(AL), 3(f), 12()
	o: 

nname: 12
n 12(None)[current_zap = self.service
self.live_controller.real_zap(current_zap)
if self.service == current_zap:
	self.service = None
	continue
]:
	i: 3(t)
	o: 72()

nname: 3
n 3(self.service)[]:
	i: 0(loop)
	o: 12(t), 72(f)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 72(AL)

nname: 12
n 12(None)[	current_zap = self.service
	self.live_controller.real_zap(current_zap)
	if self.service == current_zap:
		self.service = None
		continue
return None
]:
	i: 0(t)
	o: 

nname: 0
n 0(self.service)[while self.service:
]:
	i: 
	o: 12(t)

nname: 0
n 0(None)[while self.service:
	current_zap = self.service
	self.live_controller.real_zap(current_zap)
	if self.service == current_zap:
		self.service = None
		continue
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb777beec>}
nname: 18
n 18(None)[return service_id == self.service
]:
	i: 9(), 17()
	o: 

nname: 17
n 17(None)[]:
	i: 0(t)
	o: 18()

nname: 9
n 9(None)[return True
]:
	i: 0(f)
	o: 18()

nname: 0
n 0(config.asynchronous_zap)[]:
	i: 
	o: 9(f), 17(t)

nname: 0
n 0(None)[if not config.asynchronous_zap:
	return True
return service_id == self.service
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb777b64c>}
nname: 6
n 6(None)[__doc__ = ' this thread is used by wyrecord in order to do action in another thread.\n    '
def __init__(self, live_controller):
	Thread.__init__(self)
	self.service = None
	self.live_controller = live_controller
	return None

def appendService(self, service):
	self.service = service

def run(self):
	while self.service:
		current_zap = self.service
		self.live_controller.real_zap(current_zap)
		if self.service == current_zap:
			self.service = None
			continue
	return None

def isRequiredService(self, service_id):
	if not config.asynchronous_zap:
		return True
	return service_id == self.service

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb7772f0c>}
nname: 0
n 0(None)[self.scheduler = scheduler
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb777b2ac>}
nname: 0
n 0(None)[self.scheduler.RealSaveRecordingList()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb777b5ec>}
nname: 6
n 6(None)[def __init__(self, scheduler):
	self.scheduler = scheduler

def execute(self):
	self.scheduler.RealSaveRecordingList()

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb7772f6c>}
nname: 0
n 0(None)[self.path = path
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb777b6ac>}
nname: 0
n 0(None)[log.debug('remove folder start: ' + self.path)
removeFolder(self.path)
log.debug('remove folder over: ' + self.path)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb777b6cc>}
nname: 6
n 6(None)[def __init__(self, path):
	self.path = path

def execute(self):
	log.debug('remove folder start: ' + self.path)
	removeFolder(self.path)
	log.debug('remove folder over: ' + self.path)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb7772f0c>}
nname: 0
n 0(None)[self.recorder_factory = recorder_factory
self.recorder_instance = recorder_instance
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb777b5ac>}
nname: 0
n 0(None)[self.recorder_factory.deleteRecorder(self.recorder_instance)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb777b12c>}
nname: 6
n 6(None)[def __init__(self, recorder_factory, recorder_instance):
	self.recorder_factory = recorder_factory
	self.recorder_instance = recorder_instance

def execute(self):
	self.recorder_factory.deleteRecorder(self.recorder_instance)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb7772dac>}
nname: 0
n 0(None)[from threading import Thread
from threading import Lock
from peewee.misc_utils import MetaSingleton
from tools import removeFolder
from logger import log
from config import *
import time
class Action():
	__doc__ = ' an action is an object with an execute method.\n    '
	def __init__(self):
		pass

	def execute(self):
		pass



class AsynchronousAction(Thread):
	__doc__ = ' this thread is used by wyrecord in order to do action in another thread.\n    '
	__metaclass__ = MetaSingleton
	def __init__(self):
		Thread.__init__(self)
		self.action_list = []
		self.quit = False
		self.on_pause = False
		self.protec_list = Lock()

	def appendAction(self, action):
		self.protec_list.acquire()
		self.action_list.append(action)
		self.protec_list.release()

	def pause(self):
		self.on_pause = True

	def resume(self):
		self.on_pause = False

	def exit(self):
		self.quit = True

	def run(self):
		pass



class AsynchronousZap(Thread):
	__doc__ = ' this thread is used by wyrecord in order to do action in another thread.\n    '
	def __init__(self, live_controller):
		Thread.__init__(self)
		self.service = None
		self.live_controller = live_controller
		return None

	def appendService(self, service):
		self.service = service

	def run(self):
		while self.service:
			current_zap = self.service
			self.live_controller.real_zap(current_zap)
			if self.service == current_zap:
				self.service = None
				continue
		return None

	def isRequiredService(self, service_id):
		if not config.asynchronous_zap:
			return True
		return service_id == self.service



class ActionSaveRecordingList(Action):
	def __init__(self, scheduler):
		self.scheduler = scheduler

	def execute(self):
		self.scheduler.RealSaveRecordingList()



class ActionRemoveFolder(Action):
	def __init__(self, path):
		self.path = path

	def execute(self):
		log.debug('remove folder start: ' + self.path)
		removeFolder(self.path)
		log.debug('remove folder over: ' + self.path)



class ActionDeleteRecorderInstance(Action):
	def __init__(self, recorder_factory, recorder_instance):
		self.recorder_factory = recorder_factory
		self.recorder_instance = recorder_instance

	def execute(self):
		self.recorder_factory.deleteRecorder(self.recorder_instance)



]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb776decc>}
from threading import Thread
from threading import Lock
from peewee.misc_utils import MetaSingleton
from tools import removeFolder
from logger import log
from config import *
import time
class Action():
	__doc__ = ' an action is an object with an execute method.\n    '
	def __init__(self):
		pass

	def execute(self):
		pass



class AsynchronousAction(Thread):
	__doc__ = ' this thread is used by wyrecord in order to do action in another thread.\n    '
	__metaclass__ = MetaSingleton
	def __init__(self):
		Thread.__init__(self)
		self.action_list = []
		self.quit = False
		self.on_pause = False
		self.protec_list = Lock()

	def appendAction(self, action):
		self.protec_list.acquire()
		self.action_list.append(action)
		self.protec_list.release()

	def pause(self):
		self.on_pause = True

	def resume(self):
		self.on_pause = False

	def exit(self):
		self.quit = True

	def run(self):
		pass



class AsynchronousZap(Thread):
	__doc__ = ' this thread is used by wyrecord in order to do action in another thread.\n    '
	def __init__(self, live_controller):
		Thread.__init__(self)
		self.service = None
		self.live_controller = live_controller
		return None

	def appendService(self, service):
		self.service = service

	def run(self):
		while self.service:
			current_zap = self.service
			self.live_controller.real_zap(current_zap)
			if self.service == current_zap:
				self.service = None
				continue
		return None

	def isRequiredService(self, service_id):
		if not config.asynchronous_zap:
			return True
		return service_id == self.service



class ActionSaveRecordingList(Action):
	def __init__(self, scheduler):
		self.scheduler = scheduler

	def execute(self):
		self.scheduler.RealSaveRecordingList()



class ActionRemoveFolder(Action):
	def __init__(self, path):
		self.path = path

	def execute(self):
		log.debug('remove folder start: ' + self.path)
		removeFolder(self.path)
		log.debug('remove folder over: ' + self.path)



class ActionDeleteRecorderInstance(Action):
	def __init__(self, recorder_factory, recorder_instance):
		self.recorder_factory = recorder_factory
		self.recorder_instance = recorder_instance

	def execute(self):
		self.recorder_factory.deleteRecorder(self.recorder_instance)



