# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 0
n 0(None)[self.wyplayer = wyplayer
self.renderer_manager = renderer_manager
self.default_renderer = renderer_manager.getDefaultRenderer()
self.live_manager = live_manager
self.scheduler = scheduler
self._LiveController__last_zap_live = None
Callbacks().pmt_updated.register(self.selfZap)
Callbacks().pat_updated.register(self.selfZap)
self.async_zap = AsynchronousZap(self)
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7668c6c>}
nname: 0
n 0(None)[return getattr(self.wyplayer, name)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76682ac>}
nname: 224
n 224(None)[return None
]:
	i: 209(), 223()
	o: 

nname: 223
n 223(None)[]:
	i: 203(f)
	o: 224()

nname: 209
n 209(None)[self._LiveController__playAValidLiveIfAny()
]:
	i: 203(t)
	o: 224()

nname: 203
n 203(play_another_live)[]:
	i: 158(JA), 177(), 202()
	o: 209(t), 223(f)

nname: 202
n 202(None)[]:
	i: 80&126(f)
	o: 203()

nname: 177
n 177(None)[current_live = None
raise StopLiveErrors(current_live.id)
]:
	i: 142(f)
	o: 203()

nname: 158
n 158(None)[raise LiveIsRecordingErrors(current_live.id)
]:
	i: 142(t)
	o: 203(JA)

nname: 142
n 142(status == error.WYRECORD_LIVE_IS_RECORDING)[]:
	i: 80&126(t)
	o: 158(t), 177(f)

nname: 80&126
n 80&126(status != error.WYRECORD_SUCCESS and status != error.WYRECORD_LIVE_NOT_STARTED)[stop_live_result = self.live_manager.StopLive(current_live.id)
status = stop_live_result['status']
]:
	i: 46(), 60(), 79(AE)
	o: 142(t), 202(f)

nname: 60
n 60(None)[log.debug('failed to stop playing')
]:
	i: 43(except)
	o: 80&126()

nname: 46
n 46(None)[self.stopPlaying()
]:
	i: 43(try)
	o: 80&126()

nname: 43
n 43(None)[]:
	i: 21(), 42()
	o: 46(try), 60(except)

nname: 42
n 42(None)[]:
	i: 0(t)
	o: 43()

nname: 21
n 21(None)[log.info('ask to stop a live when no live is running')
return False
]:
	i: 0(f)
	o: 43()

nname: 0
n 0(current_live)[current_live = self._LiveController__getCurrentlive(True)
]:
	i: 
	o: 21(f), 42(t)

nname: 80&126
n 80&126(None)[stop_live_result = self.live_manager.StopLive(current_live.id)
status = stop_live_result['status']
if status != error.WYRECORD_SUCCESS and status != error.WYRECORD_LIVE_NOT_STARTED:
	if status == error.WYRECORD_LIVE_IS_RECORDING:
		raise LiveIsRecordingErrors(current_live.id)
	else:
		current_live = None
		raise StopLiveErrors(current_live.id)
if play_another_live:
	self._LiveController__playAValidLiveIfAny()
return None
]:
	i: 46()
	o: 

nname: 46
n 46(None)[try:
	self.stopPlaying()
except:
	log.debug('failed to stop playing')
]:
	i: 0(try)
	o: 80&126()

nname: 0
n 0(None)[current_live = self._LiveController__getCurrentlive(True)
if not current_live:
	log.info('ask to stop a live when no live is running')
	return False
]:
	i: 
	o: 46(try)

nname: 80&126
n 80&126(None)[stop_live_result = self.live_manager.StopLive(current_live.id)
status = stop_live_result['status']
if status != error.WYRECORD_SUCCESS and status != error.WYRECORD_LIVE_NOT_STARTED:
	if status == error.WYRECORD_LIVE_IS_RECORDING:
		raise LiveIsRecordingErrors(current_live.id)
	else:
		current_live = None
		raise StopLiveErrors(current_live.id)
if play_another_live:
	self._LiveController__playAValidLiveIfAny()
return None
]:
	i: 0()
	o: 

nname: 0
n 0(None)[current_live = self._LiveController__getCurrentlive(True)
if not current_live:
	log.info('ask to stop a live when no live is running')
	return False
try:
	self.stopPlaying()
except:
	log.debug('failed to stop playing')
]:
	i: 
	o: 80&126()

nname: 0
n 0(None)[current_live = self._LiveController__getCurrentlive(True)
if not current_live:
	log.info('ask to stop a live when no live is running')
	return False
try:
	self.stopPlaying()
except:
	log.debug('failed to stop playing')
stop_live_result = self.live_manager.StopLive(current_live.id)
status = stop_live_result['status']
if status != error.WYRECORD_SUCCESS and status != error.WYRECORD_LIVE_NOT_STARTED:
	if status == error.WYRECORD_LIVE_IS_RECORDING:
		raise LiveIsRecordingErrors(current_live.id)
	else:
		current_live = None
		raise StopLiveErrors(current_live.id)
if play_another_live:
	self._LiveController__playAValidLiveIfAny()
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb766b94c>}
nname: 50
n 50(None)[return False
]:
	i: 21(), 49()
	o: 

nname: 49
n 49(None)[]:
	i: 0(f)
	o: 50()

nname: 21
n 21(None)[self.zap(live_list[0].serviceid)
return True
]:
	i: 0(t)
	o: 50()

nname: 0
n 0(live_list)[live_list = self.live_manager.GetRunningLiveList()
]:
	i: 
	o: 21(t), 49(f)

nname: 0
n 0(None)[live_list = self.live_manager.GetRunningLiveList()
if live_list:
	self.zap(live_list[0].serviceid)
	return True
return False
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb766844c>}
nname: 314
n 314(None)[]:
	i: 281(), 313()
	o: 

nname: 313
n 313(None)[]:
	i: 271(f)
	o: 314()

nname: 281
n 281(None)[raise SchedulingDoneWithConflictErrors(current_live.id, current_live.serviceid, start_record_result['conflict'])
]:
	i: 271(t)
	o: 314()

nname: 271
n 271(start_record_result['conflict'])[]:
	i: 131(JA), 172(JA), 213(JA), 245(), 270()
	o: 281(t), 313(f)

nname: 270
n 270(None)[]:
	i: 57(f)
	o: 271()

nname: 245
n 245(None)[raise DefaultLiveControllerError(current_live.id, current_live.serviceid)
]:
	i: 197(f)
	o: 271()

nname: 213
n 213(None)[raise SchedulingFailedOnConflictErrors(current_live.id, current_live.serviceid, start_record_result['conflict'])
]:
	i: 197(t)
	o: 271(JA)

nname: 197
n 197(status == error.WYRECORD_SCHEDULE_CONFLICT)[]:
	i: 156(f)
	o: 213(t), 245(f)

nname: 172
n 172(None)[raise NoDeviceForServiceErrors(current_live.id, current_live.serviceid)
]:
	i: 156(t)
	o: 271(JA)

nname: 156
n 156(status == error.WYRECORD_NO_DEVICE_FOR_SERVICE)[]:
	i: 115(f)
	o: 172(t), 197(f)

nname: 131
n 131(None)[raise BadServiceIdErrors(current_live.id, current_live.serviceid)
]:
	i: 115(t)
	o: 271(JA)

nname: 115
n 115(status == error.WYRECORD_BAD_SERVICE_ID)[]:
	i: 57(t)
	o: 131(t), 156(f)

nname: 57
n 57(status != error.WYRECORD_SUCCESS)[start_record_result = self.scheduler.StartLiveRecording(current_live.serviceid, current_live.deviceid, duration, name)
status = start_record_result['status']
]:
	i: 37(), 56()
	o: 115(t), 270(f)

nname: 56
n 56(None)[]:
	i: 0(f)
	o: 57()

nname: 37
n 37(None)[raise LiveIsRecordingErrors(current_live.id)
]:
	i: 0(t)
	o: 57()

nname: 0
n 0(current_live.isRecording())[log.debug('liveController.startRecord')
current_live = self.getCurrentlive()
]:
	i: 
	o: 37(t), 56(f)

nname: 271
n 271(None)[if start_record_result['conflict']:
	raise SchedulingDoneWithConflictErrors(current_live.id, current_live.serviceid, start_record_result['conflict'])
]:
	i: 0(JA)
	o: 

nname: 0
n 0(None)[log.debug('liveController.startRecord')
current_live = self.getCurrentlive()
if current_live.isRecording():
	raise LiveIsRecordingErrors(current_live.id)
start_record_result = self.scheduler.StartLiveRecording(current_live.serviceid, current_live.deviceid, duration, name)
status = start_record_result['status']
if status != error.WYRECORD_SUCCESS:
	if status == error.WYRECORD_BAD_SERVICE_ID:
		raise BadServiceIdErrors(current_live.id, current_live.serviceid)
	else:
		if status == error.WYRECORD_NO_DEVICE_FOR_SERVICE:
			raise NoDeviceForServiceErrors(current_live.id, current_live.serviceid)
		else:
			if status == error.WYRECORD_SCHEDULE_CONFLICT:
				raise SchedulingFailedOnConflictErrors(current_live.id, current_live.serviceid, start_record_result['conflict'])
			else:
				raise DefaultLiveControllerError(current_live.id, current_live.serviceid)
]:
	i: 
	o: 271(JA)

nname: 0
n 0(None)[log.debug('liveController.startRecord')
current_live = self.getCurrentlive()
if current_live.isRecording():
	raise LiveIsRecordingErrors(current_live.id)
start_record_result = self.scheduler.StartLiveRecording(current_live.serviceid, current_live.deviceid, duration, name)
status = start_record_result['status']
if status != error.WYRECORD_SUCCESS:
	if status == error.WYRECORD_BAD_SERVICE_ID:
		raise BadServiceIdErrors(current_live.id, current_live.serviceid)
	else:
		if status == error.WYRECORD_NO_DEVICE_FOR_SERVICE:
			raise NoDeviceForServiceErrors(current_live.id, current_live.serviceid)
		else:
			if status == error.WYRECORD_SCHEDULE_CONFLICT:
				raise SchedulingFailedOnConflictErrors(current_live.id, current_live.serviceid, start_record_result['conflict'])
			else:
				raise DefaultLiveControllerError(current_live.id, current_live.serviceid)
if start_record_result['conflict']:
	raise SchedulingDoneWithConflictErrors(current_live.id, current_live.serviceid, start_record_result['conflict'])
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7667b8c>}
nname: 269
n 269(None)[]:
	i: 159(JA), 211(JA), 243(), 268()
	o: 

nname: 268
n 268(None)[]:
	i: 120(f)
	o: 269()

nname: 243
n 243(None)[raise DefaultLiveControllerError(current_live.id, current_live.serviceid)
]:
	i: 191(f)
	o: 269()

nname: 211
n 211(None)[raise SchedulingDoneWithConflictErrors(current_live.id, current_live.serviceid, set_duration_result['conflict'])
]:
	i: 191(t)
	o: 269(JA)

nname: 191
n 191(set_duration_result['status'] == error.WYRECORD_SCHEDULE_CONFLICT)[]:
	i: 139(f)
	o: 211(t), 243(f)

nname: 159
n 159(None)[raise SchedulingFailedOnConflictErrors(current_live.id, current_live.serviceid, set_duration_result['conflict'])
]:
	i: 139(t)
	o: 269(JA)

nname: 139
n 139(set_duration_result['status'] == error.WYRECORD_DURATION_TOO_BIG)[]:
	i: 120(t)
	o: 159(t), 191(f)

nname: 120
n 120(set_duration_result['status'] != error.WYRECORD_SUCCESS)[]:
	i: 92(), 119()
	o: 139(t), 268(f)

nname: 119
n 119(None)[]:
	i: 46(f)
	o: 120()

nname: 92
n 92(None)[raise SchedulingFailedOnDiskSpaceErrors(set_duration_result['needed_space'], set_duration_result['available_space'])
]:
	i: 46(t)
	o: 120()

nname: 46
n 46(set_duration_result['status'] == error.WYRECORD_NOT_ENOUGH_DISK_SPACE)[set_duration_result = self.scheduler.SetRecordingDuration(current_live.current_recordingid, duration, False)
]:
	i: 24(), 45()
	o: 92(t), 119(f)

nname: 45
n 45(None)[]:
	i: 0(f)
	o: 46()

nname: 24
n 24(None)[log.error('live controller seDuration with 0')
]:
	i: 0(t)
	o: 46()

nname: 0
n 0(duration == 0)[current_live = self.getCurrentlive()
]:
	i: 
	o: 24(t), 45(f)

nname: 120
n 120(None)[if set_duration_result['status'] != error.WYRECORD_SUCCESS:
	if set_duration_result['status'] == error.WYRECORD_DURATION_TOO_BIG:
		raise SchedulingFailedOnConflictErrors(current_live.id, current_live.serviceid, set_duration_result['conflict'])
	else:
		if set_duration_result['status'] == error.WYRECORD_SCHEDULE_CONFLICT:
			raise SchedulingDoneWithConflictErrors(current_live.id, current_live.serviceid, set_duration_result['conflict'])
		else:
			raise DefaultLiveControllerError(current_live.id, current_live.serviceid)
]:
	i: 0()
	o: 

nname: 0
n 0(None)[current_live = self.getCurrentlive()
if duration == 0:
	log.error('live controller seDuration with 0')
set_duration_result = self.scheduler.SetRecordingDuration(current_live.current_recordingid, duration, False)
if set_duration_result['status'] == error.WYRECORD_NOT_ENOUGH_DISK_SPACE:
	raise SchedulingFailedOnDiskSpaceErrors(set_duration_result['needed_space'], set_duration_result['available_space'])
]:
	i: 
	o: 120()

nname: 0
n 0(None)[current_live = self.getCurrentlive()
if duration == 0:
	log.error('live controller seDuration with 0')
set_duration_result = self.scheduler.SetRecordingDuration(current_live.current_recordingid, duration, False)
if set_duration_result['status'] == error.WYRECORD_NOT_ENOUGH_DISK_SPACE:
	raise SchedulingFailedOnDiskSpaceErrors(set_duration_result['needed_space'], set_duration_result['available_space'])
if set_duration_result['status'] != error.WYRECORD_SUCCESS:
	if set_duration_result['status'] == error.WYRECORD_DURATION_TOO_BIG:
		raise SchedulingFailedOnConflictErrors(current_live.id, current_live.serviceid, set_duration_result['conflict'])
	else:
		if set_duration_result['status'] == error.WYRECORD_SCHEDULE_CONFLICT:
			raise SchedulingDoneWithConflictErrors(current_live.id, current_live.serviceid, set_duration_result['conflict'])
		else:
			raise DefaultLiveControllerError(current_live.id, current_live.serviceid)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76674ec>}
nname: 111
n 111(None)[return True
]:
	i: 85(), 110()
	o: 

nname: 110
n 110(None)[]:
	i: 55(t)
	o: 111()

nname: 85
n 85(None)[raise DefaultLiveControllerError(current_live.id, current_live.serviceid)
]:
	i: 55(f)
	o: 111()

nname: 55
n 55(ret)[ret = self.scheduler.StopRecording(current_live.current_recordingid, True)
]:
	i: 46(), 54()
	o: 85(f), 110(t)

nname: 54
n 54(None)[]:
	i: 0&35(f)
	o: 55()

nname: 46
n 46(None)[return False
]:
	i: 0&35(t)
	o: 55()

nname: 0&35
n 0&35(not current_live or not current_live.current_recordingid)[log.debug('liveController.stopRecord')
current_live = self.getCurrentlive(True)
]:
	i: 
	o: 46(t), 54(f)

nname: 0&35
n 0&35(None)[log.debug('liveController.stopRecord')
current_live = self.getCurrentlive(True)
if not current_live or not current_live.current_recordingid:
	return False
ret = self.scheduler.StopRecording(current_live.current_recordingid, True)
if not ret:
	raise DefaultLiveControllerError(current_live.id, current_live.serviceid)
return True
]:
	i: 
	o: 

self.nodes: {'0&35': <unpyclib.structure.node instance at 0xb766842c>}
nname: 0
n 0(None)[self.wyplayer.seek(offset)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76681cc>}
nname: 0
n 0(None)[self._LiveController__set_speed(0)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb766812c>}
nname: 0
n 0(None)[self._LiveController__set_speed(1)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb766814c>}
nname: 0
n 0(None)[return self.wyplayer.speed
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb766814c>}
nname: 55
n 55(None)[]:
	i: 24(), 41()
	o: 

nname: 41
n 41(None)[self.default_renderer.resetPositionSaving()
]:
	i: 0(f)
	o: 55()

nname: 24
n 24(None)[self.default_renderer.savePausePosition()
]:
	i: 0(t)
	o: 55()

nname: 0
n 0(speed == 0)[self.wyplayer.speed = speed
]:
	i: 
	o: 24(t), 41(f)

nname: 0
n 0(None)[self.wyplayer.speed = speed
if speed == 0:
	self.default_renderer.savePausePosition()
else:
	self.default_renderer.resetPositionSaving()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76683cc>}
nname: 0
n 0(None)[current_live = self.getCurrentlive()
return current_live.external_dvb_manager.EPGFromProgramId(program_id)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb766832c>}
nname: 0
n 0(None)[current_live = self.getCurrentlive()
return current_live.external_dvb_manager.GetDeviceCurrentUTCTime(current_live.deviceid)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb766880c>}
nname: 123
n 123(None)[return current_live
]:
	i: 109(), 122()
	o: 

nname: 122
n 122(None)[]:
	i: 103(t)
	o: 123()

nname: 109
n 109(None)[raise NoLiveStartedErrors()
]:
	i: 103(f)
	o: 123()

nname: 103
n 103(current_live)[]:
	i: 94(), 102()
	o: 109(f), 122(t)

nname: 102
n 102(None)[]:
	i: 88(f)
	o: 103()

nname: 94
n 94(None)[return current_live
]:
	i: 88(t)
	o: 103()

nname: 88
n 88(no_exception)[]:
	i: 69(JA), 84(), 87()
	o: 94(t), 102(f)

nname: 87
n 87(None)[]:
	i: 0(t)
	o: 88()

nname: 84
n 84(None)[]:
	i: 56(JA), 83()
	o: 88()

nname: 83
n 83(None)[]:
	i: 18(f)
	o: 84()

nname: 69
n 69(None)[current_live = live_list[0]
]:
	i: 40(f)
	o: 88(JA)

nname: 56
n 56(None)[current_live = self._LiveController__last_zap_live
]:
	i: 40(t)
	o: 84(JA)

nname: 40
n 40(self._LiveController__last_zap_live in live_list)[]:
	i: 18(t)
	o: 56(t), 69(f)

nname: 18
n 18(live_list)[live_list = self.live_manager.GetRunningLiveList()
]:
	i: 0(f)
	o: 40(t), 83(f)

nname: 0
n 0(current_live)[current_live = self.default_renderer.live
]:
	i: 
	o: 18(f), 87(t)

nname: 123
n 123(None)[return current_live
]:
	i: 88()
	o: 

nname: 88
n 88(None)[if no_exception:
	return current_live
if not current_live:
	raise NoLiveStartedErrors()
]:
	i: 69(JA), 56(JA), 18(f), 0(t)
	o: 123()

nname: 69
n 69(None)[current_live = live_list[0]
]:
	i: 40(f)
	o: 88(JA)

nname: 56
n 56(None)[current_live = self._LiveController__last_zap_live
]:
	i: 40(t)
	o: 88(JA)

nname: 40
n 40(self._LiveController__last_zap_live in live_list)[]:
	i: 18(t)
	o: 56(t), 69(f)

nname: 18
n 18(live_list)[live_list = self.live_manager.GetRunningLiveList()
]:
	i: 0(f)
	o: 40(t), 88(f)

nname: 0
n 0(current_live)[current_live = self.default_renderer.live
]:
	i: 
	o: 18(f), 88(t)

nname: 123
n 123(None)[return current_live
]:
	i: 0()
	o: 

nname: 0
n 0(None)[current_live = self.default_renderer.live
if not current_live:
	live_list = self.live_manager.GetRunningLiveList()
	if live_list:
		if self._LiveController__last_zap_live in live_list:
			current_live = self._LiveController__last_zap_live
		else:
			current_live = live_list[0]
if no_exception:
	return current_live
if not current_live:
	raise NoLiveStartedErrors()
]:
	i: 
	o: 123()

nname: 0
n 0(None)[current_live = self.default_renderer.live
if not current_live:
	live_list = self.live_manager.GetRunningLiveList()
	if live_list:
		if self._LiveController__last_zap_live in live_list:
			current_live = self._LiveController__last_zap_live
		else:
			current_live = live_list[0]
if no_exception:
	return current_live
if not current_live:
	raise NoLiveStartedErrors()
return current_live
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb766870c>}
nname: 0
n 0(None)[self.default_renderer.stop()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7668fec>}
nname: 0
n 0(None)[return self.getCurrentlive(True)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb766818c>}
nname: 0
n 0(None)[]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb766818c>}
nname: 0
n 0(None)[return self.default_renderer.getTimeInfo().current_time
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76682cc>}
nname: 0
n 0(None)[return self.default_renderer.getTimeInfo().min_available_time
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb766830c>}
nname: 0
n 0(None)[return self.default_renderer.getTimeInfo().max_available_time
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76680cc>}
nname: 6
n 6(None)[__doc__ = '\n    entry point of wyrecord for live, timeshift and instant record feature.\n    it wraps wyplayer to avoid client to use wyplayer on live, timeshift and instant record\n\n    each method raise LiveControllerError exception on error (see docstring)\n    '
def __init__(self, wyplayer, live_manager, scheduler, renderer_manager):
	self.wyplayer = wyplayer
	self.renderer_manager = renderer_manager
	self.default_renderer = renderer_manager.getDefaultRenderer()
	self.live_manager = live_manager
	self.scheduler = scheduler
	self._LiveController__last_zap_live = None
	Callbacks().pmt_updated.register(self.selfZap)
	Callbacks().pat_updated.register(self.selfZap)
	self.async_zap = AsynchronousZap(self)
	return None

def __getattr__(self, name):
	return getattr(self.wyplayer, name)

getRunningLiveList = GlobalLock()()
zap = Chrono(['wyrecord'])()
real_zap = GlobalLock()()
canZap = GlobalLock()()
stopAllTimeshift = GlobalLock()()
stopLive = GlobalLock()()
def _LiveController__stopLive(self, play_another_live=True):
	current_live = self._LiveController__getCurrentlive(True)
	if not current_live:
		log.info('ask to stop a live when no live is running')
		return False
	try:
		self.stopPlaying()
	except:
		log.debug('failed to stop playing')
	stop_live_result = self.live_manager.StopLive(current_live.id)
	status = stop_live_result['status']
	if status != error.WYRECORD_SUCCESS and status != error.WYRECORD_LIVE_NOT_STARTED:
		if status == error.WYRECORD_LIVE_IS_RECORDING:
			raise LiveIsRecordingErrors(current_live.id)
		else:
			current_live = None
			raise StopLiveErrors(current_live.id)
	if play_another_live:
		self._LiveController__playAValidLiveIfAny()
	return None

def _LiveController__playAValidLiveIfAny(self):
	live_list = self.live_manager.GetRunningLiveList()
	if live_list:
		self.zap(live_list[0].serviceid)
		return True
	return False

def startRecord(self, duration=0, name=''):
	log.debug('liveController.startRecord')
	current_live = self.getCurrentlive()
	if current_live.isRecording():
		raise LiveIsRecordingErrors(current_live.id)
	start_record_result = self.scheduler.StartLiveRecording(current_live.serviceid, current_live.deviceid, duration, name)
	status = start_record_result['status']
	if status != error.WYRECORD_SUCCESS:
		if status == error.WYRECORD_BAD_SERVICE_ID:
			raise BadServiceIdErrors(current_live.id, current_live.serviceid)
		else:
			if status == error.WYRECORD_NO_DEVICE_FOR_SERVICE:
				raise NoDeviceForServiceErrors(current_live.id, current_live.serviceid)
			else:
				if status == error.WYRECORD_SCHEDULE_CONFLICT:
					raise SchedulingFailedOnConflictErrors(current_live.id, current_live.serviceid, start_record_result['conflict'])
				else:
					raise DefaultLiveControllerError(current_live.id, current_live.serviceid)
	if start_record_result['conflict']:
		raise SchedulingDoneWithConflictErrors(current_live.id, current_live.serviceid, start_record_result['conflict'])

def setDuration(self, duration):
	current_live = self.getCurrentlive()
	if duration == 0:
		log.error('live controller seDuration with 0')
	set_duration_result = self.scheduler.SetRecordingDuration(current_live.current_recordingid, duration, False)
	if set_duration_result['status'] == error.WYRECORD_NOT_ENOUGH_DISK_SPACE:
		raise SchedulingFailedOnDiskSpaceErrors(set_duration_result['needed_space'], set_duration_result['available_space'])
	if set_duration_result['status'] != error.WYRECORD_SUCCESS:
		if set_duration_result['status'] == error.WYRECORD_DURATION_TOO_BIG:
			raise SchedulingFailedOnConflictErrors(current_live.id, current_live.serviceid, set_duration_result['conflict'])
		else:
			if set_duration_result['status'] == error.WYRECORD_SCHEDULE_CONFLICT:
				raise SchedulingDoneWithConflictErrors(current_live.id, current_live.serviceid, set_duration_result['conflict'])
			else:
				raise DefaultLiveControllerError(current_live.id, current_live.serviceid)

def stopRecord(self):
	log.debug('liveController.stopRecord')
	current_live = self.getCurrentlive(True)
	if not current_live or not current_live.current_recordingid:
		return False
	ret = self.scheduler.StopRecording(current_live.current_recordingid, True)
	if not ret:
		raise DefaultLiveControllerError(current_live.id, current_live.serviceid)
	return True

def seek(self, offset):
	self.wyplayer.seek(offset)

def pause(self):
	self._LiveController__set_speed(0)

def resume(self):
	self._LiveController__set_speed(1)

_LiveController__doc_speed = 'floating point number indicating the current playback speed.\n\n           playback state is converted from speed as follows:\n\n            - speed < -1.0: fast backward playback\n            - speed = -1.0: normal speed backward playback\n               - -1.0 < speed < 0.0: slow backward playback\n            - speed = 0.0: pause\n            - 0.0 < speed < 1.0: slow forward playback\n            - speed = 1.0: normal speed forward playback\n            - 1.0 < speed: fast forward playback\n\n           note: in the current wyplayer implementation, backward playback\n           supports only a single speed which is dependent on the specific\n           media stream (depends on spacing between key video frames).\n        '
def _LiveController__get_speed(self):
	return self.wyplayer.speed

def _LiveController__set_speed(self, speed):
	self.wyplayer.speed = speed
	if speed == 0:
		self.default_renderer.savePausePosition()
	else:
		self.default_renderer.resetPositionSaving()

speed = property(fget=_LiveController__get_speed, fset=_LiveController__set_speed, doc=_LiveController__doc_speed)
def getEPGFromProgramId(self, program_id):
	current_live = self.getCurrentlive()
	return current_live.external_dvb_manager.EPGFromProgramId(program_id)

def getLiveCurrentUTCTime(self):
	current_live = self.getCurrentlive()
	return current_live.external_dvb_manager.GetDeviceCurrentUTCTime(current_live.deviceid)

getCurrentlive = GlobalLock()()
def _LiveController__getCurrentlive(self, no_exception=False):
	current_live = self.default_renderer.live
	if not current_live:
		live_list = self.live_manager.GetRunningLiveList()
		if live_list:
			if self._LiveController__last_zap_live in live_list:
				current_live = self._LiveController__last_zap_live
			else:
				current_live = live_list[0]
	if no_exception:
		return current_live
	if not current_live:
		raise NoLiveStartedErrors()
	return current_live

def stopPlaying(self):
	self.default_renderer.stop()

playCurrentLive = GlobalLock()()
selfZap = GlobalLock()()
close = GlobalLock()()
_LiveController__doc_current_live = ' here for backward compatibility\n        '
def _LiveController__get_current_live(self):
	return self.getCurrentlive(True)

def _LiveController__set_current_live(self, live):
	pass

current_live = property(fget=_LiveController__get_current_live, fset=_LiveController__set_current_live, doc=_LiveController__doc_current_live)
def getPlayingTimeshiftTime(self):
	return self.default_renderer.getTimeInfo().current_time

def getMinimumTimeshiftTime(self):
	return self.default_renderer.getTimeInfo().min_available_time

def getMaximumTimeshiftTime(self):
	return self.default_renderer.getTimeInfo().max_available_time

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb7655b4c>}
nname: 0
n 0(None)[import time
import error
import live
from config import *
from exceptions import *
from peewee.analyse import Chrono
from peewee.analyse import timestep
from logger import log
from asynchronousaction import AsynchronousAction
from asynchronousaction import AsynchronousZap
from callbacks import Callbacks
from globallock import GlobalLock
class LiveController(object):
	__doc__ = '\n    entry point of wyrecord for live, timeshift and instant record feature.\n    it wraps wyplayer to avoid client to use wyplayer on live, timeshift and instant record\n\n    each method raise LiveControllerError exception on error (see docstring)\n    '
	def __init__(self, wyplayer, live_manager, scheduler, renderer_manager):
		self.wyplayer = wyplayer
		self.renderer_manager = renderer_manager
		self.default_renderer = renderer_manager.getDefaultRenderer()
		self.live_manager = live_manager
		self.scheduler = scheduler
		self._LiveController__last_zap_live = None
		Callbacks().pmt_updated.register(self.selfZap)
		Callbacks().pat_updated.register(self.selfZap)
		self.async_zap = AsynchronousZap(self)
		return None

	def __getattr__(self, name):
		return getattr(self.wyplayer, name)

	getRunningLiveList = GlobalLock()()
	zap = Chrono(['wyrecord'])()
	real_zap = GlobalLock()()
	canZap = GlobalLock()()
	stopAllTimeshift = GlobalLock()()
	stopLive = GlobalLock()()
	def _LiveController__stopLive(self, play_another_live=True):
		current_live = self._LiveController__getCurrentlive(True)
		if not current_live:
			log.info('ask to stop a live when no live is running')
			return False
		try:
			self.stopPlaying()
		except:
			log.debug('failed to stop playing')
		stop_live_result = self.live_manager.StopLive(current_live.id)
		status = stop_live_result['status']
		if status != error.WYRECORD_SUCCESS and status != error.WYRECORD_LIVE_NOT_STARTED:
			if status == error.WYRECORD_LIVE_IS_RECORDING:
				raise LiveIsRecordingErrors(current_live.id)
			else:
				current_live = None
				raise StopLiveErrors(current_live.id)
		if play_another_live:
			self._LiveController__playAValidLiveIfAny()
		return None

	def _LiveController__playAValidLiveIfAny(self):
		live_list = self.live_manager.GetRunningLiveList()
		if live_list:
			self.zap(live_list[0].serviceid)
			return True
		return False

	def startRecord(self, duration=0, name=''):
		log.debug('liveController.startRecord')
		current_live = self.getCurrentlive()
		if current_live.isRecording():
			raise LiveIsRecordingErrors(current_live.id)
		start_record_result = self.scheduler.StartLiveRecording(current_live.serviceid, current_live.deviceid, duration, name)
		status = start_record_result['status']
		if status != error.WYRECORD_SUCCESS:
			if status == error.WYRECORD_BAD_SERVICE_ID:
				raise BadServiceIdErrors(current_live.id, current_live.serviceid)
			else:
				if status == error.WYRECORD_NO_DEVICE_FOR_SERVICE:
					raise NoDeviceForServiceErrors(current_live.id, current_live.serviceid)
				else:
					if status == error.WYRECORD_SCHEDULE_CONFLICT:
						raise SchedulingFailedOnConflictErrors(current_live.id, current_live.serviceid, start_record_result['conflict'])
					else:
						raise DefaultLiveControllerError(current_live.id, current_live.serviceid)
		if start_record_result['conflict']:
			raise SchedulingDoneWithConflictErrors(current_live.id, current_live.serviceid, start_record_result['conflict'])

	def setDuration(self, duration):
		current_live = self.getCurrentlive()
		if duration == 0:
			log.error('live controller seDuration with 0')
		set_duration_result = self.scheduler.SetRecordingDuration(current_live.current_recordingid, duration, False)
		if set_duration_result['status'] == error.WYRECORD_NOT_ENOUGH_DISK_SPACE:
			raise SchedulingFailedOnDiskSpaceErrors(set_duration_result['needed_space'], set_duration_result['available_space'])
		if set_duration_result['status'] != error.WYRECORD_SUCCESS:
			if set_duration_result['status'] == error.WYRECORD_DURATION_TOO_BIG:
				raise SchedulingFailedOnConflictErrors(current_live.id, current_live.serviceid, set_duration_result['conflict'])
			else:
				if set_duration_result['status'] == error.WYRECORD_SCHEDULE_CONFLICT:
					raise SchedulingDoneWithConflictErrors(current_live.id, current_live.serviceid, set_duration_result['conflict'])
				else:
					raise DefaultLiveControllerError(current_live.id, current_live.serviceid)

	def stopRecord(self):
		log.debug('liveController.stopRecord')
		current_live = self.getCurrentlive(True)
		if not current_live or not current_live.current_recordingid:
			return False
		ret = self.scheduler.StopRecording(current_live.current_recordingid, True)
		if not ret:
			raise DefaultLiveControllerError(current_live.id, current_live.serviceid)
		return True

	def seek(self, offset):
		self.wyplayer.seek(offset)

	def pause(self):
		self._LiveController__set_speed(0)

	def resume(self):
		self._LiveController__set_speed(1)

	_LiveController__doc_speed = 'floating point number indicating the current playback speed.\n\n           playback state is converted from speed as follows:\n\n            - speed < -1.0: fast backward playback\n            - speed = -1.0: normal speed backward playback\n               - -1.0 < speed < 0.0: slow backward playback\n            - speed = 0.0: pause\n            - 0.0 < speed < 1.0: slow forward playback\n            - speed = 1.0: normal speed forward playback\n            - 1.0 < speed: fast forward playback\n\n           note: in the current wyplayer implementation, backward playback\n           supports only a single speed which is dependent on the specific\n           media stream (depends on spacing between key video frames).\n        '
	def _LiveController__get_speed(self):
		return self.wyplayer.speed

	def _LiveController__set_speed(self, speed):
		self.wyplayer.speed = speed
		if speed == 0:
			self.default_renderer.savePausePosition()
		else:
			self.default_renderer.resetPositionSaving()

	speed = property(fget=_LiveController__get_speed, fset=_LiveController__set_speed, doc=_LiveController__doc_speed)
	def getEPGFromProgramId(self, program_id):
		current_live = self.getCurrentlive()
		return current_live.external_dvb_manager.EPGFromProgramId(program_id)

	def getLiveCurrentUTCTime(self):
		current_live = self.getCurrentlive()
		return current_live.external_dvb_manager.GetDeviceCurrentUTCTime(current_live.deviceid)

	getCurrentlive = GlobalLock()()
	def _LiveController__getCurrentlive(self, no_exception=False):
		current_live = self.default_renderer.live
		if not current_live:
			live_list = self.live_manager.GetRunningLiveList()
			if live_list:
				if self._LiveController__last_zap_live in live_list:
					current_live = self._LiveController__last_zap_live
				else:
					current_live = live_list[0]
		if no_exception:
			return current_live
		if not current_live:
			raise NoLiveStartedErrors()
		return current_live

	def stopPlaying(self):
		self.default_renderer.stop()

	playCurrentLive = GlobalLock()()
	selfZap = GlobalLock()()
	close = GlobalLock()()
	_LiveController__doc_current_live = ' here for backward compatibility\n        '
	def _LiveController__get_current_live(self):
		return self.getCurrentlive(True)

	def _LiveController__set_current_live(self, live):
		pass

	current_live = property(fget=_LiveController__get_current_live, fset=_LiveController__set_current_live, doc=_LiveController__doc_current_live)
	def getPlayingTimeshiftTime(self):
		return self.default_renderer.getTimeInfo().current_time

	def getMinimumTimeshiftTime(self):
		return self.default_renderer.getTimeInfo().min_available_time

	def getMaximumTimeshiftTime(self):
		return self.default_renderer.getTimeInfo().max_available_time



]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb764af0c>}
import time
import error
import live
from config import *
from exceptions import *
from peewee.analyse import Chrono
from peewee.analyse import timestep
from logger import log
from asynchronousaction import AsynchronousAction
from asynchronousaction import AsynchronousZap
from callbacks import Callbacks
from globallock import GlobalLock
class LiveController(object):
	__doc__ = '\n    entry point of wyrecord for live, timeshift and instant record feature.\n    it wraps wyplayer to avoid client to use wyplayer on live, timeshift and instant record\n\n    each method raise LiveControllerError exception on error (see docstring)\n    '
	def __init__(self, wyplayer, live_manager, scheduler, renderer_manager):
		self.wyplayer = wyplayer
		self.renderer_manager = renderer_manager
		self.default_renderer = renderer_manager.getDefaultRenderer()
		self.live_manager = live_manager
		self.scheduler = scheduler
		self._LiveController__last_zap_live = None
		Callbacks().pmt_updated.register(self.selfZap)
		Callbacks().pat_updated.register(self.selfZap)
		self.async_zap = AsynchronousZap(self)
		return None

	def __getattr__(self, name):
		return getattr(self.wyplayer, name)

	getRunningLiveList = GlobalLock()()
	zap = Chrono(['wyrecord'])()
	real_zap = GlobalLock()()
	canZap = GlobalLock()()
	stopAllTimeshift = GlobalLock()()
	stopLive = GlobalLock()()
	def _LiveController__stopLive(self, play_another_live=True):
		current_live = self._LiveController__getCurrentlive(True)
		if not current_live:
			log.info('ask to stop a live when no live is running')
			return False
		try:
			self.stopPlaying()
		except:
			log.debug('failed to stop playing')
		stop_live_result = self.live_manager.StopLive(current_live.id)
		status = stop_live_result['status']
		if status != error.WYRECORD_SUCCESS and status != error.WYRECORD_LIVE_NOT_STARTED:
			if status == error.WYRECORD_LIVE_IS_RECORDING:
				raise LiveIsRecordingErrors(current_live.id)
			else:
				current_live = None
				raise StopLiveErrors(current_live.id)
		if play_another_live:
			self._LiveController__playAValidLiveIfAny()
		return None

	def _LiveController__playAValidLiveIfAny(self):
		live_list = self.live_manager.GetRunningLiveList()
		if live_list:
			self.zap(live_list[0].serviceid)
			return True
		return False

	def startRecord(self, duration=0, name=''):
		log.debug('liveController.startRecord')
		current_live = self.getCurrentlive()
		if current_live.isRecording():
			raise LiveIsRecordingErrors(current_live.id)
		start_record_result = self.scheduler.StartLiveRecording(current_live.serviceid, current_live.deviceid, duration, name)
		status = start_record_result['status']
		if status != error.WYRECORD_SUCCESS:
			if status == error.WYRECORD_BAD_SERVICE_ID:
				raise BadServiceIdErrors(current_live.id, current_live.serviceid)
			else:
				if status == error.WYRECORD_NO_DEVICE_FOR_SERVICE:
					raise NoDeviceForServiceErrors(current_live.id, current_live.serviceid)
				else:
					if status == error.WYRECORD_SCHEDULE_CONFLICT:
						raise SchedulingFailedOnConflictErrors(current_live.id, current_live.serviceid, start_record_result['conflict'])
					else:
						raise DefaultLiveControllerError(current_live.id, current_live.serviceid)
		if start_record_result['conflict']:
			raise SchedulingDoneWithConflictErrors(current_live.id, current_live.serviceid, start_record_result['conflict'])

	def setDuration(self, duration):
		current_live = self.getCurrentlive()
		if duration == 0:
			log.error('live controller seDuration with 0')
		set_duration_result = self.scheduler.SetRecordingDuration(current_live.current_recordingid, duration, False)
		if set_duration_result['status'] == error.WYRECORD_NOT_ENOUGH_DISK_SPACE:
			raise SchedulingFailedOnDiskSpaceErrors(set_duration_result['needed_space'], set_duration_result['available_space'])
		if set_duration_result['status'] != error.WYRECORD_SUCCESS:
			if set_duration_result['status'] == error.WYRECORD_DURATION_TOO_BIG:
				raise SchedulingFailedOnConflictErrors(current_live.id, current_live.serviceid, set_duration_result['conflict'])
			else:
				if set_duration_result['status'] == error.WYRECORD_SCHEDULE_CONFLICT:
					raise SchedulingDoneWithConflictErrors(current_live.id, current_live.serviceid, set_duration_result['conflict'])
				else:
					raise DefaultLiveControllerError(current_live.id, current_live.serviceid)

	def stopRecord(self):
		log.debug('liveController.stopRecord')
		current_live = self.getCurrentlive(True)
		if not current_live or not current_live.current_recordingid:
			return False
		ret = self.scheduler.StopRecording(current_live.current_recordingid, True)
		if not ret:
			raise DefaultLiveControllerError(current_live.id, current_live.serviceid)
		return True

	def seek(self, offset):
		self.wyplayer.seek(offset)

	def pause(self):
		self._LiveController__set_speed(0)

	def resume(self):
		self._LiveController__set_speed(1)

	_LiveController__doc_speed = 'floating point number indicating the current playback speed.\n\n           playback state is converted from speed as follows:\n\n            - speed < -1.0: fast backward playback\n            - speed = -1.0: normal speed backward playback\n               - -1.0 < speed < 0.0: slow backward playback\n            - speed = 0.0: pause\n            - 0.0 < speed < 1.0: slow forward playback\n            - speed = 1.0: normal speed forward playback\n            - 1.0 < speed: fast forward playback\n\n           note: in the current wyplayer implementation, backward playback\n           supports only a single speed which is dependent on the specific\n           media stream (depends on spacing between key video frames).\n        '
	def _LiveController__get_speed(self):
		return self.wyplayer.speed

	def _LiveController__set_speed(self, speed):
		self.wyplayer.speed = speed
		if speed == 0:
			self.default_renderer.savePausePosition()
		else:
			self.default_renderer.resetPositionSaving()

	speed = property(fget=_LiveController__get_speed, fset=_LiveController__set_speed, doc=_LiveController__doc_speed)
	def getEPGFromProgramId(self, program_id):
		current_live = self.getCurrentlive()
		return current_live.external_dvb_manager.EPGFromProgramId(program_id)

	def getLiveCurrentUTCTime(self):
		current_live = self.getCurrentlive()
		return current_live.external_dvb_manager.GetDeviceCurrentUTCTime(current_live.deviceid)

	getCurrentlive = GlobalLock()()
	def _LiveController__getCurrentlive(self, no_exception=False):
		current_live = self.default_renderer.live
		if not current_live:
			live_list = self.live_manager.GetRunningLiveList()
			if live_list:
				if self._LiveController__last_zap_live in live_list:
					current_live = self._LiveController__last_zap_live
				else:
					current_live = live_list[0]
		if no_exception:
			return current_live
		if not current_live:
			raise NoLiveStartedErrors()
		return current_live

	def stopPlaying(self):
		self.default_renderer.stop()

	playCurrentLive = GlobalLock()()
	selfZap = GlobalLock()()
	close = GlobalLock()()
	_LiveController__doc_current_live = ' here for backward compatibility\n        '
	def _LiveController__get_current_live(self):
		return self.getCurrentlive(True)

	def _LiveController__set_current_live(self, live):
		pass

	current_live = property(fget=_LiveController__get_current_live, fset=_LiveController__set_current_live, doc=_LiveController__doc_current_live)
	def getPlayingTimeshiftTime(self):
		return self.default_renderer.getTimeInfo().current_time

	def getMinimumTimeshiftTime(self):
		return self.default_renderer.getTimeInfo().min_available_time

	def getMaximumTimeshiftTime(self):
		return self.default_renderer.getTimeInfo().max_available_time



