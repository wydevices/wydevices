# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 39
n 39(None)[adjust.new_rec.updateStartTime(adjust.new_rec_start)
]:
	i: 0(AL), 38()
	o: 

nname: 38
n 38(None)[]:
	i: 3(AF), 16()
	o: 39()

nname: 16
n 16(None)[for rec in adjust.getRecToModify():
rec.updateStopTime(adjust.new_rec_start)
]:
	i: 3(for)
	o: 38()

nname: 3
n 3(None)[]:
	i: 0(loop)
	o: 16(for), 38(AF)

nname: 0
n 0(None)[]:
	i: 
	o: 3(loop), 39(AL)

nname: 39
n 39(None)[adjust.new_rec.updateStartTime(adjust.new_rec_start)
]:
	i: 16()
	o: 

nname: 16
n 16(None)[for rec in adjust.getRecToModify():
	rec.updateStopTime(adjust.new_rec_start)
]:
	i: 0(for)
	o: 39()

nname: 0
n 0(None)[]:
	i: 
	o: 16(for)

nname: 39
n 39(None)[adjust.new_rec.updateStartTime(adjust.new_rec_start)
]:
	i: 0()
	o: 

nname: 0
n 0(None)[for rec in adjust.getRecToModify():
	rec.updateStopTime(adjust.new_rec_start)
]:
	i: 
	o: 39()

nname: 0
n 0(None)[for rec in adjust.getRecToModify():
	rec.updateStopTime(adjust.new_rec_start)
adjust.new_rec.updateStartTime(adjust.new_rec_start)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb760f82c>}
nname: 0
n 0(None)[self.new_rec = new_rec
self.current_rec_list = current_rec_list
self.result = []
self.new_rec_start = self._AdjustTimeForRec__check()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb760fd8c>}
nname: 34
n 34(None)[return new_rec_start < rec.GetScheduledStopTime()
]:
	i: 0(t), 18()
	o: 

nname: 18
n 18(None)[]:
	i: 0(f)
	o: 34()

nname: 0
n 0(new_rec_start < rec.GetScheduledStopTime())[]:
	i: 
	o: 18(f), 34(t)

nname: 0
n 0(None)[if not new_rec_start < rec.GetScheduledStopTime():
	pass
return new_rec_start < rec.GetScheduledStopTime()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7623d0c>}
nname: 34
n 34(None)[return new_rec_start < rec.GetScheduledStopTime()
]:
	i: 0(t), 18()
	o: 

nname: 18
n 18(None)[]:
	i: 0(f)
	o: 34()

nname: 0
n 0(new_rec_start < rec.GetScheduledStopTime())[]:
	i: 
	o: 18(f), 34(t)

nname: 0
n 0(None)[if not new_rec_start < rec.GetScheduledStopTime():
	pass
return new_rec_start < rec.GetScheduledStopTime()
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7623d8c>}
nname: 367
n 367(None)[filter((lambda rec: new_rec_start < rec.GetScheduledStopTime():
	pass
return new_rec_start < rec.GetScheduledStopTime()), self.result)
return new_rec_start
]:
	i: 0(AL), 366()
	o: 

nname: 366
n 366(None)[]:
	i: 18(AF), 337()
	o: 367()

nname: 337
n 337(None)[self.new_rec.status = RECORDING_STATUS_ABORTED
log.critical('SHOULD NOT HAPPEN => BUG => CHECK ALGO')
]:
	i: 289(f), 308()
	o: 366()

nname: 308
n 308(None)[log.debug('trying to start an instant record during padding of a scheduled')
self.new_rec.status = RECORDING_STATUS_ABORTED
continue
]:
	i: 289(t)
	o: 337()

nname: 289
n 289(self.new_rec.type == RECORDING_TYPE_NOT_SCHEDULED)[]:
	i: 253(f), 269()
	o: 308(t), 337(f)

nname: 269
n 269(None)[self.result.append(rec)
continue
]:
	i: 253(t)
	o: 289()

nname: 253
n 253(rec.type == RECORDING_TYPE_NOT_SCHEDULED)[]:
	i: 111&120(f), 234()
	o: 269(t), 289(f)

nname: 234
n 234(None)[self.result.append(rec)
continue
]:
	i: 223(), 233()
	o: 253()

nname: 233
n 233(None)[]:
	i: 211(f)
	o: 234()

nname: 223
n 223(None)[new_rec_start = half_time
]:
	i: 211(t)
	o: 234()

nname: 211
n 211(half_time > new_rec_start)[]:
	i: 138(), 178()
	o: 223(t), 233(f)

nname: 178
n 178(None)[half_time = int(self.new_rec.start_padding / 2) + self.new_rec.start_time
]:
	i: 128(f)
	o: 211()

nname: 138
n 138(None)[half_time = int((self.new_rec.start_time - rec.stop_time) / 2) + rec.stop_time
]:
	i: 128(t)
	o: 211()

nname: 128
n 128(rec.stop_time)[]:
	i: 111&120(t)
	o: 138(t), 178(f)

nname: 111&120
n 111&120(conflict_with_padding and not conflict_without_padding)[conflict_without_padding = self.new_rec.start_time < rec.stop_time
]:
	i: 74(t), 98()
	o: 128(t), 253(f)

nname: 98
n 98(None)[]:
	i: 74(f)
	o: 111&120()

nname: 74
n 74(self.new_rec.start_time < rec.stop_time)[conflict_with_padding = self.new_rec.GetScheduledStartTime() < rec.GetScheduledStopTime()
]:
	i: 28(t), 58()
	o: 98(f), 111&120(t)

nname: 58
n 58(None)[]:
	i: 28(f)
	o: 74()

nname: 28
n 28(self.new_rec.GetScheduledStartTime() < rec.GetScheduledStopTime())[for rec in self.current_rec_list:
]:
	i: 18(for)
	o: 58(f), 74(t)

nname: 18
n 18(None)[]:
	i: 0(loop)
	o: 28(for), 366(AF)

nname: 0
n 0(None)[new_rec_start = self.new_rec.GetScheduledStartTime()
]:
	i: 
	o: 18(loop), 367(AL)

nname: 367
n 367(None)[filter((lambda rec: new_rec_start < rec.GetScheduledStopTime():
	pass
return new_rec_start < rec.GetScheduledStopTime()), self.result)
return new_rec_start
]:
	i: 0(AL), 18(AF), 337()
	o: 

nname: 337
n 337(None)[self.new_rec.status = RECORDING_STATUS_ABORTED
log.critical('SHOULD NOT HAPPEN => BUG => CHECK ALGO')
]:
	i: 253(f)
	o: 367()

nname: 253
n 253(None)[if rec.type == RECORDING_TYPE_NOT_SCHEDULED:
	self.result.append(rec)
	continue
if self.new_rec.type == RECORDING_TYPE_NOT_SCHEDULED:
	log.debug('trying to start an instant record during padding of a scheduled')
	self.new_rec.status = RECORDING_STATUS_ABORTED
	continue
]:
	i: 111&120(f), 234()
	o: 337()

nname: 234
n 234(None)[self.result.append(rec)
continue
]:
	i: 128()
	o: 253()

nname: 128
n 128(None)[if rec.stop_time:
	half_time = int((self.new_rec.start_time - rec.stop_time) / 2) + rec.stop_time
else:
	half_time = int(self.new_rec.start_padding / 2) + self.new_rec.start_time
if half_time > new_rec_start:
	new_rec_start = half_time
]:
	i: 111&120(t)
	o: 234()

nname: 111&120
n 111&120(conflict_with_padding and not conflict_without_padding)[conflict_without_padding = self.new_rec.start_time < rec.stop_time
]:
	i: 28(t)
	o: 128(t), 253(f)

nname: 28
n 28(None)[for rec in self.current_rec_list:
if not self.new_rec.GetScheduledStartTime() < rec.GetScheduledStopTime():
	pass
conflict_with_padding = self.new_rec.GetScheduledStartTime() < rec.GetScheduledStopTime()
if not self.new_rec.start_time < rec.stop_time:
	pass
]:
	i: 18(for)
	o: 111&120()

nname: 18
n 18(None)[]:
	i: 0(loop)
	o: 28(for), 367(AF)

nname: 0
n 0(None)[new_rec_start = self.new_rec.GetScheduledStartTime()
]:
	i: 
	o: 18(loop), 367(AL)

nname: 367
n 367(None)[filter((lambda rec: new_rec_start < rec.GetScheduledStopTime():
	pass
return new_rec_start < rec.GetScheduledStopTime()), self.result)
return new_rec_start
]:
	i: 0(AL), 18(AF), 253()
	o: 

nname: 253
n 253(None)[if rec.type == RECORDING_TYPE_NOT_SCHEDULED:
	self.result.append(rec)
	continue
if self.new_rec.type == RECORDING_TYPE_NOT_SCHEDULED:
	log.debug('trying to start an instant record during padding of a scheduled')
	self.new_rec.status = RECORDING_STATUS_ABORTED
	continue
self.new_rec.status = RECORDING_STATUS_ABORTED
log.critical('SHOULD NOT HAPPEN => BUG => CHECK ALGO')
]:
	i: 28(f), 128()
	o: 367()

nname: 128
n 128(None)[if rec.stop_time:
	half_time = int((self.new_rec.start_time - rec.stop_time) / 2) + rec.stop_time
else:
	half_time = int(self.new_rec.start_padding / 2) + self.new_rec.start_time
if half_time > new_rec_start:
	new_rec_start = half_time
self.result.append(rec)
continue
]:
	i: 28(t)
	o: 253()

nname: 28
n 28(conflict_with_padding and not conflict_without_padding)[for rec in self.current_rec_list:
if not self.new_rec.GetScheduledStartTime() < rec.GetScheduledStopTime():
	pass
conflict_with_padding = self.new_rec.GetScheduledStartTime() < rec.GetScheduledStopTime()
if not self.new_rec.start_time < rec.stop_time:
	pass
conflict_without_padding = self.new_rec.start_time < rec.stop_time
]:
	i: 18(for)
	o: 128(t), 253(f)

nname: 18
n 18(None)[]:
	i: 0(loop)
	o: 28(for), 367(AF)

nname: 0
n 0(None)[new_rec_start = self.new_rec.GetScheduledStartTime()
]:
	i: 
	o: 18(loop), 367(AL)

nname: 367
n 367(None)[filter((lambda rec: new_rec_start < rec.GetScheduledStopTime():
	pass
return new_rec_start < rec.GetScheduledStopTime()), self.result)
return new_rec_start
]:
	i: 0(AL), 18(AF), 28()
	o: 

nname: 28
n 28(None)[for rec in self.current_rec_list:
if not self.new_rec.GetScheduledStartTime() < rec.GetScheduledStopTime():
	pass
conflict_with_padding = self.new_rec.GetScheduledStartTime() < rec.GetScheduledStopTime()
if not self.new_rec.start_time < rec.stop_time:
	pass
conflict_without_padding = self.new_rec.start_time < rec.stop_time
if conflict_with_padding and not conflict_without_padding:
	if rec.stop_time:
		half_time = int((self.new_rec.start_time - rec.stop_time) / 2) + rec.stop_time
	else:
		half_time = int(self.new_rec.start_padding / 2) + self.new_rec.start_time
	if half_time > new_rec_start:
		new_rec_start = half_time
	self.result.append(rec)
	continue
if rec.type == RECORDING_TYPE_NOT_SCHEDULED:
	self.result.append(rec)
	continue
if self.new_rec.type == RECORDING_TYPE_NOT_SCHEDULED:
	log.debug('trying to start an instant record during padding of a scheduled')
	self.new_rec.status = RECORDING_STATUS_ABORTED
	continue
self.new_rec.status = RECORDING_STATUS_ABORTED
log.critical('SHOULD NOT HAPPEN => BUG => CHECK ALGO')
]:
	i: 18(for)
	o: 367()

nname: 18
n 18(None)[]:
	i: 0(loop)
	o: 28(for), 367(AF)

nname: 0
n 0(None)[new_rec_start = self.new_rec.GetScheduledStartTime()
]:
	i: 
	o: 18(loop), 367(AL)

nname: 28
n 28(None)[for rec in self.current_rec_list:
	if not self.new_rec.GetScheduledStartTime() < rec.GetScheduledStopTime():
		pass
	conflict_with_padding = self.new_rec.GetScheduledStartTime() < rec.GetScheduledStopTime()
	if not self.new_rec.start_time < rec.stop_time:
		pass
	conflict_without_padding = self.new_rec.start_time < rec.stop_time
	if conflict_with_padding and not conflict_without_padding:
		if rec.stop_time:
			half_time = int((self.new_rec.start_time - rec.stop_time) / 2) + rec.stop_time
		else:
			half_time = int(self.new_rec.start_padding / 2) + self.new_rec.start_time
		if half_time > new_rec_start:
			new_rec_start = half_time
		self.result.append(rec)
		continue
	if rec.type == RECORDING_TYPE_NOT_SCHEDULED:
		self.result.append(rec)
		continue
	if self.new_rec.type == RECORDING_TYPE_NOT_SCHEDULED:
		log.debug('trying to start an instant record during padding of a scheduled')
		self.new_rec.status = RECORDING_STATUS_ABORTED
		continue
	self.new_rec.status = RECORDING_STATUS_ABORTED
	log.critical('SHOULD NOT HAPPEN => BUG => CHECK ALGO')
filter((lambda rec: new_rec_start < rec.GetScheduledStopTime():
	pass
return new_rec_start < rec.GetScheduledStopTime()), self.result)
return new_rec_start
]:
	i: 0(for)
	o: 

nname: 0
n 0(None)[new_rec_start = self.new_rec.GetScheduledStartTime()
]:
	i: 
	o: 28(for)

nname: 0
n 0(None)[new_rec_start = self.new_rec.GetScheduledStartTime()
for rec in self.current_rec_list:
	if not self.new_rec.GetScheduledStartTime() < rec.GetScheduledStopTime():
		pass
	conflict_with_padding = self.new_rec.GetScheduledStartTime() < rec.GetScheduledStopTime()
	if not self.new_rec.start_time < rec.stop_time:
		pass
	conflict_without_padding = self.new_rec.start_time < rec.stop_time
	if conflict_with_padding and not conflict_without_padding:
		if rec.stop_time:
			half_time = int((self.new_rec.start_time - rec.stop_time) / 2) + rec.stop_time
		else:
			half_time = int(self.new_rec.start_padding / 2) + self.new_rec.start_time
		if half_time > new_rec_start:
			new_rec_start = half_time
		self.result.append(rec)
		continue
	if rec.type == RECORDING_TYPE_NOT_SCHEDULED:
		self.result.append(rec)
		continue
	if self.new_rec.type == RECORDING_TYPE_NOT_SCHEDULED:
		log.debug('trying to start an instant record during padding of a scheduled')
		self.new_rec.status = RECORDING_STATUS_ABORTED
		continue
	self.new_rec.status = RECORDING_STATUS_ABORTED
	log.critical('SHOULD NOT HAPPEN => BUG => CHECK ALGO')
filter((lambda rec: new_rec_start < rec.GetScheduledStopTime():
	pass
return new_rec_start < rec.GetScheduledStopTime()), self.result)
return new_rec_start
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7626fec>}
nname: 0
n 0(None)[return self.result
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb760feac>}
nname: 0
n 0(None)[return self.new_rec_start
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb760ffcc>}
nname: 6
n 6(None)[__doc__ = ' class used to dynamicly resolve conflict.\n    \n    a new rec need to start. a curren_rec_list are currently running.\n    modify on the fly padding in order to start the new rec.\n    '
def __init__(self, new_rec, current_rec_list):
	self.new_rec = new_rec
	self.current_rec_list = current_rec_list
	self.result = []
	self.new_rec_start = self._AdjustTimeForRec__check()

def _AdjustTimeForRec__check(self):
	new_rec_start = self.new_rec.GetScheduledStartTime()
	for rec in self.current_rec_list:
		if not self.new_rec.GetScheduledStartTime() < rec.GetScheduledStopTime():
			pass
		conflict_with_padding = self.new_rec.GetScheduledStartTime() < rec.GetScheduledStopTime()
		if not self.new_rec.start_time < rec.stop_time:
			pass
		conflict_without_padding = self.new_rec.start_time < rec.stop_time
		if conflict_with_padding and not conflict_without_padding:
			if rec.stop_time:
				half_time = int((self.new_rec.start_time - rec.stop_time) / 2) + rec.stop_time
			else:
				half_time = int(self.new_rec.start_padding / 2) + self.new_rec.start_time
			if half_time > new_rec_start:
				new_rec_start = half_time
			self.result.append(rec)
			continue
		if rec.type == RECORDING_TYPE_NOT_SCHEDULED:
			self.result.append(rec)
			continue
		if self.new_rec.type == RECORDING_TYPE_NOT_SCHEDULED:
			log.debug('trying to start an instant record during padding of a scheduled')
			self.new_rec.status = RECORDING_STATUS_ABORTED
			continue
		self.new_rec.status = RECORDING_STATUS_ABORTED
		log.critical('SHOULD NOT HAPPEN => BUG => CHECK ALGO')
	filter((lambda rec: new_rec_start < rec.GetScheduledStopTime():
		pass
	return new_rec_start < rec.GetScheduledStopTime()), self.result)
	return new_rec_start

def getRecToModify(self):
	return self.result

def getTime(self):
	return self.new_rec_start

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb760f9ac>}
nname: 0
n 0(None)[from logger import log
from recording import RECORDING_TYPE_NORMAL
from recording import RECORDING_TYPE_FLASHBACK
from recording import RECORDING_TYPE_NOT_SCHEDULED
from recording import RECORDING_STATUS_ABORTED
def resolveFromAdjustTimeForRec(adjust):
	for rec in adjust.getRecToModify():
		rec.updateStopTime(adjust.new_rec_start)
	adjust.new_rec.updateStartTime(adjust.new_rec_start)

class AdjustTimeForRec(object):
	__doc__ = ' class used to dynamicly resolve conflict.\n    \n    a new rec need to start. a curren_rec_list are currently running.\n    modify on the fly padding in order to start the new rec.\n    '
	def __init__(self, new_rec, current_rec_list):
		self.new_rec = new_rec
		self.current_rec_list = current_rec_list
		self.result = []
		self.new_rec_start = self._AdjustTimeForRec__check()

	def _AdjustTimeForRec__check(self):
		new_rec_start = self.new_rec.GetScheduledStartTime()
		for rec in self.current_rec_list:
			if not self.new_rec.GetScheduledStartTime() < rec.GetScheduledStopTime():
				pass
			conflict_with_padding = self.new_rec.GetScheduledStartTime() < rec.GetScheduledStopTime()
			if not self.new_rec.start_time < rec.stop_time:
				pass
			conflict_without_padding = self.new_rec.start_time < rec.stop_time
			if conflict_with_padding and not conflict_without_padding:
				if rec.stop_time:
					half_time = int((self.new_rec.start_time - rec.stop_time) / 2) + rec.stop_time
				else:
					half_time = int(self.new_rec.start_padding / 2) + self.new_rec.start_time
				if half_time > new_rec_start:
					new_rec_start = half_time
				self.result.append(rec)
				continue
			if rec.type == RECORDING_TYPE_NOT_SCHEDULED:
				self.result.append(rec)
				continue
			if self.new_rec.type == RECORDING_TYPE_NOT_SCHEDULED:
				log.debug('trying to start an instant record during padding of a scheduled')
				self.new_rec.status = RECORDING_STATUS_ABORTED
				continue
			self.new_rec.status = RECORDING_STATUS_ABORTED
			log.critical('SHOULD NOT HAPPEN => BUG => CHECK ALGO')
		filter((lambda rec: new_rec_start < rec.GetScheduledStopTime():
			pass
		return new_rec_start < rec.GetScheduledStopTime()), self.result)
		return new_rec_start

	def getRecToModify(self):
		return self.result

	def getTime(self):
		return self.new_rec_start



]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7606b6c>}
from logger import log
from recording import RECORDING_TYPE_NORMAL
from recording import RECORDING_TYPE_FLASHBACK
from recording import RECORDING_TYPE_NOT_SCHEDULED
from recording import RECORDING_STATUS_ABORTED
def resolveFromAdjustTimeForRec(adjust):
	for rec in adjust.getRecToModify():
		rec.updateStopTime(adjust.new_rec_start)
	adjust.new_rec.updateStartTime(adjust.new_rec_start)

class AdjustTimeForRec(object):
	__doc__ = ' class used to dynamicly resolve conflict.\n    \n    a new rec need to start. a curren_rec_list are currently running.\n    modify on the fly padding in order to start the new rec.\n    '
	def __init__(self, new_rec, current_rec_list):
		self.new_rec = new_rec
		self.current_rec_list = current_rec_list
		self.result = []
		self.new_rec_start = self._AdjustTimeForRec__check()

	def _AdjustTimeForRec__check(self):
		new_rec_start = self.new_rec.GetScheduledStartTime()
		for rec in self.current_rec_list:
			if not self.new_rec.GetScheduledStartTime() < rec.GetScheduledStopTime():
				pass
			conflict_with_padding = self.new_rec.GetScheduledStartTime() < rec.GetScheduledStopTime()
			if not self.new_rec.start_time < rec.stop_time:
				pass
			conflict_without_padding = self.new_rec.start_time < rec.stop_time
			if conflict_with_padding and not conflict_without_padding:
				if rec.stop_time:
					half_time = int((self.new_rec.start_time - rec.stop_time) / 2) + rec.stop_time
				else:
					half_time = int(self.new_rec.start_padding / 2) + self.new_rec.start_time
				if half_time > new_rec_start:
					new_rec_start = half_time
				self.result.append(rec)
				continue
			if rec.type == RECORDING_TYPE_NOT_SCHEDULED:
				self.result.append(rec)
				continue
			if self.new_rec.type == RECORDING_TYPE_NOT_SCHEDULED:
				log.debug('trying to start an instant record during padding of a scheduled')
				self.new_rec.status = RECORDING_STATUS_ABORTED
				continue
			self.new_rec.status = RECORDING_STATUS_ABORTED
			log.critical('SHOULD NOT HAPPEN => BUG => CHECK ALGO')
		filter((lambda rec: new_rec_start < rec.GetScheduledStopTime():
			pass
		return new_rec_start < rec.GetScheduledStopTime()), self.result)
		return new_rec_start

	def getRecToModify(self):
		return self.result

	def getTime(self):
		return self.new_rec_start



