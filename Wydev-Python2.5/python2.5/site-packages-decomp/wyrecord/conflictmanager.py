# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 56
n 56(None)[]:
	i: 33(), 46()
	o: 

nname: 46
n 46(None)[self.recording_list = rec_list
]:
	i: 0(t)
	o: 56()

nname: 33
n 33(None)[self.recording_list = []
]:
	i: 0(f)
	o: 56()

nname: 0
n 0(rec_list)[self.start = start
self.stop = stop
self.are_services_playable = are_services_playable
]:
	i: 
	o: 33(f), 46(t)

nname: 0
n 0(None)[self.start = start
self.stop = stop
self.are_services_playable = are_services_playable
if not rec_list:
	self.recording_list = []
else:
	self.recording_list = rec_list
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76be42c>}
nname: 0
n 0(None)[return ChronologicalElement(self.are_services_playable, copy.copy(self.start), copy.copy(self.stop), copy.copy(self.recording_list))
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76be62c>}
nname: 452
n 452(None)[return invalid_rec_list
]:
	i: 67(AL), 451()
	o: 

nname: 451
n 451(None)[]:
	i: 70(AF), 448()
	o: 452()

nname: 448
n 448(None)[]:
	i: 438(JA), 447()
	o: 451()

nname: 447
n 447(None)[_POP_TOP pass
]:
	i: 395&402(f), 443()
	o: 448()

nname: 443
n 443(None)[continue
]:
	i: 418(t)
	o: 447()

nname: 438
n 438(None)[break
]:
	i: 418(f)
	o: 448(JA)

nname: 418
n 418(loop)[invalid_rec_list.append(recording)
]:
	i: 395&402(t)
	o: 438(f), 443(t)

nname: 395&402
n 395&402(not device_found or nb_rec > config.max_simultaneous_rec)[]:
	i: 336(AL), 394()
	o: 418(t), 447(f)

nname: 394
n 394(None)[]:
	i: 345(AF), 390()
	o: 395&402()

nname: 390
n 390(None)[]:
	i: 358(f), 376()
	o: 394()

nname: 376
n 376(None)[nb_rec += 1
continue
]:
	i: 358(t)
	o: 390()

nname: 358
n 358(rec.type != RECORDING_TYPE_IS_LIVE)[for rec in found_list.keys():
]:
	i: 345(for)
	o: 376(t), 390(f)

nname: 345
n 345(None)[]:
	i: 336(loop)
	o: 358(for), 394(AF)

nname: 336
n 336(None)[nb_rec = 0
]:
	i: 150(AL), 335()
	o: 345(loop), 395&402(AL)

nname: 335
n 335(None)[]:
	i: 182(AF), 332()
	o: 336()

nname: 332
n 332(None)[]:
	i: 189(AL), 331()
	o: 335()

nname: 331
n 331(None)[]:
	i: 282(f), 326()
	o: 332()

nname: 326
n 326(None)[break
continue
]:
	i: 282(t)
	o: 331()

nname: 282
n 282(device in found_list.values())[]:
	i: 201(AF), 278()
	o: 326(t), 331(f)

nname: 278
n 278(None)[_POP_TOP pass
]:
	i: 214&241(f), 273()
	o: 282()

nname: 273
n 273(None)[break
continue
]:
	i: 214&241(t)
	o: 278()

nname: 214&241
n 214&241(found_recording.service_id == recording.service_id or not self.are_services_playable(found_device, found_recording.service_id, device, recording.service_id))[recording.deviceid, found_list[recording], device_found, found_recording, found_device = device, device, True, found_list.items(), found_list.items()
]:
	i: 201(for)
	o: 273(t), 278(f)

nname: 201
n 201(None)[]:
	i: 189(loop)
	o: 214&241(for), 282(AF)

nname: 189
n 189(None)[for device in possible_devices:
failed_to_found = False
]:
	i: 182(for)
	o: 201(loop), 332(AL)

nname: 182
n 182(None)[]:
	i: 150(loop)
	o: 189(for), 335(AF)

nname: 150
n 150(None)[device_found = False
log.debug('getInvalidRecordingList possible_devices =' + str(possible_devices))
]:
	i: 124(), 140()
	o: 182(loop), 336(AL)

nname: 140
n 140(None)[possible_devices = recording.possible_deviceids
]:
	i: 80(f)
	o: 150()

nname: 124
n 124(None)[possible_devices = [recording.deviceid]
]:
	i: 80(t)
	o: 150()

nname: 80
n 80(recording.deviceid != 0)[for recording in self.recording_list:
log.debug('getInvalidRecordingList recording =' + str(recording.id))
]:
	i: 70(for)
	o: 124(t), 140(f)

nname: 70
n 70(None)[]:
	i: 67(loop)
	o: 80(for), 451(AF)

nname: 67
n 67(None)[]:
	i: 27(), 66()
	o: 70(loop), 452(AL)

nname: 66
n 66(None)[]:
	i: 0(f)
	o: 67()

nname: 27
n 27(None)[self.recording_list.remove(first_rec)
self.recording_list.insert(0, first_rec)
]:
	i: 0(t)
	o: 67()

nname: 0
n 0(first_rec in self.recording_list)[invalid_rec_list = []
found_list = {}
]:
	i: 
	o: 27(t), 66(f)

nname: 452
n 452(None)[return invalid_rec_list
]:
	i: 0(AL), 70(AF), 438(JA), 447()
	o: 

nname: 447
n 447(None)[_POP_TOP pass
]:
	i: 395&402(f), 443()
	o: 452()

nname: 443
n 443(None)[continue
]:
	i: 418(t)
	o: 447()

nname: 438
n 438(None)[break
]:
	i: 418(f)
	o: 452(JA)

nname: 418
n 418(loop)[invalid_rec_list.append(recording)
]:
	i: 395&402(t)
	o: 438(f), 443(t)

nname: 395&402
n 395&402(not device_found or nb_rec > config.max_simultaneous_rec)[]:
	i: 336(AL), 345(AF), 358()
	o: 418(t), 447(f)

nname: 358
n 358(None)[for rec in found_list.keys():
if rec.type != RECORDING_TYPE_IS_LIVE:
	nb_rec += 1
	continue
]:
	i: 345(for)
	o: 395&402()

nname: 345
n 345(None)[]:
	i: 336(loop)
	o: 358(for), 395&402(AF)

nname: 336
n 336(None)[nb_rec = 0
]:
	i: 80(AL), 182(AF), 189(AL), 282()
	o: 345(loop), 395&402(AL)

nname: 282
n 282(None)[if device in found_list.values():
	break
	continue
]:
	i: 201(AF), 214&241()
	o: 336()

nname: 214&241
n 214&241(None)[recording.deviceid, found_list[recording], device_found, found_recording, found_device = device, device, True, found_list.items(), found_list.items()
if found_recording.service_id == recording.service_id or not self.are_services_playable(found_device, found_recording.service_id, device, recording.service_id):
	break
	continue
_POP_TOP pass
]:
	i: 201(for)
	o: 282()

nname: 201
n 201(None)[]:
	i: 189(loop)
	o: 214&241(for), 282(AF)

nname: 189
n 189(None)[for device in possible_devices:
failed_to_found = False
]:
	i: 182(for)
	o: 201(loop), 336(AL)

nname: 182
n 182(None)[]:
	i: 80(loop)
	o: 189(for), 336(AF)

nname: 80
n 80(None)[for recording in self.recording_list:
log.debug('getInvalidRecordingList recording =' + str(recording.id))
if recording.deviceid != 0:
	possible_devices = [recording.deviceid]
else:
	possible_devices = recording.possible_deviceids
device_found = False
log.debug('getInvalidRecordingList possible_devices =' + str(possible_devices))
]:
	i: 70(for)
	o: 182(loop), 336(AL)

nname: 70
n 70(None)[]:
	i: 0(loop)
	o: 80(for), 452(AF)

nname: 0
n 0(None)[invalid_rec_list = []
found_list = {}
if first_rec in self.recording_list:
	self.recording_list.remove(first_rec)
	self.recording_list.insert(0, first_rec)
]:
	i: 
	o: 70(loop), 452(AL)

nname: 452
n 452(None)[return invalid_rec_list
]:
	i: 0(AL), 70(AF), 438(JA), 447()
	o: 

nname: 447
n 447(None)[_POP_TOP pass
]:
	i: 358(f), 443()
	o: 452()

nname: 443
n 443(None)[continue
]:
	i: 418(t)
	o: 447()

nname: 438
n 438(None)[break
]:
	i: 418(f)
	o: 452(JA)

nname: 418
n 418(loop)[invalid_rec_list.append(recording)
]:
	i: 358(t)
	o: 438(f), 443(t)

nname: 358
n 358(not device_found or nb_rec > config.max_simultaneous_rec)[for rec in found_list.keys():
	if rec.type != RECORDING_TYPE_IS_LIVE:
		nb_rec += 1
		continue
]:
	i: 336(for)
	o: 418(t), 447(f)

nname: 336
n 336(None)[nb_rec = 0
]:
	i: 80(AL), 182(AF), 214&241()
	o: 358(for)

nname: 214&241
n 214&241(None)[recording.deviceid, found_list[recording], device_found, found_recording, found_device = device, device, True, found_list.items(), found_list.items()
	if found_recording.service_id == recording.service_id or not self.are_services_playable(found_device, found_recording.service_id, device, recording.service_id):
		break
		continue
	_POP_TOP pass
else:
	if device in found_list.values():
		break
		continue
]:
	i: 189(for)
	o: 336()

nname: 189
n 189(None)[for device in possible_devices:
failed_to_found = False
]:
	i: 182(for)
	o: 214&241(for)

nname: 182
n 182(None)[]:
	i: 80(loop)
	o: 189(for), 336(AF)

nname: 80
n 80(None)[for recording in self.recording_list:
log.debug('getInvalidRecordingList recording =' + str(recording.id))
if recording.deviceid != 0:
	possible_devices = [recording.deviceid]
else:
	possible_devices = recording.possible_deviceids
device_found = False
log.debug('getInvalidRecordingList possible_devices =' + str(possible_devices))
]:
	i: 70(for)
	o: 182(loop), 336(AL)

nname: 70
n 70(None)[]:
	i: 0(loop)
	o: 80(for), 452(AF)

nname: 0
n 0(None)[invalid_rec_list = []
found_list = {}
if first_rec in self.recording_list:
	self.recording_list.remove(first_rec)
	self.recording_list.insert(0, first_rec)
]:
	i: 
	o: 70(loop), 452(AL)

nname: 452
n 452(None)[return invalid_rec_list
]:
	i: 0(AL), 70(AF), 438(JA), 447()
	o: 

nname: 447
n 447(None)[_POP_TOP pass
]:
	i: 336(f), 443()
	o: 452()

nname: 443
n 443(None)[continue
]:
	i: 418(t)
	o: 447()

nname: 438
n 438(None)[break
]:
	i: 418(f)
	o: 452(JA)

nname: 418
n 418(loop)[invalid_rec_list.append(recording)
]:
	i: 336(t)
	o: 438(f), 443(t)

nname: 336
n 336(not device_found or nb_rec > config.max_simultaneous_rec)[nb_rec = 0
for rec in found_list.keys():
	if rec.type != RECORDING_TYPE_IS_LIVE:
		nb_rec += 1
		continue
]:
	i: 80(AL), 182(AF), 189()
	o: 418(t), 447(f)

nname: 189
n 189(None)[for device in possible_devices:
failed_to_found = False
recording.deviceid, found_list[recording], device_found, found_recording, found_device = device, device, True, found_list.items(), found_list.items()
	if found_recording.service_id == recording.service_id or not self.are_services_playable(found_device, found_recording.service_id, device, recording.service_id):
		break
		continue
	_POP_TOP pass
else:
	if device in found_list.values():
		break
		continue
]:
	i: 182(for)
	o: 336()

nname: 182
n 182(None)[]:
	i: 80(loop)
	o: 189(for), 336(AF)

nname: 80
n 80(None)[for recording in self.recording_list:
log.debug('getInvalidRecordingList recording =' + str(recording.id))
if recording.deviceid != 0:
	possible_devices = [recording.deviceid]
else:
	possible_devices = recording.possible_deviceids
device_found = False
log.debug('getInvalidRecordingList possible_devices =' + str(possible_devices))
]:
	i: 70(for)
	o: 182(loop), 336(AL)

nname: 70
n 70(None)[]:
	i: 0(loop)
	o: 80(for), 452(AF)

nname: 0
n 0(None)[invalid_rec_list = []
found_list = {}
if first_rec in self.recording_list:
	self.recording_list.remove(first_rec)
	self.recording_list.insert(0, first_rec)
]:
	i: 
	o: 70(loop), 452(AL)

self.nodes: {0: <unpyclib.structure.node instance at 0xb76c732c>, 418: <unpyclib.structure.node instance at 0xb7657f6c>, 70: <unpyclib.structure.node instance at 0xb76c4bec>, 182: <unpyclib.structure.node instance at 0xb76c4e6c>, 443: <unpyclib.structure.node instance at 0xb76c708c>, 189: <unpyclib.structure.node instance at 0xb76c7ccc>, 447: <unpyclib.structure.node instance at 0xb76c710c>, 452: <unpyclib.structure.node instance at 0xb76c728c>, 438: <unpyclib.structure.node instance at 0xb7657fec>, 336: <unpyclib.structure.node instance at 0xb76c7e6c>, 80: <unpyclib.structure.node instance at 0xb76c736c>}
nname: 113
n 113(None)[del _[1]
# INPLACE_* op used not as INPLACE!!!
s = '\n list , size = ' + str(len(self.recording_list)) += repr + [](self.recording_list)
return s
]:
	i: 0(AF), 97()
	o: 

nname: 97
n 97(None)[for rec in self.recording_list:
]:
	i: 0(for)
	o: 113()

nname: 0
n 0(None)[s = ''
s += '\n start ' + str(self.start)
s += '\n stop ' + str(self.stop)
]:
	i: 
	o: 97(for), 113(AF)

self.nodes: {0: <unpyclib.structure.node instance at 0xb76bef6c>, 97: <unpyclib.structure.node instance at 0xb76be90c>, 113: <unpyclib.structure.node instance at 0xb76be50c>}
nname: 6
n 6(None)[__doc__ = ' element used by ChronologicalRecordingList.\n\n    a chronological element is defined by:\n        a start time\n        a stop time\n        the list of simultaneous recording during this laps of time\n    \n    this element is used to store the recordings (self.recording_list) that should be played\n    at the same time from self.start to self.stop.\n    \n    \n    it can compute the list of recording that are in conflict.\n    '
def __init__(self, are_services_playable, start=-2147483640, stop=0, rec_list=None, next_elem=None, previous_elem=None):
	self.start = start
	self.stop = stop
	self.are_services_playable = are_services_playable
	if not rec_list:
		self.recording_list = []
	else:
		self.recording_list = rec_list

def getCopy(self):
	return ChronologicalElement(self.are_services_playable, copy.copy(self.start), copy.copy(self.stop), copy.copy(self.recording_list))

def getInvalidRecordingList(self, first_rec=None, loop=False):
	invalid_rec_list = []
	found_list = {}
	if first_rec in self.recording_list:
		self.recording_list.remove(first_rec)
		self.recording_list.insert(0, first_rec)

def __str__(self):
	s = ''
	s += '\n start ' + str(self.start)
	s += '\n stop ' + str(self.stop)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb76b8dcc>}
nname: 0
n 0(None)[self.elemList = None
self.recording_launcher = recording_launcher
self.orderRecording(not_ordered_list)
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76be0cc>}
nname: 65
n 65(None)[]:
	i: 30(AL), 60(), 64()
	o: 

nname: 64
n 64(None)[]:
	i: 0(f)
	o: 65()

nname: 60
n 60(None)[]:
	i: 34(AF), 41()
	o: 65()

nname: 41
n 41(None)[for rec in list_to_order:
self.insertRecording(rec)
]:
	i: 34(for)
	o: 60()

nname: 34
n 34(None)[]:
	i: 30(loop)
	o: 41(for), 60(AF)

nname: 30
n 30(None)[]:
	i: 0(t)
	o: 34(loop), 65(AL)

nname: 0
n 0(list_to_order)[self.elemList = [ChronologicalElement(self.recording_launcher.AreServicesPlayable)]
]:
	i: 
	o: 30(t), 64(f)

nname: 65
n 65(None)[]:
	i: 41(), 0(f)
	o: 

nname: 41
n 41(None)[for rec in list_to_order:
	self.insertRecording(rec)
]:
	i: 30(for)
	o: 65()

nname: 30
n 30(None)[]:
	i: 0(t)
	o: 41(for)

nname: 0
n 0(list_to_order)[self.elemList = [ChronologicalElement(self.recording_launcher.AreServicesPlayable)]
]:
	i: 
	o: 30(t), 65(f)

nname: 65
n 65(None)[]:
	i: 30(), 0(f)
	o: 

nname: 30
n 30(None)[for rec in list_to_order:
	self.insertRecording(rec)
]:
	i: 0(t)
	o: 65()

nname: 0
n 0(list_to_order)[self.elemList = [ChronologicalElement(self.recording_launcher.AreServicesPlayable)]
]:
	i: 
	o: 30(t), 65(f)

nname: 0
n 0(None)[self.elemList = [ChronologicalElement(self.recording_launcher.AreServicesPlayable)]
if list_to_order:
	for rec in list_to_order:
		self.insertRecording(rec)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76be30c>}
nname: 221
n 221(None)[]:
	i: 128(), 188()
	o: 

nname: 188
n 188(None)[log.critical('SHOULD NOT HAPPEN CHECK ALGO')
self.elemList.recording_list.append(rec)
]:
	i: 122(f)
	o: 221()

nname: 128
n 128(None)[self._ChronologicalRecordingList__checkBegin(conflict_list[0], rec)
self._ChronologicalRecordingList__checkEnd(conflict_list[-1], rec)
self._ChronologicalRecordingList__joinList(conflict_list, rec)
]:
	i: 122(t)
	o: 221()

nname: 122
n 122(conflict_list)[]:
	i: 0(AL), 121()
	o: 128(t), 188(f)

nname: 121
n 121(None)[]:
	i: 18(AF), 117()
	o: 122()

nname: 117
n 117(None)[_POP_TOP pass
]:
	i: 28&49&65&84(f), 100()
	o: 121()

nname: 100
n 100(None)[conflict_list.append(current_elem)
continue
]:
	i: 28&49&65&84(t)
	o: 117()

nname: 28&49&65&84
n 28&49&65&84((current_elem.start < rec.stop_time or rec.stop_time == 0) and (current_elem.stop > rec.start_time or current_elem.stop == 0))[for current_elem in self.elemList:
]:
	i: 18(for)
	o: 100(t), 117(f)

nname: 18
n 18(None)[]:
	i: 0(loop)
	o: 28&49&65&84(for), 121(AF)

nname: 0
n 0(None)[rec.deviceid = 0
conflict_list = []
]:
	i: 
	o: 18(loop), 122(AL)

nname: 122
n 122(None)[if conflict_list:
	self._ChronologicalRecordingList__checkBegin(conflict_list[0], rec)
	self._ChronologicalRecordingList__checkEnd(conflict_list[-1], rec)
	self._ChronologicalRecordingList__joinList(conflict_list, rec)
else:
	log.critical('SHOULD NOT HAPPEN CHECK ALGO')
	self.elemList.recording_list.append(rec)
]:
	i: 0(AL), 18(AF), 28&49&65&84()
	o: 

nname: 28&49&65&84
n 28&49&65&84(None)[for current_elem in self.elemList:
if (current_elem.start < rec.stop_time or rec.stop_time == 0) and (current_elem.stop > rec.start_time or current_elem.stop == 0):
	conflict_list.append(current_elem)
	continue
_POP_TOP pass
]:
	i: 18(for)
	o: 122()

nname: 18
n 18(None)[]:
	i: 0(loop)
	o: 28&49&65&84(for), 122(AF)

nname: 0
n 0(None)[rec.deviceid = 0
conflict_list = []
]:
	i: 
	o: 18(loop), 122(AL)

nname: 28&49&65&84
n 28&49&65&84(None)[for current_elem in self.elemList:
	if (current_elem.start < rec.stop_time or rec.stop_time == 0) and (current_elem.stop > rec.start_time or current_elem.stop == 0):
		conflict_list.append(current_elem)
		continue
	_POP_TOP pass
if conflict_list:
	self._ChronologicalRecordingList__checkBegin(conflict_list[0], rec)
	self._ChronologicalRecordingList__checkEnd(conflict_list[-1], rec)
	self._ChronologicalRecordingList__joinList(conflict_list, rec)
else:
	log.critical('SHOULD NOT HAPPEN CHECK ALGO')
	self.elemList.recording_list.append(rec)
]:
	i: 0(for)
	o: 

nname: 0
n 0(None)[rec.deviceid = 0
conflict_list = []
]:
	i: 
	o: 28&49&65&84(for)

nname: 0
n 0(None)[rec.deviceid = 0
conflict_list = []
for current_elem in self.elemList:
	if (current_elem.start < rec.stop_time or rec.stop_time == 0) and (current_elem.stop > rec.start_time or current_elem.stop == 0):
		conflict_list.append(current_elem)
		continue
	_POP_TOP pass
if conflict_list:
	self._ChronologicalRecordingList__checkBegin(conflict_list[0], rec)
	self._ChronologicalRecordingList__checkEnd(conflict_list[-1], rec)
	self._ChronologicalRecordingList__joinList(conflict_list, rec)
else:
	log.critical('SHOULD NOT HAPPEN CHECK ALGO')
	self.elemList.recording_list.append(rec)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76be92c>}
nname: 36
n 36(None)[return None
]:
	i: 27(), 35()
	o: 

nname: 35
n 35(None)[]:
	i: 0(f)
	o: 36()

nname: 27
n 27(None)[return conflict
]:
	i: 0(t)
	o: 36()

nname: 0
n 0(conflict.conflict_list)[conflict = InConflictRecording(self.elemList, rec)
]:
	i: 
	o: 27(t), 35(f)

nname: 0
n 0(None)[conflict = InConflictRecording(self.elemList, rec)
if conflict.conflict_list:
	return conflict
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76be20c>}
nname: 42
n 42(None)[return s
]:
	i: 0(AL), 41()
	o: 

nname: 41
n 41(None)[]:
	i: 9(AF), 19()
	o: 42()

nname: 19
n 19(None)[for current_elem in self.elemList:
s += current_elem.__str__()
]:
	i: 9(for)
	o: 41()

nname: 9
n 9(None)[]:
	i: 0(loop)
	o: 19(for), 41(AF)

nname: 0
n 0(None)[s = 'THE chronological list'
]:
	i: 
	o: 9(loop), 42(AL)

nname: 42
n 42(None)[return s
]:
	i: 19()
	o: 

nname: 19
n 19(None)[for current_elem in self.elemList:
	s += current_elem.__str__()
]:
	i: 0(for)
	o: 42()

nname: 0
n 0(None)[s = 'THE chronological list'
]:
	i: 
	o: 19(for)

nname: 42
n 42(None)[return s
]:
	i: 0()
	o: 

nname: 0
n 0(None)[s = 'THE chronological list'
for current_elem in self.elemList:
	s += current_elem.__str__()
]:
	i: 
	o: 42()

nname: 0
n 0(None)[s = 'THE chronological list'
for current_elem in self.elemList:
	s += current_elem.__str__()
return s
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76be16c>}
nname: 180
n 180(None)[]:
	i: 18(), 108(), 179()
	o: 

nname: 179
n 179(None)[]:
	i: 89(f)
	o: 180()

nname: 108
n 108(None)[new_elem = elem.getCopy()
new_elem.stop = rec.start_time
elem.start = new_elem.stop
self.elemList.insert(self.elemList.index(elem), new_elem)
]:
	i: 89(t)
	o: 180()

nname: 89
n 89(elem.start < rec.start_time)[]:
	i: 0(f)
	o: 108(t), 179(f)

nname: 18
n 18(None)[new_elem = ChronologicalElement(self.recording_launcher.AreServicesPlayable, rec.start_time, elem.start, [rec])
self.elemList.insert(self.elemList.index(elem), new_elem)
]:
	i: 0(t)
	o: 180()

nname: 0
n 0(elem.start > rec.start_time)[]:
	i: 
	o: 18(t), 89(f)

nname: 0
n 0(None)[if elem.start > rec.start_time:
	new_elem = ChronologicalElement(self.recording_launcher.AreServicesPlayable, rec.start_time, elem.start, [rec])
	self.elemList.insert(self.elemList.index(elem), new_elem)
else:
	if elem.start < rec.start_time:
		new_elem = elem.getCopy()
		new_elem.stop = rec.start_time
		elem.start = new_elem.stop
		self.elemList.insert(self.elemList.index(elem), new_elem)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76bef4c>}
nname: 260
n 260(None)[]:
	i: 74(), 184(), 259()
	o: 

nname: 259
n 259(None)[]:
	i: 149&168(f)
	o: 260()

nname: 184
n 184(None)[new_elem = ChronologicalElement(self.recording_launcher.AreServicesPlayable, elem.stop, rec.stop_time, [rec])
self.elemList.insert(self.elemList.index(elem) + 1, new_elem)
]:
	i: 149&168(t)
	o: 260()

nname: 149&168
n 149&168(elem.stop < rec.stop_time or rec.stop_time == 0)[]:
	i: 40&58(f)
	o: 184(t), 259(f)

nname: 74
n 74(None)[new_elem = elem.getCopy()
new_elem.start = rec.stop_time
elem.stop = new_elem.start
self.elemList.insert(self.elemList.index(elem) + 1, new_elem)
]:
	i: 40&58(t)
	o: 260()

nname: 40&58
n 40&58(elem.stop > rec.stop_time or elem.stop == 0)[]:
	i: 31(), 39()
	o: 74(t), 149&168(f)

nname: 39
n 39(None)[]:
	i: 0&15(f)
	o: 40&58()

nname: 31
n 31(None)[]:
	i: 0&15(t)
	o: 40&58()

nname: 0&15
n 0&15(elem.stop == 0 and rec.stop_time == 0)[]:
	i: 
	o: 31(t), 39(f)

nname: 260
n 260(None)[]:
	i: 0&15()
	o: 

nname: 0&15
n 0&15(None)[if elem.stop == 0 and rec.stop_time == 0:
	pass
if elem.stop > rec.stop_time or elem.stop == 0:
	new_elem = elem.getCopy()
	new_elem.start = rec.stop_time
	elem.stop = new_elem.start
	self.elemList.insert(self.elemList.index(elem) + 1, new_elem)
else:
	if elem.stop < rec.stop_time or rec.stop_time == 0:
		new_elem = ChronologicalElement(self.recording_launcher.AreServicesPlayable, elem.stop, rec.stop_time, [rec])
		self.elemList.insert(self.elemList.index(elem) + 1, new_elem)
]:
	i: 
	o: 260()

nname: 0&15
n 0&15(None)[if elem.stop == 0 and rec.stop_time == 0:
	pass
if elem.stop > rec.stop_time or elem.stop == 0:
	new_elem = elem.getCopy()
	new_elem.start = rec.stop_time
	elem.stop = new_elem.start
	self.elemList.insert(self.elemList.index(elem) + 1, new_elem)
else:
	if elem.stop < rec.stop_time or rec.stop_time == 0:
		new_elem = ChronologicalElement(self.recording_launcher.AreServicesPlayable, elem.stop, rec.stop_time, [rec])
		self.elemList.insert(self.elemList.index(elem) + 1, new_elem)
]:
	i: 
	o: 

self.nodes: {'0&15': <unpyclib.structure.node instance at 0xb76be9ac>}
nname: 146
n 146(None)[return None
]:
	i: 0(AL), 145()
	o: 

nname: 145
n 145(None)[]:
	i: 9(AF), 136()
	o: 146()

nname: 136
n 136(None)[previous_elem = elem
]:
	i: 60(JA), 131(), 135()
	o: 145()

nname: 135
n 135(None)[]:
	i: 16(f)
	o: 136()

nname: 131
n 131(None)[]:
	i: 41(f)
	o: 136()

nname: 60
n 60(None)[new_elem = ChronologicalElement(self.recording_launcher.AreServicesPlayable, previous_elem.stop, elem.start, [rec])
self.elemList.insert(self.elemList.index(elem), new_elem)
]:
	i: 41(t)
	o: 136(JA)

nname: 41
n 41(previous_elem.stop < elem.start)[]:
	i: 16(t)
	o: 60(t), 131(f)

nname: 16
n 16(previous_elem)[for elem in list:
elem.recording_list.append(rec)
]:
	i: 9(for)
	o: 41(t), 135(f)

nname: 9
n 9(None)[]:
	i: 0(loop)
	o: 16(for), 145(AF)

nname: 0
n 0(None)[previous_elem = None
]:
	i: 
	o: 9(loop), 146(AL)

nname: 146
n 146(None)[return None
]:
	i: 0(AL), 9(AF), 16()
	o: 

nname: 16
n 16(None)[for elem in list:
elem.recording_list.append(rec)
if previous_elem:
	if previous_elem.stop < elem.start:
		new_elem = ChronologicalElement(self.recording_launcher.AreServicesPlayable, previous_elem.stop, elem.start, [rec])
		self.elemList.insert(self.elemList.index(elem), new_elem)
previous_elem = elem
]:
	i: 9(for)
	o: 146()

nname: 9
n 9(None)[]:
	i: 0(loop)
	o: 16(for), 146(AF)

nname: 0
n 0(None)[previous_elem = None
]:
	i: 
	o: 9(loop), 146(AL)

nname: 16
n 16(None)[for elem in list:
	elem.recording_list.append(rec)
	if previous_elem:
		if previous_elem.stop < elem.start:
			new_elem = ChronologicalElement(self.recording_launcher.AreServicesPlayable, previous_elem.stop, elem.start, [rec])
			self.elemList.insert(self.elemList.index(elem), new_elem)
	previous_elem = elem
return None
]:
	i: 0(for)
	o: 

nname: 0
n 0(None)[previous_elem = None
]:
	i: 
	o: 16(for)

nname: 0
n 0(None)[previous_elem = None
for elem in list:
	elem.recording_list.append(rec)
	if previous_elem:
		if previous_elem.stop < elem.start:
			new_elem = ChronologicalElement(self.recording_launcher.AreServicesPlayable, previous_elem.stop, elem.start, [rec])
			self.elemList.insert(self.elemList.index(elem), new_elem)
	previous_elem = elem
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76bec0c>}
nname: 6
n 6(None)[__doc__ = ' used to arrange a recording list in a list of ChronologicalElement.\n    a logical structure is used to store recording so that conflict checking and resolving\n    are easier. The recordings are stored in a continuous list of chronological element.\n    \n    the goal is to check simultaneous recording.\n    \n    usage:\n    give the list by constructor\n    update the list by orderRecording\n    add recording by insertRecording\n    \n    get result getConflict\n    '
def __init__(self, recording_launcher, not_ordered_list=None):
	self.elemList = None
	self.recording_launcher = recording_launcher
	self.orderRecording(not_ordered_list)
	return None

def orderRecording(self, list_to_order):
	self.elemList = [ChronologicalElement(self.recording_launcher.AreServicesPlayable)]
	if list_to_order:
		for rec in list_to_order:
			self.insertRecording(rec)

def insertRecording(self, rec):
	rec.deviceid = 0
	conflict_list = []
	for current_elem in self.elemList:
		if (current_elem.start < rec.stop_time or rec.stop_time == 0) and (current_elem.stop > rec.start_time or current_elem.stop == 0):
			conflict_list.append(current_elem)
			continue
		_POP_TOP pass
	if conflict_list:
		self._ChronologicalRecordingList__checkBegin(conflict_list[0], rec)
		self._ChronologicalRecordingList__checkEnd(conflict_list[-1], rec)
		self._ChronologicalRecordingList__joinList(conflict_list, rec)
	else:
		log.critical('SHOULD NOT HAPPEN CHECK ALGO')
		self.elemList.recording_list.append(rec)

def getConflict(self, rec):
	conflict = InConflictRecording(self.elemList, rec)
	if conflict.conflict_list:
		return conflict
	return None

def __str__(self):
	s = 'THE chronological list'
	for current_elem in self.elemList:
		s += current_elem.__str__()
	return s

def _ChronologicalRecordingList__checkBegin(self, elem, rec):
	if elem.start > rec.start_time:
		new_elem = ChronologicalElement(self.recording_launcher.AreServicesPlayable, rec.start_time, elem.start, [rec])
		self.elemList.insert(self.elemList.index(elem), new_elem)
	else:
		if elem.start < rec.start_time:
			new_elem = elem.getCopy()
			new_elem.stop = rec.start_time
			elem.start = new_elem.stop
			self.elemList.insert(self.elemList.index(elem), new_elem)

def _ChronologicalRecordingList__checkEnd(self, elem, rec):
	if elem.stop == 0 and rec.stop_time == 0:
		pass
	if elem.stop > rec.stop_time or elem.stop == 0:
		new_elem = elem.getCopy()
		new_elem.start = rec.stop_time
		elem.stop = new_elem.start
		self.elemList.insert(self.elemList.index(elem) + 1, new_elem)
	else:
		if elem.stop < rec.stop_time or rec.stop_time == 0:
			new_elem = ChronologicalElement(self.recording_launcher.AreServicesPlayable, elem.stop, rec.stop_time, [rec])
			self.elemList.insert(self.elemList.index(elem) + 1, new_elem)

def _ChronologicalRecordingList__joinList(self, list, rec):
	previous_elem = None
	for elem in list:
		elem.recording_list.append(rec)
		if previous_elem:
			if previous_elem.stop < elem.start:
				new_elem = ChronologicalElement(self.recording_launcher.AreServicesPlayable, previous_elem.stop, elem.start, [rec])
				self.elemList.insert(self.elemList.index(elem), new_elem)
		previous_elem = elem
	return None

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb76b8e6c>}
nname: 79
n 79(None)[self._InConflictRecording__computeConflictList(chronological_list)
self._InConflictRecording__computeValidStartStopTime()
return None
]:
	i: 57(), 78()
	o: 

nname: 78
n 78(None)[]:
	i: 0(f)
	o: 79()

nname: 57
n 57(None)[log.error('can not work without specifying a recording')
return None
]:
	i: 0(t)
	o: 79()

nname: 0
n 0(rec == None)[self.conflict_list = []
self.in_conflict_rec = []
self.valid_start_stop_list = []
self.rec = rec
self.recording_list_corrupted = True
]:
	i: 
	o: 57(t), 78(f)

nname: 0
n 0(None)[self.conflict_list = []
self.in_conflict_rec = []
self.valid_start_stop_list = []
self.rec = rec
self.recording_list_corrupted = True
if rec == None:
	log.error('can not work without specifying a recording')
	return None
self._InConflictRecording__computeConflictList(chronological_list)
self._InConflictRecording__computeValidStartStopTime()
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76bef6c>}
nname: 104
n 104(None)[]:
	i: 0(AL), 103()
	o: 

nname: 103
n 103(None)[]:
	i: 12(AF), 100()
	o: 104()

nname: 100
n 100(None)[]:
	i: 59(JA), 99()
	o: 103()

nname: 99
n 99(None)[]:
	i: 19(f), 95()
	o: 100()

nname: 95
n 95(None)[continue
]:
	i: 31(f)
	o: 99()

nname: 59
n 59(None)[self.conflict_list.append(current_elem)
self.in_conflict_rec.extend(rec_list)
]:
	i: 31(t)
	o: 100(JA)

nname: 31
n 31(rec_list)[rec_list = current_elem.getInvalidRecordingList(self.rec, True)
]:
	i: 19(t)
	o: 59(t), 95(f)

nname: 19
n 19(current_elem.recording_list)[for current_elem in chronological_list:
]:
	i: 12(for)
	o: 31(t), 99(f)

nname: 12
n 12(None)[]:
	i: 0(loop)
	o: 19(for), 103(AF)

nname: 0
n 0(None)[self.conflict_list = []
]:
	i: 
	o: 12(loop), 104(AL)

nname: 104
n 104(None)[]:
	i: 0(AL), 12(AF), 59(JA), 19(f), 95()
	o: 

nname: 95
n 95(None)[continue
]:
	i: 31(f)
	o: 104()

nname: 59
n 59(None)[self.conflict_list.append(current_elem)
self.in_conflict_rec.extend(rec_list)
]:
	i: 31(t)
	o: 104(JA)

nname: 31
n 31(rec_list)[rec_list = current_elem.getInvalidRecordingList(self.rec, True)
]:
	i: 19(t)
	o: 59(t), 95(f)

nname: 19
n 19(current_elem.recording_list)[for current_elem in chronological_list:
]:
	i: 12(for)
	o: 31(t), 104(f)

nname: 12
n 12(None)[]:
	i: 0(loop)
	o: 19(for), 104(AF)

nname: 0
n 0(None)[self.conflict_list = []
]:
	i: 
	o: 12(loop), 104(AL)

nname: 19
n 19(None)[for current_elem in chronological_list:
	if current_elem.recording_list:
		rec_list = current_elem.getInvalidRecordingList(self.rec, True)
		if rec_list:
			self.conflict_list.append(current_elem)
			self.in_conflict_rec.extend(rec_list)
		else:
			continue
]:
	i: 0(for)
	o: 

nname: 0
n 0(None)[self.conflict_list = []
]:
	i: 
	o: 19(for)

nname: 0
n 0(None)[self.conflict_list = []
for current_elem in chronological_list:
	if current_elem.recording_list:
		rec_list = current_elem.getInvalidRecordingList(self.rec, True)
		if rec_list:
			self.conflict_list.append(current_elem)
			self.in_conflict_rec.extend(rec_list)
		else:
			continue
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76be5ac>}
nname: 201
n 201(None)[self.recording_list_corrupted = False
]:
	i: 165(), 200()
	o: 

nname: 200
n 200(None)[]:
	i: 144(f)
	o: 201()

nname: 165
n 165(None)[self.valid_start_stop_list.append((chronological_elem.stop, self.rec.stop_time))
]:
	i: 144(t)
	o: 201()

nname: 144
n 144(self.rec.stop_time > chronological_elem.stop)[]:
	i: 18(AL), 143()
	o: 165(t), 200(f)

nname: 143
n 143(None)[]:
	i: 33(AF), 131()
	o: 144()

nname: 131
n 131(None)[rec_start_time = chronological_elem.stop
]:
	i: 101(), 130()
	o: 143()

nname: 130
n 130(None)[]:
	i: 86(f)
	o: 131()

nname: 101
n 101(None)[self.valid_start_stop_list.append((rec_start_time, chronological_elem.start))
]:
	i: 86(t)
	o: 131()

nname: 86
n 86(chronological_elem.start > rec_start_time)[]:
	i: 64(), 85()
	o: 101(t), 130(f)

nname: 85
n 85(None)[]:
	i: 43(f)
	o: 86()

nname: 64
n 64(None)[log.critical('Wyrecor ERROR: recording list is CORRUPTED')
]:
	i: 43(t)
	o: 86()

nname: 43
n 43(self.rec not in chronological_elem.recording_list)[for chronological_elem in self.conflict_list:
]:
	i: 33(for)
	o: 64(t), 85(f)

nname: 33
n 33(None)[]:
	i: 18(loop)
	o: 43(for), 143(AF)

nname: 18
n 18(None)[rec_start_time = self.rec.start_time
]:
	i: 9(), 17()
	o: 33(loop), 144(AL)

nname: 17
n 17(None)[]:
	i: 0(t)
	o: 18()

nname: 9
n 9(None)[]:
	i: 0(f)
	o: 18()

nname: 0
n 0(self.conflict_list)[]:
	i: 
	o: 9(f), 17(t)

nname: 144
n 144(None)[if self.rec.stop_time > chronological_elem.stop:
	self.valid_start_stop_list.append((chronological_elem.stop, self.rec.stop_time))
self.recording_list_corrupted = False
]:
	i: 0(AL), 33(AF), 131()
	o: 

nname: 131
n 131(None)[rec_start_time = chronological_elem.stop
]:
	i: 43()
	o: 144()

nname: 43
n 43(None)[for chronological_elem in self.conflict_list:
if self.rec not in chronological_elem.recording_list:
	log.critical('Wyrecor ERROR: recording list is CORRUPTED')
if chronological_elem.start > rec_start_time:
	self.valid_start_stop_list.append((rec_start_time, chronological_elem.start))
]:
	i: 33(for)
	o: 131()

nname: 33
n 33(None)[]:
	i: 0(loop)
	o: 43(for), 144(AF)

nname: 0
n 0(None)[if not self.conflict_list:
	pass
rec_start_time = self.rec.start_time
]:
	i: 
	o: 33(loop), 144(AL)

nname: 144
n 144(None)[if self.rec.stop_time > chronological_elem.stop:
	self.valid_start_stop_list.append((chronological_elem.stop, self.rec.stop_time))
self.recording_list_corrupted = False
]:
	i: 0(AL), 33(AF), 43()
	o: 

nname: 43
n 43(None)[for chronological_elem in self.conflict_list:
if self.rec not in chronological_elem.recording_list:
	log.critical('Wyrecor ERROR: recording list is CORRUPTED')
if chronological_elem.start > rec_start_time:
	self.valid_start_stop_list.append((rec_start_time, chronological_elem.start))
rec_start_time = chronological_elem.stop
]:
	i: 33(for)
	o: 144()

nname: 33
n 33(None)[]:
	i: 0(loop)
	o: 43(for), 144(AF)

nname: 0
n 0(None)[if not self.conflict_list:
	pass
rec_start_time = self.rec.start_time
]:
	i: 
	o: 33(loop), 144(AL)

self.nodes: {0: <unpyclib.structure.node instance at 0xb76c7b4c>, 33: <unpyclib.structure.node instance at 0xb76be9ac>, 43: <unpyclib.structure.node instance at 0xb76c76cc>, 144: <unpyclib.structure.node instance at 0xb76c76ec>}
nname: 0
n 0(None)[return self.in_conflict_rec
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76b8e8c>}
nname: 54
n 54(None)[return self.rec.start_time >= self.valid_start_stop_list[0][0]
]:
	i: 45(), 53()
	o: 

nname: 53
n 53(None)[]:
	i: 36(t)
	o: 54()

nname: 45
n 45(None)[return False
]:
	i: 36(f)
	o: 54()

nname: 36
n 36(self.valid_start_stop_list)[]:
	i: 27(), 35()
	o: 45(f), 53(t)

nname: 35
n 35(None)[]:
	i: 18(t)
	o: 36()

nname: 27
n 27(None)[return False
]:
	i: 18(f)
	o: 36()

nname: 18
n 18(self.rec)[]:
	i: 9(), 17()
	o: 27(f), 35(t)

nname: 17
n 17(None)[]:
	i: 0(t)
	o: 18()

nname: 9
n 9(None)[return True
]:
	i: 0(f)
	o: 18()

nname: 0
n 0(self.conflict_list)[]:
	i: 
	o: 9(f), 17(t)

nname: 36
n 36(None)[if not self.valid_start_stop_list:
	return False
return self.rec.start_time >= self.valid_start_stop_list[0][0]
]:
	i: 0()
	o: 

nname: 0
n 0(None)[if not self.conflict_list:
	return True
if not self.rec:
	return False
]:
	i: 
	o: 36()

nname: 0
n 0(None)[if not self.conflict_list:
	return True
if not self.rec:
	return False
if not self.valid_start_stop_list:
	return False
return self.rec.start_time >= self.valid_start_stop_list[0][0]
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76c7fec>}
nname: 135
n 135(None)[s += '\n    valid time list:'
s += repr(self.valid_start_stop_list)
return s
]:
	i: 89(AL), 134()
	o: 

nname: 134
n 134(None)[]:
	i: 102(AF), 112()
	o: 135()

nname: 112
n 112(None)[for elem in self.conflict_list:
s += elem.__str__()
]:
	i: 102(for)
	o: 134()

nname: 102
n 102(None)[]:
	i: 89(loop)
	o: 112(for), 134(AF)

nname: 89
n 89(None)[s += '\n    conflict list:'
]:
	i: 64(), 78()
	o: 102(loop), 135(AL)

nname: 78
n 78(None)[s += 'no'
]:
	i: 0(f)
	o: 89()

nname: 64
n 64(None)[s += 'yes'
]:
	i: 0(t)
	o: 89()

nname: 0
n 0(self.recording_list_corrupted)[s = '\n'
s += '\nConflict object description: (for rec= '
s += repr(self.rec_id)
s += ')'
s += '\n    recording_list corrupted:'
]:
	i: 
	o: 64(t), 78(f)

nname: 134
n 134(None)[s += '\n    valid time list:'
s += repr(self.valid_start_stop_list)
return s
]:
	i: 102()
	o: 

nname: 102
n 102(None)[for elem in self.conflict_list:
	s += elem.__str__()
]:
	i: 0(loop)
	o: 134()

nname: 0
n 0(None)[s = '\n'
s += '\nConflict object description: (for rec= '
s += repr(self.rec_id)
s += ')'
s += '\n    recording_list corrupted:'
if self.recording_list_corrupted:
	s += 'yes'
else:
	s += 'no'
s += '\n    conflict list:'
]:
	i: 
	o: 102(loop)

nname: 134
n 134(None)[s += '\n    valid time list:'
s += repr(self.valid_start_stop_list)
return s
]:
	i: 0()
	o: 

nname: 0
n 0(None)[s = '\n'
s += '\nConflict object description: (for rec= '
s += repr(self.rec_id)
s += ')'
s += '\n    recording_list corrupted:'
if self.recording_list_corrupted:
	s += 'yes'
else:
	s += 'no'
s += '\n    conflict list:'
for elem in self.conflict_list:
	s += elem.__str__()
]:
	i: 
	o: 134()

nname: 0
n 0(None)[s = '\n'
s += '\nConflict object description: (for rec= '
s += repr(self.rec_id)
s += ')'
s += '\n    recording_list corrupted:'
if self.recording_list_corrupted:
	s += 'yes'
else:
	s += 'no'
s += '\n    conflict list:'
for elem in self.conflict_list:
	s += elem.__str__()
s += '\n    valid time list:'
s += repr(self.valid_start_stop_list)
return s
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76c7e4c>}
nname: 6
n 6(None)[__doc__ = ' object that build the list of recording in conflict.\n    conflict should happen only on new recording that have id = 0\n    \n    it is used to find the valid time range period for the recording of\n    id = rec_id\n    '
def __init__(self, chronological_list, rec):
	self.conflict_list = []
	self.in_conflict_rec = []
	self.valid_start_stop_list = []
	self.rec = rec
	self.recording_list_corrupted = True
	if rec == None:
		log.error('can not work without specifying a recording')
		return None
	self._InConflictRecording__computeConflictList(chronological_list)
	self._InConflictRecording__computeValidStartStopTime()
	return None

def _InConflictRecording__computeConflictList(self, chronological_list):
	self.conflict_list = []
	for current_elem in chronological_list:
		if current_elem.recording_list:
			rec_list = current_elem.getInvalidRecordingList(self.rec, True)
			if rec_list:
				self.conflict_list.append(current_elem)
				self.in_conflict_rec.extend(rec_list)
			else:
				continue

def _InConflictRecording__computeValidStartStopTime(self):
	if not self.conflict_list:
		pass
	rec_start_time = self.rec.start_time

def getAllRecInConflict(self):
	return self.in_conflict_rec

def isStartTimeValid(self):
	if not self.conflict_list:
		return True
	if not self.rec:
		return False
	if not self.valid_start_stop_list:
		return False
	return self.rec.start_time >= self.valid_start_stop_list[0][0]

def __str__(self):
	s = '\n'
	s += '\nConflict object description: (for rec= '
	s += repr(self.rec_id)
	s += ')'
	s += '\n    recording_list corrupted:'
	if self.recording_list_corrupted:
		s += 'yes'
	else:
		s += 'no'
	s += '\n    conflict list:'
	for elem in self.conflict_list:
		s += elem.__str__()
	s += '\n    valid time list:'
	s += repr(self.valid_start_stop_list)
	return s

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb76b8d6c>}
nname: 0
n 0(None)[from config import config
import copy
from recording import RECORDING_TYPE_IS_LIVE
from logger import log
class ChronologicalElement(object):
	__doc__ = ' element used by ChronologicalRecordingList.\n\n    a chronological element is defined by:\n        a start time\n        a stop time\n        the list of simultaneous recording during this laps of time\n    \n    this element is used to store the recordings (self.recording_list) that should be played\n    at the same time from self.start to self.stop.\n    \n    \n    it can compute the list of recording that are in conflict.\n    '
	def __init__(self, are_services_playable, start=-2147483640, stop=0, rec_list=None, next_elem=None, previous_elem=None):
		self.start = start
		self.stop = stop
		self.are_services_playable = are_services_playable
		if not rec_list:
			self.recording_list = []
		else:
			self.recording_list = rec_list

	def getCopy(self):
		return ChronologicalElement(self.are_services_playable, copy.copy(self.start), copy.copy(self.stop), copy.copy(self.recording_list))

	def getInvalidRecordingList(self, first_rec=None, loop=False):
		invalid_rec_list = []
		found_list = {}
		if first_rec in self.recording_list:
			self.recording_list.remove(first_rec)
			self.recording_list.insert(0, first_rec)

	def __str__(self):
		s = ''
		s += '\n start ' + str(self.start)
		s += '\n stop ' + str(self.stop)



class ChronologicalRecordingList(object):
	__doc__ = ' used to arrange a recording list in a list of ChronologicalElement.\n    a logical structure is used to store recording so that conflict checking and resolving\n    are easier. The recordings are stored in a continuous list of chronological element.\n    \n    the goal is to check simultaneous recording.\n    \n    usage:\n    give the list by constructor\n    update the list by orderRecording\n    add recording by insertRecording\n    \n    get result getConflict\n    '
	def __init__(self, recording_launcher, not_ordered_list=None):
		self.elemList = None
		self.recording_launcher = recording_launcher
		self.orderRecording(not_ordered_list)
		return None

	def orderRecording(self, list_to_order):
		self.elemList = [ChronologicalElement(self.recording_launcher.AreServicesPlayable)]
		if list_to_order:
			for rec in list_to_order:
				self.insertRecording(rec)

	def insertRecording(self, rec):
		rec.deviceid = 0
		conflict_list = []
		for current_elem in self.elemList:
			if (current_elem.start < rec.stop_time or rec.stop_time == 0) and (current_elem.stop > rec.start_time or current_elem.stop == 0):
				conflict_list.append(current_elem)
				continue
			_POP_TOP pass
		if conflict_list:
			self._ChronologicalRecordingList__checkBegin(conflict_list[0], rec)
			self._ChronologicalRecordingList__checkEnd(conflict_list[-1], rec)
			self._ChronologicalRecordingList__joinList(conflict_list, rec)
		else:
			log.critical('SHOULD NOT HAPPEN CHECK ALGO')
			self.elemList.recording_list.append(rec)

	def getConflict(self, rec):
		conflict = InConflictRecording(self.elemList, rec)
		if conflict.conflict_list:
			return conflict
		return None

	def __str__(self):
		s = 'THE chronological list'
		for current_elem in self.elemList:
			s += current_elem.__str__()
		return s

	def _ChronologicalRecordingList__checkBegin(self, elem, rec):
		if elem.start > rec.start_time:
			new_elem = ChronologicalElement(self.recording_launcher.AreServicesPlayable, rec.start_time, elem.start, [rec])
			self.elemList.insert(self.elemList.index(elem), new_elem)
		else:
			if elem.start < rec.start_time:
				new_elem = elem.getCopy()
				new_elem.stop = rec.start_time
				elem.start = new_elem.stop
				self.elemList.insert(self.elemList.index(elem), new_elem)

	def _ChronologicalRecordingList__checkEnd(self, elem, rec):
		if elem.stop == 0 and rec.stop_time == 0:
			pass
		if elem.stop > rec.stop_time or elem.stop == 0:
			new_elem = elem.getCopy()
			new_elem.start = rec.stop_time
			elem.stop = new_elem.start
			self.elemList.insert(self.elemList.index(elem) + 1, new_elem)
		else:
			if elem.stop < rec.stop_time or rec.stop_time == 0:
				new_elem = ChronologicalElement(self.recording_launcher.AreServicesPlayable, elem.stop, rec.stop_time, [rec])
				self.elemList.insert(self.elemList.index(elem) + 1, new_elem)

	def _ChronologicalRecordingList__joinList(self, list, rec):
		previous_elem = None
		for elem in list:
			elem.recording_list.append(rec)
			if previous_elem:
				if previous_elem.stop < elem.start:
					new_elem = ChronologicalElement(self.recording_launcher.AreServicesPlayable, previous_elem.stop, elem.start, [rec])
					self.elemList.insert(self.elemList.index(elem), new_elem)
			previous_elem = elem
		return None



class InConflictRecording(object):
	__doc__ = ' object that build the list of recording in conflict.\n    conflict should happen only on new recording that have id = 0\n    \n    it is used to find the valid time range period for the recording of\n    id = rec_id\n    '
	def __init__(self, chronological_list, rec):
		self.conflict_list = []
		self.in_conflict_rec = []
		self.valid_start_stop_list = []
		self.rec = rec
		self.recording_list_corrupted = True
		if rec == None:
			log.error('can not work without specifying a recording')
			return None
		self._InConflictRecording__computeConflictList(chronological_list)
		self._InConflictRecording__computeValidStartStopTime()
		return None

	def _InConflictRecording__computeConflictList(self, chronological_list):
		self.conflict_list = []
		for current_elem in chronological_list:
			if current_elem.recording_list:
				rec_list = current_elem.getInvalidRecordingList(self.rec, True)
				if rec_list:
					self.conflict_list.append(current_elem)
					self.in_conflict_rec.extend(rec_list)
				else:
					continue

	def _InConflictRecording__computeValidStartStopTime(self):
		if not self.conflict_list:
			pass
		rec_start_time = self.rec.start_time

	def getAllRecInConflict(self):
		return self.in_conflict_rec

	def isStartTimeValid(self):
		if not self.conflict_list:
			return True
		if not self.rec:
			return False
		if not self.valid_start_stop_list:
			return False
		return self.rec.start_time >= self.valid_start_stop_list[0][0]

	def __str__(self):
		s = '\n'
		s += '\nConflict object description: (for rec= '
		s += repr(self.rec_id)
		s += ')'
		s += '\n    recording_list corrupted:'
		if self.recording_list_corrupted:
			s += 'yes'
		else:
			s += 'no'
		s += '\n    conflict list:'
		for elem in self.conflict_list:
			s += elem.__str__()
		s += '\n    valid time list:'
		s += repr(self.valid_start_stop_list)
		return s



]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76b1dcc>}
from config import config
import copy
from recording import RECORDING_TYPE_IS_LIVE
from logger import log
class ChronologicalElement(object):
	__doc__ = ' element used by ChronologicalRecordingList.\n\n    a chronological element is defined by:\n        a start time\n        a stop time\n        the list of simultaneous recording during this laps of time\n    \n    this element is used to store the recordings (self.recording_list) that should be played\n    at the same time from self.start to self.stop.\n    \n    \n    it can compute the list of recording that are in conflict.\n    '
	def __init__(self, are_services_playable, start=-2147483640, stop=0, rec_list=None, next_elem=None, previous_elem=None):
		self.start = start
		self.stop = stop
		self.are_services_playable = are_services_playable
		if not rec_list:
			self.recording_list = []
		else:
			self.recording_list = rec_list

	def getCopy(self):
		return ChronologicalElement(self.are_services_playable, copy.copy(self.start), copy.copy(self.stop), copy.copy(self.recording_list))

	def getInvalidRecordingList(self, first_rec=None, loop=False):
		invalid_rec_list = []
		found_list = {}
		if first_rec in self.recording_list:
			self.recording_list.remove(first_rec)
			self.recording_list.insert(0, first_rec)

	def __str__(self):
		s = ''
		s += '\n start ' + str(self.start)
		s += '\n stop ' + str(self.stop)



class ChronologicalRecordingList(object):
	__doc__ = ' used to arrange a recording list in a list of ChronologicalElement.\n    a logical structure is used to store recording so that conflict checking and resolving\n    are easier. The recordings are stored in a continuous list of chronological element.\n    \n    the goal is to check simultaneous recording.\n    \n    usage:\n    give the list by constructor\n    update the list by orderRecording\n    add recording by insertRecording\n    \n    get result getConflict\n    '
	def __init__(self, recording_launcher, not_ordered_list=None):
		self.elemList = None
		self.recording_launcher = recording_launcher
		self.orderRecording(not_ordered_list)
		return None

	def orderRecording(self, list_to_order):
		self.elemList = [ChronologicalElement(self.recording_launcher.AreServicesPlayable)]
		if list_to_order:
			for rec in list_to_order:
				self.insertRecording(rec)

	def insertRecording(self, rec):
		rec.deviceid = 0
		conflict_list = []
		for current_elem in self.elemList:
			if (current_elem.start < rec.stop_time or rec.stop_time == 0) and (current_elem.stop > rec.start_time or current_elem.stop == 0):
				conflict_list.append(current_elem)
				continue
			_POP_TOP pass
		if conflict_list:
			self._ChronologicalRecordingList__checkBegin(conflict_list[0], rec)
			self._ChronologicalRecordingList__checkEnd(conflict_list[-1], rec)
			self._ChronologicalRecordingList__joinList(conflict_list, rec)
		else:
			log.critical('SHOULD NOT HAPPEN CHECK ALGO')
			self.elemList.recording_list.append(rec)

	def getConflict(self, rec):
		conflict = InConflictRecording(self.elemList, rec)
		if conflict.conflict_list:
			return conflict
		return None

	def __str__(self):
		s = 'THE chronological list'
		for current_elem in self.elemList:
			s += current_elem.__str__()
		return s

	def _ChronologicalRecordingList__checkBegin(self, elem, rec):
		if elem.start > rec.start_time:
			new_elem = ChronologicalElement(self.recording_launcher.AreServicesPlayable, rec.start_time, elem.start, [rec])
			self.elemList.insert(self.elemList.index(elem), new_elem)
		else:
			if elem.start < rec.start_time:
				new_elem = elem.getCopy()
				new_elem.stop = rec.start_time
				elem.start = new_elem.stop
				self.elemList.insert(self.elemList.index(elem), new_elem)

	def _ChronologicalRecordingList__checkEnd(self, elem, rec):
		if elem.stop == 0 and rec.stop_time == 0:
			pass
		if elem.stop > rec.stop_time or elem.stop == 0:
			new_elem = elem.getCopy()
			new_elem.start = rec.stop_time
			elem.stop = new_elem.start
			self.elemList.insert(self.elemList.index(elem) + 1, new_elem)
		else:
			if elem.stop < rec.stop_time or rec.stop_time == 0:
				new_elem = ChronologicalElement(self.recording_launcher.AreServicesPlayable, elem.stop, rec.stop_time, [rec])
				self.elemList.insert(self.elemList.index(elem) + 1, new_elem)

	def _ChronologicalRecordingList__joinList(self, list, rec):
		previous_elem = None
		for elem in list:
			elem.recording_list.append(rec)
			if previous_elem:
				if previous_elem.stop < elem.start:
					new_elem = ChronologicalElement(self.recording_launcher.AreServicesPlayable, previous_elem.stop, elem.start, [rec])
					self.elemList.insert(self.elemList.index(elem), new_elem)
			previous_elem = elem
		return None



class InConflictRecording(object):
	__doc__ = ' object that build the list of recording in conflict.\n    conflict should happen only on new recording that have id = 0\n    \n    it is used to find the valid time range period for the recording of\n    id = rec_id\n    '
	def __init__(self, chronological_list, rec):
		self.conflict_list = []
		self.in_conflict_rec = []
		self.valid_start_stop_list = []
		self.rec = rec
		self.recording_list_corrupted = True
		if rec == None:
			log.error('can not work without specifying a recording')
			return None
		self._InConflictRecording__computeConflictList(chronological_list)
		self._InConflictRecording__computeValidStartStopTime()
		return None

	def _InConflictRecording__computeConflictList(self, chronological_list):
		self.conflict_list = []
		for current_elem in chronological_list:
			if current_elem.recording_list:
				rec_list = current_elem.getInvalidRecordingList(self.rec, True)
				if rec_list:
					self.conflict_list.append(current_elem)
					self.in_conflict_rec.extend(rec_list)
				else:
					continue

	def _InConflictRecording__computeValidStartStopTime(self):
		if not self.conflict_list:
			pass
		rec_start_time = self.rec.start_time

	def getAllRecInConflict(self):
		return self.in_conflict_rec

	def isStartTimeValid(self):
		if not self.conflict_list:
			return True
		if not self.rec:
			return False
		if not self.valid_start_stop_list:
			return False
		return self.rec.start_time >= self.valid_start_stop_list[0][0]

	def __str__(self):
		s = '\n'
		s += '\nConflict object description: (for rec= '
		s += repr(self.rec_id)
		s += ')'
		s += '\n    recording_list corrupted:'
		if self.recording_list_corrupted:
			s += 'yes'
		else:
			s += 'no'
		s += '\n    conflict list:'
		for elem in self.conflict_list:
			s += elem.__str__()
		s += '\n    valid time list:'
		s += repr(self.valid_start_stop_list)
		return s



