# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 266
n 266(None)[return None
]:
	i: 236(AL), 265()
	o: 

nname: 265
n 265(None)[]:
	i: 239(AF), 246()
	o: 266()

nname: 246
n 246(None)[for chunk in iterable:
fp.write(chunk)
]:
	i: 239(for)
	o: 265()

nname: 239
n 239(None)[]:
	i: 236(loop)
	o: 246(for), 265(AF)

nname: 236
n 236(None)[]:
	i: 124(), 167()
	o: 239(loop), 266(AL)

nname: 167
n 167(None)[iterable = cls(skipkeys=skipkeys, ensure_ascii=ensure_ascii, check_circular=check_circular, allow_nan=allow_nan, indent=indent, separators=separators, encoding=encoding, default=default, **kw).iterencode(obj)
]:
	i: 156(), 166()
	o: 236()

nname: 166
n 166(None)[]:
	i: 143(f)
	o: 167()

nname: 156
n 156(None)[cls = JSONEncoder
]:
	i: 143(t)
	o: 167()

nname: 143
n 143(cls is None)[]:
	i: 0&12&25&38&51&64&77&90&103&116(f)
	o: 156(t), 166(f)

nname: 124
n 124(None)[iterable = _default_encoder.iterencode(obj)
]:
	i: 0&12&25&38&51&64&77&90&103&116(t)
	o: 236()

nname: 0&12&25&38&51&64&77&90&103&116
n 0&12&25&38&51&64&77&90&103&116(skipkeys is False and ensure_ascii is True and check_circular is True and allow_nan is True and cls is None and indent is None and separators is None and encoding == 'utf-8' and default is None and not kw)[]:
	i: 
	o: 124(t), 143(f)

nname: 266
n 266(None)[return None
]:
	i: 246()
	o: 

nname: 246
n 246(None)[for chunk in iterable:
	fp.write(chunk)
]:
	i: 236(for)
	o: 266()

nname: 236
n 236(None)[]:
	i: 124(), 143()
	o: 246(for)

nname: 143
n 143(None)[if cls is None:
	cls = JSONEncoder
iterable = cls(skipkeys=skipkeys, ensure_ascii=ensure_ascii, check_circular=check_circular, allow_nan=allow_nan, indent=indent, separators=separators, encoding=encoding, default=default, **kw).iterencode(obj)
]:
	i: 0&12&25&38&51&64&77&90&103&116(f)
	o: 236()

nname: 124
n 124(None)[iterable = _default_encoder.iterencode(obj)
]:
	i: 0&12&25&38&51&64&77&90&103&116(t)
	o: 236()

nname: 0&12&25&38&51&64&77&90&103&116
n 0&12&25&38&51&64&77&90&103&116(skipkeys is False and ensure_ascii is True and check_circular is True and allow_nan is True and cls is None and indent is None and separators is None and encoding == 'utf-8' and default is None and not kw)[]:
	i: 
	o: 124(t), 143(f)

nname: 266
n 266(None)[return None
]:
	i: 0&12&25&38&51&64&77&90&103&116()
	o: 

nname: 0&12&25&38&51&64&77&90&103&116
n 0&12&25&38&51&64&77&90&103&116(None)[if skipkeys is False and ensure_ascii is True and check_circular is True and allow_nan is True and cls is None and indent is None and separators is None and encoding == 'utf-8' and default is None and not kw:
	iterable = _default_encoder.iterencode(obj)
else:
	if cls is None:
		cls = JSONEncoder
	iterable = cls(skipkeys=skipkeys, ensure_ascii=ensure_ascii, check_circular=check_circular, allow_nan=allow_nan, indent=indent, separators=separators, encoding=encoding, default=default, **kw).iterencode(obj)
for chunk in iterable:
	fp.write(chunk)
]:
	i: 
	o: 266()

nname: 0&12&25&38&51&64&77&90&103&116
n 0&12&25&38&51&64&77&90&103&116(None)[if skipkeys is False and ensure_ascii is True and check_circular is True and allow_nan is True and cls is None and indent is None and separators is None and encoding == 'utf-8' and default is None and not kw:
	iterable = _default_encoder.iterencode(obj)
else:
	if cls is None:
		cls = JSONEncoder
	iterable = cls(skipkeys=skipkeys, ensure_ascii=ensure_ascii, check_circular=check_circular, allow_nan=allow_nan, indent=indent, separators=separators, encoding=encoding, default=default, **kw).iterencode(obj)
for chunk in iterable:
	fp.write(chunk)
return None
]:
	i: 
	o: 

self.nodes: {'0&12&25&38&51&64&77&90&103&116': <unpyclib.structure.node instance at 0xb772a4ac>}
nname: 165
n 165(None)[return cls(skipkeys=skipkeys, ensure_ascii=ensure_ascii, check_circular=check_circular, allow_nan=allow_nan, indent=indent, separators=separators, encoding=encoding, default=default, **kw).encode(obj)
]:
	i: 154(), 164()
	o: 

nname: 164
n 164(None)[]:
	i: 142(f)
	o: 165()

nname: 154
n 154(None)[cls = JSONEncoder
]:
	i: 142(t)
	o: 165()

nname: 142
n 142(cls is None)[]:
	i: 124(), 141()
	o: 154(t), 164(f)

nname: 141
n 141(None)[]:
	i: 0&12&25&38&51&64&77&90&103&116(f)
	o: 142()

nname: 124
n 124(None)[return _default_encoder.encode(obj)
]:
	i: 0&12&25&38&51&64&77&90&103&116(t)
	o: 142()

nname: 0&12&25&38&51&64&77&90&103&116
n 0&12&25&38&51&64&77&90&103&116(skipkeys is False and ensure_ascii is True and check_circular is True and allow_nan is True and cls is None and indent is None and separators is None and encoding == 'utf-8' and default is None and not kw)[]:
	i: 
	o: 124(t), 141(f)

nname: 0&12&25&38&51&64&77&90&103&116
n 0&12&25&38&51&64&77&90&103&116(None)[if skipkeys is False and ensure_ascii is True and check_circular is True and allow_nan is True and cls is None and indent is None and separators is None and encoding == 'utf-8' and default is None and not kw:
	return _default_encoder.encode(obj)
if cls is None:
	cls = JSONEncoder
return cls(skipkeys=skipkeys, ensure_ascii=ensure_ascii, check_circular=check_circular, allow_nan=allow_nan, indent=indent, separators=separators, encoding=encoding, default=default, **kw).encode(obj)
]:
	i: 
	o: 

self.nodes: {'0&12&25&38&51&64&77&90&103&116': <unpyclib.structure.node instance at 0xb772ad8c>}
nname: 0
n 0(None)[return loads(fp.read(), encoding=encoding, cls=cls, object_hook=object_hook, parse_float=parse_float, parse_int=parse_int, parse_constant=parse_constant, **kw)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb771da4c>}
nname: 234
n 234(None)[return cls(encoding=encoding, **kw).decode(s)
]:
	i: 219(), 233()
	o: 

nname: 233
n 233(None)[]:
	i: 207(f)
	o: 234()

nname: 219
n 219(None)[kw['parse_constant'] = parse_constant
]:
	i: 207(t)
	o: 234()

nname: 207
n 207(parse_constant is not None)[]:
	i: 192(), 206()
	o: 219(t), 233(f)

nname: 206
n 206(None)[]:
	i: 180(f)
	o: 207()

nname: 192
n 192(None)[kw['parse_int'] = parse_int
]:
	i: 180(t)
	o: 207()

nname: 180
n 180(parse_int is not None)[]:
	i: 165(), 179()
	o: 192(t), 206(f)

nname: 179
n 179(None)[]:
	i: 153(f)
	o: 180()

nname: 165
n 165(None)[kw['parse_float'] = parse_float
]:
	i: 153(t)
	o: 180()

nname: 153
n 153(parse_float is not None)[]:
	i: 138(), 152()
	o: 165(t), 179(f)

nname: 152
n 152(None)[]:
	i: 126(f)
	o: 153()

nname: 138
n 138(None)[kw['object_hook'] = object_hook
]:
	i: 126(t)
	o: 153()

nname: 126
n 126(object_hook is not None)[]:
	i: 115(), 125()
	o: 138(t), 152(f)

nname: 125
n 125(None)[]:
	i: 103(f)
	o: 126()

nname: 115
n 115(None)[cls = JSONDecoder
]:
	i: 103(t)
	o: 126()

nname: 103
n 103(cls is None)[]:
	i: 85(), 102()
	o: 115(t), 125(f)

nname: 102
n 102(None)[]:
	i: 0&12&25&38&51&64&77(f)
	o: 103()

nname: 85
n 85(None)[return _default_decoder.decode(s)
]:
	i: 0&12&25&38&51&64&77(t)
	o: 103()

nname: 0&12&25&38&51&64&77
n 0&12&25&38&51&64&77(cls is None and encoding is None and object_hook is None and parse_int is None and parse_float is None and parse_constant is None and not kw)[]:
	i: 
	o: 85(t), 102(f)

nname: 207
n 207(None)[if parse_constant is not None:
	kw['parse_constant'] = parse_constant
return cls(encoding=encoding, **kw).decode(s)
]:
	i: 153()
	o: 

nname: 153
n 153(None)[if parse_float is not None:
	kw['parse_float'] = parse_float
if parse_int is not None:
	kw['parse_int'] = parse_int
]:
	i: 0&12&25&38&51&64&77()
	o: 207()

nname: 0&12&25&38&51&64&77
n 0&12&25&38&51&64&77(None)[if cls is None and encoding is None and object_hook is None and parse_int is None and parse_float is None and parse_constant is None and not kw:
	return _default_decoder.decode(s)
if cls is None:
	cls = JSONDecoder
if object_hook is not None:
	kw['object_hook'] = object_hook
]:
	i: 
	o: 153()

nname: 0&12&25&38&51&64&77
n 0&12&25&38&51&64&77(None)[if cls is None and encoding is None and object_hook is None and parse_int is None and parse_float is None and parse_constant is None and not kw:
	return _default_decoder.decode(s)
if cls is None:
	cls = JSONDecoder
if object_hook is not None:
	kw['object_hook'] = object_hook
if parse_float is not None:
	kw['parse_float'] = parse_float
if parse_int is not None:
	kw['parse_int'] = parse_int
if parse_constant is not None:
	kw['parse_constant'] = parse_constant
return cls(encoding=encoding, **kw).decode(s)
]:
	i: 
	o: 

self.nodes: {'0&12&25&38&51&64&77': <unpyclib.structure.node instance at 0xb772a10c>}
nname: 0
n 0(None)[__doc__ = 'A simple, fast, extensible JSON encoder and decoder\n\nJSON (JavaScript Object Notation) <http://json.org> is a subset of\nJavaScript syntax (ECMA-262 3rd edition) used as a lightweight data\ninterchange format.\n\nsimplejson exposes an API familiar to uses of the standard library\nmarshal and pickle modules.\n\nEncoding basic Python object hierarchies::\n\n    >>> import simplejson\n    >>> simplejson.dumps([\'foo\', {\'bar\': (\'baz\', None, 1.0, 2)}])\n    \'["foo", {"bar": ["baz", null, 1.0, 2]}]\'\n    >>> print simplejson.dumps("\\"foo\\bar")\n    "\\"foo\\bar"\n    >>> print simplejson.dumps(u\'\\u1234\')\n    "\\u1234"\n    >>> print simplejson.dumps(\'\\\\\')\n    "\\\\"\n    >>> print simplejson.dumps({"c": 0, "b": 0, "a": 0}, sort_keys=True)\n    {"a": 0, "b": 0, "c": 0}\n    >>> from StringIO import StringIO\n    >>> io = StringIO()\n    >>> simplejson.dump([\'streaming API\'], io)\n    >>> io.getvalue()\n    \'["streaming API"]\'\n\nCompact encoding::\n\n    >>> import simplejson\n    >>> compact = simplejson.dumps([1,2,3,{\'4\': 5, \'6\': 7}], separators=(\',\',\':\'))\n    >>> # Can\'t assume dict ordering\n    >>> compact in (\'[1,2,3,{"4":5,"6":7}]\', \'[1,2,3,{"6":7,"4":5}]\')\n    True\n\nPretty printing (using repr() because of extraneous whitespace in the output)::\n\n    >>> import simplejson\n    >>> print repr(simplejson.dumps({\'4\': 5, \'6\': 7}, sort_keys=True, indent=4))\n    \'{\\n    "4": 5, \\n    "6": 7\\n}\'\n\nDecoding JSON::\n\n    >>> import simplejson\n    >>> simplejson.loads(\'["foo", {"bar":["baz", null, 1.0, 2]}]\') == ["foo", {"bar":["baz", None, 1.0, 2]}]\n    True\n    >>> simplejson.loads(\'"\\\\"foo\\\\bar"\') == \'"foo\\x08ar\'\n    True\n    >>> from StringIO import StringIO\n    >>> io = StringIO(\'["streaming API"]\')\n    >>> simplejson.load(io) == ["streaming API"]\n    True\n\nSpecializing JSON object decoding::\n\n    >>> import simplejson\n    >>> def as_complex(dct):\n    ...     if \'__complex__\' in dct:\n    ...         return complex(dct[\'real\'], dct[\'imag\'])\n    ...     return dct\n    ...\n    >>> simplejson.loads(\'{"__complex__": true, "real": 1, "imag": 2}\',\n    ...     object_hook=as_complex)\n    (1+2j)\n    >>> from decimal import Decimal\n    >>> simplejson.loads(\'1.1\', parse_float=Decimal) == Decimal("1.1")\n    True\n\nExtending JSONEncoder::\n\n    >>> import simplejson\n    >>> class ComplexEncoder(simplejson.JSONEncoder):\n    ...     def default(self, obj):\n    ...         if isinstance(obj, complex):\n    ...             return [obj.real, obj.imag]\n    ...         return simplejson.JSONEncoder.default(self, obj)\n    ...\n    >>> dumps(2 + 1j, cls=ComplexEncoder)\n    \'[2.0, 1.0]\'\n    >>> ComplexEncoder().encode(2 + 1j)\n    \'[2.0, 1.0]\'\n    >>> \'\'.join(ComplexEncoder().iterencode(2 + 1j))\n    \'[2.0, 1.0]\'\n\n\nUsing simplejson from the shell to validate and\npretty-print::\n\n    $ echo \'{"json":"obj"}\' | python -msimplejson.tool\n    {\n        "json": "obj"\n    }\n    $ echo \'{ 1.2:3.4}\' | python -msimplejson.tool\n    Expecting property name: line 1 column 2 (char 2)\n'
__version__ = '2.0.4'
__all__ = ['dump', 'dumps', 'load', 'loads', 'JSONDecoder', 'JSONEncoder']
from decoder import JSONDecoder
from encoder import JSONEncoder
_default_encoder = JSONEncoder(skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, indent=None, separators=None, encoding='utf-8', default=None)
def dump(obj, fp, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, encoding='utf-8', default=None, **kw):
	if skipkeys is False and ensure_ascii is True and check_circular is True and allow_nan is True and cls is None and indent is None and separators is None and encoding == 'utf-8' and default is None and not kw:
		iterable = _default_encoder.iterencode(obj)
	else:
		if cls is None:
			cls = JSONEncoder
		iterable = cls(skipkeys=skipkeys, ensure_ascii=ensure_ascii, check_circular=check_circular, allow_nan=allow_nan, indent=indent, separators=separators, encoding=encoding, default=default, **kw).iterencode(obj)
	for chunk in iterable:
		fp.write(chunk)
	return None

def dumps(obj, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, encoding='utf-8', default=None, **kw):
	if skipkeys is False and ensure_ascii is True and check_circular is True and allow_nan is True and cls is None and indent is None and separators is None and encoding == 'utf-8' and default is None and not kw:
		return _default_encoder.encode(obj)
	if cls is None:
		cls = JSONEncoder
	return cls(skipkeys=skipkeys, ensure_ascii=ensure_ascii, check_circular=check_circular, allow_nan=allow_nan, indent=indent, separators=separators, encoding=encoding, default=default, **kw).encode(obj)

_default_decoder = JSONDecoder(encoding=None, object_hook=None)
def load(fp, encoding=None, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, **kw):
	return loads(fp.read(), encoding=encoding, cls=cls, object_hook=object_hook, parse_float=parse_float, parse_int=parse_int, parse_constant=parse_constant, **kw)

def loads(s, encoding=None, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, **kw):
	if cls is None and encoding is None and object_hook is None and parse_int is None and parse_float is None and parse_constant is None and not kw:
		return _default_decoder.decode(s)
	if cls is None:
		cls = JSONDecoder
	if object_hook is not None:
		kw['object_hook'] = object_hook
	if parse_float is not None:
		kw['parse_float'] = parse_float
	if parse_int is not None:
		kw['parse_int'] = parse_int
	if parse_constant is not None:
		kw['parse_constant'] = parse_constant
	return cls(encoding=encoding, **kw).decode(s)

]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7716cac>}
__doc__ = 'A simple, fast, extensible JSON encoder and decoder\n\nJSON (JavaScript Object Notation) <http://json.org> is a subset of\nJavaScript syntax (ECMA-262 3rd edition) used as a lightweight data\ninterchange format.\n\nsimplejson exposes an API familiar to uses of the standard library\nmarshal and pickle modules.\n\nEncoding basic Python object hierarchies::\n\n    >>> import simplejson\n    >>> simplejson.dumps([\'foo\', {\'bar\': (\'baz\', None, 1.0, 2)}])\n    \'["foo", {"bar": ["baz", null, 1.0, 2]}]\'\n    >>> print simplejson.dumps("\\"foo\\bar")\n    "\\"foo\\bar"\n    >>> print simplejson.dumps(u\'\\u1234\')\n    "\\u1234"\n    >>> print simplejson.dumps(\'\\\\\')\n    "\\\\"\n    >>> print simplejson.dumps({"c": 0, "b": 0, "a": 0}, sort_keys=True)\n    {"a": 0, "b": 0, "c": 0}\n    >>> from StringIO import StringIO\n    >>> io = StringIO()\n    >>> simplejson.dump([\'streaming API\'], io)\n    >>> io.getvalue()\n    \'["streaming API"]\'\n\nCompact encoding::\n\n    >>> import simplejson\n    >>> compact = simplejson.dumps([1,2,3,{\'4\': 5, \'6\': 7}], separators=(\',\',\':\'))\n    >>> # Can\'t assume dict ordering\n    >>> compact in (\'[1,2,3,{"4":5,"6":7}]\', \'[1,2,3,{"6":7,"4":5}]\')\n    True\n\nPretty printing (using repr() because of extraneous whitespace in the output)::\n\n    >>> import simplejson\n    >>> print repr(simplejson.dumps({\'4\': 5, \'6\': 7}, sort_keys=True, indent=4))\n    \'{\\n    "4": 5, \\n    "6": 7\\n}\'\n\nDecoding JSON::\n\n    >>> import simplejson\n    >>> simplejson.loads(\'["foo", {"bar":["baz", null, 1.0, 2]}]\') == ["foo", {"bar":["baz", None, 1.0, 2]}]\n    True\n    >>> simplejson.loads(\'"\\\\"foo\\\\bar"\') == \'"foo\\x08ar\'\n    True\n    >>> from StringIO import StringIO\n    >>> io = StringIO(\'["streaming API"]\')\n    >>> simplejson.load(io) == ["streaming API"]\n    True\n\nSpecializing JSON object decoding::\n\n    >>> import simplejson\n    >>> def as_complex(dct):\n    ...     if \'__complex__\' in dct:\n    ...         return complex(dct[\'real\'], dct[\'imag\'])\n    ...     return dct\n    ...\n    >>> simplejson.loads(\'{"__complex__": true, "real": 1, "imag": 2}\',\n    ...     object_hook=as_complex)\n    (1+2j)\n    >>> from decimal import Decimal\n    >>> simplejson.loads(\'1.1\', parse_float=Decimal) == Decimal("1.1")\n    True\n\nExtending JSONEncoder::\n\n    >>> import simplejson\n    >>> class ComplexEncoder(simplejson.JSONEncoder):\n    ...     def default(self, obj):\n    ...         if isinstance(obj, complex):\n    ...             return [obj.real, obj.imag]\n    ...         return simplejson.JSONEncoder.default(self, obj)\n    ...\n    >>> dumps(2 + 1j, cls=ComplexEncoder)\n    \'[2.0, 1.0]\'\n    >>> ComplexEncoder().encode(2 + 1j)\n    \'[2.0, 1.0]\'\n    >>> \'\'.join(ComplexEncoder().iterencode(2 + 1j))\n    \'[2.0, 1.0]\'\n\n\nUsing simplejson from the shell to validate and\npretty-print::\n\n    $ echo \'{"json":"obj"}\' | python -msimplejson.tool\n    {\n        "json": "obj"\n    }\n    $ echo \'{ 1.2:3.4}\' | python -msimplejson.tool\n    Expecting property name: line 1 column 2 (char 2)\n'
__version__ = '2.0.4'
__all__ = ['dump', 'dumps', 'load', 'loads', 'JSONDecoder', 'JSONEncoder']
from decoder import JSONDecoder
from encoder import JSONEncoder
_default_encoder = JSONEncoder(skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, indent=None, separators=None, encoding='utf-8', default=None)
def dump(obj, fp, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, encoding='utf-8', default=None, **kw):
	if skipkeys is False and ensure_ascii is True and check_circular is True and allow_nan is True and cls is None and indent is None and separators is None and encoding == 'utf-8' and default is None and not kw:
		iterable = _default_encoder.iterencode(obj)
	else:
		if cls is None:
			cls = JSONEncoder
		iterable = cls(skipkeys=skipkeys, ensure_ascii=ensure_ascii, check_circular=check_circular, allow_nan=allow_nan, indent=indent, separators=separators, encoding=encoding, default=default, **kw).iterencode(obj)
	for chunk in iterable:
		fp.write(chunk)
	return None

def dumps(obj, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, encoding='utf-8', default=None, **kw):
	if skipkeys is False and ensure_ascii is True and check_circular is True and allow_nan is True and cls is None and indent is None and separators is None and encoding == 'utf-8' and default is None and not kw:
		return _default_encoder.encode(obj)
	if cls is None:
		cls = JSONEncoder
	return cls(skipkeys=skipkeys, ensure_ascii=ensure_ascii, check_circular=check_circular, allow_nan=allow_nan, indent=indent, separators=separators, encoding=encoding, default=default, **kw).encode(obj)

_default_decoder = JSONDecoder(encoding=None, object_hook=None)
def load(fp, encoding=None, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, **kw):
	return loads(fp.read(), encoding=encoding, cls=cls, object_hook=object_hook, parse_float=parse_float, parse_int=parse_int, parse_constant=parse_constant, **kw)

def loads(s, encoding=None, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, **kw):
	if cls is None and encoding is None and object_hook is None and parse_int is None and parse_float is None and parse_constant is None and not kw:
		return _default_decoder.decode(s)
	if cls is None:
		cls = JSONDecoder
	if object_hook is not None:
		kw['object_hook'] = object_hook
	if parse_float is not None:
		kw['parse_float'] = parse_float
	if parse_int is not None:
		kw['parse_int'] = parse_int
	if parse_constant is not None:
		kw['parse_constant'] = parse_constant
	return cls(encoding=encoding, **kw).decode(s)

