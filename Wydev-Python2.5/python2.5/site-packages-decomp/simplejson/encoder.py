# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 0
n 0(None)[return ESCAPE_DCT[match.group(0)]
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75d3f8c>}
nname: 0
n 0(None)[def replace(match):
	return ESCAPE_DCT[match.group(0)]

return '"' + ESCAPE.sub(replace, s) + '"'
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75caeac>}
nname: 145
n 145(None)[]:
	i: 18(), 68(JA), 83(), 143(AE)
	o: 

nname: 143
n 143(None)[]:
	i: 30(f)
	o: 145(AE)

nname: 83
n 83(None)[n -= 65536
s1 = 55296 | n >> 10 & 1023
s2 = 56320 | n & 1023
return '\\u%04x\\u%04x' % (s1, s2)
]:
	i: 40(f)
	o: 145()

nname: 68
n 68(None)[return '\\u%04x' % (n,)
]:
	i: 40(t)
	o: 145(JA)

nname: 40
n 40(n < 65536)[n = ord(s)
]:
	i: 30(t)
	o: 68(t), 83(f)

nname: 30
n 30(<dummy_ex3> EXC_MATCH KeyError)[]:
	i: 0(except)
	o: 40(t), 143(f)

nname: 18
n 18(None)[return ESCAPE_DCT[s]
]:
	i: 0(try)
	o: 145()

nname: 0
n 0(None)[s = match.group(0)
]:
	i: 
	o: 18(try), 30(except)

nname: 30
n 30(None)[except KeyError:
	n = ord(s)
	if n < 65536:
		return '\\u%04x' % (n,)
	else:
		n -= 65536
		s1 = 55296 | n >> 10 & 1023
		s2 = 56320 | n & 1023
		return '\\u%04x\\u%04x' % (s1, s2)
]:
	i: 0()
	o: 

nname: 0
n 0(None)[s = match.group(0)
try:
	return ESCAPE_DCT[s]
]:
	i: 
	o: 30()

nname: 0
n 0(None)[s = match.group(0)
try:
	return ESCAPE_DCT[s]
except KeyError:
	n = ord(s)
	if n < 65536:
		return '\\u%04x' % (n,)
	else:
		n -= 65536
		s1 = 55296 | n >> 10 & 1023
		s2 = 56320 | n & 1023
		return '\\u%04x\\u%04x' % (s1, s2)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb755be4c>}
nname: 57
n 57(None)[def replace(match):
	s = match.group(0)
	try:
		return ESCAPE_DCT[s]
	except KeyError:
		n = ord(s)
		if n < 65536:
			return '\\u%04x' % (n,)
		else:
			n -= 65536
			s1 = 55296 | n >> 10 & 1023
			s2 = 56320 | n & 1023
			return '\\u%04x\\u%04x' % (s1, s2)

return '"' + str(ESCAPE_ASCII.sub(replace, s)) + '"'
]:
	i: 37(), 56()
	o: 

nname: 56
n 56(None)[]:
	i: 0&15(f)
	o: 57()

nname: 37
n 37(None)[s = s.decode('utf-8')
]:
	i: 0&15(t)
	o: 57()

nname: 0&15
n 0&15(isinstance(s, str) and HAS_UTF8.search(s) is not None)[]:
	i: 
	o: 37(t), 56(f)

nname: 0&15
n 0&15(None)[if isinstance(s, str) and HAS_UTF8.search(s) is not None:
	s = s.decode('utf-8')
def replace(match):
	s = match.group(0)
	try:
		return ESCAPE_DCT[s]
	except KeyError:
		n = ord(s)
		if n < 65536:
			return '\\u%04x' % (n,)
		else:
			n -= 65536
			s1 = 55296 | n >> 10 & 1023
			s2 = 56320 | n & 1023
			return '\\u%04x\\u%04x' % (s1, s2)

return '"' + str(ESCAPE_ASCII.sub(replace, s)) + '"'
]:
	i: 
	o: 

self.nodes: {'0&15': <unpyclib.structure.node instance at 0xb75d33ec>}
nname: 115
n 115(None)[self.encoding = encoding
return None
]:
	i: 101(), 114()
	o: 

nname: 114
n 114(None)[]:
	i: 89(f)
	o: 115()

nname: 101
n 101(None)[self.default = default
]:
	i: 89(t)
	o: 115()

nname: 89
n 89(default is not None)[]:
	i: 66(), 88()
	o: 101(t), 114(f)

nname: 88
n 88(None)[]:
	i: 0(f)
	o: 89()

nname: 66
n 66(None)[self.item_separator, self.key_separator = separators
]:
	i: 0(t)
	o: 89()

nname: 0
n 0(separators is not None)[self.skipkeys = skipkeys
self.ensure_ascii = ensure_ascii
self.check_circular = check_circular
self.allow_nan = allow_nan
self.sort_keys = sort_keys
self.indent = indent
]:
	i: 
	o: 66(t), 88(f)

nname: 115
n 115(None)[self.encoding = encoding
return None
]:
	i: 0()
	o: 

nname: 0
n 0(None)[self.skipkeys = skipkeys
self.ensure_ascii = ensure_ascii
self.check_circular = check_circular
self.allow_nan = allow_nan
self.sort_keys = sort_keys
self.indent = indent
if separators is not None:
	self.item_separator, self.key_separator = separators
if default is not None:
	self.default = default
]:
	i: 
	o: 115()

nname: 0
n 0(None)[self.skipkeys = skipkeys
self.ensure_ascii = ensure_ascii
self.check_circular = check_circular
self.allow_nan = allow_nan
self.sort_keys = sort_keys
self.indent = indent
if separators is not None:
	self.item_separator, self.key_separator = separators
if default is not None:
	self.default = default
self.encoding = encoding
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75d1e6c>}
nname: 0
n 0(None)[raise TypeError('%r is not JSON serializable' % (o,))
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb755b76c>}
nname: 188
n 188(None)[return ''.join(chunks)
]:
	i: 171(), 187()
	o: 

nname: 187
n 187(None)[]:
	i: 129(t)
	o: 188()

nname: 171
n 171(None)[chunks = list(chunks)
]:
	i: 129(f)
	o: 188()

nname: 129
n 129(isinstance(chunks, (list, tuple)))[chunks = self.iterencode(o, _one_shot=True)
]:
	i: 100(JA), 114(), 128()
	o: 171(f), 187(t)

nname: 128
n 128(None)[]:
	i: 0(f)
	o: 129()

nname: 114
n 114(None)[return encode_basestring(o)
]:
	i: 91(f)
	o: 129()

nname: 100
n 100(None)[return encode_basestring_ascii(o)
]:
	i: 91(t)
	o: 129(JA)

nname: 91
n 91(self.ensure_ascii)[]:
	i: 67(JA), 86(), 90()
	o: 100(t), 114(f)

nname: 90
n 90(None)[]:
	i: 15(f)
	o: 91()

nname: 86
n 86(None)[]:
	i: 31&53(f)
	o: 91()

nname: 67
n 67(None)[o = o.decode(_encoding)
]:
	i: 31&53(t)
	o: 91(JA)

nname: 31&53
n 31&53(_encoding is not None and not _encoding == 'utf-8')[_encoding = self.encoding
]:
	i: 15(t)
	o: 67(t), 86(f)

nname: 15
n 15(isinstance(o, str))[]:
	i: 0(t)
	o: 31&53(t), 90(f)

nname: 0
n 0(isinstance(o, basestring))[]:
	i: 
	o: 15(t), 128(f)

nname: 129
n 129(None)[chunks = self.iterencode(o, _one_shot=True)
if not isinstance(chunks, (list, tuple)):
	chunks = list(chunks)
return ''.join(chunks)
]:
	i: 15(JA), 0(f)
	o: 

nname: 15
n 15(None)[if isinstance(o, str):
	_encoding = self.encoding
	if _encoding is not None and not _encoding == 'utf-8':
		o = o.decode(_encoding)
if self.ensure_ascii:
	return encode_basestring_ascii(o)
else:
	return encode_basestring(o)
]:
	i: 0(t)
	o: 129(JA)

nname: 0
n 0(isinstance(o, basestring))[]:
	i: 
	o: 15(t), 129(f)

nname: 0
n 0(None)[if isinstance(o, basestring):
	if isinstance(o, str):
		_encoding = self.encoding
		if _encoding is not None and not _encoding == 'utf-8':
			o = o.decode(_encoding)
	if self.ensure_ascii:
		return encode_basestring_ascii(o)
	else:
		return encode_basestring(o)
chunks = self.iterencode(o, _one_shot=True)
if not isinstance(chunks, (list, tuple)):
	chunks = list(chunks)
return ''.join(chunks)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb755feec>}
nname: 109
n 109(None)[return text
]:
	i: 85(), 108()
	o: 

nname: 108
n 108(None)[]:
	i: 79(t)
	o: 109()

nname: 85
n 85(None)[raise ValueError('Out of range float values are not JSON compliant: %r' % (o,))
]:
	i: 79(f)
	o: 109()

nname: 79
n 79(allow_nan)[]:
	i: 12(), 35(), 58(), 68()
	o: 85(f), 108(t)

nname: 68
n 68(None)[return _repr(o)
]:
	i: 45(f)
	o: 79()

nname: 58
n 58(None)[text = '-Infinity'
]:
	i: 45(t)
	o: 79()

nname: 45
n 45(o == _neginf)[]:
	i: 22(f)
	o: 58(t), 68(f)

nname: 35
n 35(None)[text = 'Infinity'
]:
	i: 22(t)
	o: 79()

nname: 22
n 22(o == _inf)[]:
	i: 0(f)
	o: 35(t), 45(f)

nname: 12
n 12(None)[text = 'NaN'
]:
	i: 0(t)
	o: 79()

nname: 0
n 0(o != o)[]:
	i: 
	o: 12(t), 22(f)

nname: 109
n 109(None)[return text
]:
	i: 0()
	o: 

nname: 0
n 0(None)[if o != o:
	text = 'NaN'
else:
	if o == _inf:
		text = 'Infinity'
	else:
		if o == _neginf:
			text = '-Infinity'
		else:
			return _repr(o)
if not allow_nan:
	raise ValueError('Out of range float values are not JSON compliant: %r' % (o,))
]:
	i: 
	o: 109()

nname: 0
n 0(None)[if o != o:
	text = 'NaN'
else:
	if o == _inf:
		text = 'Infinity'
	else:
		if o == _neginf:
			text = '-Infinity'
		else:
			return _repr(o)
if not allow_nan:
	raise ValueError('Out of range float values are not JSON compliant: %r' % (o,))
return text
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb756f82c>}
nname: 35
n 35(None)[return _orig_encoder(o)
]:
	i: 15(), 34()
	o: 

nname: 34
n 34(None)[]:
	i: 0(f)
	o: 35()

nname: 15
n 15(None)[o = o.decode(_encoding)
]:
	i: 0(t)
	o: 35()

nname: 0
n 0(isinstance(o, str))[]:
	i: 
	o: 15(t), 34(f)

nname: 0
n 0(None)[if isinstance(o, str):
	o = o.decode(_encoding)
return _orig_encoder(o)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75662ec>}
nname: 275
n 275(None)[return _iterencode(o, 0)
]:
	i: 156(), 217()
	o: 

nname: 217
n 217(None)[_iterencode = _make_iterencode(markers, self.default, _encoder, self.indent, floatstr, self.key_separator, self.item_separator, self.sort_keys, self.skipkeys, _one_shot)
]:
	i: 90&121&134&145(f)
	o: 275()

nname: 156
n 156(None)[_iterencode = c_make_encoder(markers, self.default, _encoder, self.indent, self.key_separator, self.item_separator, self.sort_keys, self.skipkeys, self.allow_nan)
]:
	i: 90&121&134&145(t)
	o: 275()

nname: 90&121&134&145
n 90&121&134&145(_one_shot and c_make_encoder is not None and not self.indent and not self.sort_keys)[def floatstr(o, allow_nan=self.allow_nan, _repr=FLOAT_REPR, _inf=INFINITY, _neginf=-INFINITY):
	if o != o:
		text = 'NaN'
	else:
		if o == _inf:
			text = 'Infinity'
		else:
			if o == _neginf:
				text = '-Infinity'
			else:
				return _repr(o)
	if not allow_nan:
		raise ValueError('Out of range float values are not JSON compliant: %r' % (o,))
	return text

]:
	i: 67(), 89()
	o: 156(t), 217(f)

nname: 89
n 89(None)[]:
	i: 52(f)
	o: 90&121&134&145()

nname: 67
n 67(None)[def _encoder(o, _orig_encoder=_encoder, _encoding=self.encoding):
	if isinstance(o, str):
		o = o.decode(_encoding)
	return _orig_encoder(o)

]:
	i: 52(t)
	o: 90&121&134&145()

nname: 52
n 52(self.encoding != 'utf-8')[]:
	i: 35(), 45()
	o: 67(t), 89(f)

nname: 45
n 45(None)[_encoder = encode_basestring
]:
	i: 26(f)
	o: 52()

nname: 35
n 35(None)[_encoder = encode_basestring_ascii
]:
	i: 26(t)
	o: 52()

nname: 26
n 26(self.ensure_ascii)[]:
	i: 9(), 19()
	o: 35(t), 45(f)

nname: 19
n 19(None)[markers = None
]:
	i: 0(f)
	o: 26()

nname: 9
n 9(None)[markers = {}
]:
	i: 0(t)
	o: 26()

nname: 0
n 0(self.check_circular)[]:
	i: 
	o: 9(t), 19(f)

nname: 275
n 275(None)[return _iterencode(o, 0)
]:
	i: 52()
	o: 

nname: 52
n 52(None)[if self.encoding != 'utf-8':
	def _encoder(o, _orig_encoder=_encoder, _encoding=self.encoding):
		if isinstance(o, str):
			o = o.decode(_encoding)
		return _orig_encoder(o)

def floatstr(o, allow_nan=self.allow_nan, _repr=FLOAT_REPR, _inf=INFINITY, _neginf=-INFINITY):
	if o != o:
		text = 'NaN'
	else:
		if o == _inf:
			text = 'Infinity'
		else:
			if o == _neginf:
				text = '-Infinity'
			else:
				return _repr(o)
	if not allow_nan:
		raise ValueError('Out of range float values are not JSON compliant: %r' % (o,))
	return text

if _one_shot and c_make_encoder is not None and not self.indent and not self.sort_keys:
	_iterencode = c_make_encoder(markers, self.default, _encoder, self.indent, self.key_separator, self.item_separator, self.sort_keys, self.skipkeys, self.allow_nan)
else:
	_iterencode = _make_iterencode(markers, self.default, _encoder, self.indent, floatstr, self.key_separator, self.item_separator, self.sort_keys, self.skipkeys, _one_shot)
]:
	i: 0()
	o: 275()

nname: 0
n 0(None)[if self.check_circular:
	markers = {}
else:
	markers = None
if self.ensure_ascii:
	_encoder = encode_basestring_ascii
else:
	_encoder = encode_basestring
]:
	i: 
	o: 52()

nname: 275
n 275(None)[return _iterencode(o, 0)
]:
	i: 0()
	o: 

nname: 0
n 0(None)[if self.check_circular:
	markers = {}
else:
	markers = None
if self.ensure_ascii:
	_encoder = encode_basestring_ascii
else:
	_encoder = encode_basestring
if self.encoding != 'utf-8':
	def _encoder(o, _orig_encoder=_encoder, _encoding=self.encoding):
		if isinstance(o, str):
			o = o.decode(_encoding)
		return _orig_encoder(o)

def floatstr(o, allow_nan=self.allow_nan, _repr=FLOAT_REPR, _inf=INFINITY, _neginf=-INFINITY):
	if o != o:
		text = 'NaN'
	else:
		if o == _inf:
			text = 'Infinity'
		else:
			if o == _neginf:
				text = '-Infinity'
			else:
				return _repr(o)
	if not allow_nan:
		raise ValueError('Out of range float values are not JSON compliant: %r' % (o,))
	return text

if _one_shot and c_make_encoder is not None and not self.indent and not self.sort_keys:
	_iterencode = c_make_encoder(markers, self.default, _encoder, self.indent, self.key_separator, self.item_separator, self.sort_keys, self.skipkeys, self.allow_nan)
else:
	_iterencode = _make_iterencode(markers, self.default, _encoder, self.indent, floatstr, self.key_separator, self.item_separator, self.sort_keys, self.skipkeys, _one_shot)
]:
	i: 
	o: 275()

nname: 0
n 0(None)[if self.check_circular:
	markers = {}
else:
	markers = None
if self.ensure_ascii:
	_encoder = encode_basestring_ascii
else:
	_encoder = encode_basestring
if self.encoding != 'utf-8':
	def _encoder(o, _orig_encoder=_encoder, _encoding=self.encoding):
		if isinstance(o, str):
			o = o.decode(_encoding)
		return _orig_encoder(o)

def floatstr(o, allow_nan=self.allow_nan, _repr=FLOAT_REPR, _inf=INFINITY, _neginf=-INFINITY):
	if o != o:
		text = 'NaN'
	else:
		if o == _inf:
			text = 'Infinity'
		else:
			if o == _neginf:
				text = '-Infinity'
			else:
				return _repr(o)
	if not allow_nan:
		raise ValueError('Out of range float values are not JSON compliant: %r' % (o,))
	return text

if _one_shot and c_make_encoder is not None and not self.indent and not self.sort_keys:
	_iterencode = c_make_encoder(markers, self.default, _encoder, self.indent, self.key_separator, self.item_separator, self.sort_keys, self.skipkeys, self.allow_nan)
else:
	_iterencode = _make_iterencode(markers, self.default, _encoder, self.indent, floatstr, self.key_separator, self.item_separator, self.sort_keys, self.skipkeys, _one_shot)
return _iterencode(o, 0)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb755b18c>}
nname: 6
n 6(None)[__doc__ = 'Extensible JSON <http://json.org> encoder for Python data structures.\n\n    Supports the following objects and types by default:\n\n    +-------------------+---------------+\n    | Python            | JSON          |\n    +===================+===============+\n    | dict              | object        |\n    +-------------------+---------------+\n    | list, tuple       | array         |\n    +-------------------+---------------+\n    | str, unicode      | string        |\n    +-------------------+---------------+\n    | int, long, float  | number        |\n    +-------------------+---------------+\n    | True              | true          |\n    +-------------------+---------------+\n    | False             | false         |\n    +-------------------+---------------+\n    | None              | null          |\n    +-------------------+---------------+\n\n    To extend this to recognize other objects, subclass and implement a\n    ``.default()`` method with another method that returns a serializable\n    object for ``o`` if possible, otherwise it should call the superclass\n    implementation (to raise ``TypeError``).\n\n    '
item_separator = ', '
key_separator = ': '
def __init__(self, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, sort_keys=False, indent=None, separators=None, encoding='utf-8', default=None):
	self.skipkeys = skipkeys
	self.ensure_ascii = ensure_ascii
	self.check_circular = check_circular
	self.allow_nan = allow_nan
	self.sort_keys = sort_keys
	self.indent = indent
	if separators is not None:
		self.item_separator, self.key_separator = separators
	if default is not None:
		self.default = default
	self.encoding = encoding
	return None

def default(self, o):
	raise TypeError('%r is not JSON serializable' % (o,))

def encode(self, o):
	if isinstance(o, basestring):
		if isinstance(o, str):
			_encoding = self.encoding
			if _encoding is not None and not _encoding == 'utf-8':
				o = o.decode(_encoding)
		if self.ensure_ascii:
			return encode_basestring_ascii(o)
		else:
			return encode_basestring(o)
	chunks = self.iterencode(o, _one_shot=True)
	if not isinstance(chunks, (list, tuple)):
		chunks = list(chunks)
	return ''.join(chunks)

def iterencode(self, o, _one_shot=False):
	if self.check_circular:
		markers = {}
	else:
		markers = None
	if self.ensure_ascii:
		_encoder = encode_basestring_ascii
	else:
		_encoder = encode_basestring
	if self.encoding != 'utf-8':
		def _encoder(o, _orig_encoder=_encoder, _encoding=self.encoding):
			if isinstance(o, str):
				o = o.decode(_encoding)
			return _orig_encoder(o)

	def floatstr(o, allow_nan=self.allow_nan, _repr=FLOAT_REPR, _inf=INFINITY, _neginf=-INFINITY):
		if o != o:
			text = 'NaN'
		else:
			if o == _inf:
				text = 'Infinity'
			else:
				if o == _neginf:
					text = '-Infinity'
				else:
					return _repr(o)
		if not allow_nan:
			raise ValueError('Out of range float values are not JSON compliant: %r' % (o,))
		return text

	if _one_shot and c_make_encoder is not None and not self.indent and not self.sort_keys:
		_iterencode = c_make_encoder(markers, self.default, _encoder, self.indent, self.key_separator, self.item_separator, self.sort_keys, self.skipkeys, self.allow_nan)
	else:
		_iterencode = _make_iterencode(markers, self.default, _encoder, self.indent, floatstr, self.key_separator, self.item_separator, self.sort_keys, self.skipkeys, _one_shot)
	return _iterencode(o, 0)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb75d376c>}
nname: 597
n 597(None)[return None
]:
	i: 585(), 596()
	o: 

nname: 596
n 596(None)[]:
	i: 568(f)
	o: 597()

nname: 585
n 585(None)[del markers[markerid]
]:
	i: 568(t)
	o: 597()

nname: 568
n 568(markers is not None)[yield ']'
]:
	i: 536(), 567()
	o: 585(t), 596(f)

nname: 567
n 567(None)[]:
	i: 524(f)
	o: 568()

nname: 536
n 536(None)[_current_indent_level -= 1
yield '\n' + ' ' * _indent * _current_indent_level
]:
	i: 524(t)
	o: 568()

nname: 524
n 524(newline_indent is not None)[]:
	i: 171(AL), 523()
	o: 536(t), 567(f)

nname: 523
n 523(None)[]:
	i: 180(AF), 520()
	o: 524()

nname: 520
n 520(None)[]:
	i: 498(AL), 519()
	o: 523()

nname: 519
n 519(None)[]:
	i: 501(AF), 508()
	o: 520()

nname: 508
n 508(None)[for chunk in chunks:
yield chunk
]:
	i: 501(for)
	o: 519()

nname: 501
n 501(None)[]:
	i: 498(loop)
	o: 508(for), 519(AF)

nname: 498
n 498(None)[]:
	i: 428(), 463(), 482()
	o: 501(loop), 520(AL)

nname: 482
n 482(None)[chunks = _iterencode(value, _current_indent_level)
]:
	i: 447(f)
	o: 498()

nname: 463
n 463(None)[chunks = _iterencode_dict(value, _current_indent_level)
]:
	i: 447(t)
	o: 498()

nname: 447
n 447(isinstance(value, dict))[]:
	i: 401(f)
	o: 463(t), 482(f)

nname: 428
n 428(None)[chunks = _iterencode_list(value, _current_indent_level)
]:
	i: 401(t)
	o: 498()

nname: 401
n 401(isinstance(value, (list, tuple)))[yield buf
]:
	i: 366(f), 382()
	o: 428(t), 447(f)

nname: 382
n 382(None)[yield buf + _floatstr(value)
continue
]:
	i: 366(t)
	o: 401()

nname: 366
n 366(isinstance(value, float))[]:
	i: 325(f), 347()
	o: 382(t), 401(f)

nname: 347
n 347(None)[yield buf + str(value)
continue
]:
	i: 325(t)
	o: 366()

nname: 325
n 325(isinstance(value, (int, long)))[]:
	i: 299(f), 312()
	o: 347(t), 366(f)

nname: 312
n 312(None)[yield buf + 'false'
continue
]:
	i: 299(t)
	o: 325()

nname: 299
n 299(value is False)[]:
	i: 273(f), 286()
	o: 312(t), 325(f)

nname: 286
n 286(None)[yield buf + 'true'
continue
]:
	i: 273(t)
	o: 299()

nname: 273
n 273(value is True)[]:
	i: 247(f), 260()
	o: 286(t), 299(f)

nname: 260
n 260(None)[yield buf + 'null'
continue
]:
	i: 247(t)
	o: 273()

nname: 247
n 247(value is None)[]:
	i: 213(f), 228()
	o: 260(t), 273(f)

nname: 228
n 228(None)[yield buf + _encoder(value)
continue
]:
	i: 213(t)
	o: 247()

nname: 213
n 213(isinstance(value, basestring))[]:
	i: 196(), 206()
	o: 228(t), 247(f)

nname: 206
n 206(None)[buf = separator
]:
	i: 187(f)
	o: 213()

nname: 196
n 196(None)[first = False
]:
	i: 187(t)
	o: 213()

nname: 187
n 187(first)[for value in lst:
]:
	i: 180(for)
	o: 196(t), 206(f)

nname: 180
n 180(None)[]:
	i: 171(loop)
	o: 187(for), 523(AF)

nname: 171
n 171(None)[first = True
]:
	i: 106(), 158()
	o: 180(loop), 524(AL)

nname: 158
n 158(None)[newline_indent = None
separator = _item_separator
]:
	i: 88(f)
	o: 171()

nname: 106
n 106(None)[_current_indent_level += 1
newline_indent = '\n' + ' ' * _indent * _current_indent_level
separator = _item_separator + newline_indent
buf += newline_indent
]:
	i: 88(t)
	o: 171()

nname: 88
n 88(_indent is not None)[buf = '['
]:
	i: 74(), 87()
	o: 106(t), 158(f)

nname: 87
n 87(None)[]:
	i: 20(f)
	o: 88()

nname: 74
n 74(None)[markers[markerid] = lst
]:
	i: 57(), 73()
	o: 88()

nname: 73
n 73(None)[]:
	i: 32(f)
	o: 74()

nname: 57
n 57(None)[raise ValueError('Circular reference detected')
]:
	i: 32(t)
	o: 74()

nname: 32
n 32(markerid in markers)[markerid = id(lst)
]:
	i: 20(t)
	o: 57(t), 73(f)

nname: 20
n 20(markers is not None)[]:
	i: 6(), 19()
	o: 32(t), 87(f)

nname: 19
n 19(None)[]:
	i: 0(t)
	o: 20()

nname: 6
n 6(None)[yield '[]'
return None
]:
	i: 0(f)
	o: 20()

nname: 0
n 0(lst)[]:
	i: 
	o: 6(f), 19(t)

nname: 597
n 597(None)[return None
]:
	i: 524()
	o: 

nname: 524
n 524(None)[if newline_indent is not None:
	_current_indent_level -= 1
	yield '\n' + ' ' * _indent * _current_indent_level
yield ']'
if markers is not None:
	del markers[markerid]
]:
	i: 88(AL), 180(AF), 508()
	o: 597()

nname: 508
n 508(None)[for chunk in chunks:
	yield chunk
]:
	i: 498(for)
	o: 524()

nname: 498
n 498(None)[]:
	i: 366()
	o: 508(for)

nname: 366
n 366(None)[if isinstance(value, float):
	yield buf + _floatstr(value)
	continue
yield buf
if isinstance(value, (list, tuple)):
	chunks = _iterencode_list(value, _current_indent_level)
else:
	if isinstance(value, dict):
		chunks = _iterencode_dict(value, _current_indent_level)
	else:
		chunks = _iterencode(value, _current_indent_level)
]:
	i: 299(f)
	o: 498()

nname: 299
n 299(None)[if value is False:
	yield buf + 'false'
	continue
if isinstance(value, (int, long)):
	yield buf + str(value)
	continue
]:
	i: 247(f)
	o: 366()

nname: 247
n 247(None)[if value is None:
	yield buf + 'null'
	continue
if value is True:
	yield buf + 'true'
	continue
]:
	i: 187(f)
	o: 299()

nname: 187
n 187(None)[for value in lst:
if first:
	first = False
else:
	buf = separator
if isinstance(value, basestring):
	yield buf + _encoder(value)
	continue
]:
	i: 180(for)
	o: 247()

nname: 180
n 180(None)[]:
	i: 88(loop)
	o: 187(for), 524(AF)

nname: 88
n 88(None)[buf = '['
if _indent is not None:
	_current_indent_level += 1
	newline_indent = '\n' + ' ' * _indent * _current_indent_level
	separator = _item_separator + newline_indent
	buf += newline_indent
else:
	newline_indent = None
	separator = _item_separator
first = True
]:
	i: 32(), 0(f)
	o: 180(loop), 524(AL)

nname: 32
n 32(None)[markerid = id(lst)
if markerid in markers:
	raise ValueError('Circular reference detected')
markers[markerid] = lst
]:
	i: 0(t)
	o: 88()

nname: 0
n 0(markers is not None)[if not lst:
	yield '[]'
	return None
]:
	i: 
	o: 32(t), 88(f)

nname: 524
n 524(None)[if newline_indent is not None:
	_current_indent_level -= 1
	yield '\n' + ' ' * _indent * _current_indent_level
yield ']'
if markers is not None:
	del markers[markerid]
return None
]:
	i: 0(AL), 180(AF), 498()
	o: 

nname: 498
n 498(None)[for chunk in chunks:
	yield chunk
]:
	i: 299()
	o: 524()

nname: 299
n 299(None)[if value is False:
	yield buf + 'false'
	continue
if isinstance(value, (int, long)):
	yield buf + str(value)
	continue
if isinstance(value, float):
	yield buf + _floatstr(value)
	continue
yield buf
if isinstance(value, (list, tuple)):
	chunks = _iterencode_list(value, _current_indent_level)
else:
	if isinstance(value, dict):
		chunks = _iterencode_dict(value, _current_indent_level)
	else:
		chunks = _iterencode(value, _current_indent_level)
]:
	i: 187(f)
	o: 498()

nname: 187
n 187(None)[for value in lst:
if first:
	first = False
else:
	buf = separator
if isinstance(value, basestring):
	yield buf + _encoder(value)
	continue
if value is None:
	yield buf + 'null'
	continue
if value is True:
	yield buf + 'true'
	continue
]:
	i: 180(for)
	o: 299()

nname: 180
n 180(None)[]:
	i: 0(loop)
	o: 187(for), 524(AF)

nname: 0
n 0(None)[if not lst:
	yield '[]'
	return None
if markers is not None:
	markerid = id(lst)
	if markerid in markers:
		raise ValueError('Circular reference detected')
	markers[markerid] = lst
buf = '['
if _indent is not None:
	_current_indent_level += 1
	newline_indent = '\n' + ' ' * _indent * _current_indent_level
	separator = _item_separator + newline_indent
	buf += newline_indent
else:
	newline_indent = None
	separator = _item_separator
first = True
]:
	i: 
	o: 180(loop), 524(AL)

nname: 524
n 524(None)[if newline_indent is not None:
	_current_indent_level -= 1
	yield '\n' + ' ' * _indent * _current_indent_level
yield ']'
if markers is not None:
	del markers[markerid]
return None
]:
	i: 0(AL), 180(AF), 498()
	o: 

nname: 498
n 498(None)[for chunk in chunks:
	yield chunk
]:
	i: 187()
	o: 524()

nname: 187
n 187(None)[for value in lst:
if first:
	first = False
else:
	buf = separator
if isinstance(value, basestring):
	yield buf + _encoder(value)
	continue
if value is None:
	yield buf + 'null'
	continue
if value is True:
	yield buf + 'true'
	continue
if value is False:
	yield buf + 'false'
	continue
if isinstance(value, (int, long)):
	yield buf + str(value)
	continue
if isinstance(value, float):
	yield buf + _floatstr(value)
	continue
yield buf
if isinstance(value, (list, tuple)):
	chunks = _iterencode_list(value, _current_indent_level)
else:
	if isinstance(value, dict):
		chunks = _iterencode_dict(value, _current_indent_level)
	else:
		chunks = _iterencode(value, _current_indent_level)
]:
	i: 180(for)
	o: 498()

nname: 180
n 180(None)[]:
	i: 0(loop)
	o: 187(for), 524(AF)

nname: 0
n 0(None)[if not lst:
	yield '[]'
	return None
if markers is not None:
	markerid = id(lst)
	if markerid in markers:
		raise ValueError('Circular reference detected')
	markers[markerid] = lst
buf = '['
if _indent is not None:
	_current_indent_level += 1
	newline_indent = '\n' + ' ' * _indent * _current_indent_level
	separator = _item_separator + newline_indent
	buf += newline_indent
else:
	newline_indent = None
	separator = _item_separator
first = True
]:
	i: 
	o: 180(loop), 524(AL)

nname: 524
n 524(None)[if newline_indent is not None:
	_current_indent_level -= 1
	yield '\n' + ' ' * _indent * _current_indent_level
yield ']'
if markers is not None:
	del markers[markerid]
return None
]:
	i: 0(AL), 180(AF), 187()
	o: 

nname: 187
n 187(None)[for value in lst:
if first:
	first = False
else:
	buf = separator
if isinstance(value, basestring):
	yield buf + _encoder(value)
	continue
if value is None:
	yield buf + 'null'
	continue
if value is True:
	yield buf + 'true'
	continue
if value is False:
	yield buf + 'false'
	continue
if isinstance(value, (int, long)):
	yield buf + str(value)
	continue
if isinstance(value, float):
	yield buf + _floatstr(value)
	continue
yield buf
if isinstance(value, (list, tuple)):
	chunks = _iterencode_list(value, _current_indent_level)
else:
	if isinstance(value, dict):
		chunks = _iterencode_dict(value, _current_indent_level)
	else:
		chunks = _iterencode(value, _current_indent_level)
for chunk in chunks:
	yield chunk
]:
	i: 180(for)
	o: 524()

nname: 180
n 180(None)[]:
	i: 0(loop)
	o: 187(for), 524(AF)

nname: 0
n 0(None)[if not lst:
	yield '[]'
	return None
if markers is not None:
	markerid = id(lst)
	if markerid in markers:
		raise ValueError('Circular reference detected')
	markers[markerid] = lst
buf = '['
if _indent is not None:
	_current_indent_level += 1
	newline_indent = '\n' + ' ' * _indent * _current_indent_level
	separator = _item_separator + newline_indent
	buf += newline_indent
else:
	newline_indent = None
	separator = _item_separator
first = True
]:
	i: 
	o: 180(loop), 524(AL)

self.nodes: {0: <unpyclib.structure.node instance at 0xb757b10c>, 524: <unpyclib.structure.node instance at 0xb757b2ac>, 180: <unpyclib.structure.node instance at 0xb757050c>, 187: <unpyclib.structure.node instance at 0xb757bfec>}
nname: 0
n 0(None)[return kv[0]
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75937ec>}
nname: 829
n 829(None)[return None
]:
	i: 817(), 828()
	o: 

nname: 828
n 828(None)[]:
	i: 800(f)
	o: 829()

nname: 817
n 817(None)[del markers[markerid]
]:
	i: 800(t)
	o: 829()

nname: 800
n 800(markers is not None)[yield '}'
]:
	i: 768(), 799()
	o: 817(t), 828(f)

nname: 799
n 799(None)[]:
	i: 756(f)
	o: 800()

nname: 768
n 768(None)[_current_indent_level -= 1
yield '\n' + ' ' * _indent * _current_indent_level
]:
	i: 756(t)
	o: 800()

nname: 756
n 756(newline_indent is not None)[]:
	i: 225(AL), 755()
	o: 768(t), 799(f)

nname: 755
n 755(None)[]:
	i: 228(AF), 752()
	o: 756()

nname: 752
n 752(None)[]:
	i: 730(AL), 751()
	o: 755()

nname: 751
n 751(None)[]:
	i: 733(AF), 740()
	o: 752()

nname: 740
n 740(None)[for chunk in chunks:
yield chunk
]:
	i: 733(for)
	o: 751()

nname: 733
n 733(None)[]:
	i: 730(loop)
	o: 740(for), 751(AF)

nname: 730
n 730(None)[]:
	i: 660(), 695(), 714()
	o: 733(loop), 752(AL)

nname: 714
n 714(None)[chunks = _iterencode(value, _current_indent_level)
]:
	i: 679(f)
	o: 730()

nname: 695
n 695(None)[chunks = _iterencode_dict(value, _current_indent_level)
]:
	i: 679(t)
	o: 730()

nname: 679
n 679(isinstance(value, dict))[]:
	i: 638(f)
	o: 695(t), 714(f)

nname: 660
n 660(None)[chunks = _iterencode_list(value, _current_indent_level)
]:
	i: 638(t)
	o: 730()

nname: 638
n 638(isinstance(value, (list, tuple)))[]:
	i: 607(f), 623()
	o: 660(t), 679(f)

nname: 623
n 623(None)[yield _floatstr(value)
continue
]:
	i: 607(t)
	o: 638()

nname: 607
n 607(isinstance(value, float))[]:
	i: 570(f), 592()
	o: 623(t), 638(f)

nname: 592
n 592(None)[yield str(value)
continue
]:
	i: 570(t)
	o: 607()

nname: 570
n 570(isinstance(value, (int, long)))[]:
	i: 548(f), 561()
	o: 592(t), 607(f)

nname: 561
n 561(None)[yield 'false'
continue
]:
	i: 548(t)
	o: 570()

nname: 548
n 548(value is False)[]:
	i: 526(f), 539()
	o: 561(t), 570(f)

nname: 539
n 539(None)[yield 'true'
continue
]:
	i: 526(t)
	o: 548()

nname: 526
n 526(value is True)[]:
	i: 504(f), 517()
	o: 539(t), 548(f)

nname: 517
n 517(None)[yield 'null'
continue
]:
	i: 504(t)
	o: 526()

nname: 504
n 504(value is None)[]:
	i: 458(f), 489()
	o: 517(t), 526(f)

nname: 489
n 489(None)[yield _encoder(value)
continue
]:
	i: 458(t)
	o: 504()

nname: 458
n 458(isinstance(value, basestring))[yield _encoder(key)
yield _key_separator
]:
	i: 442(), 452()
	o: 489(t), 504(f)

nname: 452
n 452(None)[yield item_separator
]:
	i: 436(f)
	o: 458()

nname: 442
n 442(None)[first = False
]:
	i: 436(t)
	o: 458()

nname: 436
n 436(first)[]:
	i: 259(), 279(), 317(), 346(), 369(), 392(), 409(), 416()
	o: 442(t), 452(f)

nname: 416
n 416(None)[raise TypeError('key %r is not a string' % (key,))
]:
	i: 402(f)
	o: 436()

nname: 409
n 409(None)[continue
]:
	i: 402(t)
	o: 436()

nname: 402
n 402(_skipkeys)[]:
	i: 379(f)
	o: 409(t), 416(f)

nname: 392
n 392(None)[key = 'null'
]:
	i: 379(t)
	o: 436()

nname: 379
n 379(key is None)[]:
	i: 356(f)
	o: 392(t), 402(f)

nname: 369
n 369(None)[key = 'false'
]:
	i: 356(t)
	o: 436()

nname: 356
n 356(key is False)[]:
	i: 333(f)
	o: 369(t), 379(f)

nname: 346
n 346(None)[key = 'true'
]:
	i: 333(t)
	o: 436()

nname: 333
n 333(key is True)[]:
	i: 295(f)
	o: 346(t), 356(f)

nname: 317
n 317(None)[key = str(key)
]:
	i: 295(t)
	o: 436()

nname: 295
n 295(isinstance(key, (int, long)))[]:
	i: 263(f)
	o: 317(t), 333(f)

nname: 279
n 279(None)[key = _floatstr(key)
]:
	i: 263(t)
	o: 436()

nname: 263
n 263(isinstance(key, float))[]:
	i: 235(f)
	o: 279(t), 295(f)

nname: 259
n 259(None)[]:
	i: 235(t)
	o: 436()

nname: 235
n 235(isinstance(key, basestring))[for key, value in items:
]:
	i: 228(for)
	o: 259(t), 263(f)

nname: 228
n 228(None)[]:
	i: 225(loop)
	o: 235(for), 755(AF)

nname: 225
n 225(None)[]:
	i: 177(), 212()
	o: 228(loop), 756(AL)

nname: 212
n 212(None)[items = dct.iteritems()
]:
	i: 165(f)
	o: 225()

nname: 177
n 177(None)[items = dct.items()
items.sort(key=(lambda kv: kv[0]))
]:
	i: 165(t)
	o: 225()

nname: 165
n 165(_sort_keys)[first = True
]:
	i: 105(), 152()
	o: 177(t), 212(f)

nname: 152
n 152(None)[newline_indent = None
item_separator = _item_separator
]:
	i: 88(f)
	o: 165()

nname: 105
n 105(None)[_current_indent_level += 1
newline_indent = '\n' + ' ' * _indent * _current_indent_level
item_separator = _item_separator + newline_indent
yield newline_indent
]:
	i: 88(t)
	o: 165()

nname: 88
n 88(_indent is not None)[yield '{'
]:
	i: 74(), 87()
	o: 105(t), 152(f)

nname: 87
n 87(None)[]:
	i: 20(f)
	o: 88()

nname: 74
n 74(None)[markers[markerid] = dct
]:
	i: 57(), 73()
	o: 88()

nname: 73
n 73(None)[]:
	i: 32(f)
	o: 74()

nname: 57
n 57(None)[raise ValueError('Circular reference detected')
]:
	i: 32(t)
	o: 74()

nname: 32
n 32(markerid in markers)[markerid = id(dct)
]:
	i: 20(t)
	o: 57(t), 73(f)

nname: 20
n 20(markers is not None)[]:
	i: 6(), 19()
	o: 32(t), 87(f)

nname: 19
n 19(None)[]:
	i: 0(t)
	o: 20()

nname: 6
n 6(None)[yield '{}'
return None
]:
	i: 0(f)
	o: 20()

nname: 0
n 0(dct)[]:
	i: 
	o: 6(f), 19(t)

nname: 829
n 829(None)[return None
]:
	i: 756()
	o: 

nname: 756
n 756(None)[if newline_indent is not None:
	_current_indent_level -= 1
	yield '\n' + ' ' * _indent * _current_indent_level
yield '}'
if markers is not None:
	del markers[markerid]
]:
	i: 225(AL), 228(AF), 751()
	o: 829()

nname: 751
n 751(None)[]:
	i: 733()
	o: 756()

nname: 733
n 733(None)[for chunk in chunks:
	yield chunk
]:
	i: 638(loop)
	o: 751()

nname: 638
n 638(None)[if isinstance(value, (list, tuple)):
	chunks = _iterencode_list(value, _current_indent_level)
else:
	if isinstance(value, dict):
		chunks = _iterencode_dict(value, _current_indent_level)
	else:
		chunks = _iterencode(value, _current_indent_level)
]:
	i: 570(f)
	o: 733(loop)

nname: 570
n 570(None)[if isinstance(value, (int, long)):
	yield str(value)
	continue
if isinstance(value, float):
	yield _floatstr(value)
	continue
]:
	i: 526(f)
	o: 638()

nname: 526
n 526(None)[if value is True:
	yield 'true'
	continue
if value is False:
	yield 'false'
	continue
]:
	i: 458(f)
	o: 570()

nname: 458
n 458(None)[yield _encoder(key)
yield _key_separator
if isinstance(value, basestring):
	yield _encoder(value)
	continue
if value is None:
	yield 'null'
	continue
]:
	i: 235()
	o: 526()

nname: 235
n 235(None)[for key, value in items:
if isinstance(key, basestring):
	pass
else:
	if isinstance(key, float):
		key = _floatstr(key)
	else:
		if isinstance(key, (int, long)):
			key = str(key)
		else:
			if key is True:
				key = 'true'
			else:
				if key is False:
					key = 'false'
				else:
					if key is None:
						key = 'null'
					else:
						if _skipkeys:
							continue
						else:
							raise TypeError('key %r is not a string' % (key,))
if first:
	first = False
else:
	yield item_separator
]:
	i: 228(for)
	o: 458()

nname: 228
n 228(None)[]:
	i: 225(loop)
	o: 235(for), 756(AF)

nname: 225
n 225(None)[]:
	i: 88()
	o: 228(loop), 756(AL)

nname: 88
n 88(None)[yield '{'
if _indent is not None:
	_current_indent_level += 1
	newline_indent = '\n' + ' ' * _indent * _current_indent_level
	item_separator = _item_separator + newline_indent
	yield newline_indent
else:
	newline_indent = None
	item_separator = _item_separator
first = True
if _sort_keys:
	items = dct.items()
	items.sort(key=(lambda kv: kv[0]))
else:
	items = dct.iteritems()
]:
	i: 32(), 0(f)
	o: 225()

nname: 32
n 32(None)[markerid = id(dct)
if markerid in markers:
	raise ValueError('Circular reference detected')
markers[markerid] = dct
]:
	i: 0(t)
	o: 88()

nname: 0
n 0(markers is not None)[if not dct:
	yield '{}'
	return None
]:
	i: 
	o: 32(t), 88(f)

nname: 756
n 756(None)[if newline_indent is not None:
	_current_indent_level -= 1
	yield '\n' + ' ' * _indent * _current_indent_level
yield '}'
if markers is not None:
	del markers[markerid]
return None
]:
	i: 225(AL), 228(AF), 638()
	o: 

nname: 638
n 638(None)[if isinstance(value, (list, tuple)):
	chunks = _iterencode_list(value, _current_indent_level)
else:
	if isinstance(value, dict):
		chunks = _iterencode_dict(value, _current_indent_level)
	else:
		chunks = _iterencode(value, _current_indent_level)
for chunk in chunks:
	yield chunk
]:
	i: 526(f)
	o: 756()

nname: 526
n 526(None)[if value is True:
	yield 'true'
	continue
if value is False:
	yield 'false'
	continue
if isinstance(value, (int, long)):
	yield str(value)
	continue
if isinstance(value, float):
	yield _floatstr(value)
	continue
]:
	i: 235(f)
	o: 638()

nname: 235
n 235(None)[for key, value in items:
if isinstance(key, basestring):
	pass
else:
	if isinstance(key, float):
		key = _floatstr(key)
	else:
		if isinstance(key, (int, long)):
			key = str(key)
		else:
			if key is True:
				key = 'true'
			else:
				if key is False:
					key = 'false'
				else:
					if key is None:
						key = 'null'
					else:
						if _skipkeys:
							continue
						else:
							raise TypeError('key %r is not a string' % (key,))
if first:
	first = False
else:
	yield item_separator
yield _encoder(key)
yield _key_separator
if isinstance(value, basestring):
	yield _encoder(value)
	continue
if value is None:
	yield 'null'
	continue
]:
	i: 228(for)
	o: 526()

nname: 228
n 228(None)[]:
	i: 225(loop)
	o: 235(for), 756(AF)

nname: 225
n 225(None)[]:
	i: 0()
	o: 228(loop), 756(AL)

nname: 0
n 0(None)[if not dct:
	yield '{}'
	return None
if markers is not None:
	markerid = id(dct)
	if markerid in markers:
		raise ValueError('Circular reference detected')
	markers[markerid] = dct
yield '{'
if _indent is not None:
	_current_indent_level += 1
	newline_indent = '\n' + ' ' * _indent * _current_indent_level
	item_separator = _item_separator + newline_indent
	yield newline_indent
else:
	newline_indent = None
	item_separator = _item_separator
first = True
if _sort_keys:
	items = dct.items()
	items.sort(key=(lambda kv: kv[0]))
else:
	items = dct.iteritems()
]:
	i: 
	o: 225()

nname: 756
n 756(None)[if newline_indent is not None:
	_current_indent_level -= 1
	yield '\n' + ' ' * _indent * _current_indent_level
yield '}'
if markers is not None:
	del markers[markerid]
return None
]:
	i: 0(AL), 228(AF), 638()
	o: 

nname: 638
n 638(None)[if isinstance(value, (list, tuple)):
	chunks = _iterencode_list(value, _current_indent_level)
else:
	if isinstance(value, dict):
		chunks = _iterencode_dict(value, _current_indent_level)
	else:
		chunks = _iterencode(value, _current_indent_level)
for chunk in chunks:
	yield chunk
]:
	i: 235(f)
	o: 756()

nname: 235
n 235(None)[for key, value in items:
if isinstance(key, basestring):
	pass
else:
	if isinstance(key, float):
		key = _floatstr(key)
	else:
		if isinstance(key, (int, long)):
			key = str(key)
		else:
			if key is True:
				key = 'true'
			else:
				if key is False:
					key = 'false'
				else:
					if key is None:
						key = 'null'
					else:
						if _skipkeys:
							continue
						else:
							raise TypeError('key %r is not a string' % (key,))
if first:
	first = False
else:
	yield item_separator
yield _encoder(key)
yield _key_separator
if isinstance(value, basestring):
	yield _encoder(value)
	continue
if value is None:
	yield 'null'
	continue
if value is True:
	yield 'true'
	continue
if value is False:
	yield 'false'
	continue
if isinstance(value, (int, long)):
	yield str(value)
	continue
if isinstance(value, float):
	yield _floatstr(value)
	continue
]:
	i: 228(for)
	o: 638()

nname: 228
n 228(None)[]:
	i: 0(loop)
	o: 235(for), 756(AF)

nname: 0
n 0(None)[if not dct:
	yield '{}'
	return None
if markers is not None:
	markerid = id(dct)
	if markerid in markers:
		raise ValueError('Circular reference detected')
	markers[markerid] = dct
yield '{'
if _indent is not None:
	_current_indent_level += 1
	newline_indent = '\n' + ' ' * _indent * _current_indent_level
	item_separator = _item_separator + newline_indent
	yield newline_indent
else:
	newline_indent = None
	item_separator = _item_separator
first = True
if _sort_keys:
	items = dct.items()
	items.sort(key=(lambda kv: kv[0]))
else:
	items = dct.iteritems()
]:
	i: 
	o: 228(loop), 756(AL)

nname: 756
n 756(None)[if newline_indent is not None:
	_current_indent_level -= 1
	yield '\n' + ' ' * _indent * _current_indent_level
yield '}'
if markers is not None:
	del markers[markerid]
return None
]:
	i: 0(AL), 228(AF), 235()
	o: 

nname: 235
n 235(None)[for key, value in items:
if isinstance(key, basestring):
	pass
else:
	if isinstance(key, float):
		key = _floatstr(key)
	else:
		if isinstance(key, (int, long)):
			key = str(key)
		else:
			if key is True:
				key = 'true'
			else:
				if key is False:
					key = 'false'
				else:
					if key is None:
						key = 'null'
					else:
						if _skipkeys:
							continue
						else:
							raise TypeError('key %r is not a string' % (key,))
if first:
	first = False
else:
	yield item_separator
yield _encoder(key)
yield _key_separator
if isinstance(value, basestring):
	yield _encoder(value)
	continue
if value is None:
	yield 'null'
	continue
if value is True:
	yield 'true'
	continue
if value is False:
	yield 'false'
	continue
if isinstance(value, (int, long)):
	yield str(value)
	continue
if isinstance(value, float):
	yield _floatstr(value)
	continue
if isinstance(value, (list, tuple)):
	chunks = _iterencode_list(value, _current_indent_level)
else:
	if isinstance(value, dict):
		chunks = _iterencode_dict(value, _current_indent_level)
	else:
		chunks = _iterencode(value, _current_indent_level)
for chunk in chunks:
	yield chunk
]:
	i: 228(for)
	o: 756()

nname: 228
n 228(None)[]:
	i: 0(loop)
	o: 235(for), 756(AF)

nname: 0
n 0(None)[if not dct:
	yield '{}'
	return None
if markers is not None:
	markerid = id(dct)
	if markerid in markers:
		raise ValueError('Circular reference detected')
	markers[markerid] = dct
yield '{'
if _indent is not None:
	_current_indent_level += 1
	newline_indent = '\n' + ' ' * _indent * _current_indent_level
	item_separator = _item_separator + newline_indent
	yield newline_indent
else:
	newline_indent = None
	item_separator = _item_separator
first = True
if _sort_keys:
	items = dct.items()
	items.sort(key=(lambda kv: kv[0]))
else:
	items = dct.iteritems()
]:
	i: 
	o: 228(loop), 756(AL)

self.nodes: {0: <unpyclib.structure.node instance at 0xb7585f8c>, 228: <unpyclib.structure.node instance at 0xb7570fec>, 235: <unpyclib.structure.node instance at 0xb75729cc>, 756: <unpyclib.structure.node instance at 0xb7572dec>}
nname: 408
n 408(None)[return None
]:
	i: 15(), 43(), 65(), 87(), 118(), 149(), 186(AL), 217(), 237(AL), 268(), 396(), 407()
	o: 

nname: 407
n 407(None)[]:
	i: 384(f)
	o: 408()

nname: 396
n 396(None)[del markers[markerid]
]:
	i: 384(t)
	o: 408()

nname: 384
n 384(markers is not None)[]:
	i: 341(AL), 383()
	o: 396(t), 407(f)

nname: 383
n 383(None)[]:
	i: 356(AF), 372()
	o: 384()

nname: 372
n 372(None)[for chunk in _iterencode(o, _current_indent_level):
yield chunk
]:
	i: 356(for)
	o: 383()

nname: 356
n 356(None)[]:
	i: 341(loop)
	o: 372(for), 383(AF)

nname: 341
n 341(None)[o = _default(o)
]:
	i: 327(), 340()
	o: 356(loop), 384(AL)

nname: 340
n 340(None)[]:
	i: 272(f)
	o: 341()

nname: 327
n 327(None)[markers[markerid] = o
]:
	i: 310(), 326()
	o: 341()

nname: 326
n 326(None)[]:
	i: 285(f)
	o: 327()

nname: 310
n 310(None)[raise ValueError('Circular reference detected')
]:
	i: 285(t)
	o: 327()

nname: 285
n 285(markerid in markers)[markerid = id(o)
]:
	i: 272(t)
	o: 310(t), 326(f)

nname: 272
n 272(markers is not None)[]:
	i: 221(f)
	o: 285(t), 340(f)

nname: 268
n 268(None)[]:
	i: 241(AF), 257()
	o: 408()

nname: 257
n 257(None)[for chunk in _iterencode_dict(o, _current_indent_level):
yield chunk
]:
	i: 241(for)
	o: 268()

nname: 241
n 241(None)[]:
	i: 237(loop)
	o: 257(for), 268(AF)

nname: 237
n 237(None)[]:
	i: 221(t)
	o: 241(loop), 408(AL)

nname: 221
n 221(isinstance(o, dict))[]:
	i: 164(f)
	o: 237(t), 272(f)

nname: 217
n 217(None)[]:
	i: 190(AF), 206()
	o: 408()

nname: 206
n 206(None)[for chunk in _iterencode_list(o, _current_indent_level):
yield chunk
]:
	i: 190(for)
	o: 217()

nname: 190
n 190(None)[]:
	i: 186(loop)
	o: 206(for), 217(AF)

nname: 186
n 186(None)[]:
	i: 164(t)
	o: 190(loop), 408(AL)

nname: 164
n 164(isinstance(o, (list, tuple)))[]:
	i: 133(f)
	o: 186(t), 221(f)

nname: 149
n 149(None)[yield _floatstr(o)
]:
	i: 133(t)
	o: 408()

nname: 133
n 133(isinstance(o, float))[]:
	i: 96(f)
	o: 149(t), 164(f)

nname: 118
n 118(None)[yield str(o)
]:
	i: 96(t)
	o: 408()

nname: 96
n 96(isinstance(o, (int, long)))[]:
	i: 74(f)
	o: 118(t), 133(f)

nname: 87
n 87(None)[yield 'false'
]:
	i: 74(t)
	o: 408()

nname: 74
n 74(o is False)[]:
	i: 52(f)
	o: 87(t), 96(f)

nname: 65
n 65(None)[yield 'true'
]:
	i: 52(t)
	o: 408()

nname: 52
n 52(o is True)[]:
	i: 30(f)
	o: 65(t), 74(f)

nname: 43
n 43(None)[yield 'null'
]:
	i: 30(t)
	o: 408()

nname: 30
n 30(o is None)[]:
	i: 0(f)
	o: 43(t), 52(f)

nname: 15
n 15(None)[yield _encoder(o)
]:
	i: 0(t)
	o: 408()

nname: 0
n 0(isinstance(o, basestring))[]:
	i: 
	o: 15(t), 30(f)

nname: 408
n 408(None)[return None
]:
	i: 15(), 43(), 65(), 87(), 118(), 149(), 206(), 257(), 384()
	o: 

nname: 384
n 384(None)[if markers is not None:
	del markers[markerid]
]:
	i: 372()
	o: 408()

nname: 372
n 372(None)[for chunk in _iterencode(o, _current_indent_level):
	yield chunk
]:
	i: 341(for)
	o: 384()

nname: 341
n 341(None)[o = _default(o)
]:
	i: 285(), 272(f)
	o: 372(for)

nname: 285
n 285(None)[markerid = id(o)
if markerid in markers:
	raise ValueError('Circular reference detected')
markers[markerid] = o
]:
	i: 272(t)
	o: 341()

nname: 272
n 272(markers is not None)[]:
	i: 221(f)
	o: 285(t), 341(f)

nname: 257
n 257(None)[for chunk in _iterencode_dict(o, _current_indent_level):
	yield chunk
]:
	i: 237(for)
	o: 408()

nname: 237
n 237(None)[]:
	i: 221(t)
	o: 257(for)

nname: 221
n 221(isinstance(o, dict))[]:
	i: 164(f)
	o: 237(t), 272(f)

nname: 206
n 206(None)[for chunk in _iterencode_list(o, _current_indent_level):
	yield chunk
]:
	i: 186(for)
	o: 408()

nname: 186
n 186(None)[]:
	i: 164(t)
	o: 206(for)

nname: 164
n 164(isinstance(o, (list, tuple)))[]:
	i: 133(f)
	o: 186(t), 221(f)

nname: 149
n 149(None)[yield _floatstr(o)
]:
	i: 133(t)
	o: 408()

nname: 133
n 133(isinstance(o, float))[]:
	i: 96(f)
	o: 149(t), 164(f)

nname: 118
n 118(None)[yield str(o)
]:
	i: 96(t)
	o: 408()

nname: 96
n 96(isinstance(o, (int, long)))[]:
	i: 74(f)
	o: 118(t), 133(f)

nname: 87
n 87(None)[yield 'false'
]:
	i: 74(t)
	o: 408()

nname: 74
n 74(o is False)[]:
	i: 52(f)
	o: 87(t), 96(f)

nname: 65
n 65(None)[yield 'true'
]:
	i: 52(t)
	o: 408()

nname: 52
n 52(o is True)[]:
	i: 30(f)
	o: 65(t), 74(f)

nname: 43
n 43(None)[yield 'null'
]:
	i: 30(t)
	o: 408()

nname: 30
n 30(o is None)[]:
	i: 0(f)
	o: 43(t), 52(f)

nname: 15
n 15(None)[yield _encoder(o)
]:
	i: 0(t)
	o: 408()

nname: 0
n 0(isinstance(o, basestring))[]:
	i: 
	o: 15(t), 30(f)

nname: 408
n 408(None)[return None
]:
	i: 15(), 43(), 65(), 87(), 118(), 149(), 186(), 237(), 372()
	o: 

nname: 372
n 372(None)[for chunk in _iterencode(o, _current_indent_level):
	yield chunk
if markers is not None:
	del markers[markerid]
]:
	i: 272(for)
	o: 408()

nname: 272
n 272(None)[if markers is not None:
	markerid = id(o)
	if markerid in markers:
		raise ValueError('Circular reference detected')
	markers[markerid] = o
o = _default(o)
]:
	i: 221(f)
	o: 372(for)

nname: 237
n 237(None)[for chunk in _iterencode_dict(o, _current_indent_level):
	yield chunk
]:
	i: 221(t)
	o: 408()

nname: 221
n 221(isinstance(o, dict))[]:
	i: 164(f)
	o: 237(t), 272(f)

nname: 186
n 186(None)[for chunk in _iterencode_list(o, _current_indent_level):
	yield chunk
]:
	i: 164(t)
	o: 408()

nname: 164
n 164(isinstance(o, (list, tuple)))[]:
	i: 133(f)
	o: 186(t), 221(f)

nname: 149
n 149(None)[yield _floatstr(o)
]:
	i: 133(t)
	o: 408()

nname: 133
n 133(isinstance(o, float))[]:
	i: 96(f)
	o: 149(t), 164(f)

nname: 118
n 118(None)[yield str(o)
]:
	i: 96(t)
	o: 408()

nname: 96
n 96(isinstance(o, (int, long)))[]:
	i: 74(f)
	o: 118(t), 133(f)

nname: 87
n 87(None)[yield 'false'
]:
	i: 74(t)
	o: 408()

nname: 74
n 74(o is False)[]:
	i: 52(f)
	o: 87(t), 96(f)

nname: 65
n 65(None)[yield 'true'
]:
	i: 52(t)
	o: 408()

nname: 52
n 52(o is True)[]:
	i: 30(f)
	o: 65(t), 74(f)

nname: 43
n 43(None)[yield 'null'
]:
	i: 30(t)
	o: 408()

nname: 30
n 30(o is None)[]:
	i: 0(f)
	o: 43(t), 52(f)

nname: 15
n 15(None)[yield _encoder(o)
]:
	i: 0(t)
	o: 408()

nname: 0
n 0(isinstance(o, basestring))[]:
	i: 
	o: 15(t), 30(f)

nname: 408
n 408(None)[return None
]:
	i: 15(), 43(), 65(), 87(), 118(), 149(), 186(), 237(), 272()
	o: 

nname: 272
n 272(None)[if markers is not None:
	markerid = id(o)
	if markerid in markers:
		raise ValueError('Circular reference detected')
	markers[markerid] = o
o = _default(o)
for chunk in _iterencode(o, _current_indent_level):
	yield chunk
if markers is not None:
	del markers[markerid]
]:
	i: 221(f)
	o: 408()

nname: 237
n 237(None)[for chunk in _iterencode_dict(o, _current_indent_level):
	yield chunk
]:
	i: 221(t)
	o: 408()

nname: 221
n 221(isinstance(o, dict))[]:
	i: 164(f)
	o: 237(t), 272(f)

nname: 186
n 186(None)[for chunk in _iterencode_list(o, _current_indent_level):
	yield chunk
]:
	i: 164(t)
	o: 408()

nname: 164
n 164(isinstance(o, (list, tuple)))[]:
	i: 133(f)
	o: 186(t), 221(f)

nname: 149
n 149(None)[yield _floatstr(o)
]:
	i: 133(t)
	o: 408()

nname: 133
n 133(isinstance(o, float))[]:
	i: 96(f)
	o: 149(t), 164(f)

nname: 118
n 118(None)[yield str(o)
]:
	i: 96(t)
	o: 408()

nname: 96
n 96(isinstance(o, (int, long)))[]:
	i: 74(f)
	o: 118(t), 133(f)

nname: 87
n 87(None)[yield 'false'
]:
	i: 74(t)
	o: 408()

nname: 74
n 74(o is False)[]:
	i: 52(f)
	o: 87(t), 96(f)

nname: 65
n 65(None)[yield 'true'
]:
	i: 52(t)
	o: 408()

nname: 52
n 52(o is True)[]:
	i: 30(f)
	o: 65(t), 74(f)

nname: 43
n 43(None)[yield 'null'
]:
	i: 30(t)
	o: 408()

nname: 30
n 30(o is None)[]:
	i: 0(f)
	o: 43(t), 52(f)

nname: 15
n 15(None)[yield _encoder(o)
]:
	i: 0(t)
	o: 408()

nname: 0
n 0(isinstance(o, basestring))[]:
	i: 
	o: 15(t), 30(f)

nname: 0
n 0(None)[if isinstance(o, basestring):
	yield _encoder(o)
else:
	if o is None:
		yield 'null'
	else:
		if o is True:
			yield 'true'
		else:
			if o is False:
				yield 'false'
			else:
				if isinstance(o, (int, long)):
					yield str(o)
				else:
					if isinstance(o, float):
						yield _floatstr(o)
					else:
						if isinstance(o, (list, tuple)):
							for chunk in _iterencode_list(o, _current_indent_level):
								yield chunk
						else:
							if isinstance(o, dict):
								for chunk in _iterencode_dict(o, _current_indent_level):
									yield chunk
							else:
								if markers is not None:
									markerid = id(o)
									if markerid in markers:
										raise ValueError('Circular reference detected')
									markers[markerid] = o
								o = _default(o)
								for chunk in _iterencode(o, _current_indent_level):
									yield chunk
								if markers is not None:
									del markers[markerid]
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb756686c>}
nname: 0
n 0(None)[def _iterencode_list(lst, _current_indent_level):
	if not lst:
		yield '[]'
		return None
	if markers is not None:
		markerid = id(lst)
		if markerid in markers:
			raise ValueError('Circular reference detected')
		markers[markerid] = lst
	buf = '['
	if _indent is not None:
		_current_indent_level += 1
		newline_indent = '\n' + ' ' * _indent * _current_indent_level
		separator = _item_separator + newline_indent
		buf += newline_indent
	else:
		newline_indent = None
		separator = _item_separator
	first = True

def _iterencode_dict(dct, _current_indent_level):
	if not dct:
		yield '{}'
		return None
	if markers is not None:
		markerid = id(dct)
		if markerid in markers:
			raise ValueError('Circular reference detected')
		markers[markerid] = dct
	yield '{'
	if _indent is not None:
		_current_indent_level += 1
		newline_indent = '\n' + ' ' * _indent * _current_indent_level
		item_separator = _item_separator + newline_indent
		yield newline_indent
	else:
		newline_indent = None
		item_separator = _item_separator
	first = True
	if _sort_keys:
		items = dct.items()
		items.sort(key=(lambda kv: kv[0]))
	else:
		items = dct.iteritems()

def _iterencode(o, _current_indent_level):
	if isinstance(o, basestring):
		yield _encoder(o)
	else:
		if o is None:
			yield 'null'
		else:
			if o is True:
				yield 'true'
			else:
				if o is False:
					yield 'false'
				else:
					if isinstance(o, (int, long)):
						yield str(o)
					else:
						if isinstance(o, float):
							yield _floatstr(o)
						else:
							if isinstance(o, (list, tuple)):
								for chunk in _iterencode_list(o, _current_indent_level):
									yield chunk
							else:
								if isinstance(o, dict):
									for chunk in _iterencode_dict(o, _current_indent_level):
										yield chunk
								else:
									if markers is not None:
										markerid = id(o)
										if markerid in markers:
											raise ValueError('Circular reference detected')
										markers[markerid] = o
									o = _default(o)
									for chunk in _iterencode(o, _current_indent_level):
										yield chunk
									if markers is not None:
										del markers[markerid]
	return None

return _iterencode
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb755b18c>}
nname: 326
n 326(None)[encode_basestring_ascii = c_encode_basestring_ascii
class JSONEncoder(object):
	__doc__ = 'Extensible JSON <http://json.org> encoder for Python data structures.\n\n    Supports the following objects and types by default:\n\n    +-------------------+---------------+\n    | Python            | JSON          |\n    +===================+===============+\n    | dict              | object        |\n    +-------------------+---------------+\n    | list, tuple       | array         |\n    +-------------------+---------------+\n    | str, unicode      | string        |\n    +-------------------+---------------+\n    | int, long, float  | number        |\n    +-------------------+---------------+\n    | True              | true          |\n    +-------------------+---------------+\n    | False             | false         |\n    +-------------------+---------------+\n    | None              | null          |\n    +-------------------+---------------+\n\n    To extend this to recognize other objects, subclass and implement a\n    ``.default()`` method with another method that returns a serializable\n    object for ``o`` if possible, otherwise it should call the superclass\n    implementation (to raise ``TypeError``).\n\n    '
	item_separator = ', '
	key_separator = ': '
	def __init__(self, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, sort_keys=False, indent=None, separators=None, encoding='utf-8', default=None):
		self.skipkeys = skipkeys
		self.ensure_ascii = ensure_ascii
		self.check_circular = check_circular
		self.allow_nan = allow_nan
		self.sort_keys = sort_keys
		self.indent = indent
		if separators is not None:
			self.item_separator, self.key_separator = separators
		if default is not None:
			self.default = default
		self.encoding = encoding
		return None

	def default(self, o):
		raise TypeError('%r is not JSON serializable' % (o,))

	def encode(self, o):
		if isinstance(o, basestring):
			if isinstance(o, str):
				_encoding = self.encoding
				if _encoding is not None and not _encoding == 'utf-8':
					o = o.decode(_encoding)
			if self.ensure_ascii:
				return encode_basestring_ascii(o)
			else:
				return encode_basestring(o)
		chunks = self.iterencode(o, _one_shot=True)
		if not isinstance(chunks, (list, tuple)):
			chunks = list(chunks)
		return ''.join(chunks)

	def iterencode(self, o, _one_shot=False):
		if self.check_circular:
			markers = {}
		else:
			markers = None
		if self.ensure_ascii:
			_encoder = encode_basestring_ascii
		else:
			_encoder = encode_basestring
		if self.encoding != 'utf-8':
			def _encoder(o, _orig_encoder=_encoder, _encoding=self.encoding):
				if isinstance(o, str):
					o = o.decode(_encoding)
				return _orig_encoder(o)

		def floatstr(o, allow_nan=self.allow_nan, _repr=FLOAT_REPR, _inf=INFINITY, _neginf=-INFINITY):
			if o != o:
				text = 'NaN'
			else:
				if o == _inf:
					text = 'Infinity'
				else:
					if o == _neginf:
						text = '-Infinity'
					else:
						return _repr(o)
			if not allow_nan:
				raise ValueError('Out of range float values are not JSON compliant: %r' % (o,))
			return text

		if _one_shot and c_make_encoder is not None and not self.indent and not self.sort_keys:
			_iterencode = c_make_encoder(markers, self.default, _encoder, self.indent, self.key_separator, self.item_separator, self.sort_keys, self.skipkeys, self.allow_nan)
		else:
			_iterencode = _make_iterencode(markers, self.default, _encoder, self.indent, floatstr, self.key_separator, self.item_separator, self.sort_keys, self.skipkeys, _one_shot)
		return _iterencode(o, 0)



def _make_iterencode(markers, _default, _encoder, _indent, _floatstr, _key_separator, _item_separator, _sort_keys, _skipkeys, _one_shot, False=False, True=True, ValueError=ValueError, basestring=basestring, dict=dict, float=float, id=id, int=int, isinstance=isinstance, list=list, long=long, str=str, tuple=tuple):
	def _iterencode_list(lst, _current_indent_level):
		if not lst:
			yield '[]'
			return None
		if markers is not None:
			markerid = id(lst)
			if markerid in markers:
				raise ValueError('Circular reference detected')
			markers[markerid] = lst
		buf = '['
		if _indent is not None:
			_current_indent_level += 1
			newline_indent = '\n' + ' ' * _indent * _current_indent_level
			separator = _item_separator + newline_indent
			buf += newline_indent
		else:
			newline_indent = None
			separator = _item_separator
		first = True

	def _iterencode_dict(dct, _current_indent_level):
		if not dct:
			yield '{}'
			return None
		if markers is not None:
			markerid = id(dct)
			if markerid in markers:
				raise ValueError('Circular reference detected')
			markers[markerid] = dct
		yield '{'
		if _indent is not None:
			_current_indent_level += 1
			newline_indent = '\n' + ' ' * _indent * _current_indent_level
			item_separator = _item_separator + newline_indent
			yield newline_indent
		else:
			newline_indent = None
			item_separator = _item_separator
		first = True
		if _sort_keys:
			items = dct.items()
			items.sort(key=(lambda kv: kv[0]))
		else:
			items = dct.iteritems()

	def _iterencode(o, _current_indent_level):
		if isinstance(o, basestring):
			yield _encoder(o)
		else:
			if o is None:
				yield 'null'
			else:
				if o is True:
					yield 'true'
				else:
					if o is False:
						yield 'false'
					else:
						if isinstance(o, (int, long)):
							yield str(o)
						else:
							if isinstance(o, float):
								yield _floatstr(o)
							else:
								if isinstance(o, (list, tuple)):
									for chunk in _iterencode_list(o, _current_indent_level):
										yield chunk
								else:
									if isinstance(o, dict):
										for chunk in _iterencode_dict(o, _current_indent_level):
											yield chunk
									else:
										if markers is not None:
											markerid = id(o)
											if markerid in markers:
												raise ValueError('Circular reference detected')
											markers[markerid] = o
										o = _default(o)
										for chunk in _iterencode(o, _current_indent_level):
											yield chunk
										if markers is not None:
											del markers[markerid]
		return None

	return _iterencode

]:
	i: 280(t), 322()
	o: 

nname: 322
n 322(None)[]:
	i: 280(f)
	o: 326()

nname: 280
n 280(c_encode_basestring_ascii)[INFINITY = float('1e66666')
FLOAT_REPR = repr
def encode_basestring(s):
	def replace(match):
		return ESCAPE_DCT[match.group(0)]

	return '"' + ESCAPE.sub(replace, s) + '"'

def py_encode_basestring_ascii(s):
	if isinstance(s, str) and HAS_UTF8.search(s) is not None:
		s = s.decode('utf-8')
	def replace(match):
		s = match.group(0)
		try:
			return ESCAPE_DCT[s]
		except KeyError:
			n = ord(s)
			if n < 65536:
				return '\\u%04x' % (n,)
			else:
				n -= 65536
				s1 = 55296 | n >> 10 & 1023
				s2 = 56320 | n & 1023
				return '\\u%04x\\u%04x' % (s1, s2)

	return '"' + str(ESCAPE_ASCII.sub(replace, s)) + '"'

]:
	i: 114(AL), 279()
	o: 322(f), 326(t)

nname: 279
n 279(None)[]:
	i: 231(AF), 244()
	o: 280()

nname: 244
n 244(None)[for i in range(32):
ESCAPE_DCT.setdefault(chr(i), '\\u%04x' % (i,))
]:
	i: 231(for)
	o: 279()

nname: 231
n 231(None)[]:
	i: 114(loop)
	o: 244(for), 279(AF)

nname: 114
n 114(None)[ESCAPE = re.compile('[\\x00-\\x1f\\\\"\\b\\f\\n\\r\\t]')
ESCAPE_ASCII = re.compile('([\\\\"]|[^\\ -~])')
HAS_UTF8 = re.compile('[\\x80-\\xff]')
ESCAPE_DCT = {'\\': '\\\\', '"': '\\"', '\x08': '\\b', '\x0c': '\\f', '\n': '\\n', '\r': '\\r', '\t': '\\t'}
]:
	i: 69(), 99(), 112(AE)
	o: 231(loop), 280(AL)

nname: 112
n 112(None)[]:
	i: 89(f)
	o: 114(AE)

nname: 99
n 99(None)[c_make_encoder = None
]:
	i: 89(t)
	o: 114()

nname: 89
n 89(<dummy_ex3> EXC_MATCH ImportError)[]:
	i: 66(except)
	o: 99(t), 112(f)

nname: 69
n 69(None)[from simplejson._speedups import make_encoder as c_make_encoder
]:
	i: 66(try)
	o: 114()

nname: 66
n 66(None)[]:
	i: 21(), 51(), 64(AE)
	o: 69(try), 89(except)

nname: 64
n 64(None)[]:
	i: 41(f)
	o: 66(AE)

nname: 51
n 51(None)[c_encode_basestring_ascii = None
]:
	i: 41(t)
	o: 66()

nname: 41
n 41(<dummy_ex3> EXC_MATCH ImportError)[]:
	i: 0(except)
	o: 51(t), 64(f)

nname: 21
n 21(None)[from simplejson._speedups import encode_basestring_ascii as c_encode_basestring_ascii
]:
	i: 0(try)
	o: 66()

nname: 0
n 0(None)[__doc__ = 'Implementation of JSONEncoder\n'
import re
]:
	i: 
	o: 21(try), 41(except)

nname: 280
n 280(None)[INFINITY = float('1e66666')
FLOAT_REPR = repr
def encode_basestring(s):
	def replace(match):
		return ESCAPE_DCT[match.group(0)]

	return '"' + ESCAPE.sub(replace, s) + '"'

def py_encode_basestring_ascii(s):
	if isinstance(s, str) and HAS_UTF8.search(s) is not None:
		s = s.decode('utf-8')
	def replace(match):
		s = match.group(0)
		try:
			return ESCAPE_DCT[s]
		except KeyError:
			n = ord(s)
			if n < 65536:
				return '\\u%04x' % (n,)
			else:
				n -= 65536
				s1 = 55296 | n >> 10 & 1023
				s2 = 56320 | n & 1023
				return '\\u%04x\\u%04x' % (s1, s2)

	return '"' + str(ESCAPE_ASCII.sub(replace, s)) + '"'

if not c_encode_basestring_ascii:
	pass
encode_basestring_ascii = c_encode_basestring_ascii
class JSONEncoder(object):
	__doc__ = 'Extensible JSON <http://json.org> encoder for Python data structures.\n\n    Supports the following objects and types by default:\n\n    +-------------------+---------------+\n    | Python            | JSON          |\n    +===================+===============+\n    | dict              | object        |\n    +-------------------+---------------+\n    | list, tuple       | array         |\n    +-------------------+---------------+\n    | str, unicode      | string        |\n    +-------------------+---------------+\n    | int, long, float  | number        |\n    +-------------------+---------------+\n    | True              | true          |\n    +-------------------+---------------+\n    | False             | false         |\n    +-------------------+---------------+\n    | None              | null          |\n    +-------------------+---------------+\n\n    To extend this to recognize other objects, subclass and implement a\n    ``.default()`` method with another method that returns a serializable\n    object for ``o`` if possible, otherwise it should call the superclass\n    implementation (to raise ``TypeError``).\n\n    '
	item_separator = ', '
	key_separator = ': '
	def __init__(self, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, sort_keys=False, indent=None, separators=None, encoding='utf-8', default=None):
		self.skipkeys = skipkeys
		self.ensure_ascii = ensure_ascii
		self.check_circular = check_circular
		self.allow_nan = allow_nan
		self.sort_keys = sort_keys
		self.indent = indent
		if separators is not None:
			self.item_separator, self.key_separator = separators
		if default is not None:
			self.default = default
		self.encoding = encoding
		return None

	def default(self, o):
		raise TypeError('%r is not JSON serializable' % (o,))

	def encode(self, o):
		if isinstance(o, basestring):
			if isinstance(o, str):
				_encoding = self.encoding
				if _encoding is not None and not _encoding == 'utf-8':
					o = o.decode(_encoding)
			if self.ensure_ascii:
				return encode_basestring_ascii(o)
			else:
				return encode_basestring(o)
		chunks = self.iterencode(o, _one_shot=True)
		if not isinstance(chunks, (list, tuple)):
			chunks = list(chunks)
		return ''.join(chunks)

	def iterencode(self, o, _one_shot=False):
		if self.check_circular:
			markers = {}
		else:
			markers = None
		if self.ensure_ascii:
			_encoder = encode_basestring_ascii
		else:
			_encoder = encode_basestring
		if self.encoding != 'utf-8':
			def _encoder(o, _orig_encoder=_encoder, _encoding=self.encoding):
				if isinstance(o, str):
					o = o.decode(_encoding)
				return _orig_encoder(o)

		def floatstr(o, allow_nan=self.allow_nan, _repr=FLOAT_REPR, _inf=INFINITY, _neginf=-INFINITY):
			if o != o:
				text = 'NaN'
			else:
				if o == _inf:
					text = 'Infinity'
				else:
					if o == _neginf:
						text = '-Infinity'
					else:
						return _repr(o)
			if not allow_nan:
				raise ValueError('Out of range float values are not JSON compliant: %r' % (o,))
			return text

		if _one_shot and c_make_encoder is not None and not self.indent and not self.sort_keys:
			_iterencode = c_make_encoder(markers, self.default, _encoder, self.indent, self.key_separator, self.item_separator, self.sort_keys, self.skipkeys, self.allow_nan)
		else:
			_iterencode = _make_iterencode(markers, self.default, _encoder, self.indent, floatstr, self.key_separator, self.item_separator, self.sort_keys, self.skipkeys, _one_shot)
		return _iterencode(o, 0)



def _make_iterencode(markers, _default, _encoder, _indent, _floatstr, _key_separator, _item_separator, _sort_keys, _skipkeys, _one_shot, False=False, True=True, ValueError=ValueError, basestring=basestring, dict=dict, float=float, id=id, int=int, isinstance=isinstance, list=list, long=long, str=str, tuple=tuple):
	def _iterencode_list(lst, _current_indent_level):
		if not lst:
			yield '[]'
			return None
		if markers is not None:
			markerid = id(lst)
			if markerid in markers:
				raise ValueError('Circular reference detected')
			markers[markerid] = lst
		buf = '['
		if _indent is not None:
			_current_indent_level += 1
			newline_indent = '\n' + ' ' * _indent * _current_indent_level
			separator = _item_separator + newline_indent
			buf += newline_indent
		else:
			newline_indent = None
			separator = _item_separator
		first = True

	def _iterencode_dict(dct, _current_indent_level):
		if not dct:
			yield '{}'
			return None
		if markers is not None:
			markerid = id(dct)
			if markerid in markers:
				raise ValueError('Circular reference detected')
			markers[markerid] = dct
		yield '{'
		if _indent is not None:
			_current_indent_level += 1
			newline_indent = '\n' + ' ' * _indent * _current_indent_level
			item_separator = _item_separator + newline_indent
			yield newline_indent
		else:
			newline_indent = None
			item_separator = _item_separator
		first = True
		if _sort_keys:
			items = dct.items()
			items.sort(key=(lambda kv: kv[0]))
		else:
			items = dct.iteritems()

	def _iterencode(o, _current_indent_level):
		if isinstance(o, basestring):
			yield _encoder(o)
		else:
			if o is None:
				yield 'null'
			else:
				if o is True:
					yield 'true'
				else:
					if o is False:
						yield 'false'
					else:
						if isinstance(o, (int, long)):
							yield str(o)
						else:
							if isinstance(o, float):
								yield _floatstr(o)
							else:
								if isinstance(o, (list, tuple)):
									for chunk in _iterencode_list(o, _current_indent_level):
										yield chunk
								else:
									if isinstance(o, dict):
										for chunk in _iterencode_dict(o, _current_indent_level):
											yield chunk
									else:
										if markers is not None:
											markerid = id(o)
											if markerid in markers:
												raise ValueError('Circular reference detected')
											markers[markerid] = o
										o = _default(o)
										for chunk in _iterencode(o, _current_indent_level):
											yield chunk
										if markers is not None:
											del markers[markerid]
		return None

	return _iterencode

]:
	i: 244()
	o: 

nname: 244
n 244(None)[for i in range(32):
	ESCAPE_DCT.setdefault(chr(i), '\\u%04x' % (i,))
]:
	i: 114(for)
	o: 280()

nname: 114
n 114(None)[ESCAPE = re.compile('[\\x00-\\x1f\\\\"\\b\\f\\n\\r\\t]')
ESCAPE_ASCII = re.compile('([\\\\"]|[^\\ -~])')
HAS_UTF8 = re.compile('[\\x80-\\xff]')
ESCAPE_DCT = {'\\': '\\\\', '"': '\\"', '\x08': '\\b', '\x0c': '\\f', '\n': '\\n', '\r': '\\r', '\t': '\\t'}
]:
	i: 69()
	o: 244(for)

nname: 69
n 69(None)[try:
	from simplejson._speedups import make_encoder as c_make_encoder
except ImportError:
	c_make_encoder = None
]:
	i: 41(try)
	o: 114()

nname: 41
n 41(None)[except ImportError:
	c_encode_basestring_ascii = None
]:
	i: 0()
	o: 69(try)

nname: 0
n 0(None)[__doc__ = 'Implementation of JSONEncoder\n'
import re
try:
	from simplejson._speedups import encode_basestring_ascii as c_encode_basestring_ascii
]:
	i: 
	o: 41()

nname: 244
n 244(None)[for i in range(32):
	ESCAPE_DCT.setdefault(chr(i), '\\u%04x' % (i,))
INFINITY = float('1e66666')
FLOAT_REPR = repr
def encode_basestring(s):
	def replace(match):
		return ESCAPE_DCT[match.group(0)]

	return '"' + ESCAPE.sub(replace, s) + '"'

def py_encode_basestring_ascii(s):
	if isinstance(s, str) and HAS_UTF8.search(s) is not None:
		s = s.decode('utf-8')
	def replace(match):
		s = match.group(0)
		try:
			return ESCAPE_DCT[s]
		except KeyError:
			n = ord(s)
			if n < 65536:
				return '\\u%04x' % (n,)
			else:
				n -= 65536
				s1 = 55296 | n >> 10 & 1023
				s2 = 56320 | n & 1023
				return '\\u%04x\\u%04x' % (s1, s2)

	return '"' + str(ESCAPE_ASCII.sub(replace, s)) + '"'

if not c_encode_basestring_ascii:
	pass
encode_basestring_ascii = c_encode_basestring_ascii
class JSONEncoder(object):
	__doc__ = 'Extensible JSON <http://json.org> encoder for Python data structures.\n\n    Supports the following objects and types by default:\n\n    +-------------------+---------------+\n    | Python            | JSON          |\n    +===================+===============+\n    | dict              | object        |\n    +-------------------+---------------+\n    | list, tuple       | array         |\n    +-------------------+---------------+\n    | str, unicode      | string        |\n    +-------------------+---------------+\n    | int, long, float  | number        |\n    +-------------------+---------------+\n    | True              | true          |\n    +-------------------+---------------+\n    | False             | false         |\n    +-------------------+---------------+\n    | None              | null          |\n    +-------------------+---------------+\n\n    To extend this to recognize other objects, subclass and implement a\n    ``.default()`` method with another method that returns a serializable\n    object for ``o`` if possible, otherwise it should call the superclass\n    implementation (to raise ``TypeError``).\n\n    '
	item_separator = ', '
	key_separator = ': '
	def __init__(self, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, sort_keys=False, indent=None, separators=None, encoding='utf-8', default=None):
		self.skipkeys = skipkeys
		self.ensure_ascii = ensure_ascii
		self.check_circular = check_circular
		self.allow_nan = allow_nan
		self.sort_keys = sort_keys
		self.indent = indent
		if separators is not None:
			self.item_separator, self.key_separator = separators
		if default is not None:
			self.default = default
		self.encoding = encoding
		return None

	def default(self, o):
		raise TypeError('%r is not JSON serializable' % (o,))

	def encode(self, o):
		if isinstance(o, basestring):
			if isinstance(o, str):
				_encoding = self.encoding
				if _encoding is not None and not _encoding == 'utf-8':
					o = o.decode(_encoding)
			if self.ensure_ascii:
				return encode_basestring_ascii(o)
			else:
				return encode_basestring(o)
		chunks = self.iterencode(o, _one_shot=True)
		if not isinstance(chunks, (list, tuple)):
			chunks = list(chunks)
		return ''.join(chunks)

	def iterencode(self, o, _one_shot=False):
		if self.check_circular:
			markers = {}
		else:
			markers = None
		if self.ensure_ascii:
			_encoder = encode_basestring_ascii
		else:
			_encoder = encode_basestring
		if self.encoding != 'utf-8':
			def _encoder(o, _orig_encoder=_encoder, _encoding=self.encoding):
				if isinstance(o, str):
					o = o.decode(_encoding)
				return _orig_encoder(o)

		def floatstr(o, allow_nan=self.allow_nan, _repr=FLOAT_REPR, _inf=INFINITY, _neginf=-INFINITY):
			if o != o:
				text = 'NaN'
			else:
				if o == _inf:
					text = 'Infinity'
				else:
					if o == _neginf:
						text = '-Infinity'
					else:
						return _repr(o)
			if not allow_nan:
				raise ValueError('Out of range float values are not JSON compliant: %r' % (o,))
			return text

		if _one_shot and c_make_encoder is not None and not self.indent and not self.sort_keys:
			_iterencode = c_make_encoder(markers, self.default, _encoder, self.indent, self.key_separator, self.item_separator, self.sort_keys, self.skipkeys, self.allow_nan)
		else:
			_iterencode = _make_iterencode(markers, self.default, _encoder, self.indent, floatstr, self.key_separator, self.item_separator, self.sort_keys, self.skipkeys, _one_shot)
		return _iterencode(o, 0)



def _make_iterencode(markers, _default, _encoder, _indent, _floatstr, _key_separator, _item_separator, _sort_keys, _skipkeys, _one_shot, False=False, True=True, ValueError=ValueError, basestring=basestring, dict=dict, float=float, id=id, int=int, isinstance=isinstance, list=list, long=long, str=str, tuple=tuple):
	def _iterencode_list(lst, _current_indent_level):
		if not lst:
			yield '[]'
			return None
		if markers is not None:
			markerid = id(lst)
			if markerid in markers:
				raise ValueError('Circular reference detected')
			markers[markerid] = lst
		buf = '['
		if _indent is not None:
			_current_indent_level += 1
			newline_indent = '\n' + ' ' * _indent * _current_indent_level
			separator = _item_separator + newline_indent
			buf += newline_indent
		else:
			newline_indent = None
			separator = _item_separator
		first = True

	def _iterencode_dict(dct, _current_indent_level):
		if not dct:
			yield '{}'
			return None
		if markers is not None:
			markerid = id(dct)
			if markerid in markers:
				raise ValueError('Circular reference detected')
			markers[markerid] = dct
		yield '{'
		if _indent is not None:
			_current_indent_level += 1
			newline_indent = '\n' + ' ' * _indent * _current_indent_level
			item_separator = _item_separator + newline_indent
			yield newline_indent
		else:
			newline_indent = None
			item_separator = _item_separator
		first = True
		if _sort_keys:
			items = dct.items()
			items.sort(key=(lambda kv: kv[0]))
		else:
			items = dct.iteritems()

	def _iterencode(o, _current_indent_level):
		if isinstance(o, basestring):
			yield _encoder(o)
		else:
			if o is None:
				yield 'null'
			else:
				if o is True:
					yield 'true'
				else:
					if o is False:
						yield 'false'
					else:
						if isinstance(o, (int, long)):
							yield str(o)
						else:
							if isinstance(o, float):
								yield _floatstr(o)
							else:
								if isinstance(o, (list, tuple)):
									for chunk in _iterencode_list(o, _current_indent_level):
										yield chunk
								else:
									if isinstance(o, dict):
										for chunk in _iterencode_dict(o, _current_indent_level):
											yield chunk
									else:
										if markers is not None:
											markerid = id(o)
											if markerid in markers:
												raise ValueError('Circular reference detected')
											markers[markerid] = o
										o = _default(o)
										for chunk in _iterencode(o, _current_indent_level):
											yield chunk
										if markers is not None:
											del markers[markerid]
		return None

	return _iterencode

]:
	i: 69(for)
	o: 

nname: 69
n 69(None)[try:
	from simplejson._speedups import make_encoder as c_make_encoder
except ImportError:
	c_make_encoder = None
ESCAPE = re.compile('[\\x00-\\x1f\\\\"\\b\\f\\n\\r\\t]')
ESCAPE_ASCII = re.compile('([\\\\"]|[^\\ -~])')
HAS_UTF8 = re.compile('[\\x80-\\xff]')
ESCAPE_DCT = {'\\': '\\\\', '"': '\\"', '\x08': '\\b', '\x0c': '\\f', '\n': '\\n', '\r': '\\r', '\t': '\\t'}
]:
	i: 0(try)
	o: 244(for)

nname: 0
n 0(None)[__doc__ = 'Implementation of JSONEncoder\n'
import re
try:
	from simplejson._speedups import encode_basestring_ascii as c_encode_basestring_ascii
except ImportError:
	c_encode_basestring_ascii = None
]:
	i: 
	o: 69(try)

nname: 244
n 244(None)[for i in range(32):
	ESCAPE_DCT.setdefault(chr(i), '\\u%04x' % (i,))
INFINITY = float('1e66666')
FLOAT_REPR = repr
def encode_basestring(s):
	def replace(match):
		return ESCAPE_DCT[match.group(0)]

	return '"' + ESCAPE.sub(replace, s) + '"'

def py_encode_basestring_ascii(s):
	if isinstance(s, str) and HAS_UTF8.search(s) is not None:
		s = s.decode('utf-8')
	def replace(match):
		s = match.group(0)
		try:
			return ESCAPE_DCT[s]
		except KeyError:
			n = ord(s)
			if n < 65536:
				return '\\u%04x' % (n,)
			else:
				n -= 65536
				s1 = 55296 | n >> 10 & 1023
				s2 = 56320 | n & 1023
				return '\\u%04x\\u%04x' % (s1, s2)

	return '"' + str(ESCAPE_ASCII.sub(replace, s)) + '"'

if not c_encode_basestring_ascii:
	pass
encode_basestring_ascii = c_encode_basestring_ascii
class JSONEncoder(object):
	__doc__ = 'Extensible JSON <http://json.org> encoder for Python data structures.\n\n    Supports the following objects and types by default:\n\n    +-------------------+---------------+\n    | Python            | JSON          |\n    +===================+===============+\n    | dict              | object        |\n    +-------------------+---------------+\n    | list, tuple       | array         |\n    +-------------------+---------------+\n    | str, unicode      | string        |\n    +-------------------+---------------+\n    | int, long, float  | number        |\n    +-------------------+---------------+\n    | True              | true          |\n    +-------------------+---------------+\n    | False             | false         |\n    +-------------------+---------------+\n    | None              | null          |\n    +-------------------+---------------+\n\n    To extend this to recognize other objects, subclass and implement a\n    ``.default()`` method with another method that returns a serializable\n    object for ``o`` if possible, otherwise it should call the superclass\n    implementation (to raise ``TypeError``).\n\n    '
	item_separator = ', '
	key_separator = ': '
	def __init__(self, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, sort_keys=False, indent=None, separators=None, encoding='utf-8', default=None):
		self.skipkeys = skipkeys
		self.ensure_ascii = ensure_ascii
		self.check_circular = check_circular
		self.allow_nan = allow_nan
		self.sort_keys = sort_keys
		self.indent = indent
		if separators is not None:
			self.item_separator, self.key_separator = separators
		if default is not None:
			self.default = default
		self.encoding = encoding
		return None

	def default(self, o):
		raise TypeError('%r is not JSON serializable' % (o,))

	def encode(self, o):
		if isinstance(o, basestring):
			if isinstance(o, str):
				_encoding = self.encoding
				if _encoding is not None and not _encoding == 'utf-8':
					o = o.decode(_encoding)
			if self.ensure_ascii:
				return encode_basestring_ascii(o)
			else:
				return encode_basestring(o)
		chunks = self.iterencode(o, _one_shot=True)
		if not isinstance(chunks, (list, tuple)):
			chunks = list(chunks)
		return ''.join(chunks)

	def iterencode(self, o, _one_shot=False):
		if self.check_circular:
			markers = {}
		else:
			markers = None
		if self.ensure_ascii:
			_encoder = encode_basestring_ascii
		else:
			_encoder = encode_basestring
		if self.encoding != 'utf-8':
			def _encoder(o, _orig_encoder=_encoder, _encoding=self.encoding):
				if isinstance(o, str):
					o = o.decode(_encoding)
				return _orig_encoder(o)

		def floatstr(o, allow_nan=self.allow_nan, _repr=FLOAT_REPR, _inf=INFINITY, _neginf=-INFINITY):
			if o != o:
				text = 'NaN'
			else:
				if o == _inf:
					text = 'Infinity'
				else:
					if o == _neginf:
						text = '-Infinity'
					else:
						return _repr(o)
			if not allow_nan:
				raise ValueError('Out of range float values are not JSON compliant: %r' % (o,))
			return text

		if _one_shot and c_make_encoder is not None and not self.indent and not self.sort_keys:
			_iterencode = c_make_encoder(markers, self.default, _encoder, self.indent, self.key_separator, self.item_separator, self.sort_keys, self.skipkeys, self.allow_nan)
		else:
			_iterencode = _make_iterencode(markers, self.default, _encoder, self.indent, floatstr, self.key_separator, self.item_separator, self.sort_keys, self.skipkeys, _one_shot)
		return _iterencode(o, 0)



def _make_iterencode(markers, _default, _encoder, _indent, _floatstr, _key_separator, _item_separator, _sort_keys, _skipkeys, _one_shot, False=False, True=True, ValueError=ValueError, basestring=basestring, dict=dict, float=float, id=id, int=int, isinstance=isinstance, list=list, long=long, str=str, tuple=tuple):
	def _iterencode_list(lst, _current_indent_level):
		if not lst:
			yield '[]'
			return None
		if markers is not None:
			markerid = id(lst)
			if markerid in markers:
				raise ValueError('Circular reference detected')
			markers[markerid] = lst
		buf = '['
		if _indent is not None:
			_current_indent_level += 1
			newline_indent = '\n' + ' ' * _indent * _current_indent_level
			separator = _item_separator + newline_indent
			buf += newline_indent
		else:
			newline_indent = None
			separator = _item_separator
		first = True

	def _iterencode_dict(dct, _current_indent_level):
		if not dct:
			yield '{}'
			return None
		if markers is not None:
			markerid = id(dct)
			if markerid in markers:
				raise ValueError('Circular reference detected')
			markers[markerid] = dct
		yield '{'
		if _indent is not None:
			_current_indent_level += 1
			newline_indent = '\n' + ' ' * _indent * _current_indent_level
			item_separator = _item_separator + newline_indent
			yield newline_indent
		else:
			newline_indent = None
			item_separator = _item_separator
		first = True
		if _sort_keys:
			items = dct.items()
			items.sort(key=(lambda kv: kv[0]))
		else:
			items = dct.iteritems()

	def _iterencode(o, _current_indent_level):
		if isinstance(o, basestring):
			yield _encoder(o)
		else:
			if o is None:
				yield 'null'
			else:
				if o is True:
					yield 'true'
				else:
					if o is False:
						yield 'false'
					else:
						if isinstance(o, (int, long)):
							yield str(o)
						else:
							if isinstance(o, float):
								yield _floatstr(o)
							else:
								if isinstance(o, (list, tuple)):
									for chunk in _iterencode_list(o, _current_indent_level):
										yield chunk
								else:
									if isinstance(o, dict):
										for chunk in _iterencode_dict(o, _current_indent_level):
											yield chunk
									else:
										if markers is not None:
											markerid = id(o)
											if markerid in markers:
												raise ValueError('Circular reference detected')
											markers[markerid] = o
										o = _default(o)
										for chunk in _iterencode(o, _current_indent_level):
											yield chunk
										if markers is not None:
											del markers[markerid]
		return None

	return _iterencode

]:
	i: 0(for)
	o: 

nname: 0
n 0(None)[__doc__ = 'Implementation of JSONEncoder\n'
import re
try:
	from simplejson._speedups import encode_basestring_ascii as c_encode_basestring_ascii
except ImportError:
	c_encode_basestring_ascii = None
try:
	from simplejson._speedups import make_encoder as c_make_encoder
except ImportError:
	c_make_encoder = None
ESCAPE = re.compile('[\\x00-\\x1f\\\\"\\b\\f\\n\\r\\t]')
ESCAPE_ASCII = re.compile('([\\\\"]|[^\\ -~])')
HAS_UTF8 = re.compile('[\\x80-\\xff]')
ESCAPE_DCT = {'\\': '\\\\', '"': '\\"', '\x08': '\\b', '\x0c': '\\f', '\n': '\\n', '\r': '\\r', '\t': '\\t'}
]:
	i: 
	o: 244(for)

nname: 0
n 0(None)[__doc__ = 'Implementation of JSONEncoder\n'
import re
try:
	from simplejson._speedups import encode_basestring_ascii as c_encode_basestring_ascii
except ImportError:
	c_encode_basestring_ascii = None
try:
	from simplejson._speedups import make_encoder as c_make_encoder
except ImportError:
	c_make_encoder = None
ESCAPE = re.compile('[\\x00-\\x1f\\\\"\\b\\f\\n\\r\\t]')
ESCAPE_ASCII = re.compile('([\\\\"]|[^\\ -~])')
HAS_UTF8 = re.compile('[\\x80-\\xff]')
ESCAPE_DCT = {'\\': '\\\\', '"': '\\"', '\x08': '\\b', '\x0c': '\\f', '\n': '\\n', '\r': '\\r', '\t': '\\t'}
for i in range(32):
	ESCAPE_DCT.setdefault(chr(i), '\\u%04x' % (i,))
INFINITY = float('1e66666')
FLOAT_REPR = repr
def encode_basestring(s):
	def replace(match):
		return ESCAPE_DCT[match.group(0)]

	return '"' + ESCAPE.sub(replace, s) + '"'

def py_encode_basestring_ascii(s):
	if isinstance(s, str) and HAS_UTF8.search(s) is not None:
		s = s.decode('utf-8')
	def replace(match):
		s = match.group(0)
		try:
			return ESCAPE_DCT[s]
		except KeyError:
			n = ord(s)
			if n < 65536:
				return '\\u%04x' % (n,)
			else:
				n -= 65536
				s1 = 55296 | n >> 10 & 1023
				s2 = 56320 | n & 1023
				return '\\u%04x\\u%04x' % (s1, s2)

	return '"' + str(ESCAPE_ASCII.sub(replace, s)) + '"'

if not c_encode_basestring_ascii:
	pass
encode_basestring_ascii = c_encode_basestring_ascii
class JSONEncoder(object):
	__doc__ = 'Extensible JSON <http://json.org> encoder for Python data structures.\n\n    Supports the following objects and types by default:\n\n    +-------------------+---------------+\n    | Python            | JSON          |\n    +===================+===============+\n    | dict              | object        |\n    +-------------------+---------------+\n    | list, tuple       | array         |\n    +-------------------+---------------+\n    | str, unicode      | string        |\n    +-------------------+---------------+\n    | int, long, float  | number        |\n    +-------------------+---------------+\n    | True              | true          |\n    +-------------------+---------------+\n    | False             | false         |\n    +-------------------+---------------+\n    | None              | null          |\n    +-------------------+---------------+\n\n    To extend this to recognize other objects, subclass and implement a\n    ``.default()`` method with another method that returns a serializable\n    object for ``o`` if possible, otherwise it should call the superclass\n    implementation (to raise ``TypeError``).\n\n    '
	item_separator = ', '
	key_separator = ': '
	def __init__(self, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, sort_keys=False, indent=None, separators=None, encoding='utf-8', default=None):
		self.skipkeys = skipkeys
		self.ensure_ascii = ensure_ascii
		self.check_circular = check_circular
		self.allow_nan = allow_nan
		self.sort_keys = sort_keys
		self.indent = indent
		if separators is not None:
			self.item_separator, self.key_separator = separators
		if default is not None:
			self.default = default
		self.encoding = encoding
		return None

	def default(self, o):
		raise TypeError('%r is not JSON serializable' % (o,))

	def encode(self, o):
		if isinstance(o, basestring):
			if isinstance(o, str):
				_encoding = self.encoding
				if _encoding is not None and not _encoding == 'utf-8':
					o = o.decode(_encoding)
			if self.ensure_ascii:
				return encode_basestring_ascii(o)
			else:
				return encode_basestring(o)
		chunks = self.iterencode(o, _one_shot=True)
		if not isinstance(chunks, (list, tuple)):
			chunks = list(chunks)
		return ''.join(chunks)

	def iterencode(self, o, _one_shot=False):
		if self.check_circular:
			markers = {}
		else:
			markers = None
		if self.ensure_ascii:
			_encoder = encode_basestring_ascii
		else:
			_encoder = encode_basestring
		if self.encoding != 'utf-8':
			def _encoder(o, _orig_encoder=_encoder, _encoding=self.encoding):
				if isinstance(o, str):
					o = o.decode(_encoding)
				return _orig_encoder(o)

		def floatstr(o, allow_nan=self.allow_nan, _repr=FLOAT_REPR, _inf=INFINITY, _neginf=-INFINITY):
			if o != o:
				text = 'NaN'
			else:
				if o == _inf:
					text = 'Infinity'
				else:
					if o == _neginf:
						text = '-Infinity'
					else:
						return _repr(o)
			if not allow_nan:
				raise ValueError('Out of range float values are not JSON compliant: %r' % (o,))
			return text

		if _one_shot and c_make_encoder is not None and not self.indent and not self.sort_keys:
			_iterencode = c_make_encoder(markers, self.default, _encoder, self.indent, self.key_separator, self.item_separator, self.sort_keys, self.skipkeys, self.allow_nan)
		else:
			_iterencode = _make_iterencode(markers, self.default, _encoder, self.indent, floatstr, self.key_separator, self.item_separator, self.sort_keys, self.skipkeys, _one_shot)
		return _iterencode(o, 0)



def _make_iterencode(markers, _default, _encoder, _indent, _floatstr, _key_separator, _item_separator, _sort_keys, _skipkeys, _one_shot, False=False, True=True, ValueError=ValueError, basestring=basestring, dict=dict, float=float, id=id, int=int, isinstance=isinstance, list=list, long=long, str=str, tuple=tuple):
	def _iterencode_list(lst, _current_indent_level):
		if not lst:
			yield '[]'
			return None
		if markers is not None:
			markerid = id(lst)
			if markerid in markers:
				raise ValueError('Circular reference detected')
			markers[markerid] = lst
		buf = '['
		if _indent is not None:
			_current_indent_level += 1
			newline_indent = '\n' + ' ' * _indent * _current_indent_level
			separator = _item_separator + newline_indent
			buf += newline_indent
		else:
			newline_indent = None
			separator = _item_separator
		first = True

	def _iterencode_dict(dct, _current_indent_level):
		if not dct:
			yield '{}'
			return None
		if markers is not None:
			markerid = id(dct)
			if markerid in markers:
				raise ValueError('Circular reference detected')
			markers[markerid] = dct
		yield '{'
		if _indent is not None:
			_current_indent_level += 1
			newline_indent = '\n' + ' ' * _indent * _current_indent_level
			item_separator = _item_separator + newline_indent
			yield newline_indent
		else:
			newline_indent = None
			item_separator = _item_separator
		first = True
		if _sort_keys:
			items = dct.items()
			items.sort(key=(lambda kv: kv[0]))
		else:
			items = dct.iteritems()

	def _iterencode(o, _current_indent_level):
		if isinstance(o, basestring):
			yield _encoder(o)
		else:
			if o is None:
				yield 'null'
			else:
				if o is True:
					yield 'true'
				else:
					if o is False:
						yield 'false'
					else:
						if isinstance(o, (int, long)):
							yield str(o)
						else:
							if isinstance(o, float):
								yield _floatstr(o)
							else:
								if isinstance(o, (list, tuple)):
									for chunk in _iterencode_list(o, _current_indent_level):
										yield chunk
								else:
									if isinstance(o, dict):
										for chunk in _iterencode_dict(o, _current_indent_level):
											yield chunk
									else:
										if markers is not None:
											markerid = id(o)
											if markerid in markers:
												raise ValueError('Circular reference detected')
											markers[markerid] = o
										o = _default(o)
										for chunk in _iterencode(o, _current_indent_level):
											yield chunk
										if markers is not None:
											del markers[markerid]
		return None

	return _iterencode

]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb75caf6c>}
__doc__ = 'Implementation of JSONEncoder\n'
import re
try:
	from simplejson._speedups import encode_basestring_ascii as c_encode_basestring_ascii
except ImportError:
	c_encode_basestring_ascii = None
try:
	from simplejson._speedups import make_encoder as c_make_encoder
except ImportError:
	c_make_encoder = None
ESCAPE = re.compile('[\\x00-\\x1f\\\\"\\b\\f\\n\\r\\t]')
ESCAPE_ASCII = re.compile('([\\\\"]|[^\\ -~])')
HAS_UTF8 = re.compile('[\\x80-\\xff]')
ESCAPE_DCT = {'\\': '\\\\', '"': '\\"', '\x08': '\\b', '\x0c': '\\f', '\n': '\\n', '\r': '\\r', '\t': '\\t'}
for i in range(32):
	ESCAPE_DCT.setdefault(chr(i), '\\u%04x' % (i,))
INFINITY = float('1e66666')
FLOAT_REPR = repr
def encode_basestring(s):
	def replace(match):
		return ESCAPE_DCT[match.group(0)]

	return '"' + ESCAPE.sub(replace, s) + '"'

def py_encode_basestring_ascii(s):
	if isinstance(s, str) and HAS_UTF8.search(s) is not None:
		s = s.decode('utf-8')
	def replace(match):
		s = match.group(0)
		try:
			return ESCAPE_DCT[s]
		except KeyError:
			n = ord(s)
			if n < 65536:
				return '\\u%04x' % (n,)
			else:
				n -= 65536
				s1 = 55296 | n >> 10 & 1023
				s2 = 56320 | n & 1023
				return '\\u%04x\\u%04x' % (s1, s2)

	return '"' + str(ESCAPE_ASCII.sub(replace, s)) + '"'

if not c_encode_basestring_ascii:
	pass
encode_basestring_ascii = c_encode_basestring_ascii
class JSONEncoder(object):
	__doc__ = 'Extensible JSON <http://json.org> encoder for Python data structures.\n\n    Supports the following objects and types by default:\n\n    +-------------------+---------------+\n    | Python            | JSON          |\n    +===================+===============+\n    | dict              | object        |\n    +-------------------+---------------+\n    | list, tuple       | array         |\n    +-------------------+---------------+\n    | str, unicode      | string        |\n    +-------------------+---------------+\n    | int, long, float  | number        |\n    +-------------------+---------------+\n    | True              | true          |\n    +-------------------+---------------+\n    | False             | false         |\n    +-------------------+---------------+\n    | None              | null          |\n    +-------------------+---------------+\n\n    To extend this to recognize other objects, subclass and implement a\n    ``.default()`` method with another method that returns a serializable\n    object for ``o`` if possible, otherwise it should call the superclass\n    implementation (to raise ``TypeError``).\n\n    '
	item_separator = ', '
	key_separator = ': '
	def __init__(self, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, sort_keys=False, indent=None, separators=None, encoding='utf-8', default=None):
		self.skipkeys = skipkeys
		self.ensure_ascii = ensure_ascii
		self.check_circular = check_circular
		self.allow_nan = allow_nan
		self.sort_keys = sort_keys
		self.indent = indent
		if separators is not None:
			self.item_separator, self.key_separator = separators
		if default is not None:
			self.default = default
		self.encoding = encoding
		return None

	def default(self, o):
		raise TypeError('%r is not JSON serializable' % (o,))

	def encode(self, o):
		if isinstance(o, basestring):
			if isinstance(o, str):
				_encoding = self.encoding
				if _encoding is not None and not _encoding == 'utf-8':
					o = o.decode(_encoding)
			if self.ensure_ascii:
				return encode_basestring_ascii(o)
			else:
				return encode_basestring(o)
		chunks = self.iterencode(o, _one_shot=True)
		if not isinstance(chunks, (list, tuple)):
			chunks = list(chunks)
		return ''.join(chunks)

	def iterencode(self, o, _one_shot=False):
		if self.check_circular:
			markers = {}
		else:
			markers = None
		if self.ensure_ascii:
			_encoder = encode_basestring_ascii
		else:
			_encoder = encode_basestring
		if self.encoding != 'utf-8':
			def _encoder(o, _orig_encoder=_encoder, _encoding=self.encoding):
				if isinstance(o, str):
					o = o.decode(_encoding)
				return _orig_encoder(o)

		def floatstr(o, allow_nan=self.allow_nan, _repr=FLOAT_REPR, _inf=INFINITY, _neginf=-INFINITY):
			if o != o:
				text = 'NaN'
			else:
				if o == _inf:
					text = 'Infinity'
				else:
					if o == _neginf:
						text = '-Infinity'
					else:
						return _repr(o)
			if not allow_nan:
				raise ValueError('Out of range float values are not JSON compliant: %r' % (o,))
			return text

		if _one_shot and c_make_encoder is not None and not self.indent and not self.sort_keys:
			_iterencode = c_make_encoder(markers, self.default, _encoder, self.indent, self.key_separator, self.item_separator, self.sort_keys, self.skipkeys, self.allow_nan)
		else:
			_iterencode = _make_iterencode(markers, self.default, _encoder, self.indent, floatstr, self.key_separator, self.item_separator, self.sort_keys, self.skipkeys, _one_shot)
		return _iterencode(o, 0)



def _make_iterencode(markers, _default, _encoder, _indent, _floatstr, _key_separator, _item_separator, _sort_keys, _skipkeys, _one_shot, False=False, True=True, ValueError=ValueError, basestring=basestring, dict=dict, float=float, id=id, int=int, isinstance=isinstance, list=list, long=long, str=str, tuple=tuple):
	def _iterencode_list(lst, _current_indent_level):
		if not lst:
			yield '[]'
			return None
		if markers is not None:
			markerid = id(lst)
			if markerid in markers:
				raise ValueError('Circular reference detected')
			markers[markerid] = lst
		buf = '['
		if _indent is not None:
			_current_indent_level += 1
			newline_indent = '\n' + ' ' * _indent * _current_indent_level
			separator = _item_separator + newline_indent
			buf += newline_indent
		else:
			newline_indent = None
			separator = _item_separator
		first = True

	def _iterencode_dict(dct, _current_indent_level):
		if not dct:
			yield '{}'
			return None
		if markers is not None:
			markerid = id(dct)
			if markerid in markers:
				raise ValueError('Circular reference detected')
			markers[markerid] = dct
		yield '{'
		if _indent is not None:
			_current_indent_level += 1
			newline_indent = '\n' + ' ' * _indent * _current_indent_level
			item_separator = _item_separator + newline_indent
			yield newline_indent
		else:
			newline_indent = None
			item_separator = _item_separator
		first = True
		if _sort_keys:
			items = dct.items()
			items.sort(key=(lambda kv: kv[0]))
		else:
			items = dct.iteritems()

	def _iterencode(o, _current_indent_level):
		if isinstance(o, basestring):
			yield _encoder(o)
		else:
			if o is None:
				yield 'null'
			else:
				if o is True:
					yield 'true'
				else:
					if o is False:
						yield 'false'
					else:
						if isinstance(o, (int, long)):
							yield str(o)
						else:
							if isinstance(o, float):
								yield _floatstr(o)
							else:
								if isinstance(o, (list, tuple)):
									for chunk in _iterencode_list(o, _current_indent_level):
										yield chunk
								else:
									if isinstance(o, dict):
										for chunk in _iterencode_dict(o, _current_indent_level):
											yield chunk
									else:
										if markers is not None:
											markerid = id(o)
											if markerid in markers:
												raise ValueError('Circular reference detected')
											markers[markerid] = o
										o = _default(o)
										for chunk in _iterencode(o, _current_indent_level):
											yield chunk
										if markers is not None:
											del markers[markerid]
		return None

	return _iterencode

