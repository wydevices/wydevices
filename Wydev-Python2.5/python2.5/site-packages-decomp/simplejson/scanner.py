# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 658
n 658(None)[return None
]:
	i: 449(), 505(), 566(), 627(), 651()
	o: 

nname: 651
n 651(None)[raise StopIteration
]:
	i: 590&603(f)
	o: 658()

nname: 627
n 627(None)[return (parse_constant('-Infinity'), idx + 9)
]:
	i: 590&603(t)
	o: 658()

nname: 590&603
n 590&603(nextchar == '-' and string[idx:idx + 9] == '-Infinity')[]:
	i: 529&542(f)
	o: 627(t), 651(f)

nname: 566
n 566(None)[return (parse_constant('Infinity'), idx + 8)
]:
	i: 529&542(t)
	o: 658()

nname: 529&542
n 529&542(nextchar == 'I' and string[idx:idx + 8] == 'Infinity')[]:
	i: 468&481(f)
	o: 566(t), 590&603(f)

nname: 505
n 505(None)[return (parse_constant('NaN'), idx + 3)
]:
	i: 468&481(t)
	o: 658()

nname: 468&481
n 468&481(nextchar == 'N' and string[idx:idx + 3] == 'NaN')[]:
	i: 336(f)
	o: 505(t), 529&542(f)

nname: 449
n 449(None)[return (res, m.end())
]:
	i: 426(), 436()
	o: 658()

nname: 436
n 436(None)[res = parse_int(integer)
]:
	i: 363&391(f)
	o: 449()

nname: 426
n 426(None)[res = parse_float(integer + frac + exp)
]:
	i: 415(t), 422()
	o: 449()

nname: 422
n 422(None)[]:
	i: 415(f)
	o: 426()

nname: 415
n 415(exp)[]:
	i: 398(t), 411()
	o: 422(f), 426(t)

nname: 411
n 411(None)[]:
	i: 398(f)
	o: 415()

nname: 398
n 398(frac)[]:
	i: 363&391(t)
	o: 411(f), 415(t)

nname: 363&391
n 363&391(frac or exp)[integer, frac, exp = m.groups()
]:
	i: 336(t)
	o: 398(t), 436(f)

nname: 336
n 336(m is not None)[m = match_number(string, idx)
]:
	i: 54(), 94(), 143(), 207(), 262(), 317(), 335()
	o: 363&391(t), 468&481(f)

nname: 335
n 335(None)[]:
	i: 280&293(f)
	o: 336()

nname: 317
n 317(None)[return (False, idx + 5)
]:
	i: 280&293(t)
	o: 336()

nname: 280&293
n 280&293(nextchar == 'f' and string[idx:idx + 5] == 'false')[]:
	i: 225&238(f)
	o: 317(t), 335(f)

nname: 262
n 262(None)[return (True, idx + 4)
]:
	i: 225&238(t)
	o: 336()

nname: 225&238
n 225&238(nextchar == 't' and string[idx:idx + 4] == 'true')[]:
	i: 170&183(f)
	o: 262(t), 280&293(f)

nname: 207
n 207(None)[return (None, idx + 4)
]:
	i: 170&183(t)
	o: 336()

nname: 170&183
n 170&183(nextchar == 'n' and string[idx:idx + 4] == 'null')[]:
	i: 130(f)
	o: 207(t), 225&238(f)

nname: 143
n 143(None)[return parse_array((string, idx + 1), _scan_once)
]:
	i: 130(t)
	o: 336()

nname: 130
n 130(nextchar == '[')[]:
	i: 81(f)
	o: 143(t), 170&183(f)

nname: 94
n 94(None)[return parse_object((string, idx + 1), encoding, strict, _scan_once, object_hook)
]:
	i: 81(t)
	o: 336()

nname: 81
n 81(nextchar == '{')[]:
	i: 42(f)
	o: 94(t), 130(f)

nname: 54
n 54(None)[return parse_string(string, idx + 1, encoding, strict)
]:
	i: 42(t)
	o: 336()

nname: 42
n 42(nextchar == '"')[]:
	i: 3(), 27(), 40(AE)
	o: 54(t), 81(f)

nname: 40
n 40(None)[]:
	i: 17(f)
	o: 42(AE)

nname: 27
n 27(None)[raise StopIteration
]:
	i: 17(t)
	o: 42()

nname: 17
n 17(<dummy_ex3> EXC_MATCH IndexError)[]:
	i: 0(except)
	o: 27(t), 40(f)

nname: 3
n 3(None)[nextchar = string[idx]
]:
	i: 0(try)
	o: 42()

nname: 0
n 0(None)[]:
	i: 
	o: 3(try), 17(except)

nname: 658
n 658(None)[return None
]:
	i: 449(), 468&481()
	o: 

nname: 468&481
n 468&481(None)[if nextchar == 'N' and string[idx:idx + 3] == 'NaN':
	return (parse_constant('NaN'), idx + 3)
else:
	if nextchar == 'I' and string[idx:idx + 8] == 'Infinity':
		return (parse_constant('Infinity'), idx + 8)
	else:
		if nextchar == '-' and string[idx:idx + 9] == '-Infinity':
			return (parse_constant('-Infinity'), idx + 9)
		else:
			raise StopIteration
]:
	i: 336(f)
	o: 658()

nname: 449
n 449(None)[return (res, m.end())
]:
	i: 426(), 436()
	o: 658()

nname: 436
n 436(None)[res = parse_int(integer)
]:
	i: 363&391(f)
	o: 449()

nname: 426
n 426(None)[res = parse_float(integer + frac + exp)
]:
	i: 398(t)
	o: 449()

nname: 398
n 398(None)[if not frac:
	pass
if not exp:
	pass
]:
	i: 363&391(t)
	o: 426()

nname: 363&391
n 363&391(frac or exp)[integer, frac, exp = m.groups()
]:
	i: 336(t)
	o: 398(t), 436(f)

nname: 336
n 336(m is not None)[m = match_number(string, idx)
]:
	i: 17()
	o: 363&391(t), 468&481(f)

nname: 17
n 17(None)[except IndexError:
	raise StopIteration
if nextchar == '"':
	return parse_string(string, idx + 1, encoding, strict)
else:
	if nextchar == '{':
		return parse_object((string, idx + 1), encoding, strict, _scan_once, object_hook)
	else:
		if nextchar == '[':
			return parse_array((string, idx + 1), _scan_once)
		else:
			if nextchar == 'n' and string[idx:idx + 4] == 'null':
				return (None, idx + 4)
			else:
				if nextchar == 't' and string[idx:idx + 4] == 'true':
					return (True, idx + 4)
				else:
					if nextchar == 'f' and string[idx:idx + 5] == 'false':
						return (False, idx + 5)
]:
	i: 0()
	o: 336()

nname: 0
n 0(None)[try:
	nextchar = string[idx]
]:
	i: 
	o: 17()

nname: 658
n 658(None)[return None
]:
	i: 449(), 468&481()
	o: 

nname: 468&481
n 468&481(None)[if nextchar == 'N' and string[idx:idx + 3] == 'NaN':
	return (parse_constant('NaN'), idx + 3)
else:
	if nextchar == 'I' and string[idx:idx + 8] == 'Infinity':
		return (parse_constant('Infinity'), idx + 8)
	else:
		if nextchar == '-' and string[idx:idx + 9] == '-Infinity':
			return (parse_constant('-Infinity'), idx + 9)
		else:
			raise StopIteration
]:
	i: 336(f)
	o: 658()

nname: 449
n 449(None)[return (res, m.end())
]:
	i: 398(), 436()
	o: 658()

nname: 436
n 436(None)[res = parse_int(integer)
]:
	i: 363&391(f)
	o: 449()

nname: 398
n 398(None)[if not frac:
	pass
if not exp:
	pass
res = parse_float(integer + frac + exp)
]:
	i: 363&391(t)
	o: 449()

nname: 363&391
n 363&391(frac or exp)[integer, frac, exp = m.groups()
]:
	i: 336(t)
	o: 398(t), 436(f)

nname: 336
n 336(m is not None)[m = match_number(string, idx)
]:
	i: 0()
	o: 363&391(t), 468&481(f)

nname: 0
n 0(None)[try:
	nextchar = string[idx]
except IndexError:
	raise StopIteration
if nextchar == '"':
	return parse_string(string, idx + 1, encoding, strict)
else:
	if nextchar == '{':
		return parse_object((string, idx + 1), encoding, strict, _scan_once, object_hook)
	else:
		if nextchar == '[':
			return parse_array((string, idx + 1), _scan_once)
		else:
			if nextchar == 'n' and string[idx:idx + 4] == 'null':
				return (None, idx + 4)
			else:
				if nextchar == 't' and string[idx:idx + 4] == 'true':
					return (True, idx + 4)
				else:
					if nextchar == 'f' and string[idx:idx + 5] == 'false':
						return (False, idx + 5)
]:
	i: 
	o: 336()

nname: 658
n 658(None)[return None
]:
	i: 363&391(), 468&481()
	o: 

nname: 468&481
n 468&481(None)[if nextchar == 'N' and string[idx:idx + 3] == 'NaN':
	return (parse_constant('NaN'), idx + 3)
else:
	if nextchar == 'I' and string[idx:idx + 8] == 'Infinity':
		return (parse_constant('Infinity'), idx + 8)
	else:
		if nextchar == '-' and string[idx:idx + 9] == '-Infinity':
			return (parse_constant('-Infinity'), idx + 9)
		else:
			raise StopIteration
]:
	i: 0(f)
	o: 658()

nname: 363&391
n 363&391(None)[integer, frac, exp = m.groups()
if frac or exp:
	if not frac:
		pass
	if not exp:
		pass
	res = parse_float(integer + frac + exp)
else:
	res = parse_int(integer)
return (res, m.end())
]:
	i: 0(t)
	o: 658()

nname: 0
n 0(m is not None)[try:
	nextchar = string[idx]
except IndexError:
	raise StopIteration
if nextchar == '"':
	return parse_string(string, idx + 1, encoding, strict)
else:
	if nextchar == '{':
		return parse_object((string, idx + 1), encoding, strict, _scan_once, object_hook)
	else:
		if nextchar == '[':
			return parse_array((string, idx + 1), _scan_once)
		else:
			if nextchar == 'n' and string[idx:idx + 4] == 'null':
				return (None, idx + 4)
			else:
				if nextchar == 't' and string[idx:idx + 4] == 'true':
					return (True, idx + 4)
				else:
					if nextchar == 'f' and string[idx:idx + 5] == 'false':
						return (False, idx + 5)
m = match_number(string, idx)
]:
	i: 
	o: 363&391(t), 468&481(f)

nname: 0
n 0(None)[try:
	nextchar = string[idx]
except IndexError:
	raise StopIteration
if nextchar == '"':
	return parse_string(string, idx + 1, encoding, strict)
else:
	if nextchar == '{':
		return parse_object((string, idx + 1), encoding, strict, _scan_once, object_hook)
	else:
		if nextchar == '[':
			return parse_array((string, idx + 1), _scan_once)
		else:
			if nextchar == 'n' and string[idx:idx + 4] == 'null':
				return (None, idx + 4)
			else:
				if nextchar == 't' and string[idx:idx + 4] == 'true':
					return (True, idx + 4)
				else:
					if nextchar == 'f' and string[idx:idx + 5] == 'false':
						return (False, idx + 5)
m = match_number(string, idx)
if m is not None:
	integer, frac, exp = m.groups()
	if frac or exp:
		if not frac:
			pass
		if not exp:
			pass
		res = parse_float(integer + frac + exp)
	else:
		res = parse_int(integer)
	return (res, m.end())
else:
	if nextchar == 'N' and string[idx:idx + 3] == 'NaN':
		return (parse_constant('NaN'), idx + 3)
	else:
		if nextchar == 'I' and string[idx:idx + 8] == 'Infinity':
			return (parse_constant('Infinity'), idx + 8)
		else:
			if nextchar == '-' and string[idx:idx + 9] == '-Infinity':
				return (parse_constant('-Infinity'), idx + 9)
			else:
				raise StopIteration
return None
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7677fec>}
nname: 0
n 0(None)[parse_object = context.parse_object
parse_array = context.parse_array
parse_string = context.parse_string
match_number = NUMBER_RE.match
encoding = context.encoding
strict = context.strict
parse_float = context.parse_float
parse_int = context.parse_int
parse_constant = context.parse_constant
object_hook = context.object_hook
def _scan_once(string, idx):
	try:
		nextchar = string[idx]
	except IndexError:
		raise StopIteration
	if nextchar == '"':
		return parse_string(string, idx + 1, encoding, strict)
	else:
		if nextchar == '{':
			return parse_object((string, idx + 1), encoding, strict, _scan_once, object_hook)
		else:
			if nextchar == '[':
				return parse_array((string, idx + 1), _scan_once)
			else:
				if nextchar == 'n' and string[idx:idx + 4] == 'null':
					return (None, idx + 4)
				else:
					if nextchar == 't' and string[idx:idx + 4] == 'true':
						return (True, idx + 4)
					else:
						if nextchar == 'f' and string[idx:idx + 5] == 'false':
							return (False, idx + 5)
	m = match_number(string, idx)
	if m is not None:
		integer, frac, exp = m.groups()
		if frac or exp:
			if not frac:
				pass
			if not exp:
				pass
			res = parse_float(integer + frac + exp)
		else:
			res = parse_int(integer)
		return (res, m.end())
	else:
		if nextchar == 'N' and string[idx:idx + 3] == 'NaN':
			return (parse_constant('NaN'), idx + 3)
		else:
			if nextchar == 'I' and string[idx:idx + 8] == 'Infinity':
				return (parse_constant('Infinity'), idx + 8)
			else:
				if nextchar == '-' and string[idx:idx + 9] == '-Infinity':
					return (parse_constant('-Infinity'), idx + 9)
				else:
					raise StopIteration
	return None

return _scan_once
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7669bec>}
nname: 129
n 129(None)[make_scanner = c_make_scanner
]:
	i: 66(t), 125()
	o: 

nname: 125
n 125(None)[]:
	i: 66(f)
	o: 129()

nname: 66
n 66(c_make_scanner)[__all__ = ['make_scanner']
NUMBER_RE = re.compile('(-?(?:0|[1-9]\\d*))(\\.\\d+)?([eE][-+]?\\d+)?', re.VERBOSE | re.MULTILINE | re.DOTALL)
def py_make_scanner(context):
	parse_object = context.parse_object
	parse_array = context.parse_array
	parse_string = context.parse_string
	match_number = NUMBER_RE.match
	encoding = context.encoding
	strict = context.strict
	parse_float = context.parse_float
	parse_int = context.parse_int
	parse_constant = context.parse_constant
	object_hook = context.object_hook
	def _scan_once(string, idx):
		try:
			nextchar = string[idx]
		except IndexError:
			raise StopIteration
		if nextchar == '"':
			return parse_string(string, idx + 1, encoding, strict)
		else:
			if nextchar == '{':
				return parse_object((string, idx + 1), encoding, strict, _scan_once, object_hook)
			else:
				if nextchar == '[':
					return parse_array((string, idx + 1), _scan_once)
				else:
					if nextchar == 'n' and string[idx:idx + 4] == 'null':
						return (None, idx + 4)
					else:
						if nextchar == 't' and string[idx:idx + 4] == 'true':
							return (True, idx + 4)
						else:
							if nextchar == 'f' and string[idx:idx + 5] == 'false':
								return (False, idx + 5)
		m = match_number(string, idx)
		if m is not None:
			integer, frac, exp = m.groups()
			if frac or exp:
				if not frac:
					pass
				if not exp:
					pass
				res = parse_float(integer + frac + exp)
			else:
				res = parse_int(integer)
			return (res, m.end())
		else:
			if nextchar == 'N' and string[idx:idx + 3] == 'NaN':
				return (parse_constant('NaN'), idx + 3)
			else:
				if nextchar == 'I' and string[idx:idx + 8] == 'Infinity':
					return (parse_constant('Infinity'), idx + 8)
				else:
					if nextchar == '-' and string[idx:idx + 9] == '-Infinity':
						return (parse_constant('-Infinity'), idx + 9)
					else:
						raise StopIteration
		return None

	return _scan_once

]:
	i: 21(), 51(), 64(AE)
	o: 125(f), 129(t)

nname: 64
n 64(None)[]:
	i: 41(f)
	o: 66(AE)

nname: 51
n 51(None)[c_make_scanner = None
]:
	i: 41(t)
	o: 66()

nname: 41
n 41(<dummy_ex3> EXC_MATCH ImportError)[]:
	i: 0(except)
	o: 51(t), 64(f)

nname: 21
n 21(None)[from simplejson._speedups import make_scanner as c_make_scanner
]:
	i: 0(try)
	o: 66()

nname: 0
n 0(None)[__doc__ = 'JSON token scanner\n'
import re
]:
	i: 
	o: 21(try), 41(except)

nname: 129
n 129(None)[make_scanner = c_make_scanner
]:
	i: 41(t)
	o: 

nname: 41
n 41(None)[except ImportError:
	c_make_scanner = None
__all__ = ['make_scanner']
NUMBER_RE = re.compile('(-?(?:0|[1-9]\\d*))(\\.\\d+)?([eE][-+]?\\d+)?', re.VERBOSE | re.MULTILINE | re.DOTALL)
def py_make_scanner(context):
	parse_object = context.parse_object
	parse_array = context.parse_array
	parse_string = context.parse_string
	match_number = NUMBER_RE.match
	encoding = context.encoding
	strict = context.strict
	parse_float = context.parse_float
	parse_int = context.parse_int
	parse_constant = context.parse_constant
	object_hook = context.object_hook
	def _scan_once(string, idx):
		try:
			nextchar = string[idx]
		except IndexError:
			raise StopIteration
		if nextchar == '"':
			return parse_string(string, idx + 1, encoding, strict)
		else:
			if nextchar == '{':
				return parse_object((string, idx + 1), encoding, strict, _scan_once, object_hook)
			else:
				if nextchar == '[':
					return parse_array((string, idx + 1), _scan_once)
				else:
					if nextchar == 'n' and string[idx:idx + 4] == 'null':
						return (None, idx + 4)
					else:
						if nextchar == 't' and string[idx:idx + 4] == 'true':
							return (True, idx + 4)
						else:
							if nextchar == 'f' and string[idx:idx + 5] == 'false':
								return (False, idx + 5)
		m = match_number(string, idx)
		if m is not None:
			integer, frac, exp = m.groups()
			if frac or exp:
				if not frac:
					pass
				if not exp:
					pass
				res = parse_float(integer + frac + exp)
			else:
				res = parse_int(integer)
			return (res, m.end())
		else:
			if nextchar == 'N' and string[idx:idx + 3] == 'NaN':
				return (parse_constant('NaN'), idx + 3)
			else:
				if nextchar == 'I' and string[idx:idx + 8] == 'Infinity':
					return (parse_constant('Infinity'), idx + 8)
				else:
					if nextchar == '-' and string[idx:idx + 9] == '-Infinity':
						return (parse_constant('-Infinity'), idx + 9)
					else:
						raise StopIteration
		return None

	return _scan_once

if not c_make_scanner:
	pass
]:
	i: 0()
	o: 129()

nname: 0
n 0(None)[__doc__ = 'JSON token scanner\n'
import re
try:
	from simplejson._speedups import make_scanner as c_make_scanner
]:
	i: 
	o: 41()

nname: 129
n 129(None)[make_scanner = c_make_scanner
]:
	i: 0(t)
	o: 

nname: 0
n 0(None)[__doc__ = 'JSON token scanner\n'
import re
try:
	from simplejson._speedups import make_scanner as c_make_scanner
except ImportError:
	c_make_scanner = None
__all__ = ['make_scanner']
NUMBER_RE = re.compile('(-?(?:0|[1-9]\\d*))(\\.\\d+)?([eE][-+]?\\d+)?', re.VERBOSE | re.MULTILINE | re.DOTALL)
def py_make_scanner(context):
	parse_object = context.parse_object
	parse_array = context.parse_array
	parse_string = context.parse_string
	match_number = NUMBER_RE.match
	encoding = context.encoding
	strict = context.strict
	parse_float = context.parse_float
	parse_int = context.parse_int
	parse_constant = context.parse_constant
	object_hook = context.object_hook
	def _scan_once(string, idx):
		try:
			nextchar = string[idx]
		except IndexError:
			raise StopIteration
		if nextchar == '"':
			return parse_string(string, idx + 1, encoding, strict)
		else:
			if nextchar == '{':
				return parse_object((string, idx + 1), encoding, strict, _scan_once, object_hook)
			else:
				if nextchar == '[':
					return parse_array((string, idx + 1), _scan_once)
				else:
					if nextchar == 'n' and string[idx:idx + 4] == 'null':
						return (None, idx + 4)
					else:
						if nextchar == 't' and string[idx:idx + 4] == 'true':
							return (True, idx + 4)
						else:
							if nextchar == 'f' and string[idx:idx + 5] == 'false':
								return (False, idx + 5)
		m = match_number(string, idx)
		if m is not None:
			integer, frac, exp = m.groups()
			if frac or exp:
				if not frac:
					pass
				if not exp:
					pass
				res = parse_float(integer + frac + exp)
			else:
				res = parse_int(integer)
			return (res, m.end())
		else:
			if nextchar == 'N' and string[idx:idx + 3] == 'NaN':
				return (parse_constant('NaN'), idx + 3)
			else:
				if nextchar == 'I' and string[idx:idx + 8] == 'Infinity':
					return (parse_constant('Infinity'), idx + 8)
				else:
					if nextchar == '-' and string[idx:idx + 9] == '-Infinity':
						return (parse_constant('-Infinity'), idx + 9)
					else:
						raise StopIteration
		return None

	return _scan_once

if not c_make_scanner:
	pass
]:
	i: 
	o: 129()

nname: 0
n 0(None)[__doc__ = 'JSON token scanner\n'
import re
try:
	from simplejson._speedups import make_scanner as c_make_scanner
except ImportError:
	c_make_scanner = None
__all__ = ['make_scanner']
NUMBER_RE = re.compile('(-?(?:0|[1-9]\\d*))(\\.\\d+)?([eE][-+]?\\d+)?', re.VERBOSE | re.MULTILINE | re.DOTALL)
def py_make_scanner(context):
	parse_object = context.parse_object
	parse_array = context.parse_array
	parse_string = context.parse_string
	match_number = NUMBER_RE.match
	encoding = context.encoding
	strict = context.strict
	parse_float = context.parse_float
	parse_int = context.parse_int
	parse_constant = context.parse_constant
	object_hook = context.object_hook
	def _scan_once(string, idx):
		try:
			nextchar = string[idx]
		except IndexError:
			raise StopIteration
		if nextchar == '"':
			return parse_string(string, idx + 1, encoding, strict)
		else:
			if nextchar == '{':
				return parse_object((string, idx + 1), encoding, strict, _scan_once, object_hook)
			else:
				if nextchar == '[':
					return parse_array((string, idx + 1), _scan_once)
				else:
					if nextchar == 'n' and string[idx:idx + 4] == 'null':
						return (None, idx + 4)
					else:
						if nextchar == 't' and string[idx:idx + 4] == 'true':
							return (True, idx + 4)
						else:
							if nextchar == 'f' and string[idx:idx + 5] == 'false':
								return (False, idx + 5)
		m = match_number(string, idx)
		if m is not None:
			integer, frac, exp = m.groups()
			if frac or exp:
				if not frac:
					pass
				if not exp:
					pass
				res = parse_float(integer + frac + exp)
			else:
				res = parse_int(integer)
			return (res, m.end())
		else:
			if nextchar == 'N' and string[idx:idx + 3] == 'NaN':
				return (parse_constant('NaN'), idx + 3)
			else:
				if nextchar == 'I' and string[idx:idx + 8] == 'Infinity':
					return (parse_constant('Infinity'), idx + 8)
				else:
					if nextchar == '-' and string[idx:idx + 9] == '-Infinity':
						return (parse_constant('-Infinity'), idx + 9)
					else:
						raise StopIteration
		return None

	return _scan_once

if not c_make_scanner:
	pass
make_scanner = c_make_scanner
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb76625cc>}
__doc__ = 'JSON token scanner\n'
import re
try:
	from simplejson._speedups import make_scanner as c_make_scanner
except ImportError:
	c_make_scanner = None
__all__ = ['make_scanner']
NUMBER_RE = re.compile('(-?(?:0|[1-9]\\d*))(\\.\\d+)?([eE][-+]?\\d+)?', re.VERBOSE | re.MULTILINE | re.DOTALL)
def py_make_scanner(context):
	parse_object = context.parse_object
	parse_array = context.parse_array
	parse_string = context.parse_string
	match_number = NUMBER_RE.match
	encoding = context.encoding
	strict = context.strict
	parse_float = context.parse_float
	parse_int = context.parse_int
	parse_constant = context.parse_constant
	object_hook = context.object_hook
	def _scan_once(string, idx):
		try:
			nextchar = string[idx]
		except IndexError:
			raise StopIteration
		if nextchar == '"':
			return parse_string(string, idx + 1, encoding, strict)
		else:
			if nextchar == '{':
				return parse_object((string, idx + 1), encoding, strict, _scan_once, object_hook)
			else:
				if nextchar == '[':
					return parse_array((string, idx + 1), _scan_once)
				else:
					if nextchar == 'n' and string[idx:idx + 4] == 'null':
						return (None, idx + 4)
					else:
						if nextchar == 't' and string[idx:idx + 4] == 'true':
							return (True, idx + 4)
						else:
							if nextchar == 'f' and string[idx:idx + 5] == 'false':
								return (False, idx + 5)
		m = match_number(string, idx)
		if m is not None:
			integer, frac, exp = m.groups()
			if frac or exp:
				if not frac:
					pass
				if not exp:
					pass
				res = parse_float(integer + frac + exp)
			else:
				res = parse_int(integer)
			return (res, m.end())
		else:
			if nextchar == 'N' and string[idx:idx + 3] == 'NaN':
				return (parse_constant('NaN'), idx + 3)
			else:
				if nextchar == 'I' and string[idx:idx + 8] == 'Infinity':
					return (parse_constant('Infinity'), idx + 8)
				else:
					if nextchar == '-' and string[idx:idx + 9] == '-Infinity':
						return (parse_constant('-Infinity'), idx + 9)
					else:
						raise StopIteration
		return None

	return _scan_once

if not c_make_scanner:
	pass
make_scanner = c_make_scanner
