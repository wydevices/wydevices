# -*- coding: utf-8 -*- 
#
# Description:
#
#  Definiton
#
#
#
# Changes:
#
# 2012-01-10
# Initial Commit
#
#
# Copyright 2010-2012, WyDev Team.
# Author: Polo35 (polo35580@hotmail.fr)
#
# Licenced under Academic Free License version 3.0
# Review WyGui README & LICENSE files for further details.

nname: 79
n 79(None)[nan, inf = struct.unpack('dd', _BYTES)
return (nan, inf, -inf)
]:
	i: 30(), 78()
	o: 

nname: 78
n 78(None)[]:
	i: 0(f)
	o: 79()

nname: 30
n 30(None)[_BYTES = _BYTES[:8][::-1] + _BYTES[8:][::-1]
]:
	i: 0(t)
	o: 79()

nname: 0
n 0(sys.byteorder != 'big')[_BYTES = '7FF80000000000007FF0000000000000'.decode('hex')
]:
	i: 
	o: 30(t), 78(f)

nname: 0
n 0(None)[_BYTES = '7FF80000000000007FF0000000000000'.decode('hex')
if sys.byteorder != 'big':
	_BYTES = _BYTES[:8][::-1] + _BYTES[8:][::-1]
nan, inf = struct.unpack('dd', _BYTES)
return (nan, inf, -inf)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb776c0ac>}
nname: 73
n 73(None)[return (lineno, colno)
]:
	i: 37(), 47()
	o: 

nname: 47
n 47(None)[colno = pos - doc.rindex('\n', 0, pos)
]:
	i: 0(f)
	o: 73()

nname: 37
n 37(None)[colno = pos
]:
	i: 0(t)
	o: 73()

nname: 0
n 0(lineno == 1)[lineno = doc.count('\n', 0, pos) + 1
]:
	i: 
	o: 37(t), 47(f)

nname: 0
n 0(None)[lineno = doc.count('\n', 0, pos) + 1
if lineno == 1:
	colno = pos
else:
	colno = pos - doc.rindex('\n', 0, pos)
return (lineno, colno)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb776c48c>}
nname: 58
n 58(None)[endlineno, endcolno = linecol(doc, end)
return '%s: line %d column %d - line %d column %d (char %d - %d)' % (msg, lineno, colno, endlineno, endcolno, pos, end)
]:
	i: 33(), 57()
	o: 

nname: 57
n 57(None)[]:
	i: 0(f)
	o: 58()

nname: 33
n 33(None)[return '%s: line %d column %d (char %d)' % (msg, lineno, colno, pos)
]:
	i: 0(t)
	o: 58()

nname: 0
n 0(end is None)[lineno, colno = linecol(doc, pos)
]:
	i: 
	o: 33(t), 57(f)

nname: 0
n 0(None)[lineno, colno = linecol(doc, pos)
if end is None:
	return '%s: line %d column %d (char %d)' % (msg, lineno, colno, pos)
endlineno, endcolno = linecol(doc, end)
return '%s: line %d column %d - line %d column %d (char %d - %d)' % (msg, lineno, colno, endlineno, endcolno, pos, end)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb776c0ac>}
nname: 787
n 787(None)[return (u''.join(chunks), end)
]:
	i: 23(AL), 774()
	o: 

nname: 774
n 774(None)[_append(m)
]:
	i: 416(), 768()
	o: 787()

nname: 768
n 768(None)[end = next_end
]:
	i: 709(), 735(), 766(AE)
	o: 774()

nname: 766
n 766(None)[]:
	i: 725(f)
	o: 768(AE)

nname: 735
n 735(None)[raise ValueError(errmsg(msg, s, end))
]:
	i: 725(t)
	o: 768()

nname: 725
n 725(<dummy_ex3> EXC_MATCH ValueError)[]:
	i: 429(except)
	o: 735(t), 766(f)

nname: 709
n 709(None)[m = unichr(uni)
]:
	i: 654(), 708()
	o: 768()

nname: 708
n 708(None)[]:
	i: 540&543(f)
	o: 709()

nname: 654
n 654(None)[uni2 = int(esc2, 16)
uni = 65536 + (uni - 55296 << 10 | uni2 - 56320)
next_end += 6
]:
	i: 643(), 653()
	o: 709()

nname: 653
n 653(None)[]:
	i: 604(f)
	o: 654()

nname: 643
n 643(None)[raise ValueError
]:
	i: 604(t)
	o: 654()

nname: 604
n 604(len(esc2) != 4)[esc2 = s[end + 7:end + 11]
]:
	i: 593(), 603()
	o: 643(t), 653(f)

nname: 603
n 603(None)[]:
	i: 559(t)
	o: 604()

nname: 593
n 593(None)[raise ValueError
]:
	i: 559(f)
	o: 604()

nname: 559
n 559(s[end + 5:end + 7] == '\\u')[msg = 'Invalid \\uXXXX\\uXXXX surrogate pair'
]:
	i: 540&543(t)
	o: 593(f), 603(t)

nname: 540&543
n 540&543(55296 <= uni and sys.maxunicode > 65535)[]:
	i: 528(), 538()
	o: 559(t), 708(f)

nname: 538
n 538(None)[uni
]:
	i: 499(f)
	o: 540&543()

nname: 528
n 528(None)[]:
	i: 499(t)
	o: 540&543()

nname: 499
n 499(55296 <= uni)[uni = int(esc, 16)
]:
	i: 488(), 498()
	o: 528(t), 538(f)

nname: 498
n 498(None)[]:
	i: 470(f)
	o: 499()

nname: 488
n 488(None)[raise ValueError
]:
	i: 470(t)
	o: 499()

nname: 470
n 470(len(esc) != 4)[]:
	i: 429(try)
	o: 488(t), 498(f)

nname: 429
n 429(None)[esc = s[end + 1:end + 5]
next_end = end + 5
msg = 'Invalid \\uXXXX escape'
]:
	i: 336(f)
	o: 470(try), 725(except)

nname: 416
n 416(None)[end += 1
]:
	i: 352(), 376(), 414(AE)
	o: 774()

nname: 414
n 414(None)[]:
	i: 366(f)
	o: 416(AE)

nname: 376
n 376(None)[raise ValueError(errmsg('Invalid \\escape: %r' % (esc,), s, end))
]:
	i: 366(t)
	o: 416()

nname: 366
n 366(<dummy_ex3> EXC_MATCH KeyError)[]:
	i: 348(except)
	o: 376(t), 414(f)

nname: 352
n 352(None)[m = _b[esc]
]:
	i: 348(try)
	o: 416()

nname: 348
n 348(None)[]:
	i: 336(t)
	o: 352(try), 366(except)

nname: 336
n 336(esc != 'u')[]:
	i: 279(), 303(), 334(AE)
	o: 348(t), 429(f)

nname: 334
n 334(None)[]:
	i: 293(f)
	o: 336(AE)

nname: 303
n 303(None)[raise ValueError(errmsg('Unterminated string starting at', s, begin))
]:
	i: 293(t)
	o: 336()

nname: 293
n 293(<dummy_ex3> EXC_MATCH IndexError)[]:
	i: 276(except)
	o: 303(t), 334(f)

nname: 279
n 279(None)[esc = s[end]
]:
	i: 276(try)
	o: 336()

nname: 276
n 276(None)[]:
	i: 205(), 230(JA), 258(), 275()
	o: 279(try), 293(except)

nname: 275
n 275(None)[]:
	i: 210(f)
	o: 276()

nname: 258
n 258(None)[_append(terminator)
continue
]:
	i: 223(f)
	o: 276()

nname: 230
n 230(None)[raise ValueError(errmsg('Invalid control character %r at', s, end))
]:
	i: 223(t)
	o: 276(JA)

nname: 223
n 223(strict)[]:
	i: 210(t)
	o: 230(t), 258(f)

nname: 210
n 210(terminator != '\\')[]:
	i: 193(f)
	o: 223(t), 275(f)

nname: 205
n 205(None)[break
]:
	i: 193(t)
	o: 276()

nname: 193
n 193(terminator == '"')[]:
	i: 179(), 192()
	o: 205(t), 210(f)

nname: 192
n 192(None)[]:
	i: 107(f)
	o: 193()

nname: 179
n 179(None)[_append(content)
]:
	i: 159(), 178()
	o: 193()

nname: 178
n 178(None)[]:
	i: 143(t)
	o: 179()

nname: 159
n 159(None)[content = unicode(content, encoding)
]:
	i: 143(f)
	o: 179()

nname: 143
n 143(isinstance(content, unicode))[]:
	i: 107(t)
	o: 159(f), 178(t)

nname: 107
n 107(content)[end = chunk.end()
content, terminator = chunk.groups()
]:
	i: 78(), 106()
	o: 143(t), 192(f)

nname: 106
n 106(None)[]:
	i: 51(f)
	o: 107()

nname: 78
n 78(None)[raise ValueError(errmsg('Unterminated string starting at', s, begin))
]:
	i: 51(t)
	o: 107()

nname: 51
n 51(chunk is None)[chunk = _m(s, end)
]:
	i: 23(loop)
	o: 78(t), 106(f)

nname: 23
n 23(None)[chunks = []
_append = chunks.append
begin = end - 1
]:
	i: 12(), 22()
	o: 51(loop), 787(AL)

nname: 22
n 22(None)[]:
	i: 0(f)
	o: 23()

nname: 12
n 12(None)[encoding = DEFAULT_ENCODING
]:
	i: 0(t)
	o: 23()

nname: 0
n 0(encoding is None)[]:
	i: 
	o: 12(t), 22(f)

nname: 787
n 787(None)[return (u''.join(chunks), end)
]:
	i: 0(AL), 774()
	o: 

nname: 774
n 774(None)[_append(m)
]:
	i: 366(), 768()
	o: 787()

nname: 768
n 768(None)[end = next_end
]:
	i: 709(), 725()
	o: 774()

nname: 725
n 725(None)[except ValueError:
	raise ValueError(errmsg(msg, s, end))
]:
	i: 429()
	o: 768()

nname: 709
n 709(None)[m = unichr(uni)
]:
	i: 654(), 499(f)
	o: 768()

nname: 654
n 654(None)[uni2 = int(esc2, 16)
uni = 65536 + (uni - 55296 << 10 | uni2 - 56320)
next_end += 6
]:
	i: 559()
	o: 709()

nname: 559
n 559(None)[msg = 'Invalid \\uXXXX\\uXXXX surrogate pair'
if not s[end + 5:end + 7] == '\\u':
	raise ValueError
esc2 = s[end + 7:end + 11]
if len(esc2) != 4:
	raise ValueError
]:
	i: 499(t)
	o: 654()

nname: 499
n 499(55296 <= uni and sys.maxunicode > 65535)[uni = int(esc, 16)
if 55296 <= uni:
	pass
else:
	uni
]:
	i: 429()
	o: 559(t), 709(f)

nname: 429
n 429(None)[esc = s[end + 1:end + 5]
next_end = end + 5
msg = 'Invalid \\uXXXX escape'
try:
	if len(esc) != 4:
		raise ValueError
]:
	i: 336(f)
	o: 499(), 725()

nname: 366
n 366(None)[except KeyError:
	raise ValueError(errmsg('Invalid \\escape: %r' % (esc,), s, end))
end += 1
]:
	i: 348()
	o: 774()

nname: 348
n 348(None)[try:
	m = _b[esc]
]:
	i: 336(t)
	o: 366()

nname: 336
n 336(esc != 'u')[]:
	i: 279()
	o: 348(t), 429(f)

nname: 279
n 279(None)[try:
	esc = s[end]
except IndexError:
	raise ValueError(errmsg('Unterminated string starting at', s, begin))
]:
	i: 193(try)
	o: 336()

nname: 193
n 193(None)[if terminator == '"':
	break
else:
	if terminator != '\\':
		if strict:
			raise ValueError(errmsg('Invalid control character %r at', s, end))
		else:
			_append(terminator)
			continue
]:
	i: 143(), 107(f)
	o: 279(try)

nname: 143
n 143(None)[if not isinstance(content, unicode):
	content = unicode(content, encoding)
_append(content)
]:
	i: 107(t)
	o: 193()

nname: 107
n 107(content)[end = chunk.end()
content, terminator = chunk.groups()
]:
	i: 78(), 51(f)
	o: 143(t), 193(f)

nname: 78
n 78(None)[raise ValueError(errmsg('Unterminated string starting at', s, begin))
]:
	i: 51(t)
	o: 107()

nname: 51
n 51(chunk is None)[chunk = _m(s, end)
]:
	i: 0(loop)
	o: 78(t), 107(f)

nname: 0
n 0(None)[if encoding is None:
	encoding = DEFAULT_ENCODING
chunks = []
_append = chunks.append
begin = end - 1
]:
	i: 
	o: 51(loop), 787(AL)

nname: 787
n 787(None)[return (u''.join(chunks), end)
]:
	i: 0(AL), 774()
	o: 

nname: 774
n 774(None)[_append(m)
]:
	i: 348(), 768()
	o: 787()

nname: 768
n 768(None)[end = next_end
]:
	i: 709(), 725()
	o: 774()

nname: 725
n 725(None)[except ValueError:
	raise ValueError(errmsg(msg, s, end))
]:
	i: 429()
	o: 768()

nname: 709
n 709(None)[m = unichr(uni)
]:
	i: 559(), 499(f)
	o: 768()

nname: 559
n 559(None)[msg = 'Invalid \\uXXXX\\uXXXX surrogate pair'
if not s[end + 5:end + 7] == '\\u':
	raise ValueError
esc2 = s[end + 7:end + 11]
if len(esc2) != 4:
	raise ValueError
uni2 = int(esc2, 16)
uni = 65536 + (uni - 55296 << 10 | uni2 - 56320)
next_end += 6
]:
	i: 499(t)
	o: 709()

nname: 499
n 499(55296 <= uni and sys.maxunicode > 65535)[uni = int(esc, 16)
if 55296 <= uni:
	pass
else:
	uni
]:
	i: 429()
	o: 559(t), 709(f)

nname: 429
n 429(None)[esc = s[end + 1:end + 5]
next_end = end + 5
msg = 'Invalid \\uXXXX escape'
try:
	if len(esc) != 4:
		raise ValueError
]:
	i: 279(f)
	o: 499(), 725()

nname: 348
n 348(None)[try:
	m = _b[esc]
except KeyError:
	raise ValueError(errmsg('Invalid \\escape: %r' % (esc,), s, end))
end += 1
]:
	i: 279(t)
	o: 774()

nname: 279
n 279(esc != 'u')[try:
	esc = s[end]
except IndexError:
	raise ValueError(errmsg('Unterminated string starting at', s, begin))
]:
	i: 107(try)
	o: 348(t), 429(f)

nname: 107
n 107(None)[end = chunk.end()
content, terminator = chunk.groups()
if content:
	if not isinstance(content, unicode):
		content = unicode(content, encoding)
	_append(content)
if terminator == '"':
	break
else:
	if terminator != '\\':
		if strict:
			raise ValueError(errmsg('Invalid control character %r at', s, end))
		else:
			_append(terminator)
			continue
]:
	i: 78(), 51(f)
	o: 279(try)

nname: 78
n 78(None)[raise ValueError(errmsg('Unterminated string starting at', s, begin))
]:
	i: 51(t)
	o: 107()

nname: 51
n 51(chunk is None)[chunk = _m(s, end)
]:
	i: 0(loop)
	o: 78(t), 107(f)

nname: 0
n 0(None)[if encoding is None:
	encoding = DEFAULT_ENCODING
chunks = []
_append = chunks.append
begin = end - 1
]:
	i: 
	o: 51(loop), 787(AL)

nname: 787
n 787(None)[return (u''.join(chunks), end)
]:
	i: 0(AL), 774()
	o: 

nname: 774
n 774(None)[_append(m)
]:
	i: 348(), 768()
	o: 787()

nname: 768
n 768(None)[end = next_end
]:
	i: 499(), 725()
	o: 774()

nname: 725
n 725(None)[except ValueError:
	raise ValueError(errmsg(msg, s, end))
]:
	i: 429()
	o: 768()

nname: 499
n 499(None)[uni = int(esc, 16)
if 55296 <= uni:
	pass
else:
	uni
if 55296 <= uni and sys.maxunicode > 65535:
	msg = 'Invalid \\uXXXX\\uXXXX surrogate pair'
	if not s[end + 5:end + 7] == '\\u':
		raise ValueError
	esc2 = s[end + 7:end + 11]
	if len(esc2) != 4:
		raise ValueError
	uni2 = int(esc2, 16)
	uni = 65536 + (uni - 55296 << 10 | uni2 - 56320)
	next_end += 6
m = unichr(uni)
]:
	i: 429()
	o: 768()

nname: 429
n 429(None)[esc = s[end + 1:end + 5]
next_end = end + 5
msg = 'Invalid \\uXXXX escape'
try:
	if len(esc) != 4:
		raise ValueError
]:
	i: 107(f)
	o: 499(), 725()

nname: 348
n 348(None)[try:
	m = _b[esc]
except KeyError:
	raise ValueError(errmsg('Invalid \\escape: %r' % (esc,), s, end))
end += 1
]:
	i: 107(t)
	o: 774()

nname: 107
n 107(esc != 'u')[end = chunk.end()
content, terminator = chunk.groups()
if content:
	if not isinstance(content, unicode):
		content = unicode(content, encoding)
	_append(content)
if terminator == '"':
	break
else:
	if terminator != '\\':
		if strict:
			raise ValueError(errmsg('Invalid control character %r at', s, end))
		else:
			_append(terminator)
			continue
try:
	esc = s[end]
except IndexError:
	raise ValueError(errmsg('Unterminated string starting at', s, begin))
]:
	i: 78(), 51(f)
	o: 348(t), 429(f)

nname: 78
n 78(None)[raise ValueError(errmsg('Unterminated string starting at', s, begin))
]:
	i: 51(t)
	o: 107()

nname: 51
n 51(chunk is None)[chunk = _m(s, end)
]:
	i: 0(loop)
	o: 78(t), 107(f)

nname: 0
n 0(None)[if encoding is None:
	encoding = DEFAULT_ENCODING
chunks = []
_append = chunks.append
begin = end - 1
]:
	i: 
	o: 51(loop), 787(AL)

self.nodes: {0: <unpyclib.structure.node instance at 0x9efff0c>, 51: <unpyclib.structure.node instance at 0x9eeca2c>, 774: <unpyclib.structure.node instance at 0x9effdec>, 429: <unpyclib.structure.node instance at 0x9effdcc>, 78: <unpyclib.structure.node instance at 0x9eecaec>, 787: <unpyclib.structure.node instance at 0x9effe6c>, 348: <unpyclib.structure.node instance at 0x9effecc>, 107: <unpyclib.structure.node instance at 0x9effeac>, 499: <unpyclib.structure.node instance at 0x9efff6c>, 768: <unpyclib.structure.node instance at 0x9effd6c>, 725: <unpyclib.structure.node instance at 0x9ef568c>}
nname: 908
n 908(None)[return (pairs, end)
]:
	i: 891(), 907()
	o: 

nname: 907
n 907(None)[]:
	i: 879(f)
	o: 908()

nname: 891
n 891(None)[pairs = object_hook(pairs)
]:
	i: 879(t)
	o: 908()

nname: 879
n 879(object_hook is not None)[]:
	i: 179(AL), 877()
	o: 891(t), 907(f)

nname: 877
n 877(None)[]:
	i: 192(f), 873()
	o: 879()

nname: 873
n 873(None)[]:
	i: 819(f), 841()
	o: 877()

nname: 841
n 841(None)[raise ValueError(errmsg('Expecting property name', s, end - 1))
continue
]:
	i: 819(t)
	o: 873()

nname: 819
n 819(nextchar != '"')[end += 1
]:
	i: 790(), 804(), 817(AE)
	o: 841(t), 873(f)

nname: 817
n 817(None)[]:
	i: 794(f)
	o: 819(AE)

nname: 804
n 804(None)[nextchar = ''
]:
	i: 794(t)
	o: 819()

nname: 794
n 794(<dummy_ex3> EXC_MATCH IndexError)[]:
	i: 688(except)
	o: 804(t), 817(f)

nname: 790
n 790(None)[]:
	i: 746(JA), 785(), 789()
	o: 819()

nname: 789
n 789(None)[]:
	i: 691(f)
	o: 790()

nname: 785
n 785(None)[]:
	i: 713(f)
	o: 790()

nname: 746
n 746(None)[end = _w(s, end + 1).end()
nextchar = s[end]
]:
	i: 713(t)
	o: 790(JA)

nname: 713
n 713(nextchar in _ws)[end += 1
nextchar = s[end]
]:
	i: 691(t)
	o: 746(t), 785(f)

nname: 691
n 691(nextchar in _ws)[nextchar = s[end]
]:
	i: 688(try)
	o: 713(t), 789(f)

nname: 688
n 688(None)[]:
	i: 637(), 655(), 687()
	o: 691(try), 794(except)

nname: 687
n 687(None)[]:
	i: 642(f)
	o: 688()

nname: 655
n 655(None)[raise ValueError(errmsg('Expecting , delimiter', s, end - 1))
]:
	i: 642(t)
	o: 688()

nname: 642
n 642(nextchar != ',')[]:
	i: 615(f)
	o: 655(t), 687(f)

nname: 637
n 637(None)[break
]:
	i: 615(t)
	o: 688()

nname: 615
n 615(nextchar == '}')[end += 1
]:
	i: 586(), 600(), 613(AE)
	o: 637(t), 642(f)

nname: 613
n 613(None)[]:
	i: 590(f)
	o: 615(AE)

nname: 600
n 600(None)[nextchar = ''
]:
	i: 590(t)
	o: 615()

nname: 590
n 590(<dummy_ex3> EXC_MATCH IndexError)[]:
	i: 511(except)
	o: 600(t), 613(f)

nname: 586
n 586(None)[]:
	i: 546(), 585()
	o: 615()

nname: 585
n 585(None)[]:
	i: 524(f)
	o: 586()

nname: 546
n 546(None)[end = _w(s, end + 1).end()
nextchar = s[end]
]:
	i: 524(t)
	o: 586()

nname: 524
n 524(nextchar in _ws)[nextchar = s[end]
]:
	i: 511(try)
	o: 546(t), 585(f)

nname: 511
n 511(None)[pairs[key] = value
]:
	i: 443(), 478(), 509(AE)
	o: 524(try), 590(except)

nname: 509
n 509(None)[]:
	i: 468(f)
	o: 511(AE)

nname: 478
n 478(None)[raise ValueError(errmsg('Expecting object', s, end))
]:
	i: 468(t)
	o: 511()

nname: 468
n 468(<dummy_ex3> EXC_MATCH StopIteration)[]:
	i: 440(except)
	o: 478(t), 509(f)

nname: 443
n 443(None)[value, end = scan_once(s, end)
]:
	i: 440(try)
	o: 511()

nname: 440
n 440(None)[]:
	i: 417(), 431(), 438(AE)
	o: 443(try), 468(except)

nname: 438
n 438(None)[]:
	i: 421(f)
	o: 440(AE)

nname: 431
n 431(None)[]:
	i: 421(t)
	o: 440()

nname: 421
n 421(<dummy_ex3> EXC_MATCH IndexError)[]:
	i: 327(except)
	o: 431(t), 438(f)

nname: 417
n 417(None)[]:
	i: 383(JA), 412(), 416()
	o: 440()

nname: 416
n 416(None)[]:
	i: 340(f)
	o: 417()

nname: 412
n 412(None)[]:
	i: 356(f)
	o: 417()

nname: 383
n 383(None)[end = _w(s, end + 1).end()
]:
	i: 356(t)
	o: 417(JA)

nname: 356
n 356(s[end] in _ws)[end += 1
]:
	i: 340(t)
	o: 383(t), 412(f)

nname: 340
n 340(s[end] in _ws)[]:
	i: 327(try)
	o: 356(t), 416(f)

nname: 327
n 327(None)[end += 1
]:
	i: 294(JA), 322(), 326()
	o: 340(try), 421(except)

nname: 326
n 326(None)[]:
	i: 198(f)
	o: 327()

nname: 322
n 322(None)[]:
	i: 249(f)
	o: 327()

nname: 294
n 294(None)[raise ValueError(errmsg('Expecting : delimiter', s, end))
]:
	i: 249(t)
	o: 327(JA)

nname: 249
n 249(s[end:end + 1] != ':')[end = _w(s, end).end()
]:
	i: 198(t)
	o: 294(t), 322(f)

nname: 198
n 198(s[end:end + 1] != ':')[key, end = scanstring(s, end, encoding, strict)
]:
	i: 192(t)
	o: 249(t), 326(f)

nname: 192
n 192(True)[]:
	i: 179(loop)
	o: 198(t), 877(f)

nname: 179
n 179(None)[end += 1
]:
	i: 115(JA), 146(JA), 174(), 178()
	o: 192(loop), 879(AL)

nname: 178
n 178(None)[]:
	i: 0(f)
	o: 179()

nname: 174
n 174(None)[]:
	i: 133(f)
	o: 179()

nname: 146
n 146(None)[raise ValueError(errmsg('Expecting property name', s, end))
]:
	i: 133(t)
	o: 179(JA)

nname: 133
n 133(nextchar != '"')[]:
	i: 103(f)
	o: 146(t), 174(f)

nname: 115
n 115(None)[return (pairs, end + 1)
]:
	i: 103(t)
	o: 179(JA)

nname: 103
n 103(nextchar == '}')[]:
	i: 60(), 102()
	o: 115(t), 133(f)

nname: 102
n 102(None)[]:
	i: 47(f)
	o: 103()

nname: 60
n 60(None)[end = _w(s, end).end()
nextchar = s[end:end + 1]
]:
	i: 47(t)
	o: 103()

nname: 47
n 47(nextchar in _ws)[]:
	i: 0(t)
	o: 60(t), 102(f)

nname: 0
n 0(nextchar != '"')[for s, end in .0:
pairs = {}
nextchar = s[end:end + 1]
]:
	i: 
	o: 47(t), 178(f)

nname: 879
n 879(None)[if object_hook is not None:
	pairs = object_hook(pairs)
return (pairs, end)
]:
	i: 179(AL), 192(f), 790(f)
	o: 

nname: 790
n 790(None)[else:
	pass
end += 1
if nextchar != '"':
	raise ValueError(errmsg('Expecting property name', s, end - 1))
	continue
]:
	i: 691()
	o: 879()

nname: 691
n 691(None)[try:
	nextchar = s[end]
	if nextchar in _ws:
		end += 1
		nextchar = s[end]
		if nextchar in _ws:
			end = _w(s, end + 1).end()
			nextchar = s[end]
except IndexError:
	nextchar = ''
]:
	i: 615(try)
	o: 790()

nname: 615
n 615(None)[end += 1
if nextchar == '}':
	break
else:
	if nextchar != ',':
		raise ValueError(errmsg('Expecting , delimiter', s, end - 1))
]:
	i: 590(), 511()
	o: 691(try)

nname: 590
n 590(None)[except IndexError:
	nextchar = ''
]:
	i: 511()
	o: 615()

nname: 615
n 615(None)[end += 1
if nextchar == '}':
	break
else:
	if nextchar != ',':
		raise ValueError(errmsg('Expecting , delimiter', s, end - 1))
]:
	i: 590(), 511()
	o: 691(try)

nname: 511
n 511(None)[pairs[key] = value
try:
	nextchar = s[end]
	if nextchar in _ws:
		end = _w(s, end + 1).end()
		nextchar = s[end]
]:
	i: 443()
	o: 615(), 590()

nname: 443
n 443(None)[try:
	value, end = scan_once(s, end)
except StopIteration:
	raise ValueError(errmsg('Expecting object', s, end))
]:
	i: 417(try)
	o: 511()

nname: 417
n 417(None)[else:
	pass
]:
	i: 340()
	o: 443(try)

nname: 340
n 340(None)[try:
	if s[end] in _ws:
		end += 1
		if s[end] in _ws:
			end = _w(s, end + 1).end()
except IndexError:
	pass
]:
	i: 198(try)
	o: 417()

nname: 198
n 198(None)[key, end = scanstring(s, end, encoding, strict)
if s[end:end + 1] != ':':
	end = _w(s, end).end()
	if s[end:end + 1] != ':':
		raise ValueError(errmsg('Expecting : delimiter', s, end))
end += 1
]:
	i: 192(t)
	o: 340(try)

nname: 192
n 192(True)[]:
	i: 179(loop)
	o: 198(t), 879(f)

nname: 179
n 179(None)[end += 1
]:
	i: 47(JA), 0(f)
	o: 192(loop), 879(AL)

nname: 47
n 47(None)[if nextchar in _ws:
	end = _w(s, end).end()
	nextchar = s[end:end + 1]
if nextchar == '}':
	return (pairs, end + 1)
else:
	if nextchar != '"':
		raise ValueError(errmsg('Expecting property name', s, end))
]:
	i: 0(t)
	o: 179(JA)

nname: 0
n 0(nextchar != '"')[for s, end in .0:
pairs = {}
nextchar = s[end:end + 1]
]:
	i: 
	o: 47(t), 179(f)

nname: 879
n 879(None)[if object_hook is not None:
	pairs = object_hook(pairs)
return (pairs, end)
]:
	i: 0(AL), 192(f), 790(f)
	o: 

nname: 790
n 790(None)[else:
	pass
end += 1
if nextchar != '"':
	raise ValueError(errmsg('Expecting property name', s, end - 1))
	continue
]:
	i: 615()
	o: 879()

nname: 615
n 615(None)[end += 1
if nextchar == '}':
	break
else:
	if nextchar != ',':
		raise ValueError(errmsg('Expecting , delimiter', s, end - 1))
try:
	nextchar = s[end]
	if nextchar in _ws:
		end += 1
		nextchar = s[end]
		if nextchar in _ws:
			end = _w(s, end + 1).end()
			nextchar = s[end]
except IndexError:
	nextchar = ''
]:
	i: 590(), 511()
	o: 790()

nname: 590
n 590(None)[except IndexError:
	nextchar = ''
]:
	i: 511()
	o: 615()

nname: 615
n 615(None)[end += 1
if nextchar == '}':
	break
else:
	if nextchar != ',':
		raise ValueError(errmsg('Expecting , delimiter', s, end - 1))
try:
	nextchar = s[end]
	if nextchar in _ws:
		end += 1
		nextchar = s[end]
		if nextchar in _ws:
			end = _w(s, end + 1).end()
			nextchar = s[end]
except IndexError:
	nextchar = ''
]:
	i: 590(), 511()
	o: 790()

nname: 511
n 511(None)[pairs[key] = value
try:
	nextchar = s[end]
	if nextchar in _ws:
		end = _w(s, end + 1).end()
		nextchar = s[end]
]:
	i: 417()
	o: 615(), 590()

nname: 417
n 417(None)[else:
	pass
try:
	value, end = scan_once(s, end)
except StopIteration:
	raise ValueError(errmsg('Expecting object', s, end))
]:
	i: 198()
	o: 511()

nname: 198
n 198(None)[key, end = scanstring(s, end, encoding, strict)
if s[end:end + 1] != ':':
	end = _w(s, end).end()
	if s[end:end + 1] != ':':
		raise ValueError(errmsg('Expecting : delimiter', s, end))
end += 1
try:
	if s[end] in _ws:
		end += 1
		if s[end] in _ws:
			end = _w(s, end + 1).end()
except IndexError:
	pass
]:
	i: 192(t)
	o: 417()

nname: 192
n 192(True)[]:
	i: 0(loop)
	o: 198(t), 879(f)

nname: 0
n 0(None)[for s, end in .0:
pairs = {}
nextchar = s[end:end + 1]
if nextchar != '"':
	if nextchar in _ws:
		end = _w(s, end).end()
		nextchar = s[end:end + 1]
	if nextchar == '}':
		return (pairs, end + 1)
	else:
		if nextchar != '"':
			raise ValueError(errmsg('Expecting property name', s, end))
end += 1
]:
	i: 
	o: 192(loop), 879(AL)

nname: 879
n 879(None)[if object_hook is not None:
	pairs = object_hook(pairs)
return (pairs, end)
]:
	i: 0(AL), 192(f), 615(f)
	o: 

nname: 615
n 615(None)[end += 1
if nextchar == '}':
	break
else:
	if nextchar != ',':
		raise ValueError(errmsg('Expecting , delimiter', s, end - 1))
try:
	nextchar = s[end]
	if nextchar in _ws:
		end += 1
		nextchar = s[end]
		if nextchar in _ws:
			end = _w(s, end + 1).end()
			nextchar = s[end]
except IndexError:
	nextchar = ''
else:
	pass
end += 1
if nextchar != '"':
	raise ValueError(errmsg('Expecting property name', s, end - 1))
	continue
]:
	i: 590(), 511()
	o: 879()

nname: 590
n 590(None)[except IndexError:
	nextchar = ''
]:
	i: 511()
	o: 615()

nname: 615
n 615(None)[end += 1
if nextchar == '}':
	break
else:
	if nextchar != ',':
		raise ValueError(errmsg('Expecting , delimiter', s, end - 1))
try:
	nextchar = s[end]
	if nextchar in _ws:
		end += 1
		nextchar = s[end]
		if nextchar in _ws:
			end = _w(s, end + 1).end()
			nextchar = s[end]
except IndexError:
	nextchar = ''
else:
	pass
end += 1
if nextchar != '"':
	raise ValueError(errmsg('Expecting property name', s, end - 1))
	continue
]:
	i: 590(), 511()
	o: 879()

nname: 511
n 511(None)[pairs[key] = value
try:
	nextchar = s[end]
	if nextchar in _ws:
		end = _w(s, end + 1).end()
		nextchar = s[end]
]:
	i: 198()
	o: 615(), 590()

nname: 198
n 198(None)[key, end = scanstring(s, end, encoding, strict)
if s[end:end + 1] != ':':
	end = _w(s, end).end()
	if s[end:end + 1] != ':':
		raise ValueError(errmsg('Expecting : delimiter', s, end))
end += 1
try:
	if s[end] in _ws:
		end += 1
		if s[end] in _ws:
			end = _w(s, end + 1).end()
except IndexError:
	pass
else:
	pass
try:
	value, end = scan_once(s, end)
except StopIteration:
	raise ValueError(errmsg('Expecting object', s, end))
]:
	i: 192(t)
	o: 511()

nname: 192
n 192(True)[]:
	i: 0(loop)
	o: 198(t), 879(f)

nname: 0
n 0(None)[for s, end in .0:
pairs = {}
nextchar = s[end:end + 1]
if nextchar != '"':
	if nextchar in _ws:
		end = _w(s, end).end()
		nextchar = s[end:end + 1]
	if nextchar == '}':
		return (pairs, end + 1)
	else:
		if nextchar != '"':
			raise ValueError(errmsg('Expecting property name', s, end))
end += 1
]:
	i: 
	o: 192(loop), 879(AL)

nname: 879
n 879(None)[if object_hook is not None:
	pairs = object_hook(pairs)
return (pairs, end)
]:
	i: 0(AL), 192(f), 615(f)
	o: 

nname: 615
n 615(None)[end += 1
if nextchar == '}':
	break
else:
	if nextchar != ',':
		raise ValueError(errmsg('Expecting , delimiter', s, end - 1))
try:
	nextchar = s[end]
	if nextchar in _ws:
		end += 1
		nextchar = s[end]
		if nextchar in _ws:
			end = _w(s, end + 1).end()
			nextchar = s[end]
except IndexError:
	nextchar = ''
else:
	pass
end += 1
if nextchar != '"':
	raise ValueError(errmsg('Expecting property name', s, end - 1))
	continue
]:
	i: 590(), 198()
	o: 879()

nname: 590
n 590(None)[except IndexError:
	nextchar = ''
]:
	i: 198()
	o: 615()

nname: 615
n 615(None)[end += 1
if nextchar == '}':
	break
else:
	if nextchar != ',':
		raise ValueError(errmsg('Expecting , delimiter', s, end - 1))
try:
	nextchar = s[end]
	if nextchar in _ws:
		end += 1
		nextchar = s[end]
		if nextchar in _ws:
			end = _w(s, end + 1).end()
			nextchar = s[end]
except IndexError:
	nextchar = ''
else:
	pass
end += 1
if nextchar != '"':
	raise ValueError(errmsg('Expecting property name', s, end - 1))
	continue
]:
	i: 590(), 198()
	o: 879()

nname: 198
n 198(None)[key, end = scanstring(s, end, encoding, strict)
if s[end:end + 1] != ':':
	end = _w(s, end).end()
	if s[end:end + 1] != ':':
		raise ValueError(errmsg('Expecting : delimiter', s, end))
end += 1
try:
	if s[end] in _ws:
		end += 1
		if s[end] in _ws:
			end = _w(s, end + 1).end()
except IndexError:
	pass
else:
	pass
try:
	value, end = scan_once(s, end)
except StopIteration:
	raise ValueError(errmsg('Expecting object', s, end))
pairs[key] = value
try:
	nextchar = s[end]
	if nextchar in _ws:
		end = _w(s, end + 1).end()
		nextchar = s[end]
]:
	i: 192(t)
	o: 615(), 590()

nname: 192
n 192(True)[]:
	i: 0(loop)
	o: 198(t), 879(f)

nname: 0
n 0(None)[for s, end in .0:
pairs = {}
nextchar = s[end:end + 1]
if nextchar != '"':
	if nextchar in _ws:
		end = _w(s, end).end()
		nextchar = s[end:end + 1]
	if nextchar == '}':
		return (pairs, end + 1)
	else:
		if nextchar != '"':
			raise ValueError(errmsg('Expecting property name', s, end))
end += 1
]:
	i: 
	o: 192(loop), 879(AL)

self.nodes: {0: <unpyclib.structure.node instance at 0x9ef760c>, 879: <unpyclib.structure.node instance at 0x9ef7f0c>, 198: <unpyclib.structure.node instance at 0x9ef7eec>, 192: <unpyclib.structure.node instance at 0x9eec52c>, 590: <unpyclib.structure.node instance at 0x9ef75ac>, 615: <unpyclib.structure.node instance at 0x9ef7a8c>}
nname: 478
n 478(None)[return (values, end)
]:
	i: 125(AL), 476()
	o: 

nname: 476
n 476(None)[]:
	i: 137(f), 473()
	o: 478()

nname: 473
n 473(None)[]:
	i: 471(AE)
	o: 476()

nname: 471
n 471(None)[]:
	i: 454(f), 464()
	o: 473(AE)

nname: 464
n 464(None)[continue
]:
	i: 454(t)
	o: 471()

nname: 454
n 454(<dummy_ex3> EXC_MATCH IndexError)[]:
	i: 370(except), 450()
	o: 464(t), 471(f)

nname: 450
n 450(None)[continue
]:
	i: 416(JA), 445(), 449()
	o: 454()

nname: 449
n 449(None)[]:
	i: 373(f)
	o: 450()

nname: 445
n 445(None)[]:
	i: 389(f)
	o: 450()

nname: 416
n 416(None)[end = _w(s, end + 1).end()
]:
	i: 389(t)
	o: 450(JA)

nname: 389
n 389(s[end] in _ws)[end += 1
]:
	i: 373(t)
	o: 416(t), 445(f)

nname: 373
n 373(s[end] in _ws)[]:
	i: 370(try)
	o: 389(t), 449(f)

nname: 370
n 370(None)[]:
	i: 323(), 341(), 369()
	o: 373(try), 454(except)

nname: 369
n 369(None)[]:
	i: 328(f)
	o: 370()

nname: 341
n 341(None)[raise ValueError(errmsg('Expecting , delimiter', s, end))
]:
	i: 328(t)
	o: 370()

nname: 328
n 328(nextchar != ',')[]:
	i: 301(f)
	o: 341(t), 369(f)

nname: 323
n 323(None)[break
]:
	i: 301(t)
	o: 370()

nname: 301
n 301(nextchar == ']')[end += 1
]:
	i: 254(), 300()
	o: 323(t), 328(f)

nname: 300
n 300(None)[]:
	i: 215(f)
	o: 301()

nname: 254
n 254(None)[end = _w(s, end + 1).end()
nextchar = s[end:end + 1]
]:
	i: 215(t)
	o: 301()

nname: 215
n 215(nextchar in _ws)[_append(value)
nextchar = s[end:end + 1]
]:
	i: 147(), 182(), 213(AE)
	o: 254(t), 300(f)

nname: 213
n 213(None)[]:
	i: 172(f)
	o: 215(AE)

nname: 182
n 182(None)[raise ValueError(errmsg('Expecting object', s, end))
]:
	i: 172(t)
	o: 215()

nname: 172
n 172(<dummy_ex3> EXC_MATCH StopIteration)[]:
	i: 143(except)
	o: 182(t), 213(f)

nname: 147
n 147(None)[value, end = scan_once(s, end)
]:
	i: 143(try)
	o: 215()

nname: 143
n 143(None)[]:
	i: 137(t)
	o: 147(try), 172(except)

nname: 137
n 137(True)[]:
	i: 125(loop)
	o: 143(t), 476(f)

nname: 125
n 125(None)[_append = values.append
]:
	i: 106(), 124()
	o: 137(loop), 478(AL)

nname: 124
n 124(None)[]:
	i: 94(f)
	o: 125()

nname: 106
n 106(None)[return (values, end + 1)
]:
	i: 94(t)
	o: 125()

nname: 94
n 94(nextchar == ']')[]:
	i: 47(), 93()
	o: 106(t), 124(f)

nname: 93
n 93(None)[]:
	i: 0(f)
	o: 94()

nname: 47
n 47(None)[end = _w(s, end + 1).end()
nextchar = s[end:end + 1]
]:
	i: 0(t)
	o: 94()

nname: 0
n 0(nextchar in _ws)[for s, end in .0:
values = []
nextchar = s[end:end + 1]
]:
	i: 
	o: 47(t), 93(f)

nname: 478
n 478(None)[return (values, end)
]:
	i: 125(AL), 137(f), 454(AE)
	o: 

nname: 454
n 454(None)[except IndexError:
	continue
]:
	i: 301(except), 373()
	o: 478(AE)

nname: 373
n 373(None)[if s[end] in _ws:
	end += 1
	if s[end] in _ws:
		end = _w(s, end + 1).end()
continue
]:
	i: 301(try)
	o: 454()

nname: 301
n 301(None)[end += 1
if nextchar == ']':
	break
else:
	if nextchar != ',':
		raise ValueError(errmsg('Expecting , delimiter', s, end))
]:
	i: 172()
	o: 373(try), 454(except)

nname: 172
n 172(None)[except StopIteration:
	raise ValueError(errmsg('Expecting object', s, end))
_append(value)
nextchar = s[end:end + 1]
if nextchar in _ws:
	end = _w(s, end + 1).end()
	nextchar = s[end:end + 1]
]:
	i: 143()
	o: 301()

nname: 143
n 143(None)[try:
	value, end = scan_once(s, end)
]:
	i: 137(t)
	o: 172()

nname: 137
n 137(True)[]:
	i: 125(loop)
	o: 143(t), 478(f)

nname: 125
n 125(None)[_append = values.append
]:
	i: 0()
	o: 137(loop), 478(AL)

nname: 0
n 0(None)[for s, end in .0:
values = []
nextchar = s[end:end + 1]
if nextchar in _ws:
	end = _w(s, end + 1).end()
	nextchar = s[end:end + 1]
if nextchar == ']':
	return (values, end + 1)
]:
	i: 
	o: 125()

nname: 478
n 478(None)[return (values, end)
]:
	i: 0(AL), 137(f), 454(AE)
	o: 

nname: 454
n 454(None)[except IndexError:
	continue
]:
	i: 301(except), 373()
	o: 478(AE)

nname: 373
n 373(None)[if s[end] in _ws:
	end += 1
	if s[end] in _ws:
		end = _w(s, end + 1).end()
continue
]:
	i: 301(try)
	o: 454()

nname: 301
n 301(None)[end += 1
if nextchar == ']':
	break
else:
	if nextchar != ',':
		raise ValueError(errmsg('Expecting , delimiter', s, end))
]:
	i: 143()
	o: 373(try), 454(except)

nname: 143
n 143(None)[try:
	value, end = scan_once(s, end)
except StopIteration:
	raise ValueError(errmsg('Expecting object', s, end))
_append(value)
nextchar = s[end:end + 1]
if nextchar in _ws:
	end = _w(s, end + 1).end()
	nextchar = s[end:end + 1]
]:
	i: 137(t)
	o: 301()

nname: 137
n 137(True)[]:
	i: 0(loop)
	o: 143(t), 478(f)

nname: 0
n 0(None)[for s, end in .0:
values = []
nextchar = s[end:end + 1]
if nextchar in _ws:
	end = _w(s, end + 1).end()
	nextchar = s[end:end + 1]
if nextchar == ']':
	return (values, end + 1)
_append = values.append
]:
	i: 
	o: 137(loop), 478(AL)

nname: 478
n 478(None)[return (values, end)
]:
	i: 0(AL), 137(f), 454(AE)
	o: 

nname: 454
n 454(None)[except IndexError:
	continue
]:
	i: 143(except), 373()
	o: 478(AE)

nname: 373
n 373(None)[if s[end] in _ws:
	end += 1
	if s[end] in _ws:
		end = _w(s, end + 1).end()
continue
]:
	i: 143(try)
	o: 454()

nname: 143
n 143(None)[try:
	value, end = scan_once(s, end)
except StopIteration:
	raise ValueError(errmsg('Expecting object', s, end))
_append(value)
nextchar = s[end:end + 1]
if nextchar in _ws:
	end = _w(s, end + 1).end()
	nextchar = s[end:end + 1]
end += 1
if nextchar == ']':
	break
else:
	if nextchar != ',':
		raise ValueError(errmsg('Expecting , delimiter', s, end))
]:
	i: 137(t)
	o: 373(try), 454(except)

nname: 137
n 137(True)[]:
	i: 0(loop)
	o: 143(t), 478(f)

nname: 0
n 0(None)[for s, end in .0:
values = []
nextchar = s[end:end + 1]
if nextchar in _ws:
	end = _w(s, end + 1).end()
	nextchar = s[end:end + 1]
if nextchar == ']':
	return (values, end + 1)
_append = values.append
]:
	i: 
	o: 137(loop), 478(AL)

self.nodes: {0: <unpyclib.structure.node instance at 0xb776c5ec>, 137: <unpyclib.structure.node instance at 0x9efffcc>, 143: <unpyclib.structure.node instance at 0xb776c62c>, 478: <unpyclib.structure.node instance at 0x9eff6cc>, 454: <unpyclib.structure.node instance at 0xb776c38c>, 373: <unpyclib.structure.node instance at 0xb776c16c>}
nname: 63
n 63(None)[self.parse_constant = parse_constant
self.strict = strict
self.parse_object = JSONObject
self.parse_array = JSONArray
self.parse_string = scanstring
self.scan_once = make_scanner(self)
]:
	i: 44(t), 56()
	o: 

nname: 56
n 56(None)[]:
	i: 44(f)
	o: 63()

nname: 44
n 44(parse_constant)[self.parse_int = parse_int
]:
	i: 28(t), 40()
	o: 56(f), 63(t)

nname: 40
n 40(None)[]:
	i: 28(f)
	o: 44()

nname: 28
n 28(parse_int)[self.parse_float = parse_float
]:
	i: 0(t), 24()
	o: 40(f), 44(t)

nname: 24
n 24(None)[]:
	i: 0(f)
	o: 28()

nname: 0
n 0(parse_float)[self.encoding = encoding
self.object_hook = object_hook
]:
	i: 
	o: 24(f), 28(t)

nname: 44
n 44(None)[self.parse_int = parse_int
if not parse_constant:
	pass
self.parse_constant = parse_constant
self.strict = strict
self.parse_object = JSONObject
self.parse_array = JSONArray
self.parse_string = scanstring
self.scan_once = make_scanner(self)
]:
	i: 0(t)
	o: 

nname: 0
n 0(None)[self.encoding = encoding
self.object_hook = object_hook
if not parse_float:
	pass
self.parse_float = parse_float
if not parse_int:
	pass
]:
	i: 
	o: 44()

nname: 0
n 0(None)[self.encoding = encoding
self.object_hook = object_hook
if not parse_float:
	pass
self.parse_float = parse_float
if not parse_int:
	pass
self.parse_int = parse_int
if not parse_constant:
	pass
self.parse_constant = parse_constant
self.strict = strict
self.parse_object = JSONObject
self.parse_array = JSONArray
self.parse_string = scanstring
self.scan_once = make_scanner(self)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7764eac>}
nname: 119
n 119(None)[return obj
]:
	i: 81(), 118()
	o: 

nname: 118
n 118(None)[]:
	i: 0(f)
	o: 119()

nname: 81
n 81(None)[raise ValueError(errmsg('Extra data', s, end, len(s)))
]:
	i: 0(t)
	o: 119()

nname: 0
n 0(end != len(s))[obj, end = self.raw_decode(s, idx=_w(s, 0).end())
end = _w(s, end).end()
]:
	i: 
	o: 81(t), 118(f)

nname: 0
n 0(None)[obj, end = self.raw_decode(s, idx=_w(s, 0).end())
end = _w(s, end).end()
if end != len(s):
	raise ValueError(errmsg('Extra data', s, end, len(s)))
return obj
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7764d0c>}
nname: 62
n 62(None)[return (obj, end)
]:
	i: 3(), 41(), 60(AE)
	o: 

nname: 60
n 60(None)[]:
	i: 31(f)
	o: 62(AE)

nname: 41
n 41(None)[raise ValueError('No JSON object could be decoded')
]:
	i: 31(t)
	o: 62()

nname: 31
n 31(<dummy_ex3> EXC_MATCH StopIteration)[]:
	i: 0(except)
	o: 41(t), 60(f)

nname: 3
n 3(None)[obj, end = self.scan_once(s, idx)
]:
	i: 0(try)
	o: 62()

nname: 0
n 0(None)[]:
	i: 
	o: 3(try), 31(except)

nname: 31
n 31(None)[except StopIteration:
	raise ValueError('No JSON object could be decoded')
return (obj, end)
]:
	i: 0()
	o: 

nname: 0
n 0(None)[try:
	obj, end = self.scan_once(s, idx)
]:
	i: 
	o: 31()

nname: 0
n 0(None)[try:
	obj, end = self.scan_once(s, idx)
except StopIteration:
	raise ValueError('No JSON object could be decoded')
return (obj, end)
]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7764cec>}
nname: 6
n 6(None)[__doc__ = 'Simple JSON <http://json.org> decoder\n\n    Performs the following translations in decoding by default:\n\n    +---------------+-------------------+\n    | JSON          | Python            |\n    +===============+===================+\n    | object        | dict              |\n    +---------------+-------------------+\n    | array         | list              |\n    +---------------+-------------------+\n    | string        | unicode           |\n    +---------------+-------------------+\n    | number (int)  | int, long         |\n    +---------------+-------------------+\n    | number (real) | float             |\n    +---------------+-------------------+\n    | true          | True              |\n    +---------------+-------------------+\n    | false         | False             |\n    +---------------+-------------------+\n    | null          | None              |\n    +---------------+-------------------+\n\n    It also understands ``NaN``, ``Infinity``, and ``-Infinity`` as\n    their corresponding ``float`` values, which is outside the JSON spec.\n\n    '
def __init__(self, encoding=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, strict=True):
	self.encoding = encoding
	self.object_hook = object_hook
	if not parse_float:
		pass
	self.parse_float = parse_float
	if not parse_int:
		pass
	self.parse_int = parse_int
	if not parse_constant:
		pass
	self.parse_constant = parse_constant
	self.strict = strict
	self.parse_object = JSONObject
	self.parse_array = JSONArray
	self.parse_string = scanstring
	self.scan_once = make_scanner(self)

def decode(self, s, _w=WHITESPACE.match):
	obj, end = self.raw_decode(s, idx=_w(s, 0).end())
	end = _w(s, end).end()
	if end != len(s):
		raise ValueError(errmsg('Extra data', s, end, len(s)))
	return obj

def raw_decode(self, s, idx=0):
	try:
		obj, end = self.scan_once(s, idx)
	except StopIteration:
		raise ValueError('No JSON object could be decoded')
	return (obj, end)

]:
	i: 
	o: 

self.nodes: {6: <unpyclib.structure.node instance at 0xb776ae4c>}
nname: 355
n 355(None)[scanstring = c_scanstring
WHITESPACE = re.compile('[ \\t\\n\\r]*', FLAGS)
WHITESPACE_STR = ' \t\n\r'
def JSONObject(.0, encoding, strict, scan_once, object_hook, _w=WHITESPACE.match, _ws=WHITESPACE_STR):
	for s, end in .0:
	pairs = {}
	nextchar = s[end:end + 1]
	if nextchar != '"':
		if nextchar in _ws:
			end = _w(s, end).end()
			nextchar = s[end:end + 1]
		if nextchar == '}':
			return (pairs, end + 1)
		else:
			if nextchar != '"':
				raise ValueError(errmsg('Expecting property name', s, end))
	end += 1

def JSONArray(.0, scan_once, _w=WHITESPACE.match, _ws=WHITESPACE_STR):
	for s, end in .0:
	values = []
	nextchar = s[end:end + 1]
	if nextchar in _ws:
		end = _w(s, end + 1).end()
		nextchar = s[end:end + 1]
	if nextchar == ']':
		return (values, end + 1)
	_append = values.append

class JSONDecoder(object):
	__doc__ = 'Simple JSON <http://json.org> decoder\n\n    Performs the following translations in decoding by default:\n\n    +---------------+-------------------+\n    | JSON          | Python            |\n    +===============+===================+\n    | object        | dict              |\n    +---------------+-------------------+\n    | array         | list              |\n    +---------------+-------------------+\n    | string        | unicode           |\n    +---------------+-------------------+\n    | number (int)  | int, long         |\n    +---------------+-------------------+\n    | number (real) | float             |\n    +---------------+-------------------+\n    | true          | True              |\n    +---------------+-------------------+\n    | false         | False             |\n    +---------------+-------------------+\n    | null          | None              |\n    +---------------+-------------------+\n\n    It also understands ``NaN``, ``Infinity``, and ``-Infinity`` as\n    their corresponding ``float`` values, which is outside the JSON spec.\n\n    '
	def __init__(self, encoding=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, strict=True):
		self.encoding = encoding
		self.object_hook = object_hook
		if not parse_float:
			pass
		self.parse_float = parse_float
		if not parse_int:
			pass
		self.parse_int = parse_int
		if not parse_constant:
			pass
		self.parse_constant = parse_constant
		self.strict = strict
		self.parse_object = JSONObject
		self.parse_array = JSONArray
		self.parse_string = scanstring
		self.scan_once = make_scanner(self)

	def decode(self, s, _w=WHITESPACE.match):
		obj, end = self.raw_decode(s, idx=_w(s, 0).end())
		end = _w(s, end).end()
		if end != len(s):
			raise ValueError(errmsg('Extra data', s, end, len(s)))
		return obj

	def raw_decode(self, s, idx=0):
		try:
			obj, end = self.scan_once(s, idx)
		except StopIteration:
			raise ValueError('No JSON object could be decoded')
		return (obj, end)



]:
	i: 106(t), 351()
	o: 

nname: 351
n 351(None)[]:
	i: 106(f)
	o: 355()

nname: 106
n 106(c_scanstring)[__all__ = ['JSONDecoder']
FLAGS = re.VERBOSE | re.MULTILINE | re.DOTALL
def _floatconstants():
	_BYTES = '7FF80000000000007FF0000000000000'.decode('hex')
	if sys.byteorder != 'big':
		_BYTES = _BYTES[:8][::-1] + _BYTES[8:][::-1]
	nan, inf = struct.unpack('dd', _BYTES)
	return (nan, inf, -inf)

NaN, PosInf, NegInf = _floatconstants()
def linecol(doc, pos):
	lineno = doc.count('\n', 0, pos) + 1
	if lineno == 1:
		colno = pos
	else:
		colno = pos - doc.rindex('\n', 0, pos)
	return (lineno, colno)

def errmsg(msg, doc, pos, end=None):
	lineno, colno = linecol(doc, pos)
	if end is None:
		return '%s: line %d column %d (char %d)' % (msg, lineno, colno, pos)
	endlineno, endcolno = linecol(doc, end)
	return '%s: line %d column %d - line %d column %d (char %d - %d)' % (msg, lineno, colno, endlineno, endcolno, pos, end)

_CONSTANTS = {'-Infinity': NegInf, 'Infinity': PosInf, 'NaN': NaN}
STRINGCHUNK = re.compile('(.*?)(["\\\\\\x00-\\x1f])', FLAGS)
BACKSLASH = {'"': u'"', '\\': u'\\', '/': u'/', 'b': u'\x08', 'f': u'\x0c', 'n': u'\n', 'r': u'\r', 't': u'\t'}
DEFAULT_ENCODING = 'utf-8'
def py_scanstring(s, end, encoding=None, strict=True, _b=BACKSLASH, _m=STRINGCHUNK.match):
	if encoding is None:
		encoding = DEFAULT_ENCODING
	chunks = []
	_append = chunks.append
	begin = end - 1

]:
	i: 61(), 91(), 104(AE)
	o: 351(f), 355(t)

nname: 104
n 104(None)[]:
	i: 81(f)
	o: 106(AE)

nname: 91
n 91(None)[c_scanstring = None
]:
	i: 81(t)
	o: 106()

nname: 81
n 81(<dummy_ex3> EXC_MATCH ImportError)[]:
	i: 0(except)
	o: 91(t), 104(f)

nname: 61
n 61(None)[from simplejson._speedups import scanstring as c_scanstring
]:
	i: 0(try)
	o: 106()

nname: 0
n 0(None)[__doc__ = 'Implementation of JSONDecoder\n'
import re
import sys
import struct
from simplejson.scanner import make_scanner
]:
	i: 
	o: 61(try), 81(except)

nname: 355
n 355(None)[scanstring = c_scanstring
WHITESPACE = re.compile('[ \\t\\n\\r]*', FLAGS)
WHITESPACE_STR = ' \t\n\r'
def JSONObject(.0, encoding, strict, scan_once, object_hook, _w=WHITESPACE.match, _ws=WHITESPACE_STR):
	for s, end in .0:
	pairs = {}
	nextchar = s[end:end + 1]
	if nextchar != '"':
		if nextchar in _ws:
			end = _w(s, end).end()
			nextchar = s[end:end + 1]
		if nextchar == '}':
			return (pairs, end + 1)
		else:
			if nextchar != '"':
				raise ValueError(errmsg('Expecting property name', s, end))
	end += 1

def JSONArray(.0, scan_once, _w=WHITESPACE.match, _ws=WHITESPACE_STR):
	for s, end in .0:
	values = []
	nextchar = s[end:end + 1]
	if nextchar in _ws:
		end = _w(s, end + 1).end()
		nextchar = s[end:end + 1]
	if nextchar == ']':
		return (values, end + 1)
	_append = values.append

class JSONDecoder(object):
	__doc__ = 'Simple JSON <http://json.org> decoder\n\n    Performs the following translations in decoding by default:\n\n    +---------------+-------------------+\n    | JSON          | Python            |\n    +===============+===================+\n    | object        | dict              |\n    +---------------+-------------------+\n    | array         | list              |\n    +---------------+-------------------+\n    | string        | unicode           |\n    +---------------+-------------------+\n    | number (int)  | int, long         |\n    +---------------+-------------------+\n    | number (real) | float             |\n    +---------------+-------------------+\n    | true          | True              |\n    +---------------+-------------------+\n    | false         | False             |\n    +---------------+-------------------+\n    | null          | None              |\n    +---------------+-------------------+\n\n    It also understands ``NaN``, ``Infinity``, and ``-Infinity`` as\n    their corresponding ``float`` values, which is outside the JSON spec.\n\n    '
	def __init__(self, encoding=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, strict=True):
		self.encoding = encoding
		self.object_hook = object_hook
		if not parse_float:
			pass
		self.parse_float = parse_float
		if not parse_int:
			pass
		self.parse_int = parse_int
		if not parse_constant:
			pass
		self.parse_constant = parse_constant
		self.strict = strict
		self.parse_object = JSONObject
		self.parse_array = JSONArray
		self.parse_string = scanstring
		self.scan_once = make_scanner(self)

	def decode(self, s, _w=WHITESPACE.match):
		obj, end = self.raw_decode(s, idx=_w(s, 0).end())
		end = _w(s, end).end()
		if end != len(s):
			raise ValueError(errmsg('Extra data', s, end, len(s)))
		return obj

	def raw_decode(self, s, idx=0):
		try:
			obj, end = self.scan_once(s, idx)
		except StopIteration:
			raise ValueError('No JSON object could be decoded')
		return (obj, end)



]:
	i: 81(t)
	o: 

nname: 81
n 81(None)[except ImportError:
	c_scanstring = None
__all__ = ['JSONDecoder']
FLAGS = re.VERBOSE | re.MULTILINE | re.DOTALL
def _floatconstants():
	_BYTES = '7FF80000000000007FF0000000000000'.decode('hex')
	if sys.byteorder != 'big':
		_BYTES = _BYTES[:8][::-1] + _BYTES[8:][::-1]
	nan, inf = struct.unpack('dd', _BYTES)
	return (nan, inf, -inf)

NaN, PosInf, NegInf = _floatconstants()
def linecol(doc, pos):
	lineno = doc.count('\n', 0, pos) + 1
	if lineno == 1:
		colno = pos
	else:
		colno = pos - doc.rindex('\n', 0, pos)
	return (lineno, colno)

def errmsg(msg, doc, pos, end=None):
	lineno, colno = linecol(doc, pos)
	if end is None:
		return '%s: line %d column %d (char %d)' % (msg, lineno, colno, pos)
	endlineno, endcolno = linecol(doc, end)
	return '%s: line %d column %d - line %d column %d (char %d - %d)' % (msg, lineno, colno, endlineno, endcolno, pos, end)

_CONSTANTS = {'-Infinity': NegInf, 'Infinity': PosInf, 'NaN': NaN}
STRINGCHUNK = re.compile('(.*?)(["\\\\\\x00-\\x1f])', FLAGS)
BACKSLASH = {'"': u'"', '\\': u'\\', '/': u'/', 'b': u'\x08', 'f': u'\x0c', 'n': u'\n', 'r': u'\r', 't': u'\t'}
DEFAULT_ENCODING = 'utf-8'
def py_scanstring(s, end, encoding=None, strict=True, _b=BACKSLASH, _m=STRINGCHUNK.match):
	if encoding is None:
		encoding = DEFAULT_ENCODING
	chunks = []
	_append = chunks.append
	begin = end - 1

if not c_scanstring:
	pass
]:
	i: 0()
	o: 355()

nname: 0
n 0(None)[__doc__ = 'Implementation of JSONDecoder\n'
import re
import sys
import struct
from simplejson.scanner import make_scanner
try:
	from simplejson._speedups import scanstring as c_scanstring
]:
	i: 
	o: 81()

nname: 355
n 355(None)[scanstring = c_scanstring
WHITESPACE = re.compile('[ \\t\\n\\r]*', FLAGS)
WHITESPACE_STR = ' \t\n\r'
def JSONObject(.0, encoding, strict, scan_once, object_hook, _w=WHITESPACE.match, _ws=WHITESPACE_STR):
	for s, end in .0:
	pairs = {}
	nextchar = s[end:end + 1]
	if nextchar != '"':
		if nextchar in _ws:
			end = _w(s, end).end()
			nextchar = s[end:end + 1]
		if nextchar == '}':
			return (pairs, end + 1)
		else:
			if nextchar != '"':
				raise ValueError(errmsg('Expecting property name', s, end))
	end += 1

def JSONArray(.0, scan_once, _w=WHITESPACE.match, _ws=WHITESPACE_STR):
	for s, end in .0:
	values = []
	nextchar = s[end:end + 1]
	if nextchar in _ws:
		end = _w(s, end + 1).end()
		nextchar = s[end:end + 1]
	if nextchar == ']':
		return (values, end + 1)
	_append = values.append

class JSONDecoder(object):
	__doc__ = 'Simple JSON <http://json.org> decoder\n\n    Performs the following translations in decoding by default:\n\n    +---------------+-------------------+\n    | JSON          | Python            |\n    +===============+===================+\n    | object        | dict              |\n    +---------------+-------------------+\n    | array         | list              |\n    +---------------+-------------------+\n    | string        | unicode           |\n    +---------------+-------------------+\n    | number (int)  | int, long         |\n    +---------------+-------------------+\n    | number (real) | float             |\n    +---------------+-------------------+\n    | true          | True              |\n    +---------------+-------------------+\n    | false         | False             |\n    +---------------+-------------------+\n    | null          | None              |\n    +---------------+-------------------+\n\n    It also understands ``NaN``, ``Infinity``, and ``-Infinity`` as\n    their corresponding ``float`` values, which is outside the JSON spec.\n\n    '
	def __init__(self, encoding=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, strict=True):
		self.encoding = encoding
		self.object_hook = object_hook
		if not parse_float:
			pass
		self.parse_float = parse_float
		if not parse_int:
			pass
		self.parse_int = parse_int
		if not parse_constant:
			pass
		self.parse_constant = parse_constant
		self.strict = strict
		self.parse_object = JSONObject
		self.parse_array = JSONArray
		self.parse_string = scanstring
		self.scan_once = make_scanner(self)

	def decode(self, s, _w=WHITESPACE.match):
		obj, end = self.raw_decode(s, idx=_w(s, 0).end())
		end = _w(s, end).end()
		if end != len(s):
			raise ValueError(errmsg('Extra data', s, end, len(s)))
		return obj

	def raw_decode(self, s, idx=0):
		try:
			obj, end = self.scan_once(s, idx)
		except StopIteration:
			raise ValueError('No JSON object could be decoded')
		return (obj, end)



]:
	i: 0(t)
	o: 

nname: 0
n 0(None)[__doc__ = 'Implementation of JSONDecoder\n'
import re
import sys
import struct
from simplejson.scanner import make_scanner
try:
	from simplejson._speedups import scanstring as c_scanstring
except ImportError:
	c_scanstring = None
__all__ = ['JSONDecoder']
FLAGS = re.VERBOSE | re.MULTILINE | re.DOTALL
def _floatconstants():
	_BYTES = '7FF80000000000007FF0000000000000'.decode('hex')
	if sys.byteorder != 'big':
		_BYTES = _BYTES[:8][::-1] + _BYTES[8:][::-1]
	nan, inf = struct.unpack('dd', _BYTES)
	return (nan, inf, -inf)

NaN, PosInf, NegInf = _floatconstants()
def linecol(doc, pos):
	lineno = doc.count('\n', 0, pos) + 1
	if lineno == 1:
		colno = pos
	else:
		colno = pos - doc.rindex('\n', 0, pos)
	return (lineno, colno)

def errmsg(msg, doc, pos, end=None):
	lineno, colno = linecol(doc, pos)
	if end is None:
		return '%s: line %d column %d (char %d)' % (msg, lineno, colno, pos)
	endlineno, endcolno = linecol(doc, end)
	return '%s: line %d column %d - line %d column %d (char %d - %d)' % (msg, lineno, colno, endlineno, endcolno, pos, end)

_CONSTANTS = {'-Infinity': NegInf, 'Infinity': PosInf, 'NaN': NaN}
STRINGCHUNK = re.compile('(.*?)(["\\\\\\x00-\\x1f])', FLAGS)
BACKSLASH = {'"': u'"', '\\': u'\\', '/': u'/', 'b': u'\x08', 'f': u'\x0c', 'n': u'\n', 'r': u'\r', 't': u'\t'}
DEFAULT_ENCODING = 'utf-8'
def py_scanstring(s, end, encoding=None, strict=True, _b=BACKSLASH, _m=STRINGCHUNK.match):
	if encoding is None:
		encoding = DEFAULT_ENCODING
	chunks = []
	_append = chunks.append
	begin = end - 1

if not c_scanstring:
	pass
]:
	i: 
	o: 355()

nname: 0
n 0(None)[__doc__ = 'Implementation of JSONDecoder\n'
import re
import sys
import struct
from simplejson.scanner import make_scanner
try:
	from simplejson._speedups import scanstring as c_scanstring
except ImportError:
	c_scanstring = None
__all__ = ['JSONDecoder']
FLAGS = re.VERBOSE | re.MULTILINE | re.DOTALL
def _floatconstants():
	_BYTES = '7FF80000000000007FF0000000000000'.decode('hex')
	if sys.byteorder != 'big':
		_BYTES = _BYTES[:8][::-1] + _BYTES[8:][::-1]
	nan, inf = struct.unpack('dd', _BYTES)
	return (nan, inf, -inf)

NaN, PosInf, NegInf = _floatconstants()
def linecol(doc, pos):
	lineno = doc.count('\n', 0, pos) + 1
	if lineno == 1:
		colno = pos
	else:
		colno = pos - doc.rindex('\n', 0, pos)
	return (lineno, colno)

def errmsg(msg, doc, pos, end=None):
	lineno, colno = linecol(doc, pos)
	if end is None:
		return '%s: line %d column %d (char %d)' % (msg, lineno, colno, pos)
	endlineno, endcolno = linecol(doc, end)
	return '%s: line %d column %d - line %d column %d (char %d - %d)' % (msg, lineno, colno, endlineno, endcolno, pos, end)

_CONSTANTS = {'-Infinity': NegInf, 'Infinity': PosInf, 'NaN': NaN}
STRINGCHUNK = re.compile('(.*?)(["\\\\\\x00-\\x1f])', FLAGS)
BACKSLASH = {'"': u'"', '\\': u'\\', '/': u'/', 'b': u'\x08', 'f': u'\x0c', 'n': u'\n', 'r': u'\r', 't': u'\t'}
DEFAULT_ENCODING = 'utf-8'
def py_scanstring(s, end, encoding=None, strict=True, _b=BACKSLASH, _m=STRINGCHUNK.match):
	if encoding is None:
		encoding = DEFAULT_ENCODING
	chunks = []
	_append = chunks.append
	begin = end - 1

if not c_scanstring:
	pass
scanstring = c_scanstring
WHITESPACE = re.compile('[ \\t\\n\\r]*', FLAGS)
WHITESPACE_STR = ' \t\n\r'
def JSONObject(.0, encoding, strict, scan_once, object_hook, _w=WHITESPACE.match, _ws=WHITESPACE_STR):
	for s, end in .0:
	pairs = {}
	nextchar = s[end:end + 1]
	if nextchar != '"':
		if nextchar in _ws:
			end = _w(s, end).end()
			nextchar = s[end:end + 1]
		if nextchar == '}':
			return (pairs, end + 1)
		else:
			if nextchar != '"':
				raise ValueError(errmsg('Expecting property name', s, end))
	end += 1

def JSONArray(.0, scan_once, _w=WHITESPACE.match, _ws=WHITESPACE_STR):
	for s, end in .0:
	values = []
	nextchar = s[end:end + 1]
	if nextchar in _ws:
		end = _w(s, end + 1).end()
		nextchar = s[end:end + 1]
	if nextchar == ']':
		return (values, end + 1)
	_append = values.append

class JSONDecoder(object):
	__doc__ = 'Simple JSON <http://json.org> decoder\n\n    Performs the following translations in decoding by default:\n\n    +---------------+-------------------+\n    | JSON          | Python            |\n    +===============+===================+\n    | object        | dict              |\n    +---------------+-------------------+\n    | array         | list              |\n    +---------------+-------------------+\n    | string        | unicode           |\n    +---------------+-------------------+\n    | number (int)  | int, long         |\n    +---------------+-------------------+\n    | number (real) | float             |\n    +---------------+-------------------+\n    | true          | True              |\n    +---------------+-------------------+\n    | false         | False             |\n    +---------------+-------------------+\n    | null          | None              |\n    +---------------+-------------------+\n\n    It also understands ``NaN``, ``Infinity``, and ``-Infinity`` as\n    their corresponding ``float`` values, which is outside the JSON spec.\n\n    '
	def __init__(self, encoding=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, strict=True):
		self.encoding = encoding
		self.object_hook = object_hook
		if not parse_float:
			pass
		self.parse_float = parse_float
		if not parse_int:
			pass
		self.parse_int = parse_int
		if not parse_constant:
			pass
		self.parse_constant = parse_constant
		self.strict = strict
		self.parse_object = JSONObject
		self.parse_array = JSONArray
		self.parse_string = scanstring
		self.scan_once = make_scanner(self)

	def decode(self, s, _w=WHITESPACE.match):
		obj, end = self.raw_decode(s, idx=_w(s, 0).end())
		end = _w(s, end).end()
		if end != len(s):
			raise ValueError(errmsg('Extra data', s, end, len(s)))
		return obj

	def raw_decode(self, s, idx=0):
		try:
			obj, end = self.scan_once(s, idx)
		except StopIteration:
			raise ValueError('No JSON object could be decoded')
		return (obj, end)



]:
	i: 
	o: 

self.nodes: {0: <unpyclib.structure.node instance at 0xb7753f8c>}
__doc__ = 'Implementation of JSONDecoder\n'
import re
import sys
import struct
from simplejson.scanner import make_scanner
try:
	from simplejson._speedups import scanstring as c_scanstring
except ImportError:
	c_scanstring = None
__all__ = ['JSONDecoder']
FLAGS = re.VERBOSE | re.MULTILINE | re.DOTALL
def _floatconstants():
	_BYTES = '7FF80000000000007FF0000000000000'.decode('hex')
	if sys.byteorder != 'big':
		_BYTES = _BYTES[:8][::-1] + _BYTES[8:][::-1]
	nan, inf = struct.unpack('dd', _BYTES)
	return (nan, inf, -inf)

NaN, PosInf, NegInf = _floatconstants()
def linecol(doc, pos):
	lineno = doc.count('\n', 0, pos) + 1
	if lineno == 1:
		colno = pos
	else:
		colno = pos - doc.rindex('\n', 0, pos)
	return (lineno, colno)

def errmsg(msg, doc, pos, end=None):
	lineno, colno = linecol(doc, pos)
	if end is None:
		return '%s: line %d column %d (char %d)' % (msg, lineno, colno, pos)
	endlineno, endcolno = linecol(doc, end)
	return '%s: line %d column %d - line %d column %d (char %d - %d)' % (msg, lineno, colno, endlineno, endcolno, pos, end)

_CONSTANTS = {'-Infinity': NegInf, 'Infinity': PosInf, 'NaN': NaN}
STRINGCHUNK = re.compile('(.*?)(["\\\\\\x00-\\x1f])', FLAGS)
BACKSLASH = {'"': u'"', '\\': u'\\', '/': u'/', 'b': u'\x08', 'f': u'\x0c', 'n': u'\n', 'r': u'\r', 't': u'\t'}
DEFAULT_ENCODING = 'utf-8'
def py_scanstring(s, end, encoding=None, strict=True, _b=BACKSLASH, _m=STRINGCHUNK.match):
	if encoding is None:
		encoding = DEFAULT_ENCODING
	chunks = []
	_append = chunks.append
	begin = end - 1

if not c_scanstring:
	pass
scanstring = c_scanstring
WHITESPACE = re.compile('[ \\t\\n\\r]*', FLAGS)
WHITESPACE_STR = ' \t\n\r'
def JSONObject(.0, encoding, strict, scan_once, object_hook, _w=WHITESPACE.match, _ws=WHITESPACE_STR):
	for s, end in .0:
	pairs = {}
	nextchar = s[end:end + 1]
	if nextchar != '"':
		if nextchar in _ws:
			end = _w(s, end).end()
			nextchar = s[end:end + 1]
		if nextchar == '}':
			return (pairs, end + 1)
		else:
			if nextchar != '"':
				raise ValueError(errmsg('Expecting property name', s, end))
	end += 1

def JSONArray(.0, scan_once, _w=WHITESPACE.match, _ws=WHITESPACE_STR):
	for s, end in .0:
	values = []
	nextchar = s[end:end + 1]
	if nextchar in _ws:
		end = _w(s, end + 1).end()
		nextchar = s[end:end + 1]
	if nextchar == ']':
		return (values, end + 1)
	_append = values.append

class JSONDecoder(object):
	__doc__ = 'Simple JSON <http://json.org> decoder\n\n    Performs the following translations in decoding by default:\n\n    +---------------+-------------------+\n    | JSON          | Python            |\n    +===============+===================+\n    | object        | dict              |\n    +---------------+-------------------+\n    | array         | list              |\n    +---------------+-------------------+\n    | string        | unicode           |\n    +---------------+-------------------+\n    | number (int)  | int, long         |\n    +---------------+-------------------+\n    | number (real) | float             |\n    +---------------+-------------------+\n    | true          | True              |\n    +---------------+-------------------+\n    | false         | False             |\n    +---------------+-------------------+\n    | null          | None              |\n    +---------------+-------------------+\n\n    It also understands ``NaN``, ``Infinity``, and ``-Infinity`` as\n    their corresponding ``float`` values, which is outside the JSON spec.\n\n    '
	def __init__(self, encoding=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, strict=True):
		self.encoding = encoding
		self.object_hook = object_hook
		if not parse_float:
			pass
		self.parse_float = parse_float
		if not parse_int:
			pass
		self.parse_int = parse_int
		if not parse_constant:
			pass
		self.parse_constant = parse_constant
		self.strict = strict
		self.parse_object = JSONObject
		self.parse_array = JSONArray
		self.parse_string = scanstring
		self.scan_once = make_scanner(self)

	def decode(self, s, _w=WHITESPACE.match):
		obj, end = self.raw_decode(s, idx=_w(s, 0).end())
		end = _w(s, end).end()
		if end != len(s):
			raise ValueError(errmsg('Extra data', s, end, len(s)))
		return obj

	def raw_decode(self, s, idx=0):
		try:
			obj, end = self.scan_once(s, idx)
		except StopIteration:
			raise ValueError('No JSON object could be decoded')
		return (obj, end)



